code	desc
protected final void fast path ordered emit ( u value , boolean delay error , disposable disposable ) { final observer < ? super v > observer = downstream ; final simple plain queue < u > q = queue ; if ( wip . get ( ) == num && wip . compare and set ( num , num ) ) { if ( q . is empty ( ) ) { accept ( observer , value ) ; if ( leave ( - num ) == num ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } queue drain helper . drain loop ( q , observer , delay error , disposable , this ) ; }	Makes sure the fast-path emits in order.
@ check return value @ scheduler support ( scheduler support . none ) public static < t > observable < t > wrap ( observable source < t > source ) { object helper . require non null ( source , str ) ; if ( source instanceof observable ) { return rx java plugins . on assembly ( ( observable < t > ) source ) ; } return rx java plugins . on assembly ( new observable from unsafe source < t > ( source ) ) ; }	Wraps an ObservableSource into an Observable if not already an Observable. Scheduler: {.
@ check return value @ scheduler support ( scheduler support . none ) public final observable < t > sorted ( comparator < ? super t > sort function ) { object helper . require non null ( sort function , str ) ; return to list ( ) . to observable ( ) . map ( functions . list sorter ( sort function ) ) . flat map iterable ( functions . < list < t > > identity ( ) ) ; }	Returns an Observable that emits the events emitted by source ObservableSource, in asorted order based on a specified comparison function. Note that calling {.
public static < t > connectable observable < t > observe on ( final connectable observable < t > co , final scheduler scheduler ) { final observable < t > observable = co . observe on ( scheduler ) ; return rx java plugins . on assembly ( new replay < t > ( co , observable ) ) ; }	Child Observers will observe the events of the ConnectableObservable on thespecified scheduler.
@ check return value @ non null public static < t > unicast processor < t > create ( int capacity hint ) { return new unicast processor < t > ( capacity hint ) ; }	Creates an UnicastProcessor with the given internal buffer capacity hint.
@ check return value @ non null public static < t > unicast processor < t > create ( int capacity hint , runnable on cancelled ) { object helper . require non null ( on cancelled , str ) ; return new unicast processor < t > ( capacity hint , on cancelled ) ; }	Creates an UnicastProcessor with the given internal buffer capacity hint and a callback forthe case when the single Subscriber cancels its subscription.
@ suppress warnings ( str ) public static < t , r > boolean try scalar x ( publisher < t > source , subscriber < ? super r > subscriber , function < ? super t , ? extends publisher < ? extends r > > mapper ) { if ( source instanceof callable ) { t t ; try { t = ( ( callable < t > ) source ) . call ( ) ; } catch ( throwable ex ) { exceptions . throw if fatal ( ex ) ; empty subscription . error ( ex , subscriber ) ; return bool ; } if ( t == null ) { empty subscription . complete ( subscriber ) ; return bool ; } publisher < ? extends r > r ; try { r = object helper . require non null ( mapper . apply ( t ) , str ) ; } catch ( throwable ex ) { exceptions . throw if fatal ( ex ) ; empty subscription . error ( ex , subscriber ) ; return bool ; } if ( r instanceof callable ) { r u ; try { u = ( ( callable < r > ) r ) . call ( ) ; } catch ( throwable ex ) { exceptions . throw if fatal ( ex ) ; empty subscription . error ( ex , subscriber ) ; return bool ; } if ( u == null ) { empty subscription . complete ( subscriber ) ; return bool ; } subscriber . on subscribe ( new scalar subscription < r > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return bool ; } return bool ; }	Tries to subscribe to a possibly Callable source's mapped Publisher.
public static < t , u > flowable < u > scalar x ( final t value , final function < ? super t , ? extends publisher < ? extends u > > mapper ) { return rx java plugins . on assembly ( new x < t , u > ( value , mapper ) ) ; }	Maps a scalar value into a Publisher and emits its values.
public static void reset ( ) { set error handler ( null ) ; set schedule handler ( null ) ; set computation scheduler handler ( null ) ; set init computation scheduler handler ( null ) ; set io scheduler handler ( null ) ; set init io scheduler handler ( null ) ; set single scheduler handler ( null ) ; set init single scheduler handler ( null ) ; set new thread scheduler handler ( null ) ; set init new thread scheduler handler ( null ) ; set on flowable assembly ( null ) ; set on flowable subscribe ( null ) ; set on observable assembly ( null ) ; set on observable subscribe ( null ) ; set on single assembly ( null ) ; set on single subscribe ( null ) ; set on completable assembly ( null ) ; set on completable subscribe ( null ) ; set on connectable flowable assembly ( null ) ; set on connectable observable assembly ( null ) ; set on maybe assembly ( null ) ; set on maybe subscribe ( null ) ; set on parallel assembly ( null ) ; set fail on non blocking scheduler ( bool ) ; set on before blocking ( null ) ; }	Removes all handlers and resets to default behavior.
@ check return value @ non null @ scheduler support ( scheduler support . none ) public static < t > maybe < t > from completable ( completable source completable source ) { object helper . require non null ( completable source , str ) ; return rx java plugins . on assembly ( new maybe from completable < t > ( completable source ) ) ; }	Wraps a CompletableSource into a Maybe. Scheduler: {.
@ check return value @ non null @ scheduler support ( scheduler support . none ) public static < t > maybe < t > from single ( single source < t > single source ) { object helper . require non null ( single source , str ) ; return rx java plugins . on assembly ( new maybe from single < t > ( single source ) ) ; }	Wraps a SingleSource into a Maybe. Scheduler: {.
@ check return value @ scheduler support ( scheduler support . none ) public final maybe < t > retry ( long times , predicate < ? super throwable > predicate ) { return to flowable ( ) . retry ( times , predicate ) . single element ( ) ; }	Retries at most times or until the predicate returns false, whichever happens first. Scheduler: {.
public static < t > t require non null ( t object , string message ) { if ( object == null ) { throw new null pointer exception ( message ) ; } return object ; }	Verifies if the object is not null and returns it or throws a NullPointerExceptionwith the given message.
@ suppress warnings ( str ) public static < t > function < t , t > identity ( ) { return ( function < t , t > ) identity ; }	Returns an identity function that simply returns its argument.
public static < t > callable < t > just callable ( t value ) { return new just value < object , t > ( value ) ; }	Returns a Callable that returns the given value.
public static < t , u > function < t , u > just function ( u value ) { return new just value < t , u > ( value ) ; }	Returns a Function that ignores its parameter and returns the given value.
public static < t , u > function < t , u > cast function ( class < u > target ) { return new cast to class < t , u > ( target ) ; }	Returns a function that cast the incoming values via a Class object.
@ check return value @ non null public static < t > unicast subject < t > create ( ) { return new unicast subject < t > ( buffer size ( ) , bool ) ; }	Creates an UnicastSubject with an internal buffer capacity hint 16.
@ check return value @ non null public static < t > unicast subject < t > create ( int capacity hint ) { return new unicast subject < t > ( capacity hint , bool ) ; }	Creates an UnicastSubject with the given internal buffer capacity hint.
@ check return value @ non null public static < t > unicast subject < t > create ( int capacity hint , runnable on terminate ) { return new unicast subject < t > ( capacity hint , on terminate , bool ) ; }	Creates an UnicastSubject with the given internal buffer capacity hint and a callback forthe case when the single Subscriber cancels its subscription.
@ check return value @ non null public static < t > unicast subject < t > create ( boolean delay error ) { return new unicast subject < t > ( buffer size ( ) , delay error ) ; }	Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.
public throwable blocking get error ( ) { if ( get count ( ) != num ) { try { blocking helper . verify non blocking ( ) ; await ( ) ; } catch ( interrupted exception ex ) { dispose ( ) ; return ex ; } } return error ; }	Block until the latch is counted down and return the error received or null if noerror happened.
public throwable blocking get error ( long timeout , time unit unit ) { if ( get count ( ) != num ) { try { blocking helper . verify non blocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw exception helper . wrap or throw ( new timeout exception ( timeout message ( timeout , unit ) ) ) ; } } catch ( interrupted exception ex ) { dispose ( ) ; throw exception helper . wrap or throw ( ex ) ; } } return error ; }	Block until the latch is counted down and return the error received orwhen the wait is interrupted or times out, null otherwise.
public boolean blocking await ( long timeout , time unit unit ) { if ( get count ( ) != num ) { try { blocking helper . verify non blocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return bool ; } } catch ( interrupted exception ex ) { dispose ( ) ; throw exception helper . wrap or throw ( ex ) ; } } throwable ex = error ; if ( ex != null ) { throw exception helper . wrap or throw ( ex ) ; } return bool ; }	Block until the observer terminates and return true; return false ifthe wait times out.
public static < t , u > void drain max loop ( simple plain queue < t > q , subscriber < ? super u > a , boolean delay error , disposable dispose , queue drain < t , u > qd ) { int missed = num ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; t v = q . poll ( ) ; boolean empty = v == null ; if ( check terminated ( d , empty , a , delay error , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != num ) { if ( qd . accept ( a , v ) ) { if ( r != long . max value ) { qd . produced ( num ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . on error ( new missing backpressure exception ( str ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == num ) { break ; } } }	Drain the queue but give up with an error if there aren't enough requests.
public static void request ( subscription s , int prefetch ) { s . request ( prefetch < num ? long . max value : prefetch ) ; }	Requests Long.MAX_VALUE if prefetch is negative or the exactamount if prefetch is positive.
protected final void complete ( r n ) { long p = produced ; if ( p != num ) { backpressure helper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & complete mask ) != num ) { on drop ( n ) ; return ; } if ( ( r & request mask ) != num ) { lazy set ( complete mask + num ) ; downstream . on next ( n ) ; downstream . on complete ( ) ; return ; } value = n ; if ( compare and set ( num , complete mask ) ) { return ; } value = null ; } }	Signals the given value and an onComplete if the downstream is ready to receive the final value.
@ suppress warnings ( str ) @ nullable public t get value ( ) { object o = value ; if ( o != null && ! notification lite . is error ( o ) ) { return ( t ) value ; } return null ; }	Returns the contained value if this notification is an onNextsignal, null otherwise.
@ nullable public throwable get error ( ) { object o = value ; if ( notification lite . is error ( o ) ) { return notification lite . get error ( o ) ; } return null ; }	Returns the container Throwable error if this notification is an onErrorsignal, null otherwise.
public static boolean validate ( disposable upstream , disposable next , class < ? > observer ) { object helper . require non null ( next , str ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != disposable helper . disposed ) { report double subscription ( observer ) ; } return bool ; } return bool ; }	Ensures that the upstream Disposable is null and returns true, otherwisedisposes the next Disposable and if the upstream is not the shareddisposed instance, reports a ProtocolViolationException due tomultiple subscribe attempts.
public static boolean set once ( atomic reference < disposable > upstream , disposable next , class < ? > observer ) { object helper . require non null ( next , str ) ; if ( ! upstream . compare and set ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != disposable helper . disposed ) { report double subscription ( observer ) ; } return bool ; } return bool ; }	Atomically updates the target upstream AtomicReference from null to the non-nullnext Disposable, otherwise disposes next and reports a ProtocolViolationExceptionif the AtomicReference doesn't contain the shared disposed indicator.
public static boolean validate ( subscription upstream , subscription next , class < ? > subscriber ) { object helper . require non null ( next , str ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != subscription helper . cancelled ) { report double subscription ( subscriber ) ; } return bool ; } return bool ; }	Ensures that the upstream Subscription is null and returns true, otherwisecancels the next Subscription and if the upstream is not the sharedcancelled instance, reports a ProtocolViolationException due tomultiple subscribe attempts.
public static boolean set once ( atomic reference < subscription > upstream , subscription next , class < ? > subscriber ) { object helper . require non null ( next , str ) ; if ( ! upstream . compare and set ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != subscription helper . cancelled ) { report double subscription ( subscriber ) ; } return bool ; } return bool ; }	Atomically updates the target upstream AtomicReference from null to the non-nullnext Subscription, otherwise cancels next and reports a ProtocolViolationExceptionif the AtomicReference doesn't contain the shared cancelled indicator.
public static long add cap ( long a , long b ) { long u = a + b ; if ( u < num ) { return long . max value ; } return u ; }	Adds two long values and caps the sum at Long.MAX_VALUE.
public static long multiply cap ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) > > > num ) != num ) { if ( u / a != b ) { return long . max value ; } } return u ; }	Multiplies two long values and caps the product at Long.MAX_VALUE.
public static long add ( atomic long requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == long . max value ) { return long . max value ; } long u = add cap ( r , n ) ; if ( requested . compare and set ( r , u ) ) { return r ; } } }	Atomically adds the positive value n to the requested value in the AtomicLong andcaps the result at Long.MAX_VALUE and returns the previous value.
private static null pointer exception to npe ( throwable ex ) { null pointer exception npe = new null pointer exception ( str ) ; npe . init cause ( ex ) ; return npe ; }	Creates a NullPointerException instance and sets the given Throwable as its initial cause.
public void add ( object o ) {	Adds a new element to this list.
public static void shutdown ( ) { scheduled executor service exec = purge thread . get and set ( null ) ; if ( exec != null ) { exec . shutdown now ( ) ; } pools . clear ( ) ; }	Stops the purge thread.
public static scheduled executor service create ( thread factory factory ) { final scheduled executor service exec = executors . new scheduled thread pool ( num , factory ) ; try put into pool ( purge enabled , exec ) ; return exec ; }	Creates a ScheduledExecutorService with the given factory.
public final void set subscription ( subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } object helper . require non null ( s , str ) ; if ( get ( ) == num && compare and set ( num , num ) ) { subscription a = actual ; if ( a != null && cancel on replace ) { a . cancel ( ) ; } actual = s ; long r = requested ; if ( decrement and get ( ) != num ) { drain loop ( ) ; } if ( r != num ) { s . request ( r ) ; } return ; } subscription a = missed subscription . get and set ( s ) ; if ( a != null && cancel on replace ) { a . cancel ( ) ; } drain ( ) ; }	Atomically sets a new subscription.
void emit loop ( ) { for ( ; ; ) { append only linked array list < object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = bool ; return ; } queue = null ; } q . for each while ( this ) ; } }	Loops until all notifications in the queue has been processed.
public static runtime exception wrap or throw ( throwable error ) { if ( error instanceof error ) { throw ( error ) error ; } if ( error instanceof runtime exception ) { return ( runtime exception ) error ; } return new runtime exception ( error ) ; }	If the provided Throwable is an Error this methodthrows it, otherwise returns a RuntimeException wrapping the errorif that error is a checked exception.
public static list < throwable > flatten ( throwable t ) { list < throwable > list = new array list < throwable > ( ) ; array deque < throwable > deque = new array deque < throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . is empty ( ) ) { throwable e = deque . remove first ( ) ; if ( e instanceof composite exception ) { composite exception ce = ( composite exception ) e ; list < throwable > exceptions = ce . get exceptions ( ) ; for ( int i = exceptions . size ( ) - num ; i >= num ; i -- ) { deque . offer first ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }	Returns a flattened list of Throwables from tree-like CompositeException chain.
@ suppress warnings ( str ) public static < e extends throwable > exception throw if throwable ( throwable e ) throws e { if ( e instanceof exception ) { return ( exception ) e ; } throw ( e ) e ; }	Workaround for Java 6 not supporting throwing a final Throwable from a catch block.
public void clear ( ) { if ( disposed ) { return ; } open hash set < disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }	Atomically clears the container, then disposes all the previously contained Disposables.
public int size ( ) { if ( disposed ) { return num ; } synchronized ( this ) { if ( disposed ) { return num ; } open hash set < disposable > set = resources ; return set != null ? set . size ( ) : num ; } }	Returns the number of currently held Disposables.
@ suppress warnings ( str ) public static < t , r > boolean try scalar x ( observable source < t > source , observer < ? super r > observer , function < ? super t , ? extends observable source < ? extends r > > mapper ) { if ( source instanceof callable ) { t t ; try { t = ( ( callable < t > ) source ) . call ( ) ; } catch ( throwable ex ) { exceptions . throw if fatal ( ex ) ; empty disposable . error ( ex , observer ) ; return bool ; } if ( t == null ) { empty disposable . complete ( observer ) ; return bool ; } observable source < ? extends r > r ; try { r = object helper . require non null ( mapper . apply ( t ) , str ) ; } catch ( throwable ex ) { exceptions . throw if fatal ( ex ) ; empty disposable . error ( ex , observer ) ; return bool ; } if ( r instanceof callable ) { r u ; try { u = ( ( callable < r > ) r ) . call ( ) ; } catch ( throwable ex ) { exceptions . throw if fatal ( ex ) ; empty disposable . error ( ex , observer ) ; return bool ; } if ( u == null ) { empty disposable . complete ( observer ) ; return bool ; } scalar disposable < r > sd = new scalar disposable < r > ( observer , u ) ; observer . on subscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return bool ; } return bool ; }	Tries to subscribe to a possibly Callable source's mapped ObservableSource.
public static < t , u > observable < u > scalar x ( t value , function < ? super t , ? extends observable source < ? extends u > > mapper ) { return rx java plugins . on assembly ( new x < t , u > ( value , mapper ) ) ; }	Maps a scalar value into an Observable and emits its values.
public < u > boolean accept ( subscriber < ? super u > subscriber ) { object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = num ; i < c ; i ++ ) { object o = a [ i ] ; if ( o == null ) { break ; } if ( notification lite . accept full ( o , subscriber ) ) { return bool ; } } a = ( object [ ] ) a [ c ] ; } return bool ; }	Interprets the contents as NotificationLite objects and callsthe appropriate Subscriber method.
public < u > boolean accept ( observer < ? super u > observer ) { object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = num ; i < c ; i ++ ) { object o = a [ i ] ; if ( o == null ) { break ; } if ( notification lite . accept full ( o , observer ) ) { return bool ; } } a = ( object [ ] ) a [ c ] ; } return bool ; }	Interprets the contents as NotificationLite objects and callsthe appropriate Observer method.
public void start ( ) { if ( subscription helper . set once ( upstream , empty subscription . instance ) ) { queue = new spsc array queue < t > ( buffer size ) ; } }	Initializes this Processor by setting an upstream Subscription thatignores request amounts, uses a fixed bufferand allows using the onXXX and offer methodsafterwards.
public void start unbounded ( ) { if ( subscription helper . set once ( upstream , empty subscription . instance ) ) { queue = new spsc linked array queue < t > ( buffer size ) ; } }	Initializes this Processor by setting an upstream Subscription thatignores request amounts, uses an unbounded bufferand allows using the onXXX and offer methodsafterwards.
public boolean offer ( t t ) { if ( once . get ( ) ) { return bool ; } object helper . require non null ( t , str ) ; if ( fusion mode == queue subscription . none ) { if ( queue . offer ( t ) ) { drain ( ) ; return bool ; } } return bool ; }	Tries to offer an item into the internal queue and returns falseif the queue is full.
@ nullable public disposable get ( ) { disposable d = resource . get ( ) ; if ( d == disposable helper . disposed ) { return disposables . disposed ( ) ; } return d ; }	Returns the currently contained Disposable or null if this container is empty.
public final void complete ( t value ) { int state = get ( ) ; if ( ( state & ( fused ready | fused consumed | terminated | disposed ) ) != num ) { return ; } observer < ? super t > a = downstream ; if ( state == fused empty ) { this . value = value ; lazy set ( fused ready ) ; a . on next ( null ) ; } else { lazy set ( terminated ) ; a . on next ( value ) ; } if ( get ( ) != disposed ) { a . on complete ( ) ; } }	Complete the target with a single value or indicate there is a value available infusion mode.
public final void error ( throwable t ) { int state = get ( ) ; if ( ( state & ( fused ready | fused consumed | terminated | disposed ) ) != num ) { rx java plugins . on error ( t ) ; return ; } lazy set ( terminated ) ; downstream . on error ( t ) ; }	Complete the target with an error signal.
public final void complete ( ) { int state = get ( ) ; if ( ( state & ( fused ready | fused consumed | terminated | disposed ) ) != num ) { return ; } lazy set ( terminated ) ; downstream . on complete ( ) ; }	Complete the target without any value.
public perf async consumer await ( int count ) { if ( count <= num ) { while ( get count ( ) != num ) { } } else { try { await ( ) ; } catch ( interrupted exception ex ) { throw new runtime exception ( ex ) ; } } return this ; }	Wait for the terminal signal.
protected final void request ( long n ) { subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }	Requests from the upstream Subscription.
boolean add ( publish disposable < t > ps ) { for ( ; ; ) { publish disposable < t > [ ] a = subscribers . get ( ) ; if ( a == terminated ) { return bool ; } int n = a . length ; @ suppress warnings ( str ) publish disposable < t > [ ] b = new publish disposable [ n + num ] ; system . arraycopy ( a , num , b , num , n ) ; b [ n ] = ps ; if ( subscribers . compare and set ( a , b ) ) { return bool ; } } }	Tries to add the given subscriber to the subscribers array atomicallyor returns false if the subject has terminated.
@ suppress warnings ( str ) void remove ( publish disposable < t > ps ) { for ( ; ; ) { publish disposable < t > [ ] a = subscribers . get ( ) ; if ( a == terminated || a == empty ) { return ; } int n = a . length ; int j = - num ; for ( int i = num ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < num ) { return ; } publish disposable < t > [ ] b ; if ( n == num ) { b = empty ; } else { b = new publish disposable [ n - num ] ; system . arraycopy ( a , num , b , num , j ) ; system . arraycopy ( a , j + num , b , j , n - j - num ) ; } if ( subscribers . compare and set ( a , b ) ) { return ; } } }	Atomically removes the given subscriber if it is subscribed to the subject.
public static < t > connectable flowable < t > observe on ( final connectable flowable < t > cf , final scheduler scheduler ) { final flowable < t > flowable = cf . observe on ( scheduler ) ; return rx java plugins . on assembly ( new connectable flowable replay < t > ( cf , flowable ) ) ; }	Child Subscribers will observe the events of the ConnectableObservable on thespecified scheduler.
static < t , t > http service method < t , t > parse annotations ( retrofit retrofit , method method , request factory request factory ) { boolean is kotlin suspend function = request factory . is kotlin suspend function ; boolean continuation wants response = bool ; boolean continuation body nullable = bool ; annotation [ ] annotations = method . get annotations ( ) ; type adapter type ; if ( is kotlin suspend function ) { type [ ] parameter types = method . get generic parameter types ( ) ; type response type = utils . get parameter lower bound ( num , ( parameterized type ) parameter types [ parameter types . length - num ] ) ; if ( get raw type ( response type ) == response . class && response type instanceof parameterized type ) {	Inspects the annotations on an interface method to construct a reusable service method thatspeaks HTTP.
public void set delay ( long amount , time unit unit ) { if ( amount < num ) { throw new illegal argument exception ( str ) ; } this . delay ms = unit . to millis ( amount ) ; }	Set the network round trip delay.
public response < ? > create error response ( ) { response < ? > call ; try { call = error factory . call ( ) ; } catch ( exception e ) { throw new illegal state exception ( str , e ) ; } if ( call == null ) { throw new illegal state exception ( str ) ; } if ( call . is successful ( ) ) { throw new illegal state exception ( str ) ; } return call ; }	The HTTP error to be used when an error is triggered.
public long calculate delay ( time unit unit ) { float delta = variance percent / num ;	Get the delay that should be used for delaying a response in accordance with configuredbehavior.
private void create sample data ( string username , string password ) { assert . not null ( document dao , str ) ; assert . has text ( username , str ) ; authentication auth = new username password authentication token ( username , password ) ; try {	Creates a directory for the user, and a series of sub-directories.
private static http method value of ( string method ) { try { return http method . value of ( method ) ; } catch ( illegal argument exception e ) { } return null ; }	Provides a save way of obtaining the HttpMethod from a String.
@ override public dir context operations search for user ( string username ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + username + str + this ) ; } spring security ldap template template = new spring security ldap template ( context source ) ; template . set search controls ( search controls ) ; try { return template . search for single entry ( search base , search filter , new string [ ] { username } ) ; } catch ( incorrect result size data access exception not found ) { if ( not found . get actual size ( ) == num ) { throw new username not found exception ( str + username + str ) ; }	Return the LdapUserDetails containing the user's information.
public string encode ( char sequence raw password ) { string salt = prefix + this . salt generator . generate key ( ) + suffix ; return digest ( salt , raw password ) ; }	Encodes the rawPass using a MessageDigest.
public boolean matches ( char sequence raw password , string encoded password ) { string salt = extract salt ( encoded password ) ; string raw password encoded = digest ( salt , raw password ) ; return password encoder utils . equals ( encoded password . to string ( ) , raw password encoded ) ; }	Takes a previously encoded password and compares it with a rawpassword after mixingin the salt and encoding that value.
private static void perform version checks ( string min spring version ) { if ( min spring version == null ) { return ; }	Perform version checks with specific min Spring Version.
private static boolean disable checks ( string spring version , string spring security version ) { if ( spring version == null || spring version . equals ( spring security version ) ) { return bool ; } return boolean . get boolean ( disable checks ) ; }	Disable if springVersion and springSecurityVersion are the same to allow workingwith Uber Jars.
private static string get spring version ( ) { properties properties = new properties ( ) ; try { properties . load ( spring security core version . class . get class loader ( ) . get resource as stream ( str ) ) ; } catch ( io | null pointer exception e ) { return null ; } return properties . get property ( str ) ; }	Loads the spring version or null if it cannot be found.
public attribute exchange configurer attribute exchange ( string identifier pattern ) { attribute exchange configurer attribute exchange configurer = new attribute exchange configurer ( identifier pattern ) ; this . attribute exchange configurers . add ( attribute exchange configurer ) ; return attribute exchange configurer ; }	Sets up OpenID attribute exchange for OpenID's matching the specified pattern.
public o < http security > oauth2 client ( ) throws exception { o < http security > configurer = get or apply ( new o < > ( ) ) ; this . post process ( configurer ) ; return configurer ; }	Configures OAuth 2.0 Client support.
public o < http security > oauth2 resource server ( ) throws exception { o < http security > configurer = get or apply ( new o < > ( get context ( ) ) ) ; this . post process ( configurer ) ; return configurer ; }	Configures OAuth 2.0 Resource Server support.
public boolean compare ( final string dn , final string attribute name , final object value ) { final string comparison filter = str + attribute name + str ; class ldap compare callback implements context executor { public object execute with context ( dir context ctx ) throws naming exception { search controls ctls = new search controls ( ) ; ctls . set returning attributes ( no attrs ) ; ctls . set search scope ( search controls . object scope ) ; naming enumeration < search result > results = ctx . search ( dn , comparison filter , new object [ ] { value } , ctls ) ; boolean match = boolean . value of ( results . has more ( ) ) ; ldap utils . close enumeration ( results ) ; return match ; } } boolean matches = ( boolean ) execute read only ( new ldap compare callback ( ) ) ; return matches . boolean value ( ) ; }	Performs an LDAP compare operation of the value of an attribute for a particulardirectory entry.
public dir context operations retrieve entry ( final string dn , final string [ ] attributes to retrieve ) { return ( dir context operations ) execute read only ( new context executor ( ) { public object execute with context ( dir context ctx ) throws naming exception { attributes attrs = ctx . get attributes ( dn , attributes to retrieve ) ;	Composes an object from the attributes of the given DN.
public set < string > search for single attribute values ( final string base , final string filter , final object [ ] params , final string attribute name ) { string [ ] attribute names = new string [ ] { attribute name } ; set < map < string , list < string > > > multiple attribute values = search for multiple attribute values ( base , filter , params , attribute names ) ; set < string > result = new hash set < > ( ) ; for ( map < string , list < string > > map : multiple attribute values ) { list < string > values = map . get ( attribute name ) ; if ( values != null ) { result . add all ( values ) ; } } return result ; }	Performs a search using the supplied filter and returns the union of the values ofthe named attribute found in all entries matched by the search.
public static dir context operations search for single entry internal ( dir context ctx , search controls search controls , string base , string filter , object [ ] params ) throws naming exception { final distinguished name ctx base dn = new distinguished name ( ctx . get name in namespace ( ) ) ; final distinguished name search base dn = new distinguished name ( base ) ; final naming enumeration < search result > results enum = ctx . search ( search base dn , filter , params , build controls ( search controls ) ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + ctx base dn + str + search base dn + str + filter + str ) ; } set < dir context operations > results = new hash set < > ( ) ; try { while ( results enum . has more ( ) ) { search result search result = results enum . next ( ) ; dir context adapter dca = ( dir context adapter ) search result . get object ( ) ; assert . not null ( dca , str ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + dca . get dn ( ) ) ; } results . add ( dca ) ; } } catch ( partial result exception e ) { ldap utils . close enumeration ( results enum ) ; logger . info ( str ) ; } if ( results . size ( ) == num ) { throw new incorrect result size data access exception ( num , num ) ; } if ( results . size ( ) > num ) { throw new incorrect result size data access exception ( num , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }	Internal method extracted to avoid code duplication in AD search.
private static search controls build controls ( search controls original controls ) { return new search controls ( original controls . get search scope ( ) , original controls . get count limit ( ) , original controls . get time limit ( ) , original controls . get returning attributes ( ) , return object , original controls . get deref link flag ( ) ) ; }	We need to make sure the search controls has the return object flag set to true, inorder for the search to return DirContextAdapter instances.
private void lookup primary keys ( final map < serializable , acl > acls , final set < long > find now , final list < sid > sids ) { assert . not null ( acls , str ) ; assert . not empty ( find now , str ) ; string sql = compute repeating sql ( lookup primary keys where clause , find now . size ( ) ) ; set < long > parents to lookup = jdbc template . query ( sql , new prepared statement setter ( ) { public void set values ( prepared statement ps ) throws sql { int i = num ; for ( long to find : find now ) { i ++ ; ps . set long ( i , to find ) ; } } } , new process result set ( acls , sids ) ) ;	Locates the primary key IDs specified in "findNow", adding AclImpl instances withStubAclParents to the "acls" Map.
public pre authenticated granted authorities web authentication details build details ( http servlet request context ) { collection < string > j2ee user roles = get user roles ( context ) ; collection < ? extends granted authority > user gas = j2ee user roles2 granted authorities mapper . get granted authorities ( j2ee user roles ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + j2ee user roles + str + user gas + str ) ; } pre authenticated granted authorities web authentication details result = new pre authenticated granted authorities web authentication details ( context , user gas ) ; return result ; }	Builds the authentication details object.
private root bean definition create embedded server ( element element , parser context parser context ) { object source = parser context . extract source ( element ) ; string suffix = element . get attribute ( att root suffix ) ; if ( ! string utils . has text ( suffix ) ) { suffix = opt default root suffix ; } string port = element . get attribute ( att port ) ; if ( ! string utils . has text ( port ) ) { port = get default port ( ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + port ) ; } } string url = str + port + str + suffix ; bean definition builder context source = bean definition builder . root bean definition ( context source class ) ; context source . add constructor arg value ( url ) ; context source . add property value ( str , str ) ; context source . add property value ( str , str ) ; root bean definition apache container = new root bean definition ( str , null , null ) ; apache container . set source ( source ) ; apache container . get constructor argument values ( ) . add generic argument value ( suffix ) ; string ldifs = element . get attribute ( att ldif file ) ; if ( ! string utils . has text ( ldifs ) ) { ldifs = opt default ldif file ; } apache container . get constructor argument values ( ) . add generic argument value ( ldifs ) ; apache container . get property values ( ) . add property value ( str , port ) ; logger . info ( str + url ) ; if ( parser context . get registry ( ) . contains bean definition ( bean ids . embedded apache ds ) ) { parser context . get reader context ( ) . error ( str , element ) ; } parser context . get registry ( ) . register bean definition ( bean ids . embedded apache ds , apache container ) ; return ( root bean definition ) context source . get bean definition ( ) ; }	Will be called if no url attribute is supplied.Registers beans to create an embedded apache directory server.
private void create servlet api filter ( bean reference authentication manager ) { final string att servlet api provision = str ; final string def servlet api provision = str ; string provide servlet api = http elt . get attribute ( att servlet api provision ) ; if ( ! string utils . has text ( provide servlet api ) ) { provide servlet api = def servlet api provision ; } if ( str . equals ( provide servlet api ) ) { serv api filter = granted authority defaults parser utils . register with default role prefix ( pc , security context holder aware request filter bean factory . class ) ; serv api filter . get property values ( ) . add ( str , authentication manager ) ; } }	Adds the servlet-api integration filter if required.
private void create jaas api filter ( ) { final string att jaas api provision = str ; final string def jaas api provision = str ; string provide jaas api = http elt . get attribute ( att jaas api provision ) ; if ( ! string utils . has text ( provide jaas api ) ) { provide jaas api = def jaas api provision ; } if ( str . equals ( provide jaas api ) ) { jaas api filter = new root bean definition ( jaas api integration filter . class ) ; } }	Adds the jaas-api integration filter if required.
private static type resolver builder < ? extends type resolver builder > create whitelisted default typing ( ) { type resolver builder < ? extends type resolver builder > result = new whitelist type resolver builder ( object mapper . default typing . non final ) ; result = result . init ( json type info . id . class , null ) ; result = result . inclusion ( json type info . as . property ) ; return result ; }	Creates a TypeResolverBuilder that performs whitelisting.
private void insert spring security filter chain ( servlet context servlet context ) { string filter name = default filter name ; delegating filter proxy spring security filter chain = new delegating filter proxy ( filter name ) ; string context attribute = get web application context attribute ( ) ; if ( context attribute != null ) { spring security filter chain . set context attribute ( context attribute ) ; } register filter ( servlet context , bool , filter name , spring security filter chain ) ; }	Registers the springSecurityFilterChain.
public persistent remember me token get token for series ( string series id ) { try { return get jdbc template ( ) . query for object ( tokens by series sql , new row mapper < persistent remember me token > ( ) { public persistent remember me token map row ( result set rs , int row num ) throws sql { return new persistent remember me token ( rs . get string ( num ) , rs . get string ( num ) , rs . get string ( num ) , rs . get timestamp ( num ) ) ; } } , series id ) ; } catch ( empty result data access exception zero results ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + series id + str , zero results ) ; } } catch ( incorrect result size data access exception more than one ) { logger . error ( str + series id + str + str ) ; } catch ( data access exception e ) { logger . error ( str + series id , e ) ; } return null ; }	Loads the token data for the supplied series identifier.If an error occurs, it will be reported and null will be returned (since the resultshould just be a failed persistent login).
public list < granted authority > get granted authorities ( collection < string > attributes ) { list < granted authority > result = new array list < > ( attributes . size ( ) ) ; for ( string attribute : attributes ) { result . add ( get granted authority ( attribute ) ) ; } return result ; }	Map the given list of string attributes one-to-one to Spring SecurityGrantedAuthorities.
public static cipher new cipher ( string algorithm ) { try { return cipher . get instance ( algorithm ) ; } catch ( no such algorithm exception e ) { throw new illegal argument exception ( str , e ) ; } catch ( no such padding exception e ) { throw new illegal state exception ( str , e ) ; } }	Constructs a new Cipher.
@ override public void after properties set ( ) { try { super . after properties set ( ) ; } catch ( servlet exception e ) {	Check whether all required properties have been set.
public void do filter ( servlet request request , servlet response response , filter chain chain ) throws io , servlet exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + security context holder . get context ( ) . get authentication ( ) ) ; } if ( requires authentication ( ( http servlet request ) request ) ) { do authenticate ( ( http servlet request ) request , ( http servlet response ) response ) ; } chain . do filter ( request , response ) ; }	Try to authenticate a pre-authenticated user with Spring Security if the user hasnot yet been authenticated.
protected boolean principal changed ( http servlet request request , authentication current authentication ) { object principal = get pre authenticated principal ( request ) ; if ( ( principal instanceof string ) && current authentication . get name ( ) . equals ( principal ) ) { return bool ; } if ( principal != null && principal . equals ( current authentication . get principal ( ) ) ) { return bool ; } if ( logger . is debug enabled ( ) ) { logger . debug ( str + principal + str ) ; } return bool ; }	Determines if the current principal has changed. The default implementation tries If the {.
private void do authenticate ( http servlet request request , http servlet response response ) throws io , servlet exception { authentication auth result ; object principal = get pre authenticated principal ( request ) ; object credentials = get pre authenticated credentials ( request ) ; if ( principal == null ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str ) ; } return ; } if ( logger . is debug enabled ( ) ) { logger . debug ( str + principal + str ) ; } try { pre authenticated authentication token auth request = new pre authenticated authentication token ( principal , credentials ) ; auth request . set details ( authentication details source . build details ( request ) ) ; auth result = authentication manager . authenticate ( auth request ) ; successful authentication ( request , response , auth result ) ; } catch ( authentication exception failed ) { unsuccessful authentication ( request , response , failed ) ; if ( ! continue filter chain on unsuccessful authentication ) { throw failed ; } } }	Do the actual authentication for a pre-authenticated user.
private void check content length ( long content length to write ) { this . content written += content length to write ; boolean is body fully written = this . content length > num && this . content written >= this . content length ; int buffer size = get buffer size ( ) ; boolean requires flush = buffer size > num && this . content written >= buffer size ; if ( is body fully written || requires flush ) { do on response committed ( ) ; } }	Adds the contentLengthToWrite to the total contentWritten size and checks to see ifthe response should be written.
public set < granted authority > map authorities ( collection < ? extends granted authority > authorities ) { hash set < granted authority > mapped = new hash set < > ( authorities . size ( ) ) ; for ( granted authority authority : authorities ) { mapped . add ( map authority ( authority . get authority ( ) ) ) ; } if ( default authority != null ) { mapped . add ( default authority ) ; } return mapped ; }	Creates a mapping of the supplied authorities based on the case-conversion andprefix settings.
public t login processing url ( string login processing url ) { this . login processing url = login processing url ; auth filter . set requires authentication request matcher ( create login processing url matcher ( login processing url ) ) ; return get self ( ) ; }	Specifies the URL to validate the credentials.
protected final void update authentication defaults ( ) { if ( login processing url == null ) { login processing url ( login page ) ; } if ( failure handler == null ) { failure url ( login page + str ) ; } final logout configurer < b > logout configurer = get builder ( ) . get configurer ( logout configurer . class ) ; if ( logout configurer != null && ! logout configurer . is custom logout success ( ) ) { logout configurer . logout success url ( login page + str ) ; } }	Updates the default values for authentication.
protected final void update access defaults ( b http ) { if ( permit all ) { permit all support . permit all ( http , login page , login processing url , failure url ) ; } }	Updates the default values for access.
protected string map password ( object password value ) { if ( ! ( password value instanceof string ) ) {	Extension point to allow customized creation of the user's password from theattribute stored in the directory.
protected string extract remember me cookie ( http servlet request request ) { cookie [ ] cookies = request . get cookies ( ) ; if ( ( cookies == null ) || ( cookies . length == num ) ) { return null ; } for ( cookie cookie : cookies ) { if ( cookie name . equals ( cookie . get name ( ) ) ) { return cookie . get value ( ) ; } } return null ; }	Locates the Spring Security remember me cookie in the request and returns itsvalue.
protected string encode cookie ( string [ ] cookie tokens ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < cookie tokens . length ; i ++ ) { try { sb . append ( url . encode ( cookie tokens [ i ] , standard charsets . utf 8 . to string ( ) ) ) ; } catch ( unsupported encoding exception e ) { logger . error ( e . get message ( ) , e ) ; } if ( i < cookie tokens . length - num ) { sb . append ( delimiter ) ; } } string value = sb . to string ( ) ; sb = new string builder ( new string ( base64 . get encoder ( ) . encode ( value . get bytes ( ) ) ) ) ; while ( sb . char at ( sb . length ( ) - num ) == str ) { sb . delete char at ( sb . length ( ) - num ) ; } return sb . to string ( ) ; }	Inverse operation of decodeCookie.
protected void set cookie ( string [ ] tokens , int max age , http servlet request request , http servlet response response ) { string cookie value = encode cookie ( tokens ) ; cookie cookie = new cookie ( cookie name , cookie value ) ; cookie . set max age ( max age ) ; cookie . set path ( get cookie path ( request ) ) ; if ( cookie domain != null ) { cookie . set domain ( cookie domain ) ; } if ( max age < num ) { cookie . set version ( num ) ; } if ( use secure cookie == null ) { cookie . set secure ( request . is secure ( ) ) ; } else { cookie . set secure ( use secure cookie ) ; } cookie . set http only ( bool ) ; response . add cookie ( cookie ) ; }	Sets the cookie on the response.By default a secure cookie will be used if the connection is secure.
@ override public mono < object > resolve argument ( method parameter parameter , binding context binding context , server web exchange exchange ) { reactive adapter adapter = get adapter registry ( ) . get adapter ( parameter . get parameter type ( ) ) ; mono < security context > reactive security context = reactive security context holder . get context ( ) ; if ( reactive security context == null ) { return null ; } return reactive security context . flat map ( a -> { object p = resolve security context ( parameter , a ) ; mono < object > o = mono . just or empty ( p ) ; return adapter == null ? o : mono . just ( adapter . from publisher ( o ) ) ; } ) ; }	resolve the argument to inject into the controller parameter.
private string get query string ( final http servlet request request , final pattern artifact pattern ) { final string query = request . get query string ( ) ; if ( query == null ) { return null ; } final string result = artifact pattern . matcher ( query ) . replace first ( str ) ; if ( result . length ( ) == num ) { return null ; }	If present, removes the artifactParameterName and the corresponding value from thequery String.
private static int get service port ( url cas service url ) { int port = cas service url . get port ( ) ; if ( port == - num ) { port = cas service url . get default port ( ) ; } return port ; }	Gets the port from the casServiceURL ensuring to return the proper value if thedefault port is being used.
public string get principal ( ) { authentication authentication = security context holder . get context ( ) . get authentication ( ) ; if ( authentication == null ) { log . warn ( str ) ; return str ; } object principal = authentication . get principal ( ) ; if ( principal instanceof ldap user details ) { ldap user details details = ( ldap user details ) principal ; return details . get dn ( ) ; } else if ( authentication instanceof anonymous authentication token ) { if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } return str ; } else { throw new illegal argument exception ( str + str ) ; } }	Get the principals of the logged in user, in this case the distinguished name.
public void logout ( http servlet request request , http servlet response response , authentication authentication ) { assert . not null ( request , str ) ; if ( invalidate http session ) { http session session = request . get session ( bool ) ; if ( session != null ) { logger . debug ( str + session . get id ( ) ) ; session . invalidate ( ) ; } } if ( clear authentication ) { security context context = security context holder . get context ( ) ; context . set authentication ( null ) ; } security context holder . clear context ( ) ; }	Requires the request to be passed in.
public authentication authenticate ( authentication auth ) throws authentication exception { if ( ! ( auth instanceof username password authentication token ) ) { return null ; } username password authentication token request = ( username password authentication token ) auth ; set < granted authority > authorities ; try {	Attempts to login the user given the Authentication objects principal andcredential.
public void set context environment properties ( map < string , object > environment ) { assert . not empty ( environment , str ) ; this . context environment properties = new hashtable < > ( environment ) ; }	Allows a custom environment properties to be used to create initial LDAP context.
@ override public string get redirect url ( ) { return url utils . build full request url ( scheme , server name , server port , request uri , query string ) ; }	Indicates the URL that the user agent used for this request.
public int do end tag ( ) throws jsp exception { try { if ( ! authorized && tag lib config . is ui security disabled ( ) ) { page context . get out ( ) . write ( tag lib config . get secured ui suffix ( ) ) ; } } catch ( io e ) { throw new jsp exception ( e ) ; } return eval page ; }	Default processing of the end tag returning EVAL_PAGE.
@ override protected void init user details service ( ) throws exception { for ( user details builder user builder : user builders ) { get user details service ( ) . create user ( user builder . build ( ) ) ; } for ( user details user details : this . users ) { get user details service ( ) . create user ( user details ) ; } }	Populates the users that have been added.
private user details service get user details service ( ) { map < string , ? > beans = get beans of type ( caching user details service . class ) ; if ( beans . size ( ) == num ) { beans = get beans of type ( user details service . class ) ; } if ( beans . size ( ) == num ) { throw new application context exception ( str ) ; } else if ( beans . size ( ) > num ) { throw new application context exception ( str + str ) ; } return ( user details service ) beans . values ( ) . to array ( ) [ num ] ; }	Obtains a user details service for use in RememberMeServices etc.
private void add pkce parameters ( map < string , object > attributes , map < string , object > additional parameters ) { string code verifier = this . code verifier generator . generate key ( ) ; attributes . put ( pkce parameter names . code verifier , code verifier ) ; try { string code challenge = create code challenge ( code verifier ) ; additional parameters . put ( pkce parameter names . code challenge , code challenge ) ; additional parameters . put ( pkce parameter names . code challenge method , str ) ; } catch ( no such algorithm exception e ) { additional parameters . put ( pkce parameter names . code challenge , code verifier ) ; } }	Creates and adds additional PKCE parameters for use in the OAuth 2.0 Authorization and Access Token Requests.
protected boolean requires authentication ( final http servlet request request , final http servlet response response ) { final boolean service ticket request = service ticket request ( request , response ) ; final boolean result = service ticket request || proxy receptor request ( request ) || ( proxy ticket request ( service ticket request , request ) ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + result ) ; } return result ; }	Overridden to provide proxying capabilities.
private boolean service ticket request ( final http servlet request request , final http servlet response response ) { boolean result = super . requires authentication ( request , response ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + result ) ; } return result ; }	Indicates if the request is elgible to process a service ticket.
private boolean proxy ticket request ( final boolean service ticket request , final http servlet request request ) { if ( service ticket request ) { return bool ; } final boolean result = authenticate all artifacts && obtain artifact ( request ) != null && ! authenticated ( ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + result ) ; } return result ; }	Indicates if the request is elgible to process a proxy ticket.
private boolean authenticated ( ) { authentication authentication = security context holder . get context ( ) . get authentication ( ) ; return authentication != null && authentication . is authenticated ( ) && ! ( authentication instanceof anonymous authentication token ) ; }	Determines if a user is already authenticated.
private boolean proxy receptor request ( final http servlet request request ) { final boolean result = proxy receptor configured ( ) && proxy receptor matcher . matches ( request ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + result ) ; } return result ; }	Indicates if the request is elgible to be processed as the proxy receptor.
protected method security expression operations create security expression root ( authentication authentication , method invocation invocation ) { method security expression root root = new method security expression root ( authentication ) ; root . set this ( invocation . get this ( ) ) ; root . set permission evaluator ( get permission evaluator ( ) ) ; root . set trust resolver ( get trust resolver ( ) ) ; root . set role hierarchy ( get role hierarchy ( ) ) ; root . set default role prefix ( get default role prefix ( ) ) ; return root ; }	Creates the root object for expression evaluation.
private mono < jwk > get jwk ( ) { return this . web client . get ( ) . uri ( this . jwk set url ) . retrieve ( ) . body to mono ( string . class ) . map ( this :: parse ) . do on next ( jwk set -> this . cached jwk . set ( mono . just ( jwk set ) ) ) . cache ( ) ; }	Updates the cached JWK set from the configured URL.
private string utf8 url encode ( string value ) { try { return url . encode ( value , str ) ; } catch ( unsupported encoding exception e ) { error err = new assertion error ( str ) ; err . init cause ( e ) ; throw err ; } }	Performs URL encoding with UTF-8.
private collection < ? extends granted authority > get web sphere groups based granted authorities ( ) { list < string > web sphere groups = was helper . get groups for current user ( ) ; collection < ? extends granted authority > user gas = web sphere groups2 granted authorities mapper . get granted authorities ( web sphere groups ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + web sphere groups + str + user gas ) ; } return user gas ; }	Get a list of Granted Authorities based on the current user's WebSphere groups.
protected user details load user by assertion ( final assertion assertion ) { final cas assertion authentication token token = new cas assertion authentication token ( assertion , str ) ; return this . authentication user details service . load user details ( token ) ; }	Template method for retrieving the UserDetails based on the assertion.
protected object get pre authenticated principal ( http servlet request http request ) { object principal = was helper . get current user name ( ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + principal ) ; } return principal ; }	Return the WebSphere user name.
public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = num ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] new array = new byte [ length ] ; int dest pos = num ; for ( byte [ ] array : arrays ) { system . arraycopy ( array , num , new array , dest pos , array . length ) ; dest pos += array . length ; } return new array ; }	Combine the individual byte arrays into one array.
public static byte [ ] sub array ( byte [ ] array , int begin index , int end index ) { int length = end index - begin index ; byte [ ] subarray = new byte [ length ] ; system . arraycopy ( array , begin index , subarray , num , length ) ; return subarray ; }	Extract a sub array of bytes out of the byte array.
public list < granted authority > get granted authorities ( collection < string > attributes ) { array list < granted authority > ga list = new array list < > ( ) ; for ( string attribute : attributes ) { collection < granted authority > c = attributes2granted authorities map . get ( attribute ) ; if ( c != null ) { ga list . add all ( c ) ; } } ga list . trim to size ( ) ; return ga list ; }	Map the given array of attributes to Spring Security GrantedAuthorities.
private map < string , collection < granted authority > > pre process map ( map < ? , ? > org map ) { map < string , collection < granted authority > > result = new hash map < string , collection < granted authority > > ( org map . size ( ) ) ; for ( map . entry < ? , ? > entry : org map . entry set ( ) ) { assert . is instance of ( string . class , entry . get key ( ) , str ) ; result . put ( ( string ) entry . get key ( ) , get granted authority collection ( entry . get value ( ) ) ) ; } return result ; }	Preprocess the given map to convert all the values to GrantedAuthority collections.
private collection < granted authority > get granted authority collection ( object value ) { collection < granted authority > result = new array list < > ( ) ; add granted authority collection ( result , value ) ; return result ; }	Convert the given value to a collection of Granted Authorities.
private void add granted authority collection ( collection < granted authority > result , object value ) { if ( value == null ) { return ; } if ( value instanceof collection < ? > ) { add granted authority collection ( result , ( collection < ? > ) value ) ; } else if ( value instanceof object [ ] ) { add granted authority collection ( result , ( object [ ] ) value ) ; } else if ( value instanceof string ) { add granted authority collection ( result , ( string ) value ) ; } else if ( value instanceof granted authority ) { result . add ( ( granted authority ) value ) ; } else { throw new illegal argument exception ( str + value . get class ( ) . get name ( ) ) ; } }	Convert the given value to a collection of Granted Authorities, adding the resultto the given result collection.
protected object get pre authenticated principal ( http servlet request http request ) { object principal = http request . get user principal ( ) == null ? null : http request . get user principal ( ) . get name ( ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + principal ) ; } return principal ; }	Return the J2EE user name.
@ suppress warnings ( str ) public < c > c get shared object ( class < c > shared type ) { return ( c ) this . shared objects . get ( shared type ) ; }	Gets a shared Object.
protected string build https redirect url for request ( http servlet request request ) throws io , servlet exception { int server port = port resolver . get server port ( request ) ; integer https port = port mapper . lookup https port ( integer . value of ( server port ) ) ; if ( https port != null ) { redirect url builder url builder = new redirect url builder ( ) ; url builder . set scheme ( str ) ; url builder . set server name ( request . get server name ( ) ) ; url builder . set port ( https port . int value ( ) ) ; url builder . set context path ( request . get context path ( ) ) ; url builder . set servlet path ( request . get servlet path ( ) ) ; url builder . set path info ( request . get path info ( ) ) ; url builder . set query ( request . get query string ( ) ) ; return url builder . get url ( ) ; }	Builds a URL to redirect the supplied request to HTTPS.
public object invoke ( join point jp , j advisor proceed ) { interceptor status token token = super . before invocation ( new method invocation adapter ( jp ) ) ; object result ; try { result = advisor proceed . proceed with object ( ) ; } finally { super . finally invocation ( token ) ; } return super . after invocation ( token , result ) ; }	Method that is suitable for user with traditional AspectJ-code aspects.
private static string has role ( string role ) { assert . is true ( ! role . starts with ( str ) , ( ) -> role + str ) ; return str + role ; }	Creates a String for specifying a user requires a role.
private static string [ ] has any role ( string ... roles ) { for ( int i = num ; i < roles . length ; i ++ ) { roles [ i ] = str + roles [ i ] ; } return roles ; }	Creates a String for specifying that a user requires one of many roles.
protected void on login success ( http servlet request request , http servlet response response , authentication successful authentication ) { string username = successful authentication . get name ( ) ; logger . debug ( str + username ) ; persistent remember me token persistent token = new persistent remember me token ( username , generate series data ( ) , generate token data ( ) , new date ( ) ) ; try { token repository . create new token ( persistent token ) ; add cookie ( persistent token , request , response ) ; } catch ( exception e ) { logger . error ( str , e ) ; } }	Creates a new persistent login token with a new series number, stores the data inthe persistent token repository and adds the corresponding cookie to the response.
protected authentication attempt switch user ( http servlet request request ) throws authentication exception { username password authentication token target user request ; string username = request . get parameter ( this . username parameter ) ; if ( username == null ) { username = str ; } if ( this . logger . is debug enabled ( ) ) { this . logger . debug ( str + username + str ) ; } user details target user = this . user details service . load user by username ( username ) ; this . user details checker . check ( target user ) ;	Attempt to switch to another user.
protected authentication attempt exit user ( http servlet request request ) throws authentication credentials not found exception {	Attempt to exit from an already switched user.
public void set exit user url ( string exit user url ) { assert . is true ( url utils . is valid redirect url ( exit user url ) , str ) ; this . exit user matcher = create matcher ( exit user url ) ; }	Set the URL to respond to exit user processing.
@ request mapping ( value = str , method = request method . get ) public model and view display public index ( ) { contact rnd = contact manager . get random contact ( ) ; return new model and view ( str , str , rnd ) ; }	The public index page, used for unauthenticated users.
@ bean ( name = abstract security web application initializer . default filter name ) public filter spring security filter chain ( ) throws exception { boolean has configurers = web security configurers != null && ! web security configurers . is empty ( ) ; if ( ! has configurers ) { web security configurer adapter adapter = object object post processor . post process ( new web security configurer adapter ( ) { } ) ; web security . apply ( adapter ) ; } return web security . build ( ) ; }	Creates the Spring Security Filter Chain.
@ override public jwt decode ( string token ) throws jwt exception { jwt jwt = parse ( token ) ; if ( jwt instanceof jwt ) { jwt created jwt = create jwt ( token , jwt ) ; return validate jwt ( created jwt ) ; } throw new jwt exception ( str + jwt . get header ( ) . get algorithm ( ) ) ; }	Decode and validate the JWT from its compact claims representation format.
public boolean authorize using access expression ( ) throws io { if ( security context holder . get context ( ) . get authentication ( ) == null ) { return bool ; } security expression handler < filter invocation > handler = get expression handler ( ) ; expression access expression ; try { access expression = handler . get expression parser ( ) . parse expression ( get access ( ) ) ; } catch ( parse exception e ) { io io exception = new io ( ) ; io exception . init cause ( e ) ; throw io exception ; } return expression utils . evaluate as boolean ( access expression , create expression evaluation context ( handler ) ) ; }	Make an authorization decision based on a Spring EL expression.
public boolean authorize using url check ( ) throws io { string context path = ( ( http servlet request ) get request ( ) ) . get context path ( ) ; authentication current user = security context holder . get context ( ) . get authentication ( ) ; return get privilege evaluator ( ) . is allowed ( context path , get url ( ) , get method ( ) , current user ) ; }	Make an authorization decision based on the URL and HTTP method attributes.
@ override public collection < granted authority > convert ( jwt jwt ) { return get scopes ( jwt ) . stream ( ) . map ( authority -> scope authority prefix + authority ) . map ( simple granted authority :: new ) . collect ( collectors . to list ( ) ) ; }	Extracts the authorities.
@ override public csrf token generate token ( http servlet request request ) { return wrap ( request , this . delegate . generate token ( request ) ) ; }	Generates a new token.
@ request mapping ( value = str , method = request method . get ) public model and view display admin page ( @ request param ( str ) int contact id ) { contact contact = contact manager . get by id ( long . value of ( contact id ) ) ; acl acl = acl service . read acl by id ( new object identity impl ( contact ) ) ; map < string , object > model = new hash map < > ( ) ; model . put ( str , contact ) ; model . put ( str , acl ) ; return new model and view ( str , str , model ) ; }	Displays the permission admin page for a particular contact.
@ request mapping ( value = str , method = request method . get ) public model and view display add permission page for contact ( @ request param ( str ) long contact id ) { contact contact = contact manager . get by id ( contact id ) ; add permission add permission = new add permission ( ) ; add permission . set contact ( contact ) ; map < string , object > model = new hash map < > ( ) ; model . put ( str , add permission ) ; model . put ( str , list recipients ( ) ) ; model . put ( str , list permissions ( ) ) ; return new model and view ( str , model ) ; }	Displays the "add permission" page for a contact.
@ request mapping ( value = str , method = request method . post ) public string add permission ( add permission add permission , binding result result , model map model ) { add permission validator . validate ( add permission , result ) ; if ( result . has errors ( ) ) { model . put ( str , list recipients ( ) ) ; model . put ( str , list permissions ( ) ) ; return str ; } principal sid sid = new principal sid ( add permission . get recipient ( ) ) ; permission permission = permission factory . build from mask ( add permission . get permission ( ) ) ; try { contact manager . add permission ( add permission . get contact ( ) , sid , permission ) ; } catch ( data access exception existing permission ) { existing permission . print stack trace ( ) ; result . reject value ( str , str , str ) ; model . put ( str , list recipients ( ) ) ; model . put ( str , list permissions ( ) ) ; return str ; } return str ; }	Handles submission of the "add permission" form.
private static string get role with default prefix ( string default role prefix , string role ) { if ( role == null ) { return role ; } if ( default role prefix == null || default role prefix . length ( ) == num ) { return role ; } if ( role . starts with ( default role prefix ) ) { return role ; } return default role prefix + role ; }	Prefixes role with defaultRolePrefix if defaultRolePrefix is non-null and if roledoes not already start with defaultRolePrefix.
public static user details resource factory bean from string ( string users ) { in memory resource resource = new in memory resource ( users ) ; return from resource ( resource ) ; }	Creates a UserDetailsResourceFactoryBean with a resource from the provided String.
public list < string > get attribute values ( string name ) { list < string > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = collections . empty list ( ) ; } return result ; }	Returns the values for a specific attribute.
public string get first attribute value ( string name ) { list < string > result = get attribute values ( name ) ; if ( result . is empty ( ) ) { return null ; } else { return result . get ( num ) ; } }	Returns the first attribute value for a specified attribute.
public static byte [ ] encode ( char sequence string ) { try { byte buffer bytes = charset . new encoder ( ) . encode ( char buffer . wrap ( string ) ) ; byte [ ] bytes copy = new byte [ bytes . limit ( ) ] ; system . arraycopy ( bytes . array ( ) , num , bytes copy , num , bytes . limit ( ) ) ; return bytes copy ; } catch ( character coding exception e ) { throw new illegal argument exception ( str , e ) ; } }	Get the bytes of the String in UTF-8 encoded form.
public static string decode ( byte [ ] bytes ) { try { return charset . new decoder ( ) . decode ( byte buffer . wrap ( bytes ) ) . to string ( ) ; } catch ( character coding exception e ) { throw new illegal argument exception ( str , e ) ; } }	Decode the bytes in UTF-8 form into a String.
private < t extends accessible object > string [ ] lookup parameter names ( parameter name factory < t > parameter name factory , t t ) { annotation [ ] [ ] parameter annotations = parameter name factory . find parameter annotations ( t ) ; int parameter count = parameter annotations . length ; string [ ] param names = new string [ parameter count ] ; boolean found = bool ; for ( int i = num ; i < parameter count ; i ++ ) { annotation [ ] annotations = parameter annotations [ i ] ; string parameter name = find parameter name ( annotations ) ; if ( parameter name != null ) { found = bool ; param names [ i ] = parameter name ; } } return found ? param names : null ; }	Gets the parameter names or null if not found.
@ request mapping ( value = str , method = request method . post ) public string add contact ( web contact form , binding result result ) { validator . validate ( form , result ) ; if ( result . has errors ( ) ) { return str ; } contact contact = new contact ( form . get name ( ) , form . get email ( ) ) ; contact manager . create ( contact ) ; return str ; }	Handles the submission of the contact form, creating a new instance if the usernameand email are valid.
@ override protected collection < config attribute > find attributes ( method method , class < ? > target class ) { if ( target class == null ) { return null ; } return find attributes specified against ( method , target class ) ; }	Will walk the method inheritance tree to find the most specific declarationapplicable.
private void add secure method ( registered method method , list < config attribute > attr ) { assert . not null ( method , str ) ; assert . not null ( attr , str ) ; if ( logger . is info enabled ( ) ) { logger . info ( str + method + str + attr + str ) ; } this . method map . put ( method , attr ) ; }	Add configuration attributes for a secure method.
@ override public collection < config attribute > get all config attributes ( ) { set < config attribute > all attributes = new hash set < > ( ) ; for ( list < config attribute > attribute list : method map . values ( ) ) { all attributes . add all ( attribute list ) ; } return all attributes ; }	Obtains the configuration attributes explicitly defined against this bean.
private boolean is match ( string method name , string mapped name ) { return ( mapped name . ends with ( str ) && method name . starts with ( mapped name . substring ( num , mapped name . length ( ) - num ) ) ) || ( mapped name . starts with ( str ) && method name . ends with ( mapped name . substring ( num , mapped name . length ( ) ) ) ) ; }	Return if the given method name matches the mapped name.
public c any request ( ) { assert . state ( ! this . any request configured , str ) ; c configurer = request matchers ( any request ) ; this . any request configured = bool ; return configurer ; }	Maps any request.
protected void handle bind exception ( string user dn , string username , throwable cause ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + user dn + str + cause ) ; } }	Allows subclasses to inspect the exception thrown by an attempt to bind with aparticular DN.
@ transactional ( read only = bool ) public contact get random contact ( ) { logger . debug ( str ) ; random rnd = new random ( ) ; list < contact > contacts = contact dao . find all ( ) ; int get number = rnd . next int ( contacts . size ( ) ) ; return contacts . get ( get number ) ; }	This is a public method.
protected final void clear authentication attributes ( http servlet request request ) { http session session = request . get session ( bool ) ; if ( session == null ) { return ; } session . remove attribute ( web attributes . authentication exception ) ; }	Removes temporary authentication-related data which may have been stored in thesession during the authentication process.
public static field get field ( class < ? > clazz , string field name ) throws illegal state exception { assert . not null ( clazz , str ) ; assert . has text ( field name , str ) ; try { return clazz . get declared field ( field name ) ; } catch ( no such field exception nsf ) {	Attempts to locate the specified field on the class.
protected string create service url ( final http servlet request request , final http servlet response response ) { return common utils . construct service url ( null , response , this . service properties . get service ( ) , null , this . service properties . get artifact parameter ( ) , this . encode service url with session id ) ; }	Constructs a new Service Url.
protected string create redirect url ( final string service url ) { return common utils . construct redirect url ( this . login url , this . service properties . get service parameter ( ) , service url , this . service properties . is send renew ( ) , bool ) ; }	Constructs the Url for Redirection to the CAS server.
private string extract prefix ( string enc pass ) { if ( ! enc pass . starts with ( str ) ) { return null ; } int second brace = enc pass . last index of ( str ) ; if ( second brace < num ) { throw new illegal argument exception ( str ) ; } return enc pass . substring ( num , second brace + num ) ; }	Returns the hash prefix or null if there isn't one.
public void commence ( http servlet request request , http servlet response response , authentication exception arg2 ) throws io , servlet exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str ) ; } response . send error ( http servlet response . sc forbidden , str ) ; }	Always returns a 403 error code to the client.
private void check filter stack ( list < filter > filters ) { check for duplicates ( security context persistence filter . class , filters ) ; check for duplicates ( username password authentication filter . class , filters ) ; check for duplicates ( session management filter . class , filters ) ; check for duplicates ( basic authentication filter . class , filters ) ; check for duplicates ( security context holder aware request filter . class , filters ) ; check for duplicates ( jaas api integration filter . class , filters ) ; check for duplicates ( exception translation filter . class , filters ) ; check for duplicates ( filter security interceptor . class , filters ) ; }	Checks the filter list for possible errors and logs them.
@ suppress warnings ( str ) final class < ? extends throwable > [ ] get registered types ( ) { set < class < ? extends throwable > > type list = this . extractor map . key set ( ) ; return type list . to array ( new class [ type list . size ( ) ] ) ; }	Returns an array containing the classes for which extractors are registered.
private throwable extract cause ( throwable throwable ) { for ( map . entry < class < ? extends throwable > , throwable cause extractor > entry : extractor map . entry set ( ) ) { class < ? extends throwable > throwable type = entry . get key ( ) ; if ( throwable type . is instance ( throwable ) ) { throwable cause extractor extractor = entry . get value ( ) ; return extractor . extract cause ( throwable ) ; } } return null ; }	Extracts the cause of the given throwable using an appropriate extractor.
@ suppress warnings ( { str , str } ) private string register access manager ( parser context pc , boolean jsr250 enabled , bean definition expression voter ) { bean definition builder access mgr builder = bean definition builder . root bean definition ( affirmative based . class ) ; managed list voters = new managed list ( num ) ; if ( expression voter != null ) { voters . add ( expression voter ) ; } voters . add ( new root bean definition ( role voter . class ) ) ; voters . add ( new root bean definition ( authenticated voter . class ) ) ; if ( jsr250 enabled ) { voters . add ( new root bean definition ( jsr250 voter . class ) ) ; } access mgr builder . add constructor arg value ( voters ) ; bean definition access manager = access mgr builder . get bean definition ( ) ; string id = pc . get reader context ( ) . generate bean name ( access manager ) ; pc . register bean component ( new bean component definition ( access manager , id ) ) ; return id ; }	Register the default AccessDecisionManager.
public static set < string > authority list to set ( collection < ? extends granted authority > user authorities ) { assert . not null ( user authorities , str ) ; set < string > set = new hash set < > ( user authorities . size ( ) ) ; for ( granted authority authority : user authorities ) { set . add ( authority . get authority ( ) ) ; } return set ; }	Converts an array of GrantedAuthority objects to a Set.
private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return bool ; } int result = num ; for ( int i = num ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == num ; }	Constant time comparison to prevent against timing attacks.
public void set default failure url ( string default failure url ) { assert . is true ( url utils . is valid redirect url ( default failure url ) , ( ) -> str + default failure url + str ) ; this . default failure url = default failure url ; }	The URL which will be used as the failure destination.
public void set resolve hidden inputs ( function < http servlet request , map < string , string > > resolve hidden inputs ) { assert . not null ( resolve hidden inputs , str ) ; this . resolve hidden inputs = resolve hidden inputs ; }	Sets a Function used to resolve a Map of the hidden inputs where the key is thename of the input and the value is the value of the input.
private static string build request url ( string servlet path , string request uri , string context path , string path info , string query string ) { string builder url = new string builder ( ) ; if ( servlet path != null ) { url . append ( servlet path ) ; if ( path info != null ) { url . append ( path info ) ; } } else { url . append ( request uri . substring ( context path . length ( ) ) ) ; } if ( query string != null ) { url . append ( str ) . append ( query string ) ; } return url . to string ( ) ; }	Obtains the web application-specific fragment of the URL.
public static boolean is absolute url ( string url ) { if ( url == null ) { return bool ; } final pattern absolute url = pattern . compile ( str , pattern . case insensitive ) ; return absolute url . matcher ( url ) . matches ( ) ; }	Decides if a URL is absolute based on whether it contains a valid scheme name, asdefined in RFC 1738.
public list < id > create attribute list ( string identifier ) { for ( map . entry < pattern , list < id > > entry : id to attributes . entry set ( ) ) { if ( entry . get key ( ) . matcher ( identifier ) . matches ( ) ) { return entry . get value ( ) ; } } return collections . empty list ( ) ; }	Iterates through the patterns stored in the map and returns the list of attributesdefined for the first match.
serializable identifier from ( serializable identifier , result set result set ) throws sql { if ( is string ( identifier ) && has valid class id type ( result set ) && can convert from string to ( class id type from ( result set ) ) ) { identifier = convert from string to ( ( string ) identifier , class id type from ( result set ) ) ; } else {	Converts the raw type from the database into the right Java type.
protected void create entries ( final mutable acl acl ) { if ( acl . get entries ( ) . is empty ( ) ) { return ; } jdbc operations . batch update ( insert entry , new batch prepared statement setter ( ) { public int get batch size ( ) { return acl . get entries ( ) . size ( ) ; } public void set values ( prepared statement stmt , int i ) throws sql { access control entry entry = acl . get entries ( ) . get ( i ) ; assert . is true ( entry instanceof access control entry impl , str ) ; access control entry impl entry = ( access control entry impl ) entry ; stmt . set long ( num , ( ( long ) acl . get id ( ) ) . long value ( ) ) ; stmt . set int ( num , i ) ; stmt . set long ( num , create or retrieve sid primary key ( entry . get sid ( ) , bool ) . long value ( ) ) ; stmt . set int ( num , entry . get permission ( ) . get mask ( ) ) ; stmt . set boolean ( num , entry . is granting ( ) ) ; stmt . set boolean ( num , entry . is audit success ( ) ) ; stmt . set boolean ( num , entry . is audit failure ( ) ) ; } } ) ; }	Creates a new row in acl_entry for every ACE defined in the passed MutableAclobject.
protected void create object identity ( object identity object , sid owner ) { long sid id = create or retrieve sid primary key ( owner , bool ) ; long class id = create or retrieve class primary key ( object . get type ( ) , bool , object . get identifier ( ) . get class ( ) ) ; jdbc operations . update ( insert object identity , class id , object . get identifier ( ) . to string ( ) , sid id , boolean . true ) ; }	Creates an entry in the acl_object_identity table for the passed ObjectIdentity.The Sid is also necessary, as acl_object_identity has defined the sid column asnon-null.
protected void update object identity ( mutable acl acl ) { long parent id = null ; if ( acl . get parent acl ( ) != null ) { assert . is instance of ( object identity impl . class , acl . get parent acl ( ) . get object identity ( ) , str ) ; object identity impl oii = ( object identity impl ) acl . get parent acl ( ) . get object identity ( ) ; parent id = retrieve object identity primary key ( oii ) ; } assert . not null ( acl . get owner ( ) , str ) ; long owner sid = create or retrieve sid primary key ( acl . get owner ( ) , bool ) ; int count = jdbc operations . update ( update object identity , parent id , owner sid , boolean . value of ( acl . is entries inheriting ( ) ) , acl . get id ( ) ) ; if ( count != num ) { throw new not found exception ( str ) ; } }	Updates an existing acl_object_identity row, with new information presented in thepassed MutableAcl object.
public void save request ( http servlet request request , http servlet response response ) { if ( request matcher . matches ( request ) ) { default saved request saved request = new default saved request ( request , port resolver ) ; if ( create session allowed || request . get session ( bool ) != null ) {	Stores the current request, provided the configuration properties allow it.
public static server web exchange matcher path matchers ( http method method , string ... patterns ) { list < server web exchange matcher > matchers = new array list < > ( patterns . length ) ; for ( string pattern : patterns ) { matchers . add ( new path pattern parser server web exchange matcher ( pattern , method ) ) ; } return new or server web exchange matcher ( matchers ) ; }	Creates a matcher that matches on the specific method and any of the provided patterns.
public static server web exchange matcher any exchange ( ) {	Matches any exchange.
public static text encryptor delux ( char sequence password , char sequence salt ) { return new hex encoding text encryptor ( stronger ( password , salt ) ) ; }	Creates a text encryptor that uses "stronger" password-based encryption.
public static text encryptor text ( char sequence password , char sequence salt ) { return new hex encoding text encryptor ( standard ( password , salt ) ) ; }	Creates a text encryptor that uses "standard" password-based encryption.
public static text encryptor queryable text ( char sequence password , char sequence salt ) { return new hex encoding text encryptor ( new aes bytes encryptor ( password . to string ( ) , salt ) ) ; }	Creates an encryptor for queryable text strings that uses standard password-basedencryption.
public void write headers ( http servlet request request , http servlet response response ) { if ( x . allow from . equals ( frame options mode ) ) { string allow from value = this . allow from strategy . get allow from value ( request ) ; if ( x . deny . get mode ( ) . equals ( allow from value ) ) { if ( ! response . contains header ( xframe options header ) ) { response . set header ( xframe options header , x . deny . get mode ( ) ) ; } } else if ( allow from value != null ) { if ( ! response . contains header ( xframe options header ) ) { response . set header ( xframe options header , x . allow from . get mode ( ) + str + allow from value ) ; } } } else { response . set header ( xframe options header , frame options mode . get mode ( ) ) ; } }	Writes the X-Frame-Options header value, overwritting any previous value.
protected string determine target url ( http servlet request request , http servlet response response , authentication authentication ) { return determine target url ( request , response ) ; }	Builds the target URL according to the logic defined in the main class Javadoc.
protected string determine target url ( http servlet request request , http servlet response response ) { if ( is always use default target url ( ) ) { return default target url ; }	Builds the target URL according to the logic defined in the main class Javadoc.
public void set target url parameter ( string target url parameter ) { if ( target url parameter != null ) { assert . has text ( target url parameter , str ) ; } this . target url parameter = target url parameter ; }	If this property is set, the current request will be checked for this a parameterwith this name and the value used as the target URL if present.
private directory get directory with immediate parent populated ( final long id ) { return get jdbc template ( ) . query for object ( select from directory single , new object [ ] { id } , new row mapper < directory > ( ) { public directory map row ( result set rs , int row number ) throws sql { long parent directory id = new long ( rs . get long ( str ) ) ; directory parent directory = directory . root directory ; if ( parent directory id != null && ! parent directory id . equals ( new long ( - num ) ) ) {	Executes recursive SQL as needed to build a full Directory hierarchy of objects.
public distinguished name build dn ( string username ) { distinguished name dn = new distinguished name ( user dn base ) ; dn . add ( username attribute , username ) ; return dn ; }	Assembles the Distinguished Name that should be used the given username.
private map < class < ? extends object > , object > create shared objects ( ) { map < class < ? extends object > , object > shared objects = new hash map < class < ? extends object > , object > ( ) ; shared objects . put all ( local configure authentication bldr . get shared objects ( ) ) ; shared objects . put ( user details service . class , user details service ( ) ) ; shared objects . put ( application context . class , context ) ; shared objects . put ( content negotiation strategy . class , content negotiation strategy ) ; shared objects . put ( authentication trust resolver . class , trust resolver ) ; return shared objects ; }	Creates the shared objects.
private void configure jaas using loop ( ) throws io { string login config url = convert login config to url ( ) ; boolean already set = bool ; int n = num ; final string prefix = str ; string existing ; while ( ( existing = security . get property ( prefix + n ) ) != null ) { already set = existing . equals ( login config url ) ; if ( already set ) { break ; } n ++ ; } if ( ! already set ) { string key = prefix + n ; log . debug ( str + key + str + login config url ) ; security . set property ( key , login config url ) ; } }	Loops through the login.config.url.1,login.config.url.2 properties looking for thelogin configuration.
public static string get current date ( ) { long now = system . current time millis ( ) ; if ( ( now - current date generated ) > num ) { synchronized ( format ) { if ( ( now - current date generated ) > num ) { current date generated = now ; current date = format . format ( new date ( now ) ) ; } } } return current date ; }	Gets the current date in HTTP format.
private static long internal parse date ( string value , date format [ ] formats ) { date date = null ; for ( int i = num ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( parse exception ignored ) { } } if ( date == null ) { return null ; } return new long ( date . get time ( ) ) ; }	Parses date with given formatters.
@ suppress warnings ( str ) private static void update cache ( hash map cache , object key , object value ) { if ( value == null ) { return ; } if ( cache . size ( ) > num ) { cache . clear ( ) ; } cache . put ( key , value ) ; }	Updates cache.
protected void set details ( http servlet request request , username password authentication token auth request ) { auth request . set details ( authentication details source . build details ( request ) ) ; }	Provided so that subclasses may configure what is put into the authenticationrequest's details property.
private static string get security name ( final subject subject ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + subject ) ; } string user security name = null ; if ( subject != null ) {	Get the security name for the given subject.
@ suppress warnings ( str ) private static list < string > get web sphere groups ( final string security name ) { context ic = null ; try {	Get the WebSphere group names for the given security name.
protected distinguished name build group dn ( string group ) { distinguished name dn = new distinguished name ( group search base ) ; dn . add ( group role attribute name , group . to lower case ( ) ) ; return dn ; }	Creates a DN from a group name.
protected void allowable sessions exceeded ( list < session information > sessions , int allowable sessions , session registry registry ) throws session authentication exception { if ( exception if maximum exceeded || ( sessions == null ) ) { throw new session authentication exception ( messages . get message ( str , new object [ ] { integer . value of ( allowable sessions ) } , str ) ) ; }	Allows subclasses to customise behaviour when too many sessions are detected.
private void copy details ( authentication source , authentication dest ) { if ( ( dest instanceof abstract authentication token ) && ( dest . get details ( ) == null ) ) { abstract authentication token token = ( abstract authentication token ) dest ; token . set details ( source . get details ( ) ) ; } }	Copies the authentication details from a source Authentication object to adestination one, provided the latter does not already have one set.
private list < filter > get filters ( http servlet request request ) { for ( security filter chain chain : filter chains ) { if ( chain . matches ( request ) ) { return chain . get filters ( ) ; } } return null ; }	Returns the first filter chain matching the supplied URL.
public list < filter > get filters ( string url ) { return get filters ( firewall . get firewalled request ( ( new filter invocation ( url , str ) . get request ( ) ) ) ) ; }	Convenience method, mainly for testing.
protected application context get context ( page context page context ) { servlet context servlet context = page context . get servlet context ( ) ; return security web application context utils . find required web application context ( servlet context ) ; }	Allows test cases to override where application context obtained from.
public static distinguished name get full dn ( distinguished name dn , context base ctx ) throws naming exception { distinguished name base dn = new distinguished name ( base ctx . get name in namespace ( ) ) ; if ( dn . contains ( base dn ) ) { return dn ; } base dn . append ( dn ) ; return base dn ; }	Gets the full dn of a name by prepending the name of the context it is relative to.If the name already contains the base name, it is returned unaltered.
public mock mvc request specification session attrs ( map < string , object > session attributes ) { not null ( session attributes , str ) ; parameter updater . update parameters ( convert ( cfg . get mock mvc param config ( ) . session attributes update strategy ( ) ) , session attributes , this . session attributes ) ; return this ; }	Set session attributes.
public authentication scheme basic ( string user name , string password ) { final preemptive basic auth scheme preemptive basic auth scheme = new preemptive basic auth scheme ( ) ; preemptive basic auth scheme . set user name ( user name ) ; preemptive basic auth scheme . set password ( password ) ; return preemptive basic auth scheme ; }	Use preemptive http basic authentication.
public static void filters ( list < filter > filters ) { validate . not null ( filters , str ) ; rest assured . filters . add all ( filters ) ; }	Add default filters that will be applied to each request.
public static void filters ( filter filter , filter ... additional filters ) { validate . not null ( filter , str ) ; rest assured . filters . add ( filter ) ; if ( additional filters != null ) { collections . add all ( rest assured . filters , additional filters ) ; } }	Add default filters to apply to each request.
public static authentication scheme basic ( string user name , string password ) { final basic auth scheme scheme = new basic auth scheme ( ) ; scheme . set user name ( user name ) ; scheme . set password ( password ) ; return scheme ; }	Create a http basic authentication scheme.
public static authentication scheme ntlm ( string user name , string password , string workstation , string domain ) { final ntlm scheme = new ntlm ( ) ; scheme . set user name ( user name ) ; scheme . set password ( password ) ; scheme . set workstation ( workstation ) ; scheme . set domain ( domain ) ; return scheme ; }	Create a NTLM authentication scheme.
public static authentication scheme form ( string user name , string password , form auth config config ) { if ( user name == null ) { throw new illegal argument exception ( str ) ; } if ( password == null ) { throw new illegal argument exception ( str ) ; } final form auth scheme scheme = new form auth scheme ( ) ; scheme . set user name ( user name ) ; scheme . set password ( password ) ; scheme . set config ( config ) ; return scheme ; }	Use form authentication with the supplied configuration.
public static void proxy ( uri uri ) { if ( uri == null ) { throw new illegal argument exception ( str ) ; } proxy ( new proxy specification ( uri . get host ( ) , uri . get port ( ) , uri . get scheme ( ) ) ) ; }	Instruct REST Assured to connect to a proxy using a URI.
public static string print ( response options response options , response body response body , print stream stream , log detail log detail , boolean should pretty print ) { final string builder builder = new string builder ( ) ; if ( log detail == all || log detail == status ) { builder . append ( response options . status line ( ) ) ; } if ( log detail == all || log detail == headers ) { final headers headers = response options . headers ( ) ; if ( headers . exist ( ) ) { append new line if all ( log detail , builder ) . append ( to string ( headers ) ) ; } } else if ( log detail == cookies ) { final cookies cookies = response options . detailed cookies ( ) ; if ( cookies . exist ( ) ) { append new line if all ( log detail , builder ) . append ( cookies . to string ( ) ) ; } } if ( log detail == all || log detail == body ) { string response body to append ; if ( should pretty print ) { response body to append = new prettifier ( ) . get prettified body if possible ( response options , response body ) ; } else { response body to append = response body . as string ( ) ; } if ( log detail == all && ! is blank ( response body to append ) ) { builder . append ( system utils . line separator ) . append ( system utils . line separator ) ; } builder . append ( response body to append ) ; } string response = builder . to string ( ) ; stream . println ( response ) ; return response ; }	Prints the response to the print stream.
public rest assured config redirect ( redirect config redirect config ) { not null ( redirect config , str ) ; return new rest assured config ( redirect config , conf ( http client config . class ) , conf ( log config . class ) , conf ( encoder config . class ) , conf ( decoder config . class ) , conf ( session config . class ) , conf ( object mapper config . class ) , conf ( connection config . class ) , conf ( json config . class ) , conf ( xml config . class ) , conf ( ssl . class ) , conf ( matcher config . class ) , conf ( header config . class ) , conf ( multi part config . class ) , conf ( param config . class ) , conf ( o . class ) , conf ( failure config . class ) ) ; }	Set the redirect config.
public encoder config default query parameter charset ( string charset ) { return new encoder config ( default content charset , charset , should append default content charset to content type if undefined , content encoders , content type to default charset , bool ) ; }	Specify the default charset for query parameters.
public object mapper config default object mapper type ( object mapper type default object mapper type ) { return new object mapper config ( default object mapper , default object mapper type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , jaxb object mapper factory , johnzon object mapper factory , bool ) ; }	Creates an object mapper configuration that uses the specified object mapper as default.
public object mapper config jaxb object mapper factory ( jaxb jaxb object mapper factory ) { return new object mapper config ( default object mapper , default object mapper type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , jaxb object mapper factory , johnzon object mapper factory , bool ) ; }	Specify a custom JAXB object mapper factory.
public rest assured mock mvc config log config ( log config log config ) { not null ( log config , str ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the Log config.
public rest assured mock mvc config session config ( session config session config ) { not null ( session config , str ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the session config.
public rest assured mock mvc config object mapper config ( object mapper config object mapper config ) { not null ( object mapper config , str ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the object mapper config.
public rest assured mock mvc config json config ( json config json config ) { not null ( json config , str ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the Json config.
public rest assured mock mvc config xml config ( xml config xml config ) { not null ( xml config , str ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the Xml config.
public rest assured mock mvc config encoder config ( encoder config encoder config ) { not null ( encoder config , str ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the encoder config.
public rest assured mock mvc config header config ( header config header config ) { not null ( header config , str ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the header config.
public rest assured mock mvc config async config ( async config async config ) { not null ( async config , async config . class ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the async config.
public rest assured mock mvc config mock mvc config ( mock mvc config mock mvc config ) { not null ( mock mvc config , mock mvc config . class ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the MockMVC config.
public rest assured mock mvc config multi part config ( multi part config multi part config ) { not null ( multi part config , multi part config . class ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the multi-part config.
public rest assured mock mvc config param config ( mock mvc param config param config ) { not null ( param config , multi part config . class ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the parameter config.
public rest assured mock mvc config matcher config ( matcher config matcher config ) { not null ( matcher config , matcher config . class ) ; return new rest assured mock mvc config ( log config , encoder config , decoder config , session config , object mapper config , json config , xml config , header config , async config , multi part config , mock mvc config , param config , matcher config ) ; }	Set the matcher config.
public certificate auth settings allow all hostnames ( ) { return new certificate auth settings ( keystore type , trust store type , port , trust store , key store , allow all hostname verifier , ssl socket factory ) ; }	Configure the CertificateAuthSettings to allow all host names.
public xml path config declare namespaces ( map < string , string > namespaces to declare ) { return new xml path config ( jaxb object mapper factory , default parser type , default deserializer , charset , features , namespaces to declare , properties , validating , namespace aware , allow doc type declaration ) ; }	Specify declared namespaces that will be used when parsing XML.
public xml path config declared namespace ( string prefix , string namespace uri ) { validate . not empty ( prefix , str ) ; validate . not empty ( namespace uri , str ) ; map < string , string > updated namespaces = new hash map < string , string > ( declared namespaces ) ; updated namespaces . put ( prefix , namespace uri ) ; return new xml path config ( jaxb object mapper factory , default parser type , default deserializer , charset , features , updated namespaces , properties , validating , bool , allow doc type declaration ) ; }	Declares a namespace.
public object request ( string method , boolean has body , closure config closure ) throws client protocol exception , io { return this . do request ( this . default uri . to uri ( ) , method , this . default content type , has body , config closure ) ; }	Make an HTTP request to the default URI, and parse using the defaultcontent-type.
public void set headers ( map < ? , ? > headers ) { this . default request headers . clear ( ) ; if ( headers == null ) return ; for ( object key : headers . key set ( ) ) { object val = headers . get ( key ) ; if ( val == null ) continue ; this . default request headers . put ( key . to string ( ) , val . to string ( ) ) ; } }	Set the default headers to add to all requests made by this builderinstance.
public void set proxy ( string host , int port , string scheme ) { get client ( ) . get params ( ) . set parameter ( p . default proxy , new http host ( host , port , scheme ) ) ; }	Set the default HTTP proxy to be used for all requests.
public multi part spec builder control name ( string control name ) { validate . not empty ( control name , str ) ; this . control name = control name ; this . is control name explicit = bool ; return this ; }	Specify the control name of this multi-part.
public multi part spec builder header ( string name , string value ) { validate . not empty ( name , str ) ; validate . not empty ( value , str ) ;	Add a header to this multipart specification.
public void basic ( string host , int port , string user , string pass ) { builder . get client ( ) . get credentials provider ( ) . set credentials ( new auth scope ( host , port ) , new username password credentials ( user , pass ) ) ; }	Set authentication credentials to be used for the given host and port.
public void ntlm ( string host , int port , string user , string pass , string workstation , string domain ) { builder . get client ( ) . get credentials provider ( ) . set credentials ( new auth scope ( host , port ) , new nt ( user , pass , workstation , domain ) ) ; }	Set NTLM authentication credentials to be used for the given host and port.
public static headers headers ( header header , header ... additional headers ) { not null ( header , str ) ; final list < header > header list = new linked list < header > ( ) ; header list . add ( header ) ; if ( additional headers != null ) { collections . add all ( header list , additional headers ) ; } return new headers ( header list ) ; }	An alternative way to create a Headers object from the constructor.
public static void reset ( ) { mock mvc factory = null ; config = null ; base path = str ; result handlers . clear ( ) ; request post processors . clear ( ) ; response specification = null ; request specification = null ; authentication = null ; }	Reset all static configurations to their default values.
public response builder set header ( string name , string value ) { not null ( name , str ) ; not null ( value , str ) ; list < header > new headers = new array list < header > ( rest assured response . headers ( ) . as list ( ) ) ; new headers . add ( new header ( name , value ) ) ; rest assured response . set response headers ( new headers ( new headers ) ) ; if ( trim ( name ) . equals ignore case ( content type ) ) { rest assured response . set content type ( value ) ; } return this ; }	Set a specific header.
public response build ( ) { final int status code = rest assured response . status code ( ) ; if ( status code < num || status code >= num ) { throw new illegal argument exception ( format ( str , status code ) ) ; } if ( string utils . is blank ( rest assured response . status line ( ) ) ) { rest assured response . set status line ( rest assured response . status code ( ) ) ; } rest assured response . set rpr ( new response parser registrar ( ) ) ; return rest assured response ; }	Build the actual response.
public detailed cookie matcher value ( matcher < ? super string > value matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , value matcher ) ) ) ; }	Verifies whether value of cookie satisfies specified matcher.
public detailed cookie matcher comment ( matcher < ? super string > comment matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , comment matcher ) ) ) ; }	Verifies whether comment of cookie satisfies specified matcher.
public detailed cookie matcher expiry date ( matcher < ? super date > expiry date matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , expiry date matcher ) ) ) ; }	Verifies whether expiry date of cookie satisfies specified matcher.
public detailed cookie matcher domain ( matcher < ? super string > domain matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , domain matcher ) ) ) ; }	Verifies whether domain of cookie satisfies specified matcher.
public detailed cookie matcher path ( matcher < ? super string > path matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , path matcher ) ) ) ; }	Verifies whether path of cookie satisfies specified matcher.
public detailed cookie matcher secured ( matcher < ? super boolean > secured matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , secured matcher ) ) ) ; }	Verifies whether secured property of cookie satisfies specified matcher.
public detailed cookie matcher http only ( matcher < ? super boolean > http only matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , http only matcher ) ) ) ; }	Verifies whether http-only property of cookie satisfies specified matcher.
public detailed cookie matcher version ( matcher < ? super integer > version matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , version matcher ) ) ) ; }	Verifies whether version of cookie satisfies specified matcher.
public detailed cookie matcher max age ( matcher < ? super integer > max age matcher ) { return new detailed cookie matcher ( and ( matchers . has property ( str , max age matcher ) ) ) ; }	Verifies whether max age of cookie satisfies specified matcher.
public response spec builder expect header ( string header name , matcher < string > expected value matcher ) { spec . header ( header name , expected value matcher ) ; return this ; }	Expect that a response header matches the supplied header name and hamcrest matcher.
public response spec builder expect header ( string header name , string expected value ) { spec . header ( header name , expected value ) ; return this ; }	Expect that a response header matches the supplied name and value.
public response spec builder expect cookie ( string cookie name , string expected value ) { spec . cookie ( cookie name , expected value ) ; return this ; }	Expect that a response cookie matches the supplied name and value.
public proxy specification with host ( string host ) { return new proxy specification ( host , port , scheme , username , password ) ; }	Specify the hostname of the proxy.
public json path config number return type ( number return type number return type ) { return new json path config ( number return type , default parser type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , johnzon object mapper factory , default deserializer , charset ) ; }	Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers.
public json path config default parser type ( json parser type default parser type ) { return new json path config ( number return type , default parser type , gson object mapper factory , jackson1 object mapper factory , jackson2 object mapper factory , johnzon object mapper factory , default deserializer , charset ) ; }	Creates an json path configuration that uses the specified parser type as default.
public log config default stream ( print stream print stream ) { return new log config ( print stream , bool , log detail if validation fails , url encode request uri , bool ) ; }	Specify a new default stream to the print to.
public log config enable logging of request and response if validation fails ( log detail log detail ) { return new log config ( default print stream , pretty printing enabled , log detail , url encode request uri , bool ) ; }	Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail.
static http request base create http request ( uri uri , string http method , boolean has body ) { string method = not null ( upper case ( trim to null ( http method ) ) , str ) ; class < ? extends http request base > type = http method to http request type . get ( method ) ; final http request base http request ;	Get the HttpRequest class that represents this request type.
public multi part config default boundary ( string default boundary ) { return new multi part config ( default control name , default file name , default subtype , default boundary , default charset , bool ) ; }	Specify an explicit default multipart boundary to use when sending multi-part data.
public mock mvc request spec builder add attribute ( string attribute name , object attribute value ) { spec . attribute ( attribute name , attribute value ) ; return this ; }	Add request attribute.
public mock mvc request spec builder add header ( string header name , string header value ) { spec . header ( header name , header value ) ; return this ; }	Add a header to be sent with the request.
public mock mvc request spec builder add multi part ( string control name , string content body , string mime type ) { spec . multi part ( control name , mime type ) ; return this ; }	Specify a string to send to the server using multi-part form data with a specific mime-type.
public mock mvc request spec builder add result handlers ( result handler result handler , result handler ... additional result handlers ) { spec . result handlers ( result handler , additional result handlers ) ; return this ; }	Add a result handler.
public < t > http client config set param ( string parameter name , t parameter value ) { not null ( parameter name , str ) ; final map < string , object > new params = new hash map < string , object > ( http client params ) ; new params . put ( parameter name , parameter value ) ; return new http client config ( http client factory , new params , http multipart mode , should reuse http client instance , no http client , bool ) ; }	Set a http client parameter.
public http client config add params ( map < string , ? > http client params ) { not null ( http client params , str ) ; final map < string , object > new params = new hash map < string , object > ( this . http client params ) ; new params . put all ( http client params ) ; return new http client config ( http client factory , new params , http multipart mode , should reuse http client instance , no http client , bool ) ; }	Add the given parameters to an already configured number of parameters.
public http client config http client factory ( http client factory http client factory ) { return new http client config ( http client factory , http client params , http multipart mode , should reuse http client instance , no http client , bool ) ; }	Set the http client factory that Rest Assured should use when making request.
public http client config http multipart mode ( http multipart mode http multipart mode ) { return new http client config ( http client factory , http client params , http multipart mode , should reuse http client instance , http client , bool ) ; }	Specify the HTTP Multipart mode when sending multi-part data.
public < t > t get ( string path ) { final json json assertion = create json assertion ( path , params ) ; final object json = json parser . parse with ( create configurable json slurper ( ) ) ; return ( t ) json assertion . get result ( json , null ) ; }	Get the result of an Object path expression as a boolean.
public int get int ( string path ) {	Get the result of an Object path expression as an int.
public byte get byte ( string path ) {	Get the result of an Object path expression as a byte.
public short get short ( string path ) {	Get the result of an Object path expression as a short.
public float get float ( string path ) { final object value = get ( path ) ;	Get the result of an Object path expression as a float.
public double get double ( string path ) { final object value = get ( path ) ; if ( value instanceof double ) { return ( double ) value ; } return object converter . convert object to ( value , double . class ) ; }	Get the result of an Object path expression as a double.
public long get long ( string path ) {	Get the result of an Object path expression as a long.
public < t > list < t > get list ( string path , class < t > generic type ) { if ( generic type == null ) { throw new illegal argument exception ( str ) ; } final list < t > original = get ( path ) ; final list < t > new list = new linked list < t > ( ) ; if ( original != null ) { for ( t t : original ) { t e ; if ( t instanceof map && ! generic type . is assignable from ( map . class ) ) {	Get the result of an Object path expression as a list.
public < k , v > map < k , v > get map ( string path ) { return get ( path ) ; }	Get the result of an Object path expression as a map.
public < t > t get object ( string path , class < t > object type ) { object object = get from path ( path , bool ) ; return get object as type ( object , object type ) ; }	Get an XML document as a Java Object.
public request spec builder set body ( object object , object mapper mapper ) { spec . body ( object , mapper ) ; return this ; }	Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper.This works for the POST, PATCH and PUT methods only.
public request spec builder add cookie ( string key , object value , object ... cookie name value pairs ) { spec . cookie ( key , value , cookie name value pairs ) ; return this ; }	Add a cookie to be sent with the request.
public request spec builder add param ( string parameter name , object ... parameter values ) { spec . param ( parameter name , parameter values ) ; return this ; }	Add a parameter to be sent with the request.
public request spec builder add param ( string parameter name , collection < ? > parameter values ) { spec . param ( parameter name , parameter values ) ; return this ; }	Add a multi-value parameter to be sent with the request.
public mock mvc param config form params update strategy ( update strategy update strategy ) { return new mock mvc param config ( query params update strategy , update strategy , request parameter update strategy , attribute update strategy , session update strategy , bool ) ; }	Set form parameter update strategy to the given value.
public static filter log response to if matches ( print stream stream , matcher < integer > matcher ) { return new response logging filter ( stream , matcher ) ; }	Create a new logging filter without using the "new" operator.Will make the DSL look nicer.
public static cookies cookies ( cookie cookie , cookie ... additional cookies ) { assert parameter . not null ( cookie , str ) ; final list < cookie > cookie list = new linked list < cookie > ( ) ; cookie list . add ( cookie ) ; collections . add all ( cookie list , additional cookies ) ; return new cookies ( cookie list ) ; }	An alternative way to create a Cookies object from the constructor.
private void clean up for collected state ( set < key and source > keys and sources ) { synchronized ( lock ) { for ( key and source key and source : keys and sources ) { multiset < object > set = backing map . get ( key and source . key ) ; if ( set != null ) { set . remove ( key and source . source ) ; if ( set . is empty ( ) ) { backing map . remove ( key and source . key ) ; } } } } }	There may be multiple child injectors blacklisting a certain key so only remove the sourcethat's relevant.
void index ( ) { for ( binding < ? > binding : state . get explicit bindings this level ( ) . values ( ) ) { bindings multimap . put ( binding . get key ( ) . get type literal ( ) , binding ) ; } }	Indexes bindings by type.
< t > binding impl < t > get binding or throw ( key < t > key , errors errors , jit limitation jit type ) throws errors exception {	Gets a binding implementation.
private < t > binding impl < t > convert constant string binding ( key < t > key , errors errors ) throws errors exception {	Converts a constant string binding to the required type.
private boolean cleanup ( binding impl < ? > binding , set < key > encountered ) { boolean binding failed = bool ; set < dependency < ? > > deps = get internal dependencies ( binding ) ; for ( dependency dep : deps ) { key < ? > dep key = dep . get key ( ) ; injection point ip = dep . get injection point ( ) ; if ( encountered . add ( dep key ) ) {	Iterates through the binding's dependencies to clean up any stray bindings that were leftoverfrom a failed JIT binding.
private void remove failed jit binding ( binding < ? > binding , injection point ip ) { failed jit bindings . add ( binding . get key ( ) ) ; jit bindings . remove ( binding . get key ( ) ) ; members injector store . remove ( binding . get key ( ) . get type literal ( ) ) ; provision listener store . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }	Cleans up any state that may have been cached when constructing the JIT binding.
@ suppress warnings ( str ) private set < dependency < ? > > get internal dependencies ( binding impl < ? > binding ) { if ( binding instanceof constructor binding impl ) { return ( ( constructor binding impl ) binding ) . get internal dependencies ( ) ; } else if ( binding instanceof has dependencies ) { return ( ( has dependencies ) binding ) . get dependencies ( ) ; } else { return immutable set . of ( ) ; } }	Safely gets the dependencies of possibly not initialized bindings.
< t > binding impl < t > create uninitialized binding ( key < t > key , scoping scoping , object source , errors errors , boolean jit binding ) throws errors exception { class < ? > raw type = key . get type literal ( ) . get raw type ( ) ; implemented by implemented by = raw type . get annotation ( implemented by . class ) ;	Creates a binding for an injectable type with the given scope.
static object [ ] get all ( internal context context , single parameter injector < ? > [ ] parameter injectors ) throws internal provision exception { if ( parameter injectors == null ) { return no arguments ; } int size = parameter injectors . length ; object [ ] parameters = new object [ size ] ;	Returns an array of parameter values.
private static void bind injector ( injector impl injector ) { key < injector > key = key . get ( injector . class ) ; injector factory injector factory = new injector factory ( injector ) ; injector . state . put binding ( key , new provider instance binding impl < injector > ( injector , key , source provider . unknown source , injector factory , scoping . unscoped , injector factory , immutable set . < injection point > of ( ) ) ) ; }	The Injector is a special case because we allow both parent and child injectors to both have abinding for that key.
private static void bind logger ( injector impl injector ) { key < logger > key = key . get ( logger . class ) ; logger factory logger factory = new logger factory ( ) ; injector . state . put binding ( key , new provider instance binding impl < logger > ( injector , key , source provider . unknown source , logger factory , scoping . unscoped , logger factory , immutable set . < injection point > of ( ) ) ) ; }	The Logger is a special case because it knows the injection point of the injected member.
private static boolean check for misplaced binding annotations ( member member , errors errors ) { annotation misplaced binding annotation = annotations . find binding annotation ( errors , member , ( ( annotated element ) member ) . get annotations ( ) ) ; if ( misplaced binding annotation == null ) { return bool ; }	Returns true if the binding annotation is in the wrong place.
private static boolean overrides ( method a , method b ) {	Returns true if a overrides b.
public void initialize delegate ( members injector < t > delegate ) { check state ( this . delegate == null , str ) ; this . delegate = check not null ( delegate , str ) ; }	Sets the actual members injector.
@ suppress warnings ( str ) final type literal < provider < t > > provider type ( ) {	Gets the type of this type's provider.
private list < type literal < ? > > resolve all ( type [ ] types ) { type literal < ? > [ ] result = new type literal < ? > [ types . length ] ; for ( int t = num ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return immutable list . copy of ( result ) ; }	Returns an immutable list of the resolved types.
public static < t > type literal < t > canonicalize for key ( type literal < t > type literal ) { type type = type literal . get type ( ) ; if ( ! is fully specified ( type ) ) { errors errors = new errors ( ) . key not fully specified ( type literal ) ; throw new configuration exception ( errors . get messages ( ) ) ; } if ( type literal . get raw type ( ) == javax . inject . provider . class ) { parameterized type parameterized type = ( parameterized type ) type ;	Returns an type that's appropriate for use in a key. If the raw type of {.
static void prepare built in converters ( injector impl injector ) {	Installs default converters for primitives, enums, and class literals.
private static class loader canonicalize ( class loader class loader ) { return class loader != null ? class loader : system bridge holder . system bridge . get parent ( ) ; }	Attempts to canonicalize null references to the system class loader.
private static boolean has same version of cglib ( class loader class loader ) { class < ? > fc = net . sf . cglib . reflect . fast class . class ; try { return class loader . load class ( fc . get name ( ) ) == fc ; } catch ( class not found exception e ) { return bool ; } }	Returns true if the types classloader has the same version of cglib that BytecodeGen has.
private static boolean is publicly callable ( member member ) { if ( ! modifier . is public ( member . get modifiers ( ) ) ) { return bool ; } class < ? > [ ] parameter types ; if ( member instanceof constructor ) { parameter types = ( ( constructor ) member ) . get parameter types ( ) ; } else { method method = ( method ) member ; if ( ! modifier . is public ( method . get return type ( ) . get modifiers ( ) ) ) { return bool ; } parameter types = method . get parameter types ( ) ; } for ( class < ? > type : parameter types ) { if ( ! modifier . is public ( type . get modifiers ( ) ) ) { return bool ; } } return bool ; }	Returns true if the member can be called by a fast class generated in a different classloader.
public key < ? > fix annotations ( key < ? > key ) { return key . get annotation ( ) == null ? key : key . get ( key . get type literal ( ) , key . get annotation ( ) . annotation type ( ) ) ; }	Replace annotation instances with annotation types, this is only appropriate for testing if akey is bound and not for injecting.
< t > initializable < t > request injection ( injector impl injector , t instance , binding < t > binding , object source , set < injection point > injection points ) { check not null ( source ) ; preconditions . check state ( ! validation started , str ) ; provision listener stack callback < t > provision callback = binding == null ? null : injector . provision listener store . get ( binding ) ;	Registers an instance for member injection when that step is performed.
void validate oustanding injections ( errors errors ) { validation started = bool ; initializables cache . clear ( ) ; for ( injectable reference < ? > reference : pending injections ) { try { reference . validate ( errors ) ; } catch ( errors exception e ) { errors . merge ( e . get errors ( ) ) ; } } }	Prepares member injectors for all injected instances.
public t new instance ( object [ ] args ) throws throwable { constructor . set accessible ( bool ) ; try { return constructor . new instance ( args ) ; } catch ( invocation target exception e ) { throw e . get cause ( ) ; } }	Returns an instance of T, constructed using this constructor, with the supplied arguments.
static < t > internal factory < ? extends t > scope ( key < t > key , injector impl injector , internal factory < ? extends t > creator , object source , scoping scoping ) { if ( scoping . is no scope ( ) ) { return creator ; } scope scope = scoping . get scope instance ( ) ;	Scopes an internal factory.
static scoping make injectable ( scoping scoping , injector impl injector , errors errors ) { class < ? extends annotation > scope annotation = scoping . get scope annotation ( ) ; if ( scope annotation == null ) { return scoping ; } scope binding scope = injector . state . get scope binding ( scope annotation ) ; if ( scope != null ) { return for instance ( scope . get scope ( ) ) ; } errors . scope not found ( scope annotation ) ; return unscoped ; }	Replaces annotation scopes with instance scopes using the Injector's annotation-to-instancemap.
static string normalize path ( string path ) { string builder sb = new string builder ( path . length ( ) ) ; int query start = path . index of ( str ) ; string query = null ; if ( query start != - num ) { query = path . substring ( query start ) ; path = path . substring ( num , query start ) ; }	Normalizes a path by unescaping all safe, percent encoded characters.
public static < t extends annotation > t generate annotation ( class < t > annotation type ) { preconditions . check state ( is all default methods ( annotation type ) , str , annotation type ) ; return ( t ) cache . get unchecked ( annotation type ) ; }	Generates an Annotation for the annotation class.
public static boolean is retained at runtime ( class < ? extends annotation > annotation type ) { retention retention = annotation type . get annotation ( retention . class ) ; return retention != null && retention . value ( ) == retention policy . runtime ; }	Returns true if the given annotation is retained at runtime.
public static class < ? extends annotation > find scope annotation ( errors errors , annotation [ ] annotations ) { class < ? extends annotation > found = null ; for ( annotation annotation : annotations ) { class < ? extends annotation > annotation type = annotation . annotation type ( ) ; if ( is scope annotation ( annotation type ) ) { if ( found != null ) { errors . duplicate scope annotations ( found , annotation type ) ; } else { found = annotation type ; } } } return found ; }	Returns the scoping annotation, or null if there isn't one.
public static key < ? > get key ( type literal < ? > type , member member , annotation [ ] annotations , errors errors ) throws errors exception { int num errors before = errors . size ( ) ; annotation found = find binding annotation ( errors , member , annotations ) ; errors . throw if new errors ( num errors before ) ; return found == null ? key . get ( type ) : key . get ( type , found ) ; }	Gets a key for the given type, member and annotations.
public static string name of ( key < ? > key ) { annotation annotation = key . get annotation ( ) ; class < ? extends annotation > annotation type = key . get annotation type ( ) ; if ( annotation != null && ! is marker ( annotation type ) ) { return key . get annotation ( ) . to string ( ) ; } else if ( key . get annotation type ( ) != null ) { return str + key . get annotation type ( ) . get name ( ) ; } else { return str ; } }	Returns the name the binding should use.
public void initialize delegate ( provider < t > delegate ) { check state ( this . delegate == null , str ) ; this . delegate = check not null ( delegate , str ) ; }	Sets the actual provider.
private void add direct type binding ( binder binder ) { binder . bind ( binding selection . get direct key ( ) ) . to provider ( new real direct type provider < t > ( binding selection ) ) ; }	Adds a binding for T.
public constructor injector < ? > get ( injection point constructor injector , errors errors ) throws errors exception { return cache . get ( constructor injector , errors ) ; }	Returns a new complete constructor injector with injection listeners registered.
private static boolean has scope ( class < ? extends interceptor > interceptor class ) { for ( annotation annotation : interceptor class . get annotations ( ) ) { if ( annotations . is scope annotation ( annotation . annotation type ( ) ) ) { return bool ; } } return bool ; }	Returns true if the given class has a scope annotation.
static < k , v > real map binder < k , v > new real map binder ( binder binder , type literal < k > key type , key < v > value type and annotation ) { binder = binder . skip sources ( real map binder . class ) ; type literal < v > value type = value type and annotation . get type literal ( ) ; return new real map binder ( binder , key type , value type , value type and annotation . of type ( map of ( key type , value type ) ) , real multibinder . new real set binder ( binder , value type and annotation . of type ( entry of provider of ( key type , value type ) ) ) ) ; }	since it's an easy way to group a type and an optional annotation type or instance.
key < v > get key for new value ( k key ) { check not null ( key , str ) ; check configuration ( ! binding selection . is initialized ( ) , str ) ; real multibinder < map . entry < k , provider < v > > > entry set binder = binding selection . get entry set binder ( ) ; key < v > value key = key . get ( binding selection . get value type ( ) , new real element ( entry set binder . get set name ( ) , mapbinder , binding selection . get key type ( ) . to string ( ) ) ) ; entry set binder . add binding ( ) . to provider ( new provider map entry < k , v > ( key , value key ) ) ; return value key ; }	Adds a binding to the map for the given key.
private t provision ( internal context context , construction context < t > construction context ) throws internal provision exception { try { t t ; try { object [ ] parameters = single parameter injector . get all ( context , parameter injectors ) ; t = construction proxy . new instance ( parameters ) ; construction context . set proxy delegates ( t ) ; } finally { construction context . finish construction ( ) ; }	Provisions a new T.
private object write replace ( ) throws object stream exception { object [ ] sources as strings = sources . to array ( ) ; for ( int i = num ; i < sources as strings . length ; i ++ ) { sources as strings [ i ] = errors . convert ( sources as strings [ i ] ) . to string ( ) ; } return new message ( immutable list . copy of ( sources as strings ) , message , cause ) ; }	When serialized, we eagerly convert sources to strings.
static module for module ( module module ) {	Returns a module which creates bindings for provider methods from the given module.
@ override @ suppress warnings ( str ) public collection < assisted method > get assisted methods ( ) { return ( collection < assisted method > ) ( collection < ? > ) assist data by method . values ( ) ; }	the collection is immutable.
private boolean is type not specified ( type literal < ? > type literal , configuration exception ce ) { collection < message > messages = ce . get error messages ( ) ; if ( messages . size ( ) == num ) { message msg = iterables . get only element ( new errors ( ) . key not fully specified ( type literal ) . get messages ( ) ) ; return msg . get message ( ) . equals ( iterables . get only element ( messages ) . get message ( ) ) ; } else { return bool ; } }	Returns true if the ConfigurationException is due to an error of TypeLiteral not being fullyspecified.
private boolean constructor has matching params ( type literal < ? > type , constructor < ? > constructor , list < key < ? > > param list , errors errors ) throws errors exception { list < type literal < ? > > params = type . get parameter types ( constructor ) ; annotation [ ] [ ] param annotations = constructor . get parameter annotations ( ) ; int p = num ; list < key < ? > > constructor keys = lists . new array list ( ) ; for ( type literal < ? > param : params ) { key < ? > param key = annotations . get key ( param , constructor , param annotations [ p ++ ] , errors ) ; constructor keys . add ( param key ) ; }	Matching logic for constructors annotated with AssistedInject. This returns true if and only ifall .
private set < dependency < ? > > get dependencies ( injection point ctor point , type literal < ? > implementation ) { immutable set . builder < dependency < ? > > builder = immutable set . builder ( ) ; builder . add all ( ctor point . get dependencies ( ) ) ; if ( ! implementation . get raw type ( ) . is interface ( ) ) { for ( injection point ip : injection point . for instance methods and fields ( implementation ) ) { builder . add all ( ip . get dependencies ( ) ) ; } } return builder . build ( ) ; }	Calculates all dependencies required by the implementation and constructor.
private set < dependency < ? > > remove assisted deps ( set < dependency < ? > > deps ) { immutable set . builder < dependency < ? > > builder = immutable set . builder ( ) ; for ( dependency < ? > dep : deps ) { class < ? > annotation type = dep . get key ( ) . get annotation type ( ) ; if ( annotation type == null || ! annotation type . equals ( assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }	Return all non-assisted dependencies.
private boolean is valid for optimized assisted inject ( set < dependency < ? > > dependencies , class < ? > implementation , type literal < ? > factory type ) { set < dependency < ? > > bad deps = null ;	Returns true if all dependencies are suitable for the optimized version of AssistedInject.
public binding < ? > get binding from new injector ( final method method , final object [ ] args , final assist data data ) { check state ( injector != null , str ) ; final key < ? > return type = data . return type ;	Creates a child injector that binds the args, and returns the binding for the method's result.
@ override public object invoke ( object proxy , final method method , final object [ ] args ) throws throwable {	When a factory method is invoked, we create a child injector that binds all parameters, thenuse that to get an instance of the return type.
< t > errors missing implementation with hint ( key < t > key , injector injector ) { string builder sb = new string builder ( ) ; sb . append ( format ( str , key ) ) ;	Within guice's core, allow for better missing binding messages.
public static < t > real multibinder < t > new real set binder ( binder binder , key < t > key ) { binder = binder . skip sources ( real multibinder . class ) ; real multibinder < t > result = new real multibinder < > ( binder , key ) ; binder . install ( result ) ; return result ; }	Implementation of newSetBinder.
key < t > get key for new item ( ) { check configuration ( ! binding selection . is initialized ( ) , str ) ; return key . get ( binding selection . get element type literal ( ) , new real element ( binding selection . get set name ( ) , multibinder , str ) ) ; }	Adds a new entry to the set and returns the key for it.
private filter find next filter ( http servlet request request ) { while ( ++ index < filter definitions . length ) { filter filter = filter definitions [ index ] . get filter if matching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }	Iterates over the remaining filter definitions.
private static boolean has at inject ( constructor cxtor ) { return cxtor . is annotation present ( inject . class ) || cxtor . is annotation present ( javax . inject . inject . class ) ; }	Returns true if the inject annotation is on the constructor.
injection point get internal constructor ( ) { if ( factory . constructor injector != null ) { return factory . constructor injector . get construction proxy ( ) . get injection point ( ) ; } else { return constructor injection point ; } }	Returns an injection point that can be used to clean up the constructor store.
set < dependency < ? > > get internal dependencies ( ) { immutable set . builder < injection point > builder = immutable set . builder ( ) ; if ( factory . constructor injector == null ) { builder . add ( constructor injection point ) ;	Returns a set of dependencies that can be iterated over to clean up stray JIT bindings.
public static module for module ( object module , module annotated method scanner scanner ) { return for object ( module , bool , scanner ) ; }	Returns a module which creates bindings methods in the module that match the scanner.
private annotation get annotation ( binder binder , method method ) { if ( method . is bridge ( ) || method . is synthetic ( ) ) { return null ; } annotation annotation = null ; for ( class < ? extends annotation > annotation class : scanner . annotation classes ( ) ) { annotation found annotation = method . get annotation ( annotation class ) ; if ( found annotation != null ) { if ( annotation != null ) { binder . add error ( str + str , scanner , method ) ; return null ; } annotation = found annotation ; } } return annotation ; }	Returns the annotation that is claimed by the scanner, or null if there is none.
public integer get line number ( member member ) { preconditions . check argument ( type == member . get declaring class ( ) , str , member , member . get declaring class ( ) , type ) ; return lines . get ( member key ( member ) ) ; }	Get the line number associated with the given member.
void initialize ( errors errors ) { injector . lookups = injector ; new lookup processor ( errors ) . process ( injector , lookups ) ; }	Initialize the specified lookups, either immediately or when the injector is created.
private static object validate and canonicalize value ( key < ? > key , object object ) { if ( object == null || object == null object . instance ) { return null object . instance ; } if ( ! key . get type literal ( ) . get raw type ( ) . is instance ( object ) ) { throw new illegal argument exception ( str + object + str + object . get class ( ) . get name ( ) + str + key + str ) ; } return object ; }	Validates the key and object, ensuring the value matches the key type, and canonicalizing nullobjects to the null sentinel.
@ suppress warnings ( str )	Returns a new complete members injector with injection listeners registered.
private < t > members injector impl < t > create with listeners ( type literal < t > type , errors errors ) throws errors exception { int num errors before = errors . size ( ) ; set < injection point > injection points ; try { injection points = injection point . for instance methods and fields ( type ) ; } catch ( configuration exception e ) { errors . merge ( e . get error messages ( ) ) ; injection points = e . get partial value ( ) ; } immutable list < single member injector > injectors = get injectors ( injection points , errors ) ; errors . throw if new errors ( num errors before ) ; encounter impl < t > encounter = new encounter impl < > ( errors , injector . lookups ) ; set < type listener > already seen listeners = sets . new hash set ( ) ; for ( type listener binding binding : type listener bindings ) { type listener type listener = binding . get listener ( ) ; if ( ! already seen listeners . contains ( type listener ) && binding . get type matcher ( ) . matches ( type ) ) { already seen listeners . add ( type listener ) ; try { type listener . hear ( type , encounter ) ; } catch ( runtime exception e ) { errors . error notifying type listener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throw if new errors ( num errors before ) ; return new members injector impl < t > ( injector , type , encounter , injectors ) ; }	Creates a new members injector and attaches both injection listeners and method aspects.
immutable list < single member injector > get injectors ( set < injection point > injection points , errors errors ) { list < single member injector > injectors = lists . new array list ( ) ; for ( injection point injection point : injection points ) { try { errors errors for member = injection point . is optional ( ) ? new errors ( injection point ) : errors . with source ( injection point ) ; single member injector injector = injection point . get member ( ) instanceof field ? new single field injector ( this . injector , injection point , errors for member ) : new single method injector ( this . injector , injection point , errors for member ) ; injectors . add ( injector ) ; } catch ( errors exception ignored for now ) {	Returns the injectors for the specified injection points.
static < t > key < t > get ( class < t > type , annotation strategy annotation strategy ) { return new key < t > ( type , annotation strategy ) ; }	Gets a key for an injection type and an annotation strategy.
static annotation strategy strategy for ( annotation annotation ) { check not null ( annotation , str ) ; class < ? extends annotation > annotation type = annotation . annotation type ( ) ; ensure retained at runtime ( annotation type ) ; ensure is binding annotation ( annotation type ) ; if ( annotations . is marker ( annotation type ) ) { return new annotation type strategy ( annotation type , annotation ) ; } return new annotation instance strategy ( annotations . canonicalize if named ( annotation ) ) ; }	Gets the strategy for an annotation.
static annotation strategy strategy for ( class < ? extends annotation > annotation type ) { annotation type = annotations . canonicalize if named ( annotation type ) ; if ( is all default methods ( annotation type ) ) { return strategy for ( generate annotation ( annotation type ) ) ; } check not null ( annotation type , str ) ; ensure retained at runtime ( annotation type ) ; ensure is binding annotation ( annotation type ) ; return new annotation type strategy ( annotation type , null ) ; }	Gets the strategy for an annotation type.
private void prune stacktrace ( throwable throwable ) { for ( throwable t = throwable ; t != null ; t = t . get cause ( ) ) { stack trace element [ ] stack trace = t . get stack trace ( ) ; list < stack trace element > pruned = lists . new array list ( ) ; for ( stack trace element element : stack trace ) { string class name = element . get class name ( ) ; if ( ! aop internal classes . contains ( class name ) && ! class name . contains ( str ) ) { pruned . add ( element ) ; } } t . set stack trace ( pruned . to array ( new stack trace element [ pruned . size ( ) ] ) ) ; } }	Removes stacktrace elements related to AOP internal mechanics from the throwable's stack traceand any causes it may have.
public string get binding source ( ) { if ( source instanceof class ) { return stack trace elements . for type ( ( class ) source ) . to string ( ) ; } else if ( source instanceof member ) { return stack trace elements . for member ( ( member ) source ) . to string ( ) ; } else { return source . to string ( ) ; } }	Returns a string describing where this dependency was bound.
public static message create ( string message format , object ... arguments ) { return create ( null , message format , arguments ) ; }	Creates a new Message without a cause.
public static message create ( throwable cause , string message format , object ... arguments ) { return create ( cause , immutable list . of ( ) , message format , arguments ) ; }	Creates a new Message with the given cause.
public static message create ( throwable cause , list < object > sources , string message format , object ... arguments ) { string message = format ( message format , arguments ) ; return new message ( sources , message , cause ) ; }	Creates a new Message with the given cause and a binding source stack.
static object convert ( object o ) { element source source = null ; if ( o instanceof element source ) { source = ( element source ) o ; o = source . get declaring source ( ) ; } return convert ( o , source ) ; }	Formats an object in a user friendly way.
private boolean should be skipped ( string class name ) { return ( parent != null && parent . should be skipped ( class name ) ) || class names to skip . contains ( class name ) ; }	Returns true if the className should be skipped.
public object get from class names ( list < string > module class names ) { preconditions . check not null ( module class names , str ) ; for ( final string module class name : module class names ) { if ( ! should be skipped ( module class name ) ) { return new stack trace element ( module class name , str , null , - num ) ; } } return unknown source ; }	Returns the non-skipped module class name.
public static void main ( string [ ] args ) throws exception { if ( args . length != num ) { system . err . println ( str + manager . class . get name ( ) + str ) ; system . err . println ( str ) ; system . exit ( num ) ; } module module = ( module ) class . for name ( args [ num ] ) . new instance ( ) ; injector injector = guice . create injector ( module ) ; manage ( args [ num ] , injector ) ; system . out . println ( str ) ;	Run with no arguments for usage instructions.
dependency < ? > push dependency ( dependency < ? > dependency , object source ) { dependency < ? > previous = this . dependency ; this . dependency = dependency ; do push state ( dependency , source ) ; return previous ; }	Sets the new current dependency & adds it to the state.
void push state ( com . google . inject . key < ? > key , object source ) { do push state ( key , source ) ; }	Adds to the state without setting the dependency.
static < t > initializable < t > of ( final t instance ) { return new initializable < t > ( ) { @ override public t get ( ) { return instance ; } @ override public string to string ( ) { return string . value of ( instance ) ; } } ; }	Returns an initializable for an instance that requires no initialization.
protected t provision ( provider < ? extends t > provider , dependency < ? > dependency , construction context < t > construction context ) throws internal provision exception { t t = provider . get ( ) ; if ( t == null && ! dependency . is nullable ( ) ) { internal provision exception . on null injected into non nullable dependency ( source , dependency ) ; } construction context . set proxy delegates ( t ) ; return t ; }	Provisions a new instance.
public void on event ( connection event type type , string remote addr , connection conn ) { list < connection event processor > processor list = this . processors . get ( type ) ; if ( processor list != null ) { for ( connection event processor processor : processor list ) { processor . on event ( remote addr , conn ) ; } } }	Dispatch events.
public void add connection event processor ( connection event type type , connection event processor processor ) { list < connection event processor > processor list = this . processors . get ( type ) ; if ( processor list == null ) { this . processors . put if absent ( type , new array list < connection event processor > ( num ) ) ; processor list = this . processors . get ( type ) ; } processor list . add ( processor ) ; }	Add event processor.
public static < t > t get future task result ( run state recorded future task < t > task , logger logger ) { t t = null ; if ( null != task ) { try { t = task . get after run ( ) ; } catch ( interrupted exception e ) { logger . error ( str , e ) ; } catch ( execution exception e ) { logger . error ( str , e ) ; } catch ( future task not run yet exception e ) { logger . error ( str , e ) ; } catch ( future task not completed e ) { logger . error ( str , e ) ; } } return t ; }	get the result of a future taskNotice: the run method of this task should have been called at first.
public static void launder throwable ( throwable t ) { if ( t instanceof runtime exception ) { throw ( runtime exception ) t ; } else if ( t instanceof error ) { throw ( error ) t ; } else { throw new illegal state exception ( str , t ) ; } }	launder the throwable.
public void register processor ( command code cmd code , remoting processor < ? > processor ) { if ( this . cmd2processors . contains key ( cmd code ) ) { logger . warn ( str , cmd code , cmd2processors . get ( cmd code ) . get class ( ) . get name ( ) , processor . get class ( ) . get name ( ) ) ; } this . cmd2processors . put ( cmd code , processor ) ; }	Register processor to process command that has the command code of cmdCode.
public void register default processor ( remoting processor < ? > processor ) { if ( this . default processor == null ) { this . default processor = processor ; } else { throw new illegal state exception ( str + this . default processor . get class ( ) ) ; } }	Register the default processor to process command with no specific processor registered.
public remoting processor < ? > get processor ( command code cmd code ) { remoting processor < ? > processor = this . cmd2processors . get ( cmd code ) ; if ( processor != null ) { return processor ; } return this . default processor ; }	Get the specific processor with command code of cmdCode if registered, otherwise the default processor is returned.
private url try get ( string url ) { soft reference < url > soft ref = url . parsed urls . get ( url ) ; return ( null == soft ref ) ? null : soft ref . get ( ) ; }	try get from cache.
protected protocol code decode protocol code ( byte buf in ) { if ( in . readable bytes ( ) >= protocol code length ) { byte [ ] protocol code bytes = new byte [ protocol code length ] ; in . read bytes ( protocol code bytes ) ; return protocol code . from bytes ( protocol code bytes ) ; } return null ; }	decode the protocol code.
@ override public map < string , list < connection > > get all ( ) { map < string , list < connection > > all connections = new hash map < string , list < connection > > ( ) ; iterator < map . entry < string , run state recorded future task < connection pool > > > iterator = this . get conn pools ( ) . entry set ( ) . iterator ( ) ; while ( iterator . has next ( ) ) { map . entry < string , run state recorded future task < connection pool > > entry = iterator . next ( ) ; connection pool pool = future task util . get future task result ( entry . get value ( ) , logger ) ; if ( null != pool ) { all connections . put ( entry . get key ( ) , pool . get all ( ) ) ; } } return all connections ; }	Get all connections of all poolKey.
@ override public void scan ( ) { if ( null != this . conn tasks && ! this . conn tasks . is empty ( ) ) { iterator < string > iter = this . conn tasks . key set ( ) . iterator ( ) ; while ( iter . has next ( ) ) { string pool key = iter . next ( ) ; connection pool pool = this . get connection pool ( this . conn tasks . get ( pool key ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . is empty ( ) ) { if ( ( system . current time millis ( ) - pool . get last access timestamp ( ) ) > default expire time ) { iter . remove ( ) ; logger . warn ( str , pool key ) ; } } } } } }	in case of cache pollution and connection leak, to do schedule scan.
@ override public connection get and create if absent ( url url ) throws interrupted exception , remoting exception {	If no task cached, create one and initialize the connections.
@ override public void create connection and heal if need ( url url ) throws interrupted exception , remoting exception {	If no task cached, create one and initialize the connections.If task cached, check whether the number of connections adequate, if not then heal it.
private void remove task ( string pool key ) { run state recorded future task < connection pool > task = this . conn tasks . remove ( pool key ) ; if ( null != task ) { connection pool pool = future task util . get future task result ( task , logger ) ; if ( null != pool ) { pool . remove all and try close ( ) ; } } }	remove task and remove all connections.
private void heal if need ( connection pool pool , url url ) throws remoting exception , interrupted exception { string pool key = url . get unique key ( ) ;	execute heal connection tasks if the actual number of connections in pool is less than expected.
private void do create ( final url url , final connection pool pool , final string task name , final int sync create num when not warmup ) throws remoting exception { final int actual num = pool . size ( ) ; final int expect num = url . get conn num ( ) ; if ( actual num < expect num ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str , actual num , expect num , task name ) ; } if ( url . is conn warmup ( ) ) { for ( int i = actual num ; i < expect num ; ++ i ) { connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( sync create num when not warmup < num || sync create num when not warmup > url . get conn num ( ) ) { throw new illegal argument exception ( str + url . get conn num ( ) + str ) ; }	do create connections.
public void close connection ( string addr ) { url url = this . address parser . parse ( addr ) ; this . connection manager . remove ( url . get unique key ( ) ) ; }	Close all connections of a address.
public void on close ( ) { iterator < entry < integer , invoke future > > iter = invoke future map . entry set ( ) . iterator ( ) ; while ( iter . has next ( ) ) { entry < integer , invoke future > entry = iter . next ( ) ; iter . remove ( ) ; invoke future future = entry . get value ( ) ; if ( future != null ) { future . put response ( future . create connection closed response ( this . get remote address ( ) ) ) ; future . cancel timeout ( ) ; future . try async execute invoke callback abnormally ( ) ; } } }	Do something when closing.
public void close ( ) { if ( closed . compare and set ( bool , bool ) ) { try { if ( this . get channel ( ) != null ) { this . get channel ( ) . close ( ) . add listener ( new channel future listener ( ) { @ override public void operation complete ( channel future future ) throws exception { if ( logger . is info enabled ( ) ) { logger . info ( str , remoting util . parse remote address ( connection . this . get channel ( ) ) , future . is success ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( exception e ) { logger . warn ( str , remoting util . parse remote address ( connection . this . get channel ( ) ) , e ) ; } } }	Close the connection.
public object set attribute if absent ( string key , object value ) { return attributes . put if absent ( key , value ) ; }	set attribute if key absent.
public static void register user processor ( user processor < ? > processor , concurrent hash map < string , user processor < ? > > user processors ) { if ( null == processor ) { throw new runtime exception ( str ) ; } if ( processor instanceof multi interest user processor ) { register user processor ( ( multi interest user processor ) processor , user processors ) ; } else { if ( string utils . is blank ( processor . interest ( ) ) ) { throw new runtime exception ( str ) ; } user processor < ? > pre processor = user processors . put if absent ( processor . interest ( ) , processor ) ; if ( pre processor != null ) { string err msg = str + processor . interest ( ) + str ; throw new runtime exception ( err msg ) ; } } }	Help register single-interest user processor.
private static void register user processor ( multi interest user processor < ? > processor , concurrent hash map < string , user processor < ? > > user processors ) { if ( null == processor . multi interest ( ) || processor . multi interest ( ) . is empty ( ) ) { throw new runtime exception ( str ) ; } for ( string interest : processor . multi interest ( ) ) { user processor < ? > pre processor = user processors . put if absent ( interest , processor ) ; if ( pre processor != null ) { string err msg = str + interest + str ; throw new runtime exception ( err msg ) ; } } }	Help register multi-interest user processor.
private void dispatch to user processor ( remoting context ctx , rpc request command cmd ) { final int id = cmd . get id ( ) ; final byte type = cmd . get type ( ) ;	dispatch request command to user processor.
private boolean deserialize request command ( remoting context ctx , rpc request command cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = bool ; } catch ( deserialization exception e ) { logger . error ( str , cmd . get id ( ) , rpc deserialize level . value of ( level ) , e ) ; send response if necessary ( ctx , cmd . get type ( ) , this . get command factory ( ) . create exception response ( cmd . get id ( ) , response status . server deserial exception , e ) ) ; result = bool ; } catch ( throwable t ) { string err msg = str + cmd . get id ( ) + str + level ; logger . error ( err msg , t ) ; send response if necessary ( ctx , cmd . get type ( ) , this . get command factory ( ) . create exception response ( cmd . get id ( ) , t , err msg ) ) ; result = bool ; } return result ; }	deserialize request command.
private void pre process remoting context ( remoting context ctx , rpc request command cmd , long current timestamp ) { ctx . set arrive timestamp ( cmd . get arrive time ( ) ) ; ctx . set timeout ( cmd . get timeout ( ) ) ; ctx . set rpc command type ( cmd . get type ( ) ) ; ctx . get invoke context ( ) . put if absent ( invoke context . bolt process wait time , current timestamp - cmd . get arrive time ( ) ) ; }	pre process remoting context, initial some useful infos and pass to biz.
private void timeout log ( final rpc request command cmd , long current timestamp , remoting context ctx ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str , cmd . get id ( ) , current timestamp , cmd . get arrive time ( ) , ( current timestamp - cmd . get arrive time ( ) ) , cmd . get timeout ( ) ) ; } string remote addr = str ; if ( null != ctx ) { channel handler context channel ctx = ctx . get channel context ( ) ; channel channel = channel ctx . channel ( ) ; if ( null != channel ) { remote addr = remoting util . parse remote address ( channel ) ; } } logger . warn ( str , cmd . get id ( ) , remote addr , ( current timestamp - cmd . get arrive time ( ) ) , cmd . get timeout ( ) ) ; }	print some log when request timeout and discarded in io thread.
private void debug log ( remoting context ctx , rpc request command cmd , long current timestamp ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str , cmd . get id ( ) , remoting util . parse remote address ( ctx . get channel context ( ) . channel ( ) ) ) ; logger . debug ( str , cmd . get id ( ) , current timestamp , cmd . get arrive time ( ) , ( current timestamp - cmd . get arrive time ( ) ) , cmd . get timeout ( ) ) ; } }	print some debug log when receive request.
@ override public void process ( remoting context ctx , t msg , executor service default executor ) throws exception { process task task = new process task ( ctx , msg ) ; if ( this . get executor ( ) != null ) { this . get executor ( ) . execute ( task ) ; } else { default executor . execute ( task ) ; } }	Process the remoting command with its own executor or with the defaultExecutor if its own if null.
protected void oneway ( final connection conn , final remoting command request ) { try { conn . get channel ( ) . write and flush ( request ) . add listener ( new channel future listener ( ) { @ override public void operation complete ( channel future f ) throws exception { if ( ! f . is success ( ) ) { logger . error ( str , remoting util . parse remote address ( conn . get channel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( exception e ) { if ( null == conn ) { logger . error ( str ) ; } else { logger . error ( str , remoting util . parse remote address ( conn . get channel ( ) ) , e ) ; } } }	Oneway invocation.
public static byte to byte ( bit set bs ) { int value = num ; for ( int i = num ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += num << i ; } } if ( bs . length ( ) > num ) { throw new illegal argument exception ( str + value + str + bs + str + byte . min value + str + byte . max value + str ) ; } return ( byte ) value ; }	from bit set to byte.
public static bit set to bit set ( int value ) { if ( value > byte . max value || value < byte . min value ) { throw new illegal argument exception ( str + value + str + byte . min value + str + byte . max value + str ) ; } bit set bs = new bit set ( ) ; int index = num ; while ( value != num ) { if ( value % num != num ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value > > num ) ; } return bs ; }	from byte to bit set.
public void add reconnect task ( url url ) { reconnect task task = new reconnect task ( ) ; task . url = url ; tasks . add ( task ) ; }	add reconnect task.
protected remoting command to remoting command ( object request , connection conn , invoke context invoke context , int timeout millis ) throws serialization exception { rpc request command command = this . get command factory ( ) . create request command ( request ) ; if ( null != invoke context ) {	Convert application request object to remoting request command.
@ override public map < string , list < connection > > filter ( list < connection > connections ) { list < connection > service on connections = new array list < connection > ( ) ; list < connection > service off connections = new array list < connection > ( ) ; map < string , list < connection > > filtered connections = new concurrent hash map < string , list < connection > > ( ) ; for ( connection connection : connections ) { string service status = ( string ) connection . get attribute ( configs . conn service status ) ; if ( service status != null ) { if ( connection . is invoke future map finish ( ) && ! fresh select connections . contains value ( connection ) ) { service off connections . add ( connection ) ; } } else { service on connections . add ( connection ) ; } } filtered connections . put ( configs . conn service status on , service on connections ) ; filtered connections . put ( configs . conn service status off , service off connections ) ; return filtered connections ; }	Filter connections to monitor.
private void close fresh select connections ( connection last select connect , list < connection > service off connections ) throws interrupted exception { if ( null != last select connect ) { if ( last select connect . is invoke future map finish ( ) ) { service off connections . add ( last select connect ) ; } else { thread . sleep ( retry detect period ) ; if ( last select connect . is invoke future map finish ( ) ) { service off connections . add ( last select connect ) ; } else { if ( logger . is info enabled ( ) ) { logger . info ( str , remoting util . parse remote address ( last select connect . get channel ( ) ) ) ; } } } } }	close the connection of the fresh select connections.
public static boolean get bool ( string key , string default value ) { return boolean . parse boolean ( system . get property ( key , default value ) ) ; }	~~~ public helper methods to retrieve system property.
private void info log ( string format , string addr ) { if ( logger . is info enabled ( ) ) { if ( string utils . is not empty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , str ) ; } } }	print info log.
public boolean is request timeout ( ) { if ( this . timeout > num && ( this . rpc command type != rpc command type . request oneway ) && ( system . current time millis ( ) - this . arrive timestamp ) > this . timeout ) { return bool ; } return bool ; }	whether this request already timeout.
public user processor < ? > get user processor ( string class name ) { return string utils . is blank ( class name ) ? null : this . user processors . get ( class name ) ; }	Get user processor for class name.
private connection random get ( list < connection > conns ) { if ( null == conns || conns . is empty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = num ; connection result = null ; while ( ( result == null || ! result . is fine ( ) ) && tries ++ < max times ) { result = conns . get ( this . random . next int ( size ) ) ; } if ( result != null && ! result . is fine ( ) ) { result = null ; } return result ; }	get one connection randomly.
@ suppress warnings ( str ) public < t > t get ( string key , t default if not found ) { return this . context . get ( key ) != null ? ( t ) this . context . get ( key ) : default if not found ; }	get and use default if not found.
public string get property ( string key ) { if ( properties == null ) { return null ; } return properties . get property ( key ) ; }	Get property value according to property key.
public static object resolve response object ( response command response command , string addr ) throws remoting exception { pre process ( response command , addr ) ; if ( response command . get response status ( ) == response status . success ) { return to response object ( response command ) ; } else { string msg = string . format ( str , response command . get response status ( ) , addr , response command . get id ( ) ) ; logger . warn ( msg ) ; if ( response command . get cause ( ) != null ) { throw new invoke exception ( msg , response command . get cause ( ) ) ; } else { throw new invoke exception ( msg + str ) ; } } }	Analyze the response command and generate the response object.
private static object to response object ( response command response command ) throws codec exception { rpc response command response = ( rpc response command ) response command ; response . deserialize ( ) ; return response . get response object ( ) ; }	Convert remoting response command to application response object.
private static throwable to throwable ( response command response command ) throws codec exception { rpc response command resp = ( rpc response command ) response command ; resp . deserialize ( ) ; object ex = resp . get response object ( ) ; if ( ex != null && ex instanceof throwable ) { return ( throwable ) ex ; } return null ; }	Convert remoting response command to throwable if it is a throwable, otherwise return null.
private static string detail err msg ( string client err msg , response command response command ) { rpc response command resp = ( rpc response command ) response command ; if ( string utils . is not blank ( resp . get error msg ( ) ) ) { return string . format ( str , client err msg , resp . get error msg ( ) ) ; } else { return string . format ( str , client err msg ) ; } }	Detail your error msg with the error msg returned from response command.
private rpc server exception create server exception ( throwable t , string err msg ) { string formatted err msg = string . format ( str , t . get class ( ) . get name ( ) , t . get message ( ) , err msg ) ; rpc server exception e = new rpc server exception ( formatted err msg ) ; e . set stack trace ( t . get stack trace ( ) ) ; return e ; }	create server exception using error msg and fill the stack trace using the stack trace of throwable.
public static void print connection trace log ( logger logger , string trace id , invoke context invoke context ) { string source ip = invoke context . get ( invoke context . client local ip ) ; integer source port = invoke context . get ( invoke context . client local port ) ; string target ip = invoke context . get ( invoke context . client remote ip ) ; integer target port = invoke context . get ( invoke context . client remote port ) ; string builder log msg = new string builder ( ) ; log msg . append ( trace id ) . append ( str ) ; log msg . append ( source ip ) . append ( str ) ; log msg . append ( source port ) . append ( str ) ; log msg . append ( target ip ) . append ( str ) ; log msg . append ( target port ) ; if ( logger . is info enabled ( ) ) { logger . info ( log msg . to string ( ) ) ; } }	print trace log.
public static event loop group new event loop group ( int n threads , thread factory thread factory ) { return epoll enabled ? new epoll event loop group ( n threads , thread factory ) : new nio event loop group ( n threads , thread factory ) ; }	Create the right event loop according to current platform and system property, fallback to NIO when epoll not enabled.
public static string parse remote address ( final channel channel ) { if ( null == channel ) { return string utils . empty ; } final socket address remote = channel . remote address ( ) ; return do parse ( remote != null ? remote . to string ( ) . trim ( ) : string utils . empty ) ; }	Parse the remote address of the channel.
public static string parse local address ( final channel channel ) { if ( null == channel ) { return string utils . empty ; } final socket address local = channel . local address ( ) ; return do parse ( local != null ? local . to string ( ) . trim ( ) : string utils . empty ) ; }	Parse the local address of the channel.
public static string parse remote ip ( final channel channel ) { if ( null == channel ) { return string utils . empty ; } final inet socket address remote = ( inet socket address ) channel . remote address ( ) ; if ( remote != null ) { return remote . get address ( ) . get host address ( ) ; } return string utils . empty ; }	Parse the remote host ip of the channel.
public static string parse remote host name ( final channel channel ) { if ( null == channel ) { return string utils . empty ; } final inet socket address remote = ( inet socket address ) channel . remote address ( ) ; if ( remote != null ) { return remote . get address ( ) . get host name ( ) ; } return string utils . empty ; }	Parse the remote hostname of the channel.Note: take care to use this method, for a reverse name lookup takes uncertain time in {.
public static string parse local ip ( final channel channel ) { if ( null == channel ) { return string utils . empty ; } final inet socket address local = ( inet socket address ) channel . local address ( ) ; if ( local != null ) { return local . get address ( ) . get host address ( ) ; } return string utils . empty ; }	Parse the local host ip of the channel.
public static int parse remote port ( final channel channel ) { if ( null == channel ) { return - num ; } final inet socket address remote = ( inet socket address ) channel . remote address ( ) ; if ( remote != null ) { return remote . get port ( ) ; } return - num ; }	Parse the remote host port of the channel.
public static int parse local port ( final channel channel ) { if ( null == channel ) { return - num ; } final inet socket address local = ( inet socket address ) channel . local address ( ) ; if ( local != null ) { return local . get port ( ) ; } return - num ; }	Parse the local host port of the channel.
public static string parse socket address to host ip ( socket address socket address ) { final inet socket address addrs = ( inet socket address ) socket address ; if ( addrs != null ) { inet address addr = addrs . get address ( ) ; if ( null != addr ) { return addr . get host address ( ) ; } } return string utils . empty ; }	Parse the host ip of socket address.e.g.
public void add ( connection connection ) { mark access ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . add if absent ( connection ) ; if ( res ) { connection . increase ref ( ) ; } }	add a connection.
public void remove and try close ( connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decrease ref ( ) ; } if ( connection . no ref ( ) ) { connection . close ( ) ; } }	removeAndTryClose a connection.
public static void register custom serializer ( string class name , custom serializer serializer ) { custom serializer prev serializer = class custom serializer . put if absent ( class name , serializer ) ; if ( prev serializer != null ) { throw new runtime exception ( str + class name + str + prev serializer . get class ( ) . get name ( ) ) ; } }	Register custom serializer for class name.
public static custom serializer get custom serializer ( string class name ) { if ( ! class custom serializer . is empty ( ) ) { return class custom serializer . get ( class name ) ; } return null ; }	Get the custom serializer for class name.
public static void register custom serializer ( command code code , custom serializer serializer ) { custom serializer prev serializer = command custom serializer . put if absent ( code , serializer ) ; if ( prev serializer != null ) { throw new runtime exception ( str + code + str + prev serializer . get class ( ) . get name ( ) ) ; } }	Register custom serializer for command code.
public static custom serializer get custom serializer ( command code code ) { if ( ! command custom serializer . is empty ( ) ) { return command custom serializer . get ( code ) ; } return null ; }	Get the custom serializer for command code.
public boolean is connected ( string remote addr ) { url url = this . rpc remoting . address parser . parse ( remote addr ) ; return this . is connected ( url ) ; }	check whether a client address connected.
private void init write buffer water mark ( ) { int low water mark = this . netty buffer low watermark ( ) ; int high water mark = this . netty buffer high watermark ( ) ; if ( low water mark > high water mark ) { throw new illegal argument exception ( string . format ( str , high water mark , low water mark ) ) ; } else { logger . warn ( str , low water mark , high water mark ) ; } this . bootstrap . child option ( channel option . write buffer water mark , new write buffer water mark ( low water mark , high water mark ) ) ; }	init netty write buffer water mark.
public static framedata impl1 get ( opcode opcode ) { if ( opcode == null ) { throw new illegal argument exception ( str ) ; } switch ( opcode ) { case ping : return new ping frame ( ) ; case pong : return new pong frame ( ) ; case text : return new text frame ( ) ; case binary : return new binary frame ( ) ; case closing : return new close frame ( ) ; case continuous : return new continuous frame ( ) ; default : throw new illegal argument exception ( str ) ; } }	Get a frame with a specific opcode.
public static boolean batch ( web socket impl ws , byte channel sockchannel ) throws io { if ( ws == null ) { return bool ; } byte buffer buffer = ws . out queue . peek ( ) ; wrapped byte channel c = null ; if ( buffer == null ) { if ( sockchannel instanceof wrapped byte channel ) { c = ( wrapped byte channel ) sockchannel ; if ( c . is need write ( ) ) { c . write more ( ) ; } } } else { do {	Returns whether the whole outQueue has been flushed.
public void set code ( int code ) { this . code = code ;	Set the close code for this close frame.
private void validate utf8 ( byte buffer payload , int mark ) throws invalid data exception { try { payload . position ( payload . position ( ) + num ) ; reason = charsetfunctions . string utf8 ( payload ) ; } catch ( illegal argument exception e ) { throw new invalid data exception ( close frame . no ut ) ; } finally { payload . position ( mark ) ; } }	Validate the payload to valid utf8.
private void update payload ( ) { byte [ ] by = charsetfunctions . utf8 bytes ( reason ) ; byte buffer buf = byte buffer . allocate ( num ) ; buf . put int ( code ) ; buf . position ( num ) ; byte buffer pay = byte buffer . allocate ( num + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . set payload ( pay ) ; }	Update the payload to represent the close code and the reason.
private handshake state contains requested protocol ( string requested protocol ) { for ( i known protocol : known protocols ) { if ( known protocol . accept provided protocol ( requested protocol ) ) { protocol = known protocol ; log . trace ( str , protocol ) ; return handshake state . matched ; } } return handshake state . not matched ; }	Check if the requested protocol is part of this draft.
private void translate single frame check length limit ( long length ) throws limit exceeded exception { if ( length > integer . max value ) { log . trace ( str ) ; throw new limit exceeded exception ( str ) ; } if ( length > max frame size ) { log . trace ( str , max frame size , length ) ; throw new limit exceeded exception ( str , max frame size ) ; } if ( length < num ) { log . trace ( str ) ; throw new limit exceeded exception ( str ) ; } }	Check if the frame size exceeds the allowed limit.
private void translate single frame check packet size ( int maxpacketsize , int realpacketsize ) throws incomplete exception { if ( maxpacketsize < realpacketsize ) { log . trace ( str ) ; throw new incomplete exception ( realpacketsize ) ; } }	Check if the max packet size is smaller than the real packet size.
private string generate final key ( string in ) { string seckey = in . trim ( ) ; string acc = seckey + str ; message digest sh1 ; try { sh1 = message digest . get instance ( str ) ; } catch ( no such algorithm exception e ) { throw new illegal state exception ( e ) ; } return base64 . encode bytes ( sh1 . digest ( acc . get bytes ( ) ) ) ; }	Generate a final key from a input string.
private void process frame continuous and non fin ( web socket impl web socket impl , framedata frame , opcode curop ) throws invalid data exception { if ( curop != opcode . continuous ) { process frame is not fin ( frame ) ; } else if ( frame . is fin ( ) ) { process frame is fin ( web socket impl , frame ) ; } else if ( current continuous frame == null ) { log . error ( str ) ; throw new invalid data exception ( close frame . protocol error , str ) ; }	Process the frame if it is a continuous frame or the fin bit is not set.
private void process frame binary ( web socket impl web socket impl , framedata frame ) { try { web socket impl . get web socket listener ( ) . on websocket message ( web socket impl , frame . get payload data ( ) ) ; } catch ( runtime exception e ) { log runtime exception ( web socket impl , e ) ; } }	Process the frame if it is a binary frame.
private void log runtime exception ( web socket impl web socket impl , runtime exception e ) { log . error ( str , e ) ; web socket impl . get web socket listener ( ) . on websocket error ( web socket impl , e ) ; }	Log the runtime exception to the specific WebSocketImpl.
private void process frame text ( web socket impl web socket impl , framedata frame ) throws invalid data exception { try { web socket impl . get web socket listener ( ) . on websocket message ( web socket impl , charsetfunctions . string utf8 ( frame . get payload data ( ) ) ) ; } catch ( runtime exception e ) { log runtime exception ( web socket impl , e ) ; } }	Process the frame if it is a text frame.
private void process frame is fin ( web socket impl web socket impl , framedata frame ) throws invalid data exception { if ( current continuous frame == null ) { log . trace ( str ) ; throw new invalid data exception ( close frame . protocol error , str ) ; } add to buffer list ( frame . get payload data ( ) ) ; check buffer limit ( ) ; if ( current continuous frame . get opcode ( ) == opcode . text ) { ( ( framedata impl1 ) current continuous frame ) . set payload ( get payload from byte buffer list ( ) ) ; ( ( framedata impl1 ) current continuous frame ) . is valid ( ) ; try { web socket impl . get web socket listener ( ) . on websocket message ( web socket impl , charsetfunctions . string utf8 ( current continuous frame . get payload data ( ) ) ) ; } catch ( runtime exception e ) { log runtime exception ( web socket impl , e ) ; } } else if ( current continuous frame . get opcode ( ) == opcode . binary ) { ( ( framedata impl1 ) current continuous frame ) . set payload ( get payload from byte buffer list ( ) ) ; ( ( framedata impl1 ) current continuous frame ) . is valid ( ) ; try { web socket impl . get web socket listener ( ) . on websocket message ( web socket impl , current continuous frame . get payload data ( ) ) ; } catch ( runtime exception e ) { log runtime exception ( web socket impl , e ) ; } } current continuous frame = null ; clear buffer list ( ) ; }	Process the frame if it is the last frame.
private void process frame is not fin ( framedata frame ) throws invalid data exception { if ( current continuous frame != null ) { log . trace ( str ) ; throw new invalid data exception ( close frame . protocol error , str ) ; } current continuous frame = frame ; add to buffer list ( frame . get payload data ( ) ) ; check buffer limit ( ) ; }	Process the frame if it is not the last frame.
private void process frame closing ( web socket impl web socket impl , framedata frame ) { int code = close frame . nocode ; string reason = str ; if ( frame instanceof close frame ) { close frame cf = ( close frame ) frame ; code = cf . get close code ( ) ; reason = cf . get message ( ) ; } if ( web socket impl . get ready state ( ) == ready state . closing ) {	Process the frame if it is a closing frame.
private void check buffer limit ( ) throws limit exceeded exception { long total size = get byte buffer list size ( ) ; if ( total size > max frame size ) { clear buffer list ( ) ; log . trace ( str , max frame size , total size ) ; throw new limit exceeded exception ( max frame size ) ; } }	Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size.
private byte buffer get payload from byte buffer list ( ) throws limit exceeded exception { long total size = num ; byte buffer resulting byte buffer ; synchronized ( byte buffer list ) { for ( byte buffer buffer : byte buffer list ) { total size += buffer . limit ( ) ; } check buffer limit ( ) ; resulting byte buffer = byte buffer . allocate ( ( int ) total size ) ; for ( byte buffer buffer : byte buffer list ) { resulting byte buffer . put ( buffer ) ; } } resulting byte buffer . flip ( ) ; return resulting byte buffer ; }	Method to generate a full bytebuffer out of all the fragmented frame payload.
private long get byte buffer list size ( ) { long total size = num ; synchronized ( byte buffer list ) { for ( byte buffer buffer : byte buffer list ) { total size += buffer . limit ( ) ; } } return total size ; }	Get the current size of the resulting bytebuffer in the bytebuffer list.
private static handshake builder translate handshake http server ( string [ ] first line tokens , string line ) throws invalid handshake exception {	Checking the handshake for the role as server.
private static handshake builder translate handshake http client ( string [ ] first line tokens , string line ) throws invalid handshake exception {	Checking the handshake for the role as client.
public void decode ( byte buffer socket buffer ) { assert ( socket buffer . has remaining ( ) ) ; log . trace ( str , socket buffer . remaining ( ) , ( socket buffer . remaining ( ) > num ? str : new string ( socket buffer . array ( ) , socket buffer . position ( ) , socket buffer . remaining ( ) ) ) ) ; if ( ready state != ready state . not yet connected ) { if ( ready state == ready state . open ) { decode frames ( socket buffer ) ; } } else { if ( decode handshake ( socket buffer ) && ( ! is closing ( ) && ! is closed ( ) ) ) { assert ( tmp handshake bytes . has remaining ( ) != socket buffer . has remaining ( ) || ! socket buffer . has remaining ( ) ) ;	Method to decode the provided ByteBuffer.
private void close connection due to wrong handshake ( invalid data exception exception ) { write ( generate http response due to error ( num ) ) ; flush and close ( exception . get close code ( ) , exception . get message ( ) , bool ) ; }	Close the connection if the received handshake was not correct.
private void close connection due to internal server error ( runtime exception exception ) { write ( generate http response due to error ( num ) ) ; flush and close ( close frame . never connected , exception . get message ( ) , bool ) ; }	Close the connection if there was a server error by a RuntimeException.
private byte buffer generate http response due to error ( int error code ) { string error code description ; switch ( error code ) { case num : error code description = str ; break ; case num : default : error code description = str ; } return byte buffer . wrap ( charsetfunctions . ascii bytes ( str + error code description + str + ( num + error code description . length ( ) ) + str + error code description + str ) ) ; }	Generate a simple response for the corresponding endpoint to indicate some error.
@ override public void send ( string text ) { if ( text == null ) throw new illegal argument exception ( str ) ; send ( draft . create frames ( text , role == role . client ) ) ; }	Send Text data to the other end.
private void reset ( ) { thread current = thread . current thread ( ) ; if ( current == write thread || current == connect read thread ) { throw new illegal state exception ( str ) ; } try { close blocking ( ) ; if ( write thread != null ) { this . write thread . interrupt ( ) ; this . write thread = null ; } if ( connect read thread != null ) { this . connect read thread . interrupt ( ) ; this . connect read thread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( exception e ) { on error ( e ) ; engine . close connection ( close frame . abnormal close , e . get message ( ) ) ; return ; } connect latch = new count down latch ( num ) ; close latch = new count down latch ( num ) ; this . engine = new web socket impl ( this , this . draft ) ; }	Reset everything relevant to allow a reconnect.
public void connect ( ) { if ( connect read thread != null ) throw new illegal state exception ( str ) ; connect read thread = new thread ( this ) ; connect read thread . set name ( str + connect read thread . get id ( ) ) ; connect read thread . start ( ) ; }	Initiates the websocket connection.
private int get port ( ) { int port = uri . get port ( ) ; if ( port == - num ) { string scheme = uri . get scheme ( ) ; if ( str . equals ( scheme ) ) { return web socket impl . default wss port ; } else if ( str . equals ( scheme ) ) { return web socket impl . default port ; } else { throw new illegal argument exception ( str + scheme ) ; } } return port ; }	Extract the specified port.
private void send handshake ( ) throws invalid handshake exception { string path ; string part1 = uri . get raw path ( ) ; string part2 = uri . get raw query ( ) ; if ( part1 == null || part1 . length ( ) == num ) path = str ; else path = part1 ; if ( part2 != null ) path += str + part2 ; int port = get port ( ) ; string host = uri . get host ( ) + ( ( port != web socket impl . default port && port != web socket impl . default wss port ) ? str + port : str ) ; handshake impl1 client handshake = new handshake impl1 client ( ) ; handshake . set resource descriptor ( path ) ; handshake . put ( str , host ) ; if ( headers != null ) { for ( map . entry < string , string > kv : headers . entry set ( ) ) { handshake . put ( kv . get key ( ) , kv . get value ( ) ) ; } } engine . start handshake ( handshake ) ; }	Create and send the handshake to the other endpoint.
public void set connection lost timeout ( int connection lost timeout ) { synchronized ( sync connection lost ) { this . connection lost timeout = time unit . seconds . to nanos ( connection lost timeout ) ; if ( this . connection lost timeout <= num ) { log . trace ( str ) ; cancel connection lost timer ( ) ; return ; } if ( this . websocket running ) { log . trace ( str ) ;	Setter for the interval checking for lost connectionsA value lower or equal 0 results in the check to be deactivated.
protected void stop connection lost timer ( ) { synchronized ( sync connection lost ) { if ( connection lost checker service != null || connection lost checker future != null ) { this . websocket running = bool ; log . trace ( str ) ; cancel connection lost timer ( ) ; } } }	Stop the connection lost timer.
protected void start connection lost timer ( ) { synchronized ( sync connection lost ) { if ( this . connection lost timeout <= num ) { log . trace ( str ) ; return ; } log . trace ( str ) ; this . websocket running = bool ; restart connection lost timer ( ) ; } }	Start the connection lost timer.
private void restart connection lost timer ( ) { cancel connection lost timer ( ) ; connection lost checker service = executors . new single thread scheduled executor ( new named thread factory ( str ) ) ; runnable connection lost checker = new runnable ( ) { private array list < web socket > connections = new array list < web socket > ( ) ; @ override public void run ( ) { connections . clear ( ) ; try { connections . add all ( get connections ( ) ) ; long minimum pong time = ( long ) ( system . nano time ( ) - ( connection lost timeout * num ) ) ; for ( web socket conn : connections ) { execute connection lost detection ( conn , minimum pong time ) ; } } catch ( exception e ) {	This methods allows the reset of the connection lost timer in case of a changed parameter.
private void execute connection lost detection ( web socket web socket , long minimum pong time ) { if ( ! ( web socket instanceof web socket impl ) ) { return ; } web socket impl web socket impl = ( web socket impl ) web socket ; if ( web socket impl . get last pong ( ) < minimum pong time ) { log . trace ( str , web socket impl ) ; web socket impl . close connection ( close frame . abnormal close , str ) ; } else { if ( web socket impl . is open ( ) ) { web socket impl . send ping ( ) ; } else { log . trace ( str , web socket impl ) ; } } }	Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping.
private void cancel connection lost timer ( ) { if ( connection lost checker service != null ) { connection lost checker service . shutdown now ( ) ; connection lost checker service = null ; } if ( connection lost checker future != null ) { connection lost checker future . cancel ( bool ) ; connection lost checker future = null ; } }	Cancel any running timer for the connection lost detection.
@ override public server handshake builder on websocket handshake received as server ( web socket conn , draft draft , client handshake request ) throws invalid data exception { return new handshake impl1 server ( ) ; }	This default implementation does not do anything.
@ override public void on websocket ping ( web socket conn , framedata f ) { conn . send frame ( new pong frame ( ( ping frame ) f ) ) ; }	This default implementation will send a pong in response to the received ping.The pong frame will have the same payload as the ping frame.
public void stop ( int timeout ) throws interrupted exception { if ( ! isclosed . compare and set ( bool , bool ) ) {	Closes all connected clients sockets, then closes the underlyingServerSocketChannel, effectively killing the server socket selectorthread,freeing the port the server was bound to and stops all internal workerthreads.If this method is called before the server is started it will never start.
public int get port ( ) { int port = get address ( ) . get port ( ) ; if ( port == num && server != null ) { port = server . socket ( ) . get local port ( ) ; } return port ; }	Gets the port number that this server listens on.
private void do additional read ( ) throws interrupted exception , io { web socket impl conn ; while ( ! iqueue . is empty ( ) ) { conn = iqueue . remove ( num ) ; wrapped byte channel c = ( ( wrapped byte channel ) conn . get channel ( ) ) ; byte buffer buf = take buffer ( ) ; try { if ( io . read more ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . has remaining ( ) ) { conn . in queue . put ( buf ) ; queue ( conn ) ; } else { push buffer ( buf ) ; } } catch ( io e ) { push buffer ( buf ) ; throw e ; } } }	Do an additional read.
private void do accept ( selection key key , iterator < selection key > i ) throws io , interrupted exception { if ( ! on connect ( key ) ) { key . cancel ( ) ; return ; } socket channel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configure blocking ( bool ) ; socket socket = channel . socket ( ) ; socket . set tcp no delay ( is tcp no delay ( ) ) ; socket . set keep alive ( bool ) ; web socket impl w = wsf . create web socket ( this , drafts ) ; w . set selection key ( channel . register ( selector , selection key . op read , w ) ) ; try { w . set channel ( wsf . wrap channel ( channel , w . get selection key ( ) ) ) ; i . remove ( ) ; allocate buffers ( w ) ; } catch ( io ex ) { if ( w . get selection key ( ) != null ) w . get selection key ( ) . cancel ( ) ; handle io ( w . get selection key ( ) , null , ex ) ; } }	Execute a accept operation.
private boolean do read ( selection key key , iterator < selection key > i ) throws interrupted exception , io { web socket impl conn = ( web socket impl ) key . attachment ( ) ; byte buffer buf = take buffer ( ) ; if ( conn . get channel ( ) == null ) { key . cancel ( ) ; handle io ( key , conn , new io ( ) ) ; return bool ; } try { if ( io . read ( buf , conn , conn . get channel ( ) ) ) { if ( buf . has remaining ( ) ) { conn . in queue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . get channel ( ) instanceof wrapped byte channel && ( ( wrapped byte channel ) conn . get channel ( ) ) . is need read ( ) ) { iqueue . add ( conn ) ; } } else { push buffer ( buf ) ; } } else { push buffer ( buf ) ; } } catch ( io e ) { push buffer ( buf ) ; throw e ; } return bool ; }	Execute a read operation.
private void do write ( selection key key ) throws io { web socket impl conn = ( web socket impl ) key . attachment ( ) ; if ( io . batch ( conn , conn . get channel ( ) ) ) { if ( key . is valid ( ) ) { key . interest ops ( selection key . op read ) ; } } }	Execute a write operation.
private boolean do setup selector and server thread ( ) { selectorthread . set name ( str + selectorthread . get id ( ) ) ; try { server = server socket channel . open ( ) ; server . configure blocking ( bool ) ; server socket socket = server . socket ( ) ; socket . set receive buffer size ( web socket impl . rcvbuf ) ; socket . set reuse address ( is reuse addr ( ) ) ; socket . bind ( address ) ; selector = selector . open ( ) ; server . register ( selector , server . valid ops ( ) ) ; start connection lost timer ( ) ; for ( web socket worker ex : decoders ) { ex . start ( ) ; } on start ( ) ; } catch ( io ex ) { handle fatal ( null , ex ) ; return bool ; } return bool ; }	Setup the selector thread as well as basic server settings.
private boolean do ensure single thread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new illegal state exception ( get class ( ) . get name ( ) + str ) ; selectorthread = thread . current thread ( ) ; if ( isclosed . get ( ) ) { return bool ; } } return bool ; }	The websocket server can only be started once.
private void do server shutdown ( ) { stop connection lost timer ( ) ; if ( decoders != null ) { for ( web socket worker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( io e ) { log . error ( str , e ) ; on error ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( io e ) { log . error ( str , e ) ; on error ( null , e ) ; } } }	Clean up everything after a shutdown.
private socket get socket ( web socket conn ) { web socket impl impl = ( web socket impl ) conn ; return ( ( socket channel ) impl . get selection key ( ) . channel ( ) ) . socket ( ) ; }	Getter to return the socket used by this specific connection.
public void broadcast ( byte [ ] data , collection < web socket > clients ) { if ( data == null || clients == null ) { throw new illegal argument exception ( ) ; } broadcast ( byte buffer . wrap ( data ) , clients ) ; }	Send a byte array to a specific collection of websocket connections.
public void broadcast ( string text , collection < web socket > clients ) { if ( text == null || clients == null ) { throw new illegal argument exception ( ) ; } do broadcast ( text , clients ) ; }	Send a text to a specific collection of websocket connections.
private void do broadcast ( object data , collection < web socket > clients ) { string s data = null ; if ( data instanceof string ) { s data = ( string ) data ; } byte buffer b data = null ; if ( data instanceof byte buffer ) { b data = ( byte buffer ) data ; } if ( s data == null && b data == null ) { return ; } map < draft , list < framedata > > draft frames = new hash map < draft , list < framedata > > ( ) ; for ( web socket client : clients ) { if ( client != null ) { draft draft = client . get draft ( ) ; fill frames ( draft , draft frames , s data , b data ) ; try { client . send frame ( draft frames . get ( draft ) ) ; } catch ( websocket not connected exception e ) {	Private method to cache all the frames to improve memory footprint and conversion time.
private void fill frames ( draft draft , map < draft , list < framedata > > draft frames , string s data , byte buffer b data ) { if ( ! draft frames . contains key ( draft ) ) { list < framedata > frames = null ; if ( s data != null ) { frames = draft . create frames ( s data , bool ) ; } if ( b data != null ) { frames = draft . create frames ( b data , bool ) ; } if ( frames != null ) { draft frames . put ( draft , frames ) ; } } }	Fills the draftFrames with new data for the broadcast.
public static int transfer byte buffer ( byte buffer source , byte buffer dest ) { if ( source == null || dest == null ) { throw new illegal argument exception ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }	Transfer from one ByteBuffer to another ByteBuffer.
public jpa start ( ) { jpa config . persistence units ( ) . for each ( persistence unit -> emfs . put ( persistence unit . name , persistence . create entity manager factory ( persistence unit . unit name ) ) ) ; return this ; }	Initialise JPA entity manager factories.
public entity manager em ( string name ) { entity manager factory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . create entity manager ( ) ; }	Get a newly created EntityManager for the specified persistence unit name.
public void with transaction ( consumer < entity manager > block ) { with transaction ( em -> { block . accept ( em ) ; return null ; } ) ; }	Run a block of code with a newly created EntityManager for the default Persistence Unit.
private static seq < object > convert args to scala buffer ( final object ... args ) { return scala . collection . java converters . as scala buffer converter ( wrap args to list if needed ( args ) ) . as scala ( ) . to list ( ) ; }	Converts the varargs to a scala buffer, takes care of wrapping varargs into a intermediate listif necessary.
@ safe varargs private static < t > list < t > wrap args to list if needed ( final t ... args ) { list < t > out ; if ( args != null && args . length == num && args [ num ] instanceof list ) { out = ( list < t > ) args [ num ] ; } else { out = arrays . as list ( args ) ; } return out ; }	Wraps arguments passed into a list if necessary.
public string get ( play . api . i18n . lang lang , string key , object ... args ) { seq < object > scala args = convert args to scala buffer ( args ) ; return messages . apply ( key , scala args , lang ) ; }	Translates a message. Uses `java.text.MessageFormat` internally to format the message.
public string get ( play . api . i18n . lang lang , list < string > keys , object ... args ) { buffer < string > key args = scala . collection . java converters . as scala buffer converter ( keys ) . as scala ( ) ; seq < object > scala args = convert args to scala buffer ( args ) ; return messages . apply ( key args . to seq ( ) , scala args , lang ) ; }	Translates the first defined message.
public boolean is defined at ( play . api . i18n . lang lang , string key ) { return messages . is defined at ( key , lang ) ; }	Check if a message key is defined.
public messages preferred ( collection < lang > candidates ) { seq < lang > cs = scala . as scala ( candidates ) ; play . api . i18n . messages msgs = messages . preferred ( ( seq ) cs ) ; return new messages impl ( new lang ( msgs . lang ( ) ) , this ) ; }	Get a messages context appropriate for the given candidates.
public messages preferred ( http . request header request ) { play . api . i18n . messages msgs = messages . preferred ( request ) ; return new messages impl ( new lang ( msgs . lang ( ) ) , this ) ; }	Get a messages context appropriate for the given request.
public result set lang ( result result , lang lang ) { return messages . set lang ( result . as scala ( ) , lang ) . as java ( ) ; }	Given a Result and a Lang, return a new Result with the lang cookie set to the given Lang.
public final self bindings ( guiceable module ... modules ) { return new builder ( delegate . bindings ( scala . varargs ( modules ) ) ) ; }	Add bindings from guiceable modules.
public final self bindings ( play . api . inject . module ... modules ) { return bindings ( guiceable . modules ( modules ) ) ; }	Add bindings from Play modules.
public final self bindings ( play . api . inject . binding < ? > ... bindings ) { return bindings ( guiceable . bindings ( bindings ) ) ; }	Add Play bindings.
public final self overrides ( guiceable module ... modules ) { return new builder ( delegate . overrides ( scala . varargs ( modules ) ) ) ; }	Override bindings using guiceable modules.
public final self overrides ( play . api . inject . module ... modules ) { return overrides ( guiceable . modules ( modules ) ) ; }	Override bindings using Play modules.
public final self overrides ( play . api . inject . binding < ? > ... bindings ) { return overrides ( guiceable . bindings ( bindings ) ) ; }	Override bindings using Play bindings.
public final self disable ( class < ? > ... module classes ) { return new builder ( delegate . disable ( scala . to seq ( module classes ) ) ) ; }	Disable modules by class.
public completion stage < result > call ( request req ) {	Executes this action with the given HTTP request and returns the result.
public optional < file > get existing file ( string relative path ) { return option converters . to java ( env . get existing file ( relative path ) ) ; }	Retrieves a file relative to the application root path.
public < a extends annotation > binding < t > in ( final class < a > scope ) { return underlying . in ( scope ) . as java ( ) ; }	Configure the scope for this binding.
public static < a , b > tuple < a , b > tuple ( a a , b b ) { return new tuple < a , b > ( a , b ) ; }	Constructs a tuple of A,B.
public static < a , b , c , d , e > tuple5 < a , b , c , d , e > tuple5 ( a a , b b , c c , d d , e e ) { return new tuple5 < a , b , c , d , e > ( a , b , c , d , e ) ; }	Constructs a tuple of A,B,C,D,E.
private static executor to executor ( execution context ec ) { execution context prepared = ec . prepare ( ) ; if ( prepared instanceof executor ) { return ( executor ) prepared ; } else { return prepared :: execute ; } }	Converts the execution context to an executor, preparing it first.
public static jpa of ( string name , string unit name ) { return new jpa ( new jpa . persistence unit ( name , unit name ) ) ; }	Create a default JPA configuration with the given name and unit name.
public static jpa of ( string n1 , string u1 , string n2 , string u2 ) { return new jpa ( new jpa . persistence unit ( n1 , u1 ) , new jpa . persistence unit ( n2 , u2 ) ) ; }	Create a default JPA configuration with the given names and unit names.
public static jpa from ( map < string , string > map ) { immutable set . builder < jpa . persistence unit > persistence units = new immutable set . builder < jpa . persistence unit > ( ) ; for ( map . entry < string , string > entry : map . entry set ( ) ) { persistence units . add ( new jpa . persistence unit ( entry . get key ( ) , entry . get value ( ) ) ) ; } return new jpa ( persistence units . build ( ) ) ; }	Create a default JPA configuration from a map of names to unit names.
public static flow < string , byte string , not used > string ( string callback name ) { return flow . of ( string . class ) . map ( str -> { return byte string . from string ( str + string escape utils . escape ecma script ( str ) + str ) ; } ) . via ( flow ( callback name ) ) ; }	Produces a Flow of escaped ByteString from a series of String elements.
public static flow < json node , byte string , not used > json ( string callback name ) { return flow . of ( json node . class ) . map ( json -> { return byte string . from string ( json . stringify ( json ) ) ; } ) . via ( flow ( callback name ) ) ; }	Produces a flow of ByteString using `Json.stringify` from a Flow of JsonNode.
public < t extends constraint validator < ? , ? > > mapped constraint validator factory add constraint validator ( class < t > key , t constraint validator ) { validators . put ( key , ( ) -> constraint validator ) ; return this ; }	Adds validator as a singleton.
private < t extends constraint validator < ? , ? > > t new instance ( class < t > key ) { try { return key . get declared constructor ( ) . new instance ( ) ; } catch ( instantiation exception | runtime exception | illegal access exception | no such method exception | invocation target exception ex ) { throw new runtime exception ( ex ) ; } }	need to do so.
public static method get matching accessible method ( final class < ? > cls , final string method name , final class < ? > ... parameter types ) { try { final method method = cls . get method ( method name , parameter types ) ; member utils . set accessible workaround ( method ) ; return method ; } catch ( final no such method exception e ) {	Finds an accessible method that matches the given name and has compatible parameters.Compatible parameters mean that every method parameter is assignable from the given parameters.In other words, it finds a method with the given name that will take the parameters given.
@ override public completion stage < result > on client error ( request header request , int status code , string message ) { if ( status code == num ) { return on bad request ( request , message ) ; } else if ( status code == num ) { return on forbidden ( request , message ) ; } else if ( status code == num ) { return on not found ( request , message ) ; } else if ( status code >= num && status code < num ) { return on other client error ( request , status code , message ) ; } else { throw new illegal argument exception ( str + status code + str + message ) ; } }	Invoked when a client error occurs, that is, an error in the 4xx series.
protected completion stage < result > on bad request ( request header request , string message ) { return completable future . completed future ( results . bad request ( views . html . defaultpages . bad request . render ( request . method ( ) , request . uri ( ) , message , request . as scala ( ) ) ) ) ; }	Invoked when a client makes a bad request.
protected completion stage < result > on forbidden ( request header request , string message ) { return completable future . completed future ( results . forbidden ( views . html . defaultpages . unauthorized . render ( request . as scala ( ) ) ) ) ; }	Invoked when a client makes a request that was forbidden.
protected completion stage < result > on not found ( request header request , string message ) { if ( environment . is prod ( ) ) { return completable future . completed future ( results . not found ( views . html . defaultpages . not found . render ( request . method ( ) , request . uri ( ) , request . as scala ( ) ) ) ) ; } else { return completable future . completed future ( results . not found ( views . html . defaultpages . dev not found . render ( request . method ( ) , request . uri ( ) , some . apply ( routes . get ( ) ) , request . as scala ( ) ) ) ) ; } }	Invoked when a handler or resource is not found.
@ override public completion stage < result > on server error ( request header request , throwable exception ) { try { useful exception useful exception = throwable to useful exception ( exception ) ; log server error ( request , useful exception ) ; switch ( environment . mode ( ) ) { case prod : return on prod server error ( request , useful exception ) ; default : return on dev server error ( request , useful exception ) ; } } catch ( exception e ) { logger . error ( str , e ) ; return completable future . completed future ( results . internal server error ( ) ) ; } }	Invoked when a server error occurs.
protected void log server error ( request header request , useful exception useful exception ) { logger . error ( string . format ( str , useful exception . id , request . method ( ) , request . uri ( ) ) , useful exception ) ; }	Responsible for logging server errors.
protected final useful exception throwable to useful exception ( final throwable throwable ) { return http error handler exceptions . throwable to useful exception ( source mapper . source mapper ( ) , environment . is prod ( ) , throwable ) ; }	Convert the given exception to an exception that Play can report more information about.
protected completion stage < result > on dev server error ( request header request , useful exception exception ) { return completable future . completed future ( results . internal server error ( views . html . defaultpages . dev error . render ( play editor , exception , request . as scala ( ) ) ) ) ; }	Invoked in dev mode when a server error occurs.
protected completion stage < result > on prod server error ( request header request , useful exception exception ) { return completable future . completed future ( results . internal server error ( views . html . defaultpages . error . render ( exception , request . as scala ( ) ) ) ) ; }	Invoked in prod mode when a server error occurs. The base implementation returns {.
public static build doc handler from resources ( file [ ] files , string [ ] base dirs ) throws io { assert ( files . length == base dirs . length ) ; file repository [ ] repositories = new file repository [ files . length ] ; list < jar file > jar files = new array list < > ( ) ; for ( int i = num ; i < files . length ; i ++ ) { file file = files [ i ] ; string base dir = base dirs [ i ] ; if ( file . is directory ( ) ) { repositories [ i ] = new filesystem repository ( file ) ; } else {	Create a BuildDocHandler that serves documentation from the given files, which could either bedirectories or jar files.
public static build doc handler from directory ( file directory ) { file repository repo = new filesystem repository ( directory ) ; return new documentation handler ( repo ) ; }	Create an BuildDocHandler that serves documentation from a given directory by wrapping aFilesystemRepository.
public static build doc handler from directory and jar ( file directory , jar file jar file , string base ) { return from directory and jar ( directory , jar file , base , bool ) ; }	Create an BuildDocHandler that serves the manual from a given directory by wrapping aFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.
public static build doc handler from directory and jar ( file directory , jar file jar file , string base , boolean fallback to jar ) { file repository file repo = new filesystem repository ( directory ) ; file repository jar repo = new jar repository ( jar file , option . apply ( base ) ) ; file repository manual repo ; if ( fallback to jar ) { manual repo = new aggregate file repository ( new file repository [ ] { file repo , jar repo } ) ; } else { manual repo = file repo ; } return new documentation handler ( manual repo , jar repo ) ; }	Create an BuildDocHandler that serves the manual from a given directory by wrapping aFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.
public static build doc handler from jar ( jar file jar file , string base ) { file repository repo = new jar repository ( jar file , option . apply ( base ) ) ; return new documentation handler ( repo ) ; }	Create an BuildDocHandler that serves documentation from a given JAR file by wrapping aJarRepository.
public completion stage < byte string > consume data ( materializer mat ) { return data stream ( ) . run fold ( byte string . empty ( ) , byte string :: concat , mat ) ; }	Consumes the data. This method should be used carefully, since if the source represents an ephemeral stream,then the entity may not be usable after this method is invoked.
public static final http entity from content ( content content , string charset ) { string body ; if ( content instanceof xml ) {	Create an entity from the given content.
public static final http entity from string ( string content , string charset ) { return new strict ( byte string . from string ( content , charset ) , optional . of ( str + charset ) ) ; }	Create an entity from the given String.
public static final http entity chunked ( source < byte string , ? > data , optional < string > content type ) { return new chunked ( data . map ( http chunk . chunk :: new ) , content type ) ; }	Convert the given source of ByteStrings to a chunked entity.
public static result status ( int status , json node content ) { return status ( status , content , json encoding . ut ) ; }	Generates a simple result with json content and UTF8 encoding.
public static result status ( int status , json node content , json encoding encoding ) { if ( content == null ) { throw new null pointer exception ( str ) ; } return status ( status ) . send json ( content , encoding ) ; }	Generates a simple result with json content.
public static result status ( int status , byte [ ] content ) { if ( content == null ) { throw new null pointer exception ( str ) ; } return new result ( status , new http entity . strict ( byte string . from array ( content ) , optional . empty ( ) ) ) ; }	Generates a simple result with byte-array content.
public static result status ( int status , input stream content , long content length ) { return status ( status ) . send input stream ( content , content length ) ; }	Generates a chunked result.
public static result status ( int status , file content ) { return status ( status , content , static file mime types . file mime types ( ) ) ; }	Generates a result with file contents.
private user find by id ( long id ) { if ( id > num ) return null ; user user = new user ( ) ; user . id = id ; user . name = str + string . value of ( id ) ; return user ; }	designed to be lightweight operation.
public lang preferred ( collection < lang > candidates ) { return new lang ( langs . preferred ( ( scala . collection . immutable . seq ) scala . as scala ( candidates ) . to seq ( ) ) ) ; }	Select a preferred language, given the list of candidates.
public call unique ( ) { return new play . api . mvc . call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }	Append a unique identifier to the URL.
public call with fragment ( string fragment ) { return new play . api . mvc . call ( method ( ) , url ( ) , fragment ) ; }	Returns a new Call with the given fragment.
public string absolute url ( http . request request ) { return absolute url ( request . secure ( ) , request . host ( ) ) ; }	Transform this call to an absolute URL.
public string web socket url ( http . request request ) { return web socket url ( request . secure ( ) , request . host ( ) ) ; }	Transform this call to an WebSocket URL.
abstract function1 < connection , boxed unit > connection function ( final connection runnable block ) { return new abstract function1 < connection , boxed unit > ( ) { public boxed unit apply ( connection connection ) { try { block . run ( connection ) ; return boxed unit . unit ; } catch ( java . sql . sql e ) { throw new runtime exception ( str , e ) ; } } } ; }	Create a Scala function wrapper for ConnectionRunnable.
< a > abstract function1 < connection , a > connection function ( final connection callable < a > block ) { return new abstract function1 < connection , a > ( ) { public a apply ( connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . sql e ) { throw new runtime exception ( str , e ) ; } } } ; }	Create a Scala function wrapper for ConnectionCallable.
public static server for router ( mode mode , int port , function < built in components , router > block ) { return new builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }	Create a server for the router returned by the given block.
public static json node to json ( final object data ) { try { return mapper ( ) . value to tree ( data ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Converts an object to JsonNode.
public static < a > a from json ( json node json , class < a > clazz ) { try { return mapper ( ) . tree to value ( json , clazz ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Converts a JsonNode to a Java value.
public static json node parse ( string src ) { try { return mapper ( ) . read tree ( src ) ; } catch ( throwable t ) { throw new runtime exception ( t ) ; } }	Parses a String representing a json, and return it as a JsonNode.
public static json node parse ( java . io . input stream src ) { try { return mapper ( ) . read tree ( src ) ; } catch ( throwable t ) { throw new runtime exception ( t ) ; } }	Parses a InputStream representing a json, and return it as a JsonNode.
public static string relative ( string start path , string target path ) {	Create a path to targetPath that's relative to the given startPath.
public static string canonical ( string url ) { string [ ] url path = to segments ( url ) ; stack < string > canonical = new stack < > ( ) ; for ( string comp : url path ) { if ( comp . is empty ( ) || comp . equals ( current dir ) ) continue ; if ( ! comp . equals ( parent dir ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( parent dir ) ) ) canonical . push ( comp ) ; else canonical . pop ( ) ; } string prefix sep = url . starts with ( separator ) ? separator : str ; string trailing sep = url . ends with ( separator ) ? separator : str ; return prefix sep + canonical . stream ( ) . collect ( collectors . joining ( separator ) ) + trailing sep ; }	Create a canonical path that does not contain parent directories, current directories, orsuperfluous directory separators.
public static list < tuple < string , list < object > > > displayable constraint ( set < constraint descriptor < ? > > constraints ) { return constraints . parallel stream ( ) . filter ( c -> c . get annotation ( ) . annotation type ( ) . is annotation present ( display . class ) ) . map ( c -> displayable constraint ( c ) ) . collect ( collectors . to list ( ) ) ; }	Converts a set of constraints to human-readable values.
public static tuple < string , list < object > > displayable constraint ( constraint descriptor < ? > constraint ) { final display display annotation = constraint . get annotation ( ) . annotation type ( ) . get annotation ( display . class ) ; return tuple ( display annotation . name ( ) , collections . unmodifiable list ( stream . of ( display annotation . attributes ( ) ) . map ( attr -> constraint . get attributes ( ) . get ( attr ) ) . collect ( collectors . to list ( ) ) ) ) ; }	Converts a constraint to a human-readable value.
@ override public < a > completion stage < a > timeout ( final completion stage < a > stage , final long amount , final time unit unit ) { require non null ( stage , str ) ; require non null ( unit , str ) ; finite duration duration = finite duration . apply ( amount , unit ) ; return to java ( delegate . timeout ( duration , scala . as scala with future ( ( ) -> stage ) ) ) ; }	Creates a CompletionStage that returns either the input stage, or a futures.
public static date parse cron ( string cron ) { try { return new cron expression ( cron ) . get next valid time after ( new date ( ) ) ; } catch ( exception e ) { throw new illegal argument exception ( str + cron , e ) ; } }	Parses a CRON expression.
public static long cron interval ( string cron , date date ) { try { return new cron expression ( cron ) . get next interval ( date ) ; } catch ( exception e ) { throw new illegal argument exception ( str + cron , e ) ; } }	Compute the number of milliseconds between the next valid date and the one after.
public static ws create ( ws config , ahc http cache cache , materializer materializer ) { final ws client = ws . create ( config , cache , materializer ) ; return new ws ( client , materializer ) ; }	Creates WS client manually from configuration, internally creating a new instance ofAsyncHttpClient and managing its own thread pool.
public guice application builder builder ( application loader . context context ) { return initial builder . in ( context . environment ( ) ) . load config ( context . initial config ( ) ) . overrides ( overrides ( context ) ) ; }	Construct a builder to use for loading the given context.
public static result todo ( request request ) { return status ( not implemented , views . html . defaultpages . todo . render ( request . as scala ( ) ) ) ; }	Generates a 501 NOT_IMPLEMENTED simple result.
@ deprecated public static void session ( string key , string value ) { session ( ) . put ( key , value ) ; }	Puts a new value into the current session.
@ deprecated public static void flash ( string key , string value ) { flash ( ) . put ( key , value ) ; }	Puts a new value into the flash scope.
public < a extends annotation > binding key < t > qualified with ( final a instance ) { return underlying . qualified with ( instance ) . as java ( ) ; }	Qualify this binding key with the given instance of an annotation.
public < a extends annotation > binding key < t > qualified with ( final class < a > annotation ) { return underlying . qualified with ( annotation ) . as java ( ) ; }	Qualify this binding key with the given annotation.
public binding < t > to ( final class < ? extends t > implementation ) { return underlying . to ( implementation ) . as java ( ) ; }	Bind this binding key to the given implementation class.
public binding < t > to ( final provider < ? extends t > provider ) { return underlying . to ( provider ) . as java ( ) ; }	Bind this binding key to the given provider instance.
public < a extends t > binding < t > to ( final supplier < a > instance ) { return underlying . to ( new from java supplier < > ( instance ) ) . as java ( ) ; }	Bind this binding key to the given instance.
public binding < t > to ( final binding key < ? extends t > key ) { return underlying . to ( key . as scala ( ) ) . as java ( ) ; }	Bind this binding key to another binding key.
public < p extends provider < ? extends t > > binding < t > to provider ( final class < p > provider ) { return underlying . to provider ( provider ) . as java ( ) ; }	Bind this binding key to the given provider class.
public static list < lang > availables ( application app ) { play . api . i18n . langs langs = app . injector ( ) . instance of ( play . api . i18n . langs . class ) ; list < play . api . i18n . lang > available langs = scala . as java ( langs . availables ( ) ) ; return available langs . stream ( ) . map ( lang :: new ) . collect ( to list ( ) ) ; }	Retrieve Lang availables from the application configuration.
public static lang preferred ( application app , list < lang > available langs ) { play . api . i18n . langs langs = app . injector ( ) . instance of ( play . api . i18n . langs . class ) ; stream < lang > stream = available langs . stream ( ) ; list < play . api . i18n . lang > lang seq = stream . map ( l -> new play . api . i18n . lang ( l . to locale ( ) ) ) . collect ( to list ( ) ) ; return new lang ( langs . preferred ( scala . to seq ( lang seq ) ) ) ; }	Guess the preferred lang in the langs set passed as argument.
public static play . api . db . evolutions . evolutions reader from map ( map < string , list < evolution > > evolutions ) { return new simple evolutions reader ( evolutions ) ; }	Create an evolutions reader based on a simple map of database names to evolutions.
public static play . api . db . evolutions . evolutions reader for default ( evolution ... evolutions ) { map < string , list < evolution > > map = new hash map < string , list < evolution > > ( ) ; map . put ( str , arrays . as list ( evolutions ) ) ; return from map ( map ) ; }	Create an evolutions reader for the default database from a list of evolutions.
public static void cleanup evolutions ( database database , boolean autocommit , string schema ) { database evolutions evolutions = new database evolutions ( database . as scala ( ) , schema ) ; evolutions . evolve ( evolutions . reset scripts ( ) , autocommit ) ; }	Cleanup evolutions for the given database.
public guice application builder with config loader ( function < environment , config > load ) { return new builder ( delegate . load config ( func ( ( play . api . environment env ) -> new play . api . configuration ( load . apply ( new environment ( env ) ) ) ) ) ) ; }	Set the initial configuration loader.
public guice application builder with module loader ( bi function < environment , config , list < guiceable module > > loader ) { return new builder ( delegate . load ( func ( ( play . api . environment env , play . api . configuration conf ) -> scala . to seq ( loader . apply ( new environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }	Set the module loader.
public guice application builder load ( guiceable module ... modules ) { return new builder ( delegate . load ( scala . varargs ( modules ) ) ) ; }	Override the module loader with the given guiceable modules.
public guice application builder load ( com . google . inject . module ... modules ) { return load ( guiceable . modules ( modules ) ) ; }	Override the module loader with the given Guice modules.
public guice application builder load ( play . api . inject . module ... modules ) { return load ( guiceable . modules ( modules ) ) ; }	Override the module loader with the given Play modules.
public guice application builder load ( play . api . inject . binding < ? > ... bindings ) { return load ( guiceable . bindings ( bindings ) ) ; }	Override the module loader with the given Play bindings.
protected guice application builder new builder ( play . api . inject . guice . guice application builder builder ) { return new guice application builder ( builder ) ; }	Implementation of Self creation for GuiceBuilder.
public string encode ( cookie cookie ) { if ( cookie == null ) { throw new null pointer exception ( str ) ; } string builder buf = new string builder ( ) ; encode ( buf , cookie ) ; return strip trailing separator ( buf ) ; }	Encodes the specified cookie into a Cookie header value.
public entity manager em ( ) { deque < entity manager > ems = this . em stack ( bool ) ; if ( ems . is empty ( ) ) { http . context . safe current ( ) . map ( ctx -> { throw new runtime exception ( str ) ; } ) . or else get ( ( ) -> { throw new runtime exception ( str ) ; } ) ; } return ems . peek first ( ) ; }	Get the default EntityManager for this thread.
@ suppress warnings ( str ) public deque < entity manager > em stack ( boolean thread local fallback ) { return http . context . safe current ( ) . map ( context -> { object ems object = context . args . get ( current entity manager ) ; if ( ems object != null ) { return ( deque < entity manager > ) ems object ; } else { deque < entity manager > ems = new array deque < > ( ) ; context . args . put ( current entity manager , ems ) ; return ems ; } } ) . or else get ( ( ) -> {	Get the EntityManager stack.
void push or pop em ( entity manager em , boolean thread local fallback ) { deque < entity manager > ems = this . em stack ( thread local fallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . is empty ( ) ) { throw new illegal state exception ( str ) ; } ems . pop ( ) ; } }	Pushes or pops the EntityManager stack depending on the value of the em argument.
public static < in , flow in , out > flow < in , out , ? > bypass with ( function < in , f . either < flow in , out > > splitter , flow < flow in , out , ? > flow ) { return bypass with ( flow . < in > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . akka streams . only first can finish merge ( num ) , flow ) ; }	Bypass the given flow using the given splitter function.
public static < in , flow in , out > flow < in , out , ? > bypass with ( flow < in , f . either < flow in , out > , ? > splitter , graph < uniform fan in shape < out , out > , ? > merge strategy , flow < flow in , out , ? > flow ) { return splitter . via ( flow . from graph ( dsl . < flow shape < f . either < flow in , out > , out > > create ( builder -> {	Using the given splitter flow, allow messages to bypass a flow.
private list < object > convert error arguments ( object [ ] arguments ) { if ( arguments == null ) { return collections . empty list ( ) ; } list < object > converted = arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . default message source resolvable ) ) . collect ( collectors . to list ( ) ) ; return collections . unmodifiable list ( converted ) ; }	Convert the error arguments.
public form < t > fill ( t value ) { if ( value == null ) { throw new runtime exception ( str ) ; } return new form < > ( root name , backed type , new hash map < > ( ) , new hash map < > ( ) , new array list < > ( ) , optional . of nullable ( value ) , groups , messages api , formatters , validator factory , config , lang , direct field access ) ; }	Populates this form with an existing value, used for edit forms.
public list < validation error > global errors ( ) { return collections . unmodifiable list ( errors . stream ( ) . filter ( error -> error . key ( ) . is empty ( ) ) . collect ( collectors . to list ( ) ) ) ; }	Retrieve all global errors - errors without a key.
public json node errors as json ( lang lang ) { map < string , list < string > > all messages = new hash map < > ( ) ; errors . for each ( error -> { if ( error != null ) { final list < string > messages = new array list < > ( ) ; if ( messages api != null && lang != null ) { final list < string > reversed messages = new array list < > ( error . messages ( ) ) ; collections . reverse ( reversed messages ) ; messages . add ( messages api . get ( lang , reversed messages , translate msg arg ( error . arguments ( ) , messages api , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } all messages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . json . to json ( all messages ) ; }	Returns the form errors serialized as Json using the given Lang.
public optional < object > value ( string key ) { return super . value ( ) . map ( v -> v . get data ( ) . get ( as normal key ( key ) ) ) ; }	Gets the concrete value.
public dynamic form fill ( map < string , object > value ) { form < dynamic > form = super . fill ( new dynamic ( value ) ) ; return new dynamic form ( form . raw data ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messages api , formatters , validator factory , config , lang ( ) . or else ( null ) ) ; }	Fills the form with existing data.
public < t > t parse ( string text , class < t > clazz ) { return conversion . convert ( text , clazz ) ; }	Parses this string as instance of the given class.
@ suppress warnings ( str ) public < t > t parse ( field field , string text ) { return ( t ) conversion . convert ( text , new type descriptor ( field ) ) ; }	Parses this string as instance of a specific field.
public < t > string print ( t t ) { if ( t == null ) { return str ; } if ( conversion . can convert ( t . get class ( ) , string . class ) ) { return conversion . convert ( t , string . class ) ; } else { return t . to string ( ) ; } }	Computes the display string for any value.
public < t > string print ( field field , t t ) { return print ( new type descriptor ( field ) , t ) ; }	Computes the display string for any value, for a specific field.
public < t > string print ( type descriptor desc , t t ) { if ( t == null ) { return str ; } if ( desc != null && conversion . can convert ( desc , type descriptor . value of ( string . class ) ) ) { return ( string ) conversion . convert ( t , desc , type descriptor . value of ( string . class ) ) ; } else if ( conversion . can convert ( t . get class ( ) , string . class ) ) { return conversion . convert ( t , string . class ) ; } else { return t . to string ( ) ; } }	Computes the display string for any value, for a specific type.
private formatters register optional ( ) { conversion . add converter ( new generic converter ( ) { public object convert ( object source , type descriptor source type , type descriptor target type ) { if ( source type . get object type ( ) . equals ( string . class ) ) {	Converter for String -> Optional and Optional -> String.
public < t > formatters register ( final class < t > clazz , final simple formatter < t > formatter ) { conversion . add formatter for field type ( clazz , new org . springframework . format . formatter < t > ( ) { public t parse ( string text , locale locale ) throws java . text . parse exception { return formatter . parse ( text , locale ) ; } public string print ( t t , locale locale ) { return formatter . print ( t , locale ) ; } public string to string ( ) { return formatter . to string ( ) ; } } ) ; return this ; }	Registers a simple formatter.
public string encode ( cookie cookie ) { if ( cookie == null ) { throw new null pointer exception ( str ) ; } final string name = cookie . name ( ) ; final string value = cookie . value ( ) != null ? cookie . value ( ) : str ; validate cookie ( name , value ) ; string builder buf = new string builder ( ) ; if ( cookie . wrap ( ) ) { add quoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . max age ( ) != integer . min value ) { add ( buf , cookie header names . max age , cookie . max age ( ) ) ; date expires = cookie . max age ( ) <= num ? new date ( num )	Encodes the specified cookie into a Set-Cookie header value.
public static node list select nodes ( string path , object node ) { return select nodes ( path , node , null ) ; }	Select all nodes that are selected by this XPath expression.
public static < t > scala . collection . immutable . seq < t > to seq ( java . util . list < t > list ) { return scala . collection . java converters . as scala buffer converter ( list ) . as scala ( ) . to list ( ) ; }	Converts a Java List to Scala Seq.
public static < t > scala . collection . immutable . seq < t > to seq ( t [ ] array ) { return to seq ( java . util . arrays . as list ( array ) ) ; }	Converts a Java Array to Scala Seq.
@ safe varargs public static < t > scala . collection . immutable . seq < t > varargs ( t ... array ) { return to seq ( array ) ; }	Converts a Java varargs to Scala varargs.
public static < in , out > mapped web socket acceptor < in , out > json ( class < in > in ) { return new mapped web socket acceptor < > ( scala . partial function ( message -> { try { if ( message instanceof message . binary ) { return f . either . left ( play . libs . json . mapper ( ) . read value ( ( ( message . binary ) message ) . data ( ) . iterator ( ) . as input stream ( ) , in ) ) ; } else if ( message instanceof message . text ) { return f . either . left ( play . libs . json . mapper ( ) . read value ( ( ( message . text ) message ) . data ( ) , in ) ) ; } } catch ( exception e ) { return f . either . right ( new message . close ( close codes . unacceptable ( ) , e . get message ( ) ) ) ; } throw scala . no match ( ) ; } ) , out message -> { try { return new message . text ( play . libs . json . mapper ( ) . write value as string ( out message ) ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } } ) ; }	Acceptor for JSON WebSockets.
private static < in , out > web socket accept or result ( partial function < message , f . either < in , message > > in mapper , function < http . request header , completion stage < f . either < result , flow < in , out , ? > > > > f , function < out , message > out mapper ) { return new web socket ( ) { @ override public completion stage < f . either < result , flow < message , message , ? > > > apply ( http . request header request ) { return f . apply ( request ) . then apply ( result or flow -> { if ( result or flow . left . is present ( ) ) { return f . either . left ( result or flow . left . get ( ) ) ; } else { flow < message , message , ? > flow = akka streams . bypass with ( flow . < message > create ( ) . collect ( in mapper ) , play . api . libs . streams . akka streams . only first can finish merge ( num ) , result or flow . right . get ( ) . map ( out mapper :: apply ) ) ; return f . either . right ( flow ) ; } } ) ; } } ; }	Helper to create handlers for WebSockets.
private static float get primitive promotion cost ( final class < ? > src class , final class < ? > dest class ) { float cost = num ; class < ? > cls = src class ; if ( ! cls . is primitive ( ) ) {	Gets the number of steps required to promote a primitive number to another type.
private static float get total transformation cost ( final class < ? > [ ] src args , final executable executable ) { final class < ? > [ ] dest args = executable . get parameter types ( ) ; final boolean is var args = executable . is var args ( ) ;	Returns the sum of the object transformation cost for each class in the source argument list.
private static float get object transformation cost ( class < ? > src class , final class < ? > dest class ) { if ( dest class . is primitive ( ) ) { return get primitive promotion cost ( src class , dest class ) ; } float cost = num ; while ( src class != null && ! dest class . equals ( src class ) ) { if ( dest class . is interface ( ) && class utils . is assignable ( src class , dest class ) ) {	Gets the number of steps required needed to turn the source class into the destination class.This represents the number of steps in the object hierarchy graph.
public string at ( string key , object ... args ) { return messages api . get ( lang , key , args ) ; }	Get the message at the given key.
public string at ( list < string > keys , object ... args ) { return messages api . get ( lang , keys , args ) ; }	Get the message at the first defined key.
public static database create from ( string driver , string url , map < string , ? extends object > config ) { return create from ( str , driver , url , config ) ; }	Create a pooled database named "default" with the given configuration.
public static parallel sorter create ( object [ ] arrays ) { generator gen = new generator ( ) ; gen . set arrays ( arrays ) ; return gen . create ( ) ; }	Create a new ParallelSorter object for a set of arrays.
public void quick sort ( int index , int lo , int hi , comparator cmp ) { choose comparer ( index , cmp ) ; super . quick sort ( lo , hi - num ) ; }	Sort the arrays using the quicksort algorithm.
public void merge sort ( int index , int lo , int hi , comparator cmp ) { choose comparer ( index , cmp ) ; super . merge sort ( lo , hi - num ) ; }	Sort the arrays using an in-place merge sort.
public object invoke ( object obj , object [ ] args ) throws throwable { try { init ( ) ; fast class info fci = fast class info ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( invocation target exception e ) { throw e . get target exception ( ) ; } catch ( illegal argument exception e ) { if ( fast class info . i1 < num ) throw new illegal argument exception ( str + sig1 ) ; throw e ; } }	Invoke the original method, on a different object of the same type.
public void load arg ( int index ) { load local ( state . argument types [ index ] , state . local offset + skip args ( index ) ) ; }	Pushes the specified argument of the current method onto the stack.
void emit field ( int opcode , type ctype , string name , type ftype ) { mv . visit field insn ( opcode , ctype . get internal name ( ) , name , ftype . get descriptor ( ) ) ; }	package-protected for EmitUtils, try to fix.
public void zero or null ( type type ) { if ( type utils . is primitive ( type ) ) { switch ( type . get sort ( ) ) { case type . double : push ( num ) ; break ; case type . long : push ( num ) ; break ; case type . float : push ( num ) ; break ; case type . void : aconst null ( ) ; default : push ( num ) ; } } else { aconst null ( ) ; } }	Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.
public void unbox or zero ( type type ) { if ( type utils . is primitive ( type ) ) { if ( type != type . void type ) { label non null = make label ( ) ; label end = make label ( ) ; dup ( ) ; ifnonnull ( non null ) ; pop ( ) ; zero or null ( type ) ; go to ( end ) ; mark ( non null ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }	Unboxes the object on the top of the stack.
public static void process array ( code emitter e , type type , process array callback callback ) { type component type = type utils . get component type ( type ) ; local array = e . make local ( ) ; local loopvar = e . make local ( type . int type ) ; label loopbody = e . make label ( ) ; label checkloop = e . make label ( ) ; e . store local ( array ) ; e . push ( num ) ; e . store local ( loopvar ) ; e . go to ( checkloop ) ; e . mark ( loopbody ) ; e . load local ( array ) ; e . load local ( loopvar ) ; e . array load ( component type ) ; callback . process element ( component type ) ; e . iinc ( loopvar , num ) ; e . mark ( checkloop ) ; e . load local ( loopvar ) ; e . load local ( array ) ; e . arraylength ( ) ; e . if icmp ( e . lt , loopbody ) ; }	Process an array on the stack.
private static void nullcmp ( code emitter e , label one null , label both null ) { e . dup2 ( ) ; label non null = e . make label ( ) ; label one null helper = e . make label ( ) ; label end = e . make label ( ) ; e . ifnonnull ( non null ) ; e . ifnonnull ( one null helper ) ; e . pop2 ( ) ; e . go to ( both null ) ; e . mark ( non null ) ; e . ifnull ( one null helper ) ; e . go to ( end ) ; e . mark ( one null helper ) ; e . pop2 ( ) ; e . go to ( one null ) ; e . mark ( end ) ; }	If both objects on the top of the stack are non-null, does nothing.If one is null, or both are null, both are popped off and executionbranches to the respective label.
public map resolve all ( ) { map resolved = new hash map ( ) ; for ( iterator entry iter = decl to bridge . entry set ( ) . iterator ( ) ; entry iter . has next ( ) ; ) { map . entry entry = ( map . entry ) entry iter . next ( ) ; class owner = ( class ) entry . get key ( ) ; set bridges = ( set ) entry . get value ( ) ; try { input stream is = class loader . get resource as stream ( owner . get name ( ) . replace ( str , str ) + str ) ; if ( is == null ) { return resolved ; } try { new class reader ( is ) . accept ( new bridged finder ( bridges , resolved ) , class reader . skip frames | class reader . skip debug ) ; } finally { is . close ( ) ; } } catch ( io ignored ) { } } return resolved ; }	Finds all bridge methods that are being called with invokespecial &returns them.
protected void filter constructors ( class sc , list constructors ) { collection utils . filter ( constructors , new visibility predicate ( sc , bool ) ) ; if ( constructors . size ( ) == num ) throw new illegal argument exception ( str + sc ) ; }	Filter the list of constructors from the superclass.
public void set superclass ( class superclass ) { if ( superclass != null && superclass . equals ( object . class ) ) { superclass = null ; } this . superclass = superclass ; }	Set the class which the generated class will extend.
private void get field ( string [ ] names ) throws exception { final code emitter e = begin method ( constants . acc public , provider get , null ) ; e . load this ( ) ; e . load arg ( num ) ; emit utils . string switch ( e , names , constants . switch style hash , new object switch callback ( ) { public void process case ( object key , label end ) { type type = ( type ) fields . get ( key ) ; e . getfield ( ( string ) key ) ; e . box ( type ) ; e . return value ( ) ; } public void process default ( ) { e . throw exception ( illegal argument exception , str ) ; } } ) ; e . end method ( ) ; }	to avoid JVM hashcode implementation incompatibilities.
public void add ( method method ) { add ( reflect utils . get signature ( method ) , reflect utils . get exception types ( method ) ) ; }	Add a method signature to the interface.
public int cardinality ( ) { int w = value ; int c = num ; while ( w != num ) { c += t [ w & num ] ; w >>= num ; } return c ; }	If bit 31 is set then this method results in an infinite loop.
public void set naming policy ( naming policy naming policy ) { if ( naming policy == null ) naming policy = default naming policy . instance ; this . naming policy = naming policy ; }	Override the default naming policy.
public static method [ ] find methods ( string [ ] names and descriptors , method [ ] methods ) { map map = new hash map ( ) ; for ( int i = num ; i < methods . length ; i ++ ) { method method = methods [ i ] ; map . put ( method . get name ( ) + type . get method descriptor ( method ) , method ) ; } method [ ] result = new method [ names and descriptors . length / num ] ; for ( int i = num ; i < result . length ; i ++ ) { result [ i ] = ( method ) map . get ( names and descriptors [ i * num ] + names and descriptors [ i * num + num ] ) ; if ( result [ i ] == null ) {	used by MethodInterceptorGenerated generated code.
public static path resolve ( final path base , string child ) { if ( string util . starts with char ( child , file . separator char ) ) { child = child . substring ( num ) ; } return base . resolve ( child ) ; }	Resolves subpath in safer way.
public static string read string ( final path path ) throws io { try ( buffered reader reader = files . new buffered reader ( path , standard charsets . utf 8 ) ) { string writer writer = new string writer ( ) ;	Reads path content.
public http request host ( final string host ) { this . host = host ; if ( headers . contains ( header host ) ) { header overwrite ( header host , host ) ; } return this ; }	Sets request host name.
public static http request create ( final string method , final string destination ) { return new http request ( ) . method ( method . to upper case ( ) ) . set ( destination ) ; }	Generic request builder, usually used when method is a variable.Otherwise, use one of the other static request builder methods.
public static http request connect ( final string destination ) { return new http request ( ) . method ( http method . connect ) . set ( destination ) ; }	Builds a CONNECT request.
public static http request get ( final string destination ) { return new http request ( ) . method ( http method . get ) . set ( destination ) ; }	Builds a GET request.
public static http request post ( final string destination ) { return new http request ( ) . method ( http method . post ) . set ( destination ) ; }	Builds a POST request.
public static http request put ( final string destination ) { return new http request ( ) . method ( http method . put ) . set ( destination ) ; }	Builds a PUT request.
public static http request patch ( final string destination ) { return new http request ( ) . method ( http method . patch ) . set ( destination ) ; }	Builds a PATCH request.
public static http request delete ( final string destination ) { return new http request ( ) . method ( http method . delete ) . set ( destination ) ; }	Builds a DELETE request.
public static http request head ( final string destination ) { return new http request ( ) . method ( http method . head ) . set ( destination ) ; }	Builds a HEAD request.
public static http request trace ( final string destination ) { return new http request ( ) . method ( http method . trace ) . set ( destination ) ; }	Builds a TRACE request.
public static http request options ( final string destination ) { return new http request ( ) . method ( http method . options ) . set ( destination ) ; }	Builds an OPTIONS request.
public http request path ( string path ) {	Sets request path. Query string is allowed.Adds a slash if path doesn't start with one.Query will be stripped out from the path.Previous query is discarded.
public http request cookies ( final cookie ... cookies ) { if ( cookies . length == num ) { return this ; } string builder cookie string = new string builder ( ) ; boolean first = bool ; for ( cookie cookie : cookies ) { integer max age = cookie . get max age ( ) ; if ( max age != null && max age . int value ( ) == num ) { continue ; } if ( ! first ) { cookie string . append ( str ) ; } first = bool ; cookie string . append ( cookie . get name ( ) ) ; cookie string . append ( str ) ; cookie string . append ( cookie . get value ( ) ) ; } header overwrite ( str , cookie string . to string ( ) ) ; return this ; }	Sets cookies to the request.
public http request query ( final string name1 , final object value1 , final object ... parameters ) { query ( name1 , value1 == null ? null : value1 . to string ( ) ) ; for ( int i = num ; i < parameters . length ; i += num ) { string name = parameters [ i ] . to string ( ) ; string value = parameters [ i + num ] . to string ( ) ; query . add ( name , value ) ; } return this ; }	Adds many query parameters at once.
public http request query ( final map < string , string > query map ) { for ( map . entry < string , string > entry : query map . entry set ( ) ) { query . add ( entry . get key ( ) , entry . get value ( ) ) ; } return this ; }	Adds all parameters from the provided map.
public http request query string ( final string query string , final boolean decode ) { this . query = http util . parse query ( query string , decode ) ; return this ; }	Sets query from provided query string.
public string query string ( ) { if ( query == null ) { return string pool . empty ; } return http util . build query ( query , query encoding ) ; }	Generates query string. All values are URL encoded.
public string host url ( ) { string band url = new string band ( num ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( str ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != defaults . default port ) { url . append ( str ) ; url . append ( port ) ; } return url . to string ( ) ; }	Returns just host url, without path and query.
public http request basic authentication ( final string username , final string password ) { if ( username != null && password != null ) { string data = username . concat ( string pool . colon ) . concat ( password ) ; string base64 = base64 . encode to string ( data ) ; header overwrite ( header authorization , str + base64 ) ; } return this ; }	Enables basic authentication by adding required header.
public http request set host header ( ) { string host port = this . host ; if ( port != defaults . default port ) { host port += string pool . colon + port ; } header overwrite ( header host , host port ) ; return this ; }	Sets 'Host' header from current host and port.
@ override protected buffer buffer ( final boolean full request ) {	Prepares the request buffer.
static handler remove range ( final handler first handler , final label start , final label end ) { if ( first handler == null ) { return null ; } else { first handler . next handler = remove range ( first handler . next handler , start , end ) ; } int handler start = first handler . start pc . bytecode offset ; int handler end = first handler . end pc . bytecode offset ; int range start = start . bytecode offset ; int range end = end == null ? integer . max value : end . bytecode offset ;	Removes the range between start and end from the Handler list that begins with the givenelement.
static int get exception table length ( final handler first handler ) { int length = num ; handler handler = first handler ; while ( handler != null ) { length ++ ; handler = handler . next handler ; } return length ; }	Returns the number of elements of the Handler list that begins with the given element.
protected void collect action interceptors ( ) { final collection < ? extends action interceptor > interceptor values = interceptors manager . get all interceptors ( ) ; interceptors = new array list < > ( ) ; interceptors . add all ( interceptor values ) ; interceptors . sort ( comparator . comparing ( a -> a . get class ( ) . get simple name ( ) ) ) ; }	Collects all interceptors.
protected void collect action filters ( ) { final collection < ? extends action filter > filter values = filters manager . get all filters ( ) ; filters = new array list < > ( ) ; filters . add all ( filter values ) ; filters . sort ( comparator . comparing ( a -> a . get class ( ) . get simple name ( ) ) ) ; }	Collects all filters.
protected void collect action results ( ) { final collection < action result > results values = results manager . get all action results ( ) ; results = new array list < > ( ) ; results . add all ( results values ) ; results . sort ( comparator . comparing ( a -> a . get class ( ) . get simple name ( ) ) ) ; }	Collects all action results.
protected void collect action runtimes ( ) { actions = actions manager . get all action runtimes ( ) ; actions . sort ( comparator . comparing ( action runtime :: get action path ) ) ; }	Collects all action runtime configurations.
@ suppress warnings ( { str } ) protected void set simple property ( final bean property bp , final object value ) { setter setter = bp . get setter ( is declared ) ;	Sets a value of simple property.
@ override public < t > t get property ( final object bean , final string name ) { bean property bean property = new bean property ( this , bean , name ) ; if ( ! is silent ) { resolve nested properties ( bean property ) ; return ( t ) get index property ( bean property ) ; } else { try { resolve nested properties ( bean property ) ; return ( t ) get index property ( bean property ) ; } catch ( exception ignore ) { return null ; } } }	Returns value of bean's property.
@ override public string extract this reference ( final string property name ) { int ndx = string util . index of chars ( property name , index chars ) ; if ( ndx == - num ) { return property name ; } return property name . substring ( num , ndx ) ; }	Extract the first name of this reference.
@ override public print writer get writer ( ) { if ( writer == null ) { writer = new fast char array writer ( ) ; print writer = new print writer ( writer ) ; } return print writer ; }	Returns buffered writer. Buffer will be created if not already used.
public void set object reference ( final string name , final object object ) { if ( object refs == null ) { object refs = new hash map < > ( ) ; } object refs . put ( name , object ) ; }	Saves object reference.
public object get object reference ( final string name ) { if ( object refs == null ) { return null ; } return object refs . get ( name ) ; }	Returns object reference.
public object lookup object ( final string ref ) { object value = get object reference ( ref ) ; if ( value == null ) { throw new db sql builder exception ( str + ref ) ; } return value ; }	Lookups for object reference and throws an exception if reference doesn't exist.
public db entity descriptor get table descriptor ( final string table ref ) { if ( table refs == null ) { return null ; } table ref data t = table refs . get ( table ref ) ; return t == null ? null : t . desc ; }	Returns entity descriptor for provided table reference.
public db entity descriptor find table descriptor by column ref ( final string column ref ) { for ( map . entry < string , table ref data > entry : table refs . entry set ( ) ) { db entity descriptor ded = entry . get value ( ) . desc ; if ( ded . find by property name ( column ref ) != null ) { return ded ; } } return null ; }	Finds entity descriptor of a table that contains provided column reference.
public string get table alias ( final string table ref ) { if ( table refs == null ) { return null ; } table ref data t = table refs . get ( table ref ) ; return t == null ? null : t . alias ; }	Returns table alias for provided table reference.
public void register table reference ( final string table reference , final db entity descriptor ded , final string table alias ) { if ( table refs == null ) { table refs = new hash map < > ( ) ; } table ref data t = new table ref data ( ded , table alias ) ; if ( table refs . put ( table reference , t ) != null ) { throw new db sql builder exception ( str + table reference ) ; } }	Registers table reference for provided entity.
protected db entity descriptor lookup table ref ( final string table ref ) { db entity descriptor ded = get table descriptor ( table ref ) ; if ( ded == null ) { throw new db sql builder exception ( str + table ref ) ; } return ded ; }	Lookups for table reference and throws an exception if table reference not found.
public void register hint ( final string hint ) { if ( hints == null ) { hints = new array list < > ( hint count ) ; } hints . add ( hint ) ; }	Registers a hint.
@ override public final boolean serialize ( final json context json context , final t value ) { if ( json context . push value ( value ) ) {	Detects circular dependencies and pushes value as currenttype context.
protected void inject attributes ( final http servlet request servlet request , final targets targets ) { final enumeration < string > attribute names = servlet request . get attribute names ( ) ; while ( attribute names . has more elements ( ) ) { final string attr name = attribute names . next element ( ) ; targets . for each target and in ( this , ( target , in ) -> { final string name = in . matched name ( attr name ) ; if ( name != null ) { final object attr value = servlet request . get attribute ( attr name ) ; target . write value ( name , attr value , bool ) ; } } ) ; } }	Injects request attributes.
protected void inject parameters ( final http servlet request servlet request , final targets targets ) { final boolean encode = encode get params && servlet request . get method ( ) . equals ( str ) ; final enumeration < string > param names = servlet request . get parameter names ( ) ; while ( param names . has more elements ( ) ) { final string param name = param names . next element ( ) ; if ( servlet request . get attribute ( param name ) != null ) { continue ; } targets . for each target and in ( this , ( target , in ) -> { final string name = in . matched name ( param name ) ; if ( name != null ) { string [ ] param values = servlet request . get parameter values ( param name ) ; param values = servlet util . prepare parameters ( param values , treat empty params as null , ignore empty request params ) ; if ( param values != null ) { if ( encode ) { for ( int j = num ; j < param values . length ; j ++ ) { final string p = param values [ j ] ; if ( p != null ) { final string encoding = madvoc encoding . get encoding ( ) ; param values [ j ] = string util . convert charset ( p , string pool . iso 8859 1 , encoding ) ; } } } final object value = ( param values . length != num ? param values : param values [ num ] ) ; target . write value ( name , value , bool ) ; } } } ) ; } }	Inject request parameters.
protected void inject uploaded files ( final http servlet request servlet request , final targets targets ) { if ( ! ( servlet request instanceof multipart request wrapper ) ) { return ; } final multipart request wrapper multipart request = ( multipart request wrapper ) servlet request ; if ( ! multipart request . is multipart ( ) ) { return ; } final enumeration < string > param names = multipart request . get file parameter names ( ) ; while ( param names . has more elements ( ) ) { final string param name = param names . next element ( ) ; if ( servlet request . get attribute ( param name ) != null ) { continue ; } targets . for each target and in ( this , ( target , in ) -> { final string name = in . matched name ( param name ) ; if ( name != null ) { final file upload [ ] param values = multipart request . get files ( param name ) ; if ( ignore invalid upload files ) { for ( int j = num ; j < param values . length ; j ++ ) { final file upload param value = param values [ j ] ; if ( ( ! param value . is valid ( ) ) || ( ! param value . is uploaded ( ) ) ) { param values [ j ] = null ; } } } final object value = ( param values . length == num ? param values [ num ] : param values ) ; target . write value ( name , value , bool ) ; } } ) ; } }	Inject uploaded files from multipart request parameters.
public string convert property name to column name ( final string property name ) { string builder table name = new string builder ( property name . length ( ) * num ) ; if ( split camel case ) { string converted table name = format . from camel case ( property name , separator char ) ; table name . append ( converted table name ) ; } else { table name . append ( property name ) ; } if ( ! change case ) { return table name . to string ( ) ; } return uppercase ? to uppercase ( table name ) . to string ( ) : to lowercase ( table name ) . to string ( ) ; }	Converts property name to column name.
public string convert column name to property name ( final string column name ) { string builder property name = new string builder ( column name . length ( ) ) ; int len = column name . length ( ) ; if ( split camel case ) { boolean to upper = bool ; for ( int i = num ; i < len ; i ++ ) { char c = column name . char at ( i ) ; if ( c == separator char ) { to upper = bool ; continue ; } if ( to upper ) { property name . append ( character . to upper case ( c ) ) ; to upper = bool ; } else { property name . append ( character . to lower case ( c ) ) ; } } return property name . to string ( ) ; } return column name ; }	Converts column name to property name.
public string apply to column name ( final string column name ) { string property name = convert column name to property name ( column name ) ; return convert property name to column name ( property name ) ; }	Applies column naming strategy to given column name hint.Returns full column name.
public void store value ( final prepared statement st , final int index , final object value , final int db sql type ) throws sql { t t = type converter manager . get ( ) . convert type ( value , sql type ) ; set ( st , index , t , db sql type ) ; }	Stores value in database.
@ suppress warnings ( { str } ) protected < e > e prepare get value ( final t t , final class < e > destination type ) { if ( t == null ) { return null ; } if ( destination type == null ) { return ( e ) t ; } return type converter manager . get ( ) . convert type ( t , destination type ) ; }	Once when value is read from result set, prepare it to match destination type.
protected set < t > get all ( ) { final set < t > set = new hash set < > ( wrappers . size ( ) ) ; set . add all ( wrappers . values ( ) ) ; return set ; }	Returns all action wrappers.
public t resolve ( final class < ? extends t > wrapper class ) { string wrapper class name = wrapper class . get name ( ) ; t wrapper = lookup ( wrapper class name ) ; if ( wrapper == null ) { wrapper = create wrapper ( wrapper class ) ; initialize wrapper ( wrapper ) ; wrappers . put ( wrapper class name , wrapper ) ; } return wrapper ; }	Resolves single wrapper. Creates new wrapper instance if not already registered.Does not expand the wrappers.
protected < r extends t > r create wrapper ( final class < r > wrapper class ) { try { return class util . new instance ( wrapper class ) ; } catch ( exception ex ) { throw new madvoc exception ( str + wrapper class , ex ) ; } }	Creates new wrapper.
public static string separators to system ( final string path ) { if ( path == null ) { return null ; } if ( system separator == windows separator ) { return separators to windows ( path ) ; } else { return separators to unix ( path ) ; } }	Converts all separators to the system separator.
private static string do get path ( final string filename , final int separator add ) { if ( filename == null ) { return null ; } int prefix = get prefix length ( filename ) ; if ( prefix < num ) { return null ; } int index = index of last separator ( filename ) ; int end index = index + separator add ; if ( prefix >= filename . length ( ) || index < num || prefix >= end index ) { return string pool . empty ; } return filename . substring ( prefix , end index ) ; }	Does the work of getting the path.
public static string [ ] split ( final string filename ) { string prefix = get prefix ( filename ) ; if ( prefix == null ) { prefix = string pool . empty ; } int last separator index = index of last separator ( filename ) ; int last extension index = index of extension ( filename ) ; string path ; string base name ; string extension ; if ( last separator index == - num ) { path = string pool . empty ; if ( last extension index == - num ) { base name = filename . substring ( prefix . length ( ) ) ; extension = string pool . empty ; } else { base name = filename . substring ( prefix . length ( ) , last extension index ) ; extension = filename . substring ( last extension index + num ) ; } } else { path = filename . substring ( prefix . length ( ) , last separator index + num ) ; if ( last extension index == - num ) { base name = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = string pool . empty ; } else { base name = filename . substring ( prefix . length ( ) + path . length ( ) , last extension index ) ; extension = filename . substring ( last extension index + num ) ; } } return new string [ ] { prefix , path , base name , extension } ; }	Splits filename into a array of four Strings containing prefix, path, basename and extension.Path will contain ending separator.
public static string relative path ( final string target path , final string base path ) { return new file ( base path ) . to path ( ) . relativize ( new file ( target path ) . to path ( ) ) . to string ( ) ; }	Calculates relative path of target path on base path.
public web app register component ( final class < ? > madvoc component ) { objects . require non null ( madvoc component ) ; madvoc components . add ( class consumer . of ( madvoc component ) ) ; return this ; }	Registers additional Madvoc components after the registration of default components.
public < a extends action config > web app with action config ( final class < a > action config type , final consumer < a > action config consumer ) { with registered component ( action config manager . class , acm -> acm . with ( action config type , action config consumer ) ) ; return this ; }	Configures the action configurations.
public web app start ( ) { log = logger factory . get logger ( web app . class ) ; log . debug ( str ) ;	Initializes and starts web application.
protected void register madvoc components ( ) { if ( madvoc container == null ) { throw new madvoc exception ( str ) ; } log . debug ( str ) ; madvoc container . register component ( madvoc encoding . class ) ; madvoc container . register component instance ( new servlet context provider ( servlet context ) ) ; madvoc container . register component ( action config manager . class ) ; madvoc container . register component ( action method param name resolver . class ) ; madvoc container . register component ( action method parser . class ) ; madvoc container . register component ( action path rewriter . class ) ; madvoc container . register component ( actions manager . class ) ; madvoc container . register component ( context injector component . class ) ; madvoc container . register component ( interceptors manager . class ) ; madvoc container . register component ( filters manager . class ) ; madvoc container . register component ( madvoc controller . class ) ; madvoc container . register component ( root packages . class ) ; madvoc container . register component ( results manager . class ) ; madvoc container . register component ( result mapper . class ) ; madvoc container . register component ( scope resolver . class ) ; madvoc container . register component ( scope data inspector . class ) ; madvoc container . register component ( async action executor . class ) ; madvoc container . register component ( file uploader . class ) ; }	Registers default Madvoc components.
public class scanner exclude jars ( final string ... excluded jars ) { for ( final string excluded jar : excluded jars ) { rules jars . exclude ( excluded jar ) ; } return this ; }	Specify excluded jars.
public class scanner include jars ( final string ... included jars ) { for ( final string included jar : included jars ) { rules jars . include ( included jar ) ; } return this ; }	Specify included jars.
public class scanner include entries ( final string ... included entries ) { for ( final string included entry : included entries ) { rules entries . include ( included entry ) ; } return this ; }	Sets included set of names that will be considered during configuration.
public class scanner exclude entries ( final string ... excluded entries ) { for ( final string excluded entry : excluded entries ) { rules entries . exclude ( excluded entry ) ; } return this ; }	Sets excluded names that narrows included set of packages.
protected void scan jar file ( final file file ) { final zip file zip file ; try { zip file = new zip file ( file ) ; } catch ( io ioex ) { if ( ! ignore exception ) { throw new find file exception ( str + file . get name ( ) , ioex ) ; } return ; } final enumeration entries = zip file . entries ( ) ; while ( entries . has more elements ( ) ) { final zip entry zip entry = ( zip entry ) entries . next element ( ) ; final string zip entry name = zip entry . get name ( ) ; try { if ( string util . ends with ignore case ( zip entry name , class file ext ) ) { final string entry name = prepare entry name ( zip entry name , bool ) ; final class path entry class path entry = new class path entry ( entry name , zip file , zip entry ) ; try { scan entry ( class path entry ) ; } finally { class path entry . close input stream ( ) ; } } else if ( include resources ) { final string entry name = prepare entry name ( zip entry name , bool ) ; final class path entry class path entry = new class path entry ( entry name , zip file , zip entry ) ; try { scan entry ( class path entry ) ; } finally { class path entry . close input stream ( ) ; } } } catch ( runtime exception rex ) { if ( ! ignore exception ) { zip util . close ( zip file ) ; throw rex ; } } } zip util . close ( zip file ) ; }	Scans classes inside single JAR archive.
protected void scan class path ( final file root ) { string root path = root . get absolute path ( ) ; if ( ! root path . ends with ( file . separator ) ) { root path += file . separator char ; } final find file ff = find file . create ( ) . include dirs ( bool ) . recursive ( bool ) . search path ( root path ) ; file file ; while ( ( file = ff . next file ( ) ) != null ) { final string file path = file . get absolute path ( ) ; try { if ( string util . ends with ignore case ( file path , class file ext ) ) { scan class file ( file path , root path , file , bool ) ; } else if ( include resources ) { scan class file ( file path , root path , file , bool ) ; } } catch ( runtime exception rex ) { if ( ! ignore exception ) { throw rex ; } } } }	Scans single classpath directory.
public static byte [ ] bytecode signature of type ( final class type ) { final string name = str + type . get name ( ) . replace ( str , str ) + str ; return name . get bytes ( ) ; }	Returns type signature bytes used for searching in class file.
public class scanner scan ( final string ... paths ) { for ( final string path : paths ) { files to scan . add ( new file ( path ) ) ; } return this ; }	Scans provided paths.
public void start ( ) { if ( detect entries mode ) { rules entries . detect mode ( ) ; } files to scan . for each ( file -> { final string path = file . get absolute path ( ) ; if ( string util . ends with ignore case ( path , jar file ext ) ) { if ( ! accept jar ( file ) ) { return ; } scan jar file ( file ) ; } else if ( file . is directory ( ) ) { scan class path ( file ) ; } } ) ; }	Starts with the scanner.
@ override protected jtx transaction create new transaction ( final jtx transaction mode tm , final object scope , final boolean active ) { return new db jtx transaction ( this , tm , scope , active ) ; }	Builds new transaction instance.
@ suppress warnings ( str ) public < s extends madvoc scope > s default or scope type ( final class < s > scope class ) { if ( scope class == null ) { return ( s ) get or init scope ( request scope . class ) ; } return ( s ) get or init scope ( scope class ) ; }	Lookups the scope instance of given scope annotation.If instance does not exist, it will be created, cached and returned.
protected madvoc scope get or init scope ( final class < ? extends madvoc scope > madvoc scope type ) { for ( final madvoc scope s : all scopes ) { if ( s . get class ( ) . equals ( madvoc scope type ) ) { return s ; } }	Performs search for the scope class and returns it's instance.
public void for scope ( final class < ? extends madvoc scope > scope type , final consumer < madvoc scope > madvoc scope consumer ) { final madvoc scope scope = get or init scope ( scope type ) ; madvoc scope consumer . accept ( scope ) ; }	Finds a given scope and consumes it.
@ suppress warnings ( { str } ) public static string prepare csrf token ( final http session session , final int time to live ) { set < token > token set = ( set < token > ) session . get attribute ( csrf token set ) ; if ( token set == null ) { token set = new hash set < > ( ) ; session . set attribute ( csrf token set , token set ) ; } string value ; boolean unique ; do { value = random string . get ( ) . random alpha numeric ( num ) ; assure size ( token set ) ; unique = token set . add ( new token ( value , time to live ) ) ; } while ( ! unique ) ; return value ; }	Generates new CSRF token and puts it in the session.
protected static void assure size ( final set < token > token set ) { if ( token set . size ( ) < max tokens per session ) { return ; } long valid until min = long . max value ; token token to remove = null ; iterator < token > iterator = token set . iterator ( ) ; while ( iterator . has next ( ) ) { token token = iterator . next ( ) ; if ( token . is expired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . valid until < valid until min ) { valid until min = token . valid until ; token to remove = token ; } } if ( ( token to remove != null ) && ( token set . size ( ) >= max tokens per session ) ) { token set . remove ( token to remove ) ; } }	Removes expired tokens if token set is full.
@ suppress warnings ( { str } ) public static boolean check csrf token ( final http session session , final string token value ) { set < token > token set = ( set < token > ) session . get attribute ( csrf token set ) ; if ( ( token set == null ) && ( token value == null ) ) { return bool ; } if ( ( token set == null ) || ( token value == null ) ) { return bool ; } boolean found = bool ; iterator < token > it = token set . iterator ( ) ; while ( it . has next ( ) ) { token t = it . next ( ) ; if ( t . is expired ( ) ) { it . remove ( ) ; continue ; } if ( t . get value ( ) . equals ( token value ) ) { it . remove ( ) ; found = bool ; } } return found ; }	Checks token value.C.
public static bean copy from ( final object source ) { bean copy bean copy = new bean copy ( source ) ; bean copy . is source map = source instanceof map ; return bean copy ; }	Defines source, detects a map.
public void copy ( ) { bean util = new bean util bean ( ) . declared ( declared ) . forced ( forced ) . silent ( bool ) ; visit ( ) ; }	Performs the copying.
@ override protected boolean visit property ( string name , final object value ) { if ( is target map ) { name = left sq bracket + name + right sq bracket ; } bean util . set property ( destination , name , value ) ; return bool ; }	Copies single property to the destination.Exceptions are ignored, so copying continues ifdestination does not have some of the sources properties.
@ override public void init ( final template data template data ) { super . init ( template data ) ; if ( entity != null ) { ded = lookup type ( entity ) ; } else { object object = template data . get object reference ( entity name ) ; if ( object != null ) { ded = lookup type ( resolve class ( object ) ) ; } else { ded = lookup name ( entity name ) ; } } string table reference = this . table reference ; if ( table reference == null ) { table reference = table alias ; } if ( table reference == null ) { table reference = entity name ; } if ( table reference == null ) { table reference = ded . get entity name ( ) ; } template data . register table reference ( table reference , ded , table alias ) ; }	Resolves and registers table references.
@ suppress warnings ( str ) public < s extends scope > s resolve scope ( final class < s > scope type ) { s scope = ( s ) scopes . get ( scope type ) ; if ( scope == null ) { try { scope = new internal instance ( scope type , ( petite container ) this ) ; } catch ( exception ex ) { throw new petite exception ( str + scope type . get name ( ) , ex ) ; } register scope ( scope type , scope ) ; scopes . put ( scope type , scope ) ; } return scope ; }	Resolves and registers scope from a scope type.
public < t > bean definition < t > register petite bean ( final class < t > type , string name , class < ? extends scope > scope type , wiring mode wiring mode , final boolean define , final consumer < t > consumer ) { if ( name == null ) { name = resolve bean name ( type ) ; } if ( wiring mode == null ) { wiring mode = annotation resolver . resolve bean wiring mode ( type ) ; } if ( wiring mode == wiring mode . default ) { wiring mode = petite config . get default wiring mode ( ) ; } if ( scope type == null ) { scope type = annotation resolver . resolve bean scope type ( type ) ; } if ( scope type == null ) { scope type = singleton scope . class ; }	Registers or defines a bean.
protected void register bean ( final string name , final bean definition bean definition ) { beans . put ( name , bean definition ) ; if ( ! petite config . is use alt bean names ( ) ) { return ; } class type = bean definition . type ( ) ; if ( annotation resolver . bean has annotation name ( type ) ) { return ; } class [ ] interfaces = class util . resolve all interfaces ( type ) ; for ( class an interface : interfaces ) { string alt name = annotation resolver . resolve bean name ( an interface , petite config . get use full type names ( ) ) ; if ( name . equals ( alt name ) ) { continue ; } if ( beans . contains key ( alt name ) ) { continue ; } if ( beans alt . contains key ( alt name ) ) { bean definition existing = beans alt . get ( alt name ) ; if ( existing != null ) { beans alt . put ( alt name , null ) ;	Registers bean definition by putting it in the beans map.
public void remove bean ( final class type ) {	Removes all petite beans of provided type.
protected string [ ] resolve bean names for type ( final class type ) { string [ ] bean names = bean collections . get ( type ) ; if ( bean names != null ) { return bean names ; } array list < string > list = new array list < > ( ) ; for ( map . entry < string , bean definition > entry : beans . entry set ( ) ) { bean definition bean definition = entry . get value ( ) ; if ( class util . is type of ( bean definition . type , type ) ) { string bean name = entry . get key ( ) ; list . add ( bean name ) ; } } if ( list . is empty ( ) ) { bean names = string pool . empty array ; } else { bean names = list . to array ( new string [ num ] ) ; } bean collections . put ( type , bean names ) ; return bean names ; }	Resolves bean names for give type.
public void register petite ctor injection point ( final string bean name , final class [ ] param types , final string [ ] references ) { bean definition bean definition = lookup existing bean definition ( bean name ) ; class descriptor cd = class introspector . get ( ) . lookup ( bean definition . type ) ; constructor constructor = null ; if ( param types == null ) { ctor descriptor [ ] ctors = cd . get all ctor descriptors ( ) ; if ( ctors != null && ctors . length > num ) { if ( ctors . length > num ) { throw new petite exception ( ctors . length + str + bean definition . type . get name ( ) ) ; } constructor = ctors [ num ] . get constructor ( ) ; } } else { ctor descriptor ctor descriptor = cd . get ctor descriptor ( param types , bool ) ; if ( ctor descriptor != null ) { constructor = ctor descriptor . get constructor ( ) ; } } if ( constructor == null ) { throw new petite exception ( str + bean definition . type . get name ( ) ) ; } bean references [ ] ref = references resolver . resolve reference from values ( constructor , references ) ; bean definition . ctor = new ctor injection point ( constructor , ref ) ; }	Registers constructor injection point.
public void register petite property injection point ( final string bean name , final string property , final string reference ) { bean definition bean definition = lookup existing bean definition ( bean name ) ; class descriptor cd = class introspector . get ( ) . lookup ( bean definition . type ) ; property descriptor property descriptor = cd . get property descriptor ( property , bool ) ; if ( property descriptor == null ) { throw new petite exception ( str + bean definition . type . get name ( ) + str + property ) ; } bean references ref = references resolver . resolve reference from value ( property descriptor , reference ) ; property injection point pip = new property injection point ( property descriptor , ref ) ; bean definition . add property injection point ( pip ) ; }	Registers property injection point.
public void register petite set injection point ( final string bean name , final string property ) { bean definition bean definition = lookup existing bean definition ( bean name ) ; class descriptor cd = class introspector . get ( ) . lookup ( bean definition . type ) ; property descriptor property descriptor = cd . get property descriptor ( property , bool ) ; if ( property descriptor == null ) { throw new petite exception ( str + bean definition . type . get name ( ) + str + property ) ; } set injection point sip = new set injection point ( property descriptor ) ; bean definition . add set injection point ( sip ) ; }	Registers set injection point.
public void register petite method injection point ( final string bean name , final string method name , final class [ ] arguments , final string [ ] references ) { bean definition bean definition = lookup existing bean definition ( bean name ) ; class descriptor cd = class introspector . get ( ) . lookup ( bean definition . type ) ; method method = null ; if ( arguments == null ) { method descriptor [ ] methods = cd . get all method descriptors ( method name ) ; if ( methods != null && methods . length > num ) { if ( methods . length > num ) { throw new petite exception ( methods . length + str + bean definition . type . get name ( ) + str + method name ) ; } method = methods [ num ] . get method ( ) ; } } else { method descriptor md = cd . get method descriptor ( method name , arguments , bool ) ; if ( md != null ) { method = md . get method ( ) ; } } if ( method == null ) { throw new petite exception ( str + bean definition . type . get name ( ) + str + method name ) ; } bean references [ ] ref = references resolver . resolve reference from values ( method , references ) ; method injection point mip = new method injection point ( method , ref ) ; bean definition . add method injection point ( mip ) ; }	Registers method injection point.
public void register petite init methods ( final string bean name , final init method invocation strategy invocation strategy , string ... init method names ) { bean definition bean definition = lookup existing bean definition ( bean name ) ; class descriptor cd = class introspector . get ( ) . lookup ( bean definition . type ) ; if ( init method names == null ) { init method names = string pool . empty array ; } int total = init method names . length ; init method point [ ] init method points = new init method point [ total ] ; int i ; for ( i = num ; i < init method names . length ; i ++ ) { method descriptor md = cd . get method descriptor ( init method names [ i ] , class util . empty class array , bool ) ; if ( md == null ) { throw new petite exception ( str + bean definition . type . get name ( ) + str + init method names [ i ] ) ; } init method points [ i ] = new init method point ( md . get method ( ) , i , invocation strategy ) ; } bean definition . add init method points ( init method points ) ; }	Registers init method.
public void register petite destroy methods ( final string bean name , string ... destroy method names ) { bean definition bean definition = lookup existing bean definition ( bean name ) ; class descriptor cd = class introspector . get ( ) . lookup ( bean definition . type ) ; if ( destroy method names == null ) { destroy method names = string pool . empty array ; } int total = destroy method names . length ; destroy method point [ ] destroy method points = new destroy method point [ total ] ; int i ; for ( i = num ; i < destroy method names . length ; i ++ ) { method descriptor md = cd . get method descriptor ( destroy method names [ i ] , class util . empty class array , bool ) ; if ( md == null ) { throw new petite exception ( str + bean definition . type . get name ( ) + str + destroy method names [ i ] ) ; } destroy method points [ i ] = new destroy method point ( md . get method ( ) ) ; } bean definition . add destroy method points ( destroy method points ) ; }	Registers destroy method.
public void register petite provider ( final string provider name , final string bean name , final string method name , final class [ ] arguments ) { bean definition bean definition = lookup bean definition ( bean name ) ; if ( bean definition == null ) { throw new petite exception ( str + bean name ) ; } class bean type = bean definition . type ; class descriptor cd = class introspector . get ( ) . lookup ( bean type ) ; method descriptor md = cd . get method descriptor ( method name , arguments , bool ) ; if ( md == null ) { throw new petite exception ( str + method name ) ; } provider definition provider definition = new provider definition ( provider name , bean name , md . get method ( ) ) ; providers . put ( provider name , provider definition ) ; }	Registers instance method provider.
public void register petite provider ( final string provider name , final class type , final string static method name , final class [ ] arguments ) { class descriptor cd = class introspector . get ( ) . lookup ( type ) ; method descriptor md = cd . get method descriptor ( static method name , arguments , bool ) ; if ( md == null ) { throw new petite exception ( str + static method name ) ; } provider definition provider definition = new provider definition ( provider name , md . get method ( ) ) ; providers . put ( provider name , provider definition ) ; }	Registers static method provider.
public void for each bean type ( final class type , final consumer < string > bean name consumer ) { for each bean ( bd -> { if ( class util . is type of ( bd . type , type ) ) { bean name consumer . accept ( bd . name ) ; } } ) ; }	Iterates all beans that are of given type.
public void define parameters ( final map < ? , ? > properties ) { for ( map . entry < ? , ? > entry : properties . entry set ( ) ) { define parameter ( entry . get key ( ) . to string ( ) , entry . get value ( ) ) ; } }	Defines many parameters at once.
@ override public object intercept ( final action request action request ) throws exception { print before ( action request ) ; long start time = system . current time millis ( ) ; object result = null ; try { result = action request . invoke ( ) ; } catch ( exception ex ) { result = str ; throw ex ; } catch ( throwable th ) { result = str ; throw new exception ( th ) ; } finally { long execution time = system . current time millis ( ) - start time ; print after ( action request , execution time , result ) ; } return result ; }	Measure action invocation time.
public static int resolve java version ( final int version ) { final int java version number = system util . info ( ) . get java version number ( ) ; final int platform version = java version number - num + num ; return version > platform version ? version : platform version ; }	Resolves Java version from current version.
public static void push int ( final method visitor mv , final int value ) { if ( value <= num ) { mv . visit insn ( iconst 0 + value ) ; } else if ( value <= byte . max value ) { mv . visit int insn ( bipush , value ) ; } else { mv . visit int insn ( sipush , value ) ; } }	Pushes int value in an optimal way.
public static void check argument index ( final method info method info , final int arg index ) { if ( ( arg index < num ) || ( arg index > method info . get arguments count ( ) ) ) { throw new proxetta exception ( str + arg index ) ; } }	Validates argument index.
public static string advice field name ( final string name , final int index ) { return proxetta names . field prefix + name + proxetta names . field divider + index ; }	Builds advice field name.
public static string advice method name ( final string name , final int index ) { return proxetta names . method prefix + name + proxetta names . method divider + index ; }	Builds advice method name.
public static void load special method arguments ( final method visitor mv , final method info method info ) { mv . visit var insn ( aload , num ) ; for ( int i = num ; i <= method info . get arguments count ( ) ; i ++ ) { load method argument ( mv , method info , i ) ; } }	Loads all method arguments before INVOKESPECIAL call.
public static void load static method arguments ( final method visitor mv , final method info method info ) { for ( int i = num ; i < method info . get arguments count ( ) ; i ++ ) { load method argument ( mv , method info , i ) ; } }	Loads all method arguments before INVOKESTATIC call.
public static void load virtual method arguments ( final method visitor mv , final method info method info ) { for ( int i = num ; i <= method info . get arguments count ( ) ; i ++ ) { load method argument ( mv , method info , i ) ; } }	Loads all method arguments before INVOKEVIRTUAL call.
public static void load method argument ( final method visitor mv , final method info method info , final int index ) { int offset = method info . get argument offset ( index ) ; int type = method info . get argument ( index ) . get opcode ( ) ; switch ( type ) { case str : break ; case str : case str : case str : case str : case str : mv . visit var insn ( iload , offset ) ; break ; case str : mv . visit var insn ( lload , offset ) ; break ; case str : mv . visit var insn ( fload , offset ) ; break ; case str : mv . visit var insn ( dload , offset ) ; break ; default : mv . visit var insn ( aload , offset ) ; } }	Loads one argument. Index is 1-based. No conversion occurs.
public static void store method argument ( final method visitor mv , final method info method info , final int index ) { int offset = method info . get argument offset ( index ) ; int type = method info . get argument ( index ) . get opcode ( ) ; switch ( type ) { case str : break ; case str : case str : case str : case str : case str : mv . visit var insn ( istore , offset ) ; break ; case str : mv . visit var insn ( lstore , offset ) ; break ; case str : mv . visit var insn ( fstore , offset ) ; break ; case str : mv . visit var insn ( dstore , offset ) ; break ; default : mv . visit var insn ( astore , offset ) ; } }	Stores one argument. Index is 1-based. No conversion occurs.
public static void prepare return value ( final method visitor mv , final method info method info , int var offset ) { var offset += method info . get all arguments size ( ) ; switch ( method info . get return type ( ) . get opcode ( ) ) { case str : mv . visit insn ( aconst null ) ; break ; case str : asm util . value of byte ( mv ) ; break ; case str : asm util . value of character ( mv ) ; break ; case str : asm util . value of short ( mv ) ; break ; case str : asm util . value of integer ( mv ) ; break ; case str : asm util . value of boolean ( mv ) ; break ; case str : asm util . value of long ( mv ) ; break ; case str : asm util . value of float ( mv ) ; break ; case str : asm util . value of double ( mv ) ; break ; } }	Prepares return value.
public static string create method signatures key ( final int access , final string method name , final string description , final string class name ) { return new string band ( num ) . append ( access ) . append ( colon ) . append ( description ) . append ( string pool . underscore ) . append ( class name ) . append ( string pool . hash ) . append ( method name ) . to string ( ) ; }	Creates unique key for method signatures map.
public static void new array ( final method visitor mv , final class component type ) { if ( component type == int . class ) { mv . visit int insn ( newarray , t int ) ; return ; } if ( component type == long . class ) { mv . visit int insn ( newarray , t long ) ; return ; } if ( component type == float . class ) { mv . visit int insn ( newarray , t float ) ; return ; } if ( component type == double . class ) { mv . visit int insn ( newarray , t double ) ; return ; } if ( component type == byte . class ) { mv . visit int insn ( newarray , t byte ) ; return ; } if ( component type == short . class ) { mv . visit int insn ( newarray , t short ) ; return ; } if ( component type == boolean . class ) { mv . visit int insn ( newarray , t boolean ) ; return ; } if ( component type == char . class ) { mv . visit int insn ( newarray , t char ) ; return ; } mv . visit type insn ( anewarray , asm util . type to signature ( component type ) ) ; }	Creates new array.
public static void store into array ( final method visitor mv , final class component type ) { if ( component type == int . class ) { mv . visit insn ( iastore ) ; return ; } if ( component type == long . class ) { mv . visit insn ( lastore ) ; return ; } if ( component type == float . class ) { mv . visit insn ( fastore ) ; return ; } if ( component type == double . class ) { mv . visit insn ( dastore ) ; return ; } if ( component type == byte . class ) { mv . visit insn ( bastore ) ; return ; } if ( component type == short . class ) { mv . visit insn ( sastore ) ; return ; } if ( component type == boolean . class ) { mv . visit insn ( bastore ) ; return ; } if ( component type == char . class ) { mv . visit insn ( castore ) ; return ; } mv . visit insn ( aastore ) ; }	Stores element on stack into an array.
public static string extract encoding ( final string content type , string default encoding ) { string encoding = extract encoding ( content type ) ; if ( encoding == null ) { if ( default encoding == null ) { default encoding = jodd core . encoding ; } encoding = default encoding ; } return encoding ; }	Extracts encoding from a given content type.
public static boolean is empty flags ( flags flags ) { if ( flags == null ) return bool ; flags . flag [ ] system flags = flags . get system flags ( ) ; if ( system flags != null && system flags . length > num ) { return bool ; } string [ ] user flags = flags . get user flags ( ) ; if ( user flags != null && user flags . length > num ) { return bool ; } return bool ; }	Check whether flags is a empty flags.
public static string resolve auth bearer token ( final http servlet request request ) { string header = request . get header ( header authorization ) ; if ( header == null ) { return null ; } int ndx = header . index of ( str ) ; if ( ndx == - num ) { return null ; } return header . substring ( ndx + num ) . trim ( ) ; }	Returns Bearer token.
public static void require authentication ( final http servlet response resp , final string realm ) throws io { resp . set header ( www authenticate , str + realm + str ) ; resp . send error ( http servlet response . sc unauthorized ) ; }	Sends correct headers to require basic authentication for the given realm.
public static void prepare download ( final http servlet response response , final file file , final string mime type ) { if ( ! file . exists ( ) ) { throw new illegal argument exception ( str + file ) ; } if ( file . length ( ) > integer . max value ) { throw new illegal argument exception ( str + file ) ; } prepare response ( response , file . get absolute path ( ) , mime type , ( int ) file . length ( ) ) ; }	Prepares response for file download with provided mime type.
public static void prepare response ( final http servlet response response , final string file name , string mime type , final int file size ) { if ( ( mime type == null ) && ( file name != null ) ) { string extension = file name util . get extension ( file name ) ; mime type = mime types . get mime type ( extension ) ; } if ( mime type != null ) { response . set content type ( mime type ) ; } if ( file size >= num ) { response . set content length ( file size ) ; }	Prepares response for various provided data.
public static cookie [ ] get all cookies ( final http servlet request request , final string cookie name ) { cookie [ ] cookies = request . get cookies ( ) ; if ( cookies == null ) { return null ; } array list < cookie > list = new array list < > ( cookies . length ) ; for ( cookie cookie : cookies ) { if ( cookie . get name ( ) . equals ( cookie name ) ) { list . add ( cookie ) ; } } if ( list . is empty ( ) ) { return null ; } return list . to array ( new cookie [ num ] ) ; }	Returns all cookies from client that matches provided name.
public static string read request body from reader ( final http servlet request request ) throws io { buffered reader buff = request . get reader ( ) ; string writer out = new string writer ( ) ; stream util . copy ( buff , out ) ; return out . to string ( ) ; }	Reads HTTP request body using the request reader. Once body is read,it cannot be read again!.
public static string read request body from stream ( final http servlet request request ) throws io { string char encoding = request . get character encoding ( ) ; if ( char encoding == null ) { char encoding = jodd core . encoding ; } char array writer char array writer = new char array writer ( ) ; buffered reader buffered reader = null ; try { input stream input stream = request . get input stream ( ) ; if ( input stream != null ) { buffered reader = new buffered reader ( new input stream reader ( input stream , char encoding ) ) ; stream util . copy ( buffered reader , char array writer ) ; } else { return string pool . empty ; } } finally { stream util . close ( buffered reader ) ; } return char array writer . to string ( ) ; }	Reads HTTP request body using the request stream. Once body is read,it cannot be read again!.
public static void store context path ( final page context page context , final string context path variable name ) { string ctx path = get context path ( page context ) ; http servlet request request = ( http servlet request ) page context . get request ( ) ; request . set attribute ( context path variable name , ctx path ) ; servlet context servlet context = page context . get servlet context ( ) ; servlet context . set attribute ( context path variable name , ctx path ) ; }	Stores context path in server context and request scope.
public static void store context path ( final servlet context servlet context , final string context path variable name ) { string ctx path = get context path ( servlet context ) ; servlet context . set attribute ( context path variable name , ctx path ) ; }	Stores context path in page context and request scope.
public boolean is get parameter ( final http servlet request request , string name ) { name = url . encode query param ( name ) + str ; string query = request . get query string ( ) ; string [ ] name value pairs = string util . splitc ( query , str ) ; for ( string name value pair : name value pairs ) { if ( name value pair . starts with ( name ) ) { return bool ; } } return bool ; }	Checks if some parameter is in GET parameters.
public static string [ ] prepare parameters ( final string [ ] param values , final boolean treat empty params as null , final boolean ignore empty request params ) { if ( treat empty params as null || ignore empty request params ) { int empty count = num ; int total = param values . length ; for ( int i = num ; i < param values . length ; i ++ ) { string param value = param values [ i ] ; if ( param value == null ) { empty count ++ ; continue ; } if ( param value . length ( ) == num ) { empty count ++ ; if ( treat empty params as null ) { param value = null ; } } param values [ i ] = param value ; } if ( ( ignore empty request params ) && ( empty count == total ) ) { return null ; } } return param values ; }	Prepares parameters for further processing.
public static void copy params to attributes ( final http servlet request servlet request , final boolean treat empty params as null , final boolean ignore empty request params ) { enumeration param names = servlet request . get parameter names ( ) ; while ( param names . has more elements ( ) ) { string param name = ( string ) param names . next element ( ) ; if ( servlet request . get attribute ( param name ) != null ) { continue ; } string [ ] param values = servlet request . get parameter values ( param name ) ; param values = prepare parameters ( param values , treat empty params as null , ignore empty request params ) ; if ( param values == null ) { continue ; } servlet request . set attribute ( param name , param values . length == num ? param values [ num ] : param values ) ; }	Copies all request parameters to attributes.
public static void invoke body ( final jsp fragment body ) throws jsp exception { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( io ioex ) { throw new jsp exception ( str , ioex ) ; } }	Invokes tag body.
public static char [ ] render body ( final jsp fragment body ) throws jsp exception { fast char array writer writer = new fast char array writer ( ) ; invoke body ( body , writer ) ; return writer . to char array ( ) ; }	Renders tag body to char array.
public static string render body to string ( final jsp fragment body ) throws jsp exception { char [ ] result = render body ( body ) ; return new string ( result ) ; }	Renders tag body to string.
public void invoke init methods ( final init method invocation strategy invocation strategy ) { for ( final init method point init method : bean definition . init method points ( ) ) { if ( invocation strategy != init method . invocation strategy ) { continue ; } try { init method . method . invoke ( bean ) ; } catch ( exception ex ) { throw new petite exception ( str + init method , ex ) ; } } }	Invokes init methods.
public void call destroy methods ( ) { for ( final destroy method point destroy method point : bean definition . destroy method points ( ) ) { try { destroy method point . method . invoke ( bean ) ; } catch ( exception ex ) { throw new petite exception ( str + destroy method point . method , ex ) ; } } }	Calls destroy methods on given BeanData.
public object new bean instance ( ) { if ( bean definition . ctor == ctor injection point . empty ) { throw new petite exception ( str + bean definition . type . get name ( ) ) ; } int param no = bean definition . ctor . references . length ; object [ ] args = new object [ param no ] ;	Creates a new instance.
public void inject params ( final param manager param manager , final boolean implicit param injection ) { if ( bean definition . name == null ) { return ; } if ( implicit param injection ) {	Injects all parameters.
@ suppress warnings ( { str } ) public string rewrite ( final http servlet request servlet request , final string action path , final string http method ) { return action path ; }	Rewrites action path.
public void add header ( final string name , final string value ) { list < string > values list = super . get all ( name ) ; if ( values list . is empty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; values list . add ( value ) ; super . add all ( name , values list ) ; }	Adds new header value.
protected void put ( final string profile , final map < string , props entry > map , final string key , final string value , final boolean append ) { string real value = value ; if ( append || append duplicate props ) { props entry pv = map . get ( key ) ; if ( pv != null ) { real value = pv . value + append separator + real value ; } } props entry props entry = new props entry ( key , real value , profile , this ) ;	Puts key-value pair into the map, with respect of appending duplicate properties.
public void put base property ( final string key , final string value , final boolean append ) { put ( null , base properties , key , value , append ) ; }	Adds base property.
public void put profile property ( final string key , final string value , final string profile , final boolean append ) { map < string , props entry > map = profile properties . compute if absent ( profile , k -> new hash map < > ( ) ) ; put ( profile , map , key , value , append ) ; }	Adds profile property.
public props entry get profile property ( final string profile , final string key ) { final map < string , props entry > profile map = profile properties . get ( profile ) ; if ( profile map == null ) { return null ; } return profile map . get ( key ) ; }	Returns profile property.
public string resolve macros ( string value , final string ... profiles ) {	Resolves all macros in this props set.
public map extract ( map target , final string [ ] profiles , final string [ ] wildcard patterns , string prefix ) { if ( target == null ) { target = new hash map ( ) ; }	Extracts props to target map.
private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = num ; int off = offp [ num ] ; for ( i = num ; i < num ; i ++ ) { word = ( word << num ) | ( data [ off ] & num ) ; off = ( off + num ) % data . length ; } offp [ num ] = off ; return word ; }	Cycically extract a word of key material.
public static string hashpw ( string password , string salt ) { b b ; string real salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) num ; int rounds , off ; string buffer rs = new string buffer ( ) ; if ( salt . char at ( num ) != str || salt . char at ( num ) != str ) { throw new illegal argument exception ( str ) ; } if ( salt . char at ( num ) == str ) { off = num ; } else { minor = salt . char at ( num ) ; if ( minor != str || salt . char at ( num ) != str ) { throw new illegal argument exception ( str ) ; } off = num ; }	Hash a password using the OpenBSD bcrypt scheme.
public static boolean checkpw ( string plaintext , string hashed ) { byte [ ] hashed bytes ; byte [ ] try bytes ; try { string try pw = hashpw ( plaintext , hashed ) ; hashed bytes = hashed . get bytes ( str ) ; try bytes = try pw . get bytes ( str ) ; } catch ( unsupported encoding exception uee ) { return bool ; } if ( hashed bytes . length != try bytes . length ) { return bool ; } byte ret = num ; for ( int i = num ; i < try bytes . length ; i ++ ) { ret |= hashed bytes [ i ] ^ try bytes [ i ] ; } return ret == num ; }	Check that a plaintext password matches a previously hashedone.
public int copy all ( final output stream out ) throws io { int count = num ; while ( bool ) { byte b = read byte ( ) ; if ( is boundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }	Copies bytes from this stream to some output until boundary isreached.
public int copy max ( final output stream out , final int max bytes ) throws io { int count = num ; while ( bool ) { byte b = read byte ( ) ; if ( is boundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == max bytes ) { return count ; } } return count ; }	Copies max or less number of bytes to output stream.
public action runtime parse ( final class < ? > action class , final method action method , action definition action definition ) { final action annotation values annotation values = detect action annotation values ( action method ) ; final action config action config = resolve action config ( annotation values ) ;	Parses java action method annotation and returns its action runtime.
protected action config resolve action config ( final action annotation values annotation values ) { final class < ? extends annotation > annotation type ; if ( annotation values == null ) { annotation type = action . class ; } else { annotation type = annotation values . annotation type ( ) ; } return action config manager . lookup ( annotation type ) ; }	Resolves action config.
protected void detect and register alias ( final action annotation values annotation values , final action definition action definition ) { final string alias = parse method alias ( annotation values ) ; if ( alias != null ) { string alias path = string util . cut to index of ( action definition . action path ( ) , string pool . hash ) ; actions manager . register path alias ( alias , alias path ) ; } }	Detects if alias is defined in annotation and registers it if so.
protected class < ? extends action interceptor > [ ] read action interceptors ( final annotated element action class or method ) { class < ? extends action interceptor > [ ] result = null ; intercepted by intercepted by = action class or method . get annotation ( intercepted by . class ) ; if ( intercepted by != null ) { result = intercepted by . value ( ) ; if ( result . length == num ) { result = null ; } } return result ; }	Reads class or method annotation for action interceptors.
protected class < ? extends action filter > [ ] read action filters ( final annotated element action class or method ) { class < ? extends action filter > [ ] result = null ; filtered by filtered by = action class or method . get annotation ( filtered by . class ) ; if ( filtered by != null ) { result = filtered by . value ( ) ; if ( result . length == num ) { result = null ; } } return result ; }	Reads class or method annotation for action filters.
protected string [ ] read package action path ( final class action class ) { package action package = action class . get package ( ) ; final string action package name = action package . get name ( ) ;	Reads action path for package.If annotation is not set on package-level, class package will be used forpackage action path part.
protected string [ ] read method action path ( final string method name , final action annotation values annotation values , final action config action config ) {	Reads action path from the action method.
protected string parse method alias ( final action annotation values annotation values ) { string alias = null ; if ( annotation values != null ) { alias = annotation values . alias ( ) ; } return alias ; }	Reads method's alias value.
public action runtime create action runtime ( final action handler action handler , final class action class , final method action class method , final class < ? extends action result > action result , final class < ? extends action result > default action result , final action filter [ ] filters , final action interceptor [ ] interceptors , final action definition action definition , final boolean async , final boolean auth ) { if ( action handler != null ) { return new action runtime ( action handler , action class , action class method , filters , interceptors , action definition , none action result . class , none action result . class , async , auth , null , null ) ; } final scope data scope data = scope data inspector . inspect class scopes ( action class ) ;	Creates new instance of action runtime configuration.Initialize caches.
@ override protected void pre response commit ( ) { long last modified = last modified data . get last modified ( ) ; long if modified since = request . get date header ( str ) ; if ( last modified > - num && ! response . contains header ( str ) ) { if ( if modified since < ( last modified / num * num ) ) { response . set date header ( str , last modified ) ; } else { response . reset ( ) ; response . set status ( http servlet response . sc not modified ) ; } } }	todo move to BufferResponseWrapper ?.
public static < t > t apply advice ( final class < t > target class ) { class advice class = cache . get ( target class ) ; if ( advice class == null ) {	Applies advice on given target class and returns proxy instance.
public static void inject target into proxy ( final object proxy , final object target ) { class proxy class = proxy . get class ( ) ; try { field field = proxy class . get field ( str ) ; field . set ( proxy , target ) ; } catch ( exception ex ) { throw new proxetta exception ( ex ) ; } }	Injects target into proxy.
public annotation visitor visit annotation ( final string descriptor , final boolean visible ) { if ( fv != null ) { return fv . visit annotation ( descriptor , visible ) ; } return null ; }	Visits an annotation of the field.
public string resolve real name ( final string json name ) { if ( json names == null ) { return json name ; } int json index = arrays util . index of ( json names , json name ) ; if ( json index == - num ) { return json name ; } return real names [ json index ] ; }	Resolves real name from JSON name.
public string resolve json name ( final string real name ) { if ( real names == null ) { return real name ; } int real index = arrays util . index of ( real names , real name ) ; if ( real index == - num ) { return real name ; } return json names [ real index ] ; }	Resolves JSON name from real name.
public type data lookup type data ( final class type ) { type data type data = type data map . get ( type ) ; if ( type data == null ) { if ( serialization subclass aware ) { type data = find subclass type data ( type ) ; } if ( type data == null ) { type data = scan class for annotations ( type ) ; type data map . put ( type , type data ) ; } } return type data ; }	Returns all includes for given type.
protected type data lookup type data ( final class type ) { type data type data = type data map . get ( type ) ; if ( type data == null ) { type data = scan class for annotations ( type ) ; type data map . put ( type , type data ) ; } return type data ; }	Lookups type data and creates one if missing.
protected type data find subclass type data ( final class type ) { final class < ? extends annotation > default annotation = json annotation ; if ( type . get annotation ( default annotation ) != null ) {	Finds type data of first annotated superclass or interface.
public string resolve json name ( final class type , final string name ) { type data type data = lookup type data ( type ) ; return type data . resolve json name ( name ) ; }	Returns different name of a property if set by annotation.
public string resolve real name ( final class type , final string json name ) { type data type data = lookup type data ( type ) ; return type data . resolve real name ( json name ) ; }	Returns real property name for given JSON property.
@ override public byte [ ] get file content ( ) throws io { if ( data != null ) { return data ; } if ( temp file != null ) { return file util . read bytes ( temp file ) ; } return null ; }	Returns the content of file upload item.
private void copy bootstrap methods ( final class reader class reader , final char [ ] char buffer ) {	Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries ofthe SymbolTable.
int set major version and class name ( final int major version , final string class name ) { this . major version = major version ; this . class name = class name ; return add constant class ( class name ) . index ; }	Sets the major version and the name of the class to which this symbol table belongs.
void put constant pool ( final byte vector output ) { output . put short ( constant pool count ) . put byte array ( constant pool . data , num , constant pool . length ) ; }	Puts this symbol table's constant_pool array in the given ByteVector, preceded by theconstant_pool_count value.
void put bootstrap methods ( final byte vector output ) { if ( bootstrap methods != null ) { output . put short ( add constant utf8 ( constants . bootstrap methods ) ) . put int ( bootstrap methods . length + num ) . put short ( bootstrap method count ) . put byte array ( bootstrap methods . data , num , bootstrap methods . length ) ; } }	Puts this symbol table's BootstrapMethods attribute in the given ByteVector.
symbol add constant fieldref ( final string owner , final string name , final string descriptor ) { return add constant member reference ( symbol . constant fieldref tag , owner , name , descriptor ) ; }	Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table.
symbol add constant methodref ( final string owner , final string name , final string descriptor , final boolean is interface ) { int tag = is interface ? symbol . constant interface methodref tag : symbol . constant methodref tag ; return add constant member reference ( tag , owner , name , descriptor ) ; }	Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of thissymbol table.
private entry add constant member reference ( final int tag , final string owner , final string name , final string descriptor ) { int hash code = hash ( tag , owner , name , descriptor ) ; entry entry = get ( hash code ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hash code == hash code && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constant pool . put122 ( tag , add constant class ( owner ) . index , add constant name and type ( name , descriptor ) ) ; return put ( new entry ( constant pool count ++ , tag , owner , name , descriptor , num , hash code ) ) ; }	Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info tothe constant pool of this symbol table.
private void add constant member reference ( final int index , final int tag , final string owner , final string name , final string descriptor ) { add ( new entry ( index , tag , owner , name , descriptor , num , hash ( tag , owner , name , descriptor ) ) ) ; }	Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_infoto the constant pool of this symbol table.
private symbol add constant integer or float ( final int tag , final int value ) { int hash code = hash ( tag , value ) ; entry entry = get ( hash code ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hash code == hash code && entry . data == value ) { return entry ; } entry = entry . next ; } constant pool . put byte ( tag ) . put int ( value ) ; return put ( new entry ( constant pool count ++ , tag , value , hash code ) ) ; }	Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.Does nothing if the constant pool already contains a similar item.
private void add constant integer or float ( final int index , final int tag , final int value ) { add ( new entry ( index , tag , value , hash ( tag , value ) ) ) ; }	Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symboltable.
private symbol add constant long or double ( final int tag , final long value ) { int hash code = hash ( tag , value ) ; entry entry = get ( hash code ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hash code == hash code && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constant pool count ; constant pool . put byte ( tag ) . put long ( value ) ; constant pool count += num ; return put ( new entry ( index , tag , value , hash code ) ) ; }	Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.Does nothing if the constant pool already contains a similar item.
private void add constant long or double ( final int index , final int tag , final long value ) { add ( new entry ( index , tag , value , hash ( tag , value ) ) ) ; }	Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symboltable.
int add constant name and type ( final string name , final string descriptor ) { final int tag = symbol . constant name and type tag ; int hash code = hash ( tag , name , descriptor ) ; entry entry = get ( hash code ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hash code == hash code && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constant pool . put122 ( tag , add constant utf8 ( name ) , add constant utf8 ( descriptor ) ) ; return put ( new entry ( constant pool count ++ , tag , name , descriptor , hash code ) ) . index ; }	Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table.
private void add constant name and type ( final int index , final string name , final string descriptor ) { final int tag = symbol . constant name and type tag ; add ( new entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }	Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.
int add constant utf8 ( final string value ) { int hash code = hash ( symbol . constant ut tag , value ) ; entry entry = get ( hash code ) ; while ( entry != null ) { if ( entry . tag == symbol . constant ut tag && entry . hash code == hash code && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constant pool . put byte ( symbol . constant ut tag ) . put ut ( value ) ; return put ( new entry ( constant pool count ++ , symbol . constant ut tag , value , hash code ) ) . index ; }	Adds a CONSTANT_Utf8_info to the constant pool of this symbol table.
private void add constant utf8 ( final int index , final string value ) { add ( new entry ( index , symbol . constant ut tag , value , hash ( symbol . constant ut tag , value ) ) ) ; }	Adds a new CONSTANT_String_info to the constant pool of this symbol table.
private void add constant method handle ( final int index , final int reference kind , final string owner , final string name , final string descriptor ) { final int tag = symbol . constant method handle tag ; int hash code = hash ( tag , owner , name , descriptor , reference kind ) ; add ( new entry ( index , tag , owner , name , descriptor , reference kind , hash code ) ) ; }	Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.
symbol add constant dynamic ( final string name , final string descriptor , final handle bootstrap method handle , final object ... bootstrap method arguments ) { symbol bootstrap method = add bootstrap method ( bootstrap method handle , bootstrap method arguments ) ; return add constant dynamic or invoke dynamic reference ( symbol . constant dynamic tag , name , descriptor , bootstrap method . index ) ; }	Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table.
symbol add constant invoke dynamic ( final string name , final string descriptor , final handle bootstrap method handle , final object ... bootstrap method arguments ) { symbol bootstrap method = add bootstrap method ( bootstrap method handle , bootstrap method arguments ) ; return add constant dynamic or invoke dynamic reference ( symbol . constant invoke dynamic tag , name , descriptor , bootstrap method . index ) ; }	Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table.
private symbol add constant dynamic or invoke dynamic reference ( final int tag , final string name , final string descriptor , final int bootstrap method index ) { int hash code = hash ( tag , name , descriptor , bootstrap method index ) ; entry entry = get ( hash code ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hash code == hash code && entry . data == bootstrap method index && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constant pool . put122 ( tag , bootstrap method index , add constant name and type ( name , descriptor ) ) ; return put ( new entry ( constant pool count ++ , tag , null , name , descriptor , bootstrap method index , hash code ) ) ; }	Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symboltable.
private void add constant dynamic or invoke dynamic reference ( final int tag , final int index , final string name , final string descriptor , final int bootstrap method index ) { int hash code = hash ( tag , name , descriptor , bootstrap method index ) ; add ( new entry ( index , tag , null , name , descriptor , bootstrap method index , hash code ) ) ; }	Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of thissymbol table.
private symbol add constant utf8 reference ( final int tag , final string value ) { int hash code = hash ( tag , value ) ; entry entry = get ( hash code ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hash code == hash code && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constant pool . put12 ( tag , add constant utf8 ( value ) ) ; return put ( new entry ( constant pool count ++ , tag , value , hash code ) ) ; }	Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.
private void add constant utf8 reference ( final int index , final int tag , final string value ) { add ( new entry ( index , tag , value , hash ( tag , value ) ) ) ; }	Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.
symbol add bootstrap method ( final handle bootstrap method handle , final object ... bootstrap method arguments ) { byte vector bootstrap methods attribute = bootstrap methods ; if ( bootstrap methods attribute == null ) { bootstrap methods attribute = bootstrap methods = new byte vector ( ) ; }	Adds a bootstrap method to the BootstrapMethods attribute of this symbol table.
int add merged type ( final int type table index1 , final int type table index2 ) {	Adds a merged type in the type table of this symbol table.
private int hash ( final string name ) { int h = num ; for ( int i = name . length ( ) - num ; i >= num ; i -- ) { char c = name . char at ( i ) ; if ( ! case sensitive ) { if ( c >= str && c <= str ) { c += num ; } } h = num * h + c ; } if ( h > num ) { return h ; } if ( h == integer . min value ) { return integer . max value ; } return - h ; }	Calculates hash value of the input string.
public http multi map < v > clear ( ) { for ( int i = num ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }	Clears the map.
public list < v > get all ( final string name ) { linked list < v > values = new linked list < > ( ) ; int h = hash ( name ) ; int i = index ( h ) ; map entry < v > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . add first ( e . get value ( ) ) ; } e = e . next ; } return values ; }	Returns all values associated with the name.
@ override public iterator < map . entry < string , v > > iterator ( ) { final map entry [ ] e = { head . after } ; return new iterator < map . entry < string , v > > ( ) { @ override public boolean has next ( ) { return e [ num ] != head ; } @ override @ suppress warnings ( str ) public map . entry < string , v > next ( ) { if ( ! has next ( ) ) { throw new no such element exception ( str ) ; } map entry < v > next = e [ num ] ; e [ num ] = e [ num ] . after ; return next ; } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }	Returns iterator of all entries.
public list < map . entry < string , v > > entries ( ) { list < map . entry < string , v > > all = new linked list < > ( ) ; map entry < v > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }	Returns all the entries of this map.
private void grow ( final int min capacity ) { final int old capacity = buffer . length ; int new capacity = old capacity << num ; if ( new capacity - min capacity < num ) {	Grows the buffer.
@ override public fast char buffer append ( final char sequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( csq . char at ( i ) ) ; } return this ; }	Appends character sequence to buffer.
@ override public annotation visitor visit annotation ( final string desc , final boolean visible ) { annotation visitor dest ann = method visitor . visit annotation ( desc , visible ) ;	Copies target method annotations.
@ override public void visit end ( ) { create first chain delegate ( tmd ) ; for ( int p = num ; p < tmd . proxy data . length ; p ++ ) { tmd . select current proxy ( p ) ; create proxy method ( tmd ) ; } }	Finally, builds proxy methods if applied to current method.
protected void create first chain delegate ( ) {	Starts creation of first chain delegate.
protected void create first chain delegate ( final target method data tmd ) { method visitor . visit code ( ) ; if ( tmd . msign . is static ) { load static method arguments ( method visitor , tmd . msign ) ; method visitor . visit method insn ( invokestatic , wd . this reference , tmd . first method name ( ) , tmd . msign . get description ( ) , bool ) ; } else { load special method arguments ( method visitor , tmd . msign ) ; method visitor . visit method insn ( invokespecial , wd . this reference , tmd . first method name ( ) , tmd . msign . get description ( ) , bool ) ; } visit return ( method visitor , tmd . msign , bool ) ; method visitor . visit maxs ( num , num ) ; method visitor . visit end ( ) ; }	Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method.This method mirrors the target method.
public static path parse ( final string path ) { return path == null ? new path ( ) : new path ( string util . splitc ( path , str ) ) ; }	Parses input dot-separated string that represents a path.
public path push ( final char sequence field ) { push ( field ) ; if ( alt path != null ) { alt path . push ( field ) ; } return this ; }	Push element to the path.
private void configure servlet context ( final servlet context servlet context ) { servlet context . add listener ( jodd . servlet . request context listener . class ) ; if ( decora enabled ) { final filter registration filter = servlet context . add filter ( str , jodd . decora . decora servlet filter . class ) ; filter . add mapping for url patterns ( null , bool , context path ) ; } final filter registration filter = servlet context . add filter ( str , jodd . madvoc . madvoc servlet filter . class ) ; filter . add mapping for url patterns ( madvoc dispatcher types , bool , context path ) ; }	Configures servlet context.
public object execute ( ) { string method name = target method name ( ) ; class return type = return type ( ) ; object next = pathref . continue with ( this , method name , return type ) ; return proxy target . return value ( next ) ; }	Reads method name and appends it.
public field descriptor [ ] get all field descriptors ( ) { if ( all fields == null ) { field descriptor [ ] all fields = new field descriptor [ fields map . size ( ) ] ; int index = num ; for ( field descriptor field descriptor : fields map . values ( ) ) { all fields [ index ] = field descriptor ; index ++ ; } arrays . sort ( all fields , comparator . comparing ( fd -> fd . get field ( ) . get name ( ) ) ) ; this . all fields = all fields ; } return all fields ; }	Returns all fields of this collection.
@ suppress warnings ( str ) @ override protected < t > bean definition < t > create bean definition for registration ( final string name , class < t > type , final scope scope , final wiring mode wiring mode , final consumer < t > consumer ) { if ( proxetta != null ) { final class original type = type ; final proxetta factory builder = proxetta . proxy ( ) ; builder . set target ( type ) ; type = builder . define ( ) ; return new proxetta bean definition ( name , type , scope , wiring mode , original type , proxetta . get aspects ( new proxy aspect [ num ] ) , consumer ) ; } return super . create bean definition for registration ( name , type , scope , wiring mode , consumer ) ; }	Applies proxetta on bean class before bean registration.
public static db transaction mode convert to db mode ( final jtx transaction mode tx mode ) { final int isolation ; switch ( tx mode . get isolation level ( ) ) { case isolation default : isolation = db transaction mode . isolation default ; break ; case isolation none : isolation = db transaction mode . isolation none ; break ; case isolation read committed : isolation = db transaction mode . isolation read committed ; break ; case isolation read uncommitted : isolation = db transaction mode . isolation read uncommitted ; break ; case isolation repeatable read : isolation = db transaction mode . isolation repeatable read ; break ; case isolation serializable : isolation = db transaction mode . isolation serializable ; break ; default : throw new illegal argument exception ( ) ; } return new db transaction mode ( isolation , tx mode . is read only ( ) ) ; }	Converter JTX transaction mode to DB transaction mode.
private object read property ( final object source , final property descriptor property descriptor ) { getter getter = property descriptor . get getter ( declared ) ; if ( getter != null ) { try { return getter . invoke getter ( source ) ; } catch ( exception ex ) { throw new json exception ( ex ) ; } } return null ; }	Reads property using property descriptor.
@ override public void put all ( final map t ) { for ( object o : t . entry set ( ) ) { map . entry e = ( map . entry ) o ; put ( e . get key ( ) , e . get value ( ) ) ; } }	Copies all of the mappings from the specified map to this one.These mappings replace any mappings that this map had for any of thekeys currently in the specified Map.
public buffer append ( final buffer buffer ) { if ( buffer . list . is empty ( ) ) {	Appends other buffer to this one.
public void write to ( final writer writer ) throws io { for ( object o : list ) { if ( o instanceof fast byte buffer ) { fast byte buffer fast byte buffer = ( fast byte buffer ) o ; byte [ ] array = fast byte buffer . to array ( ) ; writer . write ( new string ( array , string pool . iso 8859 1 ) ) ; } else if ( o instanceof uploadable ) { uploadable uploadable = ( uploadable ) o ; input stream input stream = uploadable . open input stream ( ) ; try { stream util . copy ( input stream , writer , string pool . iso 8859 1 ) ; } finally { stream util . close ( input stream ) ; } } } }	Writes content to the writer.
public void write to ( final output stream out ) throws io { for ( object o : list ) { if ( o instanceof fast byte buffer ) { fast byte buffer fast byte buffer = ( fast byte buffer ) o ; out . write ( fast byte buffer . to array ( ) ) ; } else if ( o instanceof uploadable ) { uploadable uploadable = ( uploadable ) o ; input stream input stream = uploadable . open input stream ( ) ; try { stream util . copy ( input stream , out ) ; } finally { stream util . close ( input stream ) ; } } } }	Writes content to the output stream.
public void write to ( final output stream out , final http progress listener progress listener ) throws io {	Writes content to the output stream, using progress listener to track the sending progress.
public string get string ( final string key ) { char sequence cs = ( char sequence ) map . get ( key ) ; return cs == null ? null : cs . to string ( ) ; }	Returns the string value with the specified key.
public integer get integer ( final string key ) { number number = ( number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof integer ) { return ( integer ) number ; } return number . int value ( ) ; }	returns the integer value with the specified key.
public long get long ( final string key ) { number number = ( number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof long ) { return ( long ) number ; } return number . long value ( ) ; }	Returns the long value with the specified key.
public double get double ( final string key ) { number number = ( number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof double ) { return ( double ) number ; } return number . double value ( ) ; }	Returns the double value with the specified key.
public float get float ( final string key ) { number number = ( number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof float ) { return ( float ) number ; } return number . float value ( ) ; }	Returns the float value with the specified key.
@ suppress warnings ( str ) public < t > t get value ( final string key ) { t val = ( t ) map . get ( key ) ; if ( val instanceof map ) { return ( t ) new json object ( ( map ) val ) ; } if ( val instanceof list ) { return ( t ) new json array ( ( list ) val ) ; } return val ; }	Returns the value with the specified key, as an object.
public json object put ( final string key , final string value ) { objects . require non null ( key ) ; map . put ( key , value ) ; return this ; }	Puts a string into the JSON object with the specified key.
public void use folder ( final string folder name ) { close folder if opened ( folder ) ; try { this . folder name = folder name ; this . folder = get service ( ) . get folder ( folder name ) ; try { folder . open ( folder . read write ) ; } catch ( final mail exception ignore ) { folder . open ( folder . read only ) ; } } catch ( final messaging exception msgexc ) { throw new mail exception ( str + folder name , msgexc ) ; } }	Opens new folder and closes previously opened folder.
received email [ ] receive messages ( final email filter filter , final flags flags to set , final flags flags to unset , final boolean envelope , final consumer < message [ ] > processed message consumer ) { use and open folder if not set ( ) ; final message [ ] messages ; try { if ( filter == null ) { messages = folder . get messages ( ) ; } else { messages = folder . search ( filter . get search term ( ) ) ; } if ( messages . length == num ) { return received email . empty array ; } if ( envelope ) { final fetch profile fetch profile = new fetch profile ( ) ; fetch profile . add ( fetch profile . item . envelope ) ; fetch profile . add ( fetch profile . item . flags ) ; folder . fetch ( messages , fetch profile ) ; }	The main email receiving method.
public void update email flags ( final received email received email ) { use and open folder if not set ( ) ; try { folder . set flags ( new int [ ] { received email . message number ( ) } , received email . flags ( ) , bool ) ; } catch ( messaging exception mex ) { throw new mail exception ( str , mex ) ; } }	Updates the email flags on the server.
protected void close folder if opened ( final folder folder ) { if ( folder != null ) { try { folder . close ( bool ) ; } catch ( final messaging exception ignore ) { } } }	Closes folder if opened and expunge deleted messages.
db query named parameter lookup named parameter ( final string name ) { db query named parameter p = root np ; while ( p != null ) { if ( p . equals name ( name ) ) { return p ; } p = p . next ; } return null ; }	Lookup for named parameter.
protected boolean validate action ( final string ... profiles ) { prepare validator ( ) ; vtor . use profiles ( profiles ) ; vtor . validate ( this ) ; vtor . reset profiles ( ) ; list < violation > violations = vtor . get violations ( ) ; return violations == null ; }	Validates action. Profiles are reset after the invocation.
protected void add violation ( final string name , final object invalid value ) { prepare validator ( ) ; vtor . add violation ( new violation ( name , this , invalid value ) ) ; }	Adds action violation.
public raw data as ( final string mime or extension ) { if ( mime or extension . contains ( string pool . slash ) ) { this . mime type = mime or extension ; } else { this . mime type = mime types . get mime type ( mime or extension ) ; } return this ; }	Defines mime type by providing real mime type or just extension!.
public raw data downloadable as ( final string download file name ) { this . download file name = download file name ; this . mime type = mime types . get mime type ( file name util . get extension ( download file name ) ) ; return this ; }	Defines download file name and mime type from the name extension.
protected t set target ( final input stream target ) { assert target is not defined ( ) ; target input stream = target ; target class = null ; target class name = null ; return this ( ) ; }	Defines class input stream as a target.
protected t set target ( final string target name ) { assert target is not defined ( ) ; try { target input stream = class loader util . get class as stream ( target name ) ; if ( target input stream == null ) { throw new proxetta exception ( str + target name ) ; } target class name = target name ; target class = null ; } catch ( io ioex ) { stream util . close ( target input stream ) ; throw new proxetta exception ( str + target name , ioex ) ; } return this ( ) ; }	Defines class name as a target.Class will not be loaded by classloader!.
public t set target ( final class target ) { assert target is not defined ( ) ; try { target input stream = class loader util . get class as stream ( target ) ; if ( target input stream == null ) { throw new proxetta exception ( str + target . get name ( ) ) ; } target class = target ; target class name = target . get name ( ) ; } catch ( io ioex ) { stream util . close ( target input stream ) ; throw new proxetta exception ( str + target . get name ( ) , ioex ) ; } return this ( ) ; }	Defines class as a target.
protected void process ( ) { if ( target input stream == null ) { throw new proxetta exception ( str + target class name ) ; }	Reads the target and creates destination class.
public byte [ ] create ( ) { process ( ) ; byte [ ] result = to byte array ( ) ; dump class in debug folder ( result ) ; if ( ( ! proxetta . is forced ( ) ) && ( ! is proxy applied ( ) ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + string util . to safe string ( target class name ) ) ; } return null ; } if ( log . is debug enabled ( ) ) { log . debug ( str + string util . to safe string ( target class name ) ) ; } return result ; }	Returns byte array of created class.
public object new instance ( ) { class type = define ( ) ; try { return class util . new instance ( type ) ; } catch ( exception ex ) { throw new proxetta exception ( str , ex ) ; } }	Creates new instance of created class.Assumes default no-arg constructor.
protected void dump class in debug folder ( final byte [ ] bytes ) { file debug folder = proxetta . get debug folder ( ) ; if ( debug folder == null ) { return ; } if ( ! debug folder . exists ( ) || ! debug folder . is directory ( ) ) { log . warn ( str + debug folder ) ; } string file name = proxy class name ; if ( file name == null ) { file name = str + system . current time millis ( ) ; } file name += str ; file file = new file ( debug folder , file name ) ; try { file util . write bytes ( file , bytes ) ; } catch ( io ioex ) { log . warn ( str + file , ioex ) ; } }	Writes created class content to output folder for debugging purposes.
public t from ( final string personal name , final string from ) { return from ( new email address ( personal name , from ) ) ; }	Sets the FROM address by providing personal name and address.
public t to ( final email address to ) { this . to = arrays util . append ( this . to , to ) ; return this ( ) ; }	Appends TO address.
public t to ( final string personal name , final string to ) { return to ( new email address ( personal name , to ) ) ; }	Appends TO address by personal name and email address.
public t reply to ( final email address ... reply to ) { this . reply to = arrays util . join ( this . reply to , value or empty array ( reply to ) ) ; return this ( ) ; }	Appends REPLY-TO addresses.
public t cc ( final email address ... ccs ) { this . cc = arrays util . join ( this . cc , value or empty array ( ccs ) ) ; return this ( ) ; }	Appends CC addresses.
public t text message ( final string text , final string encoding ) { return message ( new email message ( text , mime types . mime text plain , encoding ) ) ; }	Adds plain message text.
public t html message ( final string html , final string encoding ) { return message ( new email message ( html , mime types . mime text html , encoding ) ) ; }	Adds HTML message.
public t header ( final string name , final string value ) { headers . put ( name , value ) ; return this ( ) ; }	Sets header value.
public static string get ( final string name , final string default value ) { objects . require non null ( name ) ; string value = null ; try { if ( system . get security manager ( ) == null ) { value = system . get property ( name ) ; } else { value = access controller . do privileged ( ( privileged action < string > ) ( ) -> system . get property ( name ) ) ; } } catch ( exception ignore ) { } if ( value == null ) { return default value ; } return value ; }	Returns system property. If key is not available, returns the default value.
public static boolean get boolean ( final string name , final boolean default value ) { string value = get ( name ) ; if ( value == null ) { return default value ; } value = value . trim ( ) . to lower case ( ) ; switch ( value ) { case str : case str : case str : case str : return bool ; case str : case str : case str : case str : return bool ; default : return default value ; } }	Returns system property as boolean.
public static long get int ( final string name , final int default value ) { string value = get ( name ) ; if ( value == null ) { return default value ; } value = value . trim ( ) . to lower case ( ) ; try { return integer . parse int ( value ) ; } catch ( number format exception nfex ) { return default value ; } }	Returns system property as an int.
public static long get long ( final string name , final long default value ) { string value = get ( name ) ; if ( value == null ) { return default value ; } value = value . trim ( ) . to lower case ( ) ; try { return long . parse long ( value ) ; } catch ( number format exception nfex ) { return default value ; } }	Returns system property as a long.
method parameter [ ] get resolved parameters ( ) { if ( param extractor == null ) { return method parameter . empty array ; } if ( ! param extractor . debug info present ) { throw new paramo exception ( str + declaring class . get name ( ) + str + method name ) ; } return param extractor . get method parameters ( ) ; }	Returns method parameters once when method is parsed.If method has no parameters, an empty array is returned.
protected int serialize key value ( final json context json context , final path current path , final object key , final object value , int count ) { if ( ( value == null ) && json context . is exclude nulls ( ) ) { return count ; } if ( key != null ) { current path . push ( key . to string ( ) ) ; } else { current path . push ( string pool . null ) ; }	Serializes key and a value.
protected string lookup alias ( final string alias ) { string value = actions manager . lookup path alias ( alias ) ; if ( value == null ) { action runtime cfg = actions manager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . get action path ( ) ; } } return value ; }	Lookups value as an alias and, if not found, as a default alias.
protected string resolve alias ( final string value ) { final string builder result = new string builder ( value . length ( ) ) ; int i = num ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . index of ( str , i ) ; if ( ndx == - num ) {	Returns resolved alias result value or passed on, if alias doesn't exist.
public result path resolve result path ( string path , string value ) { boolean absolute path = bool ; if ( value != null ) {	Resolves result path.
public string resolve result path string ( final string path , final string value ) { final result path result path = resolve result path ( path , value ) ; final string result = result path . path value ( ) ; return resolve alias ( result ) ; }	Resolves result path as a string, when parts are not importantand when only full string matters.
public static int last index of slash dot ( final string str ) { int slash ndx = str . last index of ( str ) ; int dot ndx = string util . last index of ( str , str , str . length ( ) , slash ndx ) ; if ( dot ndx == - num ) { if ( slash ndx == - num ) { return - num ; } slash ndx ++ ; if ( slash ndx < str . length ( ) - num ) { dot ndx = slash ndx ; } else { dot ndx = - num ; } } return dot ndx ; }	Locates last dot after the last slash or just slash.
public static int last index of dot after slash ( final string str ) { int slash ndx = str . last index of ( str ) ; slash ndx ++ ; return string util . last index of ( str , str , str . length ( ) , slash ndx ) ; }	Locates last index of dot after the optional last slash.
public static int index of dot after slash ( final string str ) { int slash ndx = str . last index of ( str ) ; if ( slash ndx == - num ) { slash ndx = num ; } return str . index of ( str , slash ndx ) ; }	Locates first dot after the last slash.
public static string resolve schema name ( final class < ? > type , final string default schema name ) { string schema name = null ; final db table db table = type . get annotation ( db table . class ) ; if ( db table != null ) { schema name = db table . schema ( ) . trim ( ) ; } if ( ( schema name == null ) || ( schema name . length ( ) == num ) ) { schema name = default schema name ; } return schema name ; }	Resolves schema name from a type.
public static db entity column descriptor resolve column descriptors ( final db entity descriptor db entity descriptor , final property descriptor property , final boolean is annotated , final column naming strategy column naming strategy ) { string column name = null ; boolean is id = bool ; class < ? extends sql type > sql type class = null ;	Resolves column descriptor from property.
public void init ( final long [ ] key , final long [ ] tweak ) { final int new nw = key . length ;	Initialize the cipher using the key and the tweak value.
private void mix ( final int j , final int d ) { y [ num ] = x [ num ] + x [ num ] ; final long rotl = r [ d % depth of d in r ] [ j ] ;	Implementation of the MIX function.
private void demix ( final int j , final int d ) { y [ num ] ^= y [ num ] ; final long rotr = r [ d % depth of d in r ] [ j ] ;	Implementation of the un-MIX function.
private void key schedule ( final int s ) { for ( int i = num ; i < nw ; i ++ ) {	Creates the subkeys.
public void init ( final string key message , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ block size / byte . size ] ; byte [ ] key data = string util . get bytes ( key message ) ; system . arraycopy ( key data , num , key , num , key . length < key data . length ? key . length : key data . length ) ; init ( bytes to longs ( key ) , tweak ) ; }	Initializes cipher in a simple way.
@ override public byte [ ] encrypt block ( final byte [ ] content , final int offset ) { long [ ] content block = bytes to longs ( content , offset , block size in bytes ) ; long [ ] encrypted block = new long [ block size / long . size ] ; block encrypt ( content block , encrypted block ) ; return longs to bytes ( encrypted block ) ; }	Encrypts a block.
protected static long [ ] bytes to longs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size > > num ] ; int i8 = offset ; for ( int i = num ; i < result . length ; i ++ ) { result [ i ] = bits . get long ( ba , i8 ) ; i8 += num ; } return result ; }	Converts segment of byte array into long array.
private static string remove any bounding ( final char s , final char e , final string str ) { if ( str == null || str . length ( ) < num ) { return str ; } if ( str . starts with ( string . value of ( s ) ) && str . ends with ( string . value of ( e ) ) ) { return str . substring ( num , str . length ( ) - num ) ; } return str ; }	If the string starts and ends with start and end char, remove them,otherwise return the string as it was passed in.
public string path ( ) { if ( methref != null ) { final string method name = methref . ref ( ) ; return target . get name ( ) + str + method name ; } return path ; }	Returns path value.
public static file zlib ( final file file ) throws io { if ( file . is directory ( ) ) { throw new io ( str ) ; } file input stream fis = new file input stream ( file ) ; deflater deflater = new deflater ( deflater . best compression ) ; string zlib file name = file . get absolute path ( ) + zlib ext ; deflater output stream dos = new deflater output stream ( new file output stream ( zlib file name ) , deflater ) ; try { stream util . copy ( fis , dos ) ; } finally { stream util . close ( dos ) ; stream util . close ( fis ) ; } return new file ( zlib file name ) ; }	Compresses a file into zlib archive.
public static file gzip ( final file file ) throws io { if ( file . is directory ( ) ) { throw new io ( str ) ; } file input stream fis = new file input stream ( file ) ; string gzip name = file . get absolute path ( ) + gzip ext ; gzip gzos = new gzip ( new file output stream ( gzip name ) ) ; try { stream util . copy ( fis , gzos ) ; } finally { stream util . close ( gzos ) ; stream util . close ( fis ) ; } return new file ( gzip name ) ; }	Compresses a file into gzip archive.
public static file ungzip ( final file file ) throws io { string out file name = file name util . remove extension ( file . get absolute path ( ) ) ; file out = new file ( out file name ) ; out . create new file ( ) ; file output stream fos = new file output stream ( out ) ; gzip gzis = new gzip ( new file input stream ( file ) ) ; try { stream util . copy ( gzis , fos ) ; } finally { stream util . close ( fos ) ; stream util . close ( gzis ) ; } return out ; }	Decompress gzip archive.
public static list < string > list zip ( final file zip file ) throws io { list < string > entries = new array list < > ( ) ; zip file zip = new zip file ( zip file ) ; enumeration zip entries = zip . entries ( ) ; while ( zip entries . has more elements ( ) ) { zip entry entry = ( zip entry ) zip entries . next element ( ) ; string entry name = entry . get name ( ) ; entries . add ( entry name ) ; } return collections . unmodifiable list ( entries ) ; }	Lists zip content.
public static void unzip ( final string zip file , final string dest dir , final string ... patterns ) throws io { unzip ( new file ( zip file ) , new file ( dest dir ) , patterns ) ; }	Extracts zip file content to the target directory.
public static void add to zip ( final zip output stream zos , final file file , string path , final string comment , final boolean recursive ) throws io { if ( ! file . exists ( ) ) { throw new file not found exception ( file . to string ( ) ) ; } if ( path == null ) { path = file . get name ( ) ; } while ( path . length ( ) != num && path . char at ( num ) == str ) { path = path . substring ( num ) ; } boolean is dir = file . is directory ( ) ; if ( is dir ) {	Adds single entry to ZIP output stream.
public static void add to zip ( final zip output stream zos , final byte [ ] content , string path , final string comment ) throws io { while ( path . length ( ) != num && path . char at ( num ) == str ) { path = path . substring ( num ) ; } if ( string util . ends with char ( path , str ) ) { path = path . substring ( num , path . length ( ) - num ) ; } zip entry zip entry = new zip entry ( path ) ; zip entry . set time ( system . current time millis ( ) ) ; if ( comment != null ) { zip entry . set comment ( comment ) ; } zos . put next entry ( zip entry ) ; input stream is = new byte array input stream ( content ) ; try { stream util . copy ( is , zos ) ; } finally { stream util . close ( is ) ; } zos . close entry ( ) ; }	Adds byte content into the zip as a file.
public field descriptor get field descriptor ( final string name , final boolean declared ) { final field descriptor field descriptor = get fields ( ) . get field descriptor ( name ) ; if ( field descriptor != null ) { if ( ! field descriptor . match declared ( declared ) ) { return null ; } } return field descriptor ; }	Returns field descriptor.
public property descriptor get property descriptor ( final string name , final boolean declared ) { property descriptor property descriptor = get properties ( ) . get property descriptor ( name ) ; if ( ( property descriptor != null ) && property descriptor . match declared ( declared ) ) { return property descriptor ; } return null ; }	Returns property descriptor. Declared flag is matched on both read and writemethods.
public static void set request bundle name ( final servlet request request , final string bundle name ) { if ( log . is debug enabled ( ) ) { log . debug ( str + bundle name ) ; } request . set attribute ( request bundle name attr , bundle name ) ; }	Sets bundle name for provided servlet request.
public static void set session locale ( final http session session , final string locale code ) { if ( log . is debug enabled ( ) ) { log . debug ( str + locale code ) ; } locale locale = locale . for language tag ( locale code ) ; session . set attribute ( session locale attr , locale ) ; }	Saves Locale to HTTP session.
public static locale get session locale ( final http session session ) { locale locale = ( locale ) session . get attribute ( session locale attr ) ; return locale == null ? message resolver . get fallback locale ( ) : locale ; }	Returns current locale from session.s.
public string [ ] filter parameters for bean name ( string bean name , final boolean resolve reference params ) { bean name = bean name + str ; list < string > list = new array list < > ( ) ; for ( map . entry < string , object > entry : params . entry set ( ) ) { string key = entry . get key ( ) ; if ( ! key . starts with ( bean name ) ) { continue ; } list . add ( key ) ; if ( ! resolve reference params ) { continue ; }	Returns an array of param keys that belongs to provided bean.Optionally resolves the value of returned parameters.
public props entries profile ( final string ... profiles ) { if ( profiles == null ) { return this ; } for ( string profile : profiles ) { add profiles ( profile ) ; } return this ; }	Enables profiles to iterate.
public static long get long little endian ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + num ] << num )	Gets a long from a byte buffer in little endian byte order.
private static byte [ ] read stream ( final input stream input stream , final boolean close ) throws io { if ( input stream == null ) { throw new io ( str ) ; } try { byte array output stream output stream = new byte array output stream ( ) ; byte [ ] data = new byte [ input stream data chunk size ] ; int bytes read ; while ( ( bytes read = input stream . read ( data , num , data . length ) ) != - num ) { output stream . write ( data , num , bytes read ) ; } output stream . flush ( ) ; return output stream . to byte array ( ) ; } finally { if ( close ) { input stream . close ( ) ; } } }	Reads the given input stream and returns its content as a byte array.
protected label read label ( final int bytecode offset , final label [ ] labels ) { if ( labels [ bytecode offset ] == null ) { labels [ bytecode offset ] = new label ( ) ; } return labels [ bytecode offset ] ; }	Returns the label corresponding to the given bytecode offset.
private int get type annotation bytecode offset ( final int [ ] type annotation offsets , final int type annotation index ) { if ( type annotation offsets == null || type annotation index >= type annotation offsets . length || read byte ( type annotation offsets [ type annotation index ] ) < type reference . instanceof ) { return - num ; } return read unsigned short ( type annotation offsets [ type annotation index ] + num ) ; }	Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or-1 if there is no such type_annotation of if it does not have a bytecode offset.
private int [ ] read bootstrap methods attribute ( final int max string length ) { char [ ] char buffer = new char [ max string length ] ; int current attribute offset = get first attribute offset ( ) ; int [ ] current bootstrap method offsets = null ; for ( int i = read unsigned short ( current attribute offset - num ) ; i > num ; -- i ) {	Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
protected ctor descriptor [ ] inspect constructors ( ) { class type = class descriptor . get type ( ) ; constructor [ ] ctors = type . get declared constructors ( ) ; ctor descriptor [ ] all ctors = new ctor descriptor [ ctors . length ] ; for ( int i = num ; i < ctors . length ; i ++ ) { constructor ctor = ctors [ i ] ; ctor descriptor ctor descriptor = create ctor descriptor ( ctor ) ; all ctors [ i ] = ctor descriptor ; if ( ctor descriptor . is default ( ) ) { default ctor = ctor descriptor ; } } return all ctors ; }	Inspects all declared constructors of a target type.
public ctor descriptor get ctor descriptor ( final class ... args ) { ctors : for ( ctor descriptor ctor descriptor : all ctors ) { class [ ] arg = ctor descriptor . get parameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = num ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return ctor descriptor ; } return null ; }	Finds constructor description that matches given argument types.
@ suppress warnings ( str ) protected map < string , transient bean data > get request map ( final http servlet request servlet request ) { return ( map < string , transient bean data > ) servlet request . get attribute ( attr name ) ; }	Returns instance map from http request.
protected map < string , transient bean data > create request map ( final http servlet request servlet request ) { map < string , transient bean data > map = new hash map < > ( ) ; servlet request . set attribute ( attr name , map ) ; return map ; }	Creates instance map and stores it in the request.
protected long [ ] convert array to array ( final object value ) { final class value component type = value . get class ( ) . get component type ( ) ; final long [ ] result ; if ( value component type . is primitive ( ) ) { result = convert primitive array to array ( value , value component type ) ; } else {	Converts array value to array.
@ override public void init ( final filter config filter config ) throws servlet exception {	Initializes Decora filter. Loads manager and parser from init parameters.
public find file search path ( final uri search path ) { file file ; try { file = new file ( search path ) ; } catch ( exception ex ) { throw new find file exception ( str + search path , ex ) ; } add path ( file ) ; return this ; }	Specifies the search path.
public find file search path ( final url search path ) { file file = file util . to container file ( search path ) ; if ( file == null ) { throw new find file exception ( str + search path ) ; } add path ( file ) ; return this ; }	Specifies the search path.
public find file include ( final string ... patterns ) { for ( string pattern : patterns ) { rules . include ( pattern ) ; } return this ; }	Defines include patterns.
public find file exclude ( final string ... patterns ) { for ( string pattern : patterns ) { rules . exclude ( pattern ) ; } return this ; }	Defines exclude patterns.
protected void add path ( final file path ) { if ( ! path . exists ( ) ) { return ; } if ( path list == null ) { path list = new linked list < > ( ) ; } path list . add ( path ) ; }	Adds existing search path to the file list.Non existing files are ignored.If path is a folder, it will be scanned for all files.
public list < file > find all ( ) { list < file > all files = new array list < > ( ) ; file file ; while ( ( file = next file ( ) ) != null ) { all files . add ( file ) ; } return all files ; }	Finds all files and returns list of founded files.
protected void init ( ) { rules . detect mode ( ) ; todo files = new linked list < > ( ) ; todo folders = new linked list < > ( ) ; if ( path list == null ) { path list = new linked list < > ( ) ; return ; } if ( path list original == null ) { path list original = ( linked list < file > ) path list . clone ( ) ; } string [ ] files = new string [ path list . size ( ) ] ; int index = num ; iterator < file > iterator = path list . iterator ( ) ; while ( iterator . has next ( ) ) { file file = iterator . next ( ) ; if ( file . is file ( ) ) { files [ index ++ ] = file . get absolute path ( ) ; iterator . remove ( ) ; } } if ( index != num ) { files iterator files iterator = new files iterator ( files ) ; todo files . add ( files iterator ) ; } }	Initializes file walking.Separates input files and folders.
@ override public iterator < file > iterator ( ) { return new iterator < file > ( ) { private file next file ; @ override public boolean has next ( ) { next file = next file ( ) ; return next file != null ; } @ override public file next ( ) { if ( next file == null ) { throw new no such element exception ( ) ; } return next file ; } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }	Returns file walking iterator.
public wiring mode resolve bean wiring mode ( final class type ) { petite bean petite bean = ( ( class < ? > ) type ) . get annotation ( petite bean . class ) ; return petite bean != null ? petite bean . wiring ( ) : wiring mode . default ; }	Resolves bean's auto-wire flag from the annotation.
public string resolve bean name ( final class type , final boolean use long type name ) { petite bean petite bean = ( ( class < ? > ) type ) . get annotation ( petite bean . class ) ; string name = null ; if ( petite bean != null ) { name = petite bean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == num ) ) { if ( use long type name ) { name = type . get name ( ) ; } else { name = string util . uncapitalize ( type . get simple name ( ) ) ; } } return name ; }	Resolves bean's name from bean annotation or type name.
public print writer get writer ( ) { if ( out writer == null ) { if ( out stream != null ) { throw new illegal state exception ( str ) ; } buffered writer = new fast char array writer ( ) ; out writer = new print writer ( buffered writer ) { @ override public void close ( ) {	Returns a writer.
public servlet output stream get output stream ( ) { if ( out stream == null ) { if ( out writer != null ) { throw new illegal state exception ( str ) ; } buffer output stream = new fast byte array servlet output stream ( ) ; out stream = buffer output stream ; } return out stream ; }	Returns a servlet output stream.
public string get class name ( ) { switch ( sort ) { case void : return str ; case boolean : return str ; case char : return str ; case byte : return str ; case short : return str ; case int : return str ; case float : return str ; case long : return str ; case double : return str ; case array : string builder string builder = new string builder ( get element type ( ) . get class name ( ) ) ; for ( int i = get dimensions ( ) ; i > num ; -- i ) { string builder . append ( str ) ; } return string builder . to string ( ) ; case object : case internal : return value buffer . substring ( value begin , value end ) . replace ( str , str ) ; default : throw new assertion error ( ) ; } }	Returns the binary name of the class corresponding to this type.
public static string get constructor descriptor ( final constructor < ? > constructor ) { string builder string builder = new string builder ( ) ; string builder . append ( str ) ; class < ? > [ ] parameters = constructor . get parameter types ( ) ; for ( class < ? > parameter : parameters ) { append descriptor ( parameter , string builder ) ; } return string builder . append ( str ) . to string ( ) ; }	Returns the descriptor corresponding to the given constructor.
public static string get method descriptor ( final type return type , final type ... argument types ) { string builder string builder = new string builder ( ) ; string builder . append ( str ) ; for ( type argument type : argument types ) { argument type . append descriptor ( string builder ) ; } string builder . append ( str ) ; return type . append descriptor ( string builder ) ; return string builder . to string ( ) ; }	Returns the descriptor corresponding to the given argument and return types.
public static string get method descriptor ( final method method ) { string builder string builder = new string builder ( ) ; string builder . append ( str ) ; class < ? > [ ] parameters = method . get parameter types ( ) ; for ( class < ? > parameter : parameters ) { append descriptor ( parameter , string builder ) ; } string builder . append ( str ) ; append descriptor ( method . get return type ( ) , string builder ) ; return string builder . to string ( ) ; }	Returns the descriptor corresponding to the given method.
private void append descriptor ( final string builder string builder ) { if ( sort == object ) { string builder . append ( value buffer , value begin - num , value end + num ) ; } else if ( sort == internal ) { string builder . append ( str ) . append ( value buffer , value begin , value end ) . append ( str ) ; } else { string builder . append ( value buffer , value begin , value end ) ; } }	Appends the descriptor corresponding to this type to the given string buffer.
public int get size ( ) { switch ( sort ) { case void : return num ; case boolean : case char : case byte : case short : case int : case float : case array : case object : case internal : return num ; case long : case double : return num ; default : throw new assertion error ( ) ; } }	Returns the size of values of this type.
public static int get arguments and return sizes ( final string method descriptor ) { int arguments size = num ;	Computes the size of the arguments and of the return value of a method.
public void set rollback only ( final throwable th ) { if ( ! is no transaction ( ) ) { if ( ( status != status marked rollback ) && ( status != status active ) ) { throw new jtx exception ( str ) ; } } rollback cause = th ; status = status marked rollback ; }	Modify the transaction associated with the target object such that the only possible outcomeof the transaction is to roll back the transaction.
protected void commit or rollback ( boolean do commit ) { if ( log . is debug enabled ( ) ) { if ( do commit ) { log . debug ( str ) ; } else { log . debug ( str ) ; } } boolean forced rollback = bool ; if ( ! is no transaction ( ) ) { if ( is rollback only ( ) ) { if ( do commit ) { do commit = bool ; forced rollback = bool ; } } else if ( ! is active ( ) ) { if ( is completed ( ) ) { throw new jtx exception ( str ) ; } throw new jtx exception ( str + ( do commit ? str : str ) ) ; } } if ( do commit ) { commit all resources ( ) ; } else { rollback all resources ( forced rollback ) ; } }	Performs either commit or rollback on all transaction resources.
protected void rollback all resources ( final boolean was forced ) { status = status rolling back ; exception last exception = null ; iterator < jtx resource > it = resources . iterator ( ) ; while ( it . has next ( ) ) { jtx resource resource = it . next ( ) ; try { resource . rollback transaction ( ) ; } catch ( exception ex ) { last exception = ex ; } finally { it . remove ( ) ; } } tx manager . remove transaction ( this ) ; status = status rolledback ; if ( last exception != null ) { status = status unknown ; throw new jtx exception ( str , last exception ) ; } if ( was forced ) { throw new jtx exception ( str , rollback cause ) ; } }	Rollbacks all attached resources.
public < e > e request resource ( final class < e > resource type ) { if ( is completed ( ) ) { throw new jtx exception ( str ) ; } if ( is rollback only ( ) ) { throw new jtx exception ( str , rollback cause ) ; } if ( ! is no transaction ( ) && ! is active ( ) ) { throw new jtx exception ( str ) ; } check timeout ( ) ; e resource = lookup resource ( resource type ) ; if ( resource == null ) { int max resources = tx manager . get max resources per transaction ( ) ; if ( ( max resources != - num ) && ( resources . size ( ) >= max resources ) ) { throw new jtx exception ( str ) ; } jtx resource manager < e > resource manager = tx manager . lookup resource manager ( resource type ) ; resource = resource manager . begin transaction ( mode , is active ( ) ) ; resources . add ( new jtx resource < > ( this , resource manager , resource ) ) ; } return resource ; }	Requests a resource. If resource is not found, it will be created and new transaction will be started on it.
protected void pop name ( ) { if ( is pushed ) { if ( pushed comma ) { write comma ( ) ; } string name = pushed name ; pushed name = null ; is pushed = bool ; write name ( name ) ; } }	Writes stored name to JSON string.
public void write string ( final string value ) { pop name ( ) ; write ( string pool . quote ) ; int len = value . length ( ) ; for ( int i = num ; i < len ; i ++ ) { char c = value . char at ( i ) ; switch ( c ) { case str : write ( str ) ; break ; case str : write ( str ) ; break ; case str : if ( strict string encoding ) { write ( str ) ; } else { write ( c ) ; } break ; case str : write ( str ) ; break ; case str : write ( str ) ; break ; case str : write ( str ) ; break ; case str : write ( str ) ; break ; case str : write ( str ) ; break ; default : if ( character . is iso ( c ) ) { unicode ( c ) ; } else { write ( c ) ; } } } write ( string pool . quote ) ; }	Write a quoted and escaped value to the output.
protected void unicode ( final char c ) { write ( str ) ; int n = c ; for ( int i = num ; i < num ; ++ i ) { int digit = ( n & num ) > > num ; char hex = char util . int2hex ( digit ) ; write ( hex ) ; n <<= num ; } }	Writes unicode representation of a character.
public void write ( final char sequence char sequence ) { pop name ( ) ; try { out . append ( char sequence ) ; } catch ( io ioex ) { throw new json exception ( ioex ) ; } }	Appends char sequence to the buffer.
public lagarto dom builder config set parsing error log level name ( string log level ) { log level = log level . trim ( ) . to upper case ( ) ; parsing error log level = logger . level . value of ( log level ) ; return this ; }	Sets parsing error log level as a name.
public void start region ( final int start , final int tag len , final int deep level ) { this . region start = start + tag len ; this . region length = num ; this . region tag start = start ; this . deep level = deep level ; }	Starts defining region by setting the start index and reset region length to zero.
public boolean is containing ( final string include ) { if ( value == null ) { return bool ; } if ( splits == null ) { splits = string util . splitc ( value , str ) ; } for ( string s : splits ) { if ( s . equals ( include ) ) { return bool ; } } return bool ; }	Returns true if attribute is containing some value.
public static void register pseudo function ( final class < ? extends pseudo function > pseudo function type ) { pseudo function pseudo function ; try { pseudo function = class util . new instance ( pseudo function type ) ; } catch ( exception ex ) { throw new cs ( ex ) ; } pseudo function map . put ( pseudo function . get pseudo function name ( ) , pseudo function ) ; }	Registers pseudo function.
public static pseudo function < ? > lookup pseudo function ( final string pseudo function name ) { pseudo function pseudo function = pseudo function map . get ( pseudo function name ) ; if ( pseudo function == null ) { throw new cs ( str + pseudo function name ) ; } return pseudo function ; }	Lookups pseudo function for given pseudo function name.
@ override public void visit ( final int version , int access , final string name , final string signature , final string super name , final string [ ] interfaces ) { wd . init ( name , super name , this . suffix , this . req proxy class name ) ;	Creates destination subclass header from current target class.
@ override public annotation visitor visit annotation ( final string desc , final boolean visible ) { annotation visitor dest ann = wd . dest . visit annotation ( desc , visible ) ;	Copies all destination type annotations to the target.
protected void make static init block ( ) { if ( wd . advice clinits != null ) { method visitor mv = wd . dest . visit method ( asm util . acc static , clinit , desc void , null , null ) ; mv . visit code ( ) ; for ( string name : wd . advice clinits ) { mv . visit method insn ( invokestatic , wd . this reference , name , desc void , bool ) ; } mv . visit insn ( return ) ; mv . visit maxs ( num , num ) ; mv . visit end ( ) ; } }	Creates static initialization block that simply calls alladvice static init methods in correct order.
protected void make proxy constructor ( ) { method visitor mv = wd . dest . visit method ( asm util . acc private | asm util . acc final , proxetta names . init method name , desc void , null , null ) ; mv . visit code ( ) ; if ( wd . advice inits != null ) { for ( string name : wd . advice inits ) { mv . visit var insn ( aload , num ) ; mv . visit method insn ( invokespecial , wd . this reference , name , desc void , bool ) ; } } mv . visit insn ( return ) ; mv . visit maxs ( num , num ) ; mv . visit end ( ) ; }	Creates init method that simply calls all advice constructor methods in correct order.This created init method is called from each destination's constructor.
protected void process super methods ( ) { for ( class reader cr : target class info . super class readers ) { cr . accept ( new empty class visitor ( ) { string declared class name ; @ override public void visit ( final int version , final int access , final string name , final string signature , final string super name , final string [ ] interfaces ) { declared class name = name ; } @ override public method visitor visit method ( final int access , final string name , final string desc , final string signature , final string [ ] exceptions ) { if ( name . equals ( init ) || name . equals ( clinit ) ) { return null ; } method signature visitor msign = target class info . lookup method signature visitor ( access , name , desc , declared class name ) ; if ( msign == null ) { return null ; } return apply proxy ( msign ) ; } } , num ) ; } }	Checks for all public super methods that are not overridden.
public int find last ( int low , int high ) { int ndx = - num ; while ( low <= high ) { int mid = ( low + high ) > > > num ; int delta = compare ( mid ) ; if ( delta > num ) { high = mid - num ; } else { if ( delta == num ) { ndx = mid ; } low = mid + num ; } } if ( ndx == - num ) { return - ( low + num ) ; } return ndx ; }	Finds very last index of given element in inclusive index range.
public string on ( final string string ) { if ( ! enabled ) { return string ; } final string builder sb = new string builder ( ) ; if ( prefix != null ) { sb . append ( prefix ) . append ( str ) ; } sb . append ( string ) ; if ( suffix != null ) { sb . append ( suffix ) . append ( str ) ; } return sb . to string ( ) ; }	Returns chalked string.
private byte [ ] replace asm instructions ( final byte [ ] class file , final boolean has frames ) { final attribute [ ] attributes = get attribute prototypes ( ) ; first field = null ; last field = null ; first method = null ; last method = null ; last runtime visible annotation = null ; last runtime invisible annotation = null ; last runtime visible type annotation = null ; last runtime invisible type annotation = null ; module writer = null ; nest host class index = num ; number of nest member classes = num ; nest member classes = null ; first attribute = null ; compute = has frames ? method writer . compute inserted frames : method writer . compute nothing ; new class reader ( class file , num , bool ) . accept ( this , attributes , ( has frames ? class reader . expand frames : num ) | class reader . expand asm insns ) ; return to byte array ( ) ; }	Returns the equivalent of the given class file, with the ASM specific instructions replacedwith standard ones.
private attribute [ ] get attribute prototypes ( ) { attribute . set attribute prototypes = new attribute . set ( ) ; attribute prototypes . add attributes ( first attribute ) ; field writer field writer = first field ; while ( field writer != null ) { field writer . collect attribute prototypes ( attribute prototypes ) ; field writer = ( field writer ) field writer . fv ; } method writer method writer = first method ; while ( method writer != null ) { method writer . collect attribute prototypes ( attribute prototypes ) ; method writer = ( method writer ) method writer . mv ; } return attribute prototypes . to array ( ) ; }	Returns the prototypes of the attributes used by this class, its fields and its methods.
public void register ( final class type , final class < ? extends sql type > sql type class ) { types . put ( type , lookup sql type ( sql type class ) ) ; }	Registers sql type for provided type.
public sql type lookup ( final class clazz ) { sql type sql type ; for ( class x = clazz ; x != null ; x = x . get superclass ( ) ) { sql type = types . get ( clazz ) ; if ( sql type != null ) { return sql type ; } class [ ] interfaces = x . get interfaces ( ) ; for ( class i : interfaces ) { sql type = types . get ( i ) ; if ( sql type != null ) { return sql type ; } } } return null ; }	Retrieves SQL type for provided type.
public sql type lookup sql type ( final class < ? extends sql type > sql type class ) { sql type sql type = sql types . get ( sql type class ) ; if ( sql type == null ) { try { sql type = class util . new instance ( sql type class ) ; } catch ( exception ex ) { throw new db sql exception ( str + sql type class . get simple name ( ) , ex ) ; } sql types . put ( sql type class , sql type ) ; } return sql type ; }	Returns sql type instance.
public static proxy info socks4 proxy ( final string proxy address , final int proxy port , final string proxy user ) { return new proxy info ( proxy type . sock , proxy address , proxy port , proxy user , null ) ; }	Creates SOCKS4 proxy.
public static proxy info socks5 proxy ( final string proxy address , final int proxy port , final string proxy user , final string proxy password ) { return new proxy info ( proxy type . sock , proxy address , proxy port , proxy user , proxy password ) ; }	Creates SOCKS5 proxy.
public static proxy info http proxy ( final string proxy address , final int proxy port , final string proxy user , final string proxy password ) { return new proxy info ( proxy type . http , proxy address , proxy port , proxy user , proxy password ) ; }	Creates HTTP proxy.
public int total thread transactions ( ) { array list < jtx transaction > tx list = tx stack . get ( ) ; if ( tx list == null ) { return num ; } return tx list . size ( ) ; }	Returns total number of transactions associated with current thread.
public int total thread transactions with status ( final jtx status status ) { array list < jtx transaction > txlist = tx stack . get ( ) ; if ( txlist == null ) { return num ; } int count = num ; for ( jtx transaction tx : txlist ) { if ( tx . get status ( ) == status ) { count ++ ; } } return count ; }	Returns total number of transactions of the specified status associated with current thread.
protected void associate transaction ( final jtx transaction tx ) { total transactions ++ ; array list < jtx transaction > tx list = tx stack . get ( ) ; if ( tx list == null ) { tx list = new array list < > ( ) ; tx stack . set ( tx list ) ; } tx list . add ( tx ) ;	Associate transaction to current thread.
protected void continue tx ( final jtx transaction source tx , final jtx transaction mode dest mode ) { if ( ! validate existing transaction ) { return ; } jtx transaction mode source mode = source tx . get transaction mode ( ) ; jtx isolation level dest isolation level = dest mode . get isolation level ( ) ; if ( dest isolation level != isolation default ) { jtx isolation level current isolation level = source mode . get isolation level ( ) ; if ( current isolation level != dest isolation level ) { throw new jtx exception ( str + dest isolation level + str + current isolation level ) ; } } if ( ( ! dest mode . is read only ( ) ) && ( source mode . is read only ( ) ) ) { throw new jtx exception ( str ) ; } }	Check if propagation of a transaction is possible, due to source and destination transaction modes.
protected < e > jtx resource manager < e > lookup resource manager ( final class < e > resource type ) {	Lookups resource manager for provided type.
protected c create proxy object ( class < c > target ) { target = proxetta util . resolve target class ( target ) ; class proxy class = cache . get ( target ) ; if ( proxy class == null ) { proxy class = proxetta . define proxy ( target ) ; cache . put ( target , proxy class ) ; } c proxy ; try { proxy = ( c ) class util . new instance ( proxy class ) ; } catch ( exception ex ) { throw new pathref exception ( ex ) ; } return proxy ; }	Creates proxy object.
protected void append ( final string method name ) { if ( path . length ( ) != num ) { path += string pool . dot ; } if ( method name . starts with ( string pool . left sq bracket ) ) { path = string util . substring ( path , num , - num ) ; } path += method name ; }	Appends method name to existing path.
public static string align left and pad ( final string text , final int size ) { int text length = text . length ( ) ; if ( text length > size ) { return text . substring ( num , size ) ; } final string builder sb = new string builder ( size ) ; sb . append ( text ) ; while ( text length ++ < size ) { sb . append ( str ) ; } return sb . to string ( ) ; }	Puts the text to the left and pads with spaces until the size is reached.
public static string to camel case ( final string input , final boolean first char uppercase , final char separator ) { final int length = input . length ( ) ; final string builder sb = new string builder ( length ) ; boolean upper case = first char uppercase ; for ( int i = num ; i < length ; i ++ ) { final char ch = input . char at ( i ) ; if ( ch == separator ) { upper case = bool ; } else if ( upper case ) { sb . append ( character . to upper case ( ch ) ) ; upper case = bool ; } else { sb . append ( ch ) ; } } return sb . to string ( ) ; }	Converts separated string value to CamelCase.
public static string format paragraph ( final string src , final int len , final boolean break on whitespace ) { string builder str = new string builder ( ) ; int total = src . length ( ) ; int from = num ; while ( from < total ) { int to = from + len ; if ( to >= total ) { to = total ; } else if ( break on whitespace ) { int ndx = string util . last index of whitespace ( src , to - num , from ) ; if ( ndx != - num ) { to = ndx + num ; } } int cut from = string util . index of non whitespace ( src , from , to ) ; if ( cut from != - num ) { int cut to = string util . last index of non whitespace ( src , to - num , from ) + num ; str . append ( src , cut from , cut to ) ; } str . append ( str ) ; from = to ; } return str . to string ( ) ; }	Formats provided string as paragraph.
public static string convert tabs to spaces ( final string line , final int tab width ) { int tab index , tab size ; int last tab index = num ; int added chars = num ; if ( tab width == num ) { return string util . remove ( line , str ) ; } string builder result = new string builder ( ) ; while ( ( tab index = line . index of ( str , last tab index ) ) != - num ) { tab size = tab width - ( ( tab index + added chars ) % tab width ) ; if ( tab size == num ) { tab size = tab width ; } added chars += tab size - num ; result . append ( line , last tab index , tab index ) ; result . append ( string util . repeat ( str , tab size ) ) ; last tab index = tab index + num ; } if ( last tab index == num ) { return line ; } result . append ( line . substring ( last tab index ) ) ; return result . to string ( ) ; }	Converts all tabs on a line to spaces according to the provided tab width.This is not a simple tab to spaces replacement, since the resultingindentation remains the same.
public static string escape java ( final string string ) { int str len = string . length ( ) ; string builder sb = new string builder ( str len ) ; for ( int i = num ; i < str len ; i ++ ) { char c = string . char at ( i ) ; switch ( c ) { case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; default : if ( ( c < num ) || ( c > num ) ) { string hex = integer . to hex string ( c ) ; sb . append ( str ) ; for ( int k = hex . length ( ) ; k < num ; k ++ ) { sb . append ( str ) ; } sb . append ( hex ) ; } else { sb . append ( c ) ; } } } return sb . to string ( ) ; }	Escapes a string using java rules.
public static string unescape java ( final string str ) { char [ ] chars = str . to char array ( ) ; string builder sb = new string builder ( str . length ( ) ) ; for ( int i = num ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( c != str ) { sb . append ( c ) ; continue ; } i ++ ; c = chars [ i ] ; switch ( c ) { case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : char hex = ( char ) integer . parse int ( new string ( chars , i + num , num ) , num ) ; sb . append ( hex ) ; i += num ; break ; default : throw new illegal argument exception ( str + c ) ; } } return sb . to string ( ) ; }	Unescapes a string using java rules.
@ suppress warnings ( { str } ) public < t > t get bean ( final class < t > type ) { string name = resolve bean name ( type ) ; return ( t ) get bean ( name ) ; }	Returns Petite bean instance.
public < t > t get bean ( final string name ) {	Returns Petite bean instance.Petite container will find the bean in corresponding scope and all its dependencies,either by constructor or property injection.
protected void init bean definition ( final bean definition def ) {	Resolves and initializes bean definition.
protected object invoke provider ( final provider definition provider ) { if ( provider . method != null ) { final object bean ; if ( provider . bean name != null ) {	Invokes provider to get a bean.
public void add bean ( final string name , final object bean , wiring mode wiring mode ) { wiring mode = petite config . resolve wiring mode ( wiring mode ) ; register petite bean ( bean . get class ( ) , name , singleton scope . class , wiring mode , bool , null ) ; bean definition def = lookup existing bean definition ( name ) ; register bean and wire and inject params and invoke init methods ( new bean data ( this , def , bean ) ) ; }	Adds object instance to the container as singleton bean.
public void set bean property ( final string name , final object value ) { object bean = null ; int ndx = name . length ( ) ; while ( bool ) { ndx = name . last index of ( str , ndx ) ; if ( ndx == - num ) { break ; } string bean name = name . substring ( num , ndx ) ; bean = get bean ( bean name ) ; if ( bean != null ) { break ; } ndx -- ; } if ( bean == null ) { throw new petite exception ( str + name ) ; } try { bean util . declared . set property ( bean , name . substring ( ndx + num ) , value ) ; } catch ( exception ex ) { throw new petite exception ( str + name , ex ) ; } }	Sets petite bean property.
public object get bean property ( final string name ) { int ndx = name . index of ( str ) ; if ( ndx == - num ) { throw new petite exception ( str + name ) ; } string bean name = name . substring ( num , ndx ) ; object bean = get bean ( bean name ) ; if ( bean == null ) { throw new petite exception ( str + name ) ; } try { return bean util . declared . get property ( bean , name . substring ( ndx + num ) ) ; } catch ( exception ex ) { throw new petite exception ( str + name , ex ) ; } }	Returns petite bean property value.
public void shutdown ( ) { scopes . for each value ( scope :: shutdown ) ; externals cache . clear ( ) ; beans . clear ( ) ; beans alt . clear ( ) ; scopes . clear ( ) ; providers . clear ( ) ; bean collections . clear ( ) ; }	Shutdowns container. After container is down, it can't be used anymore.
public static method parameter [ ] resolve parameters ( final accessible object method or ctor ) { class [ ] param types ; class declaring class ; string name ; if ( method or ctor instanceof method ) { method method = ( method ) method or ctor ; param types = method . get parameter types ( ) ; name = method . get name ( ) ; declaring class = method . get declaring class ( ) ; } else { constructor constructor = ( constructor ) method or ctor ; param types = constructor . get parameter types ( ) ; declaring class = constructor . get declaring class ( ) ; name = ctor method ; } if ( param types . length == num ) { return method parameter . empty array ; } input stream stream ; try { stream = class loader util . get class as stream ( declaring class ) ; } catch ( io ioex ) { throw new paramo exception ( str + declaring class . get name ( ) , ioex ) ; } if ( stream == null ) { throw new paramo exception ( str + declaring class ) ; } try { class reader reader = new class reader ( stream ) ; method finder visitor = new method finder ( declaring class , name , param types ) ; reader . accept ( visitor , num ) ; return visitor . get resolved parameters ( ) ; } catch ( io ioex ) { throw new paramo exception ( ioex ) ; } finally { stream util . close ( stream ) ; } }	Resolves method parameters from a method or constructor.Returns an empty array when target does not contain any parameter.No caching is involved in this process, i.e.
@ override public int do after body ( ) throws jsp exception { body content body = get body content ( ) ; jsp writer out = body . get enclosing writer ( ) ; string bodytext = populate form ( body . get string ( ) , name -> value ( name , page context ) ) ; try { out . print ( bodytext ) ; } catch ( io ioex ) { throw new jsp exception ( ioex ) ; } return skip body ; }	Performs smart form population.
public string get value ( final string ... profiles ) { if ( has macro ) { return props data . resolve macros ( value , profiles ) ; } return value ; }	Returns the property value, with replaced macros.
@ override public void end ( ) { if ( parent node != root node ) { node this node = parent node ; while ( this node != root node ) { if ( dom builder . config . is implied end tags ( ) ) { if ( impl rules . implicitly close tag on eof ( this node . get node name ( ) ) ) { this node = this node . get parent node ( ) ; continue ; } } error ( str + this node . get node name ( ) + str ) ; this node = this node . get parent node ( ) ; } }	Finishes the tree building.
protected element create element node ( final tag tag ) { boolean has void tags = html void rules != null ; boolean is void = bool ; boolean self closed = bool ; if ( has void tags ) { is void = html void rules . is void tag ( tag . get name ( ) ) ;	Creates new element with correct configuration.
protected void remove last child node if empty text ( final node parent node , final boolean closed tag ) { if ( parent node == null ) { return ; } node last child = parent node . get last child ( ) ; if ( last child == null ) { return ; } if ( last child . get node type ( ) != node . node type . text ) { return ; } if ( closed tag ) { if ( parent node . get child nodes count ( ) == num ) { return ; } } text text = ( text ) last child ; if ( text . is blank ( ) ) { last child . detach from parent ( ) ; } }	Removes last child node if contains just empty text.
public string get query string ( ) { if ( sql template == null ) { return to string ( ) ; } if ( parameter values == null ) { return sql template ; } final string builder sb = new string builder ( ) ; int q mark count = num ; final string tokenizer tok = new string tokenizer ( sql template + str , str ) ; while ( tok . has more tokens ( ) ) { final string one chunk = tok . next token ( ) ; sb . append ( one chunk ) ; try { object value = null ; if ( parameter values . size ( ) > num + q mark count ) { value = parameter values . get ( num + q mark count ) ; q mark count ++ ; } else { if ( ! tok . has more tokens ( ) ) { value = str ; } } if ( value == null ) { value = str ; } sb . append ( value ) ; } catch ( throwable th ) { sb . append ( str ) . append ( th . to string ( ) ) ; } } return sb . to string ( ) . trim ( ) ; }	Returns the query string.
protected string get action class name ( final object action ) { class clazz = action . get class ( ) ; clazz = proxetta util . resolve target class ( clazz ) ; return clazz . get name ( ) ; }	Returns correct action class name.
protected int calculate to ( final int from , final int count , final int size ) { int to = size ; if ( count != - num ) { to = from + count ; if ( to > size ) { to = size ; } } return to ; }	Calculates 'TO'.
public static string replace ( final string s , final string sub , final string with ) { if ( sub . is empty ( ) ) { return s ; } int c = num ; int i = s . index of ( sub , c ) ; if ( i == - num ) { return s ; } int length = s . length ( ) ; string builder sb = new string builder ( length + with . length ( ) ) ; do { sb . append ( s , c , i ) ; sb . append ( with ) ; c = i + sub . length ( ) ; } while ( ( i = s . index of ( sub , c ) ) != - num ) ; if ( c < length ) { sb . append ( s , c , length ) ; } return sb . to string ( ) ; }	Replaces all occurrences of a certain pattern in a string with areplacement string.
public static string replace char ( final string s , final char sub , final char with ) { int start index = s . index of ( sub ) ; if ( start index == - num ) { return s ; } char [ ] str = s . to char array ( ) ; for ( int i = start index ; i < str . length ; i ++ ) { if ( str [ i ] == sub ) { str [ i ] = with ; } } return new string ( str ) ; }	Replaces all occurrences of a character in a string.
public static string replace chars ( final string s , final char [ ] sub , final char [ ] with ) { char [ ] str = s . to char array ( ) ; for ( int i = num ; i < str . length ; i ++ ) { char c = str [ i ] ; for ( int j = num ; j < sub . length ; j ++ ) { if ( c == sub [ j ] ) { str [ i ] = with [ j ] ; break ; } } } return new string ( str ) ; }	Replaces all occurrences of a characters in a string.
public static string replace first ( final string s , final string sub , final string with ) { int i = s . index of ( sub ) ; if ( i == - num ) { return s ; } return s . substring ( num , i ) + with + s . substring ( i + sub . length ( ) ) ; }	Replaces the very first occurrence of a substring with supplied string.
public static string replace first ( final string s , final char sub , final char with ) { int index = s . index of ( sub ) ; if ( index == - num ) { return s ; } char [ ] str = s . to char array ( ) ; str [ index ] = with ; return new string ( str ) ; }	Replaces the very first occurrence of a character in a string.
public static string replace last ( final string s , final string sub , final string with ) { int i = s . last index of ( sub ) ; if ( i == - num ) { return s ; } return s . substring ( num , i ) + with + s . substring ( i + sub . length ( ) ) ; }	Replaces the very last occurrence of a substring with supplied string.
public static string replace last ( final string s , final char sub , final char with ) { int index = s . last index of ( sub ) ; if ( index == - num ) { return s ; } char [ ] str = s . to char array ( ) ; str [ index ] = with ; return new string ( str ) ; }	Replaces the very last occurrence of a character in a string.
public static string remove ( final string s , final string sub ) { int c = num ; int sublen = sub . length ( ) ; if ( sublen == num ) { return s ; } int i = s . index of ( sub , c ) ; if ( i == - num ) { return s ; } string builder sb = new string builder ( s . length ( ) ) ; do { sb . append ( s , c , i ) ; c = i + sublen ; } while ( ( i = s . index of ( sub , c ) ) != - num ) ; if ( c < s . length ( ) ) { sb . append ( s , c , s . length ( ) ) ; } return sb . to string ( ) ; }	Removes all substring occurrences from the string.
public static string remove ( final string string , final char ch ) { int string len = string . length ( ) ; char [ ] result = new char [ string len ] ; int offset = num ; for ( int i = num ; i < string len ; i ++ ) { char c = string . char at ( i ) ; if ( c == ch ) { continue ; } result [ offset ] = c ; offset ++ ; } if ( offset == string len ) { return string ;	Removes a single character from string.
public static boolean is all empty ( final string ... strings ) { for ( string string : strings ) { if ( ! is empty ( string ) ) { return bool ; } } return bool ; }	Determines if string array contains empty strings.
public static boolean is all blank ( final string ... strings ) { for ( string string : strings ) { if ( ! is blank ( string ) ) { return bool ; } } return bool ; }	Determines if string array contains just blank strings.
public static string [ ] to string array ( final object value ) { if ( value == null ) { return new string [ num ] ; } class < ? > type = value . get class ( ) ; if ( ! type . is array ( ) ) { return new string [ ] { value . to string ( ) } ; } class component type = type . get component type ( ) ; if ( component type . is primitive ( ) ) { if ( component type == int . class ) { return arrays util . to string array ( ( int [ ] ) value ) ; } else if ( component type == long . class ) { return arrays util . to string array ( ( long [ ] ) value ) ; } else if ( component type == double . class ) { return arrays util . to string array ( ( double [ ] ) value ) ; } else if ( component type == float . class ) { return arrays util . to string array ( ( float [ ] ) value ) ; } else if ( component type == boolean . class ) { return arrays util . to string array ( ( boolean [ ] ) value ) ; } else if ( component type == short . class ) { return arrays util . to string array ( ( short [ ] ) value ) ; } else if ( component type == byte . class ) { return arrays util . to string array ( ( byte [ ] ) value ) ; } else { throw new illegal argument exception ( ) ; } } else { return arrays util . to string array ( ( object [ ] ) value ) ; } }	Converts an array object to array of strings, where every elementof input array is converted to a string.
private static string change first character case ( final boolean capitalize , final string string ) { int str len = string . length ( ) ; if ( str len == num ) { return string ; } char ch = string . char at ( num ) ; char modified ch ; if ( capitalize ) { modified ch = character . to upper case ( ch ) ; } else { modified ch = character . to lower case ( ch ) ; } if ( modified ch == ch ) {	Internal method for changing the first character case.
public static string title ( final string string ) { char [ ] chars = string . to char array ( ) ; boolean was whitespace = bool ; for ( int i = num ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( char util . is whitespace ( c ) ) { was whitespace = bool ; } else { if ( was whitespace ) { chars [ i ] = character . to upper case ( c ) ; } else { chars [ i ] = character . to lower case ( c ) ; } was whitespace = bool ; } } return new string ( chars ) ; }	Makes a title-cased string from given input.
public static string compress chars ( final string s , final char c ) { int len = s . length ( ) ; string builder sb = new string builder ( len ) ; boolean was char = bool ; for ( int i = num ; i < len ; i ++ ) { char c1 = s . char at ( i ) ; if ( c1 == c ) { if ( was char ) { continue ; } was char = bool ; } else { was char = bool ; } sb . append ( c1 ) ; } if ( sb . length ( ) == len ) { return s ; } return sb . to string ( ) ; }	Compress multiple occurrences of given char into one appearance.
public static boolean starts with ignore case ( final string src , final string sub s , final int start index ) { string sub = sub s . to lower case ( ) ; int sublen = sub . length ( ) ; if ( start index + sublen > src . length ( ) ) { return bool ; } int j = num ; int i = start index ; while ( j < sublen ) { char source = character . to lower case ( src . char at ( i ) ) ; if ( sub . char at ( j ) != source ) { return bool ; } j ++ ; i ++ ; } return bool ; }	Tests if this string starts with the specified prefix with ignored caseand with the specified prefix beginning a specified index.
public static boolean ends with char ( final string s , final char c ) { if ( s . length ( ) == num ) { return bool ; } return s . char at ( s . length ( ) - num ) == c ; }	Returns if string ends with provided character.
public static int count ignore case ( final string source , final string sub ) { int count = num ; int j = num ; int sublen = sub . length ( ) ; if ( sublen == num ) { return num ; } while ( bool ) { int i = index of ignore case ( source , sub , j ) ; if ( i == - num ) { break ; } count ++ ; j = i + sublen ; } return count ; }	Count substring occurrences in a source string, ignoring case.
public static boolean equals ignore case ( final string [ ] as , final string [ ] as1 ) { if ( as . length != as1 . length ) { return bool ; } for ( int i = num ; i < as . length ; i ++ ) { if ( ! as [ i ] . equals ignore case ( as1 [ i ] ) ) { return bool ; } } return bool ; }	Compares two string arrays.
public static int index of whitespace ( final string string , final int startindex , final int endindex ) { for ( int i = startindex ; i < endindex ; i ++ ) { if ( char util . is whitespace ( string . char at ( i ) ) ) { return i ; } } return - num ; }	Returns first index of a whitespace character, starting from specified index offset.
public static string strip leading char ( final string string , final char c ) { if ( string . length ( ) > num ) { if ( string . char at ( num ) == c ) { return string . substring ( num ) ; } } return string ; }	Strips leading char if string starts with one.
public static string strip trailing char ( final string string , final char c ) { if ( string . length ( ) > num ) { if ( string . char at ( string . length ( ) - num ) == c ) { return string . substring ( num , string . length ( ) - num ) ; } } return string ; }	Strips trailing char if string ends with one.
public static string strip char ( final string string , final char c ) { if ( string . length ( ) == num ) { return string ; } if ( string . length ( ) == num ) { if ( string . char at ( num ) == c ) { return string pool . empty ; } return string ; } int left = num ; int right = string . length ( ) ; if ( string . char at ( left ) == c ) { left ++ ; } if ( string . char at ( right - num ) == c ) { right -- ; } return string . substring ( left , right ) ; }	Strips leading and trailing char from given string.
public static string strip to char ( final string string , final char c ) { int ndx = string . index of ( c ) ; if ( ndx == - num ) { return string ; } return string . substring ( ndx ) ; }	Strips everything up to the first appearance of given char.Character IS included in the returned string.
public static string strip from char ( final string string , final char c ) { int ndx = string . index of ( c ) ; if ( ndx == - num ) { return string ; } return string . substring ( num , ndx ) ; }	Strips everything from the first appearance of given char.Character IS NOT included in the returned string.
public static void crop all ( final string ... strings ) { for ( int i = num ; i < strings . length ; i ++ ) { string string = strings [ i ] ; if ( string != null ) { string = crop ( strings [ i ] ) ; } strings [ i ] = string ; } }	Crops all elements of string array.
public static string trim left ( final string src ) { int len = src . length ( ) ; int st = num ; while ( ( st < len ) && ( char util . is whitespace ( src . char at ( st ) ) ) ) { st ++ ; } return st > num ? src . substring ( st ) : src ; }	Trim whitespaces from the left.
public static string trim right ( final string src ) { int len = src . length ( ) ; int count = len ; while ( ( len > num ) && ( char util . is whitespace ( src . char at ( len - num ) ) ) ) { len -- ; } return ( len < count ) ? src . substring ( num , len ) : src ; }	Trim whitespaces from the right.
public static int [ ] index of region ( final string string , final string left boundary , final string right boundary , final int offset ) { int ndx = offset ; int [ ] res = new int [ num ] ; ndx = string . index of ( left boundary , ndx ) ; if ( ndx == - num ) { return null ; } res [ num ] = ndx ; ndx += left boundary . length ( ) ; res [ num ] = ndx ; ndx = string . index of ( right boundary , ndx ) ; if ( ndx == - num ) { return null ; } res [ num ] = ndx ; res [ num ] = ndx + right boundary . length ( ) ; return res ; }	Returns indexes of the first region without escaping character.
public static string join ( final collection collection , final char separator ) { if ( collection == null ) { return null ; } if ( collection . size ( ) == num ) { return string pool . empty ; } final string builder sb = new string builder ( collection . size ( ) * num ) ; final iterator it = collection . iterator ( ) ; for ( int i = num ; i < collection . size ( ) ; i ++ ) { if ( i > num ) { sb . append ( separator ) ; } sb . append ( it . next ( ) ) ; } return sb . to string ( ) ; }	Joins an collection of objects into one string with separator.
public static string join ( final object [ ] array , final string separator ) { if ( array == null ) { return null ; } if ( array . length == num ) { return string pool . empty ; } if ( array . length == num ) { return string . value of ( array [ num ] ) ; } final string builder sb = new string builder ( array . length * num ) ; for ( int i = num ; i < array . length ; i ++ ) { if ( i > num ) { sb . append ( separator ) ; } sb . append ( array [ i ] ) ; } return sb . to string ( ) ; }	Joins an array of objects into one string with separator.
public static string convert charset ( final string source , final string src charset name , final string new charset name ) { if ( src charset name . equals ( new charset name ) ) { return source ; } return string util . new string ( string util . get bytes ( source , src charset name ) , new charset name ) ; }	Converts string charset. If charset names are the same, the same string is returned.
public static boolean is char at equal ( final string string , final int index , final char char to compare ) { if ( ( index < num ) || ( index >= string . length ( ) ) ) { return bool ; } return string . char at ( index ) == char to compare ; }	Safely compares provided char with char on given location.
public static string surround ( string string , final string prefix , final string suffix ) { if ( ! string . starts with ( prefix ) ) { string = prefix + string ; } if ( ! string . ends with ( suffix ) ) { string += suffix ; } return string ; }	Surrounds the string with provided prefix and suffix if such missing from string.
public static string prefix ( string string , final string prefix ) { if ( ! string . starts with ( prefix ) ) { string = prefix + string ; } return string ; }	Inserts prefix if doesn't exist.
public static string suffix ( string string , final string suffix ) { if ( ! string . ends with ( suffix ) ) { string += suffix ; } return string ; }	Appends suffix if doesn't exist.
public static string cut to index of ( string string , final string substring ) { int i = string . index of ( substring ) ; if ( i != - num ) { string = string . substring ( num , i ) ; } return string ; }	Cuts the string from beginning to the first index of provided substring.
public static string cut from index of ( string string , final string substring ) { int i = string . index of ( substring ) ; if ( i != - num ) { string = string . substring ( i ) ; } return string ; }	Cuts the string from the first index of provided substring to the end.
public static string cut prefix ( string string , final string prefix ) { if ( string . starts with ( prefix ) ) { string = string . substring ( prefix . length ( ) ) ; } return string ; }	Cuts prefix if exists.
public static string cut suffix ( string string , final string suffix ) { if ( string . ends with ( suffix ) ) { string = string . substring ( num , string . length ( ) - suffix . length ( ) ) ; } return string ; }	Cuts sufix if exists.
public static string cut surrounding ( final string string , final string prefix , final string suffix ) { int start = num ; int end = string . length ( ) ; if ( string . starts with ( prefix ) ) { start = prefix . length ( ) ; } if ( string . ends with ( suffix ) ) { end -= suffix . length ( ) ; } if ( end <= start ) { return string pool . empty ; } return string . substring ( start , end ) ; }	Removes surrounding prefix and suffixes.
public static string insert ( final string src , final string insert , int offset ) { if ( offset < num ) { offset = num ; } if ( offset > src . length ( ) ) { offset = src . length ( ) ; } string builder sb = new string builder ( src ) ; sb . insert ( offset , insert ) ; return sb . to string ( ) ; }	Inserts a string on provided offset.
public static string repeat ( final string source , int count ) { string band result = new string band ( count ) ; while ( count > num ) { result . append ( source ) ; count -- ; } return result . to string ( ) ; }	Creates a new string that contains the provided string a number of times.
public static string reverse ( final string s ) { string builder result = new string builder ( s . length ( ) ) ; for ( int i = s . length ( ) - num ; i >= num ; i -- ) { result . append ( s . char at ( i ) ) ; } return result . to string ( ) ; }	Reverse a string.
public static string max common prefix ( final string one , final string two ) { final int min length = math . min ( one . length ( ) , two . length ( ) ) ; final string builder sb = new string builder ( min length ) ; for ( int pos = num ; pos < min length ; pos ++ ) { final char current char = one . char at ( pos ) ; if ( current char != two . char at ( pos ) ) { break ; } sb . append ( current char ) ; } return sb . to string ( ) ; }	Returns max common prefix of two strings.
public static string find common prefix ( final string ... strings ) { string builder prefix = new string builder ( ) ; int index = num ; char c = num ; loop : while ( bool ) { for ( int i = num ; i < strings . length ; i ++ ) { string s = strings [ i ] ; if ( index == s . length ( ) ) { break loop ; } if ( i == num ) { c = s . char at ( index ) ; } else { if ( s . char at ( index ) != c ) { break loop ; } } } index ++ ; prefix . append ( c ) ; } return prefix . length ( ) == num ? string pool . empty : prefix . to string ( ) ; }	Finds common prefix for several strings.
public static string shorten ( string s , int length , final string suffix ) { length -= suffix . length ( ) ; if ( s . length ( ) > length ) { for ( int j = length ; j >= num ; j -- ) { if ( char util . is whitespace ( s . char at ( j ) ) ) { length = j ; break ; } } string temp = s . substring ( num , length ) ; s = temp . concat ( suffix ) ; } return s ; }	Shorten string to given length.
public static string to upper case ( final string s , locale locale ) { if ( s == null ) { return null ; } string builder sb = null ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char c = s . char at ( i ) ; if ( c > num ) {	Converts all of the characters in the string to upper case, based on thelocale.
public static string remove quotes ( final string string ) { if ( ( starts with char ( string , str ) && ends with char ( string , str ) ) || ( starts with char ( string , str ) && ends with char ( string , str ) ) || ( starts with char ( string , str ) && ends with char ( string , str ) ) ) { return substring ( string , num , - num ) ; } return string ; }	Removes starting and ending single or double quotes.
public static string to hex string ( final byte [ ] bytes ) { char [ ] chars = new char [ bytes . length * num ] ; int i = num ; for ( byte b : bytes ) { chars [ i ++ ] = char util . int2hex ( ( b & num ) > > num ) ; chars [ i ++ ] = char util . int2hex ( b & num ) ; } return new string ( chars ) ; }	Converts bytes to hex string.
public static byte [ ] get bytes ( final string string ) { try { return string . get bytes ( jodd core . encoding ) ; } catch ( unsupported encoding exception e ) { throw new runtime exception ( e ) ; } }	Returns String bytes using Jodds default encoding.
public static char detect quote char ( final string str ) { if ( str . length ( ) < num ) { return num ; } final char c = str . char at ( num ) ; if ( c != str . char at ( str . length ( ) - num ) ) { return num ; } if ( c == str || c == str || c == str ) { return c ; } return num ; }	Detects quote character or return 0.
public void visit enum ( final string name , final string descriptor , final string value ) { if ( av != null ) { av . visit enum ( name , descriptor , value ) ; } }	Visits an enumeration value of the annotation.
public annotation visitor visit annotation ( final string name , final string descriptor ) { if ( av != null ) { return av . visit annotation ( name , descriptor ) ; } return null ; }	Visits a nested annotation value of the annotation.
public < e > db entity descriptor < e > register type ( final class < e > type ) { db entity descriptor < e > ded = create db entity descriptor ( type ) ; db entity descriptor < e > existing = descriptors map . put ( type , ded ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + type . get name ( ) + str + ded . get table name ( ) ) ; } if ( existing != null ) { if ( ded . get type ( ) == type ) { return ded ; } throw new db oom exception ( str + existing . get type ( ) ) ; } existing = entity names map . put ( ded . get entity name ( ) , ded ) ; if ( existing != null ) { throw new db oom exception ( str + ded . get entity name ( ) + str + existing . get type ( ) ) ; } return ded ; }	Registers just type and entity names.
public < e > db entity descriptor < e > register entity ( final class < e > type , final boolean force ) { if ( force ) { remove entity ( type ) ; } return register entity ( type ) ; }	Registers entity. Existing entity will be removed if exist, so no exception will be thrown.
public < e > db entity descriptor < e > remove entity ( final class < e > type ) { db entity descriptor < e > ded = descriptors map . remove ( type ) ; if ( ded == null ) { ded = create db entity descriptor ( type ) ; } entity names map . remove ( ded . get entity name ( ) ) ; table names map . remove ( ded . get table name ( ) ) ; return ded ; }	Removes entity and returns removed descriptor.
public < e > e create entity instance ( final class < e > type ) { try { return class util . new instance ( type ) ; } catch ( exception ex ) { throw new db oom exception ( ex ) ; } }	Creates new entity instances.
public wrapper proxetta factory set target interface ( final class target interface ) { if ( ! target interface . is interface ( ) ) { throw new proxetta exception ( str + target interface . get name ( ) ) ; } this . target interface = target interface ; return this ; }	Defines the interface of the resulting class.
public void inject target into wrapper ( final object target , final object wrapper ) { proxetta util . inject target into wrapper ( target , wrapper , target field name ) ; }	Injects target into wrapper.
protected property descriptor [ ] lookup annotated properties ( final class type ) { property descriptor [ ] properties = annotated properties . get ( type ) ; if ( properties != null ) { return properties ; } class descriptor cd = class introspector . get ( ) . lookup ( type ) ; property descriptor [ ] all properties = cd . get all property descriptors ( ) ; list < property descriptor > list = new array list < > ( ) ; for ( property descriptor property descriptor : all properties ) { annotation ann = null ; if ( property descriptor . get field descriptor ( ) != null ) { ann = property descriptor . get field descriptor ( ) . get field ( ) . get annotation ( annotations ) ; } if ( ann == null && property descriptor . get write method descriptor ( ) != null ) { ann = property descriptor . get write method descriptor ( ) . get method ( ) . get annotation ( annotations ) ; } if ( ann == null && property descriptor . get read method descriptor ( ) != null ) { ann = property descriptor . get read method descriptor ( ) . get method ( ) . get annotation ( annotations ) ; } if ( ann != null ) { list . add ( property descriptor ) ; } } if ( list . is empty ( ) ) { properties = empty ; } else { properties = list . to array ( new property descriptor [ num ] ) ; } annotated properties . put ( type , properties ) ; return properties ; }	Lookups for annotated properties.
public db server detect database and configure db oom ( final connection provider cp , final db oom config db oom config ) { cp . init ( ) ; final connection connection = cp . get connection ( ) ; final db server db server = detect database ( connection ) ; cp . close connection ( connection ) ; db server . accept ( db oom config ) ; return db server ; }	Detects database and configure DbOom engine.
@ override public void close ( ) throws io { if ( closed ) { return ; } if ( gzipstream != null ) { flush to g ( ) ; gzipstream . close ( ) ; gzipstream = null ; } else { if ( buffer count > num ) { output . write ( buffer , num , buffer count ) ; buffer count = num ; } } output . close ( ) ; closed = bool ; }	Closes this output stream, causing any buffered data to be flushed and anyfurther output data to throw an IOException.
@ override public void write ( final int b ) throws io { if ( closed ) { throw new io ( str ) ; } if ( buffer count >= buffer . length ) { flush to g ( ) ; } buffer [ buffer count ++ ] = ( byte ) b ; }	Writes the specified byte to our output stream.
@ override public void do filter ( final servlet request request , final servlet response response , final filter chain chain ) throws io , servlet exception { http servlet request http request = ( http servlet request ) request ; http servlet response http response = ( http servlet response ) response ; if ( is requested session id from url ( http request ) ) { http session session = http request . get session ( bool ) ; if ( session != null ) { session . invalidate ( ) ;	Filters requests to remove URL-based session identifiers.
public string get encoded name ( ) { if ( name == null ) { return null ; } try { return mime utility . encode text ( name ) ; } catch ( final unsupported encoding exception ueex ) { throw new mail exception ( ueex ) ; } }	Returns encoded attachment name.
public byte [ ] to byte array ( ) { final fast byte array output stream out ; if ( size != - num ) { out = new fast byte array output stream ( size ) ; } else { out = new fast byte array output stream ( ) ; } write to stream ( out ) ; return out . to byte array ( ) ; }	Returns byte content of the attachment.
public void write to file ( final file destination ) { input stream input = null ; final output stream output ; try { input = get data source ( ) . get input stream ( ) ; output = new file output stream ( destination ) ; stream util . copy ( input , output ) ; } catch ( final io ioex ) { throw new mail exception ( ioex ) ; } finally { stream util . close ( input ) ; } }	Saves attachment to a file.
public void write to stream ( final output stream out ) { input stream input = null ; try { input = get data source ( ) . get input stream ( ) ; stream util . copy ( input , out ) ; } catch ( final io ioex ) { throw new mail exception ( ioex ) ; } finally { stream util . close ( input ) ; } }	Saves attachment to the output stream.
protected static string append argument ( final string desc , final string type ) { int ndx = desc . index of ( str ) ; return desc . substring ( num , ndx ) + type + desc . substring ( ndx ) ; }	Appends argument to the existing description.
protected static string prepend argument ( final string desc , final string type ) { int ndx = desc . index of ( str ) ; ndx ++ ; return desc . substring ( num , ndx ) + type + desc . substring ( ndx ) ; }	Prepends argument to the existing description.
protected static string change return type ( final string desc , final string type ) { int ndx = desc . index of ( str ) ; return desc . substring ( num , ndx + num ) + type ; }	Changes return type.
@ override public void text ( final char sequence text ) { if ( ! strip ) { super . text ( text ) ; return ; } int text length = text . length ( ) ; char [ ] dest = new char [ text length ] ; int ndx = num ; boolean regular char = bool ; for ( int i = num ; i < text length ; i ++ ) { char c = text . char at ( i ) ; if ( char util . is whitespace ( c ) ) { if ( regular char ) { regular char = bool ; c = str ; } else { continue ; } } else { regular char = bool ; } dest [ ndx ] = c ; ndx ++ ; } if ( regular char || ( ndx != num ) ) { super . text ( char buffer . wrap ( dest , num , ndx ) ) ; stripped chars count += text length - ndx ; } else { stripped chars count += text length ; } }	Cleans unnecessary whitespaces.
public < t > void register ( final class < t > type , final type converter < t > type converter ) { converters . put ( type , type converter ) ; }	Registers a converter for specified type.User must register converter for all super-classes as well.
public < t > type converter < t > lookup ( final class < t > type ) { return converters . get ( type ) ; }	Retrieves converter for provided type.
public list < node > select ( final string query ) { collection < list < css selector > > selectors collection = cs . parse ( query ) ; return select ( selectors collection ) ; }	Selects nodes using CSS3 selector query.
public list < node > select ( final collection < list < css selector > > selectors collection ) { list < node > results = new array list < > ( ) ; for ( list < css selector > selectors : selectors collection ) { process selectors ( results , selectors ) ; } return results ; }	Selected nodes using pre-parsed CSS selectors.
protected void process selectors ( final list < node > results , final list < css selector > selectors ) { list < node > selected nodes = select ( root node , selectors ) ; for ( node selected node : selected nodes ) { if ( ! results . contains ( selected node ) ) { results . add ( selected node ) ; } } }	Process selectors and keep adding results.
public node select first ( final string query ) { list < node > selected nodes = select ( query ) ; if ( selected nodes . is empty ( ) ) { return null ; } return selected nodes . get ( num ) ; }	Selects nodes using CSS3 selector query and returns the very first one.
protected void walk descendants iteratively ( final linked list < node > nodes , final css selector css selector , final list < node > result ) { while ( ! nodes . is empty ( ) ) { node node = nodes . remove first ( ) ; select and add ( node , css selector , result ) ;	Walks over the child notes, maintaining the tree order and not using recursion.
protected void walk ( final node root node , final css selector css selector , final list < node > result ) {	Finds nodes in the tree that matches single selector.
protected void select and add ( final node node , final css selector css selector , final list < node > result ) {	Selects single node for single selector and appends it to the results.
private static char [ ] zz unpack c ( final string packed ) { char [ ] map = new char [ num ] ; int i = num ; int j = num ; while ( i < num ) { int count = packed . char at ( i ++ ) ; char value = packed . char at ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > num ) ; } return map ; }	Unpacks the compressed character translation table.
private boolean zz refill ( ) { if ( zz buffer == null ) { zz buffer = zz chars ; zz end read += zz chars . length ; return bool ; } return bool ; }	Refills the input buffer.
protected < t > page data < t > page ( string sql , final map params , final int page , final int page size , final string sort column name , final boolean ascending , final class [ ] target ) { if ( sort column name != null ) { sql = build order sql ( sql , sort column name , ascending ) ; } int from = ( page - num ) * page size ; string page sql = build page sql ( sql , from , page size ) ; db sql builder dbsql = sql ( page sql ) ; db oom query query = query ( dbsql ) ; query . set max rows ( page size ) ; query . set fetch size ( page size ) ; query . set map ( params ) ; list < t > list = query . list ( page size , target ) ; query . close ( ) ; string count sql = build count sql ( sql ) ; dbsql = sql ( count sql ) ; query = query ( dbsql ) ; query . set map ( params ) ; long count = query . execute count ( ) ; query . close ( ) ; return new page data < > ( page , ( int ) count , page size , list ) ; }	Pages given page.
protected string remove select ( string sql ) { int ndx = string util . index of ignore case ( sql , str ) ; if ( ndx != - num ) { sql = sql . substring ( ndx + num ) ;	Removes the first 'select' from the sql query.
protected string remove to from ( string sql ) { int from = num ; int from count = num ; int select count = num ; int last ndx = num ; while ( bool ) { int ndx = string util . index of ignore case ( sql , str , from ) ; if ( ndx == - num ) { break ; }	Removes the first part of the sql up to the relevant 'from'.Tries to detect sub-queries in the 'select' part.
protected string remove last order by ( string sql ) { int ndx = string util . last index of ignore case ( sql , str ) ; if ( ndx != - num ) { int ndx2 = sql . last index of ( sql , str ) ; if ( ndx > ndx2 ) { sql = sql . substring ( num , ndx ) ; } } return sql ; }	Removes everything from last "order by".
public static string decode ( final string html ) { int ndx = html . index of ( str ) ; if ( ndx == - num ) { return html ; } string builder result = new string builder ( html . length ( ) ) ; int last index = num ; int len = html . length ( ) ; mainloop : while ( ndx != - num ) { result . append ( html . substring ( last index , ndx ) ) ; last index = ndx ; while ( html . char at ( last index ) != str ) { last index ++ ; if ( last index == len ) { last index = ndx ; break mainloop ; } } if ( html . char at ( ndx + num ) == str ) {	Decodes HTML text. Assumes that all character references are properly closed with semi-colon.
public static string detect name ( final char [ ] input , int ndx ) { final ptr ptr = new ptr ( ) ; int first index = num ; int last index = entity names . length - num ; int len = input . length ; char [ ] last name = null ; final binary search base binary search = new binary search base ( ) { @ override protected int compare ( final int index ) { char [ ] name = entity names [ index ] ; if ( ptr . offset >= name . length ) { return - num ; } return name [ ptr . offset ] - ptr . c ; } } ; while ( bool ) { ptr . c = input [ ndx ] ; if ( ! char util . is alpha or digit ( ptr . c ) ) { return last name != null ? new string ( last name ) : null ; } first index = binary search . find first ( first index , last index ) ; if ( first index < num ) { return last name != null ? new string ( last name ) : null ; } char [ ] element = entity names [ first index ] ; if ( element . length == ptr . offset + num ) {	Detects the longest character reference name on given position in char array.
@ override protected string build order sql ( string sql , final string column , final boolean ascending ) { sql += str + column ; if ( ! ascending ) { sql += str ; } return sql ; }	Appends ORDER BY keyword.
@ override protected string build page sql ( string sql , final int from , final int page size ) { sql = remove select ( sql ) ; return str + from + str + page size + sql ; }	Builds page sql using LIMIT keyword after the SELECT.
private void resolve columns and properties ( final class type ) { property descriptor [ ] all properties = class introspector . get ( ) . lookup ( type ) . get all property descriptors ( ) ; list < db entity column descriptor > dec list = new array list < > ( all properties . length ) ; int idcount = num ; hash set < string > names = new hash set < > ( all properties . length ) ; for ( property descriptor property descriptor : all properties ) { db entity column descriptor dec = db meta util . resolve column descriptors ( this , property descriptor , is annotated , column naming strategy ) ; if ( dec != null ) { if ( ! names . add ( dec . get column name ( ) ) ) { throw new db oom exception ( str + dec . get column name ( ) ) ; } dec list . add ( dec ) ; if ( dec . is id ) { idcount ++ ; } } } if ( dec list . is empty ( ) ) { throw new db oom exception ( str + type ) ; } column descriptors = dec list . to array ( new db entity column descriptor [ num ] ) ; arrays . sort ( column descriptors ) ;	Resolves list of all columns and properties.
public db entity column descriptor find by column name ( final string column name ) { if ( column name == null ) { return null ; } init ( ) ; for ( db entity column descriptor column descriptor : column descriptors ) { if ( column descriptor . column name . equals ignore case ( column name ) ) { return column descriptor ; } } return null ; }	Finds column descriptor by column name.
public db entity column descriptor find by property name ( final string property name ) { if ( property name == null ) { return null ; } init ( ) ; for ( db entity column descriptor column descriptor : column descriptors ) { if ( column descriptor . property name . equals ( property name ) ) { return column descriptor ; } } return null ; }	Finds column descriptor by property name.
public string get property name ( final string column name ) { db entity column descriptor dec = find by column name ( column name ) ; return dec == null ? null : dec . property name ; }	Returns property name for specified column name.
public string get column name ( final string property name ) { db entity column descriptor dec = find by property name ( property name ) ; return dec == null ? null : dec . column name ; }	Returns column name for specified property name..
public object get id value ( final e object ) { final string property name = get id property name ( ) ; return bean util . declared . get property ( object , property name ) ; }	Returns ID value for given entity instance.
public void set id value ( final e object , final object value ) { final string property name = get id property name ( ) ; bean util . declared . set property ( object , property name , value ) ; }	Sets ID value for given entity.
public string get key value ( final e object ) { object id value = get id value ( object ) ; string id value string = id value == null ? string pool . null : id value . to string ( ) ; return type . get name ( ) . concat ( string pool . colon ) . concat ( id value string ) ; }	Returns unique key for this entity.
public string band append ( string s ) { if ( s == null ) { s = string pool . null ; } if ( index >= array . length ) { expand capacity ( ) ; } array [ index ++ ] = s ; length += s . length ( ) ; return this ; }	Appends a string.
public void set index ( final int new index ) { if ( new index < num ) { throw new array index out of bounds exception ( new index ) ; } if ( new index > array . length ) { string [ ] new array = new string [ new index ] ; system . arraycopy ( array , num , new array , num , index ) ; array = new array ; } if ( new index > index ) { for ( int i = index ; i < new index ; i ++ ) { array [ i ] = string pool . empty ; } } else if ( new index < index ) { for ( int i = new index ; i < index ; i ++ ) { array [ i ] = null ; } } index = new index ; length = calculate length ( ) ; }	Specifies the new index.
protected void expand capacity ( ) { string [ ] new array = new string [ array . length << num ] ; system . arraycopy ( array , num , new array , num , index ) ; array = new array ; }	Expands internal string array by multiplying its size by 2.
protected int calculate length ( ) { int len = num ; for ( int i = num ; i < index ; i ++ ) { len += array [ i ] . length ( ) ; } return len ; }	Calculates string length.
protected string create mixing message ( final bean definition target bean definition , final bean definition ref bean definition ) { return str + ref bean definition . name + str + ref bean definition . scope . get class ( ) . get simple name ( ) + str + target bean definition . name + str + target bean definition . scope . get class ( ) . get simple name ( ) ; }	Creates mixed scope message.
protected object create scoped proxy bean ( final petite container petite container , final bean definition ref bean definition ) { class bean type = ref bean definition . type ; class proxy class = proxy classes . get ( bean type ) ; if ( proxy class == null ) {	Creates scoped proxy bean for given bean definition.
protected void init ( ) { file [ ] files array = dir . list files ( ) ; files count = num ; if ( files array != null ) { files count = files array . length ; for ( file file : files array ) { if ( ! accept file ( file ) ) { continue ; } map . put ( file , new mutable long ( file . last modified ( ) ) ) ; } } }	Initializes dir watcher by reading all filesfrom watched folder.
protected boolean accept file ( final file file ) { if ( ! file . is file ( ) ) { return bool ;	Accepts if a file is going to be watched.
public dir watcher use watch file ( final string name ) { watch file = new file ( dir , name ) ; if ( ! watch file . is file ( ) || ! watch file . exists ( ) ) { try { file util . touch ( watch file ) ; } catch ( io ioex ) { throw new dir watcher exception ( str + name , ioex ) ; } } watch file last access time = watch file . last modified ( ) ; return this ; }	Enables usage of provided watch file.
public void start ( final long polling interval ) { if ( timer == null ) { if ( ! start blank ) { init ( ) ; } timer = new timer ( bool ) ; timer . schedule ( new watch task ( ) , num , polling interval ) ; } }	Starts the watcher.
protected void on change ( final dir watcher event . type type , final file file ) { listeners . accept ( new dir watcher event ( type , file ) ) ; }	Triggers listeners on file change.
public void add ( final enumeration < t > enumeration ) { if ( all enumerations . contains ( enumeration ) ) { throw new illegal argument exception ( str ) ; } all enumerations . add ( enumeration ) ; }	Adds an enumeration to this composite.
int compute field info size ( ) {	Returns the size of the field_info JVMS structure generated by this FieldWriter.
void put field info ( final byte vector output ) { boolean use synthetic attribute = symbol table . get major version ( ) < opcodes . 5 ;	Puts the content of the field_info JVMS structure generated by this FieldWriter into the givenByteVector.
public static target of value ( final object value , final scope data scope data ) { return new target ( value , null , scope data , null , value instance creator ) ; }	Creates a common target over a value, with known scope data.
public void write value ( final injection point injection point , final object property value , final boolean silent ) { write value ( injection point . target name ( ) , property value , silent ) ; }	Writes value to this target.
public void decorate ( final writer writer , final char [ ] page content , final char [ ] decora content ) throws io { decora tag [ ] decora tags = parse decorator ( decora content ) ; parse page ( page content , decora tags ) ; write decorated page ( writer , decora content , page content , decora tags ) ; }	Decorates page content with decorator template and outputs the result.
protected void parse page ( final char [ ] page content , final decora tag [ ] decora tags ) { lagarto parser lagarto parser = new lagarto parser ( page content ) ; page region extractor writer = new page region extractor ( decora tags ) ; lagarto parser . parse ( writer ) ; }	Parses target page and extracts Decora regions for replacements.
protected void write decorated page ( final writer out , final char [ ] decorator content , final char [ ] page content , final decora tag [ ] decora tags ) throws io { int ndx = num ; for ( decora tag decora tag : decora tags ) {	Writes decorated content.
protected void write region ( final writer out , final char [ ] page content , final decora tag decora tag , final decora tag [ ] decora tags ) throws io { int region start = decora tag . get region start ( ) ; int region len = decora tag . get region length ( ) ; int region end = region start + region len ; for ( decora tag inner decora tag : decora tags ) { if ( decora tag == inner decora tag ) { continue ; } if ( decora tag . is region undefined ( ) ) { continue ; } if ( inner decora tag . is inside other tag region ( decora tag ) ) {	Writes region to output, but extracts all inner regions.
public void start ( ) throws io { server socket = new server socket ( listen port , socket backlog ) ; server socket . set reuse address ( bool ) ; executor service = executors . new fixed thread pool ( thread pool size ) ; running = bool ; while ( running ) { socket socket = server socket . accept ( ) ; socket . set keep alive ( bool ) ; executor service . execute ( on socket connection ( socket ) ) ; } executor service . shutdown ( ) ; }	Starts HTTP tunnel. Method ends when the tunnel is stopped.
public static process result run ( final process process ) throws interrupted exception { final byte array output stream baos = new byte array output stream ( ) ; final stream gobbler output gobbler = new stream gobbler ( process . get input stream ( ) , baos , output prefix ) ; final stream gobbler error gobbler = new stream gobbler ( process . get error stream ( ) , baos , error prefix ) ; output gobbler . start ( ) ; error gobbler . start ( ) ; final int result = process . wait for ( ) ; output gobbler . wait for ( ) ; error gobbler . wait for ( ) ; return new process result ( result , baos . to string ( ) ) ; }	Executes a process and returns the process output and exit code.
@ override protected imapssl get store ( final session session ) { simple authenticator simple authenticator = ( simple authenticator ) authenticator ; final url url ; if ( simple authenticator == null ) { url = new url ( protocol imap , host , port , string pool . empty , null , null ) ; } else { final password authentication pa = simple authenticator . get password authentication ( ) ; url = new url ( protocol imap , host , port , string pool . empty , pa . get user name ( ) , pa . get password ( ) ) ; } return new imapssl ( session , url ) ; }	Returns email store.
public servlet output stream create output stream ( ) throws io { gzip response stream gzstream = new gzip response stream ( orig response ) ; gzstream . set buffer ( threshold ) ; return gzstream ; }	Creates and returns a ServletOutputStream to write the content associatedwith this Response.
@ override public void init ( final template data template data ) { super . init ( template data ) ; if ( hint != null ) { template data . increment hints count ( ) ; } }	Counts actual real hints.
protected void append column name ( final string builder query , final db entity descriptor ded , final db entity column descriptor dec ) { query . append ( resolve table ( table ref , ded ) ) . append ( str ) . append ( dec . get column name ( ) ) ; if ( template data . get column alias type ( ) != null ) {	Simply appends column name with optional table reference and alias.
protected void add rule ( final d rule definition , final boolean include ) { if ( rules == null ) { rules = new array list < > ( ) ; } if ( include ) { includes count ++ ; } else { excludes count ++ ; } rule < r > new rule = new rule < > ( make rule ( rule definition ) , include ) ; if ( rules . contains ( new rule ) ) { return ; } rules . add ( new rule ) ; }	Adds a rule. Duplicates are not allowed and will be ignored.
public boolean apply ( final v value , final boolean blacklist , boolean flag ) { if ( rules == null ) { return flag ; } if ( blacklist ) { flag = process excludes ( value , flag ) ; flag = process includes ( value , flag ) ; } else { flag = process includes ( value , flag ) ; flag = process excludes ( value , flag ) ; } return flag ; }	Applies rules on given flag.
protected boolean process includes ( final v value , boolean include ) { if ( includes count > num ) { if ( ! include ) { for ( rule < r > rule : rules ) { if ( ! rule . include ) { continue ; } if ( in ex rule matcher . accept ( value , rule . value , bool ) ) { include = bool ; break ; } } } } return include ; }	Process includes rules.
protected boolean process excludes ( final v value , boolean include ) { if ( excludes count > num ) { if ( include ) { for ( rule < r > rule : rules ) { if ( rule . include ) { continue ; } if ( in ex rule matcher . accept ( value , rule . value , bool ) ) { include = bool ; break ; } } } } return include ; }	Process excludes rules.
public string get pseudo class name ( ) { string name = get class ( ) . get simple name ( ) . to lower case ( ) ; name = name . replace ( str , str ) ; return name ; }	Returns pseudo-class name from simple class name.
@ override public boolean add all ( final collection < ? extends e > c ) { iterator < ? extends e > i = c . iterator ( ) ; boolean changed = bool ; while ( i . has next ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; }	Add all of the elements in the given collection to this list.
protected int find insertion point ( final e o , int low , int high ) { while ( low <= high ) { int mid = ( low + high ) > > > num ; int delta = compare ( get ( mid ) , o ) ; if ( delta > num ) { high = mid - num ; } else { low = mid + num ; } } return low ; }	Conducts a binary search to find the index where Objectshould be inserted.
public void bind annotation config ( final class < ? extends annotation > annotation type , final class < ? extends action config > action config class ) { final action config action config = register new action configuration ( action config class ) ; action configs . put ( annotation type , action config ) ; for ( final annotation parser annotation parser : annotation parsers ) { if ( annotation type . equals ( annotation parser . get annotation type ( ) ) ) {	Binds action annotation and the action config.
protected action config register new action configuration ( final class < ? extends action config > action config class ) { final action config new action config = create action config ( action config class ) ; action configs . put ( action config class , new action config ) ; return new action config ; }	Registers action configuration for given type.
public action config lookup ( final class action type or annotation type ) { final action config action config = action configs . get ( action type or annotation type ) ; if ( action config == null ) { throw new madvoc exception ( str + action type or annotation type . get name ( ) ) ; } return action config ; }	Lookup for the action configuration.
public < t extends action config > void with ( final class < t > action config type , final consumer < t > action config consumer ) { final t action config = ( t ) lookup ( action config type ) ; action config consumer . accept ( action config ) ; }	Fetch some action config and consumes it.
protected static void setup system mail properties ( ) { system . set property ( str , boolean . value of ( defaults . mail mime encodefilename ) . to string ( ) ) ; system . set property ( str , boolean . value of ( defaults . mail mime decodefilename ) . to string ( ) ) ; }	Setups the system email properties.
public void validate within ( final validation context vctx , final object value ) { vtor . validate ( vctx , value , name ) ; }	Validates provided context and value withing this constraint content.
protected element find last table ( final node node ) { node table node = node ; while ( table node != null ) { if ( table node . get node type ( ) == node . node type . element ) { string table node name = table node . get node name ( ) . to lower case ( ) ; if ( table node name . equals ( str ) ) { break ; } } table node = table node . get parent node ( ) ; } return ( element ) table node ; }	Finds the last table in stack of open elements.
protected void fix elements ( ) { for ( element foster element : foster elements ) {	Performs the fix for elements.
protected map < string , bean data > register session beans ( final http session http session ) { session beans session beans = new session beans ( ) ; http session . set attribute ( session beans name , session beans ) ; return session beans . get bean map ( ) ; }	Registers new session destroy callback if not already registered.
@ suppress warnings ( str ) protected map < string , bean data > get session map ( final http session session ) { session beans session beans = ( session beans ) session . get attribute ( session beans name ) ; if ( session beans == null ) { return null ; } return session beans . get bean map ( ) ; }	Returns instance map from http session.
public void init ( string name , final string super name , final string suffix , final string req proxy class name ) { int last slash = name . last index of ( str ) ; this . target package = last slash == - num ? string pool . empty : name . substring ( num , last slash ) . replace ( str , str ) ; this . target classname = name . substring ( last slash + num ) ; this . next supername = super name ; this . super name = name ;	Work data initialization.
void add advice init method ( final string name ) { if ( advice inits == null ) { advice inits = new array list < > ( ) ; } advice inits . add ( name ) ; }	Saves used constructors of advices.
public void end ( ) { if ( new action ) { bundle id = bundles manager . register bundle ( context path , action path , bundle id , bundle content type , sources ) ; } }	Called on end of parsing.
protected void add ( final string section , final string key , final string builder value , final boolean trim , final operator operator ) {	Adds accumulated value to key and current section.
protected void extract profiles and add ( final string key , final string value , final operator operator ) { string full key = key ; int ndx = full key . index of ( profile left ) ; if ( ndx == - num ) { just add ( full key , value , null , operator ) ; return ; }	Extracts profiles from the key name and adds key-value to them.
protected void just add ( final string key , final string value , final array list < string > key profiles , final operator operator ) { if ( operator == operator . copy ) { hash map < string , object > target = new hash map < > ( ) ; string [ ] profiles = null ; if ( key profiles != null ) { profiles = key profiles . to array ( new string [ num ] ) ; } string [ ] sources = string util . splitc ( value , str ) ; for ( string source : sources ) { source = source . trim ( ) ;	Core key-value addition.
public static string typedesc2 class name ( final string desc ) { string class name = desc ; switch ( desc . char at ( num ) ) { case str : case str : case str : case str : case str : case str : case str : case str : case str : if ( desc . length ( ) != num ) { throw new illegal argument exception ( invalid base type + desc ) ; } break ; case str : class name = class name . substring ( num , class name . length ( ) - num ) ; break ; case str :	Converts bytecode-like description to java class name that can be loadedwith a classloader.
public static string typeref2 name ( final string desc ) { if ( desc . char at ( num ) != type reference ) { throw new illegal argument exception ( invalid type description + desc ) ; } string name = desc . substring ( num , desc . length ( ) - num ) ; return name . replace ( str , str ) ; }	Converts type reference to java-name.
public static string type to typeref ( final class type ) { if ( ! type . is array ( ) ) { if ( ! type . is primitive ( ) ) { return str + type to signature ( type ) + str ; } if ( type == int . class ) { return str ; } if ( type == long . class ) { return str ; } if ( type == boolean . class ) { return str ; } if ( type == double . class ) { return str ; } if ( type == float . class ) { return str ; } if ( type == short . class ) { return str ; } if ( type == void . class ) { return str ; } if ( type == byte . class ) { return str ; } if ( type == char . class ) { return str ; } } return type . get name ( ) ; }	Converts type to byteccode type ref.
public consumers < t > add all ( final consumer < t > ... consumers ) { collections . add all ( consumer list , consumers ) ; return this ; }	Registers additional consumers.
@ suppress warnings ( str ) protected collection < t > create collection ( final int length ) { if ( collection type . is interface ( ) ) { if ( collection type == list . class ) { if ( length > num ) { return new array list < > ( length ) ; } else { return new array list < > ( ) ; } } if ( collection type == set . class ) { if ( length > num ) { return new hash set < > ( length ) ; } else { return new hash set < > ( ) ; } } throw new type conversion exception ( str + collection type . get name ( ) ) ; } if ( length > num ) { try { constructor < collection < t > > ctor = ( constructor < collection < t > > ) collection type . get constructor ( int . class ) ; return ctor . new instance ( integer . value of ( length ) ) ; } catch ( exception ex ) {	Creates new collection of target component type.Default implementation uses reflection to createan collection of target type.
protected collection < t > convert to single element collection ( final object value ) { collection < t > collection = create collection ( num ) ;	Creates a collection with single element.
protected collection < t > convert value to collection ( object value ) { if ( value instanceof iterable ) { iterable iterable = ( iterable ) value ; collection < t > collection = create collection ( num ) ; for ( object element : iterable ) { collection . add ( convert type ( element ) ) ; } return collection ; } if ( value instanceof char sequence ) { value = csv util . to string array ( value . to string ( ) ) ; } class type = value . get class ( ) ; if ( type . is array ( ) ) {	Converts non-collection value to collection.
protected collection < t > convert collection to collection ( final collection value ) { collection < t > collection = create collection ( value . size ( ) ) ; for ( object v : value ) { collection . add ( convert type ( v ) ) ; } return collection ; }	Converts collection value to target collection.Each element is converted to target component type.
final void add line number ( final int line number ) { if ( this . line number == num ) { this . line number = ( short ) line number ; } else { if ( other line numbers == null ) { other line numbers = new int [ line numbers capacity increment ] ; } int other line number index = ++ other line numbers [ num ] ; if ( other line number index >= other line numbers . length ) { int [ ] new line numbers = new int [ other line numbers . length + line numbers capacity increment ] ; system . arraycopy ( other line numbers , num , new line numbers , num , other line numbers . length ) ; other line numbers = new line numbers ; } other line numbers [ other line number index ] = line number ; } }	Adds a source line number corresponding to this label.
final void accept ( final method visitor method visitor , final boolean visit line numbers ) { method visitor . visit label ( this ) ; if ( visit line numbers && line number != num ) { method visitor . visit line number ( line number & num , this ) ; if ( other line numbers != null ) { for ( int i = num ; i <= other line numbers [ num ] ; ++ i ) { method visitor . visit line number ( other line numbers [ i ] , this ) ; } } } }	Makes the given visitor visit this label and its source line numbers, if applicable.
final void put ( final byte vector code , final int source insn bytecode offset , final boolean wide reference ) { if ( ( flags & flag resolved ) == num ) { if ( wide reference ) { add forward reference ( source insn bytecode offset , forward reference type wide , code . length ) ; code . put int ( - num ) ; } else { add forward reference ( source insn bytecode offset , forward reference type short , code . length ) ; code . put short ( - num ) ; } } else { if ( wide reference ) { code . put int ( bytecode offset - source insn bytecode offset ) ; } else { code . put short ( bytecode offset - source insn bytecode offset ) ; } } }	Puts a reference to this label in the bytecode of a method.
private void add forward reference ( final int source insn bytecode offset , final int reference type , final int reference handle ) { if ( forward references == null ) { forward references = new int [ forward references capacity increment ] ; } int last element index = forward references [ num ] ; if ( last element index + num >= forward references . length ) { int [ ] new values = new int [ forward references . length + forward references capacity increment ] ; system . arraycopy ( forward references , num , new values , num , forward references . length ) ; forward references = new values ; } forward references [ ++ last element index ] = source insn bytecode offset ; forward references [ ++ last element index ] = reference type | reference handle ; forward references [ num ] = last element index ; }	Adds a forward reference to this label.
final void mark subroutine ( final short subroutine id ) {	Finds the basic blocks that belong to the subroutine starting with the basic blockcorresponding to this label, and marks these blocks as belonging to this subroutine.
protected int [ ] compare digits ( final string str1 , int ndx1 , final string str2 , int ndx2 ) {	Compare digits at certain position in two strings.The longest run of digits wins.
private char fix accent ( final char c ) { for ( int i = num ; i < accent chars . length ; i += num ) { final char accent char = accent chars [ i ] ; if ( accent char == c ) { return accent chars [ i + num ] ; } } return c ; }	Fixes accent char.
public byte vector put byte ( final int byte value ) { int current length = length ; if ( current length + num > data . length ) { enlarge ( num ) ; } data [ current length ++ ] = ( byte ) byte value ; length = current length ; return this ; }	Puts a byte into this byte vector.
final byte vector put11 ( final int byte value1 , final int byte value2 ) { int current length = length ; if ( current length + num > data . length ) { enlarge ( num ) ; } byte [ ] current data = data ; current data [ current length ++ ] = ( byte ) byte value1 ; current data [ current length ++ ] = ( byte ) byte value2 ; length = current length ; return this ; }	Puts two bytes into this byte vector.
public byte vector put short ( final int short value ) { int current length = length ; if ( current length + num > data . length ) { enlarge ( num ) ; } byte [ ] current data = data ; current data [ current length ++ ] = ( byte ) ( short value > > > num ) ; current data [ current length ++ ] = ( byte ) short value ; length = current length ; return this ; }	Puts a short into this byte vector.
final byte vector put12 ( final int byte value , final int short value ) { int current length = length ; if ( current length + num > data . length ) { enlarge ( num ) ; } byte [ ] current data = data ; current data [ current length ++ ] = ( byte ) byte value ; current data [ current length ++ ] = ( byte ) ( short value > > > num ) ; current data [ current length ++ ] = ( byte ) short value ; length = current length ; return this ; }	Puts a byte and a short into this byte vector.
final byte vector put112 ( final int byte value1 , final int byte value2 , final int short value ) { int current length = length ; if ( current length + num > data . length ) { enlarge ( num ) ; } byte [ ] current data = data ; current data [ current length ++ ] = ( byte ) byte value1 ; current data [ current length ++ ] = ( byte ) byte value2 ; current data [ current length ++ ] = ( byte ) ( short value > > > num ) ; current data [ current length ++ ] = ( byte ) short value ; length = current length ; return this ; }	Puts two bytes and a short into this byte vector.
public byte vector put int ( final int int value ) { int current length = length ; if ( current length + num > data . length ) { enlarge ( num ) ; } byte [ ] current data = data ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) int value ; length = current length ; return this ; }	Puts an int into this byte vector.
final byte vector put122 ( final int byte value , final int short value1 , final int short value2 ) { int current length = length ; if ( current length + num > data . length ) { enlarge ( num ) ; } byte [ ] current data = data ; current data [ current length ++ ] = ( byte ) byte value ; current data [ current length ++ ] = ( byte ) ( short value1 > > > num ) ; current data [ current length ++ ] = ( byte ) short value1 ; current data [ current length ++ ] = ( byte ) ( short value2 > > > num ) ; current data [ current length ++ ] = ( byte ) short value2 ; length = current length ; return this ; }	Puts one byte and two shorts into this byte vector.
public byte vector put long ( final long long value ) { int current length = length ; if ( current length + num > data . length ) { enlarge ( num ) ; } byte [ ] current data = data ; int int value = ( int ) ( long value > > > num ) ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) int value ; int value = ( int ) long value ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) ( int value > > > num ) ; current data [ current length ++ ] = ( byte ) int value ; length = current length ; return this ; }	Puts a long into this byte vector.
public byte vector put byte array ( final byte [ ] byte array value , final int byte offset , final int byte length ) { if ( length + byte length > data . length ) { enlarge ( byte length ) ; } if ( byte array value != null ) { system . arraycopy ( byte array value , byte offset , data , length , byte length ) ; } length += byte length ; return this ; }	Puts an array of bytes into this byte vector.
private void enlarge ( final int size ) { int double capacity = num * data . length ; int minimal capacity = length + size ; byte [ ] new data = new byte [ double capacity > minimal capacity ? double capacity : minimal capacity ] ; system . arraycopy ( data , num , new data , num , length ) ; data = new data ; }	Enlarges this byte vector so that it can receive 'size' more bytes.
protected t authenticate user via http session ( final action request action request ) { final http servlet request servlet request = action request . get http servlet request ( ) ; final user session < t > user session = user session . get ( servlet request ) ; if ( user session == null ) { return null ; } final t auth token = user session . get auth token ( ) ; if ( auth token == null ) { return null ; }	Tries to authenticate user via HTTP session.
protected t authenticate user via token ( final action request action request ) { final http servlet request servlet request = action request . get http servlet request ( ) ;	Tries to authenticate user via token.
protected t authenticate user via basic auth ( final action request action request ) { final http servlet request servlet request = action request . get http servlet request ( ) ; final string username = servlet util . resolve auth username ( servlet request ) ; if ( username == null ) { return null ; } final string password = servlet util . resolve auth password ( servlet request ) ; final t auth token = user auth ( ) . login ( username , password ) ; if ( auth token == null ) { return null ; } return auth token ; }	Tires to authenticate user via the basic authentication.
public string find default message ( final locale locale , final string key ) { string indexed key = calc index key ( key ) ; string msg = get message ( fallback bundlename , locale , key , indexed key ) ; if ( msg != null ) { return msg ; } for ( string bname : default bundles ) { msg = get message ( bname , locale , key , indexed key ) ; if ( msg != null ) { return msg ; } } return null ; }	Finds message in default bundles only, starting from fallback bundlename.
protected resource bundle get bundle ( final string bundle name , final locale locale , final class loader class loader ) { return resource bundle . get bundle ( bundle name , locale , class loader ) ; }	Returns specified bundle. Invoked every time if cache is disabled.Input arguments are always valid.
protected k get ( final k [ ] array , final int index ) { return ( k ) array . get ( array , index ) ; }	Returns array's element at given index.
protected < e , id > void set entity id ( final db entity descriptor < e > ded , final e entity , final id new id value ) { ded . set id value ( entity , new id value ) ; }	Sets new ID value for entity.
public void save ( final object entity ) { final db query q = query ( db oom . entities ( ) . insert ( entity ) ) ; q . auto close ( ) . execute update ( ) ; }	Simply inserts object into the database.
public void update ( final object entity ) { query ( db oom . entities ( ) . update all ( entity ) ) . auto close ( ) . execute update ( ) ; }	Updates single entity.
public < e > e update property ( final e entity , final string name , final object new value ) { query ( db oom . entities ( ) . update column ( entity , name , new value ) ) . auto close ( ) . execute update ( ) ; bean util . declared . set property ( entity , name , new value ) ; return entity ; }	Updates single property in database and in the bean.
public < e > e update property ( final e entity , final string name ) { object value = bean util . declared . get property ( entity , name ) ; query ( db oom . entities ( ) . update column ( entity , name , value ) ) . auto close ( ) . execute update ( ) ; return entity ; }	Updates property in the database by storing the current property value.
public < e , id > e find by id ( final class < e > entity type , final id id ) { return query ( db oom . entities ( ) . find by id ( entity type , id ) ) . auto close ( ) . find ( entity type ) ; }	Finds single entity by its id.
public < e > e find one by property ( final class < e > entity type , final string name , final object value ) { return query ( db oom . entities ( ) . find by column ( entity type , name , value ) ) . auto close ( ) . find ( entity type ) ; }	Finds single entity by matching property.
@ suppress warnings ( { str } ) public < e > e find one ( final object criteria ) { return ( e ) query ( db oom . entities ( ) . find ( criteria ) ) . auto close ( ) . find ( criteria . get class ( ) ) ; }	Finds one entity for given criteria.
public < id > void delete by id ( final class entity type , final id id ) { query ( db oom . entities ( ) . delete by id ( entity type , id ) ) . auto close ( ) . execute update ( ) ; }	Deleted single entity by its id.
public void delete by id ( final object entity ) { if ( entity != null ) { int result = query ( db oom . entities ( ) . delete by id ( entity ) ) . auto close ( ) . execute update ( ) ; if ( result != num ) {	Delete single object by its id.
public long count ( final class entity type ) { return query ( db oom . entities ( ) . count ( entity type ) ) . auto close ( ) . execute count ( ) ; }	Counts number of all entities.
public < id > void increase property ( final class entity type , final id id , final string name , final number delta ) { query ( db oom . entities ( ) . increase column ( entity type , id , name , delta , bool ) ) . auto close ( ) . execute update ( ) ; }	Increases a property.
public < id > void decrease property ( final class entity type , final id id , final string name , final number delta ) { query ( db oom . entities ( ) . increase column ( entity type , id , name , delta , bool ) ) . auto close ( ) . execute update ( ) ; }	Decreases a property.
public < e > list < e > find related ( final class < e > target , final object source ) { return query ( db oom . entities ( ) . find foreign ( target , source ) ) . auto close ( ) . list ( target ) ; }	Finds related entity.
public < e > list < e > list all ( final class < e > target ) { return query ( db oom . entities ( ) . from ( target ) ) . auto close ( ) . list ( target ) ; }	List all entities.
@ override public void clear ( ) { entries = null ; iterator < string > keys = get attribute names ( ) ; while ( keys . has next ( ) ) { remove attribute ( keys . next ( ) ) ; } }	Removes all attributes from the request as well as clears entries in this map.
@ override public set < entry < string , object > > entry set ( ) { if ( entries == null ) { entries = new hash set < > ( ) ; iterator < string > iterator = get attribute names ( ) ; while ( iterator . has next ( ) ) { final string key = iterator . next ( ) ; final object value = get attribute ( key ) ; entries . add ( new entry < string , object > ( ) { @ override public boolean equals ( final object obj ) { if ( obj == null ) { return bool ; } if ( this . get class ( ) != obj . get class ( ) ) { return bool ; } entry entry = ( entry ) obj ; return ( ( key == null ) ? ( entry . get key ( ) == null ) : key . equals ( entry . get key ( ) ) ) && ( ( value == null ) ? ( entry . get value ( ) == null ) : value . equals ( entry . get value ( ) ) ) ; } @ override public int hash code ( ) { return ( ( key == null ) ? num : key . hash code ( ) ) ^ ( ( value == null ) ? num : value . hash code ( ) ) ; } @ override public string get key ( ) { return key ; } @ override public object get value ( ) { return value ; } @ override public object set value ( final object obj ) { set attribute ( key , obj ) ; return value ; } } ) ; } } return entries ; }	Returns a Set of attributes from the http request.
@ override public object put ( final string key , final object value ) { entries = null ; object previous = get ( key ) ; set attribute ( key , value ) ; return previous ; }	Saves an attribute in the request.
@ override public object remove ( final object key ) { entries = null ; object value = get ( key ) ; remove attribute ( key . to string ( ) ) ; return value ; }	Removes the specified request attribute.
@ suppress warnings ( { str } ) public static stack trace element [ ] get current stack trace ( ) { stack trace element [ ] ste = new exception ( ) . get stack trace ( ) ; if ( ste . length > num ) { stack trace element [ ] result = new stack trace element [ ste . length - num ] ; system . arraycopy ( ste , num , result , num , ste . length - num ) ; return result ; } else { return ste ; } }	Returns current stack trace in form of array of stack trace elements.First stack trace element is removed.Since an exception is thrown internally, this method is slow.
public static stack trace element [ ] get stack trace ( final throwable t , final string [ ] allow , final string [ ] deny ) { stack trace element [ ] st = t . get stack trace ( ) ; array list < stack trace element > result = new array list < > ( st . length ) ; element loop : for ( stack trace element element : st ) { string class name = element . get class name ( ) ; if ( allow != null ) { boolean valid elemenet = bool ; for ( string filter : allow ) { if ( class name . contains ( filter ) ) { valid elemenet = bool ; break ; } } if ( ! valid elemenet ) { continue ; } } if ( deny != null ) { for ( string filter : deny ) { if ( class name . contains ( filter ) ) { continue element loop ; } } } result . add ( element ) ; } st = new stack trace element [ result . size ( ) ] ; return result . to array ( st ) ; }	Returns stack trace filtered by class names.
public static stack trace element [ ] [ ] get stack trace chain ( throwable t , final string [ ] allow , final string [ ] deny ) { array list < stack trace element [ ] > result = new array list < > ( ) ; while ( t != null ) { stack trace element [ ] stack = get stack trace ( t , allow , deny ) ; result . add ( stack ) ; t = t . get cause ( ) ; } stack trace element [ ] [ ] all stacks = new stack trace element [ result . size ( ) ] [ ] ; for ( int i = num ; i < all stacks . length ; i ++ ) { all stacks [ i ] = result . get ( i ) ; } return all stacks ; }	Returns stack trace chain filtered by class names.
public static throwable [ ] get exception chain ( throwable throwable ) { array list < throwable > list = new array list < > ( ) ; list . add ( throwable ) ; while ( ( throwable = throwable . get cause ( ) ) != null ) { list . add ( throwable ) ; } throwable [ ] result = new throwable [ list . size ( ) ] ; return list . to array ( result ) ; }	Returns exception chain starting from top up to root cause.
public static string exception stack trace to string ( final throwable t ) { string writer sw = new string writer ( ) ; print writer pw = new print writer ( sw , bool ) ; t . print stack trace ( pw ) ; stream util . close ( pw ) ; stream util . close ( sw ) ; return sw . to string ( ) ; }	Prints stack trace into a String.
public static string exception chain to string ( throwable t ) { string writer sw = new string writer ( ) ; print writer pw = new print writer ( sw , bool ) ; while ( t != null ) { t . print stack trace ( pw ) ; t = t . get cause ( ) ; } stream util . close ( pw ) ; stream util . close ( sw ) ; return sw . to string ( ) ; }	Prints full exception stack trace, from top to root cause, into a String.
public static string build message ( final string message , throwable cause ) { if ( cause != null ) { cause = get root cause ( cause ) ; string builder buf = new string builder ( ) ; if ( message != null ) { buf . append ( message ) . append ( str ) ; } buf . append ( str ) . append ( cause ) ; return buf . to string ( ) ; } else { return message ; } }	Build a message for the given base message and its cause.
public static throwable unwrap throwable ( final throwable wrapped throwable ) { throwable unwrapped = wrapped throwable ; while ( bool ) { if ( unwrapped instanceof invocation target exception ) { unwrapped = ( ( invocation target exception ) unwrapped ) . get target exception ( ) ; } else if ( unwrapped instanceof undeclared throwable exception ) { unwrapped = ( ( undeclared throwable exception ) unwrapped ) . get undeclared throwable ( ) ; } else { return unwrapped ; } } }	Unwraps invocation and undeclared exceptions to real cause.
protected void register as consumer ( final class scanner class scanner ) { class scanner . register entry consumer ( class path entry -> { final string entry name = class path entry . name ( ) ; if ( entry name . ends with ( action class suffix ) ) { try { accept action class ( class path entry . load class ( ) ) ; } catch ( exception ex ) { log . debug ( str + entry name ) ; } } else if ( class path entry . is type signature in use ( madvoc component annotation ) ) { try { accept madvoc component class ( class path entry . load class ( ) ) ; } catch ( exception ex ) { log . debug ( str + entry name ) ; } } } ) ; }	Parses class name that matches madvoc-related names.
protected void accept madvoc component class ( final class component class ) { if ( component class == null ) { return ; } if ( ! check class ( component class ) ) { return ; } madvoc components . add ( ( ) -> madvoc container . register component ( component class ) ) ; }	Registers new Madvoc component.
public static class loader get system class loader ( ) { if ( system . get security manager ( ) == null ) { return class loader . get system class loader ( ) ; } else { return access controller . do privileged ( ( privileged action < class loader > ) class loader :: get system class loader ) ; } }	Returns system class loader.
public static input stream get resource as stream ( final string resource name , final class loader calling class ) throws io { url url = get resource url ( resource name , calling class ) ; if ( url != null ) { return url . open stream ( ) ; } return null ; }	Opens a resource of the specified name for reading.
public static input stream get resource as stream ( final string resource name , final class loader calling class , final boolean use cache ) throws io { url url = get resource url ( resource name , calling class ) ; if ( url != null ) { url url connection = url . open connection ( ) ; url connection . set use caches ( use cache ) ; return url connection . get input stream ( ) ; } return null ; }	Opens a resource of the specified name for reading.
public static input stream get class as stream ( final class clazz ) throws io { return get resource as stream ( class util . convert class name to file name ( clazz ) , clazz . get class loader ( ) ) ; }	Opens a class of the specified name for reading using class classloader.
public static input stream get class as stream ( final string class name , final class loader class loader ) throws io { return get resource as stream ( class util . convert class name to file name ( class name ) , class loader ) ; }	Opens a class of the specified name for reading using provided class loader.
public route chunk add ( final string new value ) { route chunk route chunk = new route chunk ( routes , this , new value ) ; if ( children == null ) { children = new route chunk [ ] { route chunk } ; } else { children = arrays util . append ( children , route chunk ) ; } return route chunk ; }	Adds a new child to the tree.
public route chunk find or create child ( final string value ) { if ( children != null ) { for ( route chunk child : children ) { if ( child . get ( ) . equals ( value ) ) { return child ; } } } return add ( value ) ; }	Finds existing chunk or creates a new one if does not exist.
public void parse request ( ) throws io { if ( servlet util . is multipart request ( request ) ) { parse request stream ( request . get input stream ( ) , character encoding ) ; } else { enumeration names = request . get parameter names ( ) ; while ( names . has more elements ( ) ) { string param name = ( string ) names . next element ( ) ; string [ ] values = request . get parameter values ( param name ) ; put parameters ( param name , values ) ; } } }	Checks if request if multi-part and parse it.
@ suppress warnings ( str ) protected object convert to collection ( final object value , final class destination type , final class component type ) { return type converter manager . convert to collection ( value , destination type , component type ) ; }	Converter to collection.
protected object invoke setter ( final setter setter , final bean property bp , object value ) { try { final mapper function setter mapper function = setter . get mapper function ( ) ; if ( setter mapper function != null ) { value = setter mapper function . apply ( value ) ; } final class type = setter . get setter raw type ( ) ; if ( class util . is type of ( type , collection . class ) ) { class component type = setter . get setter raw component type ( ) ; value = convert to collection ( value , type , component type ) ; } else {	Invokes setter, but first converts type to match the setter type.
protected void array forced set ( final bean property bp , object array , final int index , object value ) { class component type = array . get class ( ) . get component type ( ) ; array = ensure array size ( bp , array , component type , index ) ; value = convert type ( value , component type ) ; array . set ( array , index , value ) ; }	Sets the array element forced.
protected object create bean property ( final bean property bp ) { setter setter = bp . get setter ( bool ) ; if ( setter == null ) { return null ; } class type = setter . get setter raw type ( ) ; object new instance ; try { new instance = class util . new instance ( type ) ; } catch ( exception ex ) { if ( is silent ) { return null ; } throw new bean exception ( str + bp . name , bp , ex ) ; } new instance = invoke setter ( setter , bp , new instance ) ; return new instance ; }	Creates new instance for current property name through its setter.It uses default constructor!.
protected class extract type ( final bean property bp ) { getter getter = bp . get getter ( is declared ) ; if ( getter != null ) { if ( bp . index != null ) { class type = getter . get getter raw component type ( ) ; return type == null ? object . class : type ; } return getter . get getter raw type ( ) ; } return null ;	Extracts type of current property.
public static void stop ( final http servlet request servlet request , final http servlet response servlet response ) { final http session http session = servlet request . get session ( bool ) ; if ( http session != null ) { http session . remove attribute ( auth session name ) ; } final cookie cookie = servlet util . get cookie ( servlet request , auth cookie name ) ; if ( cookie == null ) { return ; } cookie . set max age ( num ) ; cookie . set path ( str ) ; servlet response . add cookie ( cookie ) ; }	Stops the user session by removing it from the http session and invalidating the cookie.
public void start ( final http servlet request http servlet request , final http servlet response http servlet response ) { final http session http session = http servlet request . get session ( bool ) ; http session . set attribute ( auth session name , this ) ; final cookie cookie = new cookie ( auth cookie name , auth token value ) ;	Starts new user session.
public static date to date ( final local date local date ) { return date . from ( local date . at start of day ( zone id . system default ( ) ) . to instant ( ) ) ; }	Converts local date to Date.
public static calendar to calendar ( final local date time local date time ) { return gregorian calendar . from ( zoned date time . of ( local date time , zone id . system default ( ) ) ) ; }	Converts local date time to Calendar.
public class define proxy ( final class target ) { proxy proxetta factory builder = proxetta . proxy ( ) ; builder . set target ( target ) ; return builder . define ( ) ; }	Generates new class.
public void add ( final check check ) { string name = check . get name ( ) ; list < check > list = map . compute if absent ( name , k -> new array list < > ( ) ) ; list . add ( check ) ; }	Adds validation checks.
public static validation context resolve for ( final class < ? > target ) { validation context vc = new validation context ( ) ; vc . add class checks ( target ) ; return vc ; }	Resolve validation context for provided target class.
public void add class checks ( final class target ) { final list < check > list = cache . get ( target , ( ) -> { final list < check > new list = new array list < > ( ) ; final class descriptor cd = class introspector . get ( ) . lookup ( target ) ; final property descriptor [ ] all properties = cd . get all property descriptors ( ) ; for ( property descriptor property descriptor : all properties ) { collect property annotation checks ( new list , property descriptor ) ; } return new list ; } ) ; add all ( list ) ; }	Parses class annotations and adds all checks.
protected void collect property annotation checks ( final list < check > ann checks , final property descriptor property descriptor ) { field descriptor fd = property descriptor . get field descriptor ( ) ; if ( fd != null ) { annotation [ ] annotations = fd . get field ( ) . get annotations ( ) ; collect annotation checks ( ann checks , property descriptor . get type ( ) , property descriptor . get name ( ) , annotations ) ; } method descriptor md = property descriptor . get read method descriptor ( ) ; if ( md != null ) { annotation [ ] annotations = md . get method ( ) . get annotations ( ) ; collect annotation checks ( ann checks , property descriptor . get type ( ) , property descriptor . get name ( ) , annotations ) ; } md = property descriptor . get write method descriptor ( ) ; if ( md != null ) { annotation [ ] annotations = md . get method ( ) . get annotations ( ) ; collect annotation checks ( ann checks , property descriptor . get type ( ) , property descriptor . get name ( ) , annotations ) ; } }	Process all annotations of provided properties.
@ suppress warnings ( { str } ) protected void collect annotation checks ( final list < check > ann checks , final class target type , final string target name , final annotation [ ] annotations ) { for ( annotation annotation : annotations ) { constraint c = annotation . annotation type ( ) . get annotation ( constraint . class ) ; class < ? extends validation constraint > constraint class ; if ( c == null ) {	Collect annotations for some target.
protected void copy default check properties ( final check dest check , final annotation annotation ) { integer severity = ( integer ) class util . read annotation value ( annotation , ann severity ) ; dest check . set severity ( severity . int value ( ) ) ; string [ ] profiles = ( string [ ] ) class util . read annotation value ( annotation , ann profiles ) ; dest check . set profiles ( profiles ) ; string message = ( string ) class util . read annotation value ( annotation , ann message ) ; dest check . set message ( message ) ; }	Copies default properties from annotation to the check.
private static string encode uri component ( final string source , final string encoding , final uri uri part ) { if ( source == null ) { return null ; } byte [ ] bytes = encode bytes ( string util . get bytes ( source , encoding ) , uri part ) ; char [ ] chars = new char [ bytes . length ] ; for ( int i = num ; i < bytes . length ; i ++ ) { chars [ i ] = ( char ) bytes [ i ] ; } return new string ( chars ) ; }	Encodes single URI component.
public static string encode ( final string string , final string encoding ) { return encode uri component ( string , encoding , uri . unreserved ) ; }	Encodes string using default RFCP rules.
public static string encode scheme ( final string scheme , final string encoding ) { return encode uri component ( scheme , encoding , uri . scheme ) ; }	Encodes the given URI scheme with the given encoding.
public static string encode host ( final string host , final string encoding ) { return encode uri component ( host , encoding , uri . host ) ; }	Encodes the given URI host with the given encoding.
public static string encode port ( final string port , final string encoding ) { return encode uri component ( port , encoding , uri . port ) ; }	Encodes the given URI port with the given encoding.
public static string encode path ( final string path , final string encoding ) { return encode uri component ( path , encoding , uri . path ) ; }	Encodes the given URI path with the given encoding.
public static string encode query ( final string query , final string encoding ) { return encode uri component ( query , encoding , uri . query ) ; }	Encodes the given URI query with the given encoding.
public static string encode query param ( final string query param , final string encoding ) { return encode uri component ( query param , encoding , uri . query param ) ; }	Encodes the given URI query parameter with the given encoding.
public static string encode fragment ( final string fragment , final string encoding ) { return encode uri component ( fragment , encoding , uri . fragment ) ; }	Encodes the given URI fragment with the given encoding.
protected hash map < string , property descriptor > inspect properties ( ) { boolean scan accessible = class descriptor . is scan accessible ( ) ; class type = class descriptor . get type ( ) ; hash map < string , property descriptor > map = new hash map < > ( ) ; method [ ] methods = scan accessible ? class util . get accessible methods ( type ) : class util . get supported methods ( type ) ; for ( int iteration = num ; iteration < num ; iteration ++ ) {	Inspects all properties of target type.
public property descriptor [ ] get all property descriptors ( ) { if ( all properties == null ) { property descriptor [ ] all properties = new property descriptor [ property descriptors . size ( ) ] ; int index = num ; for ( property descriptor property descriptor : property descriptors . values ( ) ) { all properties [ index ] = property descriptor ; index ++ ; } arrays . sort ( all properties , new comparator < property descriptor > ( ) { @ override public int compare ( final property descriptor pd1 , final property descriptor pd2 ) { return pd1 . get name ( ) . compare to ( pd2 . get name ( ) ) ; } } ) ; this . all properties = all properties ; } return all properties ; }	Returns all property descriptors.Properties are sorted by name.
public cookie [ ] cookies ( ) { list < string > new cookies = headers ( str ) ; if ( new cookies == null ) { return new cookie [ num ] ; } list < cookie > cookie list = new array list < > ( new cookies . size ( ) ) ; for ( string cookie value : new cookies ) { try { cookie cookie = new cookie ( cookie value ) ; cookie list . add ( cookie ) ; } catch ( exception ex ) {	Returns list of valid cookies sent from server.If no cookie found, returns an empty array.
public http response unzip ( ) { string content encoding = content encoding ( ) ; if ( content encoding != null && content encoding ( ) . equals ( str ) ) { if ( body != null ) { header remove ( header content encoding ) ; try { byte array input stream in = new byte array input stream ( body . get bytes ( string pool . iso 8859 1 ) ) ; gzip gzip input stream = new gzip ( in ) ; byte array output stream out = new byte array output stream ( ) ; stream util . copy ( gzip input stream , out ) ; body ( out . to string ( string pool . iso 8859 1 ) ) ; } catch ( io ioex ) { throw new http exception ( ioex ) ; } } } return this ; }	Unzips GZip-ed body content, removes the content-encoding headerand sets the new content-length value.
public http response close ( ) { http connection http connection = http request . http connection ; if ( http connection != null ) { http connection . close ( ) ; http request . http connection = null ; } return this ; }	Closes requests connection if it was open.Should be called when using keep-alive connections.Otherwise, connection will be already closed.
@ override public boolean accept ( final scope reference scope ) { class < ? extends scope > ref scope type = reference scope . get class ( ) ; if ( ref scope type == proto scope . class ) { return bool ; } if ( ref scope type == singleton scope . class ) { return bool ; } if ( ref scope type == thread local scope . class ) { return bool ; } return bool ; }	Defines allowed referenced scopes that can be injected into thethread-local scoped bean.
public byte [ ] encrypt ( final byte [ ] content ) { fast byte buffer fbb = new fast byte buffer ( ) ; int length = content . length + num ; int block count = length / block size in bytes ; int remaining = length ; int offset = num ; for ( int i = num ; i < block count ; i ++ ) { if ( remaining == block size in bytes ) { break ; } byte [ ] encrypted = encrypt block ( content , offset ) ; fbb . append ( encrypted ) ; offset += block size in bytes ; remaining -= block size in bytes ; } if ( remaining != num ) {	Encrypts complete content, block by block.
public byte [ ] decrypt ( final byte [ ] encrypted content ) { fast byte buffer fbb = new fast byte buffer ( ) ; int length = encrypted content . length ; int block count = length / block size in bytes ; int offset = num ; for ( int i = num ; i < block count - num ; i ++ ) { byte [ ] decrypted = decrypt block ( encrypted content , offset ) ; fbb . append ( decrypted ) ; offset += block size in bytes ; }	Decrypts the whole content, block by block.
public object map2bean ( final map map , class target type ) { object target = null ;	Converts map to target type.
private object generify list ( final list list , final class component type ) { for ( int i = num ; i < list . size ( ) ; i ++ ) { object element = list . get ( i ) ; if ( element != null ) { if ( element instanceof map ) { object bean = map2bean ( ( map ) element , component type ) ; list . set ( i , bean ) ; } else { object value = convert ( element , component type ) ; list . set ( i , value ) ; } } } return list ; }	Converts type of all list elements to match the component type.
private void set value ( final object target , final property descriptor pd , object value ) throws invocation target exception , illegal access exception { class property type ; setter setter = pd . get setter ( bool ) ; if ( setter != null ) { if ( value != null ) { property type = setter . get setter raw type ( ) ; value = json parser . convert type ( value , property type ) ; } setter . invoke setter ( target , value ) ; } }	Sets the property value.
protected < k , v > map < k , v > generify map ( final map < object , object > map , final class < k > key type , final class < v > value type ) { if ( key type == string . class ) {	Change map elements to match key and value types.
@ override public int compare to ( final object o ) { db entity column descriptor that = ( db entity column descriptor ) o ; if ( this . is id != that . is id ) { return this . is id ? - num : num ;	Compares two column descriptors.
public http browser set default header ( final string name , final string value ) { default headers . add header ( name , value ) ; return this ; }	Adds default header to all requests.
public http response send request ( http request http request ) { elapsed time = system . current time millis ( ) ;	Sends new request as a browser.
protected http response send request ( final http request http request , final http response previouse response ) { if ( ! keep alive ) { http request . open ( http connection provider ) ; } else {	Opens connection and sends a response.
protected void add default headers ( final http request http request ) { for ( map . entry < string , string > entry : default headers . entries ( ) ) { string name = entry . get key ( ) ; if ( ! http request . headers . contains ( name ) ) { http request . headers . add ( name , entry . get value ( ) ) ; } } }	Add default headers to the request.
protected void read cookies ( final http response http response ) { cookie [ ] new cookies = http response . cookies ( ) ; for ( cookie cookie : new cookies ) { cookies . add ( cookie . get name ( ) , cookie ) ; } }	Reads cookies from response and adds to cookies list.
protected void add cookies ( final http request http request ) {	Add cookies to the request.
public string send mail ( final email email ) { try { final mime message msg = create message ( email ) ; get service ( ) . send message ( msg , msg . get all recipients ( ) ) ; return msg . get message id ( ) ; } catch ( final messaging exception msgexc ) { throw new mail exception ( str + email , msgexc ) ; } }	Prepares message and sends it.
private void set subject ( final email email with data , final mime message msg to set ) throws messaging exception { if ( email with data . subject encoding ( ) != null ) { msg to set . set subject ( email with data . subject ( ) , email with data . subject encoding ( ) ) ; } else { msg to set . set subject ( email with data . subject ( ) ) ; } }	Sets subject in msgToSet from subject in emailWithData.
private void set sent date ( final email email with data , final mime message msg to set ) throws messaging exception { date date = email with data . sent date ( ) ; if ( date == null ) { date = new date ( ) ; } msg to set . set sent date ( date ) ; }	Sets sent date in msgToSet with sent date from emailWithData.
private void set headers ( final email email with data , final mime message msg to set ) throws messaging exception { final map < string , string > headers = email with data . headers ( ) ; if ( headers != null ) { for ( final map . entry < string , string > entry : headers . entry set ( ) ) { msg to set . set header ( entry . get key ( ) , entry . get value ( ) ) ; } } }	Sets headers in msgToSet with headers from emailWithData.
private void set people ( final email email with data , final mime message msg to set ) throws messaging exception { msg to set . set from ( email with data . from ( ) . to internet address ( ) ) ; msg to set . set reply to ( email address . convert ( email with data . reply to ( ) ) ) ; set recipients ( email with data , msg to set ) ; }	Sets FROM, REPLY-TO and recipients.
private void set recipients ( final email email with data , final mime message msg to set ) throws messaging exception {	Sets TO, CC and BCC in msgToSet with TO, CC and BCC from emailWithData.
private void add body data ( final email email with data , final mime message msg to set ) throws messaging exception { final list < email message > messages = email with data . messages ( ) ; final int total messages = messages . size ( ) ;	Adds message data and attachments.
private void set content ( final email message email with data , final part part to set ) throws messaging exception { part to set . set content ( email with data . get content ( ) , email with data . get mime type ( ) + charset + email with data . get encoding ( ) ) ; }	Sets emailWithData content into msgToSet.
protected mime body part create attachment body part ( final email attachment < ? extends data source > attachment ) throws messaging exception { final mime body part part = new mime body part ( ) ; final string attachment name = attachment . get encoded name ( ) ; if ( attachment name != null ) { part . set file name ( attachment name ) ; } part . set data handler ( new data handler ( attachment . get data source ( ) ) ) ; if ( attachment . get content id ( ) != null ) { part . set content id ( string pool . left chev + attachment . get content id ( ) + string pool . right chev ) ; } if ( attachment . is inline ( ) ) { part . set disposition ( inline ) ; } return part ; }	Creates attachment body part.
private string get content type ( final string data header ) { string token = str ; int start = data header . index of ( token ) ; if ( start == - num ) { return string pool . empty ; } start += token . length ( ) ; return data header . substring ( start ) . trim ( ) ; }	Strips content type information from requests data header.
protected void save result set ( final result set rs ) { if ( result sets == null ) { result sets = new hash set < > ( ) ; } result sets . add ( rs ) ; }	Stores result set.
public q close all result sets ( ) { final sql sex = close query result sets ( ) ; if ( sex != null ) { throw new db sql exception ( str , sex ) ; } return this ( ) ; }	Closes all result sets created by this query.
protected sql close query ( ) { sql sql exception = close query result sets ( ) ; if ( statement != null ) { try { statement . close ( ) ; } catch ( sql sex ) { if ( sql exception == null ) { sql exception = sex ; } else { sql exception . set next exception ( sex ) ; } } statement = null ; } query = null ; query state = closed ; return sql exception ; }	Closes all assigned result sets and then closes the query.
@ override @ suppress warnings ( { str } ) public void close ( ) { final sql sql exception = close query ( ) ; connection = null ; if ( this . session != null ) { this . session . detach query ( this ) ; } if ( sql exception != null ) { throw new db sql exception ( str , sql exception ) ; } }	Closes the query and all created results sets and detaches itself from the session.
public q set fetch size ( final int rows ) { check not closed ( ) ; this . fetch size = rows ; if ( statement != null ) { try { statement . set fetch size ( fetch size ) ; } catch ( sql sex ) { throw new db sql exception ( this , str + fetch size , sex ) ; } } return this ( ) ; }	Gives the JDBC driver a hint as to the number of rows that should be fetched from the database whenmore rows are needed.
public q set max rows ( final int max rows ) { check not closed ( ) ; this . max rows = max rows ; if ( statement != null ) { try { statement . set max rows ( max rows ) ; } catch ( sql sex ) { throw new db sql exception ( this , str + max rows , sex ) ; } } return this ( ) ; }	Sets the limit for the maximum number of rows that any ResultSet object can contain to the given number.If the limit is exceeded, the excess rows are silently dropped.
protected int execute update ( final boolean close query ) { start = system . current time millis ( ) ; init ( ) ; final int result ; if ( log . is debug enabled ( ) ) { log . debug ( str + get query string ( ) ) ; } try { if ( prepared statement == null ) { if ( generated columns != null ) { if ( generated columns . length == num ) { result = statement . execute update ( query . sql , statement . return generated keys ) ; } else { result = statement . execute update ( query . sql , generated columns ) ; } } else { result = statement . execute update ( query . sql ) ; } } else { result = prepared statement . execute update ( ) ; } } catch ( sql sex ) { throw new db sql exception ( this , str , sex ) ; } if ( close query ) { close ( ) ; } elapsed = system . current time millis ( ) - start ; if ( log . is debug enabled ( ) ) { log . debug ( str + elapsed + str ) ; } return result ; }	Executes UPDATE, INSERT or DELETE queries and optionally closes the query.
protected long execute count ( final boolean close ) { start = system . current time millis ( ) ; init ( ) ; result set rs = null ; if ( log . is debug enabled ( ) ) { log . debug ( str + get query string ( ) ) ; } try { if ( prepared statement == null ) { rs = statement . execute query ( query . sql ) ; } else { rs = prepared statement . execute query ( ) ; } final long first long = db util . get first long ( rs ) ; elapsed = system . current time millis ( ) - start ; if ( log . is debug enabled ( ) ) { log . debug ( str + elapsed + str ) ; } return first long ; } catch ( sql sex ) { throw new db sql exception ( this , str , sex ) ; } finally { db util . close ( rs ) ; if ( close ) { close ( ) ; } } }	Executes count queries and optionally closes query afterwards.
public result set get generated columns ( ) { check initialized ( ) ; if ( generated columns == null ) { throw new db sql exception ( this , str ) ; } final result set rs ; try { rs = statement . get generated keys ( ) ; } catch ( sql sex ) { throw new db sql exception ( this , str , sex ) ; } save result set ( rs ) ; total open result set count ++ ; return rs ; }	Returns generated columns.
public string get query string ( ) { if ( debug ) { if ( ( callable statement != null ) ) { if ( prepared statement instanceof loggable callable statement ) { return ( ( loggable callable statement ) callable statement ) . get query string ( ) ; } } if ( prepared statement != null ) { if ( prepared statement instanceof loggable prepared statement ) { return ( ( loggable prepared statement ) prepared statement ) . get query string ( ) ; } } } if ( query != null ) { return query . sql ; } return sql string ; }	Returns query SQL string.
@ suppress warnings ( str ) public static < t > t proxy of ( final t target , final class < ? extends aspect > aspect class ) { final aspect aspect ; try { aspect = class util . new instance ( aspect class , target ) ; } catch ( exception e ) { throw new illegal argument exception ( str , e ) ; } return ( t ) new proxy instance ( target . get class ( ) . get class loader ( ) , aspect , target . get class ( ) . get interfaces ( ) ) ; }	Creates a proxy of given target and the aspect.
public static < t > collection < t > collection of ( final iterator < ? extends t > iterator ) { final list < t > list = new array list < > ( ) ; while ( iterator . has next ( ) ) { list . add ( iterator . next ( ) ) ; } return list ; }	Returns a collection containing all elements of the iterator.
public static < t > stream < t > stream of ( final iterator < t > iterator ) { return stream support . stream ( ( ( iterable < t > ) ( ) -> iterator ) . spliterator ( ) , bool ) ; }	Converts iterator to a stream.
@ override public int compare ( final t o1 , final t o2 ) { for ( comparator < t > comparator : comparators ) { int result = comparator . compare ( o1 , o2 ) ; if ( result != num ) { return result ; } } return num ; }	Compares two objects starting with first comparator; if they are equalsproceeds to the next comparator and so on.
public petite config set default wiring mode ( final wiring mode default wiring mode ) { if ( ( default wiring mode == null ) || ( default wiring mode == wiring mode . default ) ) { throw new petite exception ( str + default wiring mode ) ; } this . default wiring mode = default wiring mode ; return this ; }	Specifies default wiring mode.
protected void print ( final level level , final string message , final throwable throwable ) { if ( ! is enabled ( level ) ) { return ; } string builder msg = new string builder ( ) . append ( slf . get elapsed time ( ) ) . append ( str ) . append ( str ) . append ( level ) . append ( str ) . append ( str ) . append ( get caller class ( ) ) . append ( str ) . append ( str ) . append ( str ) . append ( message ) ; system . out . println ( msg . to string ( ) ) ; if ( throwable != null ) { throwable . print stack trace ( system . out ) ; } }	Prints error message if level is enabled.
protected string get caller class ( ) { exception exception = new exception ( ) ; stack trace element [ ] stack trace = exception . get stack trace ( ) ; for ( stack trace element stack trace element : stack trace ) { string class name = stack trace element . get class name ( ) ; if ( class name . equals ( simple logger provider . class . get name ( ) ) ) { continue ; } if ( class name . equals ( simple logger . class . get name ( ) ) ) { continue ; } if ( class name . equals ( logger . class . get name ( ) ) ) { continue ; } return shorten class name ( class name ) + str + stack trace element . get method name ( ) + str + stack trace element . get line number ( ) ; } return str ; }	Returns called class.
protected string shorten class name ( final string class name ) { int last dot index = class name . last index of ( str ) ; if ( last dot index == - num ) { return class name ; } string builder short class name = new string builder ( class name . length ( ) ) ; int start = num ; while ( bool ) { short class name . append ( class name . char at ( start ) ) ; int next = class name . index of ( str , start ) ; if ( next == last dot index ) { break ; } start = next + num ; short class name . append ( str ) ; } short class name . append ( class name . substring ( last dot index ) ) ; return short class name . to string ( ) ; }	Returns shorten class name.
public json serializer exclude types ( final class ... types ) { if ( excluded types == null ) { excluded types = types ; } else { excluded types = arrays util . join ( excluded types , types ) ; } return this ; }	Excludes types. Supports interfaces and subclasses as well.
public void serialize ( final object source , final appendable target ) { json context json context = create json context ( target ) ; json context . serialize ( source ) ; }	Serializes object into provided appendable.
public string serialize ( final object source ) { fast char buffer fast char buffer = new fast char buffer ( ) ; serialize ( source , fast char buffer ) ; return fast char buffer . to string ( ) ; }	Serializes object into source.
public static < t extends serializable > t clone via serialization ( final t obj ) throws io , class not found exception { fast byte array output stream bos = new fast byte array output stream ( ) ; object output stream out = null ; object input stream in = null ; object obj copy = null ; try { out = new object output stream ( bos ) ; out . write object ( obj ) ; out . flush ( ) ; byte [ ] bytes = bos . to byte array ( ) ; in = new object input stream ( new byte array input stream ( bytes ) ) ; obj copy = in . read object ( ) ; } finally { stream util . close ( out ) ; stream util . close ( in ) ; } return ( t ) obj copy ; }	Create object copy using serialization mechanism.
public static void write object ( final file dest , final object object ) throws io { file output stream fos = null ; buffered output stream bos = null ; object output stream oos = null ; try { fos = new file output stream ( dest ) ; bos = new buffered output stream ( fos ) ; oos = new object output stream ( bos ) ; oos . write object ( object ) ; } finally { stream util . close ( oos ) ; stream util . close ( bos ) ; stream util . close ( fos ) ; } }	Writes serializable object to a file.
public static object read object ( final file source ) throws io , class not found exception { object result = null ; file input stream fis = null ; buffered input stream bis = null ; object input stream ois = null ; try { fis = new file input stream ( source ) ; bis = new buffered input stream ( fis ) ; ois = new object input stream ( bis ) ; result = ois . read object ( ) ; } finally { stream util . close ( ois ) ; stream util . close ( bis ) ; stream util . close ( fis ) ; } return result ; }	Reads serialized object from the file.
public static byte [ ] object to byte array ( final object obj ) throws io { fast byte array output stream bos = new fast byte array output stream ( ) ; object output stream oos = null ; try { oos = new object output stream ( bos ) ; oos . write object ( obj ) ; } finally { stream util . close ( oos ) ; } return bos . to byte array ( ) ; }	Serialize an object to byte array.
public static object byte array to object ( final byte [ ] data ) throws io , class not found exception { object ret obj = null ; byte array input stream bais = new byte array input stream ( data ) ; object input stream ois = null ; try { ois = new object input stream ( bais ) ; ret obj = ois . read object ( ) ; } finally { stream util . close ( ois ) ; } return ret obj ; }	De-serialize an object from byte array.
protected string [ ] [ ] resolve mapped types table names ( final class [ ] types ) { if ( cached mapped names == null ) { string [ ] [ ] names = new string [ types . length ] [ ] ; for ( int i = num ; i < types . length ; i ++ ) { class type = types [ i ] ; if ( type != null ) { db entity descriptor ded = cached db entity descriptors [ i ] ; if ( ded != null ) { class [ ] mapped types = ded . get mapped types ( ) ; if ( mapped types != null ) { names [ i ] = create types table names ( mapped types ) ; } } } } cached mapped names = names ; } return cached mapped names ; }	Resolved mapped type names for each type.
protected string [ ] create types table names ( final class [ ] types ) { string [ ] names = new string [ types . length ] ; for ( int i = num ; i < types . length ; i ++ ) { if ( types [ i ] == null ) { names [ i ] = null ; continue ; } db entity descriptor ded = db entity manager . lookup type ( types [ i ] ) ; if ( ded != null ) { string table name = ded . get table name ( ) ; table name = table name . to upper case ( ) ; names [ i ] = table name ; } } return names ; }	Creates table names for given types.
@ suppress warnings ( { str } ) protected object read column value ( final int col ndx , final class destination type , final class < ? extends sql type > sql type class , final int column db sql type ) { if ( col ndx != cached column ndx ) { try { sql type sql type ; if ( sql type class != null ) { sql type = sql type manager . get ( ) . lookup sql type ( sql type class ) ; } else { sql type = sql type manager . get ( ) . lookup ( destination type ) ; } if ( sql type != null ) { cached column value = sql type . read value ( result set , col ndx + num , destination type , column db sql type ) ; } else { cached column value = result set . get object ( col ndx + num ) ; cached column value = type converter manager . get ( ) . convert type ( cached column value , destination type ) ; } } catch ( sql sex ) { throw new db oom exception ( db oom query , str + ( col ndx + num ) , sex ) ; } cached column ndx = col ndx ; } return cached column value ; }	Reads column value from result set.
protected void cache result set entities ( final object [ ] result ) { if ( entities cache == null ) { entities cache = new hash map < > ( ) ; } for ( int i = num ; i < result . length ; i ++ ) { object object = result [ i ] ; if ( object == null ) { continue ; } db entity descriptor ded = cached db entity descriptors [ i ] ; if ( ded == null ) {	Caches returned entities. Replaces new instances with existing ones.
public provider definition [ ] resolve ( final class type , final string name ) { class descriptor cd = class introspector . get ( ) . lookup ( type ) ; method descriptor [ ] methods = cd . get all method descriptors ( ) ; list < provider definition > list = new array list < > ( ) ; for ( method descriptor method descriptor : methods ) { method method = method descriptor . get method ( ) ; petite provider petite provider = method . get annotation ( petite provider . class ) ; if ( petite provider == null ) { continue ; } string provider name = petite provider . value ( ) ; if ( string util . is blank ( provider name ) ) {	Resolves all providers in the class.
public string apply to table name ( final string table name ) { string entity name = convert table name to entity name ( table name ) ; return convert entity name to table name ( entity name ) ; }	Applies table naming strategy to given table name hint.Returns full table name.
private boolean is connection valid ( final connection data connection data , final long now ) { if ( ! validate connection ) { return bool ; } if ( now < connection data . last used + validation timeout ) { return bool ; } connection conn = connection data . connection ; if ( validation query == null ) { try { return ! conn . is closed ( ) ; } catch ( sql sex ) { return bool ; } } boolean valid = bool ; statement st = null ; try { st = conn . create statement ( ) ; st . execute ( validation query ) ; } catch ( sql sex ) { valid = bool ; } finally { if ( st != null ) { try { st . close ( ) ; } catch ( sql ignore ) { } } } return valid ; }	Checks if existing connection is valid and available.
@ override protected void render view ( final action request action request , final string target ) throws exception { http servlet request request = action request . get http servlet request ( ) ; http servlet response response = action request . get http servlet response ( ) ; request dispatcher dispatcher = request . get request dispatcher ( target ) ; if ( dispatcher == null ) { response . send error ( sc not found , str + target ) ;	Renders the view by dispatching to the target JSP.
@ override protected string locate target ( final action request action request , string path ) { string target ; if ( path . ends with ( string pool . slash ) ) { path = path + default view page name ; } for ( final string ext : default view extensions ) { target = path + ext ; if ( target exists ( action request , target ) ) { return target ; } } return null ; }	Locates target using path with various extensions appended.
@ override public print writer get writer ( ) throws io { pre response commit ( ) ; if ( buffer == null ) { return get response ( ) . get writer ( ) ; } return buffer . get writer ( ) ; }	Returns buffered writer if buffering is enabled,otherwise returns the original writer.
@ override public servlet output stream get output stream ( ) throws io { pre response commit ( ) ; if ( buffer == null ) { return get response ( ) . get output stream ( ) ; } return buffer . get output stream ( ) ; }	Returns buffered output stream if buffering is enabled,otherwise returns the original stream.
public void write content to response ( final char [ ] content ) throws io { if ( buffer == null ) { return ; } if ( buffer . is using stream ( ) ) { servlet output stream output stream = get response ( ) . get output stream ( ) ; string encoding = get content type encoding ( ) ; if ( encoding == null ) { output stream . write ( char util . to byte array ( content ) ) ; } else { output stream . write ( char util . to byte array ( content , encoding ) ) ; } output stream . flush ( ) ; } else { writer out = get response ( ) . get writer ( ) ; out . write ( content ) ; out . flush ( ) ; } }	Writes content to original output stream, using either output stream or writer, dependingon how the content was buffered.
@ override public void set content type ( final string type ) { super . set content type ( type ) ; content type resolver = new content type header resolver ( type ) ; if ( buffer content type ( type , content type resolver . get mime type ( ) , content type resolver . get encoding ( ) ) ) { enable buffering ( ) ; } else { disable buffering ( ) ; } }	Sets the content type and enables or disables buffering.
public void print ( final string string ) throws io { if ( is buffer stream based ( ) ) { string encoding = get content type encoding ( ) ; byte [ ] bytes ; if ( encoding == null ) { bytes = string . get bytes ( ) ; } else { bytes = string . get bytes ( encoding ) ; } buffer . get output stream ( ) . write ( bytes ) ; return ; }	Appends string to the buffer.
protected json result login ( ) { t auth token ; auth token = login via basic auth ( servlet request ) ; if ( auth token == null ) { auth token = login via request params ( servlet request ) ; } if ( auth token == null ) { log . warn ( str ) ; return json result . of ( http status . error401 ( ) . unauthorized ( str ) ) ; } log . info ( str ) ; final user session < t > user session = new user session < > ( auth token , user auth . token value ( auth token ) ) ; user session . start ( servlet request , servlet response ) ;	Authenticate user and start user session.
protected json result token as json ( final t auth token ) { final json object json object = new json object ( ) ; json object . put ( str , user auth . token value ( auth token ) ) ; return json result . of ( json object ) ; }	Prepares the JSON payload that carries on the token value.
protected t login via basic auth ( final http servlet request servlet request ) { final string username = servlet util . resolve auth username ( servlet request ) ; if ( username == null ) { return null ; } final string password = servlet util . resolve auth password ( servlet request ) ; return user auth . login ( username , password ) ; }	Tries to login user with basic authentication.
public static file to container file ( final url url ) { string protocol = url . get protocol ( ) ; if ( protocol . equals ( file protocol ) ) { return to file ( url ) ; } string path = url . get path ( ) ; return new file ( uri . create ( path . substring ( zero , path . last index of ( str ) ) ) ) ; }	Returns a file of either a folder or a containing archive.
public static file mkdirs ( final file dirs ) throws io { if ( dirs . exists ( ) ) { check is directory ( dirs ) ; return dirs ; } return check create directory ( dirs ) ; }	Creates all directories at once.
public static file mkdir ( final file dir ) throws io { if ( dir . exists ( ) ) { check is directory ( dir ) ; return dir ; } return check create directory ( dir ) ; }	Creates single directory.
private static void copy file ( final file src file , final file dest file ) throws io { if ( dest file . exists ( ) ) { if ( dest file . is directory ( ) ) { throw new io ( str + dest file + str ) ; } }	Internal file copy when most of the pre-checking has passed.
public static void copy dir ( final file src dir , final file dest dir ) throws io { check dir copy ( src dir , dest dir ) ; copy directory ( src dir , dest dir ) ; }	Copies directory with specified copy params.
public static file move file to dir ( final file src file , final file dest dir ) throws io { check exists and directory ( dest dir ) ; return move file ( src file , file ( dest dir , src file . get name ( ) ) ) ; }	Moves a file to a directory.
private static void move directory ( final file src dest , file dest dir ) throws io { if ( dest dir . exists ( ) ) { check is directory ( dest dir ) ; dest dir = file ( dest dir , dest dir . get name ( ) ) ; dest dir . mkdir ( ) ; } final boolean rename = src dest . rename to ( dest dir ) ; if ( ! rename ) { copy directory ( src dest , dest dir ) ; delete dir ( src dest ) ; } }	Moves a directory.
public static void clean dir ( final file dest dir ) throws io { check exists ( dest dir ) ; check is directory ( dest dir ) ; file [ ] files = dest dir . list files ( ) ; if ( files == null ) { throw new io ( str + dest dir ) ; } io exception = null ; for ( file file : files ) { try { if ( file . is directory ( ) ) { delete dir ( file ) ; } else { file . delete ( ) ; } } catch ( io ioex ) { exception = ioex ; continue ; } } if ( exception != null ) { throw exception ; } }	Cleans a directory without deleting it.
public static char [ ] read utf ( final file file ) throws io { check exists ( file ) ; check is file ( file ) ; unicode input stream in = unicode input stream of ( file ) ; try { return stream util . read chars ( in , detect encoding ( in ) ) ; } finally { stream util . close ( in ) ; } }	Reads UTF file content as char array.
public static char [ ] read chars ( final file file , final string encoding ) throws io { check exists ( file ) ; check is file ( file ) ; input stream in = stream of ( file , encoding ) ; try { return stream util . read chars ( in , encoding ) ; } finally { stream util . close ( in ) ; } }	Reads file content as char array.
public static void write chars ( final file dest , final char [ ] data , final string encoding ) throws io { out chars ( dest , data , encoding , bool ) ; }	Write characters. append = false.
public static void write string ( final file dest , final string data , final string encoding ) throws io { out string ( dest , data , encoding , bool ) ; }	Writes String. append = false.
public static void append string ( final file dest , final string data , final string encoding ) throws io { out string ( dest , data , encoding , bool ) ; }	Appends String. append = true.
public static byte [ ] read bytes ( final file file , final int count ) throws io { check exists ( file ) ; check is file ( file ) ; long num to read = file . length ( ) ; if ( num to read >= integer . max value ) { throw new io ( str ) ; } if ( count > negative one && count < num to read ) { num to read = count ; } byte [ ] bytes = new byte [ ( int ) num to read ] ; random access file random access file = new random access file ( file , str ) ; random access file . read fully ( bytes ) ; random access file . close ( ) ; return bytes ; }	Read file and returns byte array with contents.
public static void write bytes ( final file dest , final byte [ ] data , final int off , final int len ) throws io { out bytes ( dest , data , off , len , bool ) ; }	Write bytes. append = false.
public static void append bytes ( final file dest , final byte [ ] data , final int off , final int len ) throws io { out bytes ( dest , data , off , len , bool ) ; }	Appends bytes. append = true.
public static void copy ( final file src , final file dest ) throws io { if ( src . is directory ( ) ) { copy dir ( src , dest ) ; return ; } if ( dest . is directory ( ) ) { copy file to dir ( src , dest ) ; return ; } copy file ( src , dest ) ; }	Smart copy. If source is a directory, copy it to destination.Otherwise, if destination is directory, copy source file to it.Otherwise, try to copy source file to destination file.
public static void delete ( final file dest ) throws io { if ( dest . is directory ( ) ) { delete dir ( dest ) ; return ; } delete file ( dest ) ; }	Smart delete of destination file or directory.
public static file create temp directory ( final string prefix , final string suffix , final file temp dir ) throws io { file file = create temp file ( prefix , suffix , temp dir ) ; file . delete ( ) ; file . mkdir ( ) ; return file ; }	Creates temporary directory.
public static boolean is binary ( final file file ) throws io { byte [ ] bytes = read bytes ( file , num ) ; for ( byte b : bytes ) { if ( b < num && b != num && b != num && b != num ) { return bool ; } } return bool ; }	Checks the start of the file for ASCII control characters.
private static void check dir copy ( final file src dir , final file dest dir ) throws io { check exists ( src dir ) ; check is directory ( src dir ) ; if ( equals ( src dir , dest dir ) ) { throw new io ( str + src dir + str + dest dir + str ) ; } }	Checks that srcDir exists, that it is a directory and if srcDir and destDir are not equal.
private static void check file copy ( final file src file , final file dest file ) throws io { check exists ( src file ) ; check is file ( src file ) ; if ( equals ( src file , dest file ) ) { throw new io ( str + src file + str + dest file + str ) ; } file dest parent = dest file . get parent file ( ) ; if ( dest parent != null && ! dest parent . exists ( ) ) { check create directory ( dest parent ) ; } }	Checks that file copy can occur.
public void print usage ( final string command name ) { final string builder usage = new string builder ( command name ) ; for ( final option option : options ) { if ( option . short name != null ) { usage . append ( str ) . append ( option . short name ) . append ( str ) ; } else if ( option . long name != null ) { usage . append ( str ) . append ( option . long name ) . append ( str ) ; } } for ( final param param : params ) { usage . append ( str ) . append ( param . label ) ; } system . out . println ( usage ) ; }	Prints the usage line.
public method resolve action method ( final class < ? > action class , final string method name ) { method descriptor method descriptor = class introspector . get ( ) . lookup ( action class ) . get method descriptor ( method name , bool ) ; if ( method descriptor == null ) { throw new madvoc exception ( str + action class . get simple name ( ) + str + method name ) ; } return method descriptor . get method ( ) ; }	Resolves action method for given action class ane method name.
public action runtime register action ( final class action class , final string action method name , final action definition action definition ) { method action method = resolve action method ( action class , action method name ) ; return register action ( action class , action method , action definition ) ; }	Registers action with provided action class and method name.
public void register path alias ( final string alias , final string path ) { final string existing = path aliases . put ( alias , path ) ; if ( existing != null ) { throw new madvoc exception ( str + alias + str + path + str + existing ) ; } }	Registers new path alias.
public boolean next ( ) { if ( ! looping ) { return bool ; } if ( last ) { return bool ; } if ( count == num ) { value = start ; first = bool ; } else { value += step ; first = bool ; } count ++ ; last = is last iteration ( value + step ) ; return bool ; }	Iterates to next value at the beginning of the loop.
public static char array sequence from ( final char [ ] value , final int offset , final int len ) { final char [ ] buffer = new char [ value . length ] ; system . arraycopy ( value , offset , buffer , num , len ) ; return new char array sequence ( buffer ) ; }	Static constructor that creates a char sequence by making a copy of provided char array.
public object execute ( ) throws exception { string method name = proxy target . target method name ( ) ; class [ ] arg types = proxy target . create arguments class array ( ) ; object [ ] args = proxy target . create arguments array ( ) ;	Looks up for method in target object and invokes it using reflection.
public final boolean match upper case ( final char [ ] uppercase target ) { if ( ndx + uppercase target . length > total ) { return bool ; } int j = ndx ; for ( int i = num ; i < uppercase target . length ; i ++ , j ++ ) { final char c = char util . to upper ascii ( input [ j ] ) ; if ( c != uppercase target [ i ] ) { return bool ; } } return bool ; }	Matches char buffer given in uppercase with content at current location, that willbe converted to upper case to make case-insensitive matching.
protected final char sequence char sequence ( final int from , final int to ) { if ( from == to ) { return char array sequence . empty ; } return char array sequence . of ( input , from , to - from ) ; }	Creates char sub-sequence from the input.
public static url [ ] of ( class loader class loader , class clazz ) { if ( clazz == null ) { clazz = ur . class ; } if ( class loader == null ) { class loader = clazz . get class loader ( ) ; } final set < url > urls = new linked hash set < > ( ) ; while ( class loader != null ) { if ( class loader instanceof url ) { url url class loader = ( url ) class loader ; url [ ] all urls = url class loader . get ur ( ) ; collections . add all ( urls , all urls ) ; break ; } url class url = class module url ( class loader , clazz ) ; if ( class url != null ) { urls . add ( class url ) ; } class url = class module url ( class loader , ur . class ) ; if ( class url != null ) { urls . add ( class url ) ; } module descriptor module descriptor = clazz . get module ( ) . get descriptor ( ) ; if ( module descriptor != null ) { module descriptor . requires ( ) . for each ( req -> { module layer . boot ( ) . find module ( req . name ( ) ) . if present ( mod -> { class loader module class loader = mod . get class loader ( ) ; if ( module class loader != null ) { url url = module class loader . get resource ( manifest ) ; if ( url != null ) { url = fix manifest url ( url ) ; urls . add ( url ) ; } } } ) ; } ) ; } class loader = class loader . get parent ( ) ; } return urls . to array ( new url [ num ] ) ; }	Returns urls for the classloader.
public email bcc ( final email address ... bccs ) { this . bcc = arrays util . join ( this . bcc , value or empty array ( bccs ) ) ; return this ( ) ; }	Appends one or more BCC addresses.
public void register ( final class type , final type json serializer type json serializer ) { map . put ( type , type json serializer ) ; cache . clear ( ) ; }	Registers new serializer.
protected type json serializer lookup serializer ( final class type ) { type json serializer tjs = map . get ( type ) ; if ( tjs == null ) { if ( default serializer map != null ) { tjs = default serializer map . map . get ( type ) ; } } return tjs ; }	Get type serializer from map.
public void parse request stream ( final input stream input stream , final string encoding ) throws io { set parsed ( ) ; multipart request input stream input = new multipart request input stream ( input stream ) ; input . read boundary ( ) ; while ( bool ) { file upload header header = input . read data header ( encoding ) ; if ( header == null ) { break ; } if ( header . is file ) { string file name = header . file name ; if ( file name . length ( ) > num ) { if ( header . content type . index of ( str ) > num ) { input . skip bytes ( num ) ; } } file upload new file = file upload factory . create ( input ) ; new file . process stream ( ) ; if ( file name . length ( ) == num ) {	Extracts uploaded files and parameters from the request data.
public string get parameter ( final string param name ) { if ( request parameters == null ) { return null ; } string [ ] values = request parameters . get ( param name ) ; if ( ( values != null ) && ( values . length > num ) ) { return values [ num ] ; } return null ; }	Returns single value of a parameter.
public string [ ] get parameter values ( final string param name ) { if ( request parameters == null ) { return null ; } return request parameters . get ( param name ) ; }	Returns all values all of the values the given request parameter has.
public file upload get file ( final string param name ) { if ( request files == null ) { return null ; } file upload [ ] values = request files . get ( param name ) ; if ( ( values != null ) && ( values . length > num ) ) { return values [ num ] ; } return null ; }	Returns uploaded file.
public file upload [ ] get files ( final string param name ) { if ( request files == null ) { return null ; } return request files . get ( param name ) ; }	Returns all uploaded files the given request parameter has.
@ override public void init ( final filter config filter config ) { this . filter config = filter config ; this . encoding = filter config . get init parameter ( str ) ; if ( this . encoding == null ) { this . encoding = jodd core . encoding ; } this . ignore = converter . get ( ) . to boolean value ( filter config . get init parameter ( str ) , bool ) ; }	Place this filter into service.
public void parse ( final db sql builder sql builder , final string template ) { int length = template . length ( ) ; int last = num ; while ( bool ) { int mark = template . index of ( str , last ) ; if ( mark == - num ) { if ( last < length ) { sql builder . append raw ( template . substring ( last ) ) ; } break ; } int escapes count = count escapes ( template , mark ) ;	Parses template and returns generated sql builder.
protected int find macro end ( final string template , final int from index ) { int end index = template . index of ( str , from index ) ; if ( end index == - num ) { throw new db sql builder exception ( str + template . substring ( from index ) ) ; } return end index ; }	Finds macros end.
protected int count escapes ( final string template , int macro index ) { macro index -- ; int escape count = num ; while ( macro index >= num ) { if ( template . char at ( macro index ) != escape character ) { break ; } escape count ++ ; macro index -- ; } return escape count ; }	Count escapes to the left.
public static string build query ( final http multi map < ? > query map , final string encoding ) { if ( query map . is empty ( ) ) { return string pool . empty ; } int query map size = query map . size ( ) ; string band query = new string band ( query map size * num ) ; int count = num ; for ( map . entry < string , ? > entry : query map ) { string key = entry . get key ( ) ; key = url . encode query param ( key , encoding ) ; object value = entry . get value ( ) ; if ( value == null ) { if ( count != num ) { query . append ( str ) ; } query . append ( key ) ; count ++ ; } else { if ( count != num ) { query . append ( str ) ; } query . append ( key ) ; count ++ ; query . append ( str ) ; string value string = url . encode query param ( value . to string ( ) , encoding ) ; query . append ( value string ) ; } } return query . to string ( ) ; }	Builds a query string from given query map.
public static http multi map < string > parse query ( final string query , final boolean decode ) { final http multi map < string > query map = http multi map . new case insensitive map ( ) ; if ( string util . is blank ( query ) ) { return query map ; } int last ndx = num ; while ( last ndx < query . length ( ) ) { int ndx = query . index of ( str , last ndx ) ; if ( ndx == - num ) { ndx = query . length ( ) ; } final string param and value = query . substring ( last ndx , ndx ) ; ndx = param and value . index of ( str ) ; if ( ndx == - num ) { query map . add ( param and value , null ) ; } else { string name = param and value . substring ( num , ndx ) ; if ( decode ) { name = url . decode query ( name ) ; } string value = param and value . substring ( ndx + num ) ; if ( decode ) { value = url . decode query ( value ) ; } query map . add ( name , value ) ; } last ndx += param and value . length ( ) + num ; } return query map ; }	Parses query from give query string.
public static string prepare header parameter name ( final string header name ) {	Makes nice header names.
public static string extract media type ( final string content type ) { int index = content type . index of ( str ) ; if ( index == - num ) { return content type ; } return content type . substring ( num , index ) ; }	Extracts media-type from value of "Content Type" header.
public string to html ( final node node , final appendable appendable ) { node visitor renderer = create renderer ( appendable ) ; node . visit ( renderer ) ; return appendable . to string ( ) ; }	Renders node to appendable.
public string to inner html ( final node node , final appendable appendable ) { node visitor renderer = create renderer ( appendable ) ; node . visit children ( renderer ) ; return appendable . to string ( ) ; }	Renders node children to appendable.
public void configure with ( final servlet context servlet context ) { web app class name = servlet context . get init parameter ( param madvoc webapp ) ; params files = converter . get ( ) . to string array ( servlet context . get init parameter ( param madvoc params ) ) ; madvoc configurator class name = servlet context . get init parameter ( param madvoc configurator ) ; }	Configures Madvoc by reading context init parameters.
protected void reset ( ) { this . ndx = num ; this . text len = num ; this . path = new path ( ) ; this . not first object = bool ; if ( use alt paths ) { path . alt path = new path ( ) ; } if ( class metadata name != null ) { map to bean = create map to bean ( class metadata name ) ; } }	Resets JSON parser, so it can be reused.
public json parser lazy ( final boolean lazy ) { this . lazy = lazy ; this . map supplier = lazy ? lazymap supplier : hashmap supplier ; this . list supplier = lazy ? lazylist supplier : arraylist supplier ; return this ; }	Defines how JSON parser works.
protected class replace with mapped type for path ( final class target ) { if ( mappings == null ) { return target ; } class new type ;	Replaces type with mapped type for current path.
public < t > list < t > parse as list ( final string string , final class < t > component type ) { return new json parser ( ) . map ( json parser . values , component type ) . parse ( string ) ; }	Parses input JSON to a list with specified component type.
public < k , v > map < k , v > parse as map ( final string string , final class < k > key type , final class < v > value type ) { return new json parser ( ) . map ( json parser . keys , key type ) . map ( json parser . values , value type ) . parse ( string ) ; }	Parses input JSON to a list with specified key and value types.
private object resolve lazy value ( object value ) { if ( value instanceof supplier ) { value = ( ( supplier ) value ) . get ( ) ; } return value ; }	Resolves lazy value during the parsing runtime.
private void skip object ( ) { int bracket count = num ; boolean inside string = bool ; while ( ndx < total ) { final char c = input [ ndx ] ; if ( inside string ) { if ( c == str && not preceded by even number of backslashes ( ) ) { inside string = bool ; } } else if ( c == str ) { inside string = bool ; } else if ( c == str ) { bracket count ++ ; } else if ( c == str ) { bracket count -- ; if ( bracket count == num ) { ndx ++ ; return ; } } ndx ++ ; } }	Skips over complete object.
protected string parse string ( ) { char quote = str ; if ( loose mode ) { quote = consume one of ( str , str ) ; if ( quote == num ) { return parse unquoted string content ( ) ; } } else { consume ( quote ) ; } return parse string content ( quote ) ; }	Parses a string.
protected string parse string content ( final char quote ) { final int start ndx = ndx ;	Parses string content, once when starting quote has been consumed.
protected char parse unicode ( ) { int i0 = char util . hex2int ( input [ ndx ++ ] ) ; int i1 = char util . hex2int ( input [ ndx ++ ] ) ; int i2 = char util . hex2int ( input [ ndx ++ ] ) ; int i3 = char util . hex2int ( input [ ndx ] ) ; return ( char ) ( ( i0 << num ) + ( i1 << num ) + ( i2 << num ) + i3 ) ; }	Parses 4 characters and returns unicode character.
protected string parse unquoted string content ( ) { final int start ndx = ndx ; while ( bool ) { final char c = input [ ndx ] ; if ( c <= str || char util . equals one ( c , unquoted delimeters ) ) { final int current ndx = ndx ;	Parses un-quoted string content.
protected number parse number ( ) { final int start index = ndx ; char c = input [ ndx ] ; boolean is double = bool ; boolean is exp = bool ; if ( c == str ) { ndx ++ ; } while ( bool ) { if ( is eof ( ) ) { break ; } c = input [ ndx ] ; if ( c >= str && c <= str ) { ndx ++ ; continue ; } if ( c <= num ) {	Parses JSON numbers.
protected object parse array content ( class target type , class component type ) {	Parses arrays, once when open bracket has been consumed.
protected void create empty ctor ( ) { final method visitor mv = wd . dest . visit method ( asm util . acc public , init , str , null , null ) ; mv . visit code ( ) ; mv . visit var insn ( opcodes . aload , num ) ; mv . visit method insn ( opcodes . invokespecial , asm util . signature java lang object , init , str , bool ) ; mv . visit insn ( opcodes . return ) ; mv . visit maxs ( num , num ) ; mv . visit end ( ) ; }	Created empty default constructor.
protected void create simple method wrapper ( final method signature visitor msign ) { int access = msign . get access flags ( ) ; access &= ~ acc abstract ; access &= ~ acc native ; method visitor mv = wd . dest . visit method ( access , msign . get method name ( ) , msign . get description ( ) , msign . get asm method signature ( ) , msign . get exceptions ( ) ) ; mv . visit code ( ) ; mv . visit var insn ( aload , num ) ; mv . visit field insn ( getfield , wd . this reference , wd . wrapper ref , wd . wrapper type ) ; load virtual method arguments ( mv , msign ) ; if ( wd . wrap interface ) { mv . visit method insn ( invokeinterface , wd . wrapper type . substring ( num , wd . wrapper type . length ( ) - num ) , msign . get method name ( ) , msign . get description ( ) , bool ) ; } else { mv . visit method insn ( invokevirtual , wd . wrapper type . substring ( num , wd . wrapper type . length ( ) - num ) , msign . get method name ( ) , msign . get description ( ) , bool ) ; } proxetta asm util . prepare return value ( mv , msign , num ) ; visit return ( mv , msign , bool ) ; mv . visit maxs ( num , num ) ; mv . visit end ( ) ; }	Creates simple method wrapper without proxy.
private string resolve raw type name ( string type name ) { if ( type name == null ) { return null ; } boolean is array = type name . starts with ( string pool . left sq bracket ) ; if ( is array ) { type name = type name . substring ( num ) ; } string raw type name ; if ( generics . contains key ( type name ) ) { raw type name = generics . get ( type name ) ; } else { raw type name = declared type generic . get or default ( type name , type name ) ; } if ( is array ) { raw type name = str + raw type name ; } return raw type name ; }	Resolves raw type name using the generics information from the classor method information.
public bean references resolve reference from value ( final property descriptor property descriptor , final string ref name ) { bean references references ; if ( ref name == null || ref name . is empty ( ) ) { references = build default reference ( property descriptor ) ; } else { references = bean references . of ( ref name ) ; } references = references . remove duplicate names ( ) ; return references ; }	Resolves reference from given values.
public bean references [ ] resolve reference from values ( final executable method or ctor , final string ... parameter references ) { bean references [ ] references = convert ref to references ( parameter references ) ; if ( references == null || references . length == num ) { references = build default references ( method or ctor ) ; } if ( method or ctor . get parameter types ( ) . length != references . length ) { throw new petite exception ( str + method or ctor . get declaring class ( ) . get name ( ) + str + method or ctor . get name ( ) ) ; } remove all duplicate names ( references ) ; return references ; }	Takes given parameters references and returns reference set for given method or constructor.
public bean references [ ] read all references from annotation ( final executable method or ctor ) { petite inject petite inject = method or ctor . get annotation ( petite inject . class ) ; final parameter [ ] parameters = method or ctor . get parameters ( ) ; bean references [ ] references ; final boolean has annotation on method or ctor ; if ( petite inject != null ) { references = convert ann value to references ( petite inject . value ( ) ) ; has annotation on method or ctor = bool ; } else { references = new bean references [ parameters . length ] ; has annotation on method or ctor = bool ; } int parameters with annotation count = num ; for ( int i = num ; i < parameters . length ; i ++ ) { parameter parameter = parameters [ i ] ; petite inject = parameter . get annotation ( petite inject . class ) ; if ( petite inject == null ) {	Extracts references from method or constructor annotation.
private bean references [ ] build default references ( final executable method or ctor ) { final boolean use paramo = petite config . get use paramo ( ) ; final petite reference type [ ] lookup references = petite config . get lookup references ( ) ; method parameter [ ] method parameters = null ; if ( use paramo ) { method parameters = paramo . resolve parameters ( method or ctor ) ; } final class [ ] param types = method or ctor . get parameter types ( ) ; final bean references [ ] references = new bean references [ param types . length ] ; for ( int j = num ; j < param types . length ; j ++ ) { string [ ] ref = new string [ lookup references . length ] ; references [ j ] = bean references . of ( ref ) ; for ( int i = num ; i < ref . length ; i ++ ) { switch ( lookup references [ i ] ) { case name : ref [ i ] = method parameters != null ? method parameters [ j ] . get name ( ) : null ; break ; case type short name : ref [ i ] = string util . uncapitalize ( param types [ j ] . get simple name ( ) ) ; break ; case type full name : ref [ i ] = param types [ j ] . get name ( ) ; break ; } } } return references ; }	Builds default method references.
public bean references build default reference ( final property descriptor property descriptor ) { final petite reference type [ ] lookup references = petite config . get lookup references ( ) ; final string [ ] references = new string [ lookup references . length ] ; for ( int i = num ; i < references . length ; i ++ ) { switch ( lookup references [ i ] ) { case name : references [ i ] = property descriptor . get name ( ) ; break ; case type short name : references [ i ] = string util . uncapitalize ( property descriptor . get type ( ) . get simple name ( ) ) ; break ; case type full name : references [ i ] = property descriptor . get type ( ) . get name ( ) ; break ; } } return bean references . of ( references ) ; }	Builds default field references.
private void remove all duplicate names ( final bean references [ ] all bean references ) { for ( int i = num ; i < all bean references . length ; i ++ ) { bean references references = all bean references [ i ] ; all bean references [ i ] = references . remove duplicate names ( ) ; } }	Removes duplicate names from bean references.
private bean references [ ] convert ref to references ( final string [ ] references ) { if ( references == null ) { return null ; } bean references [ ] ref = new bean references [ references . length ] ; for ( int i = num ; i < references . length ; i ++ ) { ref [ i ] = bean references . of ( references [ i ] ) ; } return ref ; }	Converts single string array to an array of bean references.
private bean references [ ] convert ann value to references ( string value ) { if ( value == null ) { return null ; } value = value . trim ( ) ; if ( value . length ( ) == num ) { return null ; } string [ ] ref names = converter . get ( ) . to string array ( value ) ; bean references [ ] references = new bean references [ ref names . length ] ; for ( int i = num ; i < ref names . length ; i ++ ) { references [ i ] = bean references . of ( ref names [ i ] . trim ( ) ) ; } return references ; }	Converts comma-separated string into array of Bean references.
public void run joy ( final consumer < jodd joy runtime > consumer ) { final jodd joy jodd joy = new jodd joy ( ) ; final jodd joy runtime joy runtime = jodd joy . start only backend ( ) ; jodd joy . with db ( joy db -> set jtx manager ( joy runtime . get jtx manager ( ) ) ) ; final jtx transaction tx = start rw tx ( ) ; final print print = new print ( ) ; try { print . line ( str , num ) ; print . new line ( ) ; consumer . accept ( joy runtime ) ; print . new line ( ) ; print . line ( str , num ) ; if ( tx != null ) { tx . commit ( ) ; } } catch ( throwable throwable ) { throwable . print stack trace ( ) ; if ( tx != null ) { tx . rollback ( ) ; } } jodd joy . stop ( ) ; }	Runs JOY in standalone mode, with only backend.
public static method find method ( final class c , final string method name ) { return find declared method ( c , method name , bool ) ; }	Returns method from an object, matched by name.
public static < t > constructor < t > find constructor ( final class < t > clazz , final class < ? > ... parameter types ) { final constructor < ? > [ ] constructors = clazz . get constructors ( ) ; class < ? > [ ] pts ; for ( constructor < ? > constructor : constructors ) { pts = constructor . get parameter types ( ) ; if ( is all assignable from ( pts , parameter types ) ) { return ( constructor < t > ) constructor ; } } return null ; }	Finds constructor with given parameter types.
public static class [ ] resolve all interfaces ( final class type ) { set < class > bag = new linked hash set < > ( ) ; resolve all interfaces ( type , bag ) ; return bag . to array ( new class [ num ] ) ; }	Resolves all interfaces of a type.
public static boolean compare parameters ( final class [ ] first , final class [ ] second ) { if ( first . length != second . length ) { return bool ; } for ( int i = num ; i < first . length ; i ++ ) { if ( first [ i ] != second [ i ] ) { return bool ; } } return bool ; }	Compares classes, usually method or ctor parameters.
public static void force access ( final accessible object acc object ) { try { if ( system . get security manager ( ) == null ) acc object . set accessible ( bool ) ; else { access controller . do privileged ( ( privileged action ) ( ) -> { acc object . set accessible ( bool ) ; return null ; } ) ; } } catch ( security exception sex ) {	Suppress access check against a reflection object.
@ suppress warnings ( str ) public static < t > t new instance ( final class < t > clazz , final object ... params ) throws instantiation exception , illegal access exception , invocation target exception , no such method exception { if ( params . length == num ) { return new instance ( clazz ) ; } final class < ? > [ ] param types = get classes ( params ) ; final constructor < ? > constructor = find constructor ( clazz , param types ) ; if ( constructor == null ) { throw new instantiation exception ( str ) ; } return ( t ) constructor . new instance ( params ) ; }	Creates new instance of given class with given optional arguments.
public static class [ ] get superclasses ( final class type ) { int i = num ; for ( class x = type . get superclass ( ) ; x != null ; x = x . get superclass ( ) ) { i ++ ; } class [ ] result = new class [ i ] ; i = num ; for ( class x = type . get superclass ( ) ; x != null ; x = x . get superclass ( ) ) { result [ i ] = x ; i ++ ; } return result ; }	Returns all superclasses.
public static class < ? > child class of ( final class < ? > parent class , final object instance ) { if ( instance == null || instance == object . class ) { return null ; } if ( parent class != null ) { if ( parent class . is interface ( ) ) { return null ; } } class < ? > child class = instance . get class ( ) ; while ( bool ) { class < ? > parent = child class . get superclass ( ) ; if ( parent == parent class ) { return child class ; } if ( parent == null ) { return null ; } child class = parent ; } }	Returns the class of the immediate subclass of the given parent class forthe given object instance; or null if such immediate subclass cannot beuniquely identified for the given object instance.
public static jar file jar file of ( final class < ? > klass ) { url url = klass . get resource ( str + klass . get name ( ) . replace ( str , str ) + str ) ; if ( url == null ) { return null ; } string s = url . get file ( ) ; int begin index = s . index of ( str ) + str . length ( ) ; int end index = s . index of ( str ) ; if ( end index == - num ) { return null ; } end index += str . length ( ) ; string f = s . substring ( begin index , end index ) ;	Returns the jar file from which the given class is loaded; or nullif no such jar file can be located.
public static void sleep ( final long ms ) { try { thread . sleep ( ms ) ; } catch ( interrupted exception iex ) { thread . current thread ( ) . interrupt ( ) ; } }	Puts a thread to sleep, without throwing an InterruptedException.
public static void sleep ( ) { try { thread . sleep ( long . max value ) ; } catch ( interrupted exception iex ) { thread . current thread ( ) . interrupt ( ) ; } }	Puts a thread to sleep forever.
public static void wait ( final object obj ) { synchronized ( obj ) { try { obj . wait ( ) ; } catch ( interrupted exception inex ) { thread . current thread ( ) . interrupt ( ) ; } } }	Waits for a object for synchronization purposes.
public static thread factory daemon thread factory ( final string name , final int priority ) { return new thread factory ( ) { private atomic integer count = new atomic integer ( ) ; @ override public thread new thread ( final runnable r ) { thread thread = new thread ( r ) ; thread . set name ( name + str + count . increment and get ( ) ) ; thread . set daemon ( bool ) ; thread . set priority ( priority ) ; return thread ; } } ; }	Creates new daemon thread factory.
@ override public t get ( ) { if ( ! initialized ) { synchronized ( this ) { if ( ! initialized ) { final t t = supplier . get ( ) ; value = t ; initialized = bool ; supplier = null ; return t ; } } } return value ; }	Returns the value. Value will be computed on first call.
public void visit parameter ( final string name , final int access ) { if ( api < opcodes . as ) { throw new unsupported operation exception ( requires as ) ; } if ( mv != null ) { mv . visit parameter ( name , access ) ; } }	Visits a parameter of this method.
public annotation visitor visit annotation ( final string descriptor , final boolean visible ) { if ( mv != null ) { return mv . visit annotation ( descriptor , visible ) ; } return null ; }	Visits an annotation of this method.
public void visit field insn ( final int opcode , final string owner , final string name , final string descriptor ) { if ( mv != null ) { mv . visit field insn ( opcode , owner , name , descriptor ) ; } }	Visits a field instruction.
public void visit method insn ( final int opcode , final string owner , final string name , final string descriptor , final boolean is interface ) { if ( api < opcodes . as ) { if ( is interface != ( opcode == opcodes . invokeinterface ) ) { throw new illegal argument exception ( str ) ; } visit method insn ( opcode , owner , name , descriptor ) ; return ; } if ( mv != null ) { mv . visit method insn ( opcode , owner , name , descriptor , is interface ) ; } }	Visits a method instruction.
public void visit invoke dynamic insn ( final string name , final string descriptor , final handle bootstrap method handle , final object ... bootstrap method arguments ) { if ( api < opcodes . as ) { throw new unsupported operation exception ( requires as ) ; } if ( mv != null ) { mv . visit invoke dynamic insn ( name , descriptor , bootstrap method handle , bootstrap method arguments ) ; } }	Visits an invokedynamic instruction.
public void visit jump insn ( final int opcode , final label label ) { if ( mv != null ) { mv . visit jump insn ( opcode , label ) ; } }	Visits a jump instruction.
public void visit multi a ( final string descriptor , final int num dimensions ) { if ( mv != null ) { mv . visit multi a ( descriptor , num dimensions ) ; } }	Visits a MULTIANEWARRAY instruction.
public void visit try catch block ( final label start , final label end , final label handler , final string type ) { if ( mv != null ) { mv . visit try catch block ( start , end , handler , type ) ; } }	Visits a try catch block.
void convert to writer ( final writer writer , final properties properties , final map < string , properties > profiles ) throws io { final buffered writer bw = get buffered writer ( writer ) ; write base and profile properties ( bw , properties , profiles ) ; write profile properties that are not in the base ( bw , properties , profiles ) ; bw . flush ( ) ; }	Convert Java Properties to Jodd Props format.
@ override public void process stream ( ) throws io { fast byte array output stream out = new fast byte array output stream ( ) ; size = num ; if ( max file size == - num ) { size += input . copy all ( out ) ; } else { size += input . copy max ( out , max file size + num ) ;	Reads data from input stream into byte array and stores file size.
@ override public t next ( ) { if ( has next == null ) { has next = boolean . value of ( move to next ( ) ) ; } if ( has next == bool ) { throw new no such element exception ( ) ; } if ( ! entity aware mode ) { has next = null ; return new element ; } count ++ ; t result = previous element ; previous element = new element ; has next = null ; return result ; }	Returns next mapped object.
private boolean move to next ( ) { if ( last ) {	Moves to next element.
@ suppress warnings ( { str } ) public static < t > t [ ] join ( t [ ] ... arrays ) { class < t > component type = ( class < t > ) arrays . get class ( ) . get component type ( ) . get component type ( ) ; return join ( component type , arrays ) ; }	Joins arrays. Component type is resolved from the array argument.
@ suppress warnings ( { str } ) public static < t > t [ ] join ( class < t > component type , t [ ] [ ] arrays ) { if ( arrays . length == num ) { return arrays [ num ] ; } int length = num ; for ( t [ ] array : arrays ) { length += array . length ; } t [ ] result = ( t [ ] ) array . new instance ( component type , length ) ; length = num ; for ( t [ ] array : arrays ) { system . arraycopy ( array , num , result , length , array . length ) ; length += array . length ; } return result ; }	Joins arrays using provided component type.
public static < t > t [ ] resize ( t [ ] buffer , int new size ) { class < t > component type = ( class < t > ) buffer . get class ( ) . get component type ( ) ; t [ ] temp = ( t [ ] ) array . new instance ( component type , new size ) ; system . arraycopy ( buffer , num , temp , num , buffer . length >= new size ? new size : buffer . length ) ; return temp ; }	Resizes an array.
public static < t > t [ ] append ( t [ ] buffer , t new element ) { t [ ] t = resize ( buffer , buffer . length + num ) ; t [ buffer . length ] = new element ; return t ; }	Appends an element to array.
@ suppress warnings ( { str } ) public static < t > t [ ] remove ( t [ ] buffer , int offset , int length , class < t > component type ) { int len2 = buffer . length - length ; t [ ] temp = ( t [ ] ) array . new instance ( component type , len2 ) ; system . arraycopy ( buffer , num , temp , num , offset ) ; system . arraycopy ( buffer , offset + length , temp , offset , len2 - offset ) ; return temp ; }	Removes sub-array.
public static int index of ( char [ ] array , char value ) { for ( int i = num ; i < array . length ; i ++ ) { if ( array [ i ] == value ) { return i ; } } return - num ; }	Finds the first occurrence of an element in an array.
public static int index of ( object [ ] array , object value ) { for ( int i = num ; i < array . length ; i ++ ) { if ( array [ i ] . equals ( value ) ) { return i ; } } return - num ; }	Finds the first occurrence in an array.
public static int index of ( byte [ ] array , byte [ ] sub , int start index ) { return index of ( array , sub , start index , array . length ) ; }	Finds the first occurrence in an array from specified given position.
public dom enable xhtml mode ( ) { config . ignore whitespaces between tags = bool ;	Enables XHTML mode.
@ override public document parse ( final char [ ] content ) { lagarto parser lagarto parser = new lagarto parser ( content ) ; return do parse ( lagarto parser ) ; }	Creates DOM tree from provided content.
protected document do parse ( final lagarto parser lagarto parser ) { lagarto parser . set config ( config ) ; dom dom builder tag visitor = new dom ( this ) ; lagarto parser . parse ( dom builder tag visitor ) ; return dom builder tag visitor . get document ( ) ; }	Parses the content using provided lagarto parser.
private void compute max stack and local ( ) {	Computes the maximum stack size of the method.
private void end current basic block with no successor ( ) { if ( compute == compute all frames ) { label next basic block = new label ( ) ; next basic block . frame = new frame ( next basic block ) ; next basic block . resolve ( code . data , code . length ) ; last basic block . next basic block = next basic block ; last basic block = next basic block ; current basic block = null ; } else if ( compute == compute max stack and local ) { current basic block . output stack max = ( short ) max relative stack size ; current basic block = null ; } }	Ends the current basic block.
final void collect attribute prototypes ( final attribute . set attribute prototypes ) { attribute prototypes . add attributes ( first attribute ) ; attribute prototypes . add attributes ( first code attribute ) ; }	Collects the attributes of this method into the given set of attribute prototypes.
public void inject context ( final object target object ) { final class target type = target object . get class ( ) ; final scope data scope data = scope data inspector . inspect class scopes with cache ( target type ) ; final targets targets = new targets ( target object , scope data ) ;	Inject context into target.
public static void register pseudo class ( final class < ? extends pseudo class > pseudo class type ) { pseudo class pseudo class ; try { pseudo class = class util . new instance ( pseudo class type ) ; } catch ( exception ex ) { throw new cs ( ex ) ; } pseudo class map . put ( pseudo class . get pseudo class name ( ) , pseudo class ) ; }	Registers pseudo class.
public static pseudo class lookup pseudo class ( final string pseudo class name ) { pseudo class pseudo class = pseudo class map . get ( pseudo class name ) ; if ( pseudo class == null ) { throw new cs ( str + pseudo class name ) ; } return pseudo class ; }	Lookups pseudo class for given pseudo class name.
public void invoke ( final action request action request ) { if ( executor service == null ) { throw new madvoc exception ( str ) ; } final http servlet request servlet request = action request . get http servlet request ( ) ; log . debug ( ( ) -> str + action request ) ; final async context async context = servlet request . start async ( ) ; executor service . submit ( ( ) -> { try { action request . invoke ( ) ; } catch ( exception ex ) { log . error ( str , exception util . unwrap throwable ( ex ) ) ; } finally { async context . complete ( ) ; } } ) ; }	Invokes an action asynchronously by submitting it to the thread pool.
protected string [ ] get all bean property names ( final class type , final boolean declared ) { class descriptor class descriptor = class introspector . get ( ) . lookup ( type ) ; property descriptor [ ] property descriptors = class descriptor . get all property descriptors ( ) ; array list < string > names = new array list < > ( property descriptors . length ) ; for ( property descriptor property descriptor : property descriptors ) { method descriptor getter = property descriptor . get read method descriptor ( ) ; if ( getter != null ) { if ( getter . match declared ( declared ) ) { names . add ( property descriptor . get name ( ) ) ; } } else if ( include fields ) { field descriptor field = property descriptor . get field descriptor ( ) ; if ( field != null ) { if ( field . match declared ( declared ) ) { names . add ( field . get name ( ) ) ; } } } } return names . to array ( new string [ num ] ) ; }	Returns all bean property names.
public void visit ( ) { string [ ] properties = resolve properties ( source , declared ) ; for ( string name : properties ) { if ( name == null ) { continue ; } if ( ! rules . match ( name , blacklist ) ) { continue ; } object value ; string property name = name ; if ( is source map ) { property name = left sq bracket + name + right sq bracket ; } if ( declared ) { value = bean util . declared . get property ( source , property name ) ; } else { value = bean util . pojo . get property ( source , property name ) ; } if ( value == null && ignore null values ) { continue ; } if ( value instanceof string && string util . is empty ( ( string ) value ) ) { continue ; } visit property ( name , value ) ; } }	Starts visiting properties.
@ override public boolean accept ( final string property name , final string rule , final boolean include ) { return property name . equals ( rule ) ; }	Compares property name to the rules.
public method injection point [ ] resolve ( final class type ) {	Resolve method injection points in given class.
protected void read filter config parameters ( final filter config filter config , final object target , final string ... parameters ) { for ( string parameter : parameters ) { string value = filter config . get init parameter ( parameter ) ; if ( value != null ) { bean util . declared . set property ( target , parameter , value ) ; } } }	Reads filter config parameters and set into destination target.
protected void send bundle file ( final http servlet response resp , final file bundle file ) throws io { output stream out = resp . get output stream ( ) ; file input stream file input stream = new file input stream ( bundle file ) ; try { stream util . copy ( file input stream , out ) ; } finally { stream util . close ( file input stream ) ; } }	Outputs bundle file to the response.
public file lookup bundle file ( string bundle id ) { if ( ( mirrors != null ) && ( ! mirrors . is empty ( ) ) ) { string real bundle id = mirrors . remove ( bundle id ) ; if ( real bundle id != null ) { bundle id = real bundle id ; } } return create bundle file ( bundle id ) ; }	Lookups for bundle file.
public file lookup gzip bundle file ( final file file ) throws io { string path = file . get path ( ) + zip util . gzip ext ; file gzip file = new file ( path ) ; if ( ! gzip file . exists ( ) ) { if ( log . is debug enabled ( ) ) { log . debug ( str + path ) ; } zip util . gzip ( file ) ; } return gzip file ; }	Locates gzipped version of bundle file.
public synchronized string register bundle ( final string context path , final string action path , final string temp bundle id , final string bundle content type , final list < string > sources ) { if ( temp bundle id == null || sources . is empty ( ) ) { if ( strategy == strategy . action managed ) {	Registers new bundle that consist of provided list of source paths.Returns the real bundle id, as provided one is just a temporary bundle id.
protected string create digest ( final string source ) { final digest engine digest engine = digest engine . sha256 ( ) ; final byte [ ] bytes = digest engine . digest ( char util . to simple byte array ( source ) ) ; string digest = base32 . encode ( bytes ) ; if ( unique digest key != null ) { digest += unique digest key ; } return digest ; }	Creates digest i.e. bundle id from given string.Returned digest must be filename safe, for all platforms.
protected void create bundle ( final string context path , final string action path , final string bundle id , final list < string > sources ) throws io { final file bundle file = create bundle file ( bundle id ) ; if ( bundle file . exists ( ) ) { return ; } string band sb = new string band ( sources . size ( ) * num ) ; for ( string src : sources ) { if ( sb . length ( ) != num ) { sb . append ( string pool . newline ) ; } string content ; if ( is external resource ( src ) ) { content = download string ( src ) ; } else { if ( ! download local ) {	Creates bundle file by loading resource files content. If bundle file alreadyexist it will not be recreated!.
public synchronized void reset ( ) { if ( strategy == strategy . action managed ) { action bundles . clear ( ) ; mirrors . clear ( ) ; } final find file ff = new find file ( ) ; ff . include dirs ( bool ) ; ff . search path ( new file ( bundle folder , stapler path ) ) ; file f ; int count = num ; while ( ( f = ff . next file ( ) ) != null ) { f . delete ( ) ; count ++ ; } if ( log . is info enabled ( ) ) { log . info ( str + count + str ) ; } }	Clears all settings and removes all created bundle files from file system.
protected string fix css relative urls ( final string content , final string src ) { final string path = file name util . get path ( src ) ; final matcher matcher = css url pattern . matcher ( content ) ; final string builder sb = new string builder ( content . length ( ) ) ; int start = num ; while ( matcher . find ( ) ) { sb . append ( content , start , matcher . start ( ) ) ; final string matched url = string util . remove chars ( matcher . group ( num ) , str ) ; final string url ; if ( matched url . starts with ( str ) || matched url . starts with ( str ) || matched url . starts with ( str ) ) { url = str + matched url + str ; } else { url = fix relative url ( matched url , path ) ; } sb . append ( url ) ; start = matcher . end ( ) ; } sb . append ( content . substring ( start ) ) ; return sb . to string ( ) ; }	Returns the content with all relative URLs fixed.
public db sql builder update column ( final object entity , final string column ref ) { final object value = bean util . pojo . get property ( entity , column ref ) ; return update column ( entity , column ref , value ) ; }	Reads property value and updates the DB.
protected static string create table ref name ( final object entity ) { class type = entity . get class ( ) ; type = ( type == class . class ? ( class ) entity : type ) ; return ( type . get simple name ( ) + str ) ; }	Creates table reference name from entity type.Always appends an underscore to reference name in orderto circumvent SQL compatibility issues when entity class nameequals to a reserved word.
@ override public db session get db session ( ) { log . debug ( str ) ; final db jtx transaction jtx = ( db jtx transaction ) jtx tx manager . get transaction ( ) ; if ( jtx == null ) { throw new db sql exception ( str + str ) ; } return jtx . request resource ( ) ; }	Returns session from JTX transaction manager and started transaction.
protected t [ ] convert to single element array ( final object value ) { t [ ] single element array = create array ( num ) ; single element array [ num ] = convert type ( value ) ; return single element array ; }	Creates an array with single element.
public map < string , string > parse signature for generics ( final string signature , final boolean is interface ) { if ( signature == null ) { return collections . empty map ( ) ; } final map < string , string > generics map = new hash map < > ( ) ; signature reader sr = new signature reader ( signature ) ; string builder sb = new string builder ( ) ; trace signature visitor v = new trace signature visitor ( sb , is interface ) { string generic name ; @ override public void visit formal type parameter ( final string name ) { generic name = name ; super . visit formal type parameter ( name ) ; } @ override public void visit class type ( final string name ) { if ( generic name != null ) { generics map . put ( generic name , str + name + str ) ; generic name = null ; } super . visit class type ( name ) ; } } ; sr . accept ( v ) ; return generics map ; }	Parses signature for generic information and returns a map where key is generic nameand value is raw type.
public set injection point [ ] resolve ( final class type , final boolean autowire ) { class descriptor cd = class introspector . get ( ) . lookup ( type ) ; list < set injection point > list = new array list < > ( ) ; property descriptor [ ] all properties = cd . get all property descriptors ( ) ; for ( property descriptor property descriptor : all properties ) { if ( property descriptor . is getter only ( ) ) { continue ; } class property type = property descriptor . get type ( ) ; if ( ! class util . is type of ( property type , collection . class ) ) { continue ; } method descriptor write method descriptor = property descriptor . get write method descriptor ( ) ; field descriptor field descriptor = property descriptor . get field descriptor ( ) ; petite inject ref = null ; if ( write method descriptor != null ) { ref = write method descriptor . get method ( ) . get annotation ( petite inject . class ) ; } if ( ref == null && field descriptor != null ) { ref = field descriptor . get field ( ) . get annotation ( petite inject . class ) ; } if ( ( ! autowire ) && ( ref == null ) ) { continue ; } list . add ( new set injection point ( property descriptor ) ) ; } set injection point [ ] fields ; if ( list . is empty ( ) ) { fields = set injection point . empty ; } else { fields = list . to array ( new set injection point [ num ] ) ; } return fields ; }	Resolves all collections for given type.
public boolean match ignored property types ( final class property type , final boolean exclude maps , final boolean include ) { if ( ! include ) { return bool ; } if ( property type != null ) { if ( ! json serializer . deep ) { class descriptor property type class descriptor = class introspector . get ( ) . lookup ( property type ) ; if ( property type class descriptor . is array ( ) ) { return bool ; } if ( property type class descriptor . is collection ( ) ) { return bool ; } if ( exclude maps ) { if ( property type class descriptor . is map ( ) ) { return bool ; } } }	Matches property types that are ignored by default.
protected void open connection for query ( ) { if ( connection == null ) { connection = connection provider . get connection ( ) ; tx active = bool ;	Opens connection in auto-commit mode, if already not opened.
protected void open tx ( ) { if ( connection == null ) { connection = connection provider . get connection ( ) ; } tx active = bool ; try { connection . set auto commit ( bool ) ; if ( tx mode . get isolation ( ) != db transaction mode . isolation default ) { connection . set transaction isolation ( tx mode . get isolation ( ) ) ; } connection . set read only ( tx mode . is read only ( ) ) ; } catch ( sql sex ) { throw new db sql exception ( str , sex ) ; } }	Opens a transaction.
protected void close tx ( ) { tx active = bool ; try { connection . set auto commit ( bool ) ; } catch ( sql sex ) { throw new db sql exception ( str , sex ) ; } }	Closes current transaction.
public void commit transaction ( ) { log . debug ( str ) ; assert tx is active ( ) ; try { connection . commit ( ) ; } catch ( sql sex ) { throw new db sql exception ( str , sex ) ; } finally { close tx ( ) ; } }	Commit the current transaction, writing any unflushed changes to the database.Transaction mode is closed.
public void rollback transaction ( ) { log . debug ( str ) ; assert tx is active ( ) ; try { connection . rollback ( ) ; } catch ( sql sex ) { throw new db sql exception ( str , sex ) ; } finally { close tx ( ) ; } }	Roll back the current transaction.
public static properties create from file ( final file file ) throws io { properties prop = new properties ( ) ; load from file ( prop , file ) ; return prop ; }	Create properties from the file.
public static properties create from string ( final string data ) throws io { properties p = new properties ( ) ; load from string ( p , data ) ; return p ; }	Creates properties from string.
public static void load from string ( final properties p , final string data ) throws io { try ( byte array input stream is = new byte array input stream ( data . get bytes ( string pool . iso 8859 1 ) ) ) { p . load ( is ) ; } }	Loads properties from string.
public static properties subset ( final properties p , string prefix , final boolean strip prefix ) { if ( string util . is blank ( prefix ) ) { return p ; } if ( ! prefix . ends with ( string pool . dot ) ) { prefix += str ; } properties result = new properties ( ) ; int base len = prefix . length ( ) ; for ( object o : p . key set ( ) ) { string key = ( string ) o ; if ( key . starts with ( prefix ) ) { result . set property ( strip prefix ? key . substring ( base len ) : key , p . get property ( key ) ) ; } } return result ; }	Creates new Properties object from the original one, by copyingthose properties that have specified first part of the key name.Prefix may be optionally stripped during this process.
public static properties create from classpath ( final string ... root template ) { properties p = new properties ( ) ; return load from classpath ( p , root template ) ; }	Creates properties from classpath.
public static string get property ( final map map , final string key , final string default value ) { object val = map . get ( key ) ; return ( val instanceof string ) ? ( string ) val : default value ; }	Returns String property from a map.
public static void resolve all variables ( final properties prop ) { for ( object o : prop . key set ( ) ) { string key = ( string ) o ; string value = resolve property ( prop , key ) ; prop . set property ( key , value ) ; } }	Resolves all variables.
public static string resolve property ( final map map , final string key ) { string value = get property ( map , key ) ; if ( value == null ) { return null ; } value = stp . parse ( value , macro name -> get property ( map , macro name ) ) ; return value ; }	Returns property with resolved variables.
public string resolve scope ( final class type , final string method name ) { if ( scope pattern == null ) { return null ; } string ctx = scope pattern ; ctx = string util . replace ( ctx , jtxctx pattern class , type . get name ( ) ) ; ctx = string util . replace ( ctx , jtxctx pattern method , method name ) ; return ctx ; }	Resolves tx scope from scope pattern.
public synchronized jtx transaction mode get tx mode ( final class type , final string method name , final class [ ] method arg types , final string unique ) { string signature = type . get name ( ) + str + method name + str + unique ; jtx transaction mode tx mode = txmap . get ( signature ) ; if ( tx mode == null ) { if ( ! txmap . contains key ( signature ) ) { final method m ; try { m = type . get method ( method name , method arg types ) ; } catch ( no such method exception nsmex ) { throw new proxetta exception ( nsmex ) ; } final transaction annotation values tx ann = read transaction annotation ( m ) ; if ( tx ann != null ) { tx mode = new jtx transaction mode ( tx ann . propagation ( ) , tx ann . isolation ( ) , tx ann . read only ( ) , tx ann . timeout ( ) ) ; } else { tx mode = default transaction mode ; } txmap . put ( signature , tx mode ) ; } } return tx mode ; }	Reads transaction mode from method annotation.
@ suppress warnings ( { str } ) public void register annotations ( final class < ? extends annotation > [ ] annotations ) { this . annotations = annotations ; this . annotation parsers = new annotation parser [ annotations . length ] ; for ( int i = num ; i < annotations . length ; i ++ ) { annotation parsers [ i ] = transaction annotation values . parser for ( annotations [ i ] ) ; } }	Registers new TX annotations.
protected transaction annotation values read transaction annotation ( final method method ) { for ( annotation parser annotation parser : annotation parsers ) { transaction annotation values tad = transaction annotation values . of ( annotation parser , method ) ; if ( tad != null ) { return tad ; } } return null ; }	Finds TX annotation.
@ override public boolean accept ( final node node ) {	Accepts single node.
protected boolean match element ( final node node ) { if ( node . get node type ( ) != node . node type . element ) { return bool ; } string element = get element ( ) ; string node name = node . get node name ( ) ; return element . equals ( string pool . star ) || element . equals ( node name ) ; }	Matches element to css selector.
public boolean accept ( final list < node > current results , final node node , final int index ) {	Accepts node within current results.
protected string unescape ( final string value ) { if ( value . index of ( str ) == - num ) { return value ; } return string util . remove ( value , str ) ; }	Unescapes CSS string by removing all backslash characters from it.
private string [ ] build jre packages ( final int java version number ) { final array list < string > packages = new array list < > ( ) ; switch ( java version number ) { case num : case num : case num : case num : case num :	Builds a set of java core packages.
protected < t extends node > t clone to ( final t dest ) {	Copies all non-final values to the empty cloned object.Cache-related values are not copied.
public void detach from parent ( ) { if ( parent node == null ) { return ; } if ( parent node . child nodes != null ) { parent node . child nodes . remove ( sibling index ) ; parent node . reindex children ( ) ; } parent node = null ; }	Removes this node from DOM tree.
public void add child ( final node ... nodes ) { if ( nodes . length == num ) { return ;	Appends several child nodes at once.Reindex is done only once, after all children are added.
public void insert child ( final node node , final int index ) { node . detach from parent ( ) ; node . parent node = this ; try { init child nodes ( node ) ; child nodes . add ( index , node ) ; } catch ( index out of bounds exception ignore ) { throw new dom ( str + index ) ; } reindex children ( ) ; }	Inserts node at given index.
public void insert before ( final node new child , final node ref child ) { int sibling index = ref child . get sibling index ( ) ; ref child . parent node . insert child ( new child , sibling index ) ; }	Inserts node before provided node.
public void insert before ( final node [ ] new childs , final node ref child ) { if ( new childs . length == num ) { return ; } int sibling index = ref child . get sibling index ( ) ; ref child . parent node . insert child ( new childs , sibling index ) ; }	Inserts several child nodes before provided node.
public void insert after ( final node new child , final node ref child ) { int sibling index = ref child . get sibling index ( ) + num ; if ( sibling index == ref child . parent node . get child nodes count ( ) ) { ref child . parent node . add child ( new child ) ; } else { ref child . parent node . insert child ( new child , sibling index ) ; } }	Inserts node after provided node.
public void insert after ( final node [ ] new childs , final node ref child ) { if ( new childs . length == num ) { return ; } int sibling index = ref child . get sibling index ( ) + num ; if ( sibling index == ref child . parent node . get child nodes count ( ) ) { ref child . parent node . add child ( new childs ) ; } else { ref child . parent node . insert child ( new childs , sibling index ) ; } }	Inserts several child nodes after referent node.
public void remove all childs ( ) { list < node > removed nodes = child nodes ; child nodes = null ; child element nodes = null ; child element nodes count = num ; if ( removed nodes != null ) { for ( int i = num , removed nodes size = removed nodes . size ( ) ; i < removed nodes size ; i ++ ) { node removed node = removed nodes . get ( i ) ; removed node . detach from parent ( ) ; } } }	Removes all child nodes.
public node find child node with name ( final string name ) { if ( child nodes == null ) { return null ; } for ( final node child node : child nodes ) { if ( child node . get node name ( ) . equals ( name ) ) { return child node ; } } return null ; }	Finds the first child node with given node name.
public node [ ] filter child nodes ( final predicate < node > node predicate ) { if ( child nodes == null ) { return new node [ num ] ; } return child nodes . stream ( ) . filter ( node predicate ) . to array ( node [ ] :: new ) ; }	Filters child nodes.
public boolean check ( ) { if ( child nodes == null ) { return bool ; }	Checks the health of child nodes.
protected void init child element nodes ( ) { if ( child element nodes == null ) { child element nodes = new element [ child element nodes count ] ; int child count = get child nodes count ( ) ; for ( int i = num ; i < child count ; i ++ ) { node child = get child ( i ) ; if ( child . sibling element index >= num ) { child element nodes [ child . sibling element index ] = ( element ) child ; } } } }	Initializes list of child elements.
protected void init sibling names ( ) { if ( sibling name index == - num ) { list < node > siblings = parent node . child nodes ; int index = num ; for ( int i = num , siblings size = siblings . size ( ) ; i < siblings size ; i ++ ) { node sibling = siblings . get ( i ) ; if ( sibling . sibling name index == - num && node type == node type . element && node name . equals ( sibling . get node name ( ) ) ) { sibling . sibling name index = index ++ ; } } } }	Initializes siblings elements of the same name.
protected void init child nodes ( final node new node ) { if ( child nodes == null ) { child nodes = new array list < > ( ) ; } if ( owner document != null ) { if ( new node . owner document != owner document ) { change owner document ( new node , owner document ) ; } } }	Initializes child nodes list when needed.Also fix owner document for new node, if needed.
protected void change owner document ( final node node , final document owner document ) { node . owner document = owner document ; int child count = node . get child nodes count ( ) ; for ( int i = num ; i < child count ; i ++ ) { node child = node . get child ( i ) ; change owner document ( child , owner document ) ; } }	Changes owner document for given node and all its children.
public node get previous sibling name ( ) { if ( node name == null ) { return null ; } init sibling names ( ) ; int index = sibling name index - num ; for ( int i = sibling index ; i >= num ; i -- ) { node sibling = parent node . child nodes . get ( i ) ; if ( ( index == sibling . sibling name index ) && node name . equals ( sibling . get node name ( ) ) ) { return sibling ; } } return null ; }	Returns this node's previous sibling element with the same name.
public string get text content ( ) { string builder sb = new string builder ( get child nodes count ( ) + num ) ; append text content ( sb ) ; return sb . to string ( ) ; }	Returns the text content of this node and its descendants.
public string get inner html ( ) { lagarto dom builder config lagarto dom builder config ; if ( owner document == null ) { lagarto dom builder config = ( ( document ) this ) . get config ( ) ; } else { lagarto dom builder config = owner document . get config ( ) ; } lagarto html renderer lagarto html renderer = lagarto dom builder config . get lagarto html renderer ( ) ; return lagarto html renderer . to inner html ( this , new string builder ( ) ) ; }	Generates inner HTML.
protected void visit children ( final node visitor node visitor ) { if ( child nodes != null ) { for ( int i = num , child nodes size = child nodes . size ( ) ; i < child nodes size ; i ++ ) { node child node = child nodes . get ( i ) ; child node . visit ( node visitor ) ; } } }	Visits children nodes.
public string get css path ( ) { string builder path = new string builder ( ) ; node node = this ; while ( node != null ) { string node name = node . get node name ( ) ; if ( node name != null ) { string builder sb = new string builder ( ) ; sb . append ( str ) . append ( node name ) ; string id = node . get attribute ( str ) ; if ( id != null ) { sb . append ( str ) . append ( id ) ; } path . insert ( num , sb ) ; } node = node . get parent node ( ) ; } if ( path . char at ( num ) == str ) { return path . substring ( num ) ; } return path . to string ( ) ; }	Returns CSS path to this node from document root.
protected void on decora tag ( final tag tag ) { string tag name = tag . get name ( ) . to string ( ) ; if ( tag . get type ( ) == tag type . self closing ) { check nested decora tags ( ) ; decora tag name = tag name . substring ( num ) ; decora tag start = tag . get tag position ( ) ; decora tag end = tag . get tag position ( ) + tag . get tag length ( ) ; define decora tag ( ) ; return ; } if ( tag . get type ( ) == tag type . start ) { check nested decora tags ( ) ; decora tag name = tag name . substring ( num ) ; decora tag start = tag . get tag position ( ) ; decora tag default value start = tag . get tag position ( ) + tag . get tag length ( ) ; return ; }	Handle Decora tags.
protected void on id attr start ( final tag tag ) { string id = tag . get id ( ) . to string ( ) . substring ( num ) ; string tag name ; string id name ; int dash index = id . index of ( str ) ; if ( dash index == - num ) { tag name = id ; id name = null ; } else { tag name = id . substring ( num , dash index ) ; id name = id . substring ( dash index + num ) ; } if ( tag . get type ( ) == tag type . self closing ) { check nested decora tags ( ) ; decora tag name = tag name ; decora id name = id name ; decora tag start = tag . get tag position ( ) ; decora tag end = tag . get tag position ( ) + tag . get tag length ( ) ; define decora tag ( ) ; return ; } if ( tag . get type ( ) == tag type . start ) { check nested decora tags ( ) ; decora tag name = tag name ; decora id name = id name ; decora tag start = tag . get tag position ( ) ; decora tag default value start = tag . get tag position ( ) + tag . get tag length ( ) ; closing tag name = tag . get name ( ) . to string ( ) ; closing tag deep level = tag . get deep level ( ) ; } }	Handle open and empty ID attribute tags.
protected void define decora tag ( ) { decora tag decora tag = decora tag default value start == num ? new decora tag ( decora tag name , decora id name , decora tag start , decora tag end ) : new decora tag ( decora tag name , decora id name , decora tag start , decora tag end , decora tag default value start , decora tag default value end - decora tag default value start ) ; decora tags . add ( decora tag ) ; decora tag name = null ; decora id name = null ; closing tag name = null ; decora tag default value start = num ; }	Defines Decora tag position inside decorator content.Resets current Decora tag tracking.
@ override public joy proxetta add proxy aspect ( final proxy aspect proxy aspect ) { require not started ( proxetta ) ; this . proxy aspects . add ( proxy aspect ) ; return this ; }	Adds a proxy aspect.
public void add root package ( final string root package , string mapping ) { if ( packages == null ) { packages = new string [ num ] ; } if ( mappings == null ) { mappings = new string [ num ] ; }	Adds root package and its path mapping.
public void add root package of ( final class action class , final string mapping ) { add root package ( action class . get package ( ) . get name ( ) , mapping ) ; }	Sets root package to package of given class.
public string find root package for action path ( final string action path ) { if ( mappings == null ) { return null ; } int ndx = - num ; int delta = integer . max value ; for ( int i = num ; i < mappings . length ; i ++ ) { string mapping = mappings [ i ] ; boolean found = bool ; if ( action path . equals ( mapping ) ) { found = bool ; } else { mapping += string pool . slash ; if ( action path . starts with ( mapping ) ) { found = bool ; } } if ( found ) { int distance = action path . length ( ) - mapping . length ( ) ; if ( distance < delta ) { ndx = i ; delta = distance ; } } } if ( ndx == - num ) { return null ; } return packages [ ndx ] ; }	Finds closest root package for the given action path.
public static string resolve validation message ( final http servlet request request , final violation violation ) { validation constraint vc = violation . get constraint ( ) ; string key = vc != null ? vc . get class ( ) . get name ( ) : violation . get name ( ) ; string msg = localization util . find message ( request , key ) ; if ( msg != null ) { return bean template parser . parse with bean ( msg , violation ) ; } return null ; }	Prepares validation messages.Key is either validation constraint class name or violation name.
public bean references remove duplicate names ( ) { if ( names . length < num ) { return this ; } int null count = num ; for ( int i = num ; i < names . length ; i ++ ) { string this ref = names [ i ] ; if ( this ref == null ) { null count ++ ; continue ; } for ( int j = num ; j < i ; j ++ ) { if ( names [ j ] == null ) { continue ; } if ( this ref . equals ( names [ j ] ) ) { names [ i ] = null ; break ; } } } if ( null count == num ) { return this ; } string [ ] new refs = new string [ names . length - null count ] ; int ndx = num ; for ( string name : names ) { if ( name == null ) { continue ; } new refs [ ndx ] = name ; ndx ++ ; } return new bean references ( new refs ) ; }	Removes later duplicated references in an array.Returns new instance of BeanReferences if there was changes,otherwise returns the same instance.
@ override public joy props add props file ( final string name pattern ) { require not started ( props ) ; this . props name patterns . add ( name pattern ) ; return this ; }	Adds props files or patterns.
public void for each target ( final consumer < target > target consumer ) { for ( final target target : targets ) { target consumer . accept ( target ) ; } }	Iterates all targets.
public void for each target and in ( final madvoc scope scope , final bi consumer < target , injection point > bi consumer ) { for ( final target target : targets ) { final scope data scope data = target . scope data ( ) ; if ( scope data . in ( ) == null ) { continue ; } for ( final injection point in : scope data . in ( ) ) { if ( in . scope ( ) != scope ) { continue ; } bi consumer . accept ( target , in ) ; } } }	Iterates all targets and for each target iterates all IN injection points of given scope.
public void for each target and out ( final madvoc scope scope , final bi consumer < target , injection point > bi consumer ) { for ( final target target : targets ) { final scope data scope data = target . scope data ( ) ; if ( scope data . out ( ) == null ) { continue ; } for ( final injection point out : scope data . out ( ) ) { if ( out . scope ( ) != scope ) { continue ; } bi consumer . accept ( target , out ) ; } } }	Iterates all targets and for each target iterates all OUT injection points of given scope.
public object [ ] extract parameters values ( ) { final object [ ] values = new object [ targets . length - num ] ; for ( int i = num ; i < targets . length ; i ++ ) { values [ i - num ] = targets [ i ] . value ( ) ; } return values ; }	Collects all parameters from target into an array.
protected target [ ] make targets ( final target action target , final method param [ ] method params ) { if ( method params == null ) {	Joins action and parameters into one single array of Targets.
@ suppress warnings ( { str , str } ) protected object create action method argument ( final class type , final object action ) { try { if ( type . get enclosing class ( ) == null || modifier . is static ( type . get modifiers ( ) ) ) {	Creates action method arguments.
@ override public void session created ( final http session event http session event ) { http session session = http session event . get session ( ) ; session map . put if absent ( session . get id ( ) , session ) ; for ( http session listener listener : listeners ) { listener . session created ( http session event ) ; } }	Stores session in map and broadcasts event to registered listeners.
@ override public void session destroyed ( final http session event http session event ) { http session session = http session event . get session ( ) ; session map . remove ( session . get id ( ) ) ; for ( http session listener listener : listeners ) { listener . session destroyed ( http session event ) ; } }	Removes session from a map and broadcasts event to registered listeners.
public json array add ( object value ) { objects . require non null ( value ) ; value = json object . resolve value ( value ) ; list . add ( value ) ; return this ; }	Adds an object to the JSON array.
public json array add all ( final json array array ) { objects . require non null ( array ) ; list . add all ( array . list ) ; return this ; }	Appends all of the elements in the specified array to the end of this JSON array.
public object remove ( final int pos ) { object removed = list . remove ( pos ) ; if ( removed instanceof map ) { return new json object ( ( map ) removed ) ; } if ( removed instanceof array list ) { return new json array ( ( list ) removed ) ; } return removed ; }	Removes the value at the specified position in the JSON array.
protected string resolve target ( final action request action request , final string result value ) { string result base path = action request . get action runtime ( ) . get result base path ( ) ; result path result path = result mapper . resolve result path ( result base path , result value ) ; string action path = result path . path ( ) ; string path = action path ; string value = result path . value ( ) ; if ( string util . is empty ( value ) ) { value = null ; } string target ; while ( bool ) {	Locates the target file from action path and the result value.
protected void target not found ( final action request action request , final string action and result path ) throws io { final http servlet response response = action request . get http servlet response ( ) ; if ( ! response . is committed ( ) ) { response . send error ( sc not found , str + action and result path ) ; } }	Called when target not found.
protected string value to string ( final string name , final object value object ) { if ( ! value object . get class ( ) . is array ( ) ) { return value object . to string ( ) ; }	Converts value to a string.
@ suppress warnings ( str ) public < t extends action filter > madvoc router filter ( final class < t > action filter class ) { filters manager . resolve ( action filter class ) ; return this ; }	Returns action filter instance for further configuration.
public string get pseudo function name ( ) { string name = get class ( ) . get simple name ( ) . to lower case ( ) ; name = name . replace ( str , str ) ; return name ; }	Returns pseudo-function name.
public property injection point [ ] resolve ( class type , final boolean autowire ) { final list < property injection point > list = new array list < > ( ) ; final set < string > used property names = new hash set < > ( ) ;	Resolves all properties for given type.
private socket create socks4 proxy socket ( final string host , final int port ) { socket socket = null ; final string proxy host = proxy . get proxy address ( ) ; final int proxy port = proxy . get proxy port ( ) ; final string user = proxy . get proxy username ( ) ; try { socket = sockets . connect ( proxy host , proxy port , connection timeout ) ; final input stream in = socket . get input stream ( ) ; final output stream out = socket . get output stream ( ) ; socket . set tcp no delay ( bool ) ; byte [ ] buf = new byte [ num ] ;	Connects to the SOCKS4 proxy and returns proxified socket.
final int get attribute count ( ) { int count = num ; attribute attribute = this ; while ( attribute != null ) { count += num ; attribute = attribute . next attribute ; } return count ; }	Returns the number of attributes of the attribute list that begins with this attribute.
public set < action result > get all action results ( ) { final set < action result > set = new hash set < > ( all results . size ( ) ) ; all results . for each value ( set :: add ) ; return set ; }	Returns all action results as new set.
public static boolean equals one ( final char c , final char sequence match ) { for ( int i = num ; i < match . length ( ) ; i ++ ) { char a match = match . char at ( i ) ; if ( c == a match ) { return bool ; } } return bool ; }	Match if one character equals to any of the given character.
public static int find first equal ( final char sequence source , final int index , final char sequence match ) { for ( int i = index ; i < source . length ( ) ; i ++ ) { if ( equals one ( source . char at ( i ) , match ) ) { return i ; } } return - num ; }	Finds index of the first character in given charsequence the matches any from thegiven set of characters.
public static int find first equal ( final char [ ] source , final int index , final char match ) { for ( int i = index ; i < source . length ; i ++ ) { if ( source [ i ] == match ) { return i ; } } return - num ; }	Finds index of the first character in given array the matches any from thegiven set of characters.
public command line args ( final string ... arguments ) { if ( arguments != null && arguments . length > num ) { collections . add all ( cmd line , arguments ) ; } return this ; }	Adds several arguments.
public command line env ( final string key , final string value ) { if ( env == null ) { env = new hash map < > ( ) ; } env . put ( key , value ) ; return this ; }	Sets environment variable.
public process runner . process result run ( ) { byte array output stream baos = new byte array output stream ( ) ; out = err = baos ; try { baos . write ( string util . join ( cmd line , str ) . get bytes ( ) ) ; baos . write ( string pool . bytes new line ) ; } catch ( io ignore ) { } process builder process builder = new process builder ( ) ; process builder . command ( cmd line ) ; if ( clean environment ) { process builder . environment ( ) . clear ( ) ; } if ( env != null ) { process builder . environment ( ) . put all ( env ) ; } process builder . directory ( working directory ) ; process process = null ; try { process = process builder . start ( ) ; } catch ( io ioex ) { return write exception ( baos , ioex ) ; } stream gobbler output gobbler = new stream gobbler ( process . get input stream ( ) , out , out prefix ) ; stream gobbler error gobbler = new stream gobbler ( process . get error stream ( ) , err , err prefix ) ; output gobbler . start ( ) ; error gobbler . start ( ) ; int result ; try { result = process . wait for ( ) ; } catch ( interrupted exception iex ) { return write exception ( baos , iex ) ; } output gobbler . wait for ( ) ; error gobbler . wait for ( ) ; return new process runner . process result ( result , baos . to string ( ) ) ; }	Runs command and returns process result.
public static void invoke ( final object listener , final class listener type ) { if ( listener type == init . class ) { ( ( init ) listener ) . init ( ) ; return ; } if ( listener type == start . class ) { ( ( start ) listener ) . start ( ) ; return ; } if ( listener type == ready . class ) { ( ( ready ) listener ) . ready ( ) ; return ; } if ( listener type == stop . class ) { ( ( stop ) listener ) . stop ( ) ; return ; } throw new madvoc exception ( str ) ; }	Invoke the listener based on type.Not very OOP, but works.
final void copy from ( final frame frame ) { input locals = frame . input locals ; input stack = frame . input stack ; output stack start = num ; output locals = frame . output locals ; output stack = frame . output stack ; output stack top = frame . output stack top ; initialization count = frame . initialization count ; initializations = frame . initializations ; }	Sets this frame to the value of the given frame.
private static int get abstract type from descriptor ( final symbol table symbol table , final string buffer , final int offset ) { string internal name ; switch ( buffer . char at ( offset ) ) { case str : return num ; case str : case str : case str : case str : case str : return integer ; case str : return float ; case str : return long ; case str : return double ; case str : internal name = buffer . substring ( offset + num , buffer . length ( ) - num ) ; return reference kind | symbol table . add type ( internal name ) ; case str : int element descriptor offset = offset + num ; while ( buffer . char at ( element descriptor offset ) == str ) { ++ element descriptor offset ; } int type value ; switch ( buffer . char at ( element descriptor offset ) ) { case str : type value = boolean ; break ; case str : type value = char ; break ; case str : type value = byte ; break ; case str : type value = short ; break ; case str : type value = integer ; break ; case str : type value = float ; break ; case str : type value = long ; break ; case str : type value = double ; break ; case str : internal name = buffer . substring ( element descriptor offset + num , buffer . length ( ) - num ) ; type value = reference kind | symbol table . add type ( internal name ) ; break ; default : throw new illegal argument exception ( ) ; } return ( ( element descriptor offset - offset ) << dim shift ) | type value ; default : throw new illegal argument exception ( ) ; } }	Returns the abstract type corresponding to the given type descriptor.
final void set input frame from api format ( final symbol table symbol table , final int num local , final object [ ] local , final int num stack , final object [ ] stack ) { int input local index = num ; for ( int i = num ; i < num local ; ++ i ) { input locals [ input local index ++ ] = get abstract type from api format ( symbol table , local [ i ] ) ; if ( local [ i ] == opcodes . long || local [ i ] == opcodes . double ) { input locals [ input local index ++ ] = top ; } } while ( input local index < input locals . length ) { input locals [ input local index ++ ] = top ; } int num stack top = num ; for ( int i = num ; i < num stack ; ++ i ) { if ( stack [ i ] == opcodes . long || stack [ i ] == opcodes . double ) { ++ num stack top ; } } input stack = new int [ num stack + num stack top ] ; int input stack index = num ; for ( int i = num ; i < num stack ; ++ i ) { input stack [ input stack index ++ ] = get abstract type from api format ( symbol table , stack [ i ] ) ; if ( stack [ i ] == opcodes . long || stack [ i ] == opcodes . double ) { input stack [ input stack index ++ ] = top ; } } output stack top = num ; initialization count = num ; }	Sets the input frame from the given public API frame description.
private int get local ( final int local index ) { if ( output locals == null || local index >= output locals . length ) {	Returns the abstract type stored at the given local variable index in the output frame.
private void set local ( final int local index , final int abstract type ) {	Replaces the abstract type stored at the given local variable index in the output frame.
private void push ( final int abstract type ) {	Pushes the given abstract type on the output frame stack.
private void push ( final symbol table symbol table , final string descriptor ) { int type descriptor offset = descriptor . char at ( num ) == str ? descriptor . index of ( str ) + num : num ; int abstract type = get abstract type from descriptor ( symbol table , descriptor , type descriptor offset ) ; if ( abstract type != num ) { push ( abstract type ) ; if ( abstract type == long || abstract type == double ) { push ( top ) ; } } }	Pushes the abstract type corresponding to the given descriptor on the output frame stack.
private void pop ( final int elements ) { if ( output stack top >= elements ) { output stack top -= elements ; } else {	Pops the given number of abstract types from the output frame stack.
private void pop ( final string descriptor ) { char first descriptor char = descriptor . char at ( num ) ; if ( first descriptor char == str ) { pop ( ( type . get arguments and return sizes ( descriptor ) > > num ) - num ) ; } else if ( first descriptor char == str || first descriptor char == str ) { pop ( num ) ; } else { pop ( num ) ; } }	Pops as many abstract types from the output frame stack as described by the given descriptor.
private void add initialized type ( final int abstract type ) {	Adds an abstract type to the list of types on which a constructor is invoked in the basicblock.
private int get initialized type ( final symbol table symbol table , final int abstract type ) { if ( abstract type == uninitialized this || ( abstract type & ( dim mask | kind mask ) ) == uninitialized kind ) { for ( int i = num ; i < initialization count ; ++ i ) { int initialized type = initializations [ i ] ; int dim = initialized type & dim mask ; int kind = initialized type & kind mask ; int value = initialized type & value mask ; if ( kind == local kind ) { initialized type = dim + input locals [ value ] ; } else if ( kind == stack kind ) { initialized type = dim + input stack [ input stack . length - value ] ; } if ( abstract type == initialized type ) { if ( abstract type == uninitialized this ) { return reference kind | symbol table . add type ( symbol table . get class name ( ) ) ; } else { return reference kind | symbol table . add type ( symbol table . get type ( abstract type & value mask ) . value ) ; } } } } return abstract type ; }	Returns the "initialized" abstract type corresponding to the given abstract type.
static void put abstract type ( final symbol table symbol table , final int abstract type , final byte vector output ) { int array dimensions = ( abstract type & frame . dim mask ) > > dim shift ; if ( array dimensions == num ) { int type value = abstract type & value mask ; switch ( abstract type & kind mask ) { case constant kind : output . put byte ( type value ) ; break ; case reference kind : output . put byte ( item object ) . put short ( symbol table . add constant class ( symbol table . get type ( type value ) . value ) . index ) ; break ; case uninitialized kind : output . put byte ( item uninitialized ) . put short ( ( int ) symbol table . get type ( type value ) . data ) ; break ; default : throw new assertion error ( ) ; } } else {	Put the given abstract type in the given ByteVector, using the JVMS verification_type_infoformat used in StackMapTable attributes.
@ override protected int prune cache ( ) { int count = num ; iterator < cache object < k , v > > values = cache map . values ( ) . iterator ( ) ; while ( values . has next ( ) ) { cache object co = values . next ( ) ; if ( co . is expired ( ) ) { values . remove ( ) ; count ++ ; } } return count ; }	Prunes expired elements from the cache.
public module visitor visit module ( final string name , final int access , final string version ) { if ( api < opcodes . as ) { throw new unsupported operation exception ( str ) ; } if ( cv != null ) { return cv . visit module ( name , access , version ) ; } return null ; }	Visit the module corresponding to the class.
public void visit outer class ( final string owner , final string name , final string descriptor ) { if ( cv != null ) { cv . visit outer class ( owner , name , descriptor ) ; } }	Visits the enclosing class of the class.
public annotation visitor visit annotation ( final string descriptor , final boolean visible ) { if ( cv != null ) { return cv . visit annotation ( descriptor , visible ) ; } return null ; }	Visits an annotation of the class.
public static db thread session get thread session ( ) { db thread session session = ( db thread session ) thread db session holder . get ( ) ; if ( session == null ) { session = new db thread session ( ) ; } return session ; }	Returns existing thread session, or new one if already not exist.
public static void close thread session ( ) { db thread session session = ( db thread session ) thread db session holder . get ( ) ; if ( session != null ) { session . close session ( ) ; } }	Closes thread session.
protected action wrapper [ ] create execution array ( ) { int total interceptors = ( this . action runtime . get interceptors ( ) != null ? this . action runtime . get interceptors ( ) . length : num ) ; int total filters = ( this . action runtime . get filters ( ) != null ? this . action runtime . get filters ( ) . length : num ) ; action wrapper [ ] execution array = new action wrapper [ total filters + num + total interceptors + num ] ;	Creates execution array that will invoke all filters, actions and resultsin correct order.
protected object invoke action method ( ) throws exception { if ( action runtime . is action handler defined ( ) ) { action runtime . get action handler ( ) . handle ( this ) ; return null ; } final object [ ] params = targets . extract parameters values ( ) ; try { return action runtime . get action class method ( ) . invoke ( action , params ) ; } catch ( invocation target exception itex ) { throw wrap to exception ( unwrap throwable ( itex ) ) ; } }	Invokes action method after starting all interceptors.After method invocation, all interceptors will finish, in opposite order.
public string read request body ( ) { if ( request body == null ) { try { request body = servlet util . read request body from stream ( get http servlet request ( ) ) ; } catch ( io ioex ) { request body = string pool . empty ; } } return request body ; }	Reads request body only once and returns it to user.
public static int calc first item index of page ( int page , final int page size , final int total ) { if ( total == num ) { return num ; } if ( page < num ) { page = num ; } int first = ( page - num ) * page size ; if ( first >= total ) { first = ( ( total - num ) / page size ) * page size ;	Calculates the first item index of requested page.
public static int calc first item index of page ( final page request page request , final int total ) { return calc first item index of page ( page request . get page ( ) , page request . get size ( ) , total ) ; }	Calculates first item index of the page.
public boolean match ( final int value ) { if ( a == num ) { return value == b ; } if ( a > num ) { if ( value < b ) { return bool ; } return ( value - b ) % a == num ; } if ( value > b ) { return bool ; } return ( b - value ) % ( - a ) == num ; }	Matches expression with the value.
public static byte [ ] to raw byte array ( final char [ ] carr ) { byte [ ] barr = new byte [ carr . length << num ] ; for ( int i = num , bpos = num ; i < carr . length ; i ++ ) { char c = carr [ i ] ; barr [ bpos ++ ] = ( byte ) ( ( c & num ) > > num ) ; barr [ bpos ++ ] = ( byte ) ( c & num ) ; } return barr ; }	Converts char array into byte array by replacing each character with two bytes.
public static int find first diff ( final char [ ] source , final int index , final char [ ] match ) { for ( int i = index ; i < source . length ; i ++ ) { if ( ! equals one ( source [ i ] , match ) ) { return i ; } } return - num ; }	Finds index of the first character in given array the differs from thegiven set of characters.
protected string resolve node name ( final node node ) { switch ( tag case ) { case default : return node . get node name ( ) ; case raw : return node . get node raw name ( ) ; case lowercase : return node . get node raw name ( ) . to lower case ( ) ; case uppercase : return node . get node raw name ( ) . to upper case ( ) ; } return null ; }	Renders node name.
protected string resolve attribute name ( final node node , final attribute attribute ) { switch ( attribute case ) { case default : return attribute . get name ( ) ; case raw : return attribute . get raw name ( ) ; case lowercase : return attribute . get raw name ( ) . to lower case ( ) ; case uppercase : return attribute . get raw name ( ) . to upper case ( ) ; } return null ; }	Renders attribute name.
public props load ( final file file ) throws io { final string extension = file name util . get extension ( file . get absolute path ( ) ) ; final string data ; if ( extension . equals ignore case ( str ) ) { data = file util . read string ( file , string pool . iso 8859 1 ) ; } else { data = file util . read string ( file ) ; } parse ( data ) ; return this ; }	Loads props from the file.
public props load ( final file file , final string encoding ) throws io { parse ( file util . read string ( file , encoding ) ) ; return this ; }	Loads properties from the file in provided encoding.
public props load ( final input stream in ) throws io { final writer out = new fast char array writer ( ) ; stream util . copy ( in , out ) ; parse ( out . to string ( ) ) ; return this ; }	Loads properties from input stream.
public props load ( final map < ? , ? > p ) { for ( final map . entry < ? , ? > entry : p . entry set ( ) ) { final string name = entry . get key ( ) . to string ( ) ; final object value = entry . get value ( ) ; if ( value == null ) { continue ; } data . put base property ( name , value . to string ( ) , bool ) ; } return this ; }	Loads base properties from the provided java properties.Null values are ignored.
@ suppress warnings ( str ) public props load ( final map < ? , ? > map , final string prefix ) { string real prefix = prefix ; real prefix += str ; for ( final map . entry entry : map . entry set ( ) ) { final string name = entry . get key ( ) . to string ( ) ; final object value = entry . get value ( ) ; if ( value == null ) { continue ; } data . put base property ( real prefix + name , value . to string ( ) , bool ) ; } return this ; }	Loads base properties from java Map using provided prefix.Null values are ignored.
public props load from classpath ( final string ... patterns ) { class scanner . create ( ) . register entry consumer ( entry data -> { string used encoding = jodd core . encoding ; if ( string util . ends with ignore case ( entry data . name ( ) , str ) ) { used encoding = string pool . iso 8859 1 ; } final string encoding = used encoding ; unchecked exception . run and wrap exception ( ( ) -> load ( entry data . open input stream ( ) , encoding ) ) ; } ) . include resources ( bool ) . ignore exception ( bool ) . exclude common jars ( ) . exclude all entries ( bool ) . include entries ( patterns ) . scan default classpath ( ) . start ( ) ; return this ; }	Loads props and properties from the classpath.
public string get value or default ( final string key , final string default value ) { initialize ( ) ; final string value = data . lookup value ( key , active profiles ) ; if ( value == null ) { return default value ; } return value ; }	Returns value of property, using active profiles or default value if not found.
public void set value ( final string key , final string value , final string profile ) { if ( profile == null ) { data . put base property ( key , value , bool ) ; } else { data . put profile property ( key , value , profile , bool ) ; } initialized = bool ; }	Sets value on some profile.
public void extract props ( final map target ) { initialize ( ) ; data . extract ( target , active profiles , null , null ) ; }	Extracts props belonging to active profiles.
public void extract props ( final map target , final string ... profiles ) { initialize ( ) ; data . extract ( target , profiles , null , null ) ; }	Extract props of given profiles.
public void extract sub props ( final map target , final string ... wildcard patterns ) { initialize ( ) ; data . extract ( target , active profiles , wildcard patterns , null ) ; }	Extracts subset of properties that matches given wildcards.
@ suppress warnings ( str ) public map < string , object > inner map ( final string prefix ) { initialize ( ) ; return data . extract ( null , active profiles , null , prefix ) ; }	Returns inner map from the props with given prefix.
public void add inner map ( string prefix , final map < ? , ? > map , final string profile ) { if ( ! string util . ends with char ( prefix , str ) ) { prefix += string pool . dot ; } for ( map . entry < ? , ? > entry : map . entry set ( ) ) { string key = entry . get key ( ) . to string ( ) ; key = prefix + key ; set value ( key , entry . get value ( ) . to string ( ) , profile ) ; } }	Adds child map to the props on given prefix.
protected void resolve active profiles ( ) { if ( active profiles prop == null ) { active profiles = null ; return ; } final props entry pv = data . get base property ( active profiles prop ) ; if ( pv == null ) {	Resolves active profiles from special property.This property can be only a base property!If default active property is not defined, nothing happens.Otherwise, it will replace currently active profiles.
public string [ ] get all profiles ( ) { string [ ] profiles = new string [ data . profile properties . size ( ) ] ; int index = num ; for ( string profile name : data . profile properties . key set ( ) ) { profiles [ index ] = profile name ; index ++ ; } return profiles ; }	Returns all profiles names.
public string [ ] get profiles for ( final string prop key name wildcard ) { hash set < string > profiles = new hash set < > ( ) ; profile : for ( map . entry < string , map < string , props entry > > entries : data . profile properties . entry set ( ) ) { string profile name = entries . get key ( ) ; map < string , props entry > value = entries . get value ( ) ; for ( string prop key name : value . key set ( ) ) { if ( wildcard . equals or match ( prop key name , prop key name wildcard ) ) { profiles . add ( profile name ) ; continue profile ; } } } return profiles . to array ( new string [ num ] ) ; }	Returns all the profiles that define certain prop's key name.Key name is given as a wildcard, or it can be matched fully.
protected void add property injection point ( final property injection point pip ) { if ( properties == null ) { properties = new property injection point [ num ] ; properties [ num ] = pip ; } else { properties = arrays util . append ( properties , pip ) ; } }	Adds property injection point.
protected void add set injection point ( final set injection point sip ) { if ( sets == null ) { sets = new set injection point [ num ] ; sets [ num ] = sip ; } else { sets = arrays util . append ( sets , sip ) ; } }	Adds set injection point.
protected void add method injection point ( final method injection point mip ) { if ( methods == null ) { methods = new method injection point [ num ] ; methods [ num ] = mip ; } else { methods = arrays util . append ( methods , mip ) ; } }	Adds method injection point.
protected void add init method points ( final init method point [ ] methods ) { if ( init methods == null ) { init methods = methods ; } else { init methods = arrays util . join ( init methods , methods ) ; } }	Adds init methods.
protected void add destroy method points ( final destroy method point [ ] methods ) { if ( destroy methods == null ) { destroy methods = methods ; } else { destroy methods = arrays util . join ( destroy methods , methods ) ; } }	Adds destroy methods.
public static class resolve target class ( final class proxy ) { final string name = proxy . get name ( ) ; if ( name . ends with ( proxetta names . proxy class name suffix ) ) { return proxy . get superclass ( ) ; } if ( name . ends with ( proxetta names . wrapper class name suffix ) ) { return get target wrapper type ( proxy ) ; } return proxy ; }	Returns target class if proxetta applied on given class.If not, returns given class as result.
public static void inject target into wrapper ( final object target , final object wrapper ) { inject target into wrapper ( target , wrapper , proxetta names . wrapper target field name ) ; }	Injects target instance into proxy using default target field name.
public static class get target wrapper type ( final class wrapper class ) { try { final field field = wrapper class . get declared field ( proxetta names . wrapper target field name ) ; return field . get type ( ) ; } catch ( no such field exception nsfex ) { throw new proxetta exception ( nsfex ) ; } }	Returns wrapper target type.
protected field descriptor find field ( final string field name ) { field descriptor field descriptor = class descriptor . get field descriptor ( field name , bool ) ; if ( field descriptor != null ) { return field descriptor ; }	Locates property field. Field is being searched also in allsuperclasses of current class.
public class get type ( ) { if ( type == null ) { if ( field descriptor != null ) { type = field descriptor . get raw type ( ) ; } else if ( read method descriptor != null ) { type = get getter ( bool ) . get getter raw type ( ) ;	Returns property type. Raw types are detected.
public class resolve key type ( final boolean declared ) { class key type = null ; getter getter = get getter ( declared ) ; if ( getter != null ) { key type = getter . get getter raw key component type ( ) ; } if ( key type == null ) { field descriptor field descriptor = get field descriptor ( ) ; if ( field descriptor != null ) { key type = field descriptor . get raw key component type ( ) ; } } return key type ; }	Resolves key type for given property descriptor.
public class resolve component type ( final boolean declared ) { class component type = null ; getter getter = get getter ( declared ) ; if ( getter != null ) { component type = getter . get getter raw component type ( ) ; } if ( component type == null ) { field descriptor field descriptor = get field descriptor ( ) ; if ( field descriptor != null ) { component type = field descriptor . get raw component type ( ) ; } } return component type ; }	Resolves component type for given property descriptor.
public static json result of ( final object object ) { final string json = json serializer . create ( ) . deep ( bool ) . serialize ( object ) ; return new json result ( json ) ; }	Creates JSON result from given object.
public static json result of ( final exception exception ) { final hash map < string , object > error map = new hash map < > ( ) ; error map . put ( str , exception util . message ( exception ) ) ; error map . put ( str , exception . get class ( ) . get name ( ) ) ; error map . put ( str , exception . get cause ( ) != null ? exception . get cause ( ) . get class ( ) . get name ( ) : null ) ; final array list < string > details = new array list < > ( ) ; final stack trace element [ ] ste = exception util . get stack trace ( exception , null , null ) ; for ( stack trace element stack trace element : ste ) { details . add ( stack trace element . to string ( ) ) ; } error map . put ( str , details ) ; final string json = json serializer . create ( ) . deep ( bool ) . serialize ( error map ) ; return new json result ( json ) . status ( http status . error500 ( ) . internal error ( ) ) ; }	Creates a JSON response from an exception.
protected string resolve http method from method name ( final string method name ) { int i = num ; while ( i < method name . length ( ) ) { if ( char util . is uppercase alpha ( method name . char at ( i ) ) ) { break ; } i ++ ; } final string name = method name . substring ( num , i ) . to upper case ( ) ; for ( final http method http method : http method . values ( ) ) { if ( http method . equals name ( name ) ) { return http method . name ( ) ; } } return null ; }	Resolves HTTP method name from method name.If method name or first camel-case word of a method equals toa HTTP method, it will be used as that HTTP methods.
private static boolean match ( final char sequence string , final char sequence pattern , int s ndx , int p ndx ) { int p len = pattern . length ( ) ; if ( p len == num ) { if ( pattern . char at ( num ) == str ) {	Internal matching recursive function.
protected loading resolve loading ( final boolean parent first strategy , final string class name ) { boolean with parent = bool ; boolean with loader = bool ; if ( parent first strategy ) { if ( is matching rules ( class name , loader only rules ) ) { with parent = bool ; } else if ( is matching rules ( class name , parent only rules ) ) { with loader = bool ; } } else { if ( is matching rules ( class name , parent only rules ) ) { with loader = bool ; } else if ( is matching rules ( class name , loader only rules ) ) { with parent = bool ; } } return new loading ( with parent , with loader ) ; }	Resolves loading rules.
@ override protected synchronized class < ? > load class ( final string class name , final boolean resolve ) throws class not found exception {	Loads class using parent-first or parent-last strategy.
@ override public url get resource ( final string resource name ) { url url = null ; loading loading = resolve resource loading ( parent first , resource name ) ; if ( parent first ) {	Returns a resource using parent-first or parent-last strategy.
public void wait for ( ) { try { synchronized ( lock ) { if ( ! end ) { lock . wait ( ) ; } } } catch ( interrupted exception ignore ) { thread . current thread ( ) . interrupt ( ) ; } }	Waits for gobbler to end.
public class < ? extends annotation > detect annotation type ( final annotation [ ] annotations ) { for ( final annotation annotation : annotations ) { if ( annotation instanceof in ) { return annotation . annotation type ( ) ; } else if ( annotation instanceof out ) { return annotation . annotation type ( ) ; } } return null ; }	Scans annotation and returns type of Madvoc annotations.
protected injection point build injection point ( final string annotation value , final string property name , final class property type , final class < ? extends madvoc scope > scope ) { final string value = annotation value . trim ( ) ; final string name , target name ; if ( string util . is not blank ( value ) ) { name = value ; target name = property name ; } else { name = property name ; target name = null ; } return new injection point ( property type , name , target name , scope resolver . default or scope type ( scope ) ) ; }	Builds injection point.
public void visit ( ) { class descriptor class descriptor = class introspector . get ( ) . lookup ( type ) ; if ( class metadata name != null ) {	Visits a type.
public static url [ ] of ( class loader class loader , class clazz ) { if ( clazz == null ) { clazz = ur . class ; } if ( class loader == null ) { class loader = clazz . get class loader ( ) ; } final set < url > urls = new linked hash set < > ( ) ; while ( class loader != null ) { if ( class loader instanceof url ) { final url url class loader = ( url ) class loader ; return url class loader . get ur ( ) ; } final url url = class module url ( class loader , clazz ) ; if ( url != null ) { urls . add ( url ) ; } class loader = class loader . get parent ( ) ; } return urls . to array ( new url [ num ] ) ; }	Returns urls for the classloader.
private void set bean ( final object bean ) { this . bean = bean ; this . cd = ( bean == null ? null : introspector . lookup ( bean . get class ( ) ) ) ; this . first = bool ; this . update property = bool ; }	Sets new bean instance.
public void update bean ( final object bean ) { this . set bean ( bean ) ; if ( this . cd != null && this . cd . is supplier ( ) ) { final object new bean = ( ( supplier ) this . bean ) . get ( ) ; set bean ( new bean ) ; } }	Updates the bean. Detects special case of suppliers.
private void load property descriptor ( ) { if ( update property ) { if ( cd == null ) { property descriptor = null ; } else { property descriptor = cd . get property descriptor ( name , bool ) ; } update property = bool ; } }	Loads property descriptor, if property was updated.
public db oom connect ( ) { connection provider . init ( ) ; final db detector db detector = new db detector ( ) ; db detector . detect database and configure db oom ( connection provider , db oom config ) ; return this ; }	Initializes the DbOom by connecting to the database.
public void add ( final iterator < t > iterator ) { if ( all iterators . contains ( iterator ) ) { throw new illegal argument exception ( str ) ; } all iterators . add ( iterator ) ; }	Adds an iterator to this composite.
private void print logo ( ) { system . out . println ( chalk256 . chalk ( ) . yellow ( ) . on ( jodd . jodd ) ) ; }	Prints a logo.
public void stop ( ) { joy props . stop ( ) ; try { joy db . stop ( ) ; joy petite . stop ( ) ; } catch ( exception ignore ) { } if ( log != null ) { log . info ( str ) ; } }	Stops the Joy.
protected socket create socket ( final string host , final int port , final int connection timeout ) throws io { final socket factory socket factory = get socket factory ( proxy , bool , bool , connection timeout ) ; if ( connection timeout < num ) { return socket factory . create socket ( host , port ) ; } else {	Creates a socket using socket factory.
protected ssl create ssl ( final string host , final int port , final int connection timeout , final boolean trust all , final boolean verify https host ) throws io { final socket factory socket factory = get socket factory ( proxy , bool , trust all , connection timeout ) ; final socket socket ; if ( connection timeout < num ) { socket = socket factory . create socket ( host , port ) ; } else {	Creates a SSL socket.
protected ssl get default ssl ( final boolean trust all certificates ) throws io { if ( trust all certificates ) { try { ssl sc = ssl . get instance ( ssl protocol ) ; sc . init ( null , trust managers . trust all certs , new java . security . secure random ( ) ) ; return sc . get socket factory ( ) ; } catch ( no such algorithm exception | key management exception e ) { throw new io ( e ) ; } } else { return ( ssl ) ssl . get default ( ) ; } }	Returns default SSL socket factory allowing setting trust managers.
protected socket factory get socket factory ( final proxy info proxy , final boolean ssl , final boolean trust all certificates , final int connection timeout ) throws io { switch ( proxy . get proxy type ( ) ) { case none : if ( ssl ) { return get default ssl ( trust all certificates ) ; } else { return socket factory . get default ( ) ; } case http : return new http ( proxy , connection timeout ) ; case sock : return new socks4 proxy socket factory ( proxy , connection timeout ) ; case sock : return new socks5 proxy socket factory ( proxy , connection timeout ) ; default : return null ; } }	Returns socket factory based on proxy type and SSL requirements.
public string random ( int count , final char [ ] chars ) { if ( count == num ) { return string pool . empty ; } final char [ ] result = new char [ count ] ; while ( count -- > num ) { result [ count ] = chars [ rnd . next int ( chars . length ) ] ; } return new string ( result ) ; }	Creates random string whose length is the number of characters specified.Characters are chosen from the set of characters specified.
public string random ( int count , final char start , final char end ) { if ( count == num ) { return string pool . empty ; } final char [ ] result = new char [ count ] ; final int len = end - start + num ; while ( count -- > num ) { result [ count ] = ( char ) ( rnd . next int ( len ) + start ) ; } return new string ( result ) ; }	Creates random string whose length is the number of characters specified.Characters are chosen from the provided range.
public string random ranges ( int count , final char ... ranges ) { if ( count == num ) { return string pool . empty ; } int i = num ; int len = num ; final int [ ] lens = new int [ ranges . length ] ; while ( i < ranges . length ) { int gap = ranges [ i + num ] - ranges [ i ] + num ; len += gap ; lens [ i ] = len ; i += num ; } final char [ ] result = new char [ count ] ; while ( count -- > num ) { char c = num ; int r = rnd . next int ( len ) ; for ( i = num ; i < ranges . length ; i += num ) { if ( r < lens [ i ] ) { r += ranges [ i ] ; if ( i != num ) { r -= lens [ i - num ] ; } c = ( char ) r ; break ; } } result [ count ] = c ; } return new string ( result ) ; }	Creates random string whose length is the number of characters specified.Characters are chosen from the multiple sets defined by range pairs.All ranges must be in acceding order.
@ suppress warnings ( str ) protected collection < object > new array instance ( final class target type ) { if ( target type == null || target type == list . class || target type == collection . class || target type . is array ( ) ) { return list supplier . get ( ) ; } if ( target type == set . class ) { return new hash set < > ( ) ; } try { return ( collection < object > ) target type . get declared constructor ( ) . new instance ( ) ; } catch ( exception e ) { throw new json exception ( e ) ; } }	Creates new type for JSON array objects.It returns a collection.Later, the collection will be converted into the target type.
protected void inject value into object ( final object target , final property descriptor pd , final object value ) { object converted value = value ; if ( value != null ) { class target class = pd . get type ( ) ; converted value = convert type ( value , target class ) ; } try { setter setter = pd . get setter ( bool ) ; if ( setter != null ) { setter . invoke setter ( target , converted value ) ; } } catch ( exception ex ) { throw new json exception ( ex ) ; } }	Injects value into the targets property.
protected object convert type ( final object value , final class target type ) { final class value class = value . get class ( ) ; if ( value class == target type ) { return value ; } try { return type converter manager . get ( ) . convert type ( value , target type ) ; } catch ( exception ex ) { if ( ! strict types ) { return null ; } throw new json exception ( str , ex ) ; } }	Converts type of the given value.
public void visit provide ( final string service , final string ... providers ) { if ( mv != null ) { mv . visit provide ( service , providers ) ; } }	Visit an implementation of a service.
@ suppress warnings ( str ) public static < a > type cache < a > create default ( ) { return ( type cache < a > ) defaults . implementation . get ( ) ; }	Creates default implementation of the type cache.
public t put ( final class < ? > type , final t value ) { return map . put ( type , value ) ; }	Add values to the map.
public method descriptor [ ] get all method descriptors ( ) { if ( all methods == null ) { final list < method descriptor > all methods list = new array list < > ( ) ; for ( method descriptor [ ] method descriptors : methods map . values ( ) ) { collections . add all ( all methods list , method descriptors ) ; } final method descriptor [ ] all methods = all methods list . to array ( new method descriptor [ num ] ) ; arrays . sort ( all methods , comparator . comparing ( md -> md . get method ( ) . get name ( ) ) ) ; this . all methods = all methods ; } return all methods ; }	Returns all methods. Cached. Lazy.
public static string resolve ip address ( final string hostname ) { try { inet address net address ; if ( hostname == null || hostname . equals ignore case ( local host ) ) { net address = inet address . get local host ( ) ; } else { net address = inet4 address . get by name ( hostname ) ; } return net address . get host address ( ) ; } catch ( unknown host exception ignore ) { return null ; } }	Resolves IP address from a hostname.
public static int get ip as int ( final string ip address ) { int ip int value = num ; string [ ] tokens = string util . splitc ( ip address , str ) ; for ( string token : tokens ) { if ( ip int value > num ) { ip int value <<= num ; } ip int value += integer . parse int ( token ) ; } return ip int value ; }	Returns IP address as integer.
public static boolean validate againt ip ( final string input ) { if ( input == null ) { return bool ; } int hit dots = num ; char [ ] data = input . to char array ( ) ; for ( int i = num ; i < data . length ; i ++ ) { char c = data [ i ] ; int b = num ; do { if ( c < str || c > str ) { return bool ; } b = ( b * num + c ) - num ; if ( ++ i >= data . length ) { break ; } c = data [ i ] ; } while ( c != str ) ; if ( b > num ) { return bool ; } hit dots ++ ; } return hit dots == num ; }	Checks given string against IP address v4 format.
public static string resolve host name ( final byte [ ] ip ) { try { inet address address = inet address . get by address ( ip ) ; return address . get host name ( ) ; } catch ( unknown host exception ignore ) { return null ; } }	Resolves host name from IP address bytes.
public static byte [ ] download bytes ( final string url ) throws io { try ( input stream input stream = new url ( url ) . open stream ( ) ) { return stream util . read bytes ( input stream ) ; } }	Downloads resource as byte array.
public static string download string ( final string url , final string encoding ) throws io { try ( input stream input stream = new url ( url ) . open stream ( ) ) { return new string ( stream util . read chars ( input stream , encoding ) ) ; } }	Downloads resource as String.
public static void download file ( final string url , final file file ) throws io { try ( input stream input stream = new url ( url ) . open stream ( ) ; readable byte channel rbc = channels . new channel ( input stream ) ; file channel file channel = file channel . open ( file . to path ( ) , standard open option . create , standard open option . truncate existing , standard open option . write ) ) { file channel . transfer from ( rbc , num , long . max value ) ; } }	Downloads resource to a file, potentially very efficiently.
public static socket connect ( final string hostname , final int port ) throws io { final socket socket = new socket ( ) ; socket . connect ( new inet socket address ( hostname , port ) ) ; return socket ; }	Creates a socket.
public static socket connect ( final string hostname , final int port , final int connection timeout ) throws io { final socket socket = new socket ( ) ; if ( connection timeout <= num ) { socket . connect ( new inet socket address ( hostname , port ) ) ; } else { socket . connect ( new inet socket address ( hostname , port ) , connection timeout ) ; } return socket ; }	Creates a socket with a timeout.
private static int get primitive class name index ( final string class name ) { int dot index = class name . index of ( str ) ; if ( dot index != - num ) { return - num ; } return arrays . binary search ( primitive type names , class name ) ; }	Detects if provided class name is a primitive type.Returns >= 0 number if so.
@ override public class load class ( final string class name , final class loader class loader ) throws class not found exception { string array class name = prepare array classname for loading ( class name ) ; if ( ( class name . index of ( str ) == - num ) && ( array class name == null ) ) {	Loads class by name.
protected class load array class by component type ( final string class name , final class loader class loader ) throws class not found exception { int ndx = class name . index of ( str ) ; int multi = string util . count ( class name , str ) ; string component type name = class name . substring ( num , ndx ) ; class component type = load class ( component type name , class loader ) ; if ( multi == num ) { return array . new instance ( component type , num ) . get class ( ) ; } int [ ] multi sizes ; if ( multi == num ) { multi sizes = new int [ ] { num , num } ; } else if ( multi == num ) { multi sizes = new int [ ] { num , num , num } ; } else { multi sizes = ( int [ ] ) array . new instance ( int . class , multi ) ; } return array . new instance ( component type , multi sizes ) . get class ( ) ; }	Loads array class using component type.
@ override public void shutdown ( ) { for ( final bean data bean data : instances . values ( ) ) { bean data . call destroy methods ( ) ; } instances . clear ( ) ; }	Iterate all beans and invokes registered destroy methods.
public static < t extends comparable > binary search < t > for array ( final t [ ] array ) { return new binary search < t > ( ) { @ override @ suppress warnings ( { str } ) protected int compare ( final int index , final t element ) { return array [ index ] . compare to ( element ) ; } @ override protected int get last index ( ) { return array . length - num ; } } ; }	Creates binary search wrapper over an array.
public static < t > binary search < t > for array ( final t [ ] array , final comparator < t > comparator ) { return new binary search < t > ( ) { @ override @ suppress warnings ( { str } ) protected int compare ( final int index , final t element ) { return comparator . compare ( array [ index ] , element ) ; } @ override protected int get last index ( ) { return array . length - num ; } } ; }	Creates binary search wrapper over an array with given comparator.
public t exclude ( final string ... excludes ) { for ( string ex : excludes ) { rules . exclude ( ex ) ; } return this ( ) ; }	Defines excluded property names.
public t include ( final string ... includes ) { for ( string in : includes ) { rules . include ( in ) ; } return this ( ) ; }	Defines included property names.
public t include as ( final class template ) { blacklist = bool ; string [ ] properties = get all bean property names ( template , bool ) ; include ( properties ) ; return this ( ) ; }	Defines included property names as public propertiesof given template class.
public void start ( final int start index ) { this . tag start index = start index ; this . name = null ; this . id ndx = - num ; this . attributes count = num ; this . tag length = num ; this . modified = bool ; this . type = tag type . start ; this . raw tag = bool ; }	Starts the tag with the index of first '<'.Resets all tag data.
public < t > void register component ( final string name , final class < t > component , final consumer < t > consumer ) { log . debug ( ( ) -> str + name + str + component . get name ( ) ) ; madpc . remove bean ( name ) ; madpc . register petite bean ( component , name , null , null , bool , consumer ) ; }	Registers Madvoc component with given name.
protected void resolve column db sql type ( final connection connection , final db entity column descriptor dec ) { if ( dec . db sql type != sql type . db sqltype unknown ) { return ; } result set rs = null ; db entity descriptor ded = dec . get db entity descriptor ( ) ; try { database meta data dmd = connection . get meta data ( ) ; rs = dmd . get columns ( null , ded . get schema name ( ) , ded . get table name ( ) , dec . get column name ( ) ) ; if ( rs . next ( ) ) { dec . db sql type = rs . get int ( str ) ; } else { dec . db sql type = sql type . db sqltype not available ; if ( log . is warn enabled ( ) ) { log . warn ( str + ded . to string ( ) + str + dec . get column name ( ) ) ; } } } catch ( sql sex ) { dec . db sql type = sql type . db sqltype not available ; if ( log . is warn enabled ( ) ) { log . warn ( str + ded . to string ( ) + str + dec . get column name ( ) , sex ) ; } } finally { db util . close ( rs ) ; } }	Resolves column db sql type and populates it in column descriptor if missing.
protected string preprocess sql ( string sql string ) {	Pre-process SQL before using it.
protected result set mapper create result set mapper ( final result set result set ) { final map < string , column data > column aliases = sqlgen != null ? sqlgen . get column data ( ) : null ; return new default result set mapper ( db oom , result set , column aliases , cache entities , this ) ; }	Factory for result sets mapper.
public < t > t find generated key ( final class < t > type ) { return find ( new class [ ] { type } , bool , get generated columns ( ) ) ; }	Finds generated key column of given type.
public void populate generated keys ( final object entity ) { final string [ ] generated columns = get generated column names ( ) ; if ( generated columns == null ) { return ; } db entity descriptor ded = db oom . entity manager ( ) . lookup type ( entity . get class ( ) ) ;	Populates entity with generated column values from executed query.
@ override protected < r extends action interceptor > r create wrapper ( final class < r > wrapper class ) { return petite container . create bean ( wrapper class ) ; }	Acquires interceptor from Petite container.
public q set bean ( final string bean name , final object bean ) { if ( bean == null ) { return this ( ) ; } init ( ) ; final string bean name prefix = bean name + str ; query . for each named parameter ( p -> { final string param name = p . name ; if ( param name . starts with ( bean name prefix ) ) { final string property name = param name . substring ( bean name prefix . length ( ) ) ; if ( bean util . declared . has root property ( bean , property name ) ) { final object value = bean util . declared . get property ( bean , property name ) ; set object ( param name , value ) ; } } } ) ; return this ( ) ; }	Sets bean parameters from bean.
public q set map ( final map parameters ) { if ( parameters == null ) { return this ( ) ; } init ( ) ; query . for each named parameter ( p -> { final string param name = p . name ; set object ( param name , parameters . get ( param name ) ) ; } ) ; return this ( ) ; }	Sets properties from the map.
public q set objects ( final object ... objects ) { int index = num ; for ( final object object : objects ) { set object ( index ++ , object ) ; } return this ( ) ; }	Sets an array of objects parameters in given order.
public void insert chunk after ( final sql chunk previous ) { sql chunk next = previous . next chunk ; previous . next chunk = this ; this . previous chunk = previous ; if ( next != null ) { next . previous chunk = this ; this . next chunk = next ; } }	Appends chunk to previous one and maintains the double-linked list of the previous chunk.Current surrounding connections of this chunk will be cut-off.
protected db entity descriptor lookup type ( final class entity ) { final db entity descriptor ded = db entity manager . lookup type ( entity ) ; if ( ded == null ) { throw new db sql builder exception ( str + entity . get name ( ) ) ; } return ded ; }	Lookups for entity name and throws an exception if entity type is invalid.
protected db entity descriptor find column ref ( final string column ref ) { db entity descriptor ded = template data . find table descriptor by column ref ( column ref ) ; if ( ded == null ) { throw new db sql builder exception ( str + column ref + str ) ; } return ded ; }	Finds a table that contains given column.
protected string resolve table ( final string table ref , final db entity descriptor ded ) { string table alias = template data . get table alias ( table ref ) ; if ( table alias != null ) { return table alias ; } return ded . get table name for query ( ) ; }	Resolves table name or alias that will be used in the query.
protected static class resolve class ( final object object ) { class type = object . get class ( ) ; return type == class . class ? ( class ) object : type ; }	Resolves object to a class.
protected void append missing space ( final string builder out ) { int len = out . length ( ) ; if ( len == num ) { return ; } len -- ; if ( ! char util . is whitespace ( out . char at ( len ) ) ) { out . append ( str ) ; } }	Appends missing space if the output doesn't end with whitespace.
public enumeration < string > get file parameter names ( ) { if ( mreq == null ) { return null ; } return collections . enumeration ( mreq . get file parameter names ( ) ) ; }	Get an enumeration of the parameter names for uploaded files.
public static boolean include ( final servlet request request , final servlet response response , final string page ) throws io , servlet exception { request dispatcher dispatcher = request . get request dispatcher ( page ) ; if ( dispatcher != null ) { dispatcher . include ( request , response ) ; return bool ; } return bool ; }	Include page which path is relative to the current HTTP request.
public static string get url ( final http servlet request request ) { string servlet path = request . get servlet path ( ) ; string query = request . get query string ( ) ; if ( ( query != null ) && ( query . length ( ) != num ) ) { servlet path += str + query ; } return servlet path ; }	Returns url, without context path, convenient for request dispatcher.
public static string get request uri ( final http servlet request request ) { string result = get include request uri ( request ) ; if ( result == null ) { result = request . get request uri ( ) ; } return result ; }	Get current request uri.
public string [ ] resolve param names ( final method action class method ) { method parameter [ ] method parameters = paramo . resolve parameters ( action class method ) ; string [ ] names = new string [ method parameters . length ] ; for ( int i = num ; i < method parameters . length ; i ++ ) { names [ i ] = method parameters [ i ] . get name ( ) ; } return names ; }	Returns method parameter names.
@ override public void start ( ) { init logger ( ) ; log . info ( str ) ; petite container = create petite container ( ) ; if ( externals cache ) { petite container . set externals cache ( type cache . create default ( ) ) ; } log . info ( str + is web application ) ; if ( ! is web application ) {	Creates and initializes Petite container.It will be auto-magically configured by scanning the classpath.
@ override public void stop ( ) { if ( log != null ) { log . info ( str ) ; } if ( petite container != null ) { petite container . shutdown ( ) ; } petite container = null ; }	Stops Petite container.
public email filter subject ( final string subject ) { final search term subject term = new subject term ( subject ) ; concat ( subject term ) ; return this ; }	Defines filter for SUBJECT field.
public email filter message id ( final string message id ) { final search term msg id term = new id ( message id ) ; concat ( msg id term ) ; return this ; }	Defines filter for message id.
public email filter from ( final string from address ) { final search term from term = new from string term ( from address ) ; concat ( from term ) ; return this ; }	Defines filter for FROM field.
public email filter to ( final string to address ) { final search term to term = new recipient string term ( recipient type . to , to address ) ; concat ( to term ) ; return this ; }	Defines filter for TO field.
public email filter cc ( final string cc address ) { final search term to term = new recipient string term ( recipient type . cc , cc address ) ; concat ( to term ) ; return this ; }	Defines filter for CC field.
public email filter bcc ( final string bcc address ) { final search term to term = new recipient string term ( recipient type . bcc , bcc address ) ; concat ( to term ) ; return this ; }	Defines filter for BCC field.
public email filter flags ( final flags flags , final boolean value ) { final search term flag term = new flag term ( flags , value ) ; concat ( flag term ) ; return this ; }	Defines filter for many flags at once.
public email filter flag ( final flag flag , final boolean value ) { final flags flags = new flags ( ) ; flags . add ( flag ) ; return flags ( flags , value ) ; }	Defines filter for single flag.
public email filter received date ( final operator operator , final long milliseconds ) { final search term term = new received date term ( operator . value , new date ( milliseconds ) ) ; concat ( term ) ; return this ; }	Defines filter for received date.
public email filter sent date ( final operator operator , final long milliseconds ) { final search term term = new sent date term ( operator . value , new date ( milliseconds ) ) ; concat ( term ) ; return this ; }	Defines filter for sent date.
public email filter size ( final operator comparison , final int size ) { final search term term = new size term ( comparison . value , size ) ; concat ( term ) ; return this ; }	Defines filter for message size.
public email filter and ( final email filter ... email filters ) { final search term [ ] search terms = new search term [ email filters . length ] ; for ( int i = num ; i < email filters . length ; i ++ ) { search terms [ i ] = email filters [ i ] . search term ; } concat ( new and term ( search terms ) ) ; return this ; }	Defines AND group of filters.
public email filter or ( final email filter ... email filters ) { final search term [ ] search terms = new search term [ email filters . length ] ; for ( int i = num ; i < email filters . length ; i ++ ) { search terms [ i ] = email filters [ i ] . search term ; } concat ( new or term ( search terms ) ) ; return this ; }	Defines OR group of filters.
public email filter not ( final email filter email filter ) { final search term search term = new not term ( email filter . search term ) ; concat ( search term ) ; return this ; }	Appends single filter as NOT.
protected void concat ( search term search term ) { if ( next is not ) { search term = new not term ( search term ) ; next is not = bool ; } if ( operator and ) { and ( search term ) ; } else { or ( search term ) ; } }	Concatenates last search term with new one.
public static string encode ( final byte [ ] bytes ) { string builder base32 = new string builder ( ( bytes . length * num + num ) / num ) ; int curr byte , digit , i = num ; while ( i < bytes . length ) {	Encode an array of binary bytes into a Base32 string.
protected boolean is gzip eligible ( final http servlet request request ) {	Determine if request is eligible for GZipping.
public list < violation > validate ( final object target ) { return validate ( validation context . resolve for ( target . get class ( ) ) , target ) ; }	Validate object using context from the annotations.
public list < violation > validate ( final validation context ctx , final object target , final string target name ) { for ( map . entry < string , list < check > > entry : ctx . map . entry set ( ) ) { string name = entry . get key ( ) ; object value = bean util . declared silent . get property ( target , name ) ; string value name = target name != null ? ( target name + str + name ) : name ;	Performs validation of provided validation context and appends violations.
public void use profile ( final string profile ) { if ( profile == null ) { return ; } if ( this . enabled profiles == null ) { this . enabled profiles = new hash set < > ( ) ; } this . enabled profiles . add ( profile ) ; }	Enables single profile.
public void use profiles ( final string ... enabled profiles ) { if ( enabled profiles == null ) { return ; } if ( this . enabled profiles == null ) { this . enabled profiles = new hash set < > ( ) ; } collections . add all ( this . enabled profiles , enabled profiles ) ; }	Enables list of profiles.
protected boolean match profiles ( final string [ ] check profiles ) {	Determine if any of checks profiles is among enabled profiles.
protected object parse request body ( final string body , final class target type ) { return json parser . create ( ) . parse ( body , target type ) ; }	Parses request body into the target type.
public long to milliseconds ( ) { double then = ( fraction - jd 1970 . fraction ) * millis in day ; then += ( integer - jd 1970 . integer ) * millis in day ; then += then > num ? num : - num ; return ( long ) then ; }	Converts to milliseconds.
public julian date add ( final julian date jds ) { int i = this . integer + jds . integer ; double f = this . fraction + jds . fraction ; return new julian date ( i , f ) ; }	Adds a JD to current instance.
public julian date sub ( final julian date jds ) { int i = this . integer - jds . integer ; double f = this . fraction - jds . fraction ; return new julian date ( i , f ) ; }	Subtracts a JD from current instance.
private void set ( final int i , double f ) { integer = i ; int fi = ( int ) f ; f -= fi ; integer += fi ; if ( f < num ) { f += num ; integer -- ; } this . fraction = f ; }	Sets integer and fractional part with normalization.Normalization means that if double is out of range,values will be correctly fixed.
protected void emit comment ( final int from , final int to ) { if ( config . enable conditional comments ) {	Emits a comment. Also checks for conditional comments!.
protected void error ( string message ) { if ( config . calculate position ) { position current position = position ( ndx ) ; message = message . concat ( string pool . space ) . concat ( current position . to string ( ) ) ; } else { message = message . concat ( str ) . concat ( integer . to string ( ndx ) ) . concat ( string pool . right sq bracket ) ; } visitor . error ( message ) ; }	Prepares error message and reports it to the visitor.
public string create hash ( final char [ ] password ) {	Returns a salted PBKDF2 hash of the password.
private static byte [ ] pbkdf2 ( final char [ ] password , final byte [ ] salt , final int iterations , final int bytes ) { pbe spec = new pbe ( password , salt , iterations , bytes * num ) ; try { secret key factory skf = secret key factory . get instance ( pbkd algorithm ) ; return skf . generate secret ( spec ) . get encoded ( ) ; } catch ( no such algorithm exception ignore ) { return null ; } catch ( invalid key spec exception e ) { throw new illegal argument exception ( e ) ; } }	Computes the PBKDF2 hash of a password.
private static byte [ ] from hex ( final string hex ) { final byte [ ] binary = new byte [ hex . length ( ) / num ] ; for ( int i = num ; i < binary . length ; i ++ ) { binary [ i ] = ( byte ) integer . parse int ( hex . substring ( num * i , num * i + num ) , num ) ; } return binary ; }	Converts a string of hexadecimal characters into a byte array.
public provider definition [ ] resolve provider definitions ( final class type , final string name ) { return provider resolver . resolve ( type , name ) ; }	Resolves provider definition defined in a bean.
public email attachment builder name ( final string name ) { if ( name != null && ! name . trim ( ) . is empty ( ) ) { this . name = name ; } return this ; }	Sets file name.
protected email attachment builder set content id from name if missing ( ) { if ( content id == null ) { if ( name != null ) { content id ( file name util . get name ( name ) ) ; } else { content id ( no name ) ; } } return this ; }	Set content ID if it is missing.
protected string resolve content type ( final string content type ) { if ( content type != null ) { return content type ; } if ( name == null ) { return mime types . mime application octet stream ; } final string extension = file name util . get extension ( name ) ; return mime types . get mime type ( extension ) ; }	Resolves content type from all data.
private static int parse type ( final string signature , final int start offset , final signature visitor signature visitor ) { int offset = start offset ;	Parses a JavaTypeSignature and makes the given visitor visit it.
int compute attributes size ( ) { symbol table . add constant utf8 ( constants . module ) ;	Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by thisModuleWriter.
void put attributes ( final byte vector output ) {	Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriterin the given ByteVector.
public static string decode ( final string source , final string encoding ) { return decode ( source , encoding , bool ) ; }	Decodes URL elements. This method may be used for allparts of URL, except for the query parts, since it doesnot decode the '+' character.
public static string decode query ( final string source , final string encoding ) { return decode ( source , encoding , bool ) ; }	Decodes query name or value.
@ override @ suppress warnings ( str ) public void start ( ) { init logger ( ) ; if ( ! database enabled ) { log . info ( str ) ; return ; } log . info ( str ) ; final petite container petite container = joy petite supplier . get ( ) . get petite container ( ) ;	Initializes database. First, creates connection pool.and transaction manager. Then, Jodds DbEntityManager isconfigured. It is also configured automagically, by scanningthe class path for entities.
protected void check connection provider ( ) { final connection connection = connection provider . get connection ( ) ; try { final database meta data database meta data = connection . get meta data ( ) ; string name = database meta data . get database product name ( ) ; string version = database meta data . get database product version ( ) ; if ( log . is info enabled ( ) ) { log . info ( str + name + str + version ) ; } } catch ( sql sex ) { log . error ( str , sex ) ; } finally { connection provider . close connection ( connection ) ; } }	Checks if connection provider can return a connection.
@ override public method visitor visit method ( final int access , final string name , final string desc , final string signature , final string [ ] exceptions ) {	Stores method signature for target method.
@ override public void visit end ( ) {	Stores signatures for all super public methods not already overridden by target class.All this methods will be accepted for proxyfication.
protected method signature visitor create method signature ( final int access , final string method name , final string description , final string signature , final string [ ] exceptions , final string classname , final map < string , string > declared type generics ) { method signature visitor v = new method signature visitor ( method name , access , classname , description , exceptions , signature , declared type generics , this ) ; new signature reader ( signature != null ? signature : description ) . accept ( v ) ; return v ; }	Creates method signature from method name.
public static string to csv string ( final object ... elements ) { string builder line = new string builder ( ) ; int last = elements . length - num ; for ( int i = num ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( field separator ) ; } continue ; } string field = elements [ i ] . to string ( ) ;	Parse fields as csv string,.
public static string [ ] to string array ( final string line ) { list < string > row = new array list < > ( ) ; boolean in quoted field = bool ; int field start = num ; final int len = line . length ( ) ; for ( int i = num ; i < len ; i ++ ) { char c = line . char at ( i ) ; if ( c == field separator ) { if ( ! in quoted field ) {	Converts CSV line to string array.
public ctor injection point resolve ( final class type , final boolean use annotation ) {	Resolves constructor injection point from type.
private class reader create advice class reader ( final class < ? extends proxy advice > advice ) { input stream input stream = null ; try { input stream = class loader util . get class as stream ( advice ) ; return new class reader ( input stream ) ; } catch ( io ioex ) { throw new proxetta exception ( ioex ) ; } finally { stream util . close ( input stream ) ; } }	Creates advice's class reader.
private class reader get cached advice class reader ( final class < ? extends proxy advice > advice ) { if ( advice class reader cache == null ) { advice class reader cache = type cache . create default ( ) ; } class reader advice reader = advice class reader cache . get ( advice ) ; if ( advice reader == null ) { advice reader = create advice class reader ( advice ) ; advice class reader cache . put ( advice , advice reader ) ; } return advice reader ; }	Returns class reader for advice.
public string encrypt ( final string str ) { try { byte [ ] utf8 = string util . get bytes ( str ) ;	Symmetrically encrypts the string.
public string decrypt ( string str ) { try { str = string util . replace char ( str , str , str ) ;	Symmetrically decrypts the string.
public static logger get logger ( final string name ) { if ( loggers == null ) { return logger provider . apply ( name ) ; } return loggers . compute if absent ( name , logger provider ) ; }	Returns logger for given name.
private void set name ( final string name ) { if ( name . contains ( str ) || name . contains ( str ) || name . starts with ( str ) ) { throw new illegal argument exception ( str + name ) ; } for ( int n = num ; n < name . length ( ) ; n ++ ) { char c = name . char at ( n ) ; if ( c <= num || c >= num ) { throw new illegal argument exception ( str + name ) ; } } this . name = name ; }	Sets the cookie name and checks for validity.
protected action request create action request ( final string action path , final string [ ] action path chunks , final action runtime action runtime , final object action , final http servlet request servlet request , final http servlet response servlet response ) { return new action request ( this , action path , action path chunks , action runtime , action , servlet request , servlet response ) ; }	Creates new action request.
@ override protected < r extends action filter > r create wrapper ( final class < r > wrapper class ) { return petite container . create bean ( wrapper class ) ; }	Acquires filter from Petite container.
protected void destroy bean ( final bean data bean data ) { if ( destroyable beans == null ) { return ; } if ( ! is bean destroyable ( bean data ) ) { return ; } if ( destroyable beans . remove ( bean data ) ) { bean data . call destroy methods ( ) ; } }	Removes destroyable bean from the list and calls it destroy methods.If bean is not destroyable, does nothing.
@ override public void shutdown ( ) { if ( destroyable beans == null ) { return ; } for ( final bean data destroyable bean : destroyable beans ) { destroyable bean . call destroy methods ( ) ; } destroyable beans . clear ( ) ; }	Shutdowns the scope and calls all collected destroyable beans.
public received email [ ] get ( ) { if ( from folder != null ) { session . use folder ( from folder ) ; } return session . receive messages ( filter , flags to set , flags to unset , envelope only , messages -> { if ( target folder != null ) { try { session . folder . copy messages ( messages , session . get folder ( target folder ) ) ; } catch ( messaging exception e ) { throw new mail exception ( str ) ; } } } ) ; }	Receives the emails as specified by the builder.
public static void main ( final string [ ] args ) { load properties files ( args ) ; try ( clustered service container container = launch ( ) ) { container . context ( ) . shutdown signal barrier ( ) . await ( ) ; system . out . println ( str ) ; } }	Launch the clustered service container and await a shutdown signal.
public void run ( ) { do { lock support . park nanos ( park ns ) ; final long current total messages = total messages ; final long current total bytes = total bytes ; final long current timestamp = system . nano time ( ) ; final long time span ns = current timestamp - last timestamp ; final double messages per sec = ( ( current total messages - last total messages ) * ( double ) report interval ns ) / ( double ) time span ns ; final double bytes per sec = ( ( current total bytes - last total bytes ) * ( double ) report interval ns ) / ( double ) time span ns ; reporting func . on report ( messages per sec , bytes per sec , current total messages , current total bytes ) ; last total bytes = current total bytes ; last total messages = current total messages ; last timestamp = current timestamp ; } while ( ! halt ) ; }	Run loop for the rate reporter.
@ suppress warnings ( str ) public static void print error ( final string channel , final int stream id , final int session id , final string message , final header flyweight cause ) { system . out . println ( message ) ; }	Generic error handler that just prints message to stdout.
public static void print rate ( final double messages per sec , final double bytes per sec , final long total messages , final long total bytes ) { system . out . println ( string . format ( str , messages per sec , bytes per sec , total messages , total bytes / ( num * num ) ) ) ; }	Print the rates to stdout.
public static mapped byte buffer map existing file read only ( final file location ) { if ( ! location . exists ( ) ) { final string msg = str + location . get absolute path ( ) ; throw new illegal state exception ( msg ) ; } mapped byte buffer mapped byte buffer = null ; try ( random access file file = new random access file ( location , str ) ; file channel channel = file . get channel ( ) ) { mapped byte buffer = channel . map ( read only , num , channel . size ( ) ) ; } catch ( final io ex ) { lang util . rethrow unchecked ( ex ) ; } return mapped byte buffer ; }	Map an existing file as a read only buffer.
public void close ( ) { final state state = this . state ; if ( state . closed != state ) { if ( is replay active ) { is replay active = bool ; archive . stop replay ( replay session id ) ; } if ( state . merged != state ) { subscription . remove destination ( replay destination ) ; } state ( state . closed ) ; } }	Close the merge and stop any active replay.
public int do work ( ) { int work count = num ; switch ( state ) { case await initial recording position : work count += await initial recording position ( ) ; break ; case await replay : work count += await replay ( ) ; break ; case await catch up : work count += await catch up ( ) ; break ; case await current recording position : work count += await updated recording position ( ) ; break ; case await stop replay : work count += await stop replay ( ) ; break ; } return work count ; }	Process the operation of the merge.
public long position ( ) { if ( is closed ) { return closed ; } final long raw tail = raw tail volatile ( log meta data buffer ) ; final int term offset = term offset ( raw tail , term buffer length ) ; return compute position ( term id ( raw tail ) , term offset , position bits to shift , initial term id ) ; }	Get the current position to which the publication has advanced for this stream.
public long offer ( final direct buffer vector [ ] vectors , final reserved value supplier reserved value supplier ) { final int length = direct buffer vector . validate and compute length ( vectors ) ; long new position = closed ; if ( ! is closed ) { final long limit = position limit . get volatile ( ) ; final exclusive term appender term appender = term appenders [ active partition index ] ; final long position = term begin position + term offset ; if ( position < limit ) { final int result ; if ( length <= max payload length ) { result = term appender . append unfragmented message ( term id , term offset , header writer , vectors , length , reserved value supplier ) ; } else { check max message length ( length ) ; result = term appender . append fragmented message ( term id , term offset , header writer , vectors , length , max payload length , reserved value supplier ) ; } new position = new position ( result ) ; } else { new position = back pressure status ( position , length ) ; } } return new position ; }	Non-blocking publish by gathering buffer vectors into a message.
public long append padding ( final int length ) { check max message length ( length ) ; long new position = closed ; if ( ! is closed ) { final long limit = position limit . get volatile ( ) ; final exclusive term appender term appender = term appenders [ active partition index ] ; final long position = term begin position + term offset ; if ( position < limit ) { check positive length ( length ) ; final int result = term appender . append padding ( term id , term offset , header writer , length ) ; new position = new position ( result ) ; } else { new position = back pressure status ( position , length ) ; } } return new position ; }	Append a padding record log of a given length to make up the log to a position.
public void close ( ) { lock . lock ( ) ; try { if ( ! is closed ) { is closed = bool ; archive proxy . close session ( control session id ) ; if ( ! context . owns aeron client ( ) ) { close helper . close ( control response poller . subscription ( ) ) ; close helper . close ( archive proxy . publication ( ) ) ; } context . close ( ) ; } } finally { lock . unlock ( ) ; } }	Notify the archive that this control session is closed so it can promptly release resources then close thelocal resources associated with the client.
public string poll for error response ( ) { lock . lock ( ) ; try { ensure open ( ) ; if ( control response poller . poll ( ) != num && control response poller . is poll complete ( ) ) { if ( control response poller . control session id ( ) == control session id && control response poller . template id ( ) == control response decoder . template id && control response poller . code ( ) == control response code . error ) { return control response poller . error message ( ) ; } } return null ; } finally { lock . unlock ( ) ; } }	Poll the response stream once for an error.
public void stop replay ( final long replay session id ) { lock . lock ( ) ; try { ensure open ( ) ; final long correlation id = aeron . next correlation id ( ) ; if ( ! archive proxy . stop replay ( replay session id , correlation id , control session id ) ) { throw new archive exception ( str ) ; } poll for response ( correlation id ) ; } finally { lock . unlock ( ) ; } }	Stop a replay session.
public static void event available image ( final image image ) { final subscription subscription = image . subscription ( ) ; system . out . format ( str , subscription . channel ( ) , subscription . stream id ( ) , image . session id ( ) , image . source identity ( ) ) ; }	Print the information for an available image to stdout.
public static void event unavailable image ( final image image ) { final subscription subscription = image . subscription ( ) ; system . out . format ( str , subscription . channel ( ) , subscription . stream id ( ) , image . session id ( ) ) ; }	This handler is called when image is unavailable.
public static status indicator reader send channel status ( final counters reader counters reader , final string channel ) { status indicator reader status reader = null ; final mutable integer id = new mutable integer ( - num ) ; counters reader . for each ( ( counter id , type id , key buffer , label ) -> { if ( type id == send channel status . send channel status type id ) { if ( channel . starts with ( key buffer . get string ascii ( channel endpoint status . channel offset ) ) ) { id . value = counter id ; } } } ) ; if ( aeron . null value != id . value ) { status reader = new unsafe buffer status indicator ( counters reader . values buffer ( ) , id . value ) ; } return status reader ; }	Return the read-only status indicator for the given send channel URI.
public static status indicator reader receive channel status ( final counters reader counters reader , final string channel ) { status indicator reader status reader = null ; final mutable integer id = new mutable integer ( - num ) ; counters reader . for each ( ( counter id , type id , key buffer , label ) -> { if ( type id == receive channel status . receive channel status type id ) { if ( channel . starts with ( key buffer . get string ascii ( channel endpoint status . channel offset ) ) ) { id . value = counter id ; } } } ) ; if ( aeron . null value != id . value ) { status reader = new unsafe buffer status indicator ( counters reader . values buffer ( ) , id . value ) ; } return status reader ; }	Return the read-only status indicator for the given receive channel URI.
public void limit ( final int limit ) { if ( limit < num || limit >= buffer . capacity ( ) ) { throw new illegal argument exception ( str + buffer . capacity ( ) + str + limit ) ; } this . limit = limit ; }	Set this limit for this buffer as the position at which the next append operation will occur.
public buffer builder append ( final direct buffer src buffer , final int src offset , final int length ) { ensure capacity ( length ) ; buffer . put bytes ( limit , src buffer , src offset , length ) ; limit += length ; return this ; }	Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.
public int poll ( ) { control session id = - num ; correlation id = - num ; relevant id = - num ; template id = - num ; error message = null ; poll complete = bool ; return subscription . controlled poll ( fragment assembler , fragment limit ) ; }	Poll for control response events.
public static mapped byte buffer map loss report ( final string aeron directory name , final int report file length ) { return map new file ( file ( aeron directory name ) , report file length , bool ) ; }	Map a new loss report in the Aeron directory for a given length.
public map < stream composite key , list < stream position > > snapshot ( ) { final map < stream composite key , list < stream position > > streams = new hash map < > ( ) ; counters . for each ( ( counter id , type id , key buffer , label ) -> { if ( ( type id >= publisher limit type id && type id <= receiver pos type id ) || type id == sender limit type id || type id == per image type id || type id == publisher pos type id ) { final stream composite key key = new stream composite key ( key buffer . get int ( session id offset ) , key buffer . get int ( stream id offset ) , key buffer . get string ascii ( channel offset ) ) ; final stream position position = new stream position ( key buffer . get long ( registration id offset ) , counters . get counter value ( counter id ) , type id ) ; streams . compute if absent ( key , ( ignore ) -> new array list < > ( ) ) . add ( position ) ; } } ) ; return streams ; }	Take a snapshot of all the counters and group them by streams.
public static unsafe buffer create default header ( final int session id , final int stream id , final int term id ) { final unsafe buffer buffer = new unsafe buffer ( buffer util . allocate direct aligned ( header length , cache line length ) ) ; buffer . put byte ( version field offset , current version ) ; buffer . put byte ( flags field offset , ( byte ) begin and end flags ) ; buffer . put short ( type field offset , ( short ) hdr type data , little endian ) ; buffer . put int ( session id field offset , session id , little endian ) ; buffer . put int ( stream id field offset , stream id , little endian ) ; buffer . put int ( term id field offset , term id , little endian ) ; buffer . put long ( reserved value offset , default reserve value ) ; return buffer ; }	Return an initialised default Data Frame Header.
public counter message flyweight key buffer ( final direct buffer key buffer , final int key offset , final int key length ) { buffer . put int ( key length offset , key length ) ; if ( null != key buffer && key length > num ) { buffer . put bytes ( key buffer offset ( ) , key buffer , key offset , key length ) ; } return this ; }	Fill the key buffer.
public counter message flyweight label buffer ( final direct buffer label buffer , final int label offset , final int label length ) { buffer . put int ( label offset ( ) , label length ) ; buffer . put bytes ( label buffer offset ( ) , label buffer , label offset , label length ) ; return this ; }	Fill the label buffer.
public boolean connect ( final string response channel , final int response stream id , final long correlation id ) { connect request encoder . wrap and apply header ( buffer , num , message header encoder ) . correlation id ( correlation id ) . response stream id ( response stream id ) . version ( aeron archive . configuration . semantic version ) . response channel ( response channel ) ; return offer with timeout ( connect request encoder . encoded length ( ) , null ) ; }	Connect to an archive on its control interface providing the response stream details.
public boolean try connect ( final string response channel , final int response stream id , final long correlation id ) { connect request encoder . wrap and apply header ( buffer , num , message header encoder ) . correlation id ( correlation id ) . response stream id ( response stream id ) . version ( aeron archive . configuration . semantic version ) . response channel ( response channel ) ; final int length = message header encoder . encoded length + connect request encoder . encoded length ( ) ; return publication . offer ( buffer , num , length ) > num ; }	Try Connect to an archive on its control interface providing the response stream details.
public boolean close session ( final long control session id ) { close session request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) ; return offer ( close session request encoder . encoded length ( ) ) ; }	Close this control session with the archive.
public boolean start recording ( final string channel , final int stream id , final source location source location , final long correlation id , final long control session id ) { start recording request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . stream id ( stream id ) . source location ( source location ) . channel ( channel ) ; return offer ( start recording request encoder . encoded length ( ) ) ; }	Start recording streams for a given channel and stream id pairing.
public boolean stop recording ( final string channel , final int stream id , final long correlation id , final long control session id ) { stop recording request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . stream id ( stream id ) . channel ( channel ) ; return offer ( stop recording request encoder . encoded length ( ) ) ; }	Stop an active recording.
public boolean replay ( final long recording id , final long position , final long length , final string replay channel , final int replay stream id , final long correlation id , final long control session id ) { replay request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . recording id ( recording id ) . position ( position ) . length ( length ) . replay stream id ( replay stream id ) . replay channel ( replay channel ) ; return offer ( replay request encoder . encoded length ( ) ) ; }	Replay a recording from a given position.
public boolean stop replay ( final long replay session id , final long correlation id , final long control session id ) { stop replay request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . replay session id ( replay session id ) ; return offer ( replay request encoder . encoded length ( ) ) ; }	Stop an existing replay session.
public boolean list recordings ( final long from recording id , final int record count , final long correlation id , final long control session id ) { list recordings request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . from recording id ( from recording id ) . record count ( record count ) ; return offer ( list recordings request encoder . encoded length ( ) ) ; }	List a range of recording descriptors.
public boolean list recordings for uri ( final long from recording id , final int record count , final string channel fragment , final int stream id , final long correlation id , final long control session id ) { list recordings for uri request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . from recording id ( from recording id ) . record count ( record count ) . stream id ( stream id ) . channel ( channel fragment ) ; return offer ( list recordings for uri request encoder . encoded length ( ) ) ; }	List a range of recording descriptors which match a channel URI fragment and stream id.
public boolean list recording ( final long recording id , final long correlation id , final long control session id ) { list recording request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . recording id ( recording id ) ; return offer ( list recording request encoder . encoded length ( ) ) ; }	List a recording descriptor for a given recording id.
public boolean extend recording ( final string channel , final int stream id , final source location source location , final long recording id , final long correlation id , final long control session id ) { extend recording request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . recording id ( recording id ) . stream id ( stream id ) . source location ( source location ) . channel ( channel ) ; return offer ( extend recording request encoder . encoded length ( ) ) ; }	Extend an existing, non-active, recorded stream for a the same channel and stream id.The channel must be configured for the initial position from which it will be extended.
public boolean get recording position ( final long recording id , final long correlation id , final long control session id ) { recording position request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . recording id ( recording id ) ; return offer ( recording position request encoder . encoded length ( ) ) ; }	Get the recorded position of an active recording.
public boolean get stop position ( final long recording id , final long correlation id , final long control session id ) { stop position request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . recording id ( recording id ) ; return offer ( stop position request encoder . encoded length ( ) ) ; }	Get the stop position of a recording.
public boolean list recording subscriptions ( final int pseudo index , final int subscription count , final string channel fragment , final int stream id , final boolean apply stream id , final long correlation id , final long control session id ) { list recording subscriptions request encoder . wrap and apply header ( buffer , num , message header encoder ) . control session id ( control session id ) . correlation id ( correlation id ) . pseudo index ( pseudo index ) . subscription count ( subscription count ) . apply stream id ( apply stream id ? boolean type . true : boolean type . false ) . stream id ( stream id ) . channel ( channel fragment ) ; return offer ( list recording subscriptions request encoder . encoded length ( ) ) ; }	List registered subscriptions in the archive which have been used to record streams.
public boolean matches tag ( final udp channel udp channel ) { if ( ! has tag || ! udp channel . has tag ( ) || tag != udp channel . tag ( ) ) { return bool ; } if ( udp channel . remote data ( ) . get address ( ) . is any local address ( ) && udp channel . remote data ( ) . get port ( ) == num && udp channel . local data ( ) . get address ( ) . is any local address ( ) && udp channel . local data ( ) . get port ( ) == num ) { return bool ; } throw new illegal argument exception ( str ) ; }	Does this channel have a tag match to another channel including endpoints.
public static inet socket address destination address ( final channel uri uri ) { try { validate configuration ( uri ) ; return get endpoint address ( uri ) ; } catch ( final exception ex ) { throw new invalid channel exception ( error code . invalid channel , ex ) ; } }	Get the endpoint address from the URI.
public string description ( ) { final string builder builder = new string builder ( str ) ; if ( null != local interface ) { builder . append ( str ) . append ( local interface . get display name ( ) ) . append ( str ) ; } builder . append ( str ) . append ( local data ) . append ( str ) . append ( remote data ) . append ( str ) . append ( multicast ttl ) ; return builder . to string ( ) ; }	Used for debugging to get a human readable description of the channel.
void add destination ( final int transport index , final receive destination udp transport transport ) { image connections = array util . ensure capacity ( image connections , transport index + num ) ; if ( transport . is multicast ( ) ) { image connections [ transport index ] = new image connection ( cached nano clock . nano time ( ) , transport . udp channel ( ) . remote control ( ) ) ; } else if ( transport . has explicit control ( ) ) { image connections [ transport index ] = new image connection ( cached nano clock . nano time ( ) , transport . explicit control address ( ) ) ; } }	Add a destination to this image so it can merge streams.
int insert packet ( final int term id , final int term offset , final unsafe buffer buffer , final int length , final int transport index , final inet socket address src address ) { final boolean is heartbeat = data header flyweight . is heartbeat ( buffer , length ) ; final long packet position = compute position ( term id , term offset , position bits to shift , initial term id ) ; final long proposed position = is heartbeat ? packet position : packet position + length ; if ( ! is flow control under run ( packet position ) && ! is flow control over run ( proposed position ) ) { track connection ( transport index , src address , last packet timestamp ns ) ; if ( is heartbeat ) { if ( data header flyweight . is end of stream ( buffer ) && ! is end of stream && all eos ( transport index ) ) { log buffer descriptor . end of stream position ( raw log . meta data ( ) , proposed position ) ; is end of stream = bool ; } heartbeats received . increment ordered ( ) ; } else { final unsafe buffer term buffer = term buffers [ index by position ( packet position , position bits to shift ) ] ; term rebuilder . insert ( term buffer , term offset , buffer , length ) ; } last packet timestamp ns = cached nano clock . nano time ( ) ; hwm position . propose max ordered ( proposed position ) ; } return length ; }	Insert frame into term buffer.
public static atomic counter find control toggle ( final counters reader counters ) { final atomic buffer buffer = counters . meta data buffer ( ) ; for ( int i = num , size = counters . max counter id ( ) ; i < size ; i ++ ) { final int record offset = counters reader . meta data offset ( i ) ; if ( counters . get counter state ( i ) == record allocated && buffer . get int ( record offset + type id offset ) == control toggle type id ) { return new atomic counter ( counters . values buffer ( ) , i , null ) ; } } return null ; }	Find the control toggle counter or return null if not found.
public string put ( final string key , final string value ) { return params . put ( key , value ) ; }	Put a key and value pair in the map of params.
public string channel tag ( ) { return ( null != tags && tags . length > channel tag index ) ? tags [ channel tag index ] : null ; }	Get the channel tag, if it exists, that refers to an another channel.
public string entity tag ( ) { return ( null != tags && tags . length > entity tag index ) ? tags [ entity tag index ] : null ; }	Get the entity tag, if it exists, that refers to an entity such as subscription or publication.
public static string add session id ( final string channel , final int session id ) { final channel uri channel uri = channel uri . parse ( channel ) ; channel uri . put ( common context . session id param name , integer . to string ( session id ) ) ; return channel uri . to string ( ) ; }	Add a sessionId to a given channel.
public static long get tag ( final string param value ) { return is tagged ( param value ) ? ascii encoding . parse long ascii ( param value , num , param value . length ( ) - num ) : invalid tag ; }	Get the value of the tag from a given parameter value.
public int append padding ( final int term id , final int term offset , final header writer header , final int length ) { final int frame length = length + header length ; final int aligned length = align ( frame length , frame alignment ) ; final unsafe buffer term buffer = this . term buffer ; final int term length = term buffer . capacity ( ) ; int resulting offset = term offset + aligned length ; put raw tail ordered ( term id , resulting offset ) ; if ( resulting offset > term length ) { resulting offset = handle end of log condition ( term buffer , term offset , header , term length , term id ) ; } else { header . write ( term buffer , term offset , frame length , term id ) ; frame type ( term buffer , term offset , padding frame type ) ; frame length ordered ( term buffer , term offset , frame length ) ; } return resulting offset ; }	Pad a length of the term buffer with a padding record.
final int update publisher limit ( ) { int work count = num ; final long sender position = this . sender position . get volatile ( ) ; if ( has receivers || ( spies simulate connection && spy positions . length > num ) ) { long min consumer position = sender position ; for ( final readable position spy position : spy positions ) { min consumer position = math . min ( min consumer position , spy position . get volatile ( ) ) ; } final long proposed publisher limit = min consumer position + term window length ; if ( publisher limit . propose max ordered ( proposed publisher limit ) ) { clean buffer ( proposed publisher limit ) ; work count = num ; } } else if ( publisher limit . get ( ) > sender position ) { publisher limit . set ordered ( sender position ) ; } return work count ; }	Update the publishers limit for flow control as part of the conductor duty cycle.
public static unsafe buffer position allocate ( final mutable direct buffer temp buffer , final string name , final int type id , final counters manager counters manager , final long registration id , final int session id , final int stream id , final string channel ) { return new unsafe buffer position ( ( unsafe buffer ) counters manager . values buffer ( ) , allocate counter id ( temp buffer , name , type id , counters manager , registration id , session id , stream id , channel ) , counters manager ) ; }	Allocate a counter for tracking a position on a stream of messages.
public static string label name ( final int type id ) { switch ( type id ) { case publisher limit . publisher limit type id : return publisher limit . name ; case sender pos . sender position type id : return sender pos . name ; case receiver hwm . receiver hwm type id : return receiver hwm . name ; case subscriber pos . subscriber position type id : return subscriber pos . name ; case receiver pos . receiver pos type id : return receiver pos . name ; case sender limit . sender limit type id : return sender limit . name ; case publisher pos . publisher pos type id : return publisher pos . name ; case sender bpe . sender bpe type id : return sender bpe . name ; default : return str ; } }	Return the label name for a counter type identifier.
public static long scan for availability ( final unsafe buffer term buffer , final int offset , final int max length ) { final int limit = math . min ( max length , term buffer . capacity ( ) - offset ) ; int available = num ; int padding = num ; do { final int term offset = offset + available ; final int frame length = frame length volatile ( term buffer , term offset ) ; if ( frame length <= num ) { break ; } int aligned frame length = align ( frame length , frame alignment ) ; if ( is padding frame ( term buffer , term offset ) ) { padding = aligned frame length - header length ; aligned frame length = header length ; } available += aligned frame length ; if ( available > limit ) { available -= aligned frame length ; padding = num ; break ; } } while ( num == padding && available < limit ) ; return pack ( padding , available ) ; }	Scan the term buffer for availability of new message fragments from a given offset up to a maxLength of bytes.
public channel uri string builder clear ( ) { prefix = null ; media = null ; endpoint = null ; network interface = null ; control endpoint = null ; control mode = null ; tags = null ; alias = null ; reliable = null ; ttl = null ; mtu = null ; term length = null ; initial term id = null ; term id = null ; term offset = null ; session id = null ; linger = null ; sparse = null ; eos = null ; tether = null ; is session id tagged = bool ; return this ; }	Clear out all the values thus setting back to the initial state.
public channel uri string builder validate ( ) { if ( null == media ) { throw new illegal state exception ( str ) ; } if ( common context . udp media . equals ( media ) && ( null == endpoint && null == control endpoint ) ) { throw new illegal state exception ( str ) ; } int count = num ; count += null == initial term id ? num : num ; count += null == term id ? num : num ; count += null == term offset ? num : num ; if ( count > num ) { if ( count < num ) { throw new illegal state exception ( str ) ; } if ( term id - initial term id < num )	Validates that the collection of set parameters are valid together.
public channel uri string builder prefix ( final string prefix ) { if ( null != prefix && ! prefix . equals ( str ) && ! prefix . equals ( spy qualifier ) ) { throw new illegal argument exception ( str + prefix ) ; } this . prefix = prefix ; return this ; }	Set the prefix for taking an addition action such as spying on an outgoing publication with "aeron-spy".
public channel uri string builder media ( final string media ) { switch ( media ) { case common context . udp media : case common context . ipc media : break ; default : throw new illegal argument exception ( str + media ) ; } this . media = media ; return this ; }	Set the media for this channel.
public channel uri string builder control mode ( final string control mode ) { if ( null != control mode && ! control mode . equals ( common context . mdc control mode manual ) && ! control mode . equals ( common context . mdc control mode dynamic ) ) { throw new illegal argument exception ( str + control mode ) ; } this . control mode = control mode ; return this ; }	Set the control mode for multi-destination-cast.
public channel uri string builder term length ( final integer term length ) { if ( null != term length ) { log buffer descriptor . check term length ( term length ) ; } this . term length = term length ; return this ; }	Set the length of buffer used for each term of the log.
public channel uri string builder term offset ( final integer term offset ) { if ( null != term offset ) { if ( ( term offset < num || term offset > log buffer descriptor . term max length ) ) { throw new illegal argument exception ( str + term offset ) ; } if ( num != ( term offset & ( frame alignment - num ) ) ) { throw new illegal argument exception ( str + term offset ) ; } } this . term offset = term offset ; return this ; }	Set the offset within a term at which a publication will start.
public channel uri string builder linger ( final long linger ns ) { if ( null != linger ns && linger ns < num ) { throw new illegal argument exception ( str + linger ns ) ; } this . linger = linger ns ; return this ; }	Set the time a network publication will linger in nanoseconds after being drained.
public void close ( ) { if ( ! is closed ) { is closed = bool ; try { if ( null != selection key ) { selection key . cancel ( ) ; } if ( null != transport poller ) { transport poller . cancel read ( this ) ; transport poller . select now without processing ( ) ; } if ( null != send datagram channel ) { send datagram channel . close ( ) ; } if ( receive datagram channel != send datagram channel && null != receive datagram channel ) { receive datagram channel . close ( ) ; } if ( null != transport poller ) { transport poller . select now without processing ( ) ; } } catch ( final io ex ) { error log . record ( ex ) ; } } }	Close transport, canceling any pending read operations and closing channel.
public boolean is valid frame ( final unsafe buffer buffer , final int length ) { boolean is frame valid = bool ; if ( frame version ( buffer , num ) != header flyweight . current version ) { is frame valid = bool ; invalid packets . increment ( ) ; } else if ( length < header flyweight . min header length ) { is frame valid = bool ; invalid packets . increment ( ) ; } return is frame valid ; }	Is the received frame valid.
public inet socket address receive ( final byte buffer buffer ) { buffer . clear ( ) ; inet socket address address = null ; try { if ( receive datagram channel . is open ( ) ) { address = ( inet socket address ) receive datagram channel . receive ( buffer ) ; } } catch ( final port unreachable exception ignored ) { } catch ( final exception ex ) { lang util . rethrow unchecked ( ex ) ; } return address ; }	Receive a datagram from the media layer.
public void on nak ( final int term id , final int term offset , final int length , final int term length , final retransmit sender retransmit sender ) { if ( ! is invalid ( term offset , term length ) ) { if ( null == active retransmits map . get ( term id , term offset ) && active retransmits map . size ( ) < max retransmits default ) { final retransmit action action = assign retransmit action ( ) ; action . term id = term id ; action . term offset = term offset ; action . length = math . min ( length , term length - term offset ) ; final long delay = delay generator . generate delay ( ) ; if ( num == delay ) { retransmit sender . resend ( term id , term offset , action . length ) ; action . linger ( linger timeout generator . generate delay ( ) , nano clock . nano time ( ) ) ; } else { action . delay ( delay , nano clock . nano time ( ) ) ; } active retransmits map . put ( term id , term offset , action ) ; } } }	Called on reception of a NAK to start retransmits handling.
public void process timeouts ( final long now ns , final retransmit sender retransmit sender ) { if ( active retransmits map . size ( ) > num ) { for ( final retransmit action action : retransmit action pool ) { if ( delayed == action . state && ( action . expire ns - now ns < num ) ) { retransmit sender . resend ( action . term id , action . term offset , action . length ) ; action . linger ( linger timeout generator . generate delay ( ) , nano clock . nano time ( ) ) ; } else if ( lingering == action . state && ( action . expire ns - now ns < num ) ) { action . cancel ( ) ; active retransmits map . remove ( action . term id , action . term offset ) ; } } } }	Called to process any outstanding timeouts.
public static string status ( final long status ) { if ( initializing == status ) { return str ; } if ( errored == status ) { return str ; } if ( active == status ) { return str ; } if ( closing == status ) { return str ; } return str + status ; }	String representation of the channel status.
public static atomic counter allocate ( final mutable direct buffer temp buffer , final string name , final int type id , final counters manager counters manager , final string channel ) { final int key length = temp buffer . put string without length ascii ( channel offset + size of int , channel , num , max channel length ) ; temp buffer . put int ( channel offset , key length ) ; int label length = num ; label length += temp buffer . put string without length ascii ( key length + label length , name ) ; label length += temp buffer . put string without length ascii ( key length + label length , str ) ; label length += temp buffer . put string without length ascii ( key length + label length , channel , num , max label length - label length ) ; return counters manager . new counter ( type id , temp buffer , num , key length , temp buffer , key length , label length ) ; }	Allocate an indicator for tracking the status of a channel endpoint.
public direct buffer vector reset ( final direct buffer buffer , final int offset , final int length ) { this . buffer = buffer ; this . offset = offset ; this . length = length ; return this ; }	Reset the values.
public direct buffer vector validate ( ) { final int capacity = buffer . capacity ( ) ; if ( offset < num || offset >= capacity ) { throw new illegal argument exception ( str + offset + str + capacity ) ; } if ( length < num || length > ( capacity - offset ) ) { throw new illegal argument exception ( str + offset + str + capacity + str + length ) ; } return this ; }	Ensure the vector is valid for the buffer.
public static int validate and compute length ( final direct buffer vector [ ] vectors ) { int message length = num ; for ( final direct buffer vector vector : vectors ) { vector . validate ( ) ; message length += vector . length ; if ( message length < num ) { throw new illegal state exception ( str + arrays . to string ( vectors ) ) ; } } return message length ; }	Validate an array of vectors to make up a message and compute the total length.
public static int producer window length ( final int term buffer length , final int default term window length ) { int term window length = term buffer length / num ; if ( num != default term window length ) { term window length = math . min ( default term window length , term window length ) ; } return term window length ; }	How far ahead a producer can get from a consumer position.
public static void validate socket buffer lengths ( final media driver . context ctx ) { try ( datagram channel probe = datagram channel . open ( ) ) { final int default so snd buf = probe . get option ( standard socket options . so sndbuf ) ; probe . set option ( standard socket options . so sndbuf , integer . max value ) ; final int max so snd buf = probe . get option ( standard socket options . so sndbuf ) ; if ( max so snd buf < ctx . socket sndbuf length ( ) ) { system . err . format ( str , socket sndbuf length prop name , ctx . socket sndbuf length ( ) , max so snd buf ) ; } probe . set option ( standard socket options . so rcvbuf , integer . max value ) ; final int max so rcv buf = probe . get option ( standard socket options . so rcvbuf ) ; if ( max so rcv buf < ctx . socket rcvbuf length ( ) ) { system . err . format ( str , socket rcvbuf length prop name , ctx . socket rcvbuf length ( ) , max so rcv buf ) ; } final int so snd buf = num == ctx . socket sndbuf length ( ) ? default so snd buf : ctx . socket sndbuf length ( ) ; if ( ctx . mtu length ( ) > so snd buf ) { throw new configuration exception ( string . format ( str , socket sndbuf length prop name , ctx . mtu length ( ) , so snd buf ) ) ; } if ( ctx . initial window length ( ) > max so rcv buf ) { throw new configuration exception ( str + configuration . initial window length prop name + str + ctx . initial window length ( ) + str + max so rcv buf ) ; } } catch ( final io ex ) { throw new aeron exception ( str + ex . to string ( ) , ex ) ; } }	Validate that the socket buffer lengths are sufficient for the media driver configuration.
public static void validate page size ( final int page size ) { if ( page size < page min size ) { throw new configuration exception ( str + page min size + str + page size ) ; } if ( page size > page max size ) { throw new configuration exception ( str + page max size + str + page size ) ; } if ( ! bit util . is power of two ( page size ) ) { throw new configuration exception ( str + page size ) ; } }	Validate that page size is valid and alignment is valid.
public static void validate session id range ( final int low , final int high ) { if ( low > high ) { throw new configuration exception ( str + low + str + high ) ; } if ( math . abs ( ( long ) high - low ) > integer . max value ) { throw new configuration exception ( str ) ; } }	Validate the range of session ids based on a high and low value provided which accounts for the values wrapping.
public static void validate unblock timeout ( final long publication unblock timeout ns , final long client liveness timeout ns , final long timer interval ns ) { if ( publication unblock timeout ns <= client liveness timeout ns ) { throw new configuration exception ( str + publication unblock timeout ns + str + client liveness timeout ns ) ; } if ( client liveness timeout ns <= timer interval ns ) { throw new configuration exception ( str + client liveness timeout ns + str + timer interval ns ) ; } }	Validate that the timeouts for unblocking publications from a client are valid.
public error response flyweight error code ( final error code code ) { buffer . put int ( offset + error code offset , code . value ( ) ) ; return this ; }	Set the error code for the command.
public void reset ( ) { is ballot sent = bool ; is leader = bool ; has requested join = bool ; has sent termination ack = bool ; vote = null ; candidate term id = aeron . null value ; leadership term id = aeron . null value ; log position = null position ; }	Reset the state of a cluster member so it can be canvassed and reestablished.
public static string encode as string ( final cluster member [ ] cluster members ) { final string builder builder = new string builder ( ) ; for ( int i = num , length = cluster members . length ; i < length ; i ++ ) { final cluster member member = cluster members [ i ] ; builder . append ( member . id ( ) ) . append ( str ) . append ( member . endpoints detail ( ) ) ; if ( ( length - num ) != i ) { builder . append ( str ) ; } } return builder . to string ( ) ; }	Encode member details from a cluster members array to a string.
public static void add member status publications ( final cluster member [ ] members , final cluster member exclude , final channel uri channel uri , final int stream id , final aeron aeron ) { for ( final cluster member member : members ) { if ( member != exclude ) { channel uri . put ( endpoint param name , member . member facing endpoint ( ) ) ; member . publication = aeron . add exclusive publication ( channel uri . to string ( ) , stream id ) ; } } }	Add the publications for sending status messages to the other members of the cluster.
public static void close member publications ( final cluster member [ ] cluster members ) { for ( final cluster member member : cluster members ) { close helper . close ( member . publication ) ; } }	Close the publications associated with members of the cluster.
public static boolean has active quorum ( final cluster member [ ] cluster members , final long now ms , final long timeout ms ) { int threshold = quorum threshold ( cluster members . length ) ; for ( final cluster member member : cluster members ) { if ( member . is leader ( ) || now ms <= ( member . time of last append position ms ( ) + timeout ms ) ) { if ( -- threshold <= num ) { return bool ; } } } return bool ; }	Check if the cluster leader has an active quorum of cluster followers.
public static long quorum position ( final cluster member [ ] members , final long [ ] ranked positions ) { final int length = ranked positions . length ; for ( int i = num ; i < length ; i ++ ) { ranked positions [ i ] = num ; } for ( final cluster member member : members ) { long new position = member . log position ; for ( int i = num ; i < length ; i ++ ) { final long ranked position = ranked positions [ i ] ; if ( new position > ranked position ) { ranked positions [ i ] = new position ; new position = ranked position ; } } } return ranked positions [ length - num ] ; }	Calculate the position reached by a quorum of cluster members.
public static void reset log positions ( final cluster member [ ] cluster members , final long log position ) { for ( final cluster member member : cluster members ) { member . log position ( log position ) ; } }	Reset the log position of all the members to the provided value.
public static boolean have voters reached position ( final cluster member [ ] cluster members , final long position , final long leadership term id ) { for ( final cluster member member : cluster members ) { if ( member . vote != null && ( member . log position < position || member . leadership term id != leadership term id ) ) { return bool ; } } return bool ; }	Has the members of the cluster the voted reached the provided position in their log.
public static boolean has won vote on full count ( final cluster member [ ] members , final long candidate term id ) { int votes = num ; for ( final cluster member member : members ) { if ( null == member . vote || member . candidate term id != candidate term id ) { return bool ; } votes += member . vote ? num : num ; } return votes >= cluster member . quorum threshold ( members . length ) ; }	Has the candidate got unanimous support of the cluster?.
public static boolean has majority vote ( final cluster member [ ] cluster members , final long candidate term id ) { int votes = num ; for ( final cluster member member : cluster members ) { if ( boolean . true . equals ( member . vote ) && member . candidate term id == candidate term id ) { ++ votes ; } } return votes >= cluster member . quorum threshold ( cluster members . length ) ; }	Has sufficient votes being counted for a majority?.
public static cluster member determine member ( final cluster member [ ] cluster members , final int member id , final string member endpoints ) { cluster member member = null value != member id ? cluster member . find member ( cluster members , member id ) : null ; if ( ( null == cluster members || num == cluster members . length ) && null == member ) { member = cluster member . parse endpoints ( null value , member endpoints ) ; } else { if ( null == member ) { throw new cluster exception ( str + member id + str ) ; } if ( ! str . equals ( member endpoints ) ) { cluster member . validate member endpoints ( member , member endpoints ) ; } } return member ; }	Determine which member of a cluster this is and check endpoints.
public static void validate member endpoints ( final cluster member member , final string member endpoints ) { final cluster member endpoint member = cluster member . parse endpoints ( aeron . null value , member endpoints ) ; if ( ! are same endpoints ( member , endpoint member ) ) { throw new cluster exception ( str + member . endpoints detail ( ) + str + member endpoints ) ; } }	Check the member with the memberEndpoints.
public static boolean are same endpoints ( final cluster member lhs , final cluster member rhs ) { return lhs . client facing endpoint ( ) . equals ( rhs . client facing endpoint ( ) ) && lhs . member facing endpoint ( ) . equals ( rhs . member facing endpoint ( ) ) && lhs . log endpoint ( ) . equals ( rhs . log endpoint ( ) ) && lhs . transfer endpoint ( ) . equals ( rhs . transfer endpoint ( ) ) && lhs . archive endpoint ( ) . equals ( rhs . archive endpoint ( ) ) ; }	Are two cluster members using the same endpoints?.
public static boolean is unanimous candidate ( final cluster member [ ] cluster members , final cluster member candidate ) { for ( final cluster member member : cluster members ) { if ( null position == member . log position || compare log ( candidate , member ) < num ) { return bool ; } } return bool ; }	Has the member achieved a unanimous view to be a suitable candidate in an election.
public static boolean is quorum candidate ( final cluster member [ ] cluster members , final cluster member candidate ) { int possible votes = num ; for ( final cluster member member : cluster members ) { if ( null position == member . log position || compare log ( candidate , member ) < num ) { continue ; } ++ possible votes ; } return possible votes >= cluster member . quorum threshold ( cluster members . length ) ; }	Has the member achieved a quorum view to be a suitable candidate in an election.
public static boolean is not duplicate endpoints ( final cluster member [ ] members , final string member endpoints ) { for ( final cluster member member : members ) { if ( member . endpoints detail ( ) . equals ( member endpoints ) ) { return bool ; } } return bool ; }	Is the string of member endpoints not duplicated in the members.
public static int find member index ( final cluster member [ ] cluster members , final int member id ) { final int length = cluster members . length ; int index = array util . unknown index ; for ( int i = num ; i < length ; i ++ ) { if ( cluster members [ i ] . id ( ) == member id ) { index = i ; } } return index ; }	Find the index at which a member id is present.
public static cluster member [ ] remove member ( final cluster member [ ] old members , final int member id ) { return array util . remove ( old members , find member index ( old members , member id ) ) ; }	Remove a member from an array if found, otherwise return the array unmodified.
public static int high member id ( final cluster member [ ] cluster members ) { int high id = aeron . null value ; for ( final cluster member member : cluster members ) { high id = math . max ( high id , member . id ( ) ) ; } return high id ; }	Find the highest member id in an array of members.
public mapped byte buffer map existing cnc file ( final consumer < string > logger ) { final file cnc file = new file ( aeron directory , cnc file descriptor . cnc file ) ; if ( cnc file . exists ( ) && cnc file . length ( ) > num ) { if ( null != logger ) { logger . accept ( str + cnc file ) ; } return io util . map existing file ( cnc file , cnc file descriptor . cnc file ) ; } return null ; }	Map the CnC file if it exists.
public static boolean is driver active ( final file directory , final long driver timeout ms , final consumer < string > logger ) { final file cnc file = new file ( directory , cnc file descriptor . cnc file ) ; if ( cnc file . exists ( ) && cnc file . length ( ) > num ) { logger . accept ( str + cnc file ) ; final mapped byte buffer cnc byte buffer = io util . map existing file ( cnc file , str ) ; try { return is driver active ( driver timeout ms , logger , cnc byte buffer ) ; } finally { io util . unmap ( cnc byte buffer ) ; } } return bool ; }	Is a media driver active in the given directory?.
public boolean is driver active ( final long driver timeout ms , final consumer < string > logger ) { final mapped byte buffer cnc byte buffer = map existing cnc file ( logger ) ; try { return is driver active ( driver timeout ms , logger , cnc byte buffer ) ; } finally { io util . unmap ( cnc byte buffer ) ; } }	Is a media driver active in the current Aeron directory?.
public static boolean is driver active ( final long driver timeout ms , final consumer < string > logger , final byte buffer cnc byte buffer ) { if ( null == cnc byte buffer ) { return bool ; } final unsafe buffer cnc meta data buffer = cnc file descriptor . create meta data buffer ( cnc byte buffer ) ; final long start time ms = system . current time millis ( ) ; int cnc version ; while ( num == ( cnc version = cnc meta data buffer . get int volatile ( cnc file descriptor . cnc version offset ( num ) ) ) ) { if ( system . current time millis ( ) > ( start time ms + driver timeout ms ) ) { throw new driver timeout exception ( str ) ; } sleep ( num ) ; } if ( cnc version != cnc version ) { throw new aeron exception ( str + cnc version + str + cnc version ) ; } final many to one ring buffer to driver buffer = new many to one ring buffer ( cnc file descriptor . create to driver buffer ( cnc byte buffer , cnc meta data buffer ) ) ; final long timestamp = to driver buffer . consumer heartbeat time ( ) ; final long now = system . current time millis ( ) ; final long timestamp age = now - timestamp ; logger . accept ( str + timestamp age ) ; return timestamp age <= driver timeout ms ; }	Is a media driver active in the current mapped CnC buffer? If the driver is mid start then it will wait forup to the driverTimeoutMs by checking for the cncVersion being set.
public static boolean request driver termination ( final file directory , final direct buffer token buffer , final int token offset , final int token length ) { final file cnc file = new file ( directory , cnc file descriptor . cnc file ) ; if ( cnc file . exists ( ) && cnc file . length ( ) > num ) { final mapped byte buffer cnc byte buffer = io util . map existing file ( cnc file , str ) ; try { final unsafe buffer cnc meta data buffer = cnc file descriptor . create meta data buffer ( cnc byte buffer ) ; final int cnc version = cnc meta data buffer . get int volatile ( cnc version offset ( num ) ) ; if ( cnc file descriptor . cnc version != cnc version ) { throw new aeron exception ( str + cnc version + str + cnc version ) ; } final many to one ring buffer to driver buffer = new many to one ring buffer ( cnc file descriptor . create to driver buffer ( cnc byte buffer , cnc meta data buffer ) ) ; final long client id = to driver buffer . next correlation id ( ) ; final driver proxy driver proxy = new driver proxy ( to driver buffer , client id ) ; return driver proxy . terminate driver ( token buffer , token offset , token length ) ; } finally { io util . unmap ( cnc byte buffer ) ; } } return bool ; }	Request a driver to run its termination hook.
public static int frame length volatile ( final unsafe buffer buffer , final int term offset ) { int frame length = buffer . get int volatile ( term offset ) ; if ( byte order . native order ( ) != little endian ) { frame length = integer . reverse bytes ( frame length ) ; } return frame length ; }	Get the length of a frame from the header as a volatile read.
public static void frame length ordered ( final unsafe buffer buffer , final int term offset , final int frame length ) { int length = frame length ; if ( byte order . native order ( ) != little endian ) { length = integer . reverse bytes ( frame length ) ; } buffer . put int ordered ( term offset , length ) ; }	Write the length header for a frame in a memory ordered fashion.
public static void frame type ( final unsafe buffer buffer , final int term offset , final int type ) { buffer . put short ( type offset ( term offset ) , ( short ) type , little endian ) ; }	Write the type field for a frame.
public static void frame flags ( final unsafe buffer buffer , final int term offset , final byte flags ) { buffer . put byte ( flags offset ( term offset ) , flags ) ; }	Write the flags field for a frame.
public static void frame term offset ( final unsafe buffer buffer , final int term offset ) { buffer . put int ( term offset offset ( term offset ) , term offset , little endian ) ; }	Write the term offset field for a frame.
public static void frame term id ( final unsafe buffer buffer , final int term offset , final int term id ) { buffer . put int ( term id offset ( term offset ) , term id , little endian ) ; }	Write the term id field for a frame.
public static int find counter id by recording ( final counters reader counters reader , final long recording id ) { final direct buffer buffer = counters reader . meta data buffer ( ) ; for ( int i = num , size = counters reader . max counter id ( ) ; i < size ; i ++ ) { if ( counters reader . get counter state ( i ) == record allocated ) { final int record offset = counters reader . meta data offset ( i ) ; if ( buffer . get int ( record offset + type id offset ) == recording position type id && buffer . get long ( record offset + key offset + recording id offset ) == recording id ) { return i ; } } } return null counter id ; }	Find the active counter id for a stream based on the recording id.
public static int find counter id by session ( final counters reader counters reader , final int session id ) { final direct buffer buffer = counters reader . meta data buffer ( ) ; for ( int i = num , size = counters reader . max counter id ( ) ; i < size ; i ++ ) { if ( counters reader . get counter state ( i ) == record allocated ) { final int record offset = counters reader . meta data offset ( i ) ; if ( buffer . get int ( record offset + type id offset ) == recording position type id && buffer . get int ( record offset + key offset + session id offset ) == session id ) { return i ; } } } return null counter id ; }	Find the active counter id for a stream based on the session id.
public static long get recording id ( final counters reader counters reader , final int counter id ) { final direct buffer buffer = counters reader . meta data buffer ( ) ; if ( counters reader . get counter state ( counter id ) == record allocated ) { final int record offset = counters reader . meta data offset ( counter id ) ; if ( buffer . get int ( record offset + type id offset ) == recording position type id ) { return buffer . get long ( record offset + key offset + recording id offset ) ; } } return null recording id ; }	Get the recording id for a given counter id.
public static boolean is active ( final counters reader counters reader , final int counter id , final long recording id ) { final direct buffer buffer = counters reader . meta data buffer ( ) ; if ( counters reader . get counter state ( counter id ) == record allocated ) { final int record offset = counters reader . meta data offset ( counter id ) ; return buffer . get int ( record offset + type id offset ) == recording position type id && buffer . get long ( record offset + key offset + recording id offset ) == recording id ; } return bool ; }	Is the recording counter still active.
public status message flyweight application specific feedback ( final byte [ ] source , final int offset , final int length ) { frame length ( header length + length ) ; put bytes ( app specific feedback field offset , source , offset , length ) ; return this ; }	Set the Application Specific Feedback for the Status Message.
public void reload ( ) { entries . clear ( ) ; index by leadership term id map . clear ( ) ; index by leadership term id map . compact ( ) ; next entry index = num ; byte buffer . clear ( ) ; try { while ( bool ) { final int bytes = file channel . read ( byte buffer ) ; if ( byte buffer . remaining ( ) == num ) { byte buffer . flip ( ) ; capture entries from buffer ( byte buffer , buffer , entries ) ; byte buffer . clear ( ) ; } if ( - num == bytes ) { if ( byte buffer . position ( ) > num ) { byte buffer . flip ( ) ; capture entries from buffer ( byte buffer , buffer , entries ) ; byte buffer . clear ( ) ; } break ; } } } catch ( final io ex ) { lang util . rethrow unchecked ( ex ) ; } }	Reload the log from disk.
public entry find last term ( ) { for ( int i = entries . size ( ) - num ; i >= num ; i -- ) { final entry entry = entries . get ( i ) ; if ( entry type term == entry . type ) { return entry ; } } return null ; }	Find the last leadership term in the recording log.
public recovery plan create recovery plan ( final aeron archive archive , final int service count ) { final array list < snapshot > snapshots = new array list < > ( ) ; final array list < log > logs = new array list < > ( ) ; plan recovery ( snapshots , logs , entries , archive , service count ) ; long last leadership term id = null value ; long last term base log position = num ; long committed log position = - num ; long appended log position = num ; final int snapshot steps size = snapshots . size ( ) ; if ( snapshot steps size > num ) { final snapshot snapshot = snapshots . get ( num ) ; last leadership term id = snapshot . leadership term id ; last term base log position = snapshot . term base log position ; appended log position = snapshot . log position ; committed log position = snapshot . log position ; } if ( ! logs . is empty ( ) ) { final log log = logs . get ( num ) ; last leadership term id = log . leadership term id ; last term base log position = log . term base log position ; appended log position = log . stop position ; committed log position = log . log position ; } return new recovery plan ( last leadership term id , last term base log position , appended log position , committed log position , snapshots , logs ) ; }	Create a recovery plan for the cluster that when the steps are replayed will bring the cluster back to thelatest stable state.
public static recovery plan create recovery plan ( final array list < recording log . snapshot > snapshots ) { long last leadership term id = null value ; long last term base log position = num ; long committed log position = - num ; long appended log position = num ; final int snapshot steps size = snapshots . size ( ) ; if ( snapshot steps size > num ) { final snapshot snapshot = snapshots . get ( num ) ; last leadership term id = snapshot . leadership term id ; last term base log position = snapshot . term base log position ; appended log position = snapshot . log position ; committed log position = snapshot . log position ; } return new recovery plan ( last leadership term id , last term base log position , appended log position , committed log position , snapshots , new array list < > ( ) ) ; }	Create a recovery plan that has only snapshots.
public void append term ( final long recording id , final long leadership term id , final long term base log position , final long timestamp ) { final int size = entries . size ( ) ; if ( size > num ) { final entry last entry = entries . get ( size - num ) ; if ( last entry . type != null value && last entry . leadership term id >= leadership term id ) { throw new cluster exception ( str + last entry . leadership term id + str + leadership term id ) ; } } index by leadership term id map . put ( leadership term id , next entry index ) ; append ( entry type term , recording id , leadership term id , term base log position , null position , timestamp , null value ) ; }	Append a log entry for a leadership term.
public void append snapshot ( final long recording id , final long leadership term id , final long term base log position , final long log position , final long timestamp , final int service id ) { final int size = entries . size ( ) ; if ( size > num ) { final entry entry = entries . get ( size - num ) ; if ( entry . type == entry type term && entry . leadership term id != leadership term id ) { throw new cluster exception ( str + entry . leadership term id + str + leadership term id ) ; } } append ( entry type snapshot , recording id , leadership term id , term base log position , log position , timestamp , service id ) ; }	Append a log entry for a snapshot.
public void commit log position ( final long leadership term id , final long log position ) { final int index = get leadership term entry index ( leadership term id ) ; commit entry value ( index , log position , log position offset ) ; final entry entry = entries . get ( index ) ; entries . set ( index , new entry ( entry . recording id , entry . leadership term id , entry . term base log position , log position , entry . timestamp , entry . service id , entry . type , entry . entry index ) ) ; }	Commit the position reached in a leadership term before a clean shutdown.
public void tombstone entry ( final long leadership term id , final int entry index ) { int index = - num ; for ( int i = num , size = entries . size ( ) ; i < size ; i ++ ) { final entry entry = entries . get ( i ) ; if ( entry . leadership term id == leadership term id && entry . entry index == entry index ) { index = entry . entry index ; if ( entry type term == entry . type ) { index by leadership term id map . remove ( leadership term id ) ; } break ; } } if ( - num == index ) { throw new cluster exception ( str + entry index ) ; } buffer . put int ( num , null value , little endian ) ; byte buffer . limit ( size of int ) . position ( num ) ; final long file position = ( index * ( long ) entry length ) + entry type offset ; try { if ( size of int != file channel . write ( byte buffer , file position ) ) { throw new cluster exception ( str ) ; } } catch ( final exception ex ) { lang util . rethrow unchecked ( ex ) ; } }	Tombstone an entry in the log so it is no longer valid.
public void close ( ) { if ( null != publication && publication . is connected ( ) ) { close session ( ) ; } if ( ! ctx . owns aeron client ( ) ) { close helper . close ( subscription ) ; close helper . close ( publication ) ; } ctx . close ( ) ; }	Close session and release associated resources.
public long offer ( final direct buffer vector [ ] vectors ) { if ( header vector != vectors [ num ] ) { vectors [ num ] = header vector ; } return publication . offer ( vectors , null ) ; }	Non-blocking publish by gathering buffer vectors into a message.
public static boolean unblock ( final unsafe buffer [ ] term buffers , final unsafe buffer log meta data buffer , final long blocked position , final int term length ) { final int position bits to shift = log buffer descriptor . position bits to shift ( term length ) ; final int blocked term count = ( int ) ( blocked position > > position bits to shift ) ; final int blocked offset = ( int ) blocked position & ( term length - num ) ; final int active term count = active term count ( log meta data buffer ) ; if ( active term count == ( blocked term count - num ) && blocked offset == num ) { final int current term id = term id ( raw tail volatile ( log meta data buffer , index by term count ( active term count ) ) ) ; return rotate log ( log meta data buffer , active term count , current term id ) ; } final int blocked index = index by term count ( blocked term count ) ; final long raw tail = raw tail volatile ( log meta data buffer , blocked index ) ; final int term id = term id ( raw tail ) ; final int tail offset = term offset ( raw tail , term length ) ; final unsafe buffer term buffer = term buffers [ blocked index ] ; switch ( term unblocker . unblock ( log meta data buffer , term buffer , blocked offset , tail offset , term id ) ) { case unblocked to end : rotate log ( log meta data buffer , blocked term count , term id ) ;	Attempt to unblock a log buffer at given position.
public string channel ( ) { final int length = buffer . get int ( offset + channel offset ) ; length of channel = size of int + length ; return buffer . get string ascii ( offset + channel offset , length ) ; }	Get the channel field as ASCII.
public image message flyweight channel ( final string channel ) { length of channel = buffer . put string ascii ( offset + channel offset , channel ) ; return this ; }	Set the channel field as ASCII.
public static void check term length ( final int term length ) { if ( term length < term min length ) { throw new illegal state exception ( str + term min length + str + term length ) ; } if ( term length > term max length ) { throw new illegal state exception ( str + term max length + str + term length ) ; } if ( ! bit util . is power of two ( term length ) ) { throw new illegal state exception ( str + term length ) ; } }	Check that term length is valid and alignment is valid.
public static void check page size ( final int page size ) { if ( page size < page min size ) { throw new illegal state exception ( str + page min size + str + page size ) ; } if ( page size > page max size ) { throw new illegal state exception ( str + page max size + str + page size ) ; } if ( ! bit util . is power of two ( page size ) ) { throw new illegal state exception ( str + page size ) ; } }	Check that page size is valid and alignment is valid.
public static boolean cas active term count ( final unsafe buffer metadata buffer , final int expected term count , final int update term count ) { return metadata buffer . compare and set int ( log active term count offset , expected term count , update term count ) ; }	Compare and set the value of the current active term count.
public static long compute position ( final int active term id , final int term offset , final int position bits to shift , final int initial term id ) { final long term count = active term id - initial term id ;	Compute the current position in absolute number of bytes.
public static long compute log length ( final int term length , final int file page size ) { if ( term length < ( num * num * num ) ) { return align ( ( term length * partition count ) + log meta data length , file page size ) ; } return ( partition count * ( long ) term length ) + align ( log meta data length , file page size ) ; }	Compute the total length of a log file given the term length.Assumes {.
public static void store default frame header ( final unsafe buffer metadata buffer , final direct buffer default header ) { if ( default header . capacity ( ) != header length ) { throw new illegal argument exception ( str + default header . capacity ( ) ) ; } metadata buffer . put int ( log default frame header length offset , header length ) ; metadata buffer . put bytes ( log default frame header offset , default header , num , header length ) ; }	Store the default frame header to the log meta data buffer.
public static void apply default header ( final unsafe buffer metadata buffer , final unsafe buffer term buffer , final int term offset ) { term buffer . put bytes ( term offset , metadata buffer , log default frame header offset , header length ) ; }	Apply the default header for a message in a term.
public static boolean rotate log ( final unsafe buffer metadata buffer , final int term count , final int term id ) { final int next term id = term id + num ; final int next term count = term count + num ; final int next index = index by term count ( next term count ) ; final int expected term id = next term id - partition count ; long raw tail ; do { raw tail = raw tail ( metadata buffer , next index ) ; if ( expected term id != term id ( raw tail ) ) { break ; } } while ( ! cas raw tail ( metadata buffer , next index , raw tail , pack tail ( next term id , num ) ) ) ; return cas active term count ( metadata buffer , term count , next term count ) ; }	Rotate the log and update the tail counter for the new term.This method is safe for concurrent use.
public static void initialise tail with term id ( final unsafe buffer metadata buffer , final int partition index , final int term id ) { metadata buffer . put long ( term tail counters offset + ( partition index * size of long ) , pack tail ( term id , num ) ) ; }	Set the initial value for the termId in the upper bits of the tail counter.
public static int term offset ( final long raw tail , final long term length ) { final long tail = raw tail & num ; return ( int ) math . min ( tail , term length ) ; }	Read the termOffset from a packed raw tail value.
public static long raw tail volatile ( final unsafe buffer metadata buffer ) { final int partition index = index by term count ( active term count ( metadata buffer ) ) ; return metadata buffer . get long volatile ( term tail counters offset + ( size of long * partition index ) ) ; }	Get the raw value of the tail for the current active partition.
public static boolean cas raw tail ( final unsafe buffer metadata buffer , final int partition index , final long expected raw tail , final long update raw tail ) { final int index = term tail counters offset + ( size of long * partition index ) ; return metadata buffer . compare and set long ( index , expected raw tail , update raw tail ) ; }	Compare and set the raw value of the tail for the given partition.
public terminate driver flyweight token buffer ( final direct buffer token buffer , final int token offset , final int token length ) { buffer . put int ( token length offset , token length ) ; if ( null != token buffer && token length > num ) { buffer . put bytes ( token buffer offset ( ) , token buffer , token offset , token length ) ; } return this ; }	Fill the token buffer.
public static counter allocate ( final aeron aeron , final mutable direct buffer temp buffer , final long leadership term id , final long log position , final long timestamp , final boolean has replay , final long ... snapshot recording ids ) { temp buffer . put long ( leadership term id offset , leadership term id ) ; temp buffer . put long ( log position offset , log position ) ; temp buffer . put long ( timestamp offset , timestamp ) ; temp buffer . put int ( replay flag offset , has replay ? num : num ) ; final int service count = snapshot recording ids . length ; temp buffer . put int ( service count offset , service count ) ; final int key length = snapshot recording ids offset + ( service count * size of long ) ; if ( key length > max key length ) { throw new cluster exception ( key length + str + max key length ) ; } for ( int i = num ; i < service count ; i ++ ) { temp buffer . put long ( snapshot recording ids offset + ( i * size of long ) , snapshot recording ids [ i ] ) ; } final int label offset = bit util . align ( key length , size of int ) ; int label length = num ; label length += temp buffer . put string without length ascii ( label offset + label length , name ) ; label length += temp buffer . put long ascii ( key length + label length , leadership term id ) ; label length += temp buffer . put string without length ascii ( label offset + label length , str ) ; label length += temp buffer . put long ascii ( label offset + label length , log position ) ; label length += temp buffer . put string without length ascii ( label offset + label length , str + has replay ) ; return aeron . add counter ( recovery state type id , temp buffer , num , key length , temp buffer , label offset , label length ) ; }	Allocate a counter to represent the snapshot services should load on start.
public static int find counter id ( final counters reader counters ) { final direct buffer buffer = counters . meta data buffer ( ) ; for ( int i = num , size = counters . max counter id ( ) ; i < size ; i ++ ) { if ( counters . get counter state ( i ) == record allocated ) { final int record offset = counters reader . meta data offset ( i ) ; if ( buffer . get int ( record offset + type id offset ) == recovery state type id ) { return i ; } } } return null counter id ; }	Find the active counter id for recovery state.
public static boolean has replay ( final counters reader counters , final int counter id ) { final direct buffer buffer = counters . meta data buffer ( ) ; if ( counters . get counter state ( counter id ) == record allocated ) { final int record offset = counters reader . meta data offset ( counter id ) ; if ( buffer . get int ( record offset + type id offset ) == recovery state type id ) { return buffer . get int ( record offset + key offset + replay flag offset ) == num ; } } return bool ; }	Has the recovery process got a log to replay?.
public static long get snapshot recording id ( final counters reader counters , final int counter id , final int service id ) { final direct buffer buffer = counters . meta data buffer ( ) ; if ( counters . get counter state ( counter id ) == record allocated ) { final int record offset = counters reader . meta data offset ( counter id ) ; if ( buffer . get int ( record offset + type id offset ) == recovery state type id ) { final int service count = buffer . get int ( record offset + key offset + service count offset ) ; if ( service id < num || service id >= service count ) { throw new cluster exception ( str + service id + str + service count ) ; } return buffer . get long ( record offset + key offset + snapshot recording ids offset + ( service id * size of long ) ) ; } } throw new cluster exception ( str + counter id ) ; }	Get the recording id of the snapshot for a service.
public static char [ ] flags to chars ( final short flags ) { final char [ ] chars = new char [ ] { str , str , str , str , str , str , str , str } ; final int length = chars . length ; short mask = ( short ) ( num << ( length - num ) ) ; for ( int i = num ; i < length ; i ++ ) { if ( ( flags & mask ) == mask ) { chars [ i ] = str ; } mask >>= num ; } return chars ; }	Convert header flags to an array of chars to be human readable.
public publication message flyweight channel ( final string channel ) { length of channel = buffer . put string ascii ( offset + channel offset , channel ) ; return this ; }	Set the channel field in ASCII.
public long offer ( final direct buffer buffer , final int offset , final int length ) { return cluster . offer ( id , response publication , buffer , offset , length ) ; }	Non-blocking publish of a partial buffer containing a message to a cluster.
public final void wrap ( final atomic buffer buffer , final int offset , final int length ) { this . buffer . wrap ( buffer , offset , length ) ; }	Wrap a region of an underlying log buffer so can can represent a claimed space for use by a publisher.
public final void commit ( ) { int frame length = buffer . capacity ( ) ; if ( byte order . native order ( ) != little endian ) { frame length = integer . reverse bytes ( frame length ) ; } buffer . put int ordered ( frame length field offset , frame length ) ; }	Commit the message to the log buffer so that is it available to subscribers.
public final void abort ( ) { int frame length = buffer . capacity ( ) ; if ( byte order . native order ( ) != little endian ) { frame length = integer . reverse bytes ( frame length ) ; } buffer . put short ( type field offset , ( short ) hdr type pad , little endian ) ; buffer . put int ordered ( frame length field offset , frame length ) ; }	Abort a claim of the message space to the log buffer so that the log can progress by ignoring this claim.
public static void main ( final string [ ] args ) { load properties files ( args ) ; final shutdown signal barrier barrier = new shutdown signal barrier ( ) ; final media driver . context ctx = new media driver . context ( ) ; ctx . termination hook ( barrier :: signal ) ; try ( media driver ignore = media driver . launch ( ctx ) ) { barrier . await ( ) ; system . out . println ( str ) ; } }	Start Media Driver as a stand-alone process.
public void close ( ) { close helper . close ( shared runner ) ; close helper . close ( shared network runner ) ; close helper . close ( receiver runner ) ; close helper . close ( sender runner ) ; close helper . close ( conductor runner ) ; close helper . close ( shared invoker ) ; if ( ctx . use windows high res timer ( ) && system util . os name ( ) . starts with ( str ) ) { if ( ! was high res timer enabled ) { high resolution timer . disable ( ) ; } } }	Shutdown the media driver by stopping all threads and freeing resources.
public final long position ( ) { final int resulting offset = bit util . align ( term offset ( ) + frame length ( ) , frame alignment ) ; return compute position ( term id ( ) , resulting offset , position bits to shift , initial term id ) ; }	Get the current position to which the image has advanced on reading this message.
public static counter allocate ( final aeron aeron , final mutable direct buffer temp buffer , final int service id ) { temp buffer . put int ( service id offset , service id ) ; final int label offset = bit util . align ( key length , size of int ) ; int label length = num ; label length += temp buffer . put string without length ascii ( label offset + label length , name ) ; label length += temp buffer . put int ascii ( label offset + label length , service id ) ; return aeron . add counter ( service heartbeat type id , temp buffer , num , key length , temp buffer , label offset , label length ) ; }	Allocate a counter to represent the heartbeat of a clustered service.
public static int find counter id ( final counters reader counters , final int service id ) { final direct buffer buffer = counters . meta data buffer ( ) ; for ( int i = num , size = counters . max counter id ( ) ; i < size ; i ++ ) { if ( counters . get counter state ( i ) == record allocated ) { final int record offset = counters reader . meta data offset ( i ) ; if ( buffer . get int ( record offset + type id offset ) == service heartbeat type id && buffer . get int ( record offset + key offset + service id offset ) == service id ) { return i ; } } } return null counter id ; }	Find the active counter id for heartbeat of a given service id.
public static atomic counter allocate ( final mutable direct buffer temp buffer , final string name , final int type id , final counters manager counters manager , final long registration id ) { return new atomic counter ( counters manager . values buffer ( ) , allocate counter id ( temp buffer , name , type id , counters manager , registration id ) , counters manager ) ; }	Allocate a counter for tracking the last heartbeat of an entity.
public void close ( ) { final mapped byte buffer cnc byte buffer = this . cnc byte buffer ; this . cnc byte buffer = null ; io util . unmap ( cnc byte buffer ) ; super . close ( ) ; }	Clean up all resources that the client uses to communicate with the Media Driver.
public static void dispatch descriptor ( final recording descriptor decoder decoder , final recording descriptor consumer consumer ) { consumer . on recording descriptor ( decoder . control session id ( ) , decoder . correlation id ( ) , decoder . recording id ( ) , decoder . start timestamp ( ) , decoder . stop timestamp ( ) , decoder . start position ( ) , decoder . stop position ( ) , decoder . initial term id ( ) , decoder . segment file length ( ) , decoder . term buffer length ( ) , decoder . mtu length ( ) , decoder . session id ( ) , decoder . stream id ( ) , decoder . stripped channel ( ) , decoder . original channel ( ) , decoder . source identity ( ) ) ; }	Dispatch a descriptor message to a consumer by reading the fields in the correct order.
private void add slab ( int minimum size ) { int next slab size ; if ( bytes used == num ) { next slab size = initial slab size ; } else if ( bytes used > max capacity hint / num ) {	the new slab is guaranteed to be at least minimumSize.
public void set byte ( long index , byte value ) { check argument ( index < bytes used , str + index + str + bytes used ) ; long seen = num ; for ( int i = num ; i < slabs . size ( ) ; i ++ ) { byte buffer slab = slabs . get ( i ) ; if ( index < seen + slab . limit ( ) ) {	Replace the byte stored at position index in this stream with value.
public void add ( statistics < ? > stats ) { if ( stats . has non null value ( ) ) { null pages . add ( bool ) ; object min = stats . generic get min ( ) ; object max = stats . generic get max ( ) ; add min max ( min , max ) ; page indexes . add ( next page index ) ; min max size += size of ( min ) ; min max size += size of ( max ) ; } else { null pages . add ( bool ) ; } null counts . add ( stats . get num nulls ( ) ) ; ++ next page index ; }	Adds the data from the specified statistics to this builder.
private static group type convert array type ( final string name , final list type info type info ) { final type info sub type = type info . get list element type info ( ) ; return list wrapper ( name , list type ( ) , new group type ( repetition . repeated , parquet hive ser de . array . to string ( ) , convert type ( str , sub type ) ) ) ; }	1 anonymous element "array_element".
private static group type convert struct type ( final string name , final struct type info type info ) { final list < string > column names = type info . get all struct field names ( ) ; final list < type info > column types = type info . get all struct field type infos ( ) ; return new group type ( repetition . optional , name , convert types ( column names , column types ) ) ; }	An optional group containing multiple elements.
private static string annotate message ( string message , int pos ) { string builder sb = new string builder ( message ) ; sb . append ( str ) ; for ( int i = num ; i < pos ; i ++ ) { sb . append ( str ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	for pretty printing which character had the error.
private void end previous bit packed run ( ) { if ( bit packed run header pointer == - num ) {	If we are currently writing a bit-packed-run, update thebit-packed-header and consider this run to be overdoes nothing if we're not currently writing a bit-packed run.
@ override public void read one ( t in , t out ) throws t { read one struct ( in , out ) ; }	reads one record from in and writes it to outexceptions are not recoverable as record might be halfway written.
@ deprecated public static list < footer > read footers ( configuration configuration , file status path status ) throws io { return read footers ( configuration , path status , bool ) ; }	this always returns the row groups.
@ deprecated public static list < footer > read summary file ( configuration configuration , file status summary status ) throws io { final path parent = summary status . get path ( ) . get parent ( ) ; parquet metadata merged footers = read footer ( configuration , summary status , filter ( bool ) ) ; return footers from summary file ( parent , merged footers ) ; }	Specifically reads a given summary file.
@ deprecated public static final parquet metadata read footer ( input file file , metadata filter filter ) throws io { parquet read options options ; if ( file instanceof hadoop input file ) { options = hadoop read options . builder ( ( ( hadoop input file ) file ) . get configuration ( ) ) . with metadata filter ( filter ) . build ( ) ; } else { options = parquet read options . builder ( ) . with metadata filter ( filter ) . build ( ) ; } try ( seekable input stream in = file . new stream ( ) ) { return read footer ( file , options , in ) ; } }	Reads the meta data block in the footer of the file using provided input stream.
public page read store read next row group ( ) throws io { if ( current block == blocks . size ( ) ) { return null ; } block meta data block = blocks . get ( current block ) ; if ( block . get row count ( ) == num ) { throw new runtime exception ( str ) ; } this . current row group = new column chunk page read store ( block . get row count ( ) ) ;	Reads all the columns requested from the row group at the current file position.
public page read store read next filtered row group ( ) throws io { if ( current block == blocks . size ( ) ) { return null ; } if ( ! options . use column index filter ( ) ) { return read next row group ( ) ; } block meta data block = blocks . get ( current block ) ; if ( block . get row count ( ) == num ) { throw new runtime exception ( str ) ; } column index store ci store = get column index store ( current block ) ; row ranges row ranges = get row ranges ( current block ) ; long row count = row ranges . row count ( ) ; if ( row count == num ) {	Reads all the columns requested from the row group at the current file position.
dictionary page read dictionary ( column chunk meta data meta ) throws io { if ( ! meta . get encodings ( ) . contains ( encoding . plain dictionary ) && ! meta . get encodings ( ) . contains ( encoding . rle dictionary ) ) { return null ; }	Reads and decompresses a dictionary page for the given column chunk.Returns null if the given column chunk has no dictionary page.
synchronized void add writer ( internal parquet record writer writer , long allocation ) { long old value = writer list . get ( writer ) ; if ( old value == null ) { writer list . put ( writer , allocation ) ; } else { throw new illegal argument exception ( str + str + str + writer ) ; } update allocation ( ) ; }	Add a new writer and its memory allocation to the memory manager.
synchronized void remove writer ( internal parquet record writer writer ) { if ( writer list . contains key ( writer ) ) { writer list . remove ( writer ) ; } if ( ! writer list . is empty ( ) ) { update allocation ( ) ; } }	Remove the given writer from the memory manager.
private void update allocation ( ) { long total allocations = num ; for ( long allocation : writer list . values ( ) ) { total allocations += allocation ; } if ( total allocations <= total memory pool ) { scale = num ; } else { scale = ( double ) total memory pool / total allocations ; log . warn ( string . format ( str + str , num * memory pool ratio , total memory pool , num * scale , writer list . size ( ) ) ) ; for ( runnable call back : call backs . values ( ) ) {	Update the allocated size of each writer based on the current allocations and pool size.
public void register scale call back ( string call back name , runnable call back ) { preconditions . check not null ( call back name , str ) ; preconditions . check not null ( call back , str ) ; if ( call backs . contains key ( call back name ) ) { throw new illegal argument exception ( str + call back name + str ) ; } else { call backs . put ( call back name , call back ) ; } }	Register callback and deduplicate it if any.
public void start ( ) throws io { state = state . start ( ) ; log . debug ( str , out . get pos ( ) ) ; out . write ( magic ) ; }	start the file.
public void start block ( long record count ) throws io { state = state . start block ( ) ; log . debug ( str , out . get pos ( ) ) ;	start a block.
public void start column ( column descriptor descriptor , long value count , compression codec name compression codec name ) throws io { state = state . start column ( ) ; encoding stats builder . clear ( ) ; current encodings = new hash set < encoding > ( ) ; current chunk path = column path . get ( descriptor . get path ( ) ) ; current chunk type = descriptor . get primitive type ( ) ; current chunk codec = compression codec name ; current chunk value count = value count ; current chunk first data page = out . get pos ( ) ; compressed length = num ; uncompressed length = num ;	start a column inside a block.
public void write dictionary page ( dictionary page dictionary page ) throws io { state = state . write ( ) ; log . debug ( str , out . get pos ( ) , dictionary page . get dictionary size ( ) ) ; current chunk dictionary page offset = out . get pos ( ) ; int uncompressed size = dictionary page . get uncompressed size ( ) ; int compressed page size = ( int ) dictionary page . get bytes ( ) . size ( ) ;	writes a dictionary page page.
public void write data page ( int value count , int uncompressed page size , bytes input bytes , statistics statistics , long row count , encoding rl encoding , encoding dl encoding , encoding values encoding ) throws io { long before header = out . get pos ( ) ; inner write data page ( value count , uncompressed page size , bytes , statistics , rl encoding , dl encoding , values encoding ) ; offset index builder . add ( ( int ) ( out . get pos ( ) - before header ) , row count ) ; }	Writes a single page.
public void end block ( ) throws io { state = state . end block ( ) ; log . debug ( str , out . get pos ( ) ) ; current block . set row count ( current record count ) ; blocks . add ( current block ) ; column indexes . add ( current column indexes ) ; offset indexes . add ( current offset indexes ) ; current column indexes = null ; current offset indexes = null ; current block = null ; }	ends a block once all column chunks have been written.
private static void copy ( seekable input stream from , position output stream to , long start , long length ) throws io { log . debug ( str , length , start , to . get pos ( ) ) ; from . seek ( start ) ; long bytes copied = num ; byte [ ] buffer = copy buffer . get ( ) ; while ( bytes copied < length ) { long bytes left = length - bytes copied ; int bytes read = from . read ( buffer , num , ( buffer . length < bytes left ? buffer . length : ( int ) bytes left ) ) ; if ( bytes read < num ) { throw new illegal argument exception ( str + start + bytes copied ) ; } to . write ( buffer , num , bytes read ) ; bytes copied += bytes read ; } }	Copy from a FS input stream to an output stream. Thread-safe.
public void end ( map < string , string > extra meta data ) throws io { state = state . end ( ) ; serialize column indexes ( column indexes , blocks , out ) ; serialize offset indexes ( offset indexes , blocks , out ) ; log . debug ( str , out . get pos ( ) ) ; this . footer = new parquet metadata ( new file meta data ( schema , extra meta data , version . full version ) , blocks ) ; serialize footer ( footer , out ) ; out . close ( ) ; }	ends a file once all blocks have been written.closes the file.
@ deprecated public static parquet metadata merge metadata files ( list < path > files , configuration conf ) throws io { preconditions . check argument ( ! files . is empty ( ) , str ) ; global meta data global meta data = null ; list < block meta data > blocks = new array list < block meta data > ( ) ; for ( path p : files ) { parquet metadata pmd = parquet file reader . read footer ( conf , p , parquet metadata converter . no filter ) ; file meta data fmd = pmd . get file meta data ( ) ; global meta data = merge into ( fmd , global meta data , bool ) ; blocks . add all ( pmd . get blocks ( ) ) ; }	Given a list of metadata files, merge them into a single ParquetMetadataRequires that the schemas be compatible, and the extraMetadata be exactly equal.
@ deprecated public static void write merged metadata file ( list < path > files , path output path , configuration conf ) throws io { parquet metadata merged = merge metadata files ( files , conf ) ; write metadata file ( output path , merged , output path . get file system ( conf ) ) ; }	Given a list of metadata files, merge them into a single metadata file.Requires that the schemas be compatible, and the extraMetaData be exactly equal.This is useful when merging 2 directories of parquet files into a single directory, as longas both directories were written with compatible schemas and equal extraMetaData.
@ deprecated public static void write metadata file ( configuration configuration , path output path , list < footer > footers ) throws io { write metadata file ( configuration , output path , footers , job summary level . all ) ; }	writes a _metadata and _common_metadata file.
static global meta data merge into ( file meta data to merge , global meta data merged metadata ) { return merge into ( to merge , merged metadata , bool ) ; }	Will return the result of merging toMerge into mergedMetadata.
public void read value ( ) { try { if ( ! value read ) { binding . read ( ) ; value read = bool ; } } catch ( runtime exception e ) { if ( corrupt delta byte arrays . requires sequential reads ( writer version , current encoding ) && e instanceof array index out of bounds exception ) {	Reads the value into the binding.
public static boolean null ok ( schema schema ) { if ( schema . type . null == schema . get type ( ) ) { return bool ; } else if ( schema . type . union == schema . get type ( ) ) { for ( schema possible : schema . get types ( ) ) { if ( null ok ( possible ) ) { return bool ; } } } return bool ; }	Returns whether null is allowed by the schema.
@ safe varargs private static < e > e coalesce ( e ... objects ) { for ( e object : objects ) { if ( object != null ) { return object ; } } return null ; }	Returns the first non-null object that is passed in.
private static object make value ( string string , schema schema ) { if ( string == null ) { return null ; } try { switch ( schema . get type ( ) ) { case boolean : return boolean . value of ( string ) ; case string : return string ; case float : return float . value of ( string ) ; case double : return double . value of ( string ) ; case int : return integer . value of ( string ) ; case long : return long . value of ( string ) ; case enum :	Returns a the value as the first matching schema type or null.Note that if the value may be null even if the schema does not allow thevalue to be null.
public static thrift meta data from extra meta data ( map < string , string > extra meta data ) { final string thrift class name = extra meta data . get ( thrift class ) ; final string thrift descriptor string = extra meta data . get ( thrift descriptor ) ; if ( thrift class name == null || thrift descriptor string == null ) { return null ; } final struct type descriptor = parse descriptor ( thrift descriptor string ) ; return new thrift meta data ( thrift class name , descriptor ) ; }	Reads ThriftMetadata from the parquet file footer.
@ suppress warnings ( str ) public static thrift meta data from thrift class ( class < ? > thrift class ) { if ( thrift class != null && t . class . is assignable from ( thrift class ) ) { class < ? extends t < ? , ? > > t class = ( class < ? extends t < ? , ? > > ) thrift class ; struct type descriptor = new thrift schema converter ( ) . to struct type ( t class ) ; return new thrift meta data ( thrift class . get name ( ) , descriptor ) ; } return null ; }	Creates ThriftMetaData from a Thrift-generated class.
public map < string , string > to extra meta data ( ) { final map < string , string > map = new hash map < string , string > ( ) ; map . put ( thrift class , get thrift class ( ) . get name ( ) ) ; map . put ( thrift descriptor , descriptor . to json ( ) ) ; return map ; }	generates a map of key values to store in the footer.
@ override public void write null ( int repetition level , int definition level ) { if ( debug ) log ( null , repetition level , definition level ) ; repetition level ( repetition level ) ; definition level ( definition level ) ; statistics . increment num nulls ( ) ; ++ value count ; }	Writes the current null value.
void write page ( ) { if ( value count == num ) { throw new parquet encoding exception ( str ) ; } this . rows written so far += page row count ; if ( debug ) log . debug ( str ) ; try { write page ( page row count , value count , statistics , repetition level column , definition level column , data column ) ; } catch ( io e ) { throw new parquet encoding exception ( str + path , e ) ; } repetition level column . reset ( ) ; definition level column . reset ( ) ; data column . reset ( ) ; value count = num ; reset statistics ( ) ; page row count = num ; }	Writes the current data to a new page in the page store.
@ override public void init from page ( int value count , byte buffer input stream stream ) throws io { this . in = stream ; long start pos = in . position ( ) ; this . config = delta binary packing config . read config ( in ) ; this . total value count = bytes utils . read unsigned var int ( in ) ; allocate values buffer ( ) ; bit widths = new int [ config . mini block num in a ] ;	eagerly loads all the data into memory.
private void allocate values buffer ( ) { int total mini block count = ( int ) math . ceil ( ( double ) total value count / config . mini block size in values ) ;	the value buffer is allocated so that the size of it is multiple of mini blockbecause when writing, data is flushed on a mini block basis.
private void check enum ( thrift type expected type , int i ) { if ( expected type . get type ( ) == id . enum ) { thrift type . enum type expected enum type = ( thrift type . enum type ) expected type ; if ( expected enum type . get enum value by id ( i ) == null ) { throw new decoding schema mismatch exception ( str + i + str + expected type ) ; } } }	In thrift enum values are written as ints, this method checks if the enum index is defined.
private void calculate bit widths for delta block buffer ( int mini blocks to flush ) { for ( int mini block index = num ; mini block index < mini blocks to flush ; mini block index ++ ) { int mask = num ; int mini start = mini block index * config . mini block size in values ;	iterate through values in each mini block and calculate the bitWidths of max values.
public static < e extends exception > void throw if instance ( throwable t , class < e > exc class ) throws e { if ( exc class . is assignable from ( t . get class ( ) ) ) {	If the given throwable is an instance of E, throw it as an E.
@ deprecated public static statistics get stats based on type ( primitive type name type ) { switch ( type ) { case in : return new int statistics ( ) ; case in : return new long statistics ( ) ; case float : return new float statistics ( ) ; case double : return new double statistics ( ) ; case boolean : return new boolean statistics ( ) ; case binary : return new binary statistics ( ) ; case in : return new binary statistics ( ) ; case fixed len byte array : return new binary statistics ( ) ; default : throw new unknown column type exception ( type ) ; } }	Returns the typed statistics object based on the passed type parameter.
public static builder get builder for reading ( primitive type type ) { switch ( type . get primitive type name ( ) ) { case float : return new float builder ( type ) ; case double : return new double builder ( type ) ; default : return new builder ( type ) ; } }	Returns a builder to create new statistics object.
public void merge statistics ( statistics stats ) { if ( stats . is empty ( ) ) return ;	Method to merge this statistics object with the object passedas parameter.
public static schema get non null ( schema schema ) { if ( schema . get type ( ) . equals ( schema . type . union ) ) { list < schema > schemas = schema . get types ( ) ; if ( schemas . size ( ) == num ) { if ( schemas . get ( num ) . get type ( ) . equals ( schema . type . null ) ) { return schemas . get ( num ) ; } else if ( schemas . get ( num ) . get type ( ) . equals ( schema . type . null ) ) { return schemas . get ( num ) ; } else { return schema ; } } else { return schema ; } } else { return schema ; } }	Given a schema, check to see if it is a union of a null type and a regular schema,and then return the non-null sub-schema.
public static task attempt context new task attempt context ( configuration conf , id task attempt id ) { try { return ( task attempt context ) task context constructor . new instance ( conf , task attempt id ) ; } catch ( instantiation exception e ) { throw new illegal argument exception ( str , e ) ; } catch ( illegal access exception e ) { throw new illegal argument exception ( str , e ) ; } catch ( invocation target exception e ) { throw new illegal argument exception ( str , e ) ; } }	Creates TaskAttemptContext from a JobConf and jobId using the correctconstructor for based on Hadoop version.
private static object invoke ( method method , object obj , object ... args ) { try { return method . invoke ( obj , args ) ; } catch ( illegal access exception e ) { throw new illegal argument exception ( str + method . get name ( ) , e ) ; } catch ( invocation target exception e ) { throw new illegal argument exception ( str + method . get name ( ) , e ) ; } }	Invokes a method and rethrows any exception as runtime exceptions.
void members display string ( string builder sb , string indent ) { for ( type field : fields ) { field . write to string builder ( sb , indent ) ; if ( field . is primitive ( ) ) { sb . append ( str ) ; } sb . append ( str ) ; } }	appends a display string for of the members of this group to sb.
list < type > merge fields ( group type to merge , boolean strict ) { list < type > new fields = new array list < type > ( ) ;	produces the list of fields resulting from merging toMerge into the fields of this.
public static void init counter from reporter ( reporter reporter , configuration configuration ) { counter loader = new map red counter loader ( reporter , configuration ) ; load counters ( ) ; }	Init counters in hadoop's mapred API, which is used by cascading and Hive.
public static filter get filter ( configuration conf ) { return filter compat . get ( get filter predicate ( conf ) , get unbound record filter instance ( conf ) ) ; }	Returns a non-null Filter, which is a wrapper around either aFilterPredicate, an UnboundRecordFilter, or a no-op filter.
public list < footer > get footers ( configuration configuration , collection < file status > statuses ) throws io { log . debug ( str , statuses . size ( ) ) ; boolean task side meta data = is task side meta data ( configuration ) ; return parquet file reader . read all footers in parallel using summary files ( configuration , statuses , task side meta data ) ; }	the footers for the files.
static < t > list < parquet input split > generate splits ( list < block meta data > row group blocks , block location [ ] hdfs blocks array , file status file status , string requested schema , map < string , string > read support metadata , long min split size , long max split size ) throws io { list < split info > split row groups = generate split info ( row group blocks , hdfs blocks array , min split size , max split size ) ;	groups together all the data blocks for the same HDFS block.
@ override public void write ( t record ) { record consumer . start message ( ) ; try { message writer . write top level message ( record ) ; } catch ( runtime exception e ) { message m = ( record instanceof message . builder ) ? ( ( message . builder ) record ) . build ( ) : ( message ) record ; log . error ( str + e . get message ( ) + str + m ) ; throw e ; } record consumer . end message ( ) ; }	Writes Protocol buffer to parquet file.
private void validated mapping ( descriptor descriptor , group type parquet schema ) { list < field descriptor > all fields = descriptor . get fields ( ) ; for ( field descriptor field descriptor : all fields ) { string field name = field descriptor . get name ( ) ; int field index = field descriptor . get index ( ) ; int parquet index = parquet schema . get field index ( field name ) ; if ( field index != parquet index ) { string message = str + field name + str + field index + str + parquet index ; throw new incompatible schema modification exception ( message ) ; } } }	validates mapping between protobuffer fields and parquet fields.
private string serialize descriptor ( class < ? extends message > proto class ) { descriptor descriptor = protobufs . get message descriptor ( proto class ) ; descriptor protos . descriptor proto as proto = descriptor . to proto ( ) ; return text format . print to string ( as proto ) ; }	Returns message descriptor as JSON String.
public list < t > amend missing required fields ( struct type record thrift type ) throws t { iterator < t > protocol iter = root events . iterator ( ) ; check struct ( protocol iter , record thrift type ) ; return fixed events ; }	Given a thrift definition, protocols events, it checks all the required fields,and create default value if a required field is missing.
private void check set ( iterator < t > event iter , thrift field set field definition ) throws t { t thrift set = accept protocol ( event iter . next ( ) ) . read set begin ( ) ; thrift field element field definition = ( ( thrift type . set type ) set field definition . get type ( ) ) . get values ( ) ; int set size = thrift set . size ; for ( int i = num ; i < set size ; i ++ ) { check field ( thrift set . elem type , event iter , element field definition ) ; } accept protocol ( event iter . next ( ) ) . read set end ( ) ; }	check each element of the Set, make sure all the element contain required fields.
public static file meta data read file meta data ( input stream from , boolean skip row groups ) throws io { file meta data md = new file meta data ( ) ; if ( skip row groups ) { read file meta data ( from , new default file meta data consumer ( md ) , skip row groups ) ; } else { read ( from , md ) ; } return md ; }	reads the meta data from the stream.
@ override public void close ( ) throws io { try { record writer . close ( task attempt context ) ; } catch ( interrupted exception e ) { thread . interrupted ( ) ; throw new io ( str , e ) ; } }	close the file.
public static void set schema ( job job , message type schema ) { group write support . set schema ( schema , context util . get configuration ( job ) ) ; }	set the schema being written to the job conf.
private static void add ( class < ? > c , primitive type name p ) { set < primitive type name > descriptors = class to parquet type . get ( c ) ; if ( descriptors == null ) { descriptors = new hash set < primitive type name > ( ) ; class to parquet type . put ( c , descriptors ) ; } descriptors . add ( p ) ; set < class < ? > > classes = parquet type to class . get ( p ) ; if ( classes == null ) { classes = new hash set < class < ? > > ( ) ; parquet type to class . put ( p , classes ) ; } classes . add ( c ) ; }	set up the mapping in both directions.
public static < t extends comparable < t > > void assert type valid ( column < t > found column , primitive type name primitive type ) { class < t > found column type = found column . get column type ( ) ; column path column path = found column . get column path ( ) ; set < primitive type name > valid type descriptors = class to parquet type . get ( found column type ) ; if ( valid type descriptors == null ) { string builder message = new string builder ( ) ; message . append ( str ) . append ( column path . to dot string ( ) ) . append ( str ) . append ( found column type . get name ( ) ) . append ( str ) ; set < class < ? > > supported types = parquet type to class . get ( primitive type ) ; if ( supported types != null ) { message . append ( str ) . append ( supported types ) ; } else { message . append ( str + primitive type ) ; } throw new illegal argument exception ( message . to string ( ) ) ; } if ( ! valid type descriptors . contains ( primitive type ) ) { string builder message = new string builder ( ) ; message . append ( str ) . append ( column path . to dot string ( ) ) . append ( str ) . append ( found column type . get name ( ) ) . append ( str ) . append ( column path . to dot string ( ) ) . append ( str ) . append ( primitive type ) . append ( str ) . append ( parquet type to class . get ( primitive type ) ) ; throw new illegal argument exception ( message . to string ( ) ) ; } }	Asserts that foundColumn was declared as a type that is compatible with the type for this column foundin the schema of the parquet file.
public static int checked cast ( long value ) { int value i = ( int ) value ; if ( value i != value ) { throw new illegal argument exception ( string . format ( str , value ) ) ; } return value i ; }	Cast value to a an int, or throw an exceptionif there is an overflow.
public schema mapping from arrow ( schema arrow schema ) { list < field > fields = arrow schema . get fields ( ) ; list < type mapping > parquet fields = from arrow ( fields ) ; message type parquet type = add to builder ( parquet fields , types . build message ( ) ) . named ( str ) ; return new schema mapping ( arrow schema , parquet type , parquet fields ) ; }	Creates a Parquet Schema from an Arrow one and returns the mapping.
public schema mapping from parquet ( message type parquet schema ) { list < type > fields = parquet schema . get fields ( ) ; list < type mapping > mappings = from parquet ( fields ) ; list < field > arrow fields = fields ( mappings ) ; return new schema mapping ( new schema ( arrow fields ) , parquet schema , mappings ) ; }	Creates an Arrow Schema from an Parquet one and returns the mapping.
public schema mapping map ( schema arrow schema , message type parquet schema ) { list < type mapping > children = map ( arrow schema . get fields ( ) , parquet schema . get fields ( ) ) ; return new schema mapping ( arrow schema , parquet schema , children ) ; }	Maps a Parquet and Arrow SchemaFor now does not validate primitive type compatibility.
@ deprecated public void write data page v2 header ( int uncompressed size , int compressed size , int value count , int null count , int row count , org . apache . parquet . column . statistics . statistics statistics , org . apache . parquet . column . encoding data encoding , int rl byte length , int dl byte length , output stream to ) throws io { write page header ( new data page v2 header ( uncompressed size , compressed size , value count , null count , row count , data encoding , rl byte length , dl byte length ) , to ) ; }	Statistics are no longer saved in page headers.
private void skip to match ( ) { while ( records read < record count && ! record filter . is match ( ) ) { state current state = get state ( num ) ; do { column reader column reader = current state . column ;	Skips forwards until the filter finds the first match.
public static void write object to conf as base64 ( string key , object obj , configuration conf ) throws io { try ( byte array output stream baos = new byte array output stream ( ) ) { try ( gzip gos = new gzip ( baos ) ; object output stream oos = new object output stream ( gos ) ) { oos . write object ( obj ) ; } conf . set ( key , new string ( base64 . encode base64 ( baos . to byte array ( ) ) , standard charsets . utf 8 ) ) ; } }	Writes an object to a configuration.
public v remove ( final k key ) { v old value = cache map . remove ( key ) ; if ( old value != null ) { log . debug ( str , key ) ; } return old value ; }	Removes the mapping for the specified key from this cache if present.
public void put ( final k key , final v new value ) { if ( new value == null || ! new value . is current ( key ) ) { if ( log . is warn enabled ( ) ) { log . warn ( str , key , ( new value == null ? str : str ) ) ; } return ; } v old value = cache map . get ( key ) ; if ( old value != null && old value . is newer than ( new value ) ) { if ( log . is warn enabled ( ) ) { log . warn ( str + str , key ) ; } return ; }	Associates the specified value with the specified key in this cache.
public v get current value ( final k key ) { v value = cache map . get ( key ) ; log . debug ( str , key , ( value == null ? str : str ) ) ; if ( value != null && ! value . is current ( key ) ) {	Returns the value to which the specified key is mapped, or null if 1) thevalue is not current or 2) this cache contains no mapping for the key.
private void write value ( type type , schema avro schema , object value ) { schema non null avro schema = avro schema converter . get non null ( avro schema ) ; logical type logical type = non null avro schema . get logical type ( ) ; if ( logical type != null ) { conversion < ? > conversion = model . get conversion by class ( value . get class ( ) , logical type ) ; write value without conversion ( type , non null avro schema , convert ( non null avro schema , logical type , conversion , value ) ) ; } else { write value without conversion ( type , non null avro schema , value ) ; } }	Calls an appropriate write method based on the value.Value MUST not be null.
public void set ( string glob ) { string builder regex = new string builder ( ) ; int set open = num ; int curly open = num ; int len = glob . length ( ) ; has wildcard = bool ; for ( int i = num ; i < len ; i ++ ) { char c = glob . char at ( i ) ; switch ( c ) { case backslash : if ( ++ i >= len ) { error ( str , glob , i ) ; } regex . append ( c ) . append ( glob . char at ( i ) ) ; continue ; case str : case str : case str : case str : case str : case str :	Set and compile a glob pattern.
public void output ( string content , logger console , string filename ) throws io { if ( filename == null || str . equals ( filename ) ) { console . info ( content ) ; } else { fs outgoing = create ( filename ) ; try { outgoing . write ( content . get bytes ( standard charsets . utf 8 ) ) ; } finally { outgoing . close ( ) ; } } }	Output content to the console or a file.This will not produce checksum files.
public input stream open ( string filename ) throws io { if ( stdin as source . equals ( filename ) ) { return system . in ; } uri uri = qualified uri ( filename ) ; if ( resource uri scheme . equals ( uri . get scheme ( ) ) ) { return resources . get resource ( uri . get raw scheme specific part ( ) ) . open stream ( ) ; } else { path file path = new path ( uri ) ;	Opens an existing file or resource.If the file does not have a file system scheme, this uses the default FS.
public static final unbound record filter column ( final string column path , final column predicates . predicate predicate ) { check not null ( column path , str ) ; check not null ( predicate , str ) ; return new unbound record filter ( ) { final string [ ] filter path = column path . split ( str ) ; @ override public record filter bind ( iterable < column reader > readers ) { for ( column reader reader : readers ) { if ( arrays . equals ( reader . get descriptor ( ) . get path ( ) , filter path ) ) { return new column record filter ( reader , predicate ) ; } } throw new illegal argument exception ( str + column path + str ) ; } } ; }	Factory method for record filter which applies the supplied predicate to the specified column.Note that if searching for a repeated sub-attribute it will only ever match against thefirst instance of it in the object.
public message type convert ( struct type struct ) { message type message type = thrift schema convert visitor . convert ( struct , field projection filter , bool ) ; field projection filter . assert no unmatched patterns ( ) ; return message type ; }	struct is assumed to contain valid structOrUnionType metadata when used with this method.This method may throw if structOrUnionType is unknown.Use convertWithoutProjection below to convert a StructType to MessageType.
private static group type list wrapper ( repetition repetition , string alias , logical type annotation logical type annotation , type nested ) { if ( ! nested . is repetition ( repetition . repeated ) ) { throw new illegal argument exception ( str + nested ) ; } return new group type ( repetition , alias , logical type annotation , nested ) ; }	to preserve the difference between empty list and null when optional.
public static group type list of elements ( repetition list repetition , string name , type element type ) { preconditions . check argument ( element type . get name ( ) . equals ( element name ) , str ) ; return list wrapper ( list repetition , name , logical type annotation . list type ( ) , new group type ( repetition . repeated , str , element type ) ) ; }	Creates a 3-level list structure annotated with LIST with elements of thegiven elementType.
@ deprecated public map < string , string > get merged key value meta data ( ) { if ( merged key value metadata == null ) { map < string , string > merged key values = new hash map < string , string > ( ) ; for ( entry < string , set < string > > entry : key value metadata . entry set ( ) ) { if ( entry . get value ( ) . size ( ) > num ) { throw new runtime exception ( str + entry . get key ( ) + str + entry . get value ( ) ) ; } merged key values . put ( entry . get key ( ) , entry . get value ( ) . iterator ( ) . next ( ) ) ; } merged key value metadata = merged key values ; } return merged key value metadata ; }	If there is a conflicting value when reading from multiple files,an exception will be thrown.
protected parquet input split get split ( final input split old split , final job conf conf ) throws io { if ( old split instanceof file split ) { file split file split = ( file split ) old split ; final long split start = file split . get start ( ) ; final long split length = file split . get length ( ) ; final path final path = file split . get path ( ) ; final job conf clone job = hive binding . push projections and filters ( conf , final path . get parent ( ) ) ; final parquet metadata parquet metadata = parquet file reader . read footer ( clone job , final path , skip row groups ) ; final file meta data file meta data = parquet metadata . get file meta data ( ) ; final read context read context = new data writable read support ( ) . init ( clone job , file meta data . get key value meta data ( ) , file meta data . get schema ( ) ) ; schema size = message type parser . parse message type ( read context . get read support metadata ( ) . get ( data writable read support . hive schema key ) ) . get field count ( ) ; return new parquet input split ( final path , split start , split start + split length , split length , file split . get locations ( ) , null ) ; } else { throw new illegal argument exception ( str + old split ) ; } }	gets a ParquetInputSplit corresponding to a split given by Hive.
private static map < string , class < ? > > get fields by name ( class < ? > record class , boolean exclude java ) { map < string , class < ? > > fields = new linked hash map < string , class < ? > > ( ) ; if ( record class != null ) { class < ? > current = record class ; do { if ( exclude java && current . get package ( ) != null && current . get package ( ) . get name ( ) . starts with ( str ) ) { break ;	this was taken from Avro's ReflectData.
private message type resolve schema access ( message type requested schema , message type file schema , configuration configuration ) { if ( configuration . get boolean ( parquet column index access , bool ) ) { final list < string > list columns = get columns ( configuration . get ( io . columns ) ) ; list < type > requested types = new array list < type > ( ) ; for ( type t : requested schema . get fields ( ) ) { int index = list columns . index of ( t . get name ( ) ) ; requested types . add ( file schema . get type ( index ) ) ; } requested schema = new message type ( requested schema . get name ( ) , requested types ) ; } return requested schema ; }	Determine the file column names based on the position within the requested columns anduse that as the requested schema.
private list < path > get input files ( list < string > input ) throws io { list < path > input files = null ; if ( input . size ( ) == num ) { path p = new path ( input . get ( num ) ) ; file system fs = p . get file system ( conf ) ; file status status = fs . get file status ( p ) ; if ( status . is dir ( ) ) { input files = get input files from directory ( status ) ; } } else { input files = parse input files ( input ) ; } check parquet files ( input files ) ; return input files ; }	Get all input files.
private void check parquet files ( list < path > input files ) throws io { if ( input files == null || input files . size ( ) <= num ) { throw new illegal argument exception ( str ) ; } for ( path input file : input files ) { file system fs = input file . get file system ( conf ) ; file status status = fs . get file status ( input file ) ; if ( status . is dir ( ) ) { throw new illegal argument exception ( str + input file . to uri ( ) ) ; } } }	Check input files basically.ParquetFileReader will throw exception when reading an illegal parquet file.
private list < path > get input files from directory ( file status partition dir ) throws io { file system fs = partition dir . get path ( ) . get file system ( conf ) ; file status [ ] input files = fs . list status ( partition dir . get path ( ) , hidden file filter . instance ) ; list < path > input = new array list < path > ( ) ; for ( file status f : input files ) { input . add ( f . get path ( ) ) ; } return input ; }	Get all parquet files under partition directory.
public static final unbound record filter page ( final long start pos , final long page size ) { return new unbound record filter ( ) { @ override public record filter bind ( iterable < column reader > readers ) { return new paged record filter ( start pos , page size ) ; } } ; }	Returns builder for creating a paged query.
public static < t extends t < t , ? extends t > > list consumer list of ( class < t > c , final consumer < list < t > > consumer ) { class list consumer implements consumer < t > { list < t > list ; @ override public void consume ( t t ) { list . add ( t ) ; } } final list consumer co = new list consumer ( ) ; return new delegating list elements consumer ( struct ( c , co ) ) { @ override public void consume list ( t protocol , event based thrift reader reader , t t list ) throws t { co . list = new array list < t > ( ) ; super . consume list ( protocol , reader , t list ) ; consumer . consume ( co . list ) ; } } ; }	To consume a list of elements.
private void init ( final job conf job ) { final string plan = hive conf . get var ( job , hive conf . conf vars . plan ) ; if ( mrwork == null && plan != null && plan . length ( ) > num ) { mrwork = utilities . get map red work ( job ) ; path to partition info . clear ( ) ; for ( final map . entry < string , partition desc > entry : mrwork . get path to partition info ( ) . entry set ( ) ) { path to partition info . put ( new path ( entry . get key ( ) ) . to uri ( ) . get path ( ) . to string ( ) , entry . get value ( ) ) ; } } }	Initialize the mrwork variable in order to get all the partition and start to update the jobconf.
private static tuple summary data merge ( tuple t ) throws io { tuple summary data summary data = new tuple summary data ( ) ; data bag bag = ( data bag ) t . get ( num ) ; for ( tuple tuple : bag ) { summary data . merge ( get data ( tuple ) ) ; } return summary data ; }	the input tuple contains a bag of string representations of TupleSummaryData.
private static tuple summary data sum up ( schema schema , tuple t ) throws exec exception { tuple summary data summary data = new tuple summary data ( ) ; data bag bag = ( data bag ) t . get ( num ) ; for ( tuple tuple : bag ) { summary data . add tuple ( schema , tuple ) ; } return summary data ; }	The input tuple contains a bag of Tuples to sum up.
public void read struct ( field consumer c ) throws t { protocol . read struct begin ( ) ; read struct content ( c ) ; protocol . read struct end ( ) ; }	reads a Struct from the underlying protocol and passes the field events to the FieldConsumer.
public void read map entry ( byte key type , typed consumer key consumer , byte value type , typed consumer value consumer ) throws t { key consumer . read ( protocol , this , key type ) ; value consumer . read ( protocol , this , value type ) ; }	reads a key-value pair.
public void write int ( int value ) throws io { input [ input size ] = value ; ++ input size ; if ( input size == values written at a time ) { pack ( ) ; if ( packed position == slab size ) { slabs . add ( bytes input . from ( packed ) ) ; total full slab size += slab size ; if ( slab size < bit width * max slab size mult ) { slab size *= num ; } init packed slab ( ) ; } } }	writes an int using the requested number of bits.accepts only values less than 2^bitWidth.
public static int read int little endian ( byte buffer in , int offset ) throws io { int ch4 = in . get ( offset ) & num ; int ch3 = in . get ( offset + num ) & num ; int ch2 = in . get ( offset + num ) & num ; int ch1 = in . get ( offset + num ) & num ; return ( ( ch1 << num ) + ( ch2 << num ) + ( ch3 << num ) + ( ch4 << num ) ) ; }	reads an int in little endian at the given position.
public static void set schema ( job job , schema schema ) { avro write support . set schema ( context util . get configuration ( job ) , schema ) ; }	Set the Avro schema to use for writing.
@ override public void create topic if not exists ( string topic , map < string , object > kafka client configs , string metadata broker list ) throws stage exception {	Should be called only by MapR Streams Producer.
public pipeline stage beans duplicate pipeline stage beans ( stage library task stage lib , pipeline stage beans pipeline stage beans , interceptor creator context builder interceptor creator context builder , map < string , object > constants , list < issue > errors ) { list < stage bean > stage beans = new array list < > ( pipeline stage beans . size ( ) ) ; for ( stage bean original : pipeline stage beans . get stages ( ) ) {	Creates additional PipelineStageBeans for additional runners.
public list < interceptor bean > create interceptors ( stage library task stage lib , stage configuration stage configuration , stage definition stage definition , interceptor creator context builder context builder , interceptor creator . interceptor type interceptor type , list < issue > issues ) { list < interceptor bean > beans = new array list < > ( ) ; if ( context builder == null ) { return beans ; } for ( interceptor definition definition : stage lib . get interceptor definitions ( ) ) { interceptor bean bean = create interceptor ( stage lib , definition , stage configuration , stage definition , context builder , interceptor type , issues ) ; if ( bean != null ) { beans . add ( bean ) ; } } return beans ; }	Create interceptors for given stage.
public interceptor bean create interceptor ( stage library task stage lib , interceptor definition definition , stage configuration stage configuration , stage definition stage definition , interceptor creator context builder context builder , interceptor creator . interceptor type interceptor type , list < issue > issues ) { class loader class loader = thread . current thread ( ) . get context class loader ( ) ; interceptor creator . context context = context builder . build for ( definition . get library definition ( ) . get name ( ) , definition . get klass ( ) . get name ( ) , stage configuration , stage definition , interceptor type ) ; try { thread . current thread ( ) . set context class loader ( definition . get stage class loader ( ) ) ; interceptor creator creator = definition . get default creator ( ) . new instance ( ) ; interceptor interceptor = creator . create ( context ) ; if ( interceptor == null ) { return null ; } return new interceptor bean ( definition , interceptor , stage lib ) ; } catch ( illegal access exception | instantiation exception e ) { log . debug ( str , e . to string ( ) , e ) ; issue creator issue creator = issue creator . get stage ( stage definition . get name ( ) ) ; issues . add ( issue creator . create ( creation error . creation 000 , str , definition . get klass ( ) . get name ( ) , e . to string ( ) ) ) ; } finally { thread . current thread ( ) . set context class loader ( class loader ) ; } return null ; }	Create a default interceptor for given InterceptorDefinition.
public static schema parse schema ( string schema ) { schema . parser parser = new schema . parser ( ) ; parser . set validate ( bool ) ;	Parse JSON representation of Avro schema to Avro's Schema JAVA object.
private static int millis to days ( long millis local ) {	Return number of days since the unix epoch.This function has been copied from Apache Hive project.
public static string get avro schema from header ( record record , string header name ) throws data generator exception { string json schema = record . get header ( ) . get attribute ( header name ) ; if ( json schema == null || json schema . is empty ( ) ) { throw new data generator exception ( errors . avro generator 03 , record . get header ( ) . get source id ( ) ) ; } return json schema ; }	Retrieves avro schema from given header.
private void upgrade v1 to v2 ( list < config > configs , context context ) { list < config > data format configs = configs . stream ( ) . filter ( c -> c . get name ( ) . starts with ( str ) ) . collect ( collectors . to list ( ) ) ;	Migrating to service for data format library.
private void copy blobstore ( list < string > blob store resources , file root data dir , file pipeline dir ) throws io { if ( blob store resources == null ) { return ; } file blobstore dir = new file ( runtime info . get data dir ( ) , blobstore base dir ) ; file staging blobstore dir = new file ( root data dir , blobstore base dir ) ; if ( ! staging blobstore dir . exists ( ) ) { if ( ! staging blobstore dir . mkdirs ( ) ) { throw new runtime exception ( str + pipeline dir . get path ( ) ) ; } } for ( string blobstore file : blob store resources ) { file src file = new file ( blobstore dir , blobstore file ) ; if ( src file . exists ( ) ) { final file dst file = new file ( staging blobstore dir , src file . get name ( ) ) ; if ( src file . can read ( ) ) {	Copy BlobStore resources to data directory.
public void reset ( ) { columns . clear ( ) ; this . columns expected = null ; column names = null ; table = null ; schema = null ; inside statement = bool ; }	Reset the listener to use with the next statement.
public boolean report health ( string thread name , int scheduled delay , long timestamp ) { thread health report thread health report = new thread health report ( thread name , scheduled delay , timestamp ) ; if ( thread to gauge map . contains key ( thread name ) ) { thread to gauge map . get ( thread name ) . set thread health report ( thread health report ) ; return bool ; } return bool ; }	Updates gauge for the registered thread with the given details.Note that the value of the threadName argument must match the one used to register.
public boolean register ( string thread name ) { if ( thread to gauge map . contains key ( thread name ) ) { return bool ; } thread health report gauge thread health report gauge = new thread health report gauge ( ) ; metrics configurator . create gauge ( metrics , get health gauge name ( thread name ) , thread health report gauge , name , rev ) ; thread to gauge map . put ( thread name , thread health report gauge ) ; return bool ; }	Creates and registers a Gauge with the given thread name.The same name must be used to report health.
public static void store control hub configs ( runtime info runtime info , map < string , string > new configs ) throws io { file config file = new file ( runtime info . get data dir ( ) , sch conf override ) ; properties properties = new properties ( ) ;	Store configuration from control hub in persistent manner inside data directory.
protected boolean credential login ( object web credential ) throws login exception { boolean cred result = get current user ( ) . check credential ( web credential ) ; set authenticated ( cred result ) ; if ( ! cred result ) { log . warn ( str ) ; } return is authenticated ( ) ; }	password supplied authentication check.
public pipeline configuration upgrade if necessary ( stage library task library , pipeline configuration pipeline conf , list < issue > issues ) { preconditions . check argument ( issues . is empty ( ) , str ) ; boolean upgrade ;	Upgrade whole pipeline at once and return updated variant.
static stage configuration upgrade if needed ( stage library task library , stage configuration conf , list < issue > issues ) { return upgrade if needed ( library , library . get stage ( conf . get library ( ) , conf . get stage name ( ) , bool ) , conf , issues ) ; }	Upgrade whole Stage configuration, including all services if needed.
static stage configuration upgrade if needed ( stage library task library , stage definition def , stage configuration conf , list < issue > issues ) { issue creator issue creator = issue creator . get stage ( conf . get instance name ( ) ) ; int from version = conf . get stage version ( ) ; int to version = def . get version ( ) ; try {	Upgrade whole Stage configuration, including all services if needed.This method is idempotent.
private static service configuration upgrade services if needed ( stage library task library , stage configuration stage conf , service configuration conf , issue creator issue creator , list < issue > issues ) { service definition def = library . get service definition ( conf . get service ( ) , bool ) ; if ( def == null ) { issues . add ( issue creator . create ( container error . container 0903 , conf . get service ( ) . get name ( ) ) ) ; } int from version = conf . get service version ( ) ; int to version = def . get version ( ) ;	Internal method that will upgrade service configuration if needed.This method is idempotent.
static private void upgrade stage if needed ( stage definition def , stage configuration conf , issue creator issue creator , list < issue > issues ) { int from version = conf . get stage version ( ) ; int to version = def . get version ( ) ;	Internal method that will upgrade only Stage configuration - not the associated services - and only if needed.This method is idempotent.
private list < string > get fields to null ( list < null replacer conditional config > null replacer conditional configs , set < string > fields that do not exist , set < string > field paths , record record ) throws on record error exception {	should be replaced by null.
private static boolean is system class ( string name , list < string > package list ) { boolean result = bool ; if ( package list != null ) { string canonical name = class loader util . canonicalize class or resource ( name ) ; for ( string c : package list ) { boolean should include = bool ; if ( c . starts with ( str ) ) { c = c . substring ( num ) ; should include = bool ; } if ( canonical name . starts with ( c ) ) { if ( c . ends with ( str )	Checks if a class should be included as a system class.A class is a system class if and only if it matches one of the positivepatterns and none of the negative ones.
@ override public boolean add ( e e ) { check not null ( e ) ;	Adds the given element to this queue.
public e add and get evicted ( e e ) { check not null ( e ) ;	Adds the given element to this queue.
private optional < value > value or default ( key key , optional < value > value ) {	Internal method to ensure that we return and not cache the default value if needed.
private list < stage output > add reported errors if needed ( list < stage output > snapshots of all stages output ) { synchronized ( this . reported errors ) { if ( reported errors . is empty ( ) ) { return snapshots of all stages output ; } try { return snapshots of all stages output . stream ( ) . map ( so -> new stage output ( so . get instance name ( ) , so . get output ( ) , so . get error records ( ) , reported errors . get ( so . get instance name ( ) ) , so . get event records ( ) ) ) . collect ( collectors . to list ( ) ) ; } finally { reported errors . clear ( ) ; } } }	Preview only returns data associated with batches, however errors are reported outside of batch context formulti-threaded pipelines.
public static descriptors . descriptor get descriptor ( proto configurable entity . context context , string proto descriptor file , string message type , map < string , set < descriptors . field descriptor > > message type to extension map , map < string , object > default value map ) throws stage exception { file descriptor file handle = new file ( context . get resources directory ( ) , proto descriptor file ) ; try ( file input stream fin = new file input stream ( descriptor file handle ) ; ) { descriptor protos . file descriptor set set = descriptor protos . file descriptor set . parse from ( fin ) ;	Returns a protobuf descriptor instance from the provided descriptor file.
public static void get all file descriptors ( descriptor protos . file descriptor set set , map < string , set < descriptors . file descriptor > > dependencies map , map < string , descriptors . file descriptor > file descriptor map ) throws stage exception { list < descriptor protos . file descriptor proto > file list = set . get file list ( ) ; try { for ( descriptor protos . file descriptor proto fdp : file list ) { if ( ! file descriptor map . contains key ( fdp . get name ( ) ) ) { set < descriptors . file descriptor > dependencies = dependencies map . get ( fdp . get name ( ) ) ; if ( dependencies == null ) { dependencies = new linked hash set < > ( ) ; dependencies map . put ( fdp . get name ( ) , dependencies ) ; dependencies . add all ( get dependencies ( dependencies map , file descriptor map , fdp , set ) ) ; } descriptors . file descriptor file descriptor = descriptors . file descriptor . build from ( fdp , dependencies . to array ( new descriptors . file descriptor [ dependencies . size ( ) ] ) ) ; file descriptor map . put ( fdp . get name ( ) , file descriptor ) ; } } } catch ( descriptors . descriptor validation exception e ) { throw new stage exception ( errors . protobuf 07 , e . get description ( ) , e ) ; } }	Loads a Protobuf file descriptor set into an ubermap of file descriptors.
public static void populate defaults and extensions ( map < string , descriptors . file descriptor > file descriptor map , map < string , set < descriptors . field descriptor > > type to extension map , map < string , object > default value map ) { for ( descriptors . file descriptor f : file descriptor map . values ( ) ) {	Populates a map of protobuf extensions and map with the default values foreach message field from a map of file descriptors.
public static descriptors . descriptor get descriptor ( descriptor protos . file descriptor set set , map < string , descriptors . file descriptor > file descriptor map , string descriptor file , string qualified message type ) throws stage exception {	Generates a protobuf descriptor instance from a FileDescriptor set.
public static field protobuf to sdc field ( record record , string field path , descriptors . descriptor descriptor , map < string , set < descriptors . field descriptor > > message type to extension map , object message ) throws data parser exception { linked hash map < string , field > sdc record map field value = new linked hash map < > ( ) ;	Converts a protobuf message to an SDC Record Field.
public static dynamic message sdc field to protobuf msg ( record record , descriptors . descriptor desc , map < string , set < descriptors . field descriptor > > message type to extension map , map < string , object > default value map ) throws data generator exception { return sdc field to protobuf msg ( record , record . get ( ) , str , desc , message type to extension map , default value map ) ; }	Serializes a record to a protobuf message using the specified descriptor.
private static dynamic message sdc field to protobuf msg ( record record , field field , string field path , descriptors . descriptor desc , map < string , set < descriptors . field descriptor > > message type to extension map , map < string , object > default value map ) throws data generator exception { if ( field == null ) { return null ; }	Serializes a field path in a record to a protobuf message using the specified descriptor.
public static void upgrade to jersey config bean ( list < config > configs ) { list < config > configs to add = new array list < > ( ) ; list < config > configs to remove = new array list < > ( ) ; list < string > moved configs = immutable list . of ( str , str , str , str , str , str , str , str ) ; for ( config config : configs ) { if ( has prefix in ( moved configs , config . get name ( ) ) ) { configs to remove . add ( config ) ; configs to add . add ( new config ( config . get name ( ) . replace ( str , str ) , config . get value ( ) ) ) ; } } configs to add . add ( new config ( str , request entity processing . chunked ) ) ; configs . remove all ( configs to remove ) ; configs . add all ( configs to add ) ; }	Helper method to upgrade both HTTP stages to the JerseyConfigBean.
public static void check connection ( async kudu client kudu client , context context , string kudu master , final list < stage . config issue > issues ) { try { kudu client . get tables list ( ) . join ( ) ; } catch ( exception ex ) { issues . add ( context . create config issue ( groups . kudu . name ( ) , kudu lookup config . conf prefix + kudu master , errors . kudu 00 , ex . to string ( ) , ex ) ) ; } }	Check network connection to the kudu master.
public static field . type convert from kudu type ( type kudu type ) { switch ( kudu type ) { case binary : return field . type . byte array ; case bool : return field . type . boolean ; case double : return field . type . double ; case float : return field . type . float ; case in : return field . type . byte ; case in : return field . type . short ; case in : return field . type . integer ; case in : return field . type . long ; case string : return field . type . string ; case unixtime micros : return field . type . datetime ; default : if ( str . equals ( kudu type . name ( ) ) ) { return field . type . decimal ; } throw new unsupported operation exception ( str + kudu type . get name ( ) ) ; } }	Convert from Kudu type to SDC Field type.
public static field create field ( row result result , string field name , type type ) throws stage exception { switch ( type ) { case in : return field . create ( field . type . byte , result . get byte ( field name ) ) ; case in : return field . create ( field . type . short , result . get short ( field name ) ) ; case in : return field . create ( field . type . integer , result . get int ( field name ) ) ; case in : return field . create ( field . type . long , result . get long ( field name ) ) ; case binary : try { return field . create ( field . type . byte array , result . get binary ( field name ) ) ; } catch ( illegal argument exception ex ) { throw new on record error exception ( errors . kudu 35 , field name ) ; } case string : return field . create ( field . type . string , result . get string ( field name ) ) ; case bool : return field . create ( field . type . boolean , result . get boolean ( field name ) ) ; case float : return field . create ( field . type . float , result . get float ( field name ) ) ; case double : return field . create ( field . type . double , result . get double ( field name ) ) ; case unixtime micros :	Create a field and assign a value off of RowResult.
private list < record > intercept ( list < record > records , list < ? extends interceptor > interceptors ) throws stage exception { for ( interceptor interceptor : interceptors ) { records = interceptor . intercept ( records ) ; } return records ; }	Intercept given records with all the interceptors.We're not cloning records during interception as we aim at changing their original form.
public string get text ( ) { if ( line == null ) { line = new string ( buffer , offset in chunk , length , charset ) ; } return line ; }	Returns the text of the line.
public static void add missing configs to stage ( stage library task stage library , stage configuration stage conf ) { stage definition stage def = stage library . get stage ( stage conf . get library ( ) , stage conf . get stage name ( ) , bool ) ; if ( stage def != null ) { for ( config definition config def : stage def . get config definitions ( ) ) { string config name = config def . get name ( ) ; config config = stage conf . get config ( config name ) ; if ( config == null ) { object default value = config def . get default value ( ) ; log . warn ( str , stage conf . get instance name ( ) , config name , default value ) ; config = new config ( config name , default value ) ; stage conf . add config ( config ) ; } } } }	Add any missing configs to the stage configuration.
private record parse response ( input stream response ) throws stage exception { record record = null ; if ( conf . http method == http method . head ) {	Parses the HTTP response text from a request into SDC Records.
private void add response headers ( record record , response response ) throws stage exception { if ( conf . header output location == header output location . none ) { return ; } record . header header = record . get header ( ) ; if ( conf . header output location == header output location . field ) { write response header to field ( record , response ) ; } else if ( conf . header output location == header output location . header ) { write response header to record header ( response , header ) ; } }	Populates HTTP response headers to the configured location.
private void write response header to field ( record record , response response ) throws stage exception { if ( record . has ( conf . header output field ) ) { throw new stage exception ( errors . http 11 , conf . header output field ) ; } map < string , field > headers = new hash map < > ( response . get string headers ( ) . size ( ) ) ; for ( map . entry < string , list < string > > entry : response . get string headers ( ) . entry set ( ) ) { if ( ! entry . get value ( ) . is empty ( ) ) { string first value = entry . get value ( ) . get ( num ) ; headers . put ( entry . get key ( ) , field . create ( first value ) ) ; } } record . set ( conf . header output field , field . create ( headers ) ) ; }	Writes HTTP response headers to the SDC Record at the configured field path.
private void write response header to record header ( response response , record . header header ) { for ( map . entry < string , list < string > > entry : response . get string headers ( ) . entry set ( ) ) { if ( ! entry . get value ( ) . is empty ( ) ) { string first value = entry . get value ( ) . get ( num ) ; header . set attribute ( conf . header attribute prefix + entry . get key ( ) , first value ) ; } } }	Writes HTTP response headers to the SDC Record header with the configured optional prefix.
synchronized private void save metadata ( ) throws stage exception {	Commit metadata content to a file to disk.This method does three-phased commit:1) New content is written into a new temporary file.2) Old metadata is dropped3) Rename from new to old is done.
private void configure client ( list < config issue > issues ) throws stage exception { client common . init ( issues , get context ( ) ) ; if ( issues . is empty ( ) ) { client = client common . get client ( ) ; parser factory = conf . data format config . get parser factory ( ) ; } }	Helper method to apply Jersey client configuration properties.
string parse headers only ( batch maker batch maker ) throws stage exception { http source offset source offset = new http source offset ( get resolved url ( ) , current parameter hash , system . current time millis ( ) , get current page ( ) ) ; record record = get context ( ) . create record ( source offset + str ) ; add response headers ( record . get header ( ) ) ; record . set ( field . create ( new hash map ( ) ) ) ; batch maker . add record ( record ) ; record count ++ ; increment source offset ( source offset , num ) ; last request completed time = system . current time millis ( ) ; return source offset . to string ( ) ; }	Used only for HEAD requests.
private void increment source offset ( http source offset source offset , int increment ) { if ( conf . pagination . mode == pagination mode . by page ) { source offset . increment start at ( num ) ; } else if ( conf . pagination . mode == pagination mode . by offset ) { source offset . increment start at ( increment ) ; } }	Increments the current source offset's startAt portion by the specified amount.This is the number of records parsed when paging BY_OFFSET or 1 if incrementingBY_PAGE.
private int parse paginated result ( batch maker batch maker , string source offset , record record ) throws stage exception { int num sub records = num ; if ( ! record . has ( conf . pagination . result field path ) ) { final stage exception stage exception = new stage exception ( errors . http 12 , conf . pagination . result field path ) ; log . error ( stage exception . get message ( ) ) ; throw stage exception ; } field result field = record . get ( conf . pagination . result field path ) ; if ( result field . get type ( ) != field . type . list ) { final stage exception stage exception = new stage exception ( errors . http 08 , result field . get type ( ) ) ; log . error ( stage exception . get message ( ) ) ; throw stage exception ; } list < field > results = result field . get value as list ( ) ; int sub record idx = num ; for ( field result : results ) { record r = get context ( ) . create record ( source offset + str + sub record idx ++ ) ; if ( conf . pagination . keep all fields ) { r . set ( record . get ( ) . clone ( ) ) ; r . set ( conf . pagination . result field path , result ) ; } else { r . set ( result ) ; } add response headers ( r . get header ( ) ) ; batch maker . add record ( r ) ; ++ num sub records ; } if ( conf . pagination . mode != pagination mode . link field ) { have more pages = num sub records > num ; } return num sub records ; }	Parses a paginated result from the configured field.
private void add response headers ( record . header header ) { final multivalued map < string , string > headers = get response ( ) . get string headers ( ) ; if ( headers == null ) { return ; } for ( map . entry < string , list < string > > entry : headers . entry set ( ) ) { if ( ! entry . get value ( ) . is empty ( ) ) { string first value = entry . get value ( ) . get ( num ) ; header . set attribute ( entry . get key ( ) , first value ) ; } } }	Adds the HTTP response headers to the record header.
private multivalued map < string , object > resolve headers ( ) throws stage exception { multivalued map < string , object > request headers = new multivalued hash map < > ( ) ; for ( map . entry < string , string > entry : conf . headers . entry set ( ) ) { list < object > header = new array list < > ( num ) ; object resolved value = header eval . eval ( header vars , entry . get value ( ) , string . class ) ; header . add ( resolved value ) ; request headers . put ( entry . get key ( ) , header ) ; hasher . put string ( entry . get key ( ) , charset . for name ( conf . data format config . charset ) ) ; hasher . put string ( entry . get value ( ) , charset . for name ( conf . data format config . charset ) ) ; } return request headers ; }	Resolves any expressions in the Header value entries of the request.
private optional < string > process response ( long start , int max records , batch maker batch maker ) throws stage exception { optional < string > new source offset = optional . empty ( ) ; if ( get response ( ) == null ) { return new source offset ; }	Verifies that the response was a successful one and has data and continues to parse the response.
protected boolean property defined ( configuration conf , string property name ) { string prop = conf . get ( property name ) ;	Return true if and only if given property is defined with non empty non default value.
public static data parser exception convert ( com . streamsets . pipeline . lib . parser . data parser exception original ) { if ( original instanceof com . streamsets . pipeline . lib . parser . recoverable data parser exception ) { return new recoverable data parser exception ( ( ( com . streamsets . pipeline . lib . parser . recoverable data parser exception ) original ) . get unparsed record ( ) , original . get error code ( ) , original . get params ( ) ) ; } return new data parser exception ( original . get error code ( ) , original . get params ( ) ) ; }	Change package name for DataParserException.
public static data generator exception convert ( com . streamsets . pipeline . lib . generator . data generator exception original ) { return new data generator exception ( original . get error code ( ) , original . get params ( ) ) ; }	Change package name for DataGeneratorException.
private credentials get credentials ( stage . context context , list < stage . config issue > issues ) { credentials credentials = null ; file credentials file ; if ( paths . get ( path ) . is absolute ( ) ) { credentials file = new file ( path ) ; } else { credentials file = new file ( context . get resources directory ( ) , path ) ; } if ( ! credentials file . exists ( ) || ! credentials file . is file ( ) ) { log . error ( google 01 . get message ( ) , credentials file . get path ( ) ) ; issues . add ( context . create config issue ( groups . credentials . name ( ) , conf credentials credentials provider , google 01 , credentials file . get path ( ) ) ) ; return null ; } try ( input stream in = new file input stream ( credentials file ) ) { credentials = service account credentials . from stream ( in ) ; } catch ( io | illegal argument exception e ) { log . error ( google 02 . get message ( ) , e ) ; issues . add ( context . create config issue ( groups . credentials . name ( ) , conf credentials credentials provider , google 02 ) ) ; } return credentials ; }	Reads a JSON credentials file for a service account from and returns any errors.
public preview info json preview with override ( string pipeline id , list < stage output json > stage outputs to override json , string rev , integer batch size , integer batches , boolean skip targets , string end stage , long timeout ) throws api exception { object post body = stage outputs to override json ; byte [ ] post binary body = null ;	Run Pipeline preview.
protected int copy to buffer ( string builder s , int initial len , int start char , int current char ) { int overrun = num ; int current size = s . length ( ) - initial len ; int read size = current char - start char ; if ( max line > - num && current size + read size > max line ) { int adjusted read size = max line - current size ; if ( adjusted read size > num ) { s . append ( cb , start char , adjusted read size ) ; overrun = read size - adjusted read size ; } else { overrun = read size ; } } else { s . append ( cb , start char , read size ) ; } return overrun ; }	we use this to trim the output in case of overruns.
static void remove logical duplicates ( sorted set < string > packages ) { iterator < string > iterator = packages . iterator ( ) ; if ( ! iterator . has next ( ) ) { return ; } string last = iterator . next ( ) ; while ( iterator . has next ( ) ) { string current = iterator . next ( ) ; if ( current . starts with ( last ) ) { iterator . remove ( ) ; } else { last = current ; } } }	Traverses sorted list of packages and removes logical duplicates.
int find next main line ( live file chunk chunk , int start idx ) { list < file line > lines = chunk . get lines ( ) ; int found = - num ; for ( int i = start idx ; found == - num && i < lines . size ( ) ; i ++ ) { if ( pattern . matcher ( lines . get ( i ) . get text ( ) . trim ( ) ) . matches ( ) ) { found = i ; } } return found ; }	finds the first main line in the chunk from the specified index position onwards.
live file chunk resolve chunk ( live file chunk chunk ) { list < file line > complete lines = new array list < > ( ) ; list < file line > chunk lines = chunk . get lines ( ) ; if ( incomplete multi line . length ( ) == num ) { incomplete multi line offset = chunk . get offset ( ) ; incomplete multi line truncated = chunk . is truncated ( ) ; } incomplete multi line truncated |= chunk . is truncated ( ) ; int pos = num ; int idx = find next main line ( chunk , pos ) ;	it there is an incomplete multiline from a previous chunk it starts from it.
public void close connection ( ) { logger . debug ( str ) ; connection connection to remove = thread local connection . get ( ) ; jdbc util . close quietly ( connection to remove ) ; if ( connection to remove != null ) { synchronized ( this ) { connections to close during destroy . remove ( connection to remove ) ; } } thread local connection . set ( null ) ; }	Close the current thread's connection.
private static string escape quoted substring ( string input ) { string [ ] parts = input . split ( str ) ; string builder output = new string builder ( input . length ( ) * num ) ; for ( int i = num ; i < parts . length ; i ++ ) { if ( ( i % num ) == num ) { output . append ( str ) . append ( parts [ i ] . replace ( str , str ) ) . append ( str ) ; } else { output . append ( parts [ i ] ) ; } } return output . to string ( ) ; }	Add backslash to escape the | character within quoted sections of theinput string.
private flow control settings get flow control settings ( ) { return flow control settings . new builder ( ) . set limit exceeded behavior ( flow controller . limit exceeded behavior . block ) . set max outstanding element count ( ( long ) conf . basic . max batch size * conf . max threads / conf . advanced . num subscribers ) . build ( ) ; }	Returns a flow control setting such that a subscriber will block if it has buffered more messages than can beprocessed in a single batch times the number of record processors.
private instantiating grpc channel provider get channel provider ( ) { return subscription admin settings . default grpc transport provider builder ( ) . set max inbound message size ( max inbound message size ) . set endpoint ( strings . is null or empty ( conf . advanced . custom endpoint ) ? subscription admin settings . get default endpoint ( ) : conf . advanced . custom endpoint ) . build ( ) ; }	Creates a channel provider shared by each subscriber.
public object put ( offset and result < map . entry > batch ) { if ( consumer error != null ) { throw new runtime exception ( utils . format ( str , consumer error ) , consumer error ) ; } if ( producer error != null ) { throw new runtime exception ( utils . format ( str , producer error ) , producer error ) ; } try { object expected offset = str ; if ( ! batch . get result ( ) . is empty ( ) ) { expected offset = batch . get result ( ) . get ( batch . get result ( ) . size ( ) - num ) . get key ( ) ;	Queues the batch for the consumer and waits until the consumersuccessfully commits the batch.
public grok compile expression ( final string expression ) { throw error if dictionary is not ready ( ) ; final string digested expression = digest expression aux ( expression ) ; logger . debug ( str + expression + str + digested expression + str ) ; return new grok ( pattern . compile ( digested expression ) ) ; }	Compiles the expression into a patternThis uses the internal dictionary of named regular expressions.
private string digest expression aux ( string original expression ) { final string pattern start = str ; final string pattern stop = str ; final char pattern delimiter = str ; while ( bool ) { int pattern start index = original expression . index of ( pattern start ) ; int pattern stop index = original expression . index of ( pattern stop , pattern start index + pattern start . length ( ) ) ;	Digests the original expression into a pure named regex.
public void add dictionary ( final input stream input stream ) { try { add dictionary aux ( new input stream reader ( input stream , str ) ) ; } catch ( io e ) { throw new grok compilation exception ( e ) ; } }	Loads dictionary from an input streamThis can be used to load dictionaries available in the class path .
public void add dictionary ( reader reader ) { try { add dictionary aux ( reader ) ; } catch ( io e ) { throw new grok compilation exception ( e ) ; } finally { io . close quietly ( reader ) ; } }	Adds a dictionary entry via a Reader object.
public map < aggregator , aggregator data > stop ( ) { utils . check state ( started , str ) ; utils . check state ( ! stopped , str ) ; stopped = bool ; long current time millis = system . current time millis ( ) ; for ( map . entry < aggregator , aggregator data > e : data . entry set ( ) ) { e . get value ( ) . set time ( current time millis ) ; } map < aggregator , aggregator data > result = data ; result = aggregate data windows ( result ) ; return result ; }	Stops the AggregatorDataProvider instance.
public map < aggregator , aggregator data > roll ( long new data window end time millis ) { utils . check state ( started , str ) ; utils . check state ( ! stopped , str ) ; map < aggregator , aggregator data > result = data ; map < aggregator , aggregator data > new data = new concurrent hash map < > ( ) ; for ( aggregator aggregator : aggregators ) { new data . put ( aggregator , aggregator . create aggregator data ( new data window end time millis ) ) ; } data = new data ; map < aggregator , aggregator data > old data = result ;	Atomically rolls the DataWindow of all aggregators associated with the AggregatorDataProvider.
public string serialize ( object obj ) throws api exception { try { if ( obj != null ) return mapper . write value as string ( obj ) ; else return null ; } catch ( exception e ) { throw new api exception ( num , e . get message ( ) ) ; } }	Serialize the given Java object into JSON string.
public < t > t deserialize ( string body , type ref return type ) throws api exception { java type java type = mapper . construct type ( return type . get type ( ) ) ; try { return mapper . read value ( body , java type ) ; } catch ( io e ) { if ( return type . get type ( ) . equals ( string . class ) ) return ( t ) body ; else throw new api exception ( num , e . get message ( ) , null , body ) ; } }	Deserialize the given JSON string to Java object.
public < t > t deserialize ( file file , type ref return type ) throws api exception { java type java type = mapper . construct type ( return type . get type ( ) ) ; try { return mapper . read value ( file , java type ) ; } catch ( io e ) { throw new api exception ( num , e . get message ( ) , null , str ) ; } }	Deserialize the given File to Java object.
private void write ( record record ) throws on record error exception {	Writes a single record to the destination.
public static string resolve el ( el el eval , el variables , string val ) throws el { return el eval . eval ( variables , val , string . class ) ; }	Resolve expression from record.
private static < t > field generate inner field from the list ( linked hash map < string , t > original , string inner pair first field name , string inner pair second field name , boolean is second field hive type ) throws hive stage checked exception { list < field > column list = new linked list < > ( ) ; for ( map . entry < string , t > pair : original . entry set ( ) ) { linked hash map < string , field > entry = new linked hash map < > ( ) ; entry . put ( inner pair first field name , field . create ( pair . get key ( ) ) ) ; if ( is second field hive type ) { hive type info hive type info = ( hive type info ) pair . get value ( ) ; entry . put ( inner pair second field name , hive type info . get hive type ( ) . get support ( ) . generate hive type info field for metadata record ( hive type info ) ) ; } else { entry . put ( inner pair second field name , field . create ( pair . get value ( ) . to string ( ) ) ) ;	Opposite operation of extractInnerMapFromTheList.It takes LinkedHashMap and generate a Field that contains the list.This is to send metadata record to HMS target.This function is called to for partition type list and partition value list.
public static string get table name ( record metadata record ) throws hive stage checked exception { if ( metadata record . has ( sep + table field ) ) { return metadata record . get ( sep + table field ) . get value as string ( ) ; } throw new hive stage checked exception ( errors . hive 17 , table field , metadata record ) ; }	Get Table Name from the metadata record.
public static string get database name ( record metadata record ) throws hive stage checked exception { if ( metadata record . has ( sep + database field ) ) { string db name = metadata record . get ( sep + database field ) . get value as string ( ) ; return db name . is empty ( ) ? default dbname : db name ; } throw new hive stage checked exception ( errors . hive 17 , database field , metadata record ) ; }	Get Database Name from the metadata record.
public static boolean get internal field ( record metadata record ) throws hive stage checked exception { if ( metadata record . has ( sep + internal field ) ) { return metadata record . get ( sep + internal field ) . get value as boolean ( ) ; } throw new hive stage checked exception ( errors . hive 17 , internal field , metadata record ) ; }	Get internal field from the metadata record.
public static string get location ( record metadata record ) throws hive stage checked exception { if ( metadata record . has ( sep + location field ) ) { return metadata record . get ( sep + location field ) . get value as string ( ) ; } throw new hive stage checked exception ( errors . hive 17 , location field , metadata record ) ; }	Get Location from the metadata record.
public static boolean get custom location ( record metadata record ) throws hive stage checked exception { if ( metadata record . get ( sep + version ) . get value as integer ( ) < num ) { return default custom location ; } if ( metadata record . has ( sep + custom location ) ) { return metadata record . get ( sep + custom location ) . get value as boolean ( ) ; } throw new hive stage checked exception ( errors . hive 17 , custom location , metadata record ) ; }	Get the customLocation flag from the metadata record.
public static string get avro schema ( record metadata record ) throws hive stage checked exception { if ( metadata record . has ( sep + avro schema ) ) { return metadata record . get ( sep + avro schema ) . get value as string ( ) ; } throw new hive stage checked exception ( errors . hive 17 , avro schema , metadata record ) ; }	Get Avro Schema from Metadata Record.
public static string get data format ( record metadata record ) throws hive stage checked exception { if ( metadata record . get ( sep + version ) . get value as integer ( ) == num ) { return default data format ; } if ( metadata record . has ( sep + data format ) ) { return metadata record . get ( sep + data format ) . get value as string ( ) ; } throw new hive stage checked exception ( errors . hive 17 , data format , metadata record ) ; }	Get DataFormat from Metadata Record.
public static field new schema metadata field builder ( string database , string table name , linked hash map < string , hive type info > column list , linked hash map < string , hive type info > partition type list , boolean internal , string location , string avro schema , hmp data format ) throws hive stage checked exception { linked hash map < string , field > metadata = new linked hash map < > ( ) ; metadata . put ( version , field . create ( schema change metadata record version ) ) ; metadata . put ( metadata record type , field . create ( metadata record type . table . name ( ) ) ) ; metadata . put ( database field , field . create ( database ) ) ; metadata . put ( table field , field . create ( table name ) ) ; metadata . put ( location field , field . create ( location ) ) ; metadata . put ( data format , field . create ( data format . name ( ) ) ) ;	Fill in metadata to Record.
public static void validate partition information ( type info cache support . type info type info , linked hash map < string , string > partition val map , string qualified table name ) throws hive stage checked exception { set < string > partition names in hive = type info . get partition type info ( ) . key set ( ) ; set < string > partition names = partition val map . key set ( ) ; if ( ! ( partition names in hive . size ( ) == partition names . size ( ) && partition names in hive . contains all ( partition names ) ) ) { log . error ( utils . format ( str , partition names in hive . size ( ) , partition names . size ( ) ) ) ; throw new hive stage checked exception ( errors . hive 27 , qualified table name ) ; } }	Checks whether the number of partition columns and names match w.r.t hive.
public static string generate partition path ( linked hash map < string , string > partitions ) { string builder builder = new string builder ( ) ; for ( map . entry < string , string > pair : partitions . entry set ( ) ) { builder . append ( string . format ( partition path , pair . get key ( ) , pair . get value ( ) ) ) ; } return builder . to string ( ) ; }	Build a partition path for the external table.
public static string serialize schema to hdfs ( user group information login ugi , final file system fs , final string location , final string schema folder , final string database name , final string table name , final string schema json ) throws stage exception { string folder location ; if ( schema folder . starts with ( sep ) ) { folder location = schema folder ; } else { folder location = location + sep + schema folder ; } final path schemas folder path = new path ( folder location ) ; final string path = folder location + sep + string . format ( avro schema file format , database name , table name , uuid . random uuid ( ) . to string ( ) ) ; try { login ugi . do as ( new privileged exception action < void > ( ) { @ override public void run ( ) throws exception { if ( ! fs . exists ( schemas folder path ) ) { fs . mkdirs ( schemas folder path ) ; } path schema file path = new path ( path ) ;	Returns the hdfs paths where the avro schema is stored after serializing.Path is appended with current time so as to have an ordering.
@ visible for testing @ suppress warnings ( str ) int set parameters ( int op code , sorted map < string , string > columns to parameters , final record record , final connection connection , prepared statement statement ) throws on record error exception { int param idx = num ;	Set parameters and primary keys in query.
public map < string , object > get configuration ( ) throws api exception { object post body = null ; byte [ ] post binary body = null ;	Returns ALL SDC Configuration.
public static long parse rfc3164 time ( string ts ) throws on record error exception { local date time now = local date time . now ( ) ; int year = now . get year ( ) ; ts = two spaces . matcher ( ts ) . replace first ( str ) ; local date time date ; try { month day month day = month day . parse ( ts , rfc3164 format ) ; local time time = local time . parse ( ts , rfc3164 format ) ;	Parse the RFC3164 date format.
public static string format ( string template , object ... args ) { string [ ] template arr = templates . get ( template ) ; if ( template arr == null ) {	no escaping is supported, no array content printing either.
@ override public final batch context start batch ( ) { return ( batch context ) access controller . do privileged ( new privileged action ( ) { public object run ( ) { try { thread . current thread ( ) . set context class loader ( main class loader ) ; return push source context delegate . start batch ( ) ; } finally { thread . current thread ( ) . set context class loader ( get definition ( ) . get stage class loader ( ) ) ; } } } ) ; }	For all PushSource callbacks we have to make sure that we get back to a security contextof SDC container module, otherwise we won't be able to update state files with new offsetsand other stuff.
private boolean check record contains solr fields ( map < string , field > record field map , record record , list < string > solr fields map , errors error to throw ) throws stage exception {	Checks whether the record contains solr fields in solrFieldsMap or not.
private list < string > filter autogenerated field names ( list < string > field names ) { list < string > result = new array list < > ( ) ; field names . for each ( name -> { if ( ! autogenerated field names map . contains ( name ) ) { result . add ( name ) ; } } ) ; return result ; }	Filter auto-generated fields from the list passed as argument.
private void send on record error exception to handler ( record record , errors error , stage exception ex ) throws stage exception { error record handler . on error ( new on record error exception ( record , error , record . get header ( ) . get source id ( ) , ex . to string ( ) , ex ) ) ; }	Send exception ex to errorRecordHandler in order to let the handler process it.
public static optional < dependency > parse jar name ( string source name , string jar name ) { if ( special cases . contains key ( jar name ) ) { dependency special case = special cases . get ( jar name ) ; return optional . of ( new dependency ( source name , special case . get name ( ) , special case . get version ( ) ) ) ; }	Generate dependency from a jar file name.
public static optional < dependency > parse url ( url url ) { return parse jar name ( url . to string ( ) , paths . get ( url . get path ( ) ) . get file name ( ) . to string ( ) ) ; }	Generate dependency from a URL.
public static synchronized couchbase connector get instance ( base couchbase config config , list < stage . config issue > issues , stage . context context ) { map < string , object > runner shared map = context . get stage runner shared map ( ) ; if ( runner shared map . contains key ( instance ) ) { log . debug ( str ) ; } else { log . debug ( str ) ; validate config ( config , issues , context ) ; if ( issues . is empty ( ) ) { runner shared map . put ( instance , new couchbase connector ( config , issues , context ) ) ; } } return ( couchbase connector ) runner shared map . get ( instance ) ; }	Maintains a singleton instance of the CouchbaseConnector object per pipeline.
public synchronized void close ( ) { if ( ! is closed ) { if ( bucket != null ) { log . debug ( str ) ; bucket . close ( ) ; } if ( cluster != null ) { log . debug ( str ) ; cluster . disconnect ( ) ; } if ( env != null ) { log . debug ( str ) ; env . shutdown ( ) ; }	Disconnects from Couchbase and releases all resources.
public static string get label from string code ( string code ) throws number format exception { try { int int code = integer . parse int ( code ) ; return get label from int code ( int code ) ; } catch ( number format exception ex ) { throw new number format exception ( string . format ( str , str , code ) ) ; } }	Convert from code in String type to label.
private void verify dependency exists ( map < string , config definition > definitions map , config definition def , string depends on key , object context msg ) { preconditions . check state ( definitions map . contains key ( depends on key ) , utils . format ( str , context msg , def . get name ( ) , depends on key ) ) ; }	Verify that the config definition's dependency actually maps to a valid config definition.
private write operation type get operation from header ( record record , string key ) { string op = record . get header ( ) . get attribute ( operation type . sdc operation type ) ; if ( op == null || op . is empty ( ) ) { return config . default write operation ; } int op code ; try { op code = integer . parse int ( op ) ; } catch ( number format exception e ) { log . debug ( str ) ; handle error ( record , errors . couchbase 08 , e ) ; return null ; } switch ( op code ) { case operation type . insert code : return write operation type . insert ; case operation type . update code : return write operation type . replace ; case operation type . upsert code : return write operation type . upsert ; case operation type . delete code : return write operation type . delete ; default : switch ( config . unsupported operation ) { case discard : log . debug ( str , key ) ; return null ; case toerror : log . debug ( str , key ) ; handle error ( record , errors . couchbase 09 , new runtime exception ( ) ) ; return null ; default : log . debug ( str , key ) ; return config . default write operation ; } } }	Evaluates the sdc.operation.type header for a record and returns the equivalent Couchbase write operation type.
private observable < document fragment < mutation > > build subdoc mutation ( async mutate in builder mutation , int ttl , long cas , boolean upsert doc ) { return mutation . upsert document ( upsert doc ) . with expiry ( ttl ) . with cas ( cas ) . with durability ( config . persist to , config . replicate to ) . execute ( ) . timeout ( config . couchbase . kv timeout , time unit . milliseconds ) ; }	Applies standard options to sub-document mutations.
@ override protected string make alter table sql string ( string schema , string table name , linked hash map < string , jdbc type info > column diff ) { string table schema = ( schema == null ) ? get default schema ( ) : schema ; string builder sql string = new string builder ( ) ; boolean first = bool ; for ( map . entry < string , jdbc type info > entry : column diff . entry set ( ) ) { if ( first ) { first = bool ; } else { sql string . append ( str ) ; } sql string . append ( alter table ) . append ( str ) ; if ( table schema != null ) { sql string . append ( table schema ) ; sql string . append ( str ) ; } sql string . append ( table name ) . append ( str ) . append ( str ) . append ( str ) . append ( entry . get key ( ) ) . append ( str ) . append ( entry . get value ( ) . to string ( ) ) . append ( str ) ; } return sql string . to string ( ) ; }	H2 wants an ALTER TABLE command per column.
public void configure ( map < string , ? > configs , final string login context name ) { super . configure ( configs , login context name ) ; this . login context name = login context name ; this . ticket renew window factor = ( double ) configs . get ( sasl configs . sasl kerberos ticket renew window factor ) ; this . ticket renew jitter = ( double ) configs . get ( sasl configs . sasl kerberos ticket renew jitter ) ; this . min time before relogin = ( long ) configs . get ( sasl configs . sasl kerberos min time before relogin ) ; this . kinit cmd = ( string ) configs . get ( sasl configs . sasl kerberos kinit cmd ) ; this . service name = get service name ( configs , login context name ) ; }	Login constructor. The constructor starts the thread usedto periodically re-login to the Kerberos Ticket Granting Server.
public offset and result < map . entry > take ( ) { if ( producer error != null ) { throw new runtime exception ( utils . format ( str , producer error ) , producer error ) ; } if ( consumer error != null ) { throw new runtime exception ( utils . format ( str , consumer error ) , consumer error ) ; } try { utils . check state ( batch committed , str ) ; while ( running ) { for ( control channel . message control message : control channel . get consumer messages ( ) ) { switch ( control message . get type ( ) ) { case producer complete :	Consumes messages off the queue.
public void commit ( string offset ) { batch committed = bool ; log . trace ( str , last committed offset , offset ) ; utils . check state ( null != last committed offset , str ) ; control channel . consumer commit ( offset ) ; last committed offset = offset ; }	Commit the offset. Required after take has returned a non-null value.
public void error ( throwable throwable ) { if ( consumer error == null ) { consumer error = throwable ; control channel . consumer error ( throwable ) ; } }	Send a control message indicating the consumer has encountered an error.
public void inject stage ( object stage , stage definition stage def , stage configuration stage conf , map < string , object > constants , list < issue > issues ) { inject configs to object ( stage , new stage injector context ( stage def , stage conf , constants , issues ) ) ; }	Inject config values to given Stage.
public definitions json get definitions ( hide stage . type hide stage ) throws api exception { object post body = null ; byte [ ] post binary body = null ;	Returns pipeline &amp; stage configuration definitionsThis will fetch defintions based on the hideStage filter.
private lineage publisher definition get definition ( string name ) { string def config = lineage publisher constants . config def ( name ) ; string publisher definition = configuration . get ( def config , null ) ; if ( string utils . is empty ( publisher definition ) ) { throw new illegal argument exception ( utils . format ( str , def config ) ) ; } string [ ] lineage plugin defs = publisher definition . split ( str ) ; if ( lineage plugin defs . length != num ) { throw new illegal state exception ( utils . format ( str , publisher definition ) ) ; } lineage publisher definition def = stage library task . get lineage publisher definition ( lineage plugin defs [ num ] ,	Parse given configuration declaration of lineage plugin and return appropriate definition.This method will throw exceptions on all error paths.
private static string format name ( string column name , boolean case sensitive ) { string return value = format ( column name ) ; if ( case sensitive ) { return return value ; } return return value . to upper case ( ) ; }	Format column names based on whether they are case-sensitive.
private static string format value ( string value ) {	Unescapes strings and returns them.
public pipeline configuration json get pipeline info ( string pipeline id , string rev , string get , boolean attachment ) throws api exception { object post body = null ; byte [ ] post binary body = null ;	Find Pipeline Configuration by name and revision.
public pipeline fragment envelope json create draft pipeline fragment ( string fragment id , string description , list < stage configuration json > stage instances ) throws api exception { object post body = stage instances ; byte [ ] post binary body = null ;	Add a new Pipeline Fragment Configuration to the store.
public list < pipeline info json > get pipelines ( string filter text , string label , int offset , int len , pipeline order by fields order by , order order , boolean include status ) throws api exception { object post body = null ; byte [ ] post binary body = null ;	Returns all Pipeline Configuration Info.
public pipeline fragment envelope json import pipeline fragment ( string fragment id , boolean draft , boolean include library definitions , pipeline fragment envelope json fragment envelope ) throws api exception { object post body = fragment envelope ; byte [ ] post binary body = null ;	Import Pipeline Fragment Configuration & Rules.
public string get file path ( string dir path template , record record , date record time ) throws stage exception { string dir path ;	Returns the temp file path to write records to.
int get operation from record ( record record , int default op code , unsupported operation action unsupported action , list < on record error exception > error records ) { string op = record . get header ( ) . get attribute ( operation type . sdc operation type ) ; int op code = - num ;	Get the numeric operation code from record header.
string get field path ( string column name , map < string , string > columns to field , int op ) { return columns to field . get ( column name ) ; }	This function simply returns field path in record for the corresponding column name.This is needed because records generated by CDC origins store data in different locationfor different operation.
public enriched event poll ( long timeout , time unit unit ) throws stage exception { try { return queue . poll ( timeout , unit ) ; } catch ( interrupted exception e ) { log . error ( errors . mysql 001 . get message ( ) , e . to string ( ) , e ) ; thread . current thread ( ) . interrupt ( ) ; throw new stage exception ( errors . mysql 001 , e . to string ( ) , e ) ; } }	Read next event from buffer with respect to maximum timeout.
public t get runner ( ) throws pipeline runtime exception { validate not destroyed ( ) ; try { return queue . take ( ) . runner ; } catch ( interrupted exception e ) { throw new pipeline runtime exception ( container error . container 0801 , e ) ; } finally { runtime stats . set available runners ( queue . size ( ) ) ; histogram . update ( queue . size ( ) ) ; } }	Get exclusive runner for use.
public t get idle runner ( long idle time ) {	Return a runner that haven't been used at least for the configured number of milliseconds.
public void return runner ( t runner ) throws pipeline runtime exception { validate not destroyed ( ) ; queue . add ( new queue item < > ( runner ) ) ; runtime stats . set available runners ( queue . size ( ) ) ; histogram . update ( queue . size ( ) ) ; }	Return given runner back to the pool.
public void destroy ( ) throws pipeline runtime exception {	Destroy only the pool itself - not the individual pipe runners.This method will also validate that all runners were properly returned to the pool.
private void validate not destroyed ( ) throws pipeline runtime exception { if ( destroyed . get ( ) ) { throw new pipeline runtime exception ( container error . container 0803 , queue . size ( ) , runtime stats . get total runners ( ) ) ; } }	Throw an exception if the runner was already destroyed.
public static long check stream exists ( client configuration aws client config , kinesis config bean conf , string stream name , list < stage . config issue > issues , stage . context context ) { long num shards = num ; try { num shards = get shard count ( aws client config , conf , stream name ) ; } catch ( amazon client exception | stage exception e ) { log . error ( errors . kinesis 01 . get message ( ) , e . to string ( ) , e ) ; issues . add ( context . create config issue ( groups . kinesis . name ( ) , kinesis config bean + str , errors . kinesis 01 , e . to string ( ) ) ) ; } return num shards ; }	Checks for existence of the requested stream and addsany configuration issues to the list.
public static string get last shard id ( client configuration aws client config , kinesis config bean conf , string stream name ) throws stage exception { amazon kinesis kinesis client = get kinesis client ( aws client config , conf ) ; string last shard id = null ; try { stream description description ; do { if ( last shard id == null ) { description = kinesis client . describe stream ( stream name ) . get stream description ( ) ; } else { description = kinesis client . describe stream ( stream name , last shard id ) . get stream description ( ) ; } int page size = description . get shards ( ) . size ( ) ; last shard id = description . get shards ( ) . get ( page size - num ) . get shard id ( ) ; } while ( description . get has more shards ( ) ) ; return last shard id ; } finally { kinesis client . shutdown ( ) ; } }	Get the last shard Id in the given streamIn preview mode, kinesis source uses the last Shard Id to get records from kinesis.
private void process queue ( linked list < record > queue , list < on record error exception > error records , connection connection , int max rows per batch , int op code ) throws stage exception { if ( queue . is empty ( ) ) { return ; } int row count = num ;	Process all records in queue.
private void handle sql exception ( sql exception , list < record > input records , list < on record error exception > errors ) throws stage exception { if ( jdbc util . is data error ( get custom data sql state codes ( ) , get connection string ( ) , exception ) ) { string formatted error = jdbc util . format sql exception ( exception ) ; log . error ( jdbc errors . jdbc 89 . get message ( ) , formatted error ) ; for ( record input record : input records ) { errors . add ( new on record error exception ( input record , jdbc errors . jdbc 89 , formatted error ) ) ; } return ; } super . handle sql exception ( exception ) ; }	Handle SQLException in a smart way, detecting if the exception is data oriented or not.
private hash code get column hash ( record record , int op ) throws on record error exception { map < string , string > parameters = get columns to parameters ( ) ; sorted map < string , string > columns to parameters = record reader . get columns to parameters ( record , op , parameters , get columns to fields ( ) ) ; return column hash function . new hasher ( ) . put object ( columns to parameters , string map funnel ) . hash ( ) ; }	Generates a hash for the fields present in a record and their mappings.A specific implementation of the hash function is not guaranteed.
public static boolean compare files ( wrapped file system fs , wrapped file f1 , wrapped file f2 ) { if ( ! fs . exists ( f2 ) ) { return bool ; } try { long mtime1 = fs . get last modified time ( f1 ) ; long mtime2 = fs . get last modified time ( f2 ) ; long ctime1 = fs . get changed time ( f1 ) ; long ctime2 = fs . get changed time ( f2 ) ; long time1 = math . max ( mtime1 , ctime1 ) ; long time2 = math . max ( mtime2 , ctime2 ) ; int compares = long . compare ( time1 , time2 ) ; if ( compares != num ) { return compares > num ; } } catch ( io ex ) { log . error ( str , f1 . get file name ( ) , ex ) ; return bool ; } return f1 . get absolute path ( ) . compare to ( f2 . get absolute path ( ) ) > num ; }	True if f1 is "newer" than f2.
private static int retrieve pid if feasible ( process process ) { if ( unix process class == null ) { return undetermined pid ; } if ( ! unix process class . is instance ( process ) ) { log . debug ( str , process . get class ( ) . get name ( ) ) ; return undetermined pid ; } try { return ( int ) pid field . get ( process ) ; } catch ( illegal access exception e ) { log . debug ( str , e ) ; return undetermined pid ; } }	Attempts to retrieve PID from internal JVM classes.
private set < string > validate and extract fields to hash ( record record , set < string > fields dont exist , set < string > fields with list or map type , set < string > fields with null , collection < string > matching fields path ) { set < string > valid fields to hash for this config = new hash set < string > ( ) ; for ( string matching field path : matching fields path ) { if ( record . has ( matching field path ) ) { field field = record . get ( matching field path ) ; if ( unsupported field types . contains ( field . get type ( ) ) ) { fields with list or map type . add ( matching field path ) ; } else if ( field . get value ( ) == null ) { fields with null . add ( matching field path ) ; } else { valid fields to hash for this config . add ( matching field path ) ; } } else { fields dont exist . add ( matching field path ) ; } } return valid fields to hash for this config ; }	Basically throw out map, list map, list and null values fields.
public static user group information get proxy user ( string user ,	Return UGI object that should be used for any remote operation.This object will be impersonate according to the configuration.
public active stats roll ( ) { long now = system . current time millis ( ) ; set end time ( now ) ; active stats stats bean = new active stats ( ) . set start time ( now ) . set data collector version ( get data collector version ( ) ) . set dpm enabled ( is dpm enabled ( ) ) . set up time ( get up time ( ) . roll ( ) ) ; stats bean . set pipelines ( get pipelines ( ) . stream ( ) . map ( usage timer :: roll ) . collect ( collectors . to list ( ) ) ) ; stats bean . set stages ( get stages ( ) . stream ( ) . filter ( timer -> timer . get multiplier ( ) > num ) . map ( usage timer :: roll ) . collect ( collectors . to list ( ) ) ) ; return stats bean ; }	returns fresh bean with same UsageTimers just reset to zero accumulated time to be used as the new live stats.
public active stats snapshot ( ) { active stats snapshot = new active stats ( ) . set start time ( get start time ( ) ) . set data collector version ( get data collector version ( ) ) . set dpm enabled ( is dpm enabled ( ) ) . set up time ( get up time ( ) . snapshot ( ) ) . set record count ( get record count ( ) ) ; snapshot . set pipelines ( get pipelines ( ) . stream ( ) . map ( usage timer :: snapshot ) . collect ( collectors . to list ( ) ) ) ; snapshot . set stages ( get stages ( ) . stream ( ) . map ( usage timer :: snapshot ) . collect ( collectors . to list ( ) ) ) ; return snapshot ; }	returns a snapshot for persistency.
private void ensure directory exists ( file system fs , path path ) throws io { if ( ! fs . exists ( path ) ) { log . debug ( str , path ) ; if ( ! fs . mkdirs ( path ) ) { throw new io ( str + path ) ; } } }	Ensure that given directory exists.Creates the directory if it doesn't exists.
public void write ( batch batch , schema table classifier schema table classifier , loading cache < schema and table , jdbc record writer > record writers , error record handler error record handler , boolean per record ) throws stage exception { multimap < schema and table , record > partitions = schema table classifier . classify ( batch ) ; for ( schema and table key : partitions . key set ( ) ) { iterator < record > record iterator = partitions . get ( key ) . iterator ( ) ; write ( record iterator , key , record writers , error record handler , per record ) ; } }	Write records to potentially different schemas and tables using EL expressions, and handle errors.
public void write ( batch batch , el table name eval , el table name vars , string table name template , loading cache < string , jdbc record writer > record writers , error record handler error record handler , boolean per record ) throws stage exception { multimap < string , record > partitions = el . partition batch by expression ( table name eval , table name vars , table name template , batch ) ; for ( string table name : partitions . key set ( ) ) { iterator < record > record iterator = partitions . get ( table name ) . iterator ( ) ; write ( record iterator , table name , record writers , error record handler , per record ) ; } }	Write records to the evaluated tables and handle errors.
public < t > void write ( iterator < record > record iterator , t key , loading cache < t , jdbc record writer > record writers , error record handler error record handler , boolean per record ) throws stage exception { final jdbc record writer jdbc record writer ; try { jdbc record writer = record writers . get unchecked ( key ) ; } catch ( unchecked execution exception ex ) { final throwable throwable = ex . get cause ( ) ; final error code error code ; final object [ ] message params ; if ( throwable instanceof stage exception ) { stage exception stage ex = ( stage exception ) ex . get cause ( ) ; error code = stage ex . get error code ( ) ; message params = stage ex . get params ( ) ; } else { error code = jdbc errors . jdbc 301 ; message params = new object [ ] { ex . get message ( ) , ex . get cause ( ) } ; }	Write records to a JDBC destination using the recordWriter specified by key, and handle errors.
public void generate no more data event ( push source . context context ) { log . info ( str ) ; batch context batch context = context . start batch ( ) ; common events . no more data . create ( context , batch context ) . create and send ( ) ; context . process batch ( batch context ) ; }	Generates the no-more-data event.
private map < partition info cache support . partition values , string > detect new partition ( partition info cache support . partition values partition values , partition info cache support . partition info p cache , string location ) throws stage exception { map < partition info cache support . partition values , string > partition info diff = new hash map < > ( ) ; partition info diff . put ( partition values , location ) ; partition info diff = ( p cache != null ) ? p cache . get diff ( partition info diff ) : partition info diff ; if ( p cache == null || ! partition info diff . is empty ( ) ) { return partition info diff ; } return null ; }	Using partition name and value that were obtained from record, compare themwith cached partition.
@ visible for testing static void update record for hdfs ( record record , boolean roll , string avro schema , string location ) { if ( roll ) { record . get header ( ) . set attribute ( hdfs header roll , str ) ; } record . get header ( ) . set attribute ( hdfs header avroschema , avro schema ) ; record . get header ( ) . set attribute ( hdfs header target directory , location ) ; log . trace ( str , record . get header ( ) . get source id ( ) , location , roll , avro schema ) ; }	Add header information to send to HDFS.
public void process ( string group , t value ) { get data ( ) . process ( immutable map . of ( group , value ) ) ; }	Processes the given value into the corresponding group-by element of the aggregator.
public static boolean is same version ( class < ? extends stage > a , class < ? extends stage > b ) { stage def a def = a . get annotation ( stage def . class ) ; stage def b def = b . get annotation ( stage def . class ) ; return a def . version ( ) == b def . version ( ) ; }	Returns if and only if both stage classes have defined the same version.
public static void main ( string [ ] args ) throws exception { bootstrap cluster . print system props env variables ( ) ; string mesos dir = system . getenv ( str ) ; if ( mesos dir == null ) { throw new illegal state exception ( str ) ; } file mesos home dir = new file ( mesos dir ) ; string spark dir = system . getenv ( str ) ; if ( spark dir == null ) { throw new illegal state exception ( str ) ; } file spark home dir = new file ( spark dir ) ; int process exit value = bootstrap cluster . find and extract jar ( mesos home dir , spark home dir ) ; if ( process exit value != num ) { throw new illegal state exception ( str ) ; } system . set property ( str , new file ( mesos home dir , bootstrap cluster . sdc mesos base dir ) . get absolute path ( ) ) ; final class < ? > clazz = class . for name ( str ) ; final method method = clazz . get method ( str , string [ ] . class ) ; method . invoke ( null , new object [ ] { args } ) ; }	Bootstrapping the Driver which starts a Spark job on Mesos.
private void configure auth and build client ( client builder client builder , list < stage . config issue > issues ) { if ( jersey client config . auth type == authentication type . oauth ) { string consumer key = jersey client config . oauth . resolve consumer key ( context , str , str , issues ) ; string consumer secret = jersey client config . oauth . resolve consumer secret ( context , str , str , issues ) ; string token = jersey client config . oauth . resolve token ( context , str , str , issues ) ; string token secret = jersey client config . oauth . resolve token secret ( context , str , str , issues ) ; if ( issues . is empty ( ) ) { auth token = jersey client util . configure o ( consumer key , consumer secret , token , token secret , client builder ) ; } } else if ( jersey client config . auth type . is one of ( authentication type . digest , authentication type . basic , authentication type . universal ) ) { string username = jersey client config . basic auth . resolve username ( context , str , str , issues ) ; string password = jersey client config . basic auth . resolve password ( context , str , str , issues ) ; if ( issues . is empty ( ) ) { jersey client util . configure password auth ( jersey client config . auth type , username , password , client builder ) ; } } try { build new authenticated client ( issues , bool ) ; client initialized = bool ; } catch ( stage exception e ) {	Helper to apply authentication properties to Jersey client.
public multivalued map < string , object > resolve headers ( map < string , string > headers , record record ) throws stage exception { el . set record in context ( header vars , record ) ; multivalued map < string , object > request headers = new multivalued hash map < > ( ) ; for ( map . entry < string , string > entry : headers . entry set ( ) ) { list < object > header = new array list < > ( num ) ; object resolved value = header eval . eval ( header vars , entry . get value ( ) , string . class ) ; header . add ( resolved value ) ; request headers . put ( entry . get key ( ) , header ) ; } return request headers ; }	Evaluates any EL expressions in the headers section of the stage configuration.
public http method get http method ( http method http method , string method expression , record record ) throws el { if ( http method != http method . expression ) { return http method ; } el . set record in context ( method vars , record ) ; return http method . value of ( method eval . eval ( method vars , method expression , string . class ) ) ; }	Determines the HTTP method to use for the next request.
public static void fill null types ( simple bindings bindings ) { bindings . put ( str , null boolean ) ; bindings . put ( str , null char ) ; bindings . put ( str , null byte ) ; bindings . put ( str , null short ) ; bindings . put ( str , null integer ) ; bindings . put ( str , null long ) ; bindings . put ( str , null float ) ; bindings . put ( str , null double ) ; bindings . put ( str , null date ) ; bindings . put ( str , null datetime ) ; bindings . put ( str , null time ) ; bindings . put ( str , null decimal ) ; bindings . put ( str , null byte array ) ; bindings . put ( str , null string ) ; bindings . put ( str , null list ) ; bindings . put ( str , null map ) ; }	Add each object of typed null to SimpleBindings, so that script languagescan use constants such as "NULL_INTEGER", "NULL_LONG" without importingother files.
public static object get field null ( record record , string field path ) { field f = record . get ( field path ) ; if ( f != null ) { return f . get value ( ) == null ? get typed null from field ( f ) : f . get value ( ) ; } return null ; }	Receive record and fieldPath from scripting processor.It resolves type of the field, and if value is null, it returnsone of the NULL_XXX objects defined in this class.If field value is not null, it returns the value stored in the field.
public schema load from registry ( string subject , int schema id ) throws schema registry exception { try { if ( is empty ( subject ) ) { return load from registry ( schema id ) ; } else { return load from registry ( subject ) ; } } catch ( schema registry exception e ) { throw new schema registry exception ( e ) ; } }	Parses and returns an Avro schema loaded from the schema registry using the provided schema IDif available, or the latest version of a schema for the specified subject.
public int register schema ( schema schema , string subject ) throws schema registry exception { try { return schema id cache . get ( subject + schema . hash code ( ) , ( ) -> registry client . register ( subject , schema ) ) ; } catch ( execution exception e ) { throw new schema registry exception ( e ) ; } }	Registers a parsed schema with the schema registry under the specified subject.
public schema load from registry ( string subject ) throws schema registry exception { try { schema metadata metadata = registry client . get latest schema metadata ( subject ) ; return registry client . get by id ( metadata . get id ( ) ) ; } catch ( io | rest client exception e ) { throw new schema registry exception ( e ) ; } }	Loads and parses a schema for the specified subject from the schema registry.
public int get schema id from subject ( string subject ) throws schema registry exception { try { schema metadata metadata = registry client . get latest schema metadata ( subject ) ; return metadata . get id ( ) ; } catch ( io | rest client exception e ) { throw new schema registry exception ( e ) ; } }	Looks up schema id for the specified subject from the schema registry.
public schema load from registry ( int id ) throws schema registry exception { try { return registry client . get by id ( id ) ; } catch ( io | rest client exception e ) { throw new schema registry exception ( e ) ; } }	Loads and parses a schema for the specified schema ID from the schema registry.
public int write schema id ( output stream os , int schema id ) throws io { if ( schema id > num ) { os . write ( magic byte ) ; os . write ( byte buffer . allocate ( id size ) . put int ( schema id ) . array ( ) ) ; } return schema id ; }	Writes the magic byte and schema ID to an output stream, replicating the functionalityof the Confluent Kafka Avro Serializer.
public optional < integer > detect schema id ( byte [ ] data ) { if ( data . length < num ) { return optional . empty ( ) ; } byte buffer wrapped = byte buffer . wrap ( data ) ;	Checks for a magic byte in the data and if present extracts the schemaId.
public static map < string , object > get default values ( schema schema ) throws schema registry exception { map < string , object > default values = new hash map < > ( ) ; try { default values . put all ( avro type util . get default values from schema ( schema , new hash set < string > ( ) ) ) ; } catch ( io e ) { throw new schema registry exception ( e ) ; } return default values ; }	Helper method to extract default values from a Schema.
public static list < record > parse all ( stage . context stage context , to error context to error context , boolean produce single record per message , string message id , byte [ ] payload ) throws stage exception { list < record > records = new array list < > ( ) ; try ( data parser parser = stage context . get service ( data format parser service . class ) . get parser ( message id , payload ) ) { record record = null ; do { try { record = parser . parse ( ) ; } catch ( recoverable data parser exception e ) { handle exception ( stage context , to error context , message id , e , e . get unparsed record ( ) ) ;	Convenience method to parse all available records in given payload.
public void log details ( ) { if ( is valid ( ) ) { return ; } log . warn ( str , name ) ; if ( ! unparseable paths . is empty ( ) ) { log . warn ( str ) ; for ( string path : unparseable paths ) { log . warn ( str , path ) ; } } if ( ! version collisions . is empty ( ) ) { log . warn ( str ) ; for ( map . entry < string , map < string , list < dependency > > > entry : version collisions . entry set ( ) ) { log . warn ( str , entry . get key ( ) , string utils . join ( entry . get value ( ) . key set ( ) , str ) ) ; for ( map . entry < string , list < dependency > > version entry : entry . get value ( ) . entry set ( ) ) { log . warn ( str , version entry . get key ( ) ) ; for ( dependency dependency : version entry . get value ( ) ) { log . warn ( str , dependency . get source name ( ) ) ; } } } } }	Generate small report into log.
private list < record > get bad records ( error sink error sink ) { list < record > bad records = new array list < > ( ) ; for ( map . entry < string , list < record > > entry : error sink . get error records ( ) . entry set ( ) ) { for ( record record : entry . get value ( ) ) { record impl error record ; switch ( error record policy ) { case original record : error record = ( record impl ) ( ( record impl ) record ) . get header ( ) . get source record ( ) ; error record . get header ( ) . copy error from ( record ) ; break ; case stage record : error record = ( record impl ) record ; break ; default : throw new illegal argument exception ( str + error record policy ) ; } error record . get header ( ) . set error context ( runtime info . get id ( ) , pipeline name ) ; bad records . add ( error record ) ; } } return bad records ; }	Generate list of error records from the error sink.
public list < stage . config issue > init ( schema generator config config , stage . context context ) { this . config = config ; return collections . empty list ( ) ; }	Initialize the schema generator.
public collection < v > get outward edge vertices ( v vertex ) { collection < v > outward edge vertices for vertex = outward edge vertices . get ( vertex ) ; return outward edge vertices for vertex != null ? outward edge vertices for vertex : collections . < v > empty set ( ) ; }	Returns the outward flowing edge vertices.
public collection < v > get inward edge vertices ( v vertex ) { collection < v > inward edge vertices for vertex = inward edges vertices . get ( vertex ) ; return inward edge vertices for vertex != null ? inward edge vertices for vertex : collections . < v > empty set ( ) ; }	Returns the inward flowing edge vertices.
public static string serialize offset map ( map < string , string > offset map ) throws io { return json mapper . write value as string ( offset map ) ; }	Serialize the Map of table to offset to a String.
@ suppress warnings ( str ) public static map < string , string > deserialize offset map ( string last source offset ) throws io { map < string , string > offset map ; if ( last source offset == null || last source offset . is empty ( ) ) { offset map = new hash map < > ( ) ; } else { offset map = json mapper . read value ( last source offset , map . class ) ; } return offset map ; }	Deserialize String offset to Map of table to offset.
public int queue report ( ) throws io , interrupted exception , execution exception , timeout exception , stage exception { final async invoker async invoker = queue resource . request ( ) . header ( wsse header , omniture auth util . get header ( username . get ( ) , shared secret . get ( ) ) ) . async ( ) ; log . debug ( str , queue resource . get uri ( ) . to url ( ) . to string ( ) , report description ) ; final future < response > response future = async invoker . post ( entity . json ( report description ) ) ; response response = response future . get ( response timeout millis , time unit . milliseconds ) ; if ( response == null ) { log . error ( str , queue resource . get uri ( ) . to url ( ) . to string ( ) ) ; throw new stage exception ( errors . omniture 01 , str ) ; } log . debug ( str , response . get status ( ) ) ; object mapper mapper = new object mapper ( ) ; string json = response . read entity ( string . class ) ; log . trace ( str , json ) ; json node root = mapper . read tree ( json ) ; if ( root == null ) { log . error ( str , json ) ; throw new stage exception ( errors . omniture 01 , json ) ; } if ( root . has ( str ) ) { throw new stage exception ( errors . omniture 01 , root . get ( str ) . as text ( ) ) ; } log . info ( str ) ; return root . get ( str ) . as int ( ) ; }	Queue a report using the Report.Queue method.
public void get report ( int report id ) throws interrupted exception , execution exception , timeout exception , io , stage exception { int wait time = num ; response response = null ; while ( ! stop ) { final async invoker async invoker = get resource . request ( ) . header ( wsse header , omniture auth util . get header ( username . get ( ) , shared secret . get ( ) ) ) . async ( ) ; log . debug ( str , get resource . get uri ( ) . to url ( ) . to string ( ) , report id ) ; final future < response > response future = async invoker . post ( entity . json ( str + report id + str ) ) ; response = response future . get ( response timeout millis , time unit . milliseconds ) ; string input = response . read entity ( string . class ) ; object mapper mapper = new object mapper ( ) ; json node root = mapper . read tree ( input ) ;	Posts a request to the Omniture API to get a report back.
public boolean is sdc ( ) { try { return fs . exists ( check point file path ) || fs . exists ( backup check point file path ) ; } catch ( io ex ) { log . error ( str , ex ) ; throw new runtime exception ( utils . format ( str , check point file path . to string ( ) , ex . to string ( ) ) , ex ) ; } }	This tell us SDC is check pointing.
private void write offsets to main offset file ( map < integer , long > partition to offset map ) throws io { log . info ( str , partition to offset map , check point file path ) ;	Or if the file is corrupted, we want to update the right offsets to the main offset file.
private void delete ( blob id blob id ) { log . debug ( str , string . format ( blob path template , blob id . get bucket ( ) , blob id . get name ( ) ) ) ; boolean deleted = storage . delete ( blob id ) ; if ( ! deleted ) { log . error ( str , string . format ( blob path template , blob id . get bucket ( ) , blob id . get name ( ) ) ) ; } }	Delete a blob for gcs.
void handle error ( blob id blob id ) { switch ( gcs origin error config . error handling option ) { case none : break ; case archive : handle archive ( blob id ) ; break ; case delete : delete ( blob id ) ; break ; } }	Handle error Blob.
private void handle archive ( blob id blob id ) { string destination path = get destination path ( blob id , gcs origin error config . error prefix ) ; switch ( gcs origin error config . archiving option ) { case copy to bucket : copy ( blob id , gcs origin error config . error bucket , destination path , bool ) ; break ; case move to bucket : copy ( blob id , gcs origin error config . error bucket , destination path , bool ) ; break ; case copy to prefix : copy ( blob id , blob id . get bucket ( ) , destination path , bool ) ; break ; case move to prefix : copy ( blob id , blob id . get bucket ( ) , destination path , bool ) ; break ; } }	Archive the blob.
public live file reader get reader ( ) throws io { utils . check state ( open , str ) ; if ( reader == null ) { current file = get starting current file name ( ) ; long file offset = get starting offset ( ) ; boolean needs to scan = current file == null || file offset == long . max value ; if ( needs to scan ) { if ( current file != null ) {	prepares and gets the reader if available before a read.
public void release reader ( boolean in error discard reader ) throws io { utils . check state ( open , str ) ;	updates reader and offsets after a read.
public api client set dpm url ( string dpm base url ) { if ( dpm base url != null && authentication != null ) { authentication . set dpm url ( dpm base url ) ; } return this ; }	Helper method to set dpmBaseURL for the first HTTP DPM authentication.
public api client add default header ( string key , string value ) { default header map . put ( key , value ) ; return this ; }	Add a default header.
public date parse date ( string str ) { try { return date format . parse ( str ) ; } catch ( java . text . parse exception e ) { throw new runtime exception ( e ) ; } }	Parse the given string into Date object.
public string escape string ( string str ) { try { return url . encode ( str , str ) . replace all ( str , str ) ; } catch ( unsupported encoding exception e ) { return str ; } }	Escape the given string to be used as URL query value.
private client get client ( ) { if ( ! host map . contains key ( base path ) ) { client config config = new client config ( ) ; config . property ( client properties . suppress http compliance validation , bool ) ; client client = client builder . new client ( config ) ; client . register ( new csrf protection filter ( str ) ) ; host map . put ( base path , client ) ; } return host map . get ( base path ) ; }	Get an existing client or create a new client to handle HTTP request.
private gp init connection ( kinetica config bean conf ) throws gp , stage exception { kinetica connection utils kinetica connection utils = new kinetica connection utils ( ) ; return kinetica connection utils . get gp ( conf ) ; }	Connect to the database.
private void get table metadata ( gp gpudb , string table name ) throws gp { kinetica table utils kinetica table utils = new kinetica table utils ( gpudb , table name ) ; type = kinetica table utils . get type ( ) ; }	Get metadata for the table.
public event builder create ( stage . context context , to event context to event ) { return new event builder ( context , to event ) ; }	Create new event record according for this stage context and event context.
public static schema build schema ( map < string , schema > fields , object ... levels ) { list < schema . field > record fields = new array list < > ( fields . size ( ) ) ; for ( map . entry < string , schema > entry : fields . entry set ( ) ) { record fields . add ( new schema . field ( entry . get key ( ) , entry . get value ( ) , null ,	Build a schema with type "record". This will be the top level schema and contains fields.
public static int convert from oracle to sdc ( string code ) { try { int int code = integer . parse int ( code ) ; switch ( int code ) { case insert code : return operation type . insert code ; case delete code : return operation type . delete code ; case update code : case select for update code : return operation type . update code ; default :	This is called when JDBC target didn't find sdc.operation.code in record headerbut found oracle.cdc.operation.
public static void add jars to job ( configuration conf , class ... klasses ) {	Add jars containing the following classes to the job's classpath.
private boolean check field order by list ( soql . field order by list context field order by list , string field name ) { return field order by list . field order by element ( num ) . field element ( ) . get text ( ) . equals ignore case ( field name ) ; }	Returns true if the first ORDER BY field matches fieldName.
private boolean check condition expressions ( soql . condition expressions context condition expressions , string field name ) { for ( soql . condition expression context ce : condition expressions . condition expression ( ) ) { if ( ( ce . condition expressions ( ) != null && check condition expressions ( ce . condition expressions ( ) , field name ) ) || ( ce . field expression ( ) != null && ce . field expression ( ) . field element ( ) . get text ( ) . equals ignore case ( field name ) ) ) { return bool ; } } return bool ; }	Returns true if any of the nested conditions contains fieldName.
public static long get offset lag for file ( string file offset string ) throws io { long offset = file context provider util . get long offset from file offset ( file offset string ) ;	If passed a valid fileOffsetString, it will return what is the offset lag in the file.
public static void premain ( string args , instrumentation instrumentation ) { if ( bootstrap main . instrumentation == null ) { bootstrap main . instrumentation = instrumentation ; } else { throw new illegal state exception ( str + bootstrap main . instrumentation + str ) ; } }	Visible due to JVM requirements only.
public int get parallelism ( ) throws stage exception { if ( origin parallelism == num ) {	This API is being used by ClusterKafkaSource.
public table result run query ( query job configuration query config , long timeout , long page size ) throws stage exception { check argument ( timeout >= num , str ) ; instant max time = instant . now ( ) . plus millis ( timeout ) ;	Executes a query request and returns the results.
private list < string > get table description ( ) throws gp { list < list < string > > descriptions = show table response . get table descriptions ( ) ; if ( descriptions == null || descriptions . size ( ) != num ) { throw new gp ( str + table name ) ; } return descriptions . get ( num ) ; }	Get the table description from the ShowTableResponse.
private void validate table accepts inserts ( ) throws gp { for ( string s : table description ) { if ( s . equals ignore case ( str ) ) { throw new gp ( str + table name + str ) ; } else if ( s . equals ignore case ( str ) ) { throw new gp ( str + table name + str ) ; } else if ( s . equals ignore case ( str ) ) { throw new gp ( str + table name + str ) ; } else if ( s . equals ignore case ( str ) ) { throw new gp ( str + table name + str ) ; } } }	if it is not.
private class < ? > get column type ( json field ) throws gp { class < ? > column type = null ;	Get the Class for the column type.
private boolean type is nullable ( json field ) throws gp { if ( field . get ( str ) instanceof json ) { json column types = field . get json ( str ) ; for ( int j = num ; j < column types . length ( ) ; j ++ ) { string ct = ( string ) column types . get ( j ) ; if ( ct . equals ( str ) ) { return bool ; } } } return bool ; }	the Avro "type" field).
private json get table schema ( string table name , show table response show table response ) throws gp { list < string > schemas = show table response . get type schemas ( ) ; if ( schemas == null || schemas . size ( ) != num ) { throw new gp ( str + table name ) ; } return new json ( schemas . get ( num ) ) ; }	Get the table's schema as a JSON Object.
private map < string , list < string > > get column properties ( string table name , show table response show table response ) throws gp { list < map < string , list < string > > > column properties list = show table response . get properties ( ) ; if ( column properties list == null || column properties list . size ( ) != num ) { throw new gp ( str + table name ) ; } return column properties list . get ( num ) ; }	Get the table's extended column properties.
private class < ? > get class for type ( string type name ) throws gp { type name = type name . replace ( str , str ) ; if ( type name . equals ignore case ( string type name ) ) { return string . class ; } else if ( type name . equals ignore case ( long type name ) ) { return long . class ; } else if ( type name . equals ignore case ( integer type name ) ) { return integer . class ; } else if ( type name . equals ignore case ( float type name ) ) { return float . class ; } else if ( type name . equals ignore case ( double type name ) ) { return double . class ; } else if ( type name . equals ignore case ( bytes type name ) ) { return byte buffer . class ; } else { throw new gp ( str + type name + str ) ; } }	Get the Java type for a type name.
public void init ( target . context context , list < target . config issue > issues ) { list < host > hosts = get aerospike hosts ( issues , connection string , groups . aerospike . get label ( ) , str , context ) ; client policy cp = new client policy ( ) ; try { client = new aerospike client ( cp , hosts . to array ( new host [ hosts . size ( ) ] ) ) ; int retries = num ; while ( ! client . is connected ( ) && retries <= max retries ) { if ( retries > max retries ) { issues . add ( context . create config issue ( groups . aerospike . get label ( ) , str , aerospike errors . aerospike 03 , connection string ) ) ; return ; } retries ++ ; try { thread . sleep ( num ) ; } catch ( interrupted exception ignored ) { } } } catch ( aerospike exception ex ) { issues . add ( context . create config issue ( groups . aerospike . get label ( ) , str , aerospike errors . aerospike 03 , connection string ) ) ; } }	initialize and validate configuration options.
string get topic ( record record ) throws stage exception { string result = publisher conf . topic ; if ( publisher conf . runtime topic resolution ) { el . set record in context ( topic vars , record ) ; try { result = topic eval . eval ( topic vars , publisher conf . topic expression , string . class ) ; if ( is empty ( result ) ) { throw new stage exception ( errors . mqtt 08 , publisher conf . topic expression , record . get header ( ) . get source id ( ) ) ; } if ( ! allowed topics . contains ( result ) && ! allow all topics ) { throw new stage exception ( errors . mqtt 09 , result , record . get header ( ) . get source id ( ) ) ; } } catch ( el e ) { throw new stage exception ( errors . mqtt 10 , publisher conf . topic expression , record . get header ( ) . get source id ( ) , e . to string ( ) ) ; } } return result ; }	Returns the topic given the record.Returns the configured topic or statically evaluated topic in case runtime resolution is not required.If runtime resolution is required then the following is done:1.
public input stream get input stream ( ) throws io { acquire lock ( ) ; try { is closed = bool ; for write = bool ; log . trace ( str , file ) ; verify and recover ( ) ; input stream is = new proxy input stream ( new file input stream ( file . to file ( ) ) ) { @ override public void close ( ) throws io { if ( is closed ) { return ; } try { super . close ( ) ; } finally { release ( ) ; is closed = bool ; stream = null ; } log . trace ( str , file ) ; } } ; stream = is ; return is ; } catch ( exception ex ) { release ( ) ; throw ex ; } }	Returns an input stream for the requested file.After completing the read the stream must be closed.
public output stream get output stream ( ) throws io { acquire lock ( ) ; try { is closed = bool ; for write = bool ; log . trace ( str , file ) ; verify and recover ( ) ; if ( files . exists ( file ) ) { files . move ( file , file old ) ; log . trace ( str , file , file old ) ; } output stream os = new proxy output stream ( new file output stream ( file tmp . to file ( ) ) ) { @ override public void close ( ) throws io { if ( is closed ) { return ; } try { super . close ( ) ; } finally { is closed = bool ; stream = null ; } log . trace ( str , file ) ; } } ; stream = os ; return os ; } catch ( exception ex ) { release ( ) ; throw ex ; } }	Returns an output stream for the requested file.After completing the write the contents must be committed using the {.
public boolean exists ( ) throws io { acquire lock ( ) ; try { verify and recover ( ) ; return files . exists ( file ) && files . size ( file ) > num ; } finally { release ( ) ; } }	Check if the DataStore exists and contains data.This method will check for the presence of the set of files that can be used to read data from the store.
public static fs permission parse fs permission ( string permissions ) throws illegal argument exception { try {	Parse String representation of permissions into HDFS FsPermission class.This method accepts the following formats:* Octal like '777' or '770'* HDFS style changes like 'a-rwx'* Unix style write up with 9 characters like 'rwxrwx---'.
private void validate all services available ( ) {	Validate service dependencies.Any error is considered fatal and RuntimeException() will be thrown that will terminate the SDC start up procedure.
@ suppress warnings ( str ) public < a extends simple aggregator > a create simple ( string name , class < ? extends aggregator > klass ) { utils . check state ( ! started , str ) ; try { a aggregator = ( a ) constructors . get ( klass ) . new instance ( name ) ; data provider . add aggregator ( aggregator ) ; aggregator . set data provider ( data provider ) ; return aggregator ; } catch ( exception ex ) { throw new runtime exception ( ex ) ; } }	Creates a simple Aggregator.
< a extends simple aggregator , t > class < ? extends number > get aggregator unit ( class < a > klass ) { try { a aggregator = ( a ) constructors . get ( klass ) . new instance ( str ) ; return aggregator . get value type ( ) ; } catch ( exception ex ) { throw new runtime exception ( ex ) ; } }	Returns the unit type of an aggregator value.
< a extends simple aggregator , t > aggregator data < a , t > create aggregator data ( class < a > klass , string name , long time window millis ) { try { a aggregator = ( a ) constructors . get ( klass ) . new instance ( name ) ; return aggregator . create aggregator data ( time window millis ) ; } catch ( exception ex ) { throw new runtime exception ( ex ) ; } }	Creates an AggregatorData.
@ suppress warnings ( str ) public < a extends simple aggregator , n extends number > group by aggregator < a , n > create group by ( string name , class < ? extends aggregator > a klass ) { utils . check state ( ! started , str ) ; group by aggregator < a , n > aggregator = new group by aggregator ( name , a klass , this ) ; data provider . add aggregator ( aggregator ) ; aggregator . set data provider ( data provider ) ; return aggregator ; }	Creates a group-by Agregator.
public void start ( long new data window end time millis ) { utils . check state ( ! started , str ) ; utils . check state ( ! stopped , str ) ; data provider . start ( new data window end time millis ) ; started = bool ; }	Starts the Aggregators instance.
public map < aggregator , aggregator data > stop ( ) { utils . check state ( started , str ) ; utils . check state ( ! stopped , str ) ; map < aggregator , aggregator data > aggregator data map = data provider . stop ( ) ; stopped = bool ; return aggregator data map ; }	Stops the Aggregators instance.
public map < aggregator , aggregator data > roll ( long new data window end time millis ) { utils . check state ( started , str ) ; utils . check state ( ! stopped , str ) ; return data provider . roll ( new data window end time millis ) ; }	Atomically rolls the DataWindow of all aggregators associated with the Aggregators instance.
public void release ( ) { synchronized ( login manager . class ) { if ( ref count == num ) throw new illegal state exception ( str ) ; else if ( ref count == num ) { cached instances . remove ( login type ) ; login . shutdown ( ) ; } -- ref count ; } }	Decrease the reference count for this instance and release resources if it reaches 0.
private static string glob to regex ( string glob ) { if ( glob . char at ( num ) == str || glob . contains ( str ) || glob . contains ( str ) ) { throw new illegal argument exception ( str ) ; }	Convert a limited file glob into a simple regex.
static list < s3 object summary > list objects lexicographically ( amazon s3 s3 client , s3 config bean s3 config bean , ant path matcher path matcher , s3 offset s3 offset , int fetch size ) {	Lists objects from AmazonS3 in lexicographical order.
public void stop ( ) throws pipeline exception { this . stop = bool ; if ( batches to capture > num ) { cancel snapshot ( this . snapshot name ) ; snapshot store . delete snapshot ( pipeline name , revision , snapshot name ) ; } }	Stops execution of the pipeline after the current batch completes.
public int produce empty batches for idle runners ( long idle time ) throws pipeline exception , stage exception { log . debug ( str ) ;	This method should be called periodically from a scheduler if the pipeline should not allow runners to be "idle"for more then idleTime.
private void create failure batch ( full pipe batch pipe batch ) { if ( ! pipeline config bean . should create failure snapshot ) { return ; } try { for ( snapshot info info : snapshot store . get summary for pipeline ( pipeline name , revision ) ) {	Create special batch by salvaging memory structures when pipelines gets into un-recoverable error.
@ suppress warnings ( str ) private bound statement record to bound statement ( record record ) throws stage exception { immutable list . builder < object > values = new immutable list . builder < > ( ) ; sorted set < string > columns present = sets . new tree set ( column mappings . key set ( ) ) ; for ( map . entry < string , string > mapping : column mappings . entry set ( ) ) { string column name = mapping . get key ( ) ; string field path = mapping . get value ( ) ;	Convert a Record into a fully-bound statement.
public void set ( map < string , string > new configuration ) { for ( map . entry < string , string > entry : new configuration . entry set ( ) ) { if ( entry . get value ( ) == null ) { this . unset ( entry . get key ( ) ) ; } else { this . set ( entry . get key ( ) , entry . get value ( ) ) ; } } }	Set multiple configs at once.If a value of given config is 'null', then this config key will be un-set.
private kudu lookup key generate lookup key ( final record record , final string table name ) throws on record error exception { map < string , field > key list = new hash map < > ( ) ; for ( map . entry < string , string > key : column to field . entry set ( ) ) { string field name = key . get value ( ) ; if ( ! record . has ( field name ) ) { throw new on record error exception ( record , errors . kudu 32 , field name ) ; } key list . put ( key . get key ( ) , record . get ( field name ) ) ; } return new kudu lookup key ( table name , key list ) ; }	Create a map of keyColumn - value to lookup in cache.
int read line ( string builder sb ) throws io { int c = reader . read ( ) ; int count = ( c == - num ) ? - num : num ; while ( c > - num && ! is over max object len ( count ) && ! check eol and adjust ( c ) ) { count ++ ; sb . append ( ( char ) c ) ; c = reader . read ( ) ; } if ( is over max object len ( count ) ) { sb . set length ( sb . length ( ) - num ) ; while ( c > - num && c != str && c != str ) { count ++ ; c = reader . read ( ) ; } check eol and adjust ( c ) ; } return count ; }	returns the reader line length, the StringBuilder has up to maxObjectLen chars.
public usage timer roll ( ) { int multiplier ; synchronized ( this ) { multiplier = get multiplier ( ) ; change multiplier ( - multiplier ) ;	returns fresh UsageTimer just reset to zero accumulated time.
public static void enable dpm ( dpm dpm info , context context ) throws io { utils . check not null ( dpm info , str ) ; string dpm base url = normalize dpm base url ( dpm info . get base url ( ) ) ;	Enable Control Hub on this Data Collector.
public static void disable dpm ( string username , string password , string organization id , context context ) throws io { string dpm base url = normalize dpm base url ( context . configuration . get ( sso . dpm base url config , str ) ) ; string user token = retrieve user token ( dpm base url , username , password ) ; try { disable dpm ( user token , organization id , context ) ; } finally { logout ( dpm base url , user token ) ; } }	Disable Control Hub on this Data Collector - with explicit login.
private static string normalize dpm base url ( string url ) { if ( url . ends with ( str ) ) { url = url . substring ( num , url . length ( ) - num ) ; } return url ; }	Normalize Control Hub URL - primarily drop training slash.
private static string retrieve user token ( string url , string username , string password ) { response response = null ; try { map < string , string > login json = new hash map < > ( ) ; login json . put ( str , username ) ; login json . put ( str , password ) ; response = client builder . new client ( ) . target ( url + str ) . register ( new csrf protection filter ( str ) ) . request ( ) . post ( entity . json ( login json ) ) ; if ( response . get status ( ) != response . status . ok . get status code ( ) ) { throw new runtime exception ( utils . format ( str , response . get status ( ) , response . read entity ( string . class ) ) ) ; } } finally { if ( response != null ) { response . close ( ) ; } } return response . get header string ( sso . x user auth token ) ; }	Login user and retrieve authentication token.
private static void logout ( string dpm base url , string user auth token ) { response response = null ; try { response = client builder . new client ( ) . target ( dpm base url + str ) . register ( new csrf protection filter ( str ) ) . request ( ) . header ( sso . x user auth token , user auth token ) . cookie ( sso . authentication cookie prefix + str , user auth token ) . get ( ) ; } finally { if ( response != null ) { response . close ( ) ; } } }	Logout given token.
private static void update token file ( context context , string app auth token ) throws io { file token file = context . token file path == null ? new file ( context . runtime info . get config dir ( ) , app token file ) : new file ( context . token file path ) ; data store data store = new data store ( token file ) ; try ( output stream os = data store . get output stream ( ) ) { io . write ( app auth token , os ) ; data store . commit ( os ) ; } finally { data store . release ( ) ; } }	Update token file with the SDC access token.
private static void update dpm properties ( context context , string dpm base url , list < string > labels , boolean enable sch ) { if ( context . skip updating dpm properties ) { return ; } try { file based configuration builder < properties configuration > builder = new file based configuration builder < > ( properties configuration . class ) . configure ( new parameters ( ) . properties ( ) . set file name ( context . runtime info . get config dir ( ) + str ) . set throw exception on missing ( bool ) . set list delimiter handler ( new default list delimiter handler ( str ) ) . set includes allowed ( bool ) ) ; properties configuration config = null ; config = builder . get configuration ( ) ; config . set property ( sso . dpm enabled , boolean . to string ( enable sch ) ) ; config . set property ( sso . dpm base url config , dpm base url ) ; config . set property ( sso . security service app auth token config , app token file prop val ) ; if ( labels != null && labels . size ( ) > num ) { config . set property ( remote event handler task . remote job labels , string utils . join ( labels , str ) ) ; } else { config . set property ( remote event handler task . remote job labels , str ) ; } builder . save ( ) ; } catch ( configuration exception e ) { throw new runtime exception ( utils . format ( str , e . get message ( ) ) , e ) ; } }	Update dpm.properties file with new configuration.
private schema . field schema field for type ( string field path , record record , string field name , field field ) throws on record error exception { schema simple schema = simple schema for type ( field path , record , field ) ; schema final schema = simple schema ;	Generate schema for given field and optionally wrap it in union with null if configured.
private schema complex schema for type ( string field path , record record , field field ) throws on record error exception { schema simple schema = simple schema for type ( field path , record , field ) ; schema final schema = simple schema ; if ( get config ( ) . avro nullable fields ) { final schema = schema . create union ( immutable list . of ( schema . create ( schema . type . null ) , simple schema ) ) ; } json node default value = get default value ( simple schema ) ; if ( default value != null ) { final schema . add prop ( str , default value ) ; } return final schema ; }	Generates complex schema for given field that will include optional union with null and potentially default valueas well.
private int get decimal scale or precision ( record record , field field , string attribute name , int default value , int min allowed ) throws on record error exception { int final value = - num ;	Resolve parameters of decimal type.
private json node get default value ( schema schema ) { if ( get config ( ) . avro nullable fields && get config ( ) . avro default nullable ) { return null node . get instance ( ) ; } if ( ! get config ( ) . avro nullable fields && default values for types . contains key ( schema . get type ( ) ) ) { return default values for types . get ( schema . get type ( ) ) ; } return null ; }	Returns default value for given field or null if no default value should be used.
@ suppress warnings ( str ) public static synchronized void init metrics if needed ( proto configurable entity . context context ) { gauge < map < string , object > > gauge = context . get gauge ( file statistic gauge name ( context ) ) ; if ( gauge == null ) { gauge = context . create gauge ( file statistic gauge name ( context ) , comparator . comparing ( gauge map ordering :: get ) ) ; map < string , object > gauge statistics = gauge . get value ( ) ;	Creates a gauge if it is already not. This is done only once for the stage.
public int compare ( wrapped file path1 , wrapped file path2 , boolean use last modified ) {	This method is a simple wrapper that lets us find the NoSuchFileException if that was the cause.
public int index of ( string group name , int index ) { int idx = - num ; if ( group info . contains key ( group name ) ) { list < group info > list = group info . get ( group name ) ; idx = list . get ( index ) . group index ( ) ; } return idx ; }	Gets the group index of a named capture group at thespecified index.
public list < string > group names ( ) { if ( group names == null ) { group names = new array list < string > ( group info . key set ( ) ) ; } return group names ; }	Gets the names of all capture groups.
static private boolean is escaped char ( string s , int pos ) { return is slash escaped char ( s , pos ) || is quote escaped char ( s , pos ) ; }	Determines if the character at the specified positionof a string is escaped.
static private boolean is slash escaped char ( string s , int pos ) {	Determines if the character at the specified positionof a string is escaped with a backslash.
static private boolean is inside char class ( string s , int pos ) { boolean open bracket found = bool ; boolean close bracket found = bool ;	Determines if a string's character is within a regex character class.
static private int count open parens ( string s , int pos ) { java . util . regex . pattern p = java . util . regex . pattern . compile ( str ) ; java . util . regex . matcher m = p . matcher ( s . sub sequence ( num , pos ) ) ; int num parens = num ; while ( m . find ( ) ) {	Counts the open-parentheses to the left of a string position,excluding escaped parentheses.
static public map < string , list < group info > > extract group info ( string named pattern ) { map < string , list < group info > > group info = new linked hash map < string , list < group info > > ( ) ; java . util . regex . matcher matcher = named group pattern . matcher ( named pattern ) ; while ( matcher . find ( ) ) { int pos = matcher . start ( ) ;	Parses info on named capture groups from a pattern.
static private string builder replace ( string builder input , java . util . regex . pattern pattern , string replacement ) { java . util . regex . matcher m = pattern . matcher ( input ) ; while ( m . find ( ) ) { if ( is escaped char ( input . to string ( ) , m . start ( ) ) ) { continue ; }	Replaces strings matching a pattern with another string.
@ override public void do get ( http servlet request request , http servlet response response ) { try { json generator jg = null ; string jsonpcb = null ; print writer writer = null ; try { writer = response . get writer ( ) ;	Process a GET request for the specified resource.
private boolean refresh schema ( big decimal scn decimal , schema and table schema and table ) throws sql { try { if ( ! table schema last update . contains key ( schema and table ) || scn decimal . compare to ( table schema last update . get ( schema and table ) ) > num ) { if ( containerized ) { try ( statement switch to pdb = connection . create statement ( ) ) { switch to pdb . execute ( str + config bean . pdb ) ; } } table schemas . put ( schema and table , get table schema ( schema and table ) ) ; table schema last update . put ( schema and table , scn decimal ) ; return bool ; } return bool ; } finally { alter session ( ) ; } }	Refresh the schema for the table if the last update of this table was before the given SCN.Returns true if it was updated, else returns false.
private boolean expired ( map . entry < transaction id key , hash queue < record sequence > > entry , local date time start time ) { return start time != null &&	An element is "expired" if the transaction started before the current window being processedand if no records have actually been sent to the pipeline.
@ override public long get offset ( ) { utils . check state ( open , utils . format l ( str , current file ) ) ; return ( truncate mode ) ? - offset : offset ; }	offset will be negative if we are in truncate mode.
private boolean fast forward ( ) throws io { try { boolean still truncate ; buffer . clear ( ) ; if ( channel . read ( buffer ) > - num || is eof ( ) ) {	returns true if still in truncate mode, false otherwise.
private static object convert string to appropriate number ( string value ) { if ( value . contains ( str ) ) { return double . value of ( value ) ; } else { return long . value of ( value ) ; } }	We need to support Strings as some information that user might need to deal with is inherently stored in Stringvariables - for example header values or CSV files.The way we're processing strings is - if it contains dot, then it's assumed to be a double otherwise long.
private int parse part ( int start offset , byte buf buf , map < string , field > fields ) throws on record error exception { int offset = start offset ; int type = buf . get unsigned short ( offset ) ;	Parses a collectd packet "part".
private int parse values ( int start offset , byte buf buf ) throws on record error exception { int offset = start offset ;	Parses the value part of the packet where metrics are located.
void lookup primary keys ( ) throws stage exception { connection connection = null ; try { connection = data source . get connection ( ) ; primary key columns = jdbc util . get primary keys ( connection , schema , table name ) ; } catch ( sql e ) { string formatted error = jdbc util . format sql exception ( e ) ; log . error ( formatted error , e ) ; throw new stage exception ( jdbc errors . jdbc 17 , table name , formatted error ) ; } finally { if ( connection != null ) { try { connection . close ( ) ; } catch ( sql e ) { string formatted error = jdbc util . format sql exception ( e ) ; log . error ( formatted error , e ) ; } } } }	Access the database, obtain a list of primary key columns, and store them in primaryKeyColumns.If table has no primary keys, primaryKeyColumns stays empty.
private void create custom field mappings ( ) { for ( jdbc field column param mapping mapping : custom mappings ) { log . debug ( str , mapping . field , mapping . column name ) ; if ( columns to fields . contains key ( mapping . column name ) ) { log . debug ( str , mapping . field , mapping . column name ) ; columns to fields . put ( mapping . column name , mapping . field ) ; columns to parameters . put ( mapping . column name , mapping . param value ) ; } } }	Use "Field to Column Mapping" option obtained from configuration and updatecolumnsToFields and columnsToParameters.
static string get sql ( field . type type ) throws on record error exception { switch ( type ) { case boolean : return str ; case char : return str ; case byte : return str ; case short : return str ; case integer : return str ; case long : return str ; case float : return str ; case double : return str ; case date : return str ; case time : return str ; case datetime : return str ; case decimal : return str ; case string : return str ; case byte array : return str ; case list map : case map : throw new on record error exception ( jdbc errors . jdbc 05 , str ) ; case list : return str ; default : throw new on record error exception ( jdbc errors . jdbc 05 , str + type . name ( ) ) ; } }	spec requires a string name for a data type, rather than just an enum.
protected string get table name ( ) { if ( ! strings . is null or empty ( schema ) ) { if ( case sensitive ) { return str + schema + str + str + table name + str ; } else { return schema + str + table name ; } } if ( case sensitive ) { return str + table name + str ; } return table name ; }	Table this writer will write to.
int set primary keys ( int index , final record record , prepared statement statement , int op code ) throws on record error exception { for ( string key : get primary key columns ( ) ) { field field = record . get ( record reader . get field path ( key , get columns to fields ( ) , op code ) ) ; if ( field == null ) { log . error ( str , key ) ; throw new on record error exception ( record , jdbc errors . jdbc 19 , key ) ; } object value = field . get value ( ) ; try { statement . set object ( index , value , get column type ( key ) ) ; } catch ( sql ex ) { log . error ( str , ex . get message ( ) ) ; throw new on record error exception ( record , jdbc errors . jdbc 19 , key , ex ) ; } ++ index ; } return index ; }	Set primary key values to query.
void handle sql exception ( sql e ) throws stage exception { string formatted error = jdbc util . format sql exception ( e ) ; log . error ( formatted error , e ) ; throw new stage exception ( jdbc errors . jdbc 14 , e . get sql ( ) , e . get error code ( ) , e . get message ( ) , formatted error , e ) ; }	This is an error that is not due to bad input record and should throw a StageExceptiononce we format the error.
public void process ( map < string , string > offsets , int batch size , report error delegate report error delegate ) throws stage exception , pipeline runtime exception { this . report error delegate = report error delegate ; get stage ( ) . set report error delegate ( this ) ; try { mdc . put ( log constants . stage , get stage ( ) . get info ( ) . get instance name ( ) ) ; get stage ( ) . execute ( offsets , batch size ) ; } finally { mdc . put ( log constants . stage , str ) ; } }	Process method for Push source that will give control of the execution to the origin.
public void prepare batch context ( batch context impl batch context ) { pipe batch pipe batch = batch context . get pipe batch ( ) ;	Called by PipelineRunner when push origin started a new batch to prepare context for it.
public map < string , object > finish batch context ( batch context impl batch context ) throws stage exception { return finish batch and calculate metrics ( batch context . get start time ( ) , batch context . get pipe batch ( ) , ( batch maker impl ) batch context . get batch maker ( ) , batch context . get pipe batch ( ) . get batch ( this ) , batch context . get pipe batch ( ) . get error sink ( ) , batch context . get pipe batch ( ) . get event sink ( ) , null ) ; }	Finish batch from the origin's perspective.
private map < string , field > flatten entire record ( field root field ) { map < string , field > ret = new linked hash map < > ( ) ; switch ( root field . get type ( ) ) { case map : case list map : flatten map ( str , root field . get value as map ( ) , ret ) ; break ; case list : flatten list ( str , root field . get value as list ( ) , ret ) ; break ; default : break ; } return ret ; }	Flatten the entire record to one giant map.
public static < t > detached stage runtime < ? extends t > create ( stage bean bean , stage . info info , stage . context context , class < t > klass ) { switch ( bean . get definition ( ) . get type ( ) ) { case processor : return new detached stage runtime . detached processor ( bean , info , context ) ; case target : case executor : return new detached stage runtime . detached target ( bean , info , context ) ; default : throw new runtime exception ( str + bean . get definition ( ) . get type ( ) ) ; } }	Create new instance of detached stage runtime.
private void execute ( record record ) throws on record error exception {	Executes an action for given record.
@ override public sorted map < string , string > get columns to parameters ( final record record , int op , map < string , string > parameters , map < string , string > columns to fields ) { sorted map < string , string > columns to parameters = new tree map < > ( ) ; for ( map . entry < string , string > entry : columns to fields . entry set ( ) ) { string column name = entry . get key ( ) ; string field path = entry . get value ( ) ; if ( op == operation type . delete code ) { field path = field path . replace ( data field , old data field ) ; } if ( record . has ( field path ) ) { columns to parameters . put ( column name , parameters . get ( column name ) ) ; } } return columns to parameters ; }	Records from MySQL BinLog origin have a bit unique structure.Records for Insert and update operations have a field path "/Data", which is a mapof all column names as key and values stored in DB as value.Record for Delete operation don't have /Data field.
private static string get condition for partition column ( string partition column , offset comparison comparison , list < string > preconditions , string quote char ) { string condition template = comparison . get query condition ( ) ; list < string > final conditions = new array list < > ( preconditions ) ; final conditions . add ( string . format ( condition template , string . format ( quoted name , quote char , partition column , quote char ) , prepared statement positional parameter ) ) ; return and joiner . join ( final conditions ) ; }	Builds parts of the query in the where clause for the the partitition column.
public static map < string , string > validate stored and specified offset ( table context table context , string offset ) throws stage exception { set < string > expected columns = sets . new hash set ( table context . get offset columns ( ) ) ; final map < string , string > actual offsets = get columns to offset map from offset format ( offset ) ;	Validates whether offset names match in the stored offset with respect to table configuration.
private list < bundle content generator definition > get requested definitions ( list < string > generators ) { stream < bundle content generator definition > stream = definitions . stream ( ) ; if ( generators == null || generators . is empty ( ) ) {	Orchestrate what definitions should be used for this bundle.Either get all definitions that should be used by default or only those specified in the generators argument.
private string [ ] get non empty args ( list < string > app args ) { list < string > non empty = new array list < > ( ) ; app args . for each ( ( string val ) -> { if ( ! string utils . is empty ( val ) ) { non empty . add ( val ) ; } } ) ; return non empty . to array ( new string [ non empty . size ( ) ] ) ; }	If there is a RecordEL, then an arg could eval to empty string.
protected operation get operation ( kudu table table , int op ) throws unsupported operation exception { operation operation = null ; switch ( op ) { case operation type . insert code : operation = table . new insert ( ) ; break ; case operation type . upsert code : operation = table . new upsert ( ) ; break ; case operation type . update code : operation = table . new update ( ) ; break ; case operation type . delete code : operation = table . new delete ( ) ; break ; default : log . error ( str , op ) ; throw new unsupported operation exception ( string . format ( str , op ) ) ; } return operation ; }	Return Operation based on the operation code.
static string convert bytes to display format ( double bytes ) { int unit idx = num ; double unit changed bytes = bytes ; while ( unit idx < units . length - num && math . floor ( unit changed bytes / num ) > num ) { unit changed bytes = unit changed bytes / num ; unit idx ++ ; } return df . format ( unit changed bytes ) + str + units [ unit idx ] ; }	Convert the bytes to a human readable format upto 2 decimal placesThe maximum unit is TB, so anything exceeding 1024 TB will be shownwith TB unit.
public live file scan ( live file current ) throws io { try { return scan internal ( current ) ; } catch ( no such file exception ex ) {	Scans the directory of for the next file.
public long get pending files ( live file current ) throws io {	Scans the directory for number of files yet to be processed.
public static boolean is whitelisted ( string name , properties specific whitelist , map < string , list < dependency > > dependencies ) { if ( specific whitelist != null && specific whitelist . contains key ( name ) ) { return versions match ( specific whitelist . get property ( name ) , dependencies . key set ( ) ) ; }	Return true if this dependency and given set of versions is whitelisted.This class have several rules for whitelisting - some of them are harcoded (known whitelist for all libraries),whereas the optional Properties argument allows specific exceptions for this particular classpath.
private static boolean versions match ( string expected versions , set < string > versions ) { set < string > expected set = sets . new hash set ( expected versions . split ( str ) ) ; return sets . symmetric difference ( expected set , versions ) . is empty ( ) ; }	Compare expected versions with given versions to see if they are the same or not.
public static void main ( string [ ] args ) throws exception { spark streaming binding binding = null ; try { binding = spark streaming binding factory . build ( bootstrap cluster . get properties ( ) ) ; binding . init ( ) ; bootstrap cluster . create transformers ( binding . get streaming context ( ) . spark context ( ) , binding . get spark session ( ) ) ; binding . start context ( ) ; binding . await termination ( ) ; } catch ( throwable error ) { string msg = str + error ; system . err . println ( new date ( ) + str + msg ) ; error . print stack trace ( system . err ) ;	Bootstrapping the Driver which starts a Spark job on cluster.
private void propagate runtime configuration ( ) {	We have special type of a ConfigDef called RUNTIME.
private void validate report description ( list < config issue > issues ) { if ( ! json mapper . is valid json ( this . report description ) ) { issues . add ( get context ( ) . create config issue ( groups . report . name ( ) , str , errors . omniture 03 ) ) ; } }	Validate Ominture Report Description.
private void upgrade v1to v2 ( list < config > configs ) { configs . remove if ( config -> ( config . get name ( ) . equals ( implicit field mapping config ) || config . get name ( ) . equals ( big query implicit field mapping config ) ) ) ; configs . add ( new config ( max cache size , - num ) ) ; }	Remove implicit field mapping.
public map < string , string > extract named groups ( final char sequence raw data ) { matcher matcher = compiled pattern . matcher ( raw data ) ; if ( matcher . find ( ) ) { match result r = matcher . to match result ( ) ; if ( r != null && r . named groups ( ) != null ) { return r . named groups ( ) ; } } return null ; }	Extracts named groups from the raw data.
public void consumer commit ( string offset ) { object offset value = offset ; if ( offset value == null ) { offset value = new null offset ( ) ; } log . trace ( str , offset value ) ; try { producer queue . put ( new message ( message type . consumer commit , offset value ) ) ; } catch ( interrupted exception e ) { log . info ( str , message type . consumer commit . name ( ) , offset value ) ; thread . current thread ( ) . interrupt ( ) ; } }	If a null value is passed to this method, it's replaced witha dummy due to the fact the payload for each message is wrappedin an Optional.
@ suppress warnings ( str ) protected sdc create ( ) throws exception { utils . check state ( open , str ) ; final sdc embedded sdc = new sdc ( ) ; object source ;	Creates an instance of SDC and adds to pool.
private void set fields in record ( record record , map < string , field > fields ) { record . set ( config bean . result field , field . create list map ( new linked hash map < > ( fields ) ) ) ; }	Set the lookup reuslt in the result field.
@ override public list < pipeline and validation status > get remote pipelines with changes ( ) throws pipeline exception { list < pipeline and validation status > pipeline and validation statuses = new array list < > ( ) ; for ( pair < pipeline state , map < string , string > > pipeline state and offset : state event listener . get pipeline state events ( ) ) { pipeline state pipeline state = pipeline state and offset . get left ( ) ; map < string , string > offset = pipeline state and offset . get right ( ) ; string name = pipeline state . get pipeline id ( ) ; string rev = pipeline state . get rev ( ) ; boolean is cluster mode = ( pipeline state . get execution mode ( ) != execution mode . standalone ) ? bool : bool ; list < worker info > worker infos = new array list < > ( ) ; string title ; int runner count = num ; if ( pipeline store . has pipeline ( name ) ) { title = pipeline store . get info ( name ) . get title ( ) ; runner runner = manager . get runner ( name , rev ) ; if ( is cluster mode ) { worker infos = get workers ( runner . get slave callback list ( callback object type . metrics ) ) ; } runner count = runner . get runner count ( ) ; } else { title = null ; } pipeline and validation statuses . add ( new pipeline and validation status ( get sch generated pipeline name ( name , rev ) , title , rev , pipeline state . get time stamp ( ) , bool , pipeline state . get status ( ) , pipeline state . get message ( ) , worker infos , is cluster mode , get source offset ( name , offset ) , null , runner count ) ) ; } return pipeline and validation statuses ; }	Returns info about remote pipelines that have changed since the last sending of events.
public static remote data collector result future ack ( future < ack event > future result ) { return new remote data collector result ( future result , null , bool , null ) ; }	Creates a future ack result from the given parameter.
public static gauge < map < string , object > > create gauge ( metric registry metrics , string name , gauge gauge , final string pipeline name , final string pipeline rev ) { return create ( metrics , gauge , metric name ( name , gauge suffix ) , pipeline name , pipeline rev ) ; }	Kept for backward compatibility with runtime stats, to be removed in future.
@ override public sorted map < string , string > get columns to parameters ( final record record , int op , map < string , string > parameters , map < string , string > columns to fields ) { sorted map < string , string > columns to parameters = new tree map < > ( ) ; for ( map . entry < string , string > entry : columns to fields . entry set ( ) ) { string column name = entry . get key ( ) ; string field path = get field path ( column name , columns to fields , op ) ; if ( record . has ( field path ) ) { columns to parameters . put ( column name , parameters . get ( column name ) ) ; } else { log . trace ( str , column name , op ) ; } } return columns to parameters ; }	Records from MongoDB Oplog origin have a bit unique structure.Records for Insert have all data in the field "o", which is a map and contains all data for columnsRecords for Delete have objectId in the field "o", which is a map and contains only objectId.Records for Update have a field "o2", which is a map and contains only objectId,and a field "o" where it stores data for updating columns and values.
private map < string , object > generate header attrs ( path file ) throws stage exception { try { map < string , object > record header attr = new hash map < > ( ) ; record header attr . put ( header attribute constants . file , file . to absolute path ( ) ) ; record header attr . put ( header attribute constants . file name , file . get file name ( ) ) ; record header attr . put ( header attribute constants . size , files . size ( file ) ) ; record header attr . put ( header attribute constants . last modified time , files . get last modified time ( file ) ) ; return record header attr ; } catch ( io e ) { throw new transformer stage checked exception ( errors . convert 09 , e . to string ( ) , e ) ; } }	Generate the Header attributes.
private void validate record ( record record ) throws stage exception { try { file ref util . validate whole file record ( record ) ; } catch ( illegal argument exception e ) { throw new transformer stage checked exception ( errors . convert 01 , e . to string ( ) , e ) ; } }	Validate the record is a whole file record.
private void handle old temp files ( path temp parquet file ) throws io { if ( temp parquet file == null ) { log . warn ( str ) ; return ; } files . delete if exists ( temp parquet file ) ; }	Delete temporary parquet file.
private input stream get avro input stream ( record record ) throws stage exception { try { file ref file ref = record . get ( file ref util . file ref field path ) . get value as file ref ( ) ;	Return the Avro file input stream.
private data file stream < generic record > get file reader ( input stream is , string source file name ) throws stage exception { try { datum reader < generic record > reader = new generic datum reader < > ( ) ; data file stream < generic record > file reader = new data file stream < > ( is , reader ) ; return file reader ; } catch ( io ex ) { throw new transformer stage checked exception ( errors . convert 11 , source file name , ex ) ; } }	Return the Avro file reader.
private void write parquet ( string source file name , data file stream < generic record > file reader , path temp parquet file ) throws stage exception { long record count = num ; generic record avro record ; schema schema = file reader . get schema ( ) ; log . debug ( str , source file name ) ; try {	Convert Avro record to Parquet.
public optional < field > check input encrypt ( record record , field field ) { if ( unsupported types . contains ( field . get type ( ) ) ) { get context ( ) . to error ( record , crypto 03 , field . get type ( ) ) ; return optional . empty ( ) ; } return optional . of ( field ) ; }	Checks that the encryption input is a supported type, otherwise sends therecord to error.
public optional < field > check input encrypt ( field field ) throws stage exception { if ( unsupported types . contains ( field . get type ( ) ) ) { throw new stage exception ( crypto 03 , field . get type ( ) ) ; } return optional . of ( field ) ; }	Checks that the encryption input is a supported type, otherwise sends therecord to StageException.
public optional < field > check input decrypt ( record record , field field ) { if ( field . get type ( ) != field . type . byte array ) { get context ( ) . to error ( record , crypto 02 , field . get type ( ) ) ; return optional . empty ( ) ; } return optional . of ( field ) ; }	Checks that the decryption input is a valid type, otherwise sends therecord to error.
public optional < field > check input decrypt ( field field ) throws stage exception { if ( field . get type ( ) != field . type . byte array ) { throw new stage exception ( crypto 02 , field . get type ( ) ) ; } return optional . of ( field ) ; }	Checks that the decryption input is a valid type, otherwise sends therecord to StageException.
public byte [ ] prepare encrypt ( field field , map < string , string > context ) { context . put ( sdc field type , field . get type ( ) . name ( ) ) ; if ( field . get type ( ) == field . type . byte array ) { return field . get value as byte array ( ) ; } else {	Does data type conversions in preparation for encryption.
public matcher use pattern ( pattern new pattern ) { if ( new pattern == null ) { throw new illegal argument exception ( str ) ; } this . parent pattern = new pattern ; matcher . use pattern ( new pattern . pattern ( ) ) ; return this ; }	Changes the Pattern that this Matcher uses to find matches with.
public matcher append replacement ( string buffer sb , string replacement ) { matcher . append replacement ( sb , parent pattern . replace properties ( replacement ) ) ; return this ; }	Implements a non-terminal append-and-replace step.
@ override public map < string , string > named groups ( ) { map < string , string > result = new linked hash map < string , string > ( ) ; if ( matcher . find ( num ) ) { for ( string group name : parent pattern . group names ( ) ) { string group value = matcher . group ( group index ( group name ) ) ; result . put ( group name , group value ) ; } } return result ; }	Finds all named groups that exist in the input string.
public string replace all ( string replacement ) { string r = parent pattern . replace properties ( replacement ) ; return matcher . replace all ( r ) ; }	Replaces every subsequence of the input sequence that matches the patternwith the given replacement string.
public static string get global variable ( data source data source , string variable ) throws sql { try ( connection conn = data source . get connection ( ) ) { try ( statement stmt = conn . create statement ( ) ; result set rs = stmt . execute query ( string . format ( str , variable ) ) ; ) { if ( rs . next ( ) ) { return rs . get string ( num ) ; } else { return str ; } } } }	Get global variable value.
private record create start event ( ) { preconditions . check state ( start event stage != null , str ) ; event record event record = new event record impl ( str , num , start event stage . get info ( ) . get instance name ( ) , str , null , null ) ; map < string , field > root field = new linked hash map < > ( ) ; root field . put ( str , field . create ( field . type . string , user context . get user ( ) ) ) ; root field . put ( str , field . create ( field . type . string , name ) ) ; root field . put ( str , field . create ( field . type . string , pipeline conf . get title ( ) ) ) ;	Create pipeline start event.
private record create stop event ( pipeline stop reason stop reason ) { preconditions . check state ( stop event stage != null , str ) ; event record event record = new event record impl ( str , num , stop event stage . get info ( ) . get instance name ( ) , str , null , null ) ; map < string , field > root field = new linked hash map < > ( ) ; root field . put ( str , field . create ( field . type . string , stop reason . name ( ) ) ) ; root field . put ( str , field . create ( field . type . string , name ) ) ; root field . put ( str , field . create ( field . type . string , pipeline conf . get title ( ) ) ) ; event record . set ( field . create ( root field ) ) ; return event record ; }	Create pipeline stop event.
protected string fix offset ( string offset column , string offset ) { com . sforce . soap . partner . field sfdc field = get field metadata ( sobject type , offset column ) ; if ( sobject record creator . decimal types . contains ( sfdc field . get type ( ) . to string ( ) ) && offset . contains ( str ) ) { big decimal val = new big decimal ( offset ) ; offset = val . to plain string ( ) ; if ( val . compare to ( max offset int ) > num && ! offset . contains ( str ) ) {	since Salesforce doesn't like scientific notation in queries.
private object extract as runtime ( field field , string value str ) { if ( field . get type ( ) == byte . type || field . get type ( ) == byte . class || field . get type ( ) == short . type || field . get type ( ) == short . class || field . get type ( ) == integer . type || field . get type ( ) == integer . class || field . get type ( ) == long . type || field . get type ( ) == long . class || field . get type ( ) == float . type || field . get type ( ) == float . class || field . get type ( ) == double . type || field . get type ( ) == double . class ) { return extract as number ( field , value str ) ; } else if ( string . class . is assignable from ( field . get type ( ) ) ) { return value str ; } throw new illegal argument exception ( utils . format ( str , field . get type ( ) ) ) ; }	RUNTIME supports only Numeric types and String at the moment.
public void execute alter table add partition query ( string qualified table name , linked hash map < string , string > partition name value map , map < string , hive type info > partition type map , string partition path ) throws stage exception { string sql = build partition addition query ( qualified table name , partition name value map , partition type map , partition path ) ; execute ( sql ) ; }	Add a new partition to the given table, with optional custom location.
public void execute alter table set tbl properties query ( string qualified table name , string partition path ) throws stage exception { string sql = build set table properties query ( qualified table name , partition path ) ; execute ( sql ) ; }	Execute Alter Table set Table Properties.
public string execute describe database ( string db name ) throws stage exception { string sql = build describe database ( db name ) ; return execute query ( sql , rs -> { if ( ! rs . next ( ) ) { throw new hive stage checked exception ( errors . hive 35 , str ) ; } return hive metastore util . strip hdfs host and port ( rs . get string ( result set location ) ) ; } ) ; }	Returns location for given database.
private void execute ( string query ) throws stage exception { log . debug ( str , query ) ; timer . context t = update timer . time ( ) ; try ( statement statement = hive config bean . get hive connection ( ) . create statement ( ) ) { statement . execute ( query ) ; } catch ( exception e ) { log . error ( str , query , e ) ; throw new hive stage checked exception ( errors . hive 20 , query , e . get message ( ) ) ; } finally { long time = t . stop ( ) ; log . debug ( str , query , time ) ; update meter . mark ( ) ; } }	Execute given query.With all required side effects such as catching exceptions, updating metrics, ...
private < t > t execute query ( string query , with result set < t > execution ) throws stage exception { log . debug ( str , query ) ; timer . context t = select timer . time ( ) ; try ( statement statement = hive config bean . get hive connection ( ) . create statement ( ) ; result set rs = statement . execute query ( query ) ; ) {	Execute given query and process it's result set.With all required side effects such as catching exceptions, updating metrics, ...
public void execute batch ( string offset key , string offset value , long batch start time , throwing consumer < pipe > consumer ) throws pipeline runtime exception , stage exception { mdc . put ( log constants . runner , string . value of ( runner id ) ) ;	Run batch with given consumer for each pipe.This method will also set the logger appropriately and calculate the runner specific metrics.
public void for each ( throwing consumer < pipe > consumer ) { try { mdc . put ( log constants . runner , string . value of ( runner id ) ) ; try { for ( pipe p : pipes ) { mdc . put ( log constants . stage , p . get stage ( ) . get info ( ) . get instance name ( ) ) ; accept consumer ( consumer , p ) ; } } finally { mdc . put ( log constants . runner , str ) ; mdc . put ( log constants . stage , str ) ; } } catch ( pipeline exception | stage exception e ) { throw new runtime exception ( e ) ; } }	Execute given consumer for each pipe, rethrowing usual exceptions as RuntimeException.Suitable for consumer that is not suppose to throw PipelineException and StageException.
public offset commit trigger get offset commit trigger ( ) { for ( pipe pipe : pipes ) { stage stage = pipe . get stage ( ) . get stage ( ) ; if ( stage instanceof target && stage instanceof offset commit trigger ) { return ( offset commit trigger ) stage ; } } return null ; }	Retrieve OffsetCommitTrigger pipe.If it exists, null otherwise.
public boolean on record error stop pipeline ( ) { for ( pipe pipe : pipes ) { stage context stage context = pipe . get stage ( ) . get context ( ) ; if ( stage context . get on error record ( ) == on record error . stop pipeline ) { return bool ; } } return bool ; }	Return true if at least one stage is configured with STOP_PIPELINE for OnRecordError policy.
private void accept consumer ( throwing consumer < pipe > consumer , pipe p ) throws pipeline runtime exception , stage exception { try {	Accept given consumer and proper log context of any exception.
private string get insert id for record ( el el vars , record record ) throws on record error exception { string record id = null ; el . set record in context ( el vars , record ) ; try { if ( ! ( string utils . is empty ( conf . row id expression ) ) ) { record id = row id el . eval ( el vars , conf . row id expression , string . class ) ; if ( string utils . is empty ( record id ) ) { throw new on record error exception ( record , errors . bigquery 15 ) ; } } } catch ( el e ) { log . error ( str , e ) ; throw new on record error exception ( record , errors . bigquery 10 , e ) ; } return record id ; }	Evaluate and obtain the row id if the expression is present or return null.
private object get value from field ( string field path , field field ) { log . trace ( str , field path , field . get type ( ) ) ; switch ( field . get type ( ) ) { case list :	Convert the sdc Field to an object for row content.
private observable < record > set fragment in record ( record record , document fragment < lookup > frag ) { if ( frag . content ( num ) == null ) { log . debug ( str ) ; return handle error ( record , errors . couchbase 25 , bool ) ; } for ( subdoc mapping config subdoc mapping : config . subdoc mapping configs ) { object frag json = frag . content ( subdoc mapping . subdoc path ) ; if ( frag json == null ) { return handle error ( record , errors . couchbase 25 , bool ) ; } try { record . set ( subdoc mapping . sdc field , json to field ( frag json ) ) ; record . get header ( ) . set attribute ( config . cas header attribute , string . value of ( frag . cas ( ) ) ) ; } catch ( io e ) { try { record . set ( subdoc mapping . sdc field , json to field ( json object . from json ( frag json . to string ( ) ) . to map ( ) ) ) ; record . get header ( ) . set attribute ( config . cas header attribute , string . value of ( frag . cas ( ) ) ) ; } catch ( io ex ) { return handle error ( record , errors . couchbase 19 , ex , bool ) ; } } } return observable . just ( record ) ; }	Writes sub-document lookup values to the record.
private observable < record > set document in record ( record record , json document doc ) { if ( doc . content ( ) == null ) { log . debug ( str , doc . id ( ) ) ; return handle error ( record , errors . couchbase 26 , bool ) ; } try { record . set ( config . output field , json to field ( doc . content ( ) . to map ( ) ) ) ; record . get header ( ) . set attribute ( config . cas header attribute , string . value of ( doc . cas ( ) ) ) ; return observable . just ( record ) ; } catch ( io e ) { log . debug ( str , doc . id ( ) ) ; return handle error ( record , errors . couchbase 19 , e , bool ) ; } }	Writes full document lookup values to the record.
private observable < record > set n1 ql ( record record , async n1ql query row row ) { for ( ql n1ql mapping : config . n1ql mapping configs ) { if ( config . multiple value operation == multiple value type . first && record . get ( n1ql mapping . sdc field ) != null ) { log . debug ( str ) ; return observable . empty ( ) ; } object property = row . value ( ) . get ( n1ql mapping . property ) ; if ( property == null ) { log . debug ( str , n1ql mapping . property ) ; return handle error ( record , errors . couchbase 27 , bool ) ; } try { record . set ( n1ql mapping . sdc field , json to field ( property ) ) ; } catch ( io e ) { try { record . set ( n1ql mapping . sdc field , json to field ( json object . from json ( property . to string ( ) ) . to map ( ) ) ) ; } catch ( io ex ) { log . debug ( str ) ; return handle error ( record , errors . couchbase 19 , ex , bool ) ; } } } return observable . just ( record ) ; }	Writes N1QL query result rows to the record.
private void handle whole file data format ( s3 object summary s3 object summary , string record id ) throws stage exception { s3 object partial s3 object for metadata ;	as the record is just the metadata along with file ref.
public boolean incomplete transactions contain ( string gtid , long seq no ) { long s = incomplete transactions . get ( gtid ) ; return s != null && s >= seq no ; }	Check if given gtid + seqNo pair is contained in this incomplete transactions.
private static < t > t with class loader internal ( class loader class loader , exception supplier < t > supplier ) throws exception { class loader previous class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( class loader ) ; return supplier . get ( ) ; } finally { thread . current thread ( ) . set context class loader ( previous class loader ) ; } }	Internal version of the wrapping function that will simply propagate all exceptions up.
public synchronized void logout ( ) { if ( subject != null ) { log . debug ( str , security configuration . is kerberos enabled ( ) , subject . get principals ( ) ) ; if ( login context != null ) { try { login context . logout ( ) ; } catch ( login exception ex ) { log . warn ( str , ex . to string ( ) , ex ) ; } finally { login context = null ; } } subject = null ; } }	Logs out. If Keberos is enabled it logs out from the KDC, otherwise is a NOP.
private void set exceptions ( configuration configuration ) { this . exceptions . clear ( ) ; this . stage lib exceptions . clear ( ) ;	This method should be called only once and before any stages are loaded.
private string replace variables ( string path ) { return path . replace ( str , data dir ) . replace ( str , config dir ) . replace ( str , resources dir ) ; }	Replace variables to internal SDC directories so that users don't have to be entering FQDN.
private void ensure proper permissions ( string path ) { class loader cl = thread . current thread ( ) . get context class loader ( ) ;	Make sure that the active code have proper rights to access the file inside protected directory.
public static void main ( string [ ] args ) throws exception { emr binding binding = null ; try { binding = new emr binding ( args ) ; binding . init ( ) ; binding . await termination ( ) ;	Bootstrapping the Driver which starts a EMR job on cluster.
string get dir path ( date date , record record ) throws stage exception { if ( dir path template in header ) {	Returns directory path for given record and date.
path rename to final name ( file system fs , path temp path ) throws io , stage exception { return fs helper . rename and get path ( fs , temp path ) ; }	This method should be called every time we finish writing into a file and consider it "done".
public boolean should roll ( record writer writer , record record ) { if ( roll if header && record . get header ( ) . get attribute ( roll header name ) != null ) { log . debug ( str , writer . get path ( ) , roll header name , record . get header ( ) . get attribute ( roll header name ) , record . get header ( ) . get source id ( ) ) ; return bool ; } return bool ; }	Return true if this record should be written into a new file regardless whether we have a file for the recordcurrently opened or not.
private boolean match strings ( string pattern , string str , map < string , string > uri template variables ) { return get string matcher ( pattern ) . match strings ( str , uri template variables ) ; }	Test whether or not a string matches against a pattern.
public map < string , string > get offsets ( ) throws io { utils . check state ( open , str ) ; return file context provider . get offsets ( ) ; }	Returns the current file offsets.
private long get remaining wait time ( long start time , long max wait time millis ) { long remaining = max wait time millis - ( system . current time millis ( ) - start time ) ; return ( remaining > num ) ? remaining : num ; }	remaining time till timeout, return zero if already in timeout.
public map < string , long > get offsets lag ( map < string , string > offset map ) throws io { return file context provider . get offsets lag ( offset map ) ; }	Determines the offset lag for each active file being read.
public stage library delegate create ( stage library task stage lib , string stage library name , class exported interface ) { stage library delegate definitition def = stage lib . get stage library delegate definition ( stage library name , exported interface ) ; if ( def == null ) { return null ; } return create instance ( def ) ; }	Create new instance of the delegator from given stage library.
private stage library delegate create instance ( stage library delegate definitition def ) { stage library delegate instance = null ; class loader class loader = thread . current thread ( ) . get context class loader ( ) ; try { thread . current thread ( ) . set context class loader ( def . get class loader ( ) ) ; instance = def . get klass ( ) . new instance ( ) ; } catch ( instantiation exception | illegal access exception ex ) { log . error ( str + ex . to string ( ) , ex ) ; } finally { thread . current thread ( ) . set context class loader ( class loader ) ; } return instance ; }	Create actual instance of delegator.
public static object get metric value ( metric registry metrics , string metric id , metric type metric type , metric element metric element ) throws observer exception {	Get metric value for given rule evaluation.
private int find header end ( final byte [ ] buf , int rlen ) { int splitbyte = num ; while ( splitbyte + num < rlen ) {	Find byte index separating header from body.
public long get body size ( ) { if ( this . headers . contains key ( str ) ) { return long . parse long ( this . headers . get ( str ) ) ; } else if ( this . splitbyte < this . rlen ) { return this . rlen - this . splitbyte ; } return num ; }	Deduce body length in bytes.
private string save tmp file ( byte buffer b , int offset , int len , string filename hint ) { string path = str ; if ( len > num ) { file output stream file output stream = null ; try { i temp file = this . temp file manager . create temp file ( filename hint ) ; byte buffer src = b . duplicate ( ) ; file output stream = new file output stream ( temp file . get name ( ) ) ; file channel dest = file output stream . get channel ( ) ; src . position ( offset ) . limit ( offset + len ) ; dest . write ( src . slice ( ) ) ; path = temp file . get name ( ) ; } catch ( exception e ) {	Retrieves the content of a sent file and saves it to a temporary file.The full path to the saved file is returned.
public static ssl make ssl ( string key and trust store classpath path , char [ ] passphrase ) throws io { try { key store keystore = key store . get instance ( key store . get default type ( ) ) ; input stream keystore stream = httpd . class . get resource as stream ( key and trust store classpath path ) ; if ( keystore stream == null ) { throw new io ( str + key and trust store classpath path ) ; } keystore . load ( keystore stream , passphrase ) ; key manager factory key manager factory = key manager factory . get instance ( key manager factory . get default algorithm ( ) ) ; key manager factory . init ( keystore , passphrase ) ; return make ssl ( keystore , key manager factory ) ; } catch ( exception e ) { throw new io ( e . get message ( ) ) ; } }	Creates an SSLSocketFactory for HTTPS. Pass a KeyStore resource with yourcertificate and passphrase.
public static string get mime type for file ( string uri ) { int dot = uri . last index of ( str ) ; string mime = null ; if ( dot >= num ) { mime = mime types ( ) . get ( uri . substring ( dot + num ) . to lower case ( ) ) ; } return mime == null ? str : mime ; }	Get MIME type from file name extension, if possible.
public response handle ( ihttp session ) { for ( i < ihttp , response > interceptor : interceptors ) { response response = interceptor . handle ( session ) ; if ( response != null ) return response ; } return http handler . handle ( session ) ; }	This is the "master" method that delegates requests to handlers and makessure there is a response to every request.
public void stop ( ) { try { safe close ( this . my server socket ) ; this . async runner . close all ( ) ; if ( this . my thread != null ) { this . my thread . join ( ) ; } } catch ( exception e ) { httpd . log . log ( level . severe , str , e ) ; } }	Stop the server.
public void add mappings ( ) { router . set not implemented ( not implemented handler . class ) ; router . set not found handler ( error404 uri handler . class ) ; router . add route ( str , integer . max value / num , index handler . class ) ; router . add route ( str , integer . max value / num , index handler . class ) ; }	default routings, they are over writable.
private void send body ( output stream output stream , long pending ) throws io { long buffer size = num * num ; byte [ ] buff = new byte [ ( int ) buffer size ] ; boolean send everything = pending == - num ; while ( pending > num || send everything ) { long bytes to read = send everything ? buffer size : math . min ( pending , buffer size ) ; int read = this . data . read ( buff , num , ( int ) bytes to read ) ; if ( read <= num ) { break ; } try { output stream . write ( buff , num , read ) ; } catch ( exception e ) { if ( this . data != null ) { this . data . close ( ) ; } } if ( ! send everything ) { pending -= read ; } } }	Sends the body to the specified OutputStream.
public static response new fixed length response ( i status , string mime type , input stream data , long total bytes ) { return new response ( status , mime type , data , total bytes ) ; }	Create a response with known length.
public boolean use gzip when accepted ( ) { if ( gzip usage == gzip usage . default ) return get mime type ( ) != null && ( get mime type ( ) . to lower case ( ) . contains ( str ) || get mime type ( ) . to lower case ( ) . contains ( str ) ) ; else return gzip usage == gzip usage . always ; }	Else decide whether or not to use Gzip.
public void set ( string name , string value , int expires ) { this . queue . add ( new cookie ( name , value , cookie . get http ( expires ) ) ) ; }	Sets a cookie.
public void unload queue ( response response ) { for ( cookie cookie : this . queue ) { response . add cookie header ( cookie . get http ( ) ) ; } }	Internally used by the webserver to add all queued cookies into theResponse's HTTP Headers.
private string base64 decode ( string base64 value ) { try { byte [ ] decoded cookie bytes = base64 . get decoder ( ) . decode ( base64 value ) ; return new string ( decoded cookie bytes ) ; } catch ( exception ex ) { logger . debug ( str + base64 value ) ; return null ; } }	Decode the value using Base64.
private string base64 encode ( string value ) { byte [ ] encoded cookie bytes = base64 . get encoder ( ) . encode ( value . get bytes ( ) ) ; return new string ( encoded cookie bytes ) ; }	Encode the value using Base64.
public void set table name ( string table name ) { assert . has text ( table name , str ) ; this . table name = table name . trim ( ) ; prepare queries ( ) ; }	Set the name of database table used to store sessions.
protected string name ( object principal ) { if ( principal instanceof user details ) { return ( ( user details ) principal ) . get username ( ) ; } if ( principal instanceof principal ) { return ( ( principal ) principal ) . get name ( ) ; } return principal . to string ( ) ; }	Derives a String name for the given principal.
private void insert session repository filter ( servlet context servlet context ) { string filter name = default filter name ; delegating filter proxy spring session repository filter = new delegating filter proxy ( filter name ) ; string context attribute = get web application context attribute ( ) ; if ( context attribute != null ) { spring session repository filter . set context attribute ( context attribute ) ; } register filter ( servlet context , bool , filter name , spring session repository filter ) ; }	Registers the springSessionRepositoryFilter.
private static string resolve principal ( session session ) { string principal name = session . get attribute ( find by index name session repository . principal name index name ) ; if ( principal name != null ) { return principal name ; } security context security context = session . get attribute ( spring security context ) ; if ( security context != null && security context . get authentication ( ) != null ) { return security context . get authentication ( ) . get name ( ) ; } return str ; }	Tries to determine the principal's name from the given Session.
private redis session get session ( string id , boolean allow expired ) { map < object , object > entries = get session bound hash operations ( id ) . entries ( ) ; if ( entries . is empty ( ) ) { return null ; } map session loaded = load session ( id , entries ) ; if ( ! allow expired && loaded . is expired ( ) ) { return null ; } redis session result = new redis session ( loaded ) ; result . original last access time = loaded . get last accessed time ( ) ; return result ; }	Gets the session.
static string get jndi name ( final model node model node , operation context context ) throws operation failed exception { final string raw jndi name = mail session definition . jndi name . resolve model attribute ( context , model node ) . as string ( ) ; return get jndi name ( raw jndi name ) ; }	Extracts the raw JNDI_NAME value from the given model node, and depending on the value andthe value of any USE_JAVA_CONTEXT child node, converts the raw name into a compliant jndi name.
public static string [ ] get canonical parameter types ( method view method ) { class < ? > [ ] parameter types = view method . get parameter types ( ) ; if ( parameter types == null ) { return no strings ; } string [ ] canonical names = new string [ parameter types . length ] ; for ( int i = num ; i < parameter types . length ; i ++ ) { canonical names [ i ] = parameter types [ i ] . get canonical name ( ) ; } return canonical names ; }	This method returns the class names of the parameters of the given methodin canonical form.
public void register interposed synchronization ( synchronization synchronization ) throws illegal state exception , system exception { int status = context transaction synchronization registry . get instance ( ) . get transaction status ( ) ; switch ( status ) { case javax . transaction . status . status active : case javax . transaction . status . status preparing : break ; case status . status marked rollback :	This is only allowed at various points of the transaction lifecycle.
@ override public void before completion ( ) {	Exceptions from Synchronizations that are registered with this TSR are not trapped for before completion.
public static transaction get current transaction ( ) { transaction tx = null ; if ( pi current != null ) {	Returns the transaction associated with the transaction propagationcontext that arrived in the current IIOP request.
@ override public void deploy ( deployment phase context phase context ) throws deployment unit processing exception { final deployment unit unit = phase context . get deployment unit ( ) ; final list < kernel deployment xml descriptor > kd xml descriptors = unit . get attachment ( kernel deployment xml descriptor . attachment key ) ; if ( kd xml descriptors == null || kd xml descriptors . is empty ( ) ) return ; for ( kernel deployment xml descriptor kdxd : kd xml descriptors ) { if ( kdxd . get bean factories count ( ) > num ) { final module specification module specification = unit . get attachment ( attachments . module specification ) ; final module loader module loader = module . get boot module loader ( ) ; module dependency dependency = new module dependency ( module loader , pojo module , bool , bool , bool , bool ) ; path filter filter = path filters . is child of ( base bean factory . class . get package ( ) . get name ( ) ) ; dependency . add import filter ( filter , bool ) ; dependency . add import filter ( path filters . reject all ( ) , bool ) ; module specification . add system dependency ( dependency ) ; return ; } } }	Add POJO module if we have any bean factories.
@ override public boolean does scoped persistence unit name identify cache region name ( persistence unit metadata pu ) { string cache region prefix = pu . get properties ( ) . get property ( available settings . cache region prefix ) ; return cache region prefix == null || cache region prefix . equals ( pu . get scoped persistence unit name ( ) ) ; }	determine if management console can display the second level cache entries.
private static list < service name > get server config dependencies ( operation context context , boolean appclient ) { final list < service name > service names = new array list < service name > ( ) ; final resource subsystem resource = context . read resource from root ( path address . path address ( ws . subsystem path ) , bool ) ; read config service names ( service names , subsystem resource , constants . client config ) ; read config service names ( service names , subsystem resource , constants . endpoint config ) ; if ( ! appclient ) { service names . add ( common web server . service name ) ; } return service names ; }	Process the model to figure out the name of the services the server config service has to depend on.
private void dec read lock count ( ) { integer current = read lock count . get ( ) ; int next ; assert current != null : str ; next = current . int value ( ) - num ; if ( next == num ) read lock count . remove ( ) ; else read lock count . set ( new integer ( next ) ) ; }	Decrements the read lock count held by the thread.
private void inc read lock count ( ) { integer current = read lock count . get ( ) ; int next ; if ( current == null ) next = num ; else next = current . int value ( ) + num ; read lock count . set ( new integer ( next ) ) ; }	Increments the read lock count held by the thread.
public synchronized < s extends service > void add service ( class < s > clazz , s service ) { for ( bean deployment archive impl bda : bean deployment archives ) { bda . get services ( ) . add ( clazz , service ) ; } }	Adds a service to all bean deployment archives in the module.
public void handle restoration calculation ( ) { if ( next expiration == null ) { return ; }	Makes sure that the timer is only run once after being restored.
public void deploy ( deployment phase context phase context ) throws deployment unit processing exception { final deployment unit deployment unit = phase context . get deployment unit ( ) ; final module specification module specification = deployment unit . get attachment ( attachments . module specification ) ; final module loader module loader = module . get boot module loader ( ) ; if ( jpa . is jpa ( deployment unit ) ) { add search dependency ( module specification , module loader , deployment unit ) ; } }	if set to `auto`, will behave like not having set the property.
private void make top level bdas visible from static modules ( ) { for ( bean deployment archive impl bda : bean deployment archives ) { if ( bda . get bean archive type ( ) . equals ( bean deployment archive impl . bean archive type . external ) || bda . get bean archive type ( ) . equals ( bean deployment archive impl . bean archive type . synthetic ) ) { for ( bean deployment archive impl top level bda : root bean deployment module . get bean deployment archives ( ) ) { bda . add bean deployment archive ( top level bda ) ; } } } }	Adds additional edges to the accessibility graph that allow static CDI-enabled modules to inject beans from top-level deployment units.
jse create ( final deployment dep ) { if ( ws . root logger . is trace enabled ( ) ) { ws . root logger . tracef ( str , dep . get simple name ( ) ) ; } final j jboss web md = ws . get required attachment ( dep , j . class ) ; final deployment unit unit = ws . get required attachment ( dep , deployment unit . class ) ; final list < pojo > pojo endpoints = get pojo endpoints ( unit ) ; final jse . builder builder = new jse . builder ( ) ;	Builds universal JSE meta data model that is AS agnostic.
private void set config name and file ( final jse . builder builder , final j jboss web md , final j jboss webservices md ) { if ( jboss webservices md != null ) { if ( jboss webservices md . get config name ( ) != null ) { final string config name = jboss webservices md . get config name ( ) ; builder . set config name ( config name ) ; ws . root logger . tracef ( str , config name ) ; final string config file = jboss webservices md . get config file ( ) ; builder . set config file ( config file ) ; ws . root logger . tracef ( str , config file ) ;	Sets config name and config file.
private list < jse > get security meta data ( final list < security constraint meta data > security constraints md ) { final list < jse > jse security m = new linked list < jse > ( ) ; if ( security constraints md != null ) { for ( final security constraint meta data security constraint md : security constraints md ) { final jse . builder jse security md = new jse . builder ( ) ;	Builds security meta data.
private map < string , string > get servlet url patterns mappings ( final j jboss web md , final list < pojo > pojo endpoints ) { final map < string , string > mappings = new hash map < string , string > ( ) ; final list < servlet mapping meta data > servlet mappings = web meta data helper . get servlet mappings ( jboss web md ) ; for ( final pojo pojo endpoint : pojo endpoints ) { mappings . put ( pojo endpoint . get name ( ) , pojo endpoint . get url pattern ( ) ) ; if ( ! pojo endpoint . is declared ( ) ) { final string endpoint name = pojo endpoint . get name ( ) ; final list < string > url patterns = web meta data helper . get url patterns ( pojo endpoint . get url pattern ( ) ) ; web meta data helper . new servlet mapping ( endpoint name , url patterns , servlet mappings ) ; } } return mappings ; }	Returns servlet name to url pattern mappings.
private map < string , string > get servlet class mappings ( final j jboss web md , final list < pojo > pojo endpoints ) { final map < string , string > mappings = new hash map < string , string > ( ) ; final j servlets = web meta data helper . get servlets ( jboss web md ) ; for ( final pojo pojo endpoint : pojo endpoints ) { final string pojo name = pojo endpoint . get name ( ) ; final string pojo class name = pojo endpoint . get class name ( ) ; mappings . put ( pojo name , pojo class name ) ; if ( ! pojo endpoint . is declared ( ) ) { final string endpoint name = pojo endpoint . get name ( ) ; final string endpoint class name = pojo endpoint . get class name ( ) ; web meta data helper . new servlet ( endpoint name , endpoint class name , servlets ) ; } } return mappings ; }	Returns servlet name to servlet class mappings.
private void resolve ( ) { if ( ! resolved ) { synchronized ( this ) { if ( ! resolved ) { final set < view description > views = get views ( ) ; final set < ejb > ejbs for view name = new hash set < ejb > ( ) ; for ( final view description view : views ) { if ( view instanceof ejb ) { final method intf view type = ( ( ejb ) view ) . get method intf ( ) ;	Checks if this ejb injection has been resolved yet, and if not resolves it.
private static set < string > get available connectors ( final operation context context , final model node operation ) throws operation failed exception { path address address = path address . path address ( operation . get ( model description constants . op addr ) ) ; path address active = messaging services . get active mq ( address ) ; set < string > available connectors = new hash set < string > ( ) ; resource subsystem resource = context . read resource from root ( active . get parent ( ) , bool ) ; available connectors . add all ( subsystem resource . get children names ( common attributes . remote connector ) ) ; resource active mq = context . read resource from root ( active , bool ) ; available connectors . add all ( active mq . get children names ( common attributes . http connector ) ) ; available connectors . add all ( active mq . get children names ( common attributes . in vm connector ) ) ; available connectors . add all ( active mq . get children names ( common attributes . remote connector ) ) ; available connectors . add all ( active mq . get children names ( common attributes . connector ) ) ; return available connectors ; }	FIXME use capabilities & requirements.
static void parse core environment element ( final xml reader , final model node operation ) throws xml { final int count = reader . get attribute count ( ) ; for ( int i = num ; i < count ; i ++ ) { require no namespace attribute ( reader , i ) ; final string value = reader . get attribute value ( i ) ; final attribute attribute = attribute . for name ( reader . get attribute local name ( i ) ) ; switch ( attribute ) { case node identifier : transaction subsystem root resource definition . node identifier . parse and set parameter ( value , operation , reader ) ; break ; case path : case relative to : throw transaction logger . root logger . unsupported attribute ( attribute . get local name ( ) , reader . get location ( ) ) ; default : throw unexpected attribute ( reader , i ) ; } }	Handle the core-environment element and children.
static void parse process id environment element ( xml reader , model node core environment add ) throws xml {	Handle the process-id child elements.
public static path address get path address ( model node operation ) { return path address . path address ( operation . require ( model description constants . op addr ) ) ; }	Returns the address of the specified operation.
public static void set path address ( model node operation , path address address ) { operation . get ( model description constants . op addr ) . set ( address . to model node ( ) ) ; }	Sets the address of the specified operation.
public static model node get attribute value ( model node operation ) { return operation . has defined ( model description constants . value ) ? operation . get ( model description constants . value ) : new model node ( ) ; }	Returns the attribute value of the specified operation.
public static boolean is include defaults ( model node operation ) { return operation . has defined ( model description constants . include defaults ) ? operation . get ( model description constants . include defaults ) . as boolean ( ) : bool ; }	Indicates whether or not this operation expects to include default values.
public static model node create composite operation ( list < model node > operations ) { model node operation = util . create operation ( model description constants . composite , path address . empty address ) ; model node steps = operation . get ( model description constants . steps ) ; for ( model node step : operations ) { steps . add ( step ) ; } return operation ; }	Creates a composite operation using the specified operation steps.
public static model node create add operation ( path address address , map < attribute , model node > parameters ) { model node operation = util . create add operation ( address ) ; for ( map . entry < attribute , model node > entry : parameters . entry set ( ) ) { operation . get ( entry . get key ( ) . get name ( ) ) . set ( entry . get value ( ) ) ; } return operation ; }	Creates an add operation using the specified address and parameters.
public static model node create add operation ( path address address , int index ) { return create add operation ( address , index , collections . empty map ( ) ) ; }	Creates an indexed add operation using the specified address and index.
public static model node create read attribute operation ( path address address , attribute attribute ) { return create attribute operation ( model description constants . read attribute operation , address , attribute ) ; }	Creates a read-attribute operation using the specified address and name.
public static model node create write attribute operation ( path address address , attribute attribute , model node value ) { model node operation = create attribute operation ( model description constants . write attribute operation , address , attribute ) ; operation . get ( model description constants . value ) . set ( value ) ; return operation ; }	Creates a write-attribute operation using the specified address, name and value.
public static model node create undefine attribute operation ( path address address , attribute attribute ) { return create attribute operation ( model description constants . undefine attribute operation , address , attribute ) ; }	Creates an undefine-attribute operation using the specified address and name.
public t get value ( ) throws illegal state exception { final context context = context value . get value ( ) ; try { return ( t ) context . lookup ( context name ) ; } catch ( naming exception e ) { throw naming logger . root logger . entry not registered ( e , context name , context ) ; } }	Lookup the value from the naming context.
public static synchronized void add url context factory ( final string scheme , object factory factory ) { map < string , object factory > factories = new hash map < string , object factory > ( url context factories ) ; factories . put ( scheme , factory ) ; url context factories = collections . unmodifiable map ( factories ) ; }	Add an ObjectFactory to handle requests for a specific URL scheme.
public static synchronized void remove url context factory ( final string scheme , object factory factory ) { map < string , object factory > factories = new hash map < string , object factory > ( url context factories ) ; object factory f = factories . get ( scheme ) ; if ( f == factory ) { factories . remove ( scheme ) ; url context factories = collections . unmodifiable map ( factories ) ; return ; } else { throw new illegal argument exception ( ) ; } }	Remove an ObjectFactory from the map of registered ones.
private list < validation provider < ? > > load providers ( class loader class loader ) { @ suppress warnings ( str ) iterator < validation provider > provider iterator = service loader . load ( validation provider . class , class loader ) . iterator ( ) ; linked list < validation provider < ? > > providers = new linked list < validation provider < ? > > ( ) ; while ( provider iterator . has next ( ) ) { try { validation provider < ? > provider = provider iterator . next ( ) ;	Retrieves the providers from the given loader, using the service loader mechanism.
void modify ( final deployment dep ) { final j jboss web md = ws . get optional attachment ( dep , j . class ) ; if ( jboss web md != null ) { this . configure endpoints ( dep , jboss web md ) ; this . modify context root ( dep , jboss web md ) ; } }	Modifies web meta data to configure webservice stack transport and properties.
private void configure endpoints ( final deployment dep , final j jboss web md ) { final string transport class name = this . get transport class name ( dep ) ; ws . root logger . trace ( str ) ;	Configures transport servlet class for every found webservice endpoint.
private void modify context root ( final deployment dep , final j jboss web md ) { final string context root = dep . get service ( ) . get context root ( ) ; if ( ws . root logger . is trace enabled ( ) ) { ws . root logger . tracef ( str , context root , dep . get simple name ( ) ) ; } jboss web md . set context root ( context root ) ; }	Modifies context root.
private string get transport class name ( final deployment dep ) { string transport class name = ( string ) dep . get property ( ws . stack transport class ) ; if ( transport class name == null ) throw ws . root logger . missing deployment property ( ws . stack transport class ) ; return transport class name ; }	Returns stack specific transport class name.
static run as set run as identity ( final run as principal , final security context sc ) { if ( wild fly security manager . is checking ( ) ) { return wild fly security manager . do unchecked ( new privileged action < run as > ( ) { @ override public run as run ( ) { if ( sc == null ) { throw undertow logger . root logger . no security context ( ) ; } run as old = sc . get outgoing run as ( ) ; sc . set outgoing run as ( principal ) ; return old ; } } ) ; } else { if ( sc == null ) { throw undertow logger . root logger . no security context ( ) ; } run as old = sc . get outgoing run as ( ) ; sc . set outgoing run as ( principal ) ; return old ; } }	Sets the run as identity.
static run as pop run as identity ( final security context sc ) { if ( wild fly security manager . is checking ( ) ) { return access controller . do privileged ( new privileged action < run as > ( ) { @ override public run as run ( ) { if ( sc == null ) { throw undertow logger . root logger . no security context ( ) ; } run as principal = sc . get outgoing run as ( ) ; sc . set outgoing run as ( null ) ; return principal ; } } ) ; } else { if ( sc == null ) { throw undertow logger . root logger . no security context ( ) ; } run as principal = sc . get outgoing run as ( ) ; sc . set outgoing run as ( null ) ; return principal ; } }	Removes the run as identity.
void process management ( final deployment unit unit , j meta data ) { final deployment resource support deployment resource support = unit . get attachment ( attachments . deployment resource support ) ; for ( final j servlet : meta data . get servlets ( ) ) { try { final string name = servlet . get name ( ) ; final model node node = deployment resource support . get deployment sub model ( undertow extension . subsystem name , path element . path element ( str , name ) ) ; node . get ( str ) . set ( servlet . get servlet class ( ) ) ; node . get ( str ) . set ( servlet . get servlet name ( ) ) ; } catch ( exception e ) {	todo move to UndertowDeploymentService and use all registered servlets from Deployment instead of just one found by metadata.
@ suppress warnings ( str ) public void inject ( object object , string property name , object property value ) throws no such method exception , illegal access exception , invocation target exception { inject ( object , property name , property value , null , bool ) ; }	Inject a value into an object property.
private boolean argument matches ( string class type , string property type ) { return ( class type . equals ( property type ) ) || ( class type . equals ( str ) && property type . equals ( str ) ) || ( class type . equals ( str ) && property type . equals ( str ) ) || ( class type . equals ( str ) && property type . equals ( str ) ) || ( class type . equals ( str ) && property type . equals ( str ) ) || ( class type . equals ( str ) && property type . equals ( str ) ) || ( class type . equals ( str ) && property type . equals ( str ) ) || ( class type . equals ( str ) && property type . equals ( str ) ) || ( class type . equals ( str ) && property type . equals ( str ) ) ; }	Compare the type of a class with the actual value.
protected method find method ( class < ? > clz , string method name , string property type ) { while ( ! clz . equals ( object . class ) ) { list < method > hits = null ; method [ ] methods = security actions . get declared methods ( clz ) ; for ( int i = num ; i < methods . length ; i ++ ) { final method method = methods [ i ] ; if ( method name . equals ( method . get name ( ) ) && method . get parameter types ( ) . length == num ) { if ( property type == null || argument matches ( property type , method . get parameter types ( ) [ num ] . get name ( ) ) ) { if ( hits == null ) hits = new array list < method > ( num ) ; security actions . set accessible ( method ) ; hits . add ( method ) ; } } } if ( hits != null ) { if ( hits . size ( ) == num ) { return hits . get ( num ) ; } else { collections . sort ( hits , new method sorter ( ) ) ; if ( property type != null ) { for ( method m : hits ) { if ( property type . equals ( m . get parameter types ( ) [ num ] . get name ( ) ) ) return m ; } } return hits . get ( num ) ; } } clz = clz . get superclass ( ) ; } return null ; }	Find a method.
protected field find field ( class < ? > clz , string field name , string field type ) { while ( ! clz . equals ( object . class ) ) { list < field > hits = null ; field [ ] fields = security actions . get declared fields ( clz ) ; for ( int i = num ; i < fields . length ; i ++ ) { final field field = fields [ i ] ; if ( field name . equals ( field . get name ( ) ) ) { if ( field type == null || argument matches ( field type , field . get type ( ) . get name ( ) ) ) { if ( hits == null ) hits = new array list < field > ( num ) ; security actions . set accessible ( field ) ; hits . add ( field ) ; } } } if ( hits != null ) { if ( hits . size ( ) == num ) { return hits . get ( num ) ; } else { collections . sort ( hits , new field sorter ( ) ) ; if ( field type != null ) { for ( field f : hits ) { if ( field type . equals ( f . get type ( ) . get name ( ) ) ) return f ; } } return hits . get ( num ) ; } } clz = clz . get superclass ( ) ; } return null ; }	Find a field.
private static string derive useful info ( http servlet request http request ) { string builder sb = new string builder ( ) ; sb . append ( str ) . append ( http request . get context path ( ) ) ; sb . append ( str ) . append ( arrays . to string ( http request . get cookies ( ) ) ) . append ( str ) ;	Obtain debug information from the servlet request object.
public jdr report standalone collect ( cli cli , string protocol , string host , int port ) throws operation failed exception { return new jdr runner ( cli , protocol , host , port , null , null ) . collect ( ) ; }	Collect a JDR report when run outside the Application Server.
public jdr report collect ( ) throws operation failed exception { jdr runner runner = new jdr runner ( bool ) ; server environment = server environment value . get value ( ) ; runner . set jboss home dir ( server environment . get home dir ( ) . get absolute path ( ) ) ; runner . set report location dir ( server environment . get server temp dir ( ) . get absolute path ( ) ) ; runner . set controller client ( controller client ) ; runner . set host controller name ( server environment . get host controller name ( ) ) ; runner . set server name ( server environment . get server name ( ) ) ; return runner . collect ( ) ; }	Collect a JDR report.
public void register resource adapter deployment ( resource adapter deployment deployment ) { if ( deployment == null ) throw new illegal argument exception ( connector logger . root logger . null var ( str ) ) ; deployment connector registry logger . tracef ( str , deployment ) ; deployments . add ( deployment ) ; }	Register a resource adapter deployment.
public void unregister resource adapter deployment ( resource adapter deployment deployment ) { if ( deployment == null ) throw new illegal argument exception ( connector logger . root logger . null var ( str ) ) ; deployment connector registry logger . tracef ( str , deployment ) ; deployments . remove ( deployment ) ; }	Unregister a resource adapter deployment.
protected static void register transformers ( final subsystem registration subsystem ) { chained transformation description builder chained = resource transformation description builder . factory . create chained subystem instance ( current model version ) ; model version model version ea = model version . create ( num , num , num ) ; model version model version ea = model version . create ( num , num , num ) ;	Register the transformers for the 1.3.0 version.
public void write params ( output stream out , object [ ] params ) { int len = params . length ; if ( len != param writers . length ) { throw iiop . root logger . error mashaling params ( ) ; } for ( int i = num ; i < len ; i ++ ) { object param = params [ i ] ; if ( param instanceof portable remote object ) { try { param = portable remote object . to stub ( ( remote ) param ) ; } catch ( no such object exception e ) { throw new runtime exception ( e ) ; } } param writers [ i ] . write ( out , remote object substitution manager . write replace remote ( param ) ) ; } }	Marshals the sequence of method parameters into an output stream.
public exception read exception ( string id , input stream in ) { exception reader exception reader = ( exception reader ) exception map . get ( id ) ; if ( exception reader == null ) { return new unexpected exception ( id ) ; } else { return exception reader . read ( in ) ; } }	Unmarshals from an input stream an exception thrown by the method.
private static object get lock owner ( final transaction synchronization registry transaction synchronization registry ) { object owner = transaction synchronization registry . get transaction key ( ) ; return owner != null ? owner : thread . current thread ( ) ; }	Use either the active transaction or the current thread as the lock owner.
static void release lock ( final stateful session component instance instance ) { instance . get lock ( ) . unlock ( get lock owner ( instance . get component ( ) . get transaction synchronization registry ( ) ) ) ; root logger . tracef ( str , instance . get lock ( ) ) ; }	Releases the lock, held by this thread, on the stateful component instance.
public void add log ( string content , string log name ) throws exception { string name = str + log name ; this . add ( new byte array input stream ( content . get bytes ( standard charsets . utf 8 ) ) , name ) ; }	Adds content to the zipfile in a file named logNamepath is prepended with the directory reserved for JDR log files.
private void add cdi ( war meta data war meta data , deployment unit deployment unit ) { j web meta data = war meta data . get merged j ( ) ; if ( web meta data == null ) { web meta data = new j ( ) ; war meta data . set merged j ( web meta data ) ; } list < param value meta data > context params = web meta data . get context params ( ) ; if ( context params == null ) { context params = new array list < param value meta data > ( ) ; } boolean is cdi = bool ; final capability service support support = deployment unit . get attachment ( attachments . capability service support ) ; if ( support . has capability ( weld capability name ) ) { is cdi = support . get optional capability runtime api ( weld capability name , weld capability . class ) . get ( ) . is part of weld deployment ( deployment unit ) ; } param value meta data param = new param value meta data ( ) ; param . set param name ( is cdi param ) ; param . set param value ( boolean . to string ( is cdi ) ) ; context params . add ( param ) ; web meta data . set context params ( context params ) ; }	a CDI ViewHandler.
protected component view get component view ( ) { component view cv = component view ;	Gets endpoint container lazily.
public void invoke ( final endpoint endpoint , final invocation ws invocation ) throws exception { try { if ( ! endpoint state . started . equals ( endpoint . get state ( ) ) ) { throw ws . root logger . endpoint already stopped ( endpoint . get short name ( ) ) ; } security domain context security domain context = endpoint . get security domain context ( ) ; security domain context . run as ( ( callable < void > ) ( ) -> { invoke internal ( endpoint , ws invocation ) ; return null ; } ) ; } catch ( throwable t ) { handle invocation exception ( t ) ; } finally { on after invocation ( ws invocation ) ; } }	Invokes WS endpoint.
protected method get component view method ( final method sei method , final collection < method > view methods ) { for ( final method view method : view methods ) { if ( matches ( sei method , view method ) ) { return view method ; } } throw new illegal state exception ( ) ; }	Translates SEI method to component view method.
private boolean matches ( final method sei method , final method view method ) { if ( ! sei method . get name ( ) . equals ( view method . get name ( ) ) ) return bool ; final class < ? > [ ] source params = sei method . get parameter types ( ) ; final class < ? > [ ] target params = view method . get parameter types ( ) ; if ( source params . length != target params . length ) return bool ; for ( int i = num ; i < source params . length ; i ++ ) { if ( ! source params [ i ] . equals ( target params [ i ] ) ) return bool ; } return bool ; }	Compares two methods if they are identical.
private ejb get ejb security meta data ( final endpoint endpoint ) { final string ejb name = endpoint . get short name ( ) ; final deployment dep = endpoint . get service ( ) . get deployment ( ) ; final ejb ejb archive md = ws . get optional attachment ( dep , ejb . class ) ; final ejb ejb md = ejb archive md != null ? ejb archive md . get bean by ejb name ( ejb name ) : null ; return ejb md != null ? ejb md . get security meta data ( ) : null ; }	Gets EJB security meta data if associated with EJB endpoint.
private string get domain ( final string old security domain , final string next security domain ) { if ( next security domain == null ) { return old security domain ; } if ( old security domain == null ) { return next security domain ; } ensure same domains ( old security domain , next security domain ) ; return old security domain ; }	Returns security domain value.
private void ensure same domains ( final string old security domain , final string new security domain ) { final boolean domains differ = ! old security domain . equals ( new security domain ) ; if ( domains differ ) throw ws . root logger . multiple security domains detected ( old security domain , new security domain ) ; }	This method ensures both passed domains contain the same value.
void set idl ( string idl name ) { super . set idl ( idl name ) ;	Set my unqualified IDL name.This also sets the names of the associated operations.
public string get absolute name ( ) { final string builder absolute = new string builder ( ) ; if ( parent != null ) { absolute . append ( parent ) . append ( entry separator ) ; } absolute . append ( local ) ; return absolute . to string ( ) ; }	Get the absolute JNDI name as a string.
public static jndi name of ( final string name ) { if ( name == null || name . is empty ( ) ) throw naming logger . root logger . invalid jndi name ( name ) ; final string [ ] parts = name . split ( entry separator ) ; jndi name current = null ; for ( string part : parts ) { current = new jndi name ( current , part ) ; } return current ; }	Create a new instance of the JndiName by breaking the provided string format into a JndiName parts.
@ override public void deploy ( deployment phase context phase context ) throws deployment unit processing exception { final deployment unit deployment unit = phase context . get deployment unit ( ) ; final resource root resource root = deployment unit . get attachment ( attachments . deployment root ) ; final virtual file deployment root = resource root . get root ( ) ; final boolean resolve properties = util . should resolve j ( deployment unit ) ; iron jacamar xml descriptor xml descriptor = process ( deployment root , resolve properties ) ; if ( xml descriptor != null ) { deployment unit . put attachment ( iron jacamar xml descriptor . attachment key , xml descriptor ) ; } }	Process a deployment for iron-jacamar.xml files.
@ override public void handle request ( http server exchange exchange ) throws exception { running count . increment ( ) ; exchange . add exchange complete listener ( new exchange completion listener ( ) { @ override public void exchange event ( http server exchange exchange , next listener next listener ) { running count . decrement ( ) ;	Increments the counter and registers a listener to decrement the counter upon exchange complete event.
private boolean is in transaction ( ) { transaction synchronization registry tsr = get transaction synchronization registry ( ) ; boolean in tx = tsr . get transaction status ( ) == status . status active ; return in tx ; }	check whether there is an active transaction.
private transaction synchronization registry get transaction synchronization registry ( ) { transaction synchronization registry cached tsr = transaction synchronization registry ; if ( cached tsr == null ) { cached tsr = ( transaction synchronization registry ) lookup ( transaction synchronization registry lookup ) ; transaction synchronization registry = cached tsr ; } return cached tsr ; }	lookup the transactionSynchronizationRegistry and cache it.
private connection factory get connection factory ( ) { connection factory cached cf = connection factory ; if ( cached cf == null ) { cached cf = ( connection factory ) lookup ( info . get connection factory lookup ( ) ) ; connection factory = cached cf ; } return cached cf ; }	lookup the connectionFactory and cache it.
public static string get last component ( final name name ) { if ( name . size ( ) > num ) return name . get ( name . size ( ) - num ) ; return str ; }	Get the last component of a name.
public static boolean is empty ( final name name ) { return name . is empty ( ) || ( name . size ( ) == num && str . equals ( name . get ( num ) ) ) ; }	Determine if a name is empty, or if ot contains only one component which is the empty string.
public static name not found exception name not found exception ( final string name , final name context name ) { return naming logger . root logger . name not found in context ( name , context name ) ; }	Create a name-not-found exception.
public static naming exception naming exception ( final string message , final throwable cause ) { final naming exception exception = new naming exception ( message ) ; if ( cause != null ) exception . init cause ( cause ) ; return exception ; }	Return a general naming exception with a root cause.
public static naming exception naming exception ( final string message , final throwable cause , final name remaining name ) { final naming exception exception = naming exception ( message , cause ) ; exception . set remaining name ( remaining name ) ; return exception ; }	Return a general naming exception with a root cause and a remaining name field.
public static cannot proceed exception cannot proceed exception ( final object resolved object , final name remaining name ) { final cannot proceed exception cpe = new cannot proceed exception ( ) ; cpe . set resolved obj ( resolved object ) ; cpe . set remaining name ( remaining name ) ; return cpe ; }	Return a cannot-proceed exception.
public static < t > naming enumeration < t > naming enumeration ( final collection < t > collection ) { final iterator < t > iterator = collection . iterator ( ) ; return new naming enumeration < t > ( ) { public t next ( ) { return next element ( ) ; } public boolean has more ( ) { return has more elements ( ) ; } public void close ( ) { } public boolean has more elements ( ) { return iterator . has next ( ) ; } public t next element ( ) { return iterator . next ( ) ; } } ; }	Return a naming enumeration over a collection.
public static void rebind ( final context ctx , final string name , final object value ) throws naming exception { final name n = ctx . get name parser ( str ) . parse ( name ) ; rebind ( ctx , n , value ) ; }	Rebind val to name in ctx, and make sure that all intermediate contexts exist.
protected final t get active mq ( final operation context context , final model node operation , final boolean for write ) throws operation failed exception { final service name artemis service name = messaging services . get active mq ( path address . path address ( operation . get ( model description constants . op addr ) ) ) ; service controller < ? > artemis service = context . get service registry ( for write ) . get service ( artemis service name ) ; mq server = mq . class . cast ( artemis service . get value ( ) ) ; path address address = path address . path address ( operation . require ( op addr ) ) ; t control = get active mq ( server , address ) ; if ( control == null ) { throw controller logger . root logger . management resource not found ( address ) ; } return control ; }	Gets the runtime ActiveMQ control object that can help service this request.
public component instance create instance ( object instance ) { basic component instance obj = construct component instance ( new immediate managed reference ( instance ) , bool ) ; obj . construction finished ( ) ; return obj ; }	Wraps an existing object instance in a ComponentInstance, and run the post construct interceptor chain on it.
protected synchronized virtual file get resteasy spring virtual file ( ) throws deployment unit processing exception { if ( resource root != null ) { return resource root ; } try { module module = module . get boot module loader ( ) . load module ( module ) ; url file url = module . get class loader ( ) . get resource ( jar location ) ; if ( file url == null ) { throw jaxrs logger . jaxrs logger . no spring integration jar ( ) ; } file dir = new file ( file url . to uri ( ) ) ; file file = null ; for ( string jar : dir . list ( ) ) { if ( jar . ends with ( str ) ) { file = new file ( dir , jar ) ; break ; } } if ( file == null ) { throw jaxrs logger . jaxrs logger . no spring integration jar ( ) ; } virtual file vf = vfs . get child ( file . to uri ( ) ) ; final closeable mount handle = vfs . mount zip ( file , vf , temp file provider service . provider ( ) ) ; service < closeable > mount handle service = new service < closeable > ( ) { public void start ( start context start context ) throws start exception { } public void stop ( stop context stop context ) { vfs . safe close ( mount handle ) ; } public closeable get value ( ) throws illegal state exception , illegal argument exception { return mount handle ; } } ; service builder < closeable > builder = service target . add service ( service name . jboss . append ( service name ) , mount handle service ) ; builder . set initial mode ( service controller . mode . active ) . install ( ) ; resource root = vf ; return resource root ; } catch ( exception e ) { throw new deployment unit processing exception ( e ) ; } }	Lookup Seam integration resource loader.
protected static string resolve runtime name ( final operation context context , final path element address ) { final model node runtime name = context . read resource from root ( path address . path address ( address ) , bool ) . get model ( ) . get ( model description constants . runtime name ) ; return runtime name . as string ( ) ; }	Resolves runtime name of model resource.
private static xml . xml listener builder ( persistent resource definition resource ) { return builder ( resource . get path element ( ) )	Registers attributes common across listener types.
public static primitive analysis get primitive analysis ( final class cls ) { if ( cls == null ) throw iiop . root logger . cannot analyze null class ( ) ; if ( cls == void . type ) return void analysis ; if ( cls == boolean . type ) return boolean analysis ; if ( cls == character . type ) return char analysis ; if ( cls == byte . type ) return byte analysis ; if ( cls == short . type ) return short analysis ; if ( cls == integer . type ) return int analysis ; if ( cls == long . type ) return long analysis ; if ( cls == float . type ) return float analysis ; if ( cls == double . type ) return double analysis ; throw iiop . root logger . not a ( cls . get name ( ) ) ; }	Get a singleton instance representing one of the primitive types.
public void shutdown ( ) { int value ; int old value ;	Upon calling this method the EJB will be set to a shutdown state, and no further invocations will be allowed.It will then wait for all active invocation to finish and then return.
public static list < string > get url patterns ( final string url pattern ) { final list < string > linked list = new linked list < string > ( ) ; linked list . add ( url pattern ) ; return linked list ; }	Creates URL pattern list from passed string.
public static j get servlets ( final j jboss web md ) { j servlets md = jboss web md . get servlets ( ) ; if ( servlets md == null ) { servlets md = new j ( ) ; jboss web md . set servlets ( servlets md ) ; } return servlets md ; }	Gets servlets meta data from jboss web meta data.
public static list < servlet mapping meta data > get servlet mappings ( final j jboss web md ) { list < servlet mapping meta data > servlet mappings md = jboss web md . get servlet mappings ( ) ; if ( servlet mappings md == null ) { servlet mappings md = new linked list < servlet mapping meta data > ( ) ; jboss web md . set servlet mappings ( servlet mappings md ) ; } return servlet mappings md ; }	Gets servlet mappings meta data from jboss web meta data.
public static list < security constraint meta data > get security constraints ( final j jboss web md ) { list < security constraint meta data > security constraints md = jboss web md . get security constraints ( ) ; if ( security constraints md == null ) { security constraints md = new linked list < security constraint meta data > ( ) ; jboss web md . set security constraints ( security constraints md ) ; } return security constraints md ; }	Gets security constraints meta data from jboss web meta data.
public static login config meta data get login config ( final j jboss web md ) { login config meta data login config md = jboss web md . get login config ( ) ; if ( login config md == null ) { login config md = new login config meta data ( ) ; jboss web md . set login config ( login config md ) ; } return login config md ; }	Gets login config meta data from jboss web meta data.
public static list < param value meta data > get context params ( final j jboss web md ) { list < param value meta data > context params md = jboss web md . get context params ( ) ; if ( context params md == null ) { context params md = new linked list < param value meta data > ( ) ; jboss web md . set context params ( context params md ) ; } return context params md ; }	Gets context parameters meta data from jboss web meta data.
public static web resource collections meta data get web resource collections ( final security constraint meta data security constraint md ) { web resource collections meta data web resource collections md = security constraint md . get resource collections ( ) ; if ( web resource collections md == null ) { web resource collections md = new web resource collections meta data ( ) ; security constraint md . set resource collections ( web resource collections md ) ; } return web resource collections md ; }	Gets web resource collections meta data from security constraint meta data.
public static list < param value meta data > get servlet init params ( final servlet meta data servlet md ) { list < param value meta data > init params md = servlet md . get init param ( ) ; if ( init params md == null ) { init params md = new linked list < param value meta data > ( ) ; servlet md . set init param ( init params md ) ; } return init params md ; }	Gets init parameters meta data from servlet meta data.
public static security constraint meta data new security constraint ( final list < security constraint meta data > security constraints md ) { final security constraint meta data security constraint md = new security constraint meta data ( ) ; security constraints md . add ( security constraint md ) ; return security constraint md ; }	Creates new security constraint meta data and associates them with security constraints meta data.
public static web resource collection meta data new web resource collection ( final string servlet name , final string url pattern , final boolean secured wsdl , final web resource collections meta data web resource collections md ) { final web resource collection meta data web resource collection md = new web resource collection meta data ( ) ; web resource collection md . set web resource name ( servlet name ) ; web resource collection md . set url patterns ( web meta data helper . get url patterns ( url pattern ) ) ; web resource collection md . set http methods ( web meta data helper . get http methods ( secured wsdl ) ) ; web resource collections md . add ( web resource collection md ) ; return web resource collection md ; }	Creates new web resource collection meta data and associates them with web resource collections meta data.
public static j new servlet ( final string servlet name , final string servlet class , final j servlets md ) { final j servlet md = new j ( ) ; servlet md . set servlet name ( servlet name ) ; servlet md . set servlet class ( servlet class ) ; servlets md . add ( servlet md ) ; return servlet md ; }	Creates new servlet meta data and associates them with servlets meta data.
public static servlet mapping meta data new servlet mapping ( final string servlet name , final list < string > url patterns , final list < servlet mapping meta data > servlet mappings md ) { final servlet mapping meta data servlet mapping md = new servlet mapping meta data ( ) ; servlet mapping md . set servlet name ( servlet name ) ; servlet mapping md . set url patterns ( url patterns ) ; servlet mappings md . add ( servlet mapping md ) ; return servlet mapping md ; }	Creates new servlet mapping meta data and associates them with servlet mappings meta data.
public static auth constraint meta data new auth constraint ( final list < string > role names , final security constraint meta data security constraint md ) { final auth constraint meta data auth constraint md = new auth constraint meta data ( ) ; auth constraint md . set role names ( role names ) ; security constraint md . set auth constraint ( auth constraint md ) ; return auth constraint md ; }	Creates new authentication constraint and associates it with security constraint meta data.
public static user data constraint meta data new user data constraint ( final string transport guarantee , final security constraint meta data security constraint md ) { final user data constraint meta data user data constraint md = new user data constraint meta data ( ) ; final transport guarantee type transport guarantee value = transport guarantee type . value of ( transport guarantee ) ; user data constraint md . set transport guarantee ( transport guarantee value ) ; security constraint md . set user data constraint ( user data constraint md ) ; return user data constraint md ; }	Creates new user constraint meta data and associates it with security constraint meta data.
public static param value meta data new param value ( final string key , final string value , final list < param value meta data > params md ) { final param value meta data param value md = web meta data helper . new param value ( key , value ) ; params md . add ( param value md ) ; return param value md ; }	Creates new parameter meta data and associates it with parameters meta data.
private static param value meta data new param value ( final string key , final string value ) { final param value meta data param md = new param value meta data ( ) ; param md . set param name ( key ) ; param md . set param value ( value ) ; return param md ; }	Creates new parameter with specified key and value.
private void register session bean interceptors ( session bean component description component description , final deployment unit deployment unit ) {	Register our listeners on SFSB that will be created.
@ override public void stop ( final stop context context ) { final weld bootstrap service bootstrap service = bootstrap supplier . get ( ) ; if ( ! bootstrap service . is started ( ) ) { throw weld logger . root logger . not started ( str ) ; } weld logger . deployment logger . stopping weld service ( bootstrap service . get deployment name ( ) ) ; class loader old tccl = wild fly security manager . get current context class loader privileged ( ) ; try { wild fly security manager . set current context class loader privileged ( bootstrap service . get deployment ( ) . get module ( ) . get class loader ( ) ) ; weld provider . container shut down ( container . instance ( bootstrap service . get deployment name ( ) ) ) ; bootstrap service . get bootstrap ( ) . shutdown ( ) ; } finally { wild fly security manager . set current context class loader privileged ( old tccl ) ; module group singleton provider . remove class loader ( bootstrap service . get deployment ( ) . get module ( ) . get class loader ( ) ) ; } bootstrap service . set started ( bool ) ; }	Stops the containerExecuted in WeldStartService to shutdown the runtime before NamingService is closed.
public static string get jndi name ( final operation context context , final model node model node ) throws operation failed exception { final string raw jndi name = jndi name . resolve model attribute ( context , model node ) . as string ( ) ; return clean jndi name ( raw jndi name , model node . has defined ( use java context . get name ( ) ) && model node . get ( use java context . get name ( ) ) . as boolean ( ) ) ; }	Extracts the raw JNDINAME value from the given model node, and depending on the value andthe value of any USE_JAVA_CONTEXT child node, converts the raw name into a compliant jndi name.
private string resolve attribute ( simple attribute definition attr , operation context context , model node model ) throws operation failed exception { final model node node = attr . resolve model attribute ( context , model ) ; return node . is defined ( ) ? node . as string ( ) : null ; }	Return null if the resolved attribute is not defined.
static int get pattern type ( string url pattern ) { int type = exact ; if ( url pattern . starts with ( str ) ) type = extension ; else if ( url pattern . starts with ( str ) && url pattern . ends with ( str ) ) type = prefix ; else if ( url pattern . equals ( str ) ) type = default ; return type ; }	Determine the url-pattern type.
static boolean targets pooled connection factory ( string server , string resource adapter , service registry service registry ) {	Return whether the definition targets an existing pooled connection factory or use a JCA-based ConnectionFactory.Checks the service registry for a PooledConnectionFactoryService with the ServiceNamecreated by the {.
static boolean targets external pooled connection factory ( string resource adapter , service registry service registry ) {	Return whether the definition targets an existing external pooled connection factory.Checks the service registry for a PooledConnectionFactoryService with the ServiceNamecreated by the {.
static string get active mq ( map < string , string > properties ) { return properties . get or default ( server , default ) ; }	The JMS connection factory can specify another server to deploy its destinationsby passing a property server=&lt;name of the server>.
private static string default persistence unit name ( string persistence unit name , persistence unit metadata holder holder ) { if ( ( persistence unit name == null || persistence unit name . length ( ) == num ) ) { for ( persistence unit metadata persistence unit : holder . get persistence units ( ) ) { string default pu = persistence unit . get properties ( ) . get property ( configuration . jpa default persistence unit ) ; if ( boolean . true . to string ( ) . equals ( default pu ) ) { persistence unit name = persistence unit . get persistence unit name ( ) ; } } } return persistence unit name ; }	if no persistence unit name is specified, return name of default persistence unit.
public void start ( start context context ) { final suspend controller suspend controller = suspend controller injected value . get value ( ) ; suspend controller . register activity ( this ) ; final local transaction context local transaction context = local transaction context injected value . get value ( ) ; local transaction context . register creation listener ( this ) ; }	Starts the service. Registers server activity, sets transaction listener on local transaction context, and creates andinstalls deployment controller service.
public void stop ( stop context context ) { final suspend controller suspend controller = suspend controller injected value . get value ( ) ; suspend controller . un register activity ( this ) ; final local transaction context local transaction context = local transaction context injected value . get value ( ) ; local transaction context . remove creation listener ( this ) ; }	Stops the service. Unregisters service activity and clears transaction listener.
@ override public void suspended ( server activity callback listener ) { this . suspended = bool ; listener updater . set ( this , listener ) ; local transaction context injected value . get value ( ) . suspend requests ( ) ; final int active invocation count = active invocation count updater . get ( this ) ; if ( active invocation count == num ) { if ( graceful txn shutdown ) { if ( active transaction count updater . get ( this ) == num ) { this . done suspended ( ) ; } else { ejb logger . root logger . suspension waiting active transactions ( active invocation count ) ; } } else { this . done suspended ( ) ; } } }	Notifies local transaction context that server is suspended, and only completes suspension ifthere are no active invocations nor transactions.
@ override public void resume ( ) { this . suspended = bool ; local transaction context injected value . get value ( ) . resume requests ( ) ; server activity callback listener = listener updater . get ( this ) ; if ( listener != null ) { listener updater . compare and set ( this , listener , null ) ; } deployment repository injected value . get value ( ) . resume ( ) ; }	Notifies local transaction context that server is resumed, and restarts deployment controller.
public void invocation complete ( ) { int active invocations = active invocation count updater . decrement and get ( this ) ; if ( suspended && active invocations == num && ( ! graceful txn shutdown || ( active transaction count updater . get ( this ) == num ) ) ) { done suspended ( ) ; } }	Notifies handler that an active invocation is complete.
@ override public void transaction created ( abstract transaction transaction , created by created by ) { active transaction count updater . increment and get ( this ) ; try { transaction . register synchronization ( this ) ; } catch ( rollback exception | illegal state exception e ) {	Notifies handler that a new transaction has been created.
public void start ( start context context ) throws start exception { final service based naming store naming store = naming store value . get value ( ) ; controller = context . get controller ( ) ; naming store . add ( controller . get name ( ) ) ; root logger . tracef ( str , name , naming store , controller . get name ( ) ) ; }	Bind the entry into the injected context.
public void stop ( stop context context ) { final service based naming store naming store = naming store value . get value ( ) ; naming store . remove ( controller . get name ( ) ) ; root logger . tracef ( str , name , naming store , context . get controller ( ) . get name ( ) ) ; }	Unbind the entry from the injected context.
public static service name get capability service name ( string capability base name , string ... dynamic parts ) { if ( capability service support == null ) { throw new illegal state exception ( ) ; } if ( dynamic parts == null || dynamic parts . length == num ) { return capability service support . get capability service name ( capability base name ) ; } return capability service support . get capability service name ( capability base name , dynamic parts ) ; }	Determines a ServiceName from a capability name.
private list < resource root > create resource roots ( final virtual file deployment root , final deployment unit deployment unit ) throws io , deployment unit processing exception { final list < resource root > entries = new array list < resource root > ( ) ;	Create the resource roots for a .war deployment.
private static set < class loader > all deployment module class loaders ( deployment unit deployment unit ) { set < class loader > deployment class loaders = new hash set < class loader > ( ) ; final deployment unit top deployment unit = deployment utils . get top deployment unit ( deployment unit ) ; final module toplevel module = top deployment unit . get attachment ( attachments . module ) ; if ( toplevel module != null ) { deployment class loaders . add ( toplevel module . get class loader ( ) ) ; final list < deployment unit > sub deployments = top deployment unit . get attachment list ( attachments . sub deployments ) ; for ( deployment unit sub deployment unit : sub deployments ) { final module sub deployment module = sub deployment unit . get attachment ( attachments . module ) ; if ( sub deployment module != null ) { deployment class loaders . add ( sub deployment module . get class loader ( ) ) ; } } } return deployment class loaders ; }	returns the toplevel deployment module classloader and all subdeployment classloaders.
public static boolean need class file transformer ( persistence unit metadata pu ) { boolean result = bool ; string provider = pu . get persistence provider class name ( ) ; if ( pu . get properties ( ) . contains key ( configuration . jpa container class transformer ) ) { result = boolean . parse boolean ( pu . get properties ( ) . get property ( configuration . jpa container class transformer ) ) ; } else if ( is hibernate provider ( provider ) ) { result = ( boolean . true . to string ( ) . equals ( pu . get properties ( ) . get property ( hibernate use class enhancer ) ) || boolean . true . to string ( ) . equals ( pu . get properties ( ) . get property ( hibernate enable dirty tracking ) ) || boolean . true . to string ( ) . equals ( pu . get properties ( ) . get property ( hibernate enable lazy initialization ) ) || boolean . true . to string ( ) . equals ( pu . get properties ( ) . get property ( hibernate enable association management ) ) ) ; } return result ; }	Determine if class file transformer is needed for the specified persistence unitif the persistence provider is Hibernate and use_class_enhancer is not true, don't need a class transformer.for other persistence providers, the transformer is assumed to be needed.
public static boolean allow two phase bootstrap ( persistence unit metadata pu ) { boolean result = bool ; if ( ee default datasource . equals ( pu . get jta data source name ( ) ) ) { result = bool ; } if ( pu . get properties ( ) . contains key ( configuration . jpa allow two phase bootstrap ) ) { result = boolean . parse boolean ( pu . get properties ( ) . get property ( configuration . jpa allow two phase bootstrap ) ) ; } return result ; }	Determine if two phase persistence unit start is allowed.
public static boolean allow default data source use ( persistence unit metadata pu ) { boolean result = bool ; if ( pu . get properties ( ) . contains key ( configuration . jpa allow default data source use ) ) { result = boolean . parse boolean ( pu . get properties ( ) . get property ( configuration . jpa allow default data source use ) ) ; } return result ; }	Determine if the default data-source should be used.
public static boolean skip mixed synchronization type check ( entity manager factory emf , map target entity manager properties ) { boolean result = bool ;	Allow the mixed synchronization checking to be skipped for backward compatibility with WildFly 10.1.0.
public static orb get orb ( string server , int port , hashtable env ) {	Get ORB using given server and port number, and properties from environment.
private static orb init applet orb ( object applet , properties orb prop ) { try { class < ? > applet class = class . for name ( str , bool , null ) ; if ( ! applet class . is instance ( applet ) ) { throw new class cast exception ( applet . get class ( ) . get name ( ) ) ; }	This method returns a new ORB instance for the given appletwithout creating a static dependency on java.applet.
private static void init method handles ( ) throws class not found exception {	Initializes reflection method handles for RMI-IIOP.
public static void set active naming store ( final naming store naming store ) { if ( wild fly security manager . is checking ( ) ) { system . get security manager ( ) . check permission ( set active naming store ) ; } active naming store = naming store ; }	Set the active naming store.
private void validate default values ( list < param detail > detail list , hash map < string , list < validator > > param converter map ) throws deployment unit processing exception { for ( param detail detail : detail list ) {	Process all parameter DefaulValue objects.
private class check param type ( type gen param type , final method method , final int param pos , final class loader class loader ) { class param clazz = null ; if ( gen param type instanceof parameterized type ) { parameterized type p type = ( parameterized type ) gen param type ; type [ ] actual type args = p type . get actual type arguments ( ) ;	Take steps to properly identify the parameter's data type.
private default value lookup default value ann ( annotation [ ] annotation arr ) { for ( annotation ann : annotation arr ) { if ( ann instanceof default value ) { return ( default value ) ann ; } } return null ; }	Extract a DefaultValue annotation from the list of parameter annotations.
private void validate base type ( method method , string default value , param detail detail ) throws deployment unit processing exception { if ( default value != null ) { try { method . invoke ( method . get declaring class ( ) , default value ) ; } catch ( exception e ) { jaxrs logger . base type method failed ( default value , detail . parameter . get simple name ( ) , detail . method . to string ( ) , method . to string ( ) , e . get class ( ) . get name ( ) , e . get message ( ) ) ; } } }	Confirm the method can handle the default value without throwingand exception.
public static extended entity manager [ ] get deferred entity managers ( ) { list < extended entity manager > store = defer to post construct . get ( ) ; try { if ( store . is empty ( ) ) { return empty ; } else { return store . to array ( new extended entity manager [ store . size ( ) ] ) ; } } finally { store . clear ( ) ; } }	Called by postconstruct interceptor.
public static string status as string ( int status ) { if ( status >= status . status active && status <= status . status rolling back ) { return tx status strings [ status ] ; } else { return str + status + str ; } }	Converts a tx Status index to a String.
public static void add cache dependencies ( classification cache type , properties properties ) { for ( event listener event listener : event listeners ) { event listener . add cache dependencies ( cache type , properties ) ; } }	add cache dependencies.
private void extract dialects ( ) { for ( object prop : sql . key set ( ) ) { int dot = ( ( string ) prop ) . index of ( str ) ; if ( dot > num ) { database dialects . add ( ( ( string ) prop ) . substring ( dot + num ) ) ; } } }	Read the properties from the timer-sql and extract the database dialects.
private void investigate dialect ( ) { connection connection = null ; if ( database == null ) {	Check the connection MetaData and driver name to guess which database dialectto use.
private string identify dialect ( string name ) { string unified = null ; if ( name != null ) { if ( name . to lower case ( ) . contains ( str ) ) { unified = str ; } else if ( name . to lower case ( ) . contains ( str ) ) { unified = str ; } else if ( name . to lower case ( ) . contains ( str ) ) { unified = str ; } else if ( name . to lower case ( ) . contains ( str ) ) { unified = str ; } else if ( name . to lower case ( ) . contains ( str ) || name . to lower case ( ) . contains ( str ) ) { unified = str ; } else if ( name . to lower case ( ) . contains ( str ) ) { unified = str ; } else if ( name . to lower case ( ) . contains ( str ) ) { unified = str ; } else if ( name . to lower case ( ) . contains ( str ) ) { unified = str ; } else if ( name . to lower case ( ) . contains ( str ) ) { unified = str ; } } ejb logger . ej timer logger . debugf ( str , name , unified ) ; return unified ; }	Use the given name and check for different database types to have a unified identifier for the dialect.
private void check database ( ) { string load timer = sql ( load timer ) ; connection connection = null ; statement statement = null ; prepared statement prepared statement = null ; result set result set = null ; try {	Checks whether the database transaction configuration is appropriateand create the timer table if necessary.
private date string as scheduler date ( final string date , final string timer id ) { if ( date == null ) { return null ; } try { return new simple date format ( scheduler date format ) . parse ( date ) ; } catch ( parse exception e ) { ejb logger . ej timer logger . schedule expression date from timer persistence invalid ( timer id , e . get message ( ) ) ; return null ; } }	Convert the stored date-string from database back to Date.
private void set node name ( final timer state timer state , prepared statement statement , int param index ) throws sql { if ( timer state == timer state . in timeout || timer state == timer state . retry timeout ) { statement . set string ( param index , node name ) ; } else { statement . set null ( param index , types . varchar ) ; } }	Set the node name for persistence if the state is IN_TIMEOUT or RETRY_TIMEOUT to show which node is current active for the timer.
public static void mark ( deployment unit unit ) { unit . put attachment ( marker , boolean . true ) ; if ( unit . get parent ( ) != null ) { mark ( unit . get parent ( ) ) ; } }	Mark this deployment and the top level deployment as being a weld deployment.
public object [ ] read params ( input stream in ) { int len = param readers . length ; object [ ] params = new object [ len ] ; for ( int i = num ; i < len ; i ++ ) { params [ i ] = param readers [ i ] . read ( in ) ; } return params ; }	Unmarshals the sequence of method parameters from an input stream.
public void write retval ( output stream out , object ret val ) { retval writer . write ( out , remote object substitution manager . write replace remote ( ret val ) ) ; }	Marshals into an output stream the return value of the method.
public void write exception ( output stream out , throwable e ) { int len = excep writers . length ; for ( int i = num ; i < len ; i ++ ) { if ( excep writers [ i ] . get exception class ( ) . is instance ( e ) ) { excep writers [ i ] . write ( out , e ) ; return ; } } throw new unknown exception ( e ) ; }	Marshals into an output stream an exception thrown by the method.
protected < u > u lookup ( lookup < u > lookup , int start , int depth ) { int size ; synchronized ( indexes ) { size = indexes . size ( ) ; for ( int i = start ; i < depth && i < size ; i ++ ) { u result = lookup . lookup ( indexes . get ( i ) ) ; if ( result != null ) return result ; } } if ( current class == null ) return null ; synchronized ( indexes ) { class reflection index cri = index . get class index ( current class ) ; indexes . add ( cri ) ; current class = current class . get superclass ( ) ; } return lookup ( lookup , size , depth ) ; }	Do lazy lookup.
public static void begin sfsb creation ( ) { sfsb data = current . get ( ) ; int no = data . creation bean nesting level ; if ( no == num ) { data . creation time xpc = new hash map < string , extended entity manager > ( ) ;	called from SFSBPreCreateInterceptor, before bean creation.
public static void end sfsb creation ( ) { sfsb data = current . get ( ) ; int no = data . creation bean nesting level ; no -- ; data . creation bean nesting level = no ; if ( no == num ) {	called from SFSBPreCreateInterceptor, after bean creation.
public static map < string , extended entity manager > current sfsb ( ) { array list < map < string , extended entity manager > > stack = current . get ( ) . invocation stack ; if ( stack != null && stack . size ( ) > num ) { return stack . get ( stack . size ( ) - num ) ; } return null ; }	return for just the current entity manager invocation.
public static void push call ( map < string , extended entity manager > entity managers ) { current sfsb ( ) . add ( entity managers ) ; if ( entity managers != null ) { for ( extended entity manager extended entity manager : entity managers . values ( ) ) { extended entity manager . internal associate with jta tx ( ) ; } } }	Push the passed SFSB context handle onto the invocation call stack.
public static map < string , extended entity manager > pop call ( ) { array list < map < string , extended entity manager > > stack = current sfsb ( ) ; map < string , extended entity manager > result = stack . remove ( stack . size ( ) - num ) ; stack . trim to size ( ) ; return result ; }	Pops the current SFSB invocation off the invocation call stack.
static map < string , extended entity manager > get current call ( ) { array list < map < string , extended entity manager > > stack = current sfsb ( ) ; map < string , extended entity manager > result = null ; if ( stack != null ) { result = stack . get ( stack . size ( ) - num ) ; } return result ; }	gets the current SFSB invocation off the invocation call stack.
public void deploy ( deployment phase context phase context ) throws deployment unit processing exception { final deployment unit deployment unit = phase context . get deployment unit ( ) ; final module specification module specification = deployment unit . get attachment ( attachments . module specification ) ; final module loader module loader = module . get boot module loader ( ) ; add dependency ( module specification , module loader , javax enterprise api ) ; add dependency ( module specification , module loader , javax inject api ) ; if ( ! weld deployment marker . is part of weld deployment ( deployment unit ) ) { return ;	Add dependencies for modules required for weld deployments, if managed weld configurations are attached to the deployment.
public static string get type idl ( class cls ) throws rmiiiop { if ( cls . is primitive ( ) ) return primitive analysis . get primitive analysis ( cls ) . get idl ( ) ; if ( cls . is array ( ) ) {	Return the IDL type name for the given class.Here we use the mapping for parameter types and return values.
public static void insert any primitive ( any any , object primitive ) { class type = primitive . get class ( ) ; if ( type == boolean . class ) any . insert boolean ( ( ( boolean ) primitive ) . boolean value ( ) ) ; else if ( type == character . class ) any . insert wchar ( ( ( character ) primitive ) . char value ( ) ) ; else if ( type == byte . class ) any . insert octet ( ( ( byte ) primitive ) . byte value ( ) ) ; else if ( type == short . class ) any . insert short ( ( ( short ) primitive ) . short value ( ) ) ; else if ( type == integer . class ) any . insert long ( ( ( integer ) primitive ) . int value ( ) ) ; else if ( type == long . class ) any . insert longlong ( ( ( long ) primitive ) . long value ( ) ) ; else if ( type == float . class ) any . insert float ( ( ( float ) primitive ) . float value ( ) ) ; else if ( type == double . class ) any . insert double ( ( ( double ) primitive ) . double value ( ) ) ; else throw iiop . root logger . not a ( type . get name ( ) ) ; }	Insert a java primitive into an Any.The primitive is assumed to be wrapped in one of the primitivewrapper classes.
public static string java to idl ( string name ) { if ( name == null || str . equals ( name ) || name . index of ( str ) != - num ) throw iiop . root logger . name cannot be null empty or qualified ( ) ; string buffer res = new string buffer ( name . length ( ) ) ; if ( name . char at ( num ) == str ) res . append ( str ) ;	Map Java name to IDL name, as per sections 1.3.2.3, 1.3.2.4 and1.3.2.2.This only works for a single name component, without a qualifyingdot.
private static boolean is reserved idl ( string s ) {	Determine if the argument is a reserved IDL keyword.
private static string get signature ( class cls ) { if ( cls . is array ( ) ) return str + cls . get component type ( ) ; if ( cls . is primitive ( ) ) { if ( cls == byte . type ) return str ; if ( cls == character . type ) return str ; if ( cls == double . type ) return str ; if ( cls == float . type ) return str ; if ( cls == integer . type ) return str ; if ( cls == long . type ) return str ; if ( cls == short . type ) return str ; if ( cls == boolean . type ) return str ; throw iiop . root logger . unknown primitive type ( cls . get name ( ) ) ; } return str + cls . get name ( ) . replace ( str , str ) + str ; }	Calculate the signature of a class, according to the Java VMspecification, section 4.3.2.
private static string get signature ( method method ) { string buffer b = new string buffer ( str ) ; class [ ] parameter types = method . get parameter types ( ) ; for ( int i = num ; i < parameter types . length ; ++ i ) b . append ( get signature ( parameter types [ i ] ) ) ; b . append ( str ) . append ( get signature ( method . get return type ( ) ) ) ; return b . to string ( ) ; }	Calculate the signature of a method, according to the Java VMspecification, section 4.3.3.
static string primitive type idl ( class type ) { if ( type == void . type ) return str ; if ( type == boolean . type ) return str ; if ( type == character . type ) return str ; if ( type == byte . type ) return str ; if ( type == short . type ) return str ; if ( type == integer . type ) return str ; if ( type == long . type ) return str ; if ( type == float . type ) return str ; if ( type == double . type ) return str ; throw iiop . root logger . not a ( type . get name ( ) ) ; }	Handle mappings for primitive types, as per section 1.3.3.
public static batch permission for name ( final string name ) { assert . check not null param ( str , name ) ; return str . equals ( name ) ? all permission : mapping . get item by string ( name ) ; }	Get the permission with the given name.
private entity manager get or create transaction scoped entity manager ( final entity manager factory emf , final string scoped pu name , final map properties , final synchronization type synchronization type ) { entity manager entity manager = transaction util . get transaction scoped entity manager ( pu scoped name , transaction synchronization registry ) ; if ( entity manager == null ) { entity manager = create entity manager ( emf , properties , synchronization type ) ; if ( root logger . is debug enabled ( ) ) { root logger . debugf ( str , transaction util . get entity manager details ( entity manager , scoped pu name ) , transaction util . get transaction ( transaction manager ) . to string ( ) ) ; } transaction util . register synchronization ( entity manager , scoped pu name , transaction synchronization registry , transaction manager ) ; transaction util . put entity manager in transaction registry ( scoped pu name , entity manager , transaction synchronization registry ) ; } else { test for mixed synchronization types ( emf , entity manager , pu scoped name , synchronization type , properties ) ; if ( root logger . is debug enabled ( ) ) { root logger . debugf ( str , transaction util . get entity manager details ( entity manager , scoped pu name ) , transaction util . get transaction ( transaction manager ) . to string ( ) ) ; } } return entity manager ; }	get or create a Transactional entity manager.Only call while a transaction is active in the current thread.
public v put ( k key , v value ) { if ( value == null ) throw new null pointer exception ( ) ; int hash = hash of ( key ) ; return segment for ( hash ) . put ( key , hash , value , bool ) ; }	Maps the specified key to the specified value in this table.Neither the key nor the value can be null.
static model node convert security role ( final model node camel case ) { final model node result = new model node ( ) ; result . set empty list ( ) ; if ( camel case . is defined ( ) ) { for ( model node role : camel case . as list ( ) ) { final model node role node = result . add ( ) ; for ( property prop : role . as property list ( ) ) { string key = prop . get name ( ) ; if ( str . equals ( key ) ) { key = security role definition . create durable queue . get name ( ) ; } else if ( str . equals ( key ) ) { key = security role definition . delete durable queue . get name ( ) ; } else if ( str . equals ( key ) ) { key = security role definition . create non durable queue . get name ( ) ; } else if ( str . equals ( key ) ) { key = security role definition . delete non durable queue . get name ( ) ; } role node . get ( key ) . set ( prop . get value ( ) ) ; } } } return result ; }	Utility for converting camel case based ActiveMQ formats to WildFly standards.
private timer impl most recent entity version ( final timer impl timer impl ) { try { final int status = context transaction manager . get instance ( ) . get status ( ) ; if ( status == status . status unknown || status == status . status no transaction ) { return timer impl ; } final string key = timer transaction key ( timer impl ) ; timer impl existing = ( timer impl ) transaction synchronization registry . get value ( ) . get resource ( key ) ; return existing != null ? existing : timer impl ; } catch ( system exception e ) { throw new runtime exception ( e ) ; } }	Returns either the loaded entity or the most recent version of the entity that hasbeen persisted in this transaction.
private map < string , timer impl > get timers ( final string timed object id , final timer service impl timer service ) { return load timers from file ( timed object id , timer service ) ; }	Gets the timer map, loading from the persistent store if necessary. Should be called under lock.
private string get directory ( string timed object id ) { string dir name = directories . get ( timed object id ) ; if ( dir name == null ) { dir name = base dir . get absolute path ( ) + file . separator + timed object id . replace ( file . separator , str ) ; file file = new file ( dir name ) ; if ( ! file . exists ( ) ) { if ( ! file . mkdirs ( ) ) { ej timer logger . fail to create directory for persist timers ( file ) ; } } directories . put ( timed object id , dir name ) ; } return dir name ; }	Gets the directory for a given timed object, making sure it exists.
synchronized void add listener ( final string target , final int scope , final naming listener naming listener ) { final target scope target scope = new target scope ( target , scope ) ;	Add a listener to the coordinator with a given target name and event scope.
synchronized void remove listener ( final naming listener naming listener ) {	Remove a listener. Will remove it from all target mappings. Once this method returns, the listener will no longerreceive any events.
void fire event ( final event context context , final name name , final binding existing binding , final binding new binding , int type , final string change info , final integer ... scopes ) { final string target = name . to string ( ) ; final set < integer > scope set = new hash set < integer > ( arrays . as list ( scopes ) ) ; final naming event event = new naming event ( context , type , new binding , existing binding , change info ) ; final set < listener holder > holders to fire = new hash set < listener holder > ( ) ;	Fire a naming event.
public static < t extends auto closeable > consumer < t > close ( ) { return value -> { try { value . close ( ) ; } catch ( throwable e ) { clustering logger . root logger . failed to close ( e , value ) ; } } ; }	Returns a consumer that closes its input.
private void add private credential ( final subject subject , final object credential ) { if ( ! wild fly security manager . is checking ( ) ) { subject . get private credentials ( ) . add ( credential ) ; } else { access controller . do privileged ( ( privileged action < void > ) ( ) -> { subject . get private credentials ( ) . add ( credential ) ; return null ; } ) ; } }	Add the specified credential to the subject's private credentials set.
public object get object instance ( final object ref , final name name , final context name ctx , final hashtable < ? , ? > environment ) throws exception { final class loader class loader = wild fly security manager . get current context class loader privileged ( ) ; if ( class loader == null ) { return ref ; } final string factories prop = ( string ) environment . get ( context . object factories ) ; if ( factories prop != null ) { final string [ ] classes = factories prop . split ( str ) ; for ( string class name : classes ) { try { final class < ? > factory class = class loader . load class ( class name ) ; final object factory object factory = object factory . class . cast ( factory class . new instance ( ) ) ; final object result = object factory . get object instance ( ref , name , name ctx , environment ) ; if ( result != null ) { return result ; } } catch ( throwable ignored ) { } } } return ref ; }	Create an object instance.
protected static void add tx management interceptor for view ( view description view ) {	Sets up the transaction management interceptor for all methods of the passed view.
private static void subst ( final string builder string builder , final string from , final string to ) { int begin = num , end = num ; while ( ( end = string builder . index of ( from , end ) ) != - num ) { string builder . delete ( end , end + from . length ( ) ) ; string builder . insert ( end , to ) ;	Substitute sub-strings inside of a string.
private transport configuration create in vm ( operation context context ) throws operation failed exception { final resource server resource = context . read resource ( empty address , bool ) ; set < resource . resource entry > invm connectors = server resource . get children ( common attributes . in vm connector ) ; if ( invm connectors . is empty ( ) ) { throw messaging logger . root logger . no in vm ( ) ; } resource . resource entry connector entry = invm connectors . iterator ( ) . next ( ) ; resource connector resource = context . read resource ( path address . path address ( connector entry . get path element ( ) ) , bool ) ; model node model = connector resource . get model ( ) ; map < string , object > params = new hash map < > ( common attributes . params . unwrap ( context , model ) ) ; params . put ( vm . server id . get name ( ) , vm . server id . resolve model attribute ( context , model ) . as int ( ) ) ; transport configuration transport configuration = new transport configuration ( vm . class . get name ( ) , params ) ; return transport configuration ; }	The XmlDataImporter requires a connector to connect to the artemis broker.We require to use a in-vm one so that importing a journal is not subject to any network connection problem.
private string add ear prefix if relative name ( final string configured name , final deployment unit deployment unit , final class < ? > component class ) throws deployment unit processing exception { if ( ! configured name . starts with ( str ) ) { return configured name ; } final deployment unit parent = deployment unit . get parent ( ) ; if ( parent == null ) { throw ejb logger . root logger . relative resource adapter name in standalone module ( deployment unit . get name ( ) , component class . get name ( ) , configured name ) ; } return new string builder ( ) . append ( parent . get name ( ) ) . append ( configured name ) . to string ( ) ; }	adds ear prefix to configured adapter name if it is specified in relative form.
public static deployment unit get root deployment unit ( deployment unit deployment unit ) { if ( deployment unit . get parent ( ) == null ) { return deployment unit ; } return deployment unit . get parent ( ) ; }	Returns the parent of the given deployment unit if such a parent exists.
public service name get service name ( ) {	Get the service name for this view.
public view configuration create view configuration ( final class < ? > view class , final component configuration component configuration , final proxy factory < ? > proxy factory ) { return new view configuration ( view class , component configuration , get service name ( ) , proxy factory ) ; }	Creates view configuration. Allows for extensibility in EE sub components.
protected injection source create injection source ( final service name service name , value < class loader > view class loader , boolean appclient ) { return new view binding injection source ( service name ) ; }	Create the injection source.
public list < interceptor factory > get view interceptors ( method method ) { ordered item container < interceptor factory > container = view interceptors . get ( method ) ; if ( container == null ) { return collections . empty list ( ) ; } return container . get sorted items ( ) ; }	Get the view interceptors for a method.
public void add view interceptor ( interceptor factory interceptor factory , int priority ) { for ( method method : proxy factory . get cached methods ( ) ) { add view interceptor ( method , interceptor factory , priority ) ; } }	Adds an interceptor factory to all methods of a view.
public void add view interceptor ( method method , interceptor factory interceptor factory , int priority ) { ordered item container < interceptor factory > container = view interceptors . get ( method ) ; if ( container == null ) { view interceptors . put ( method , container = new ordered item container < interceptor factory > ( ) ) ; } container . add ( interceptor factory , priority ) ; }	Adds a view interceptor to the given method.
public list < interceptor factory > get client interceptors ( method method ) { ordered item container < interceptor factory > container = client interceptors . get ( method ) ; if ( container == null ) { return collections . empty list ( ) ; } return container . get sorted items ( ) ; }	Get the client interceptors for a method.
public void add client interceptor ( interceptor factory interceptor factory , int priority ) { for ( method method : proxy factory . get cached methods ( ) ) { add client interceptor ( method , interceptor factory , priority ) ; } }	Adds a client interceptor factory to all methods of a view.
public void add client interceptor ( method method , interceptor factory interceptor factory , int priority ) { ordered item container < interceptor factory > container = client interceptors . get ( method ) ; if ( container == null ) { client interceptors . put ( method , container = new ordered item container < interceptor factory > ( ) ) ; } container . add ( interceptor factory , priority ) ; }	Adds a client interceptor to the given method.
public < t > void put private data ( final class < t > type , t data ) { private data . put ( type , data ) ; }	Attaches arbitrary private data to this view instance.
protected static void unexpected element ( final xml reader ) throws xml { throw ee logger . root logger . unexpected element ( reader . get name ( ) , reader . get location ( ) ) ; }	Throws a XMLStreamException for the unexpected element that was encountered during the parse.
public static list < ejb > get jaxws ejbs ( final deployment unit unit ) { final jaxws jaxws deployment = get optional attachment ( unit , ws . jaxws endpoints key ) ; return jaxws deployment != null ? jaxws deployment . get ejb endpoints ( ) : collections . < ejb > empty list ( ) ; }	Gets list of JAXWS EJBs meta data.
public static list < pojo > get jaxws pojos ( final deployment unit unit ) { final jaxws jaxws deployment = unit . get attachment ( ws . jaxws endpoints key ) ; return jaxws deployment != null ? jaxws deployment . get pojo endpoints ( ) : collections . < pojo > empty list ( ) ; }	Gets list of JAXWS POJOs meta data.
public static string get endpoint name ( final servlet meta data servlet md ) { final string endpoint name = servlet md . get name ( ) ; return endpoint name != null ? endpoint name . trim ( ) : null ; }	Returns endpoint name.
public static string get endpoint class name ( final servlet meta data servlet md ) { final string endpoint class = servlet md . get servlet class ( ) ; return endpoint class != null ? endpoint class . trim ( ) : null ; }	Returns endpoint class name.
public static servlet meta data get servlet for name ( final j jboss web md , final string servlet name ) { for ( j servlet : jboss web md . get servlets ( ) ) { if ( servlet . get name ( ) . equals ( servlet name ) ) { return servlet ; } } return null ; }	Returns servlet meta data for requested servlet name.
public static < a > a get required attachment ( final deployment unit unit , final attachment key < a > key ) { final a value = unit . get attachment ( key ) ; if ( value == null ) { throw new illegal state exception ( ) ; } return value ; }	Returns required attachment value from deployment unit.
public static < a > a get optional attachment ( final deployment unit unit , final attachment key < a > key ) { return unit . get attachment ( key ) ; }	Returns optional attachment value from deployment unit or null if not bound.
public static j get j ( final deployment unit unit ) { final war meta data war meta data = get optional attachment ( unit , war meta data . attachment key ) ; j result = null ; if ( war meta data != null ) { result = war meta data . get merged j ( ) ; if ( result == null ) { result = war meta data . get j ( ) ; } } else { result = get optional attachment ( unit , ws . jbossweb metadata key ) ; } return result ; }	Gets the JBossWebMetaData from the WarMetaData attached to the provided deployment unit, if any.
public static j get j ( final deployment unit unit , final string name ) { if ( name != null ) { final j jboss webservice meta data = unit . get attachment ( jboss webservices metadata key ) ; if ( jboss webservice meta data != null ) { j [ ] port component = jboss webservice meta data . get port components ( ) ; if ( port component != null ) { for ( j component : port component ) { if ( name . equals ( component . get ejb name ( ) ) ) { return component ; } } } } } return null ; }	Return a named port-component from the jboss-webservices.xml.
public static ejb get webservice metadata ejb ( final jaxws jaxws deployment , final string class name ) { java . util . list < ejb > ejb endpoint list = jaxws deployment . get ejb endpoints ( ) ; for ( ejb ejb endpoint : ejb endpoint list ) { if ( class name . equals ( ejb endpoint . get class name ( ) ) ) { return ejb endpoint ; } } return null ; }	Returns an EJBEndpoint based upon fully qualified classname.
public static string get context root ( final deployment dep , final j jboss web md ) { final deployment unit unit = ws . get required attachment ( dep , deployment unit . class ) ; final j jboss app md = unit . get parent ( ) == null ? null : as . get optional attachment ( unit . get parent ( ) , ws . jboss app metadata key ) ; string context root = null ;	Returns context root associated with webservice deployment.If there's application.xml descriptor provided defining nested web module, then context root defined there will bereturned.
@ override public class < ? > class for name ( string name ) { try { if ( classes . contains key ( name ) ) { return classes . get ( name ) ; } final class < ? > clazz = module . get class loader ( ) . load class ( name ) ; classes . put ( name , clazz ) ; return clazz ; } catch ( class not found exception | linkage error e ) { throw new resource loading exception ( e ) ; } }	If the class name is found in additionalClasses then return it.Otherwise the class will be loaded from the module ClassLoader.
@ override public url get resource ( string name ) { try { return module . get class loader ( ) . get resource ( name ) ; } catch ( exception e ) { throw new resource loading exception ( e ) ; } }	Loads a resource from the module class loader.
@ override public collection < url > get resources ( string name ) { try { final hash set < url > resources = new hash set < url > ( ) ; enumeration < url > urls = module . get class loader ( ) . get resources ( name ) ; while ( urls . has more elements ( ) ) { resources . add ( urls . next element ( ) ) ; } return resources ; } catch ( exception e ) { throw new resource loading exception ( e ) ; } }	Loads resources from the module class loader.
public list < resource > list ( string path ) { try { final list < resource > ret = new array list < > ( ) ; resource res = deployment resource manager . get resource ( path ) ; if ( res != null ) { for ( resource child : res . list ( ) ) { ret . add ( new servlet resource ( this , child ) ) ; } } string p = path ; if ( p . starts with ( str ) ) { p = p . substring ( num ) ; } if ( overlays != null ) { for ( virtual file overlay : overlays ) { virtual file child = overlay . get child ( p ) ; if ( child . exists ( ) ) { virtual file resource vfs resource = new virtual file resource ( overlay . get physical file ( ) , child , path ) ; for ( resource c : vfs resource . list ( ) ) { ret . add ( new servlet resource ( this , c ) ) ; } } } } return ret ; } catch ( io e ) { throw new runtime exception ( e ) ;	Lists all children of a particular path, taking overlays into account.
public static void pop call ( ) { map < string , entity manager > em stack = non tx stack . pop ( ) ; if ( em stack != null ) { for ( entity manager entity manager : em stack . values ( ) ) { try { if ( entity manager . is open ( ) ) { entity manager . close ( ) ; } } catch ( runtime exception safe to ignore ) { if ( root logger . is trace enabled ( ) ) { root logger . trace ( str + str + str , safe to ignore ) ; } } } } }	current session bean invocation is ending, close any transactional entity managers created without a JTAtransaction.
public static entity manager get ( string pu scoped name ) { map < string , entity manager > map = non tx stack . peek ( ) ; if ( map != null ) { return map . get ( pu scoped name ) ; } return null ; }	Return the transactional entity manager for the specified scoped persistence unit name.
void register clean up listener ( transaction synchronization registry transaction synchronization registry , jms context instance ) {	Closing of transaction scoped JMSContext is executed through Synchronization listener.This method registers listener, which takes care of closing JMSContext.
public void deploy ( final deployment phase context phase context ) throws deployment unit processing exception { final deployment unit deployment unit = phase context . get deployment unit ( ) ; if ( ! deployment type marker . is type ( deployment type . war , deployment unit ) ) { return ;	Process web annotations.
public static boolean is all fields public ( class c ) { try { final field [ ] list = c . get fields ( ) ; for ( int i = num ; i < list . length ; i ++ ) if ( ! modifier . is public ( list [ i ] . get modifiers ( ) ) ) return bool ; } catch ( exception e ) { return bool ; } return bool ; }	Checks whether all the fields in the class are declared as public.
protected final endpoint new http endpoint ( final string endpoint class , final string endpoint name , final deployment dep ) { if ( endpoint name == null ) throw ws . root logger . null endpoint name ( ) ; if ( endpoint class == null ) throw ws . root logger . null endpoint class ( ) ; final endpoint endpoint = this . deployment model factory . new http endpoint ( endpoint class ) ; endpoint . set short name ( endpoint name ) ; endpoint . set type ( endpoint type ) ; dep . get service ( ) . add endpoint ( endpoint ) ; return endpoint ; }	Creates new Http Web Service endpoint.
private archive deployment new deployment ( final deployment unit unit ) { ws . root logger . tracef ( str , unit ) ; final resource root deployment root = unit . get attachment ( attachments . deployment root ) ; final virtual file root = deployment root != null ? deployment root . get root ( ) : null ; final class loader class loader ; final module module = unit . get attachment ( attachments . module ) ; if ( module == null ) { class loader = unit . get attachment ( classloader key ) ; if ( class loader == null ) { throw ws . root logger . class loader resolution failed ( unit ) ; } } else { class loader = module . get class loader ( ) ; } archive deployment parent dep = null ; if ( unit . get parent ( ) != null ) { final module parent module = unit . get parent ( ) . get attachment ( attachments . module ) ; if ( parent module == null ) { throw ws . root logger . class loader resolution failed ( deployment root ) ; } ws . root logger . tracef ( str , unit . get parent ( ) ) ; parent dep = this . new deployment ( null , unit . get parent ( ) . get name ( ) , parent module . get class loader ( ) , null ) ; } final unified virtual file uvf = root != null ? new virtual file adaptor ( root ) : new resource loader adapter ( class loader ) ; final archive deployment dep = this . new deployment ( parent dep , unit . get name ( ) , class loader , uvf ) ;	Creates new Web Service deployment.
public static boolean is jaxrs deployment ( deployment unit deployment unit ) { deployment unit deployment = deployment unit . get parent ( ) == null ? deployment unit : deployment unit . get parent ( ) ; boolean val = deployment . get attachment ( attachment key ) ; return val != null && val ; }	JAX-RS annotations are found in the deployment, especially if it's an EAR one).
public void set next timeout ( date next ) { if ( next == null ) { set timer state ( timer state . expired , null ) ; } this . next expiration = next ; }	Sets the next timeout of this timer.
protected void set timer state ( timer state state , thread thread ) { assert ( ( state == timer state . in timeout || state == timer state . retry timeout ) && thread != null ) || thread == null : str + state + str + thread ; this . timer state = state ; this . executing thread = thread ; }	Sets the state and timer task executing thread of this timer.
public void merge ( final list < resteasy deployment data > deployment data ) throws deployment unit processing exception { for ( resteasy deployment data data : deployment data ) { scanned application classes . add all ( data . get scanned application classes ( ) ) ; if ( scan resources ) { scanned resource classes . add all ( data . get scanned resource classes ( ) ) ; scanned jndi component resources . add all ( data . get scanned jndi component resources ( ) ) ; } if ( scan providers ) { scanned provider classes . add all ( data . get scanned provider classes ( ) ) ; } } }	Merges a list of additional JAX-RS deployment data with this lot of deployment data.
public void deploy ( deployment phase context phase context ) throws deployment unit processing exception { final deployment unit deployment unit = phase context . get deployment unit ( ) ; final module specification module specification = deployment unit . get attachment ( attachments . module specification ) ; final module loader module loader = module . get boot module loader ( ) ;	Add the EE APIs as a dependency to all deployments.
protected void add remote transactions dependency ( ) { this . get configurators ( ) . add ( new component configurator ( ) { @ override public void configure ( deployment phase context context , component description description , component configuration component configuration ) throws deployment unit processing exception { if ( this . has remote view ( ( ejb ) description ) ) {	Adds a dependency for the ComponentConfiguration on the remote transaction service if the EJB exposes at least one remote view.
public set < interceptor description > get all container interceptors ( ) { if ( this . all container interceptors == null ) { this . all container interceptors = new hash set < interceptor description > ( ) ; this . all container interceptors . add all ( this . class level container interceptors ) ; if ( ! this . exclude default container interceptors ) { this . all container interceptors . add all ( this . default container interceptors ) ; } for ( list < interceptor description > interceptors : this . method level container interceptors . values ( ) ) { this . all container interceptors . add all ( interceptors ) ; } } return this . all container interceptors ; }	Returns a combined map of class and method level container interceptors.
public boolean is method level ( method intf method intf , method method , method intf default method intf ) { assert method intf != null : str ; assert method != null : str ; method class method = resolve real method ( method ) ; string [ ] method params = method info helper . get canonical parameter types ( class method ) ; final string method name = class method . get name ( ) ; final string class name = class method . get declaring class ( ) . get name ( ) ; array key method params key = new array key ( ( object [ ] ) method params ) ; t attr = get ( get ( get ( per view style3 , method intf ) , method name ) , method params key ) ; if ( attr != null ) return bool ; attr = get ( get ( per view style2 , method intf ) , method name ) ; if ( attr != null ) return bool ; attr = get ( per view style1 , method intf ) ; if ( attr != null ) return bool ; attr = get ( get ( get ( style3 , class name ) , method name ) , method params key ) ; if ( attr != null ) return bool ; attr = get ( style2 , method name ) ; if ( attr != null ) return bool ; attr = get ( style1 , class name ) ; if ( attr != null ) return bool ; if ( default method intf == null ) { return bool ; } else { return is method level ( default method intf , method , null ) ; } }	Returns true if the given transaction specification was expliitly specified at a method level, returnsfalse if it was inherited from the default.
protected static void check only one of elements ( xml reader , set < element > seen , element element1 , element element2 ) throws xml { if ( ! seen . contains ( element1 ) && ! seen . contains ( element2 ) ) { throw new xml ( messaging logger . root logger . required ( element1 . get local name ( ) , element2 . get local name ( ) ) , reader . get location ( ) ) ; } if ( seen . contains ( element1 ) && seen . contains ( element2 ) ) { throw new xml ( messaging logger . root logger . only one required ( element1 . get local name ( ) , element2 . get local name ( ) ) , reader . get location ( ) ) ; } }	Check one and only one of the 2 elements has been defined.
protected static class < ? > get type ( config visitor visitor , string class name ) { if ( class name != null ) { try { return visitor . get module ( ) . get class loader ( ) . load class ( class name ) ; } catch ( exception e ) { throw new illegal argument exception ( e ) ; } } return null ; }	Load class.
static type get component type ( parameterized type type , int index ) { type [ ] tp = type . get actual type arguments ( ) ; if ( index + num > tp . length ) return null ; return tp [ index ] ; }	Get component type.
public name parse ( string name ) throws naming exception { vector comps = ins string to stringified comps ( name ) ; return new cn ( comps . elements ( ) ) ; }	Returns a CompoundName given a string in INS syntax.
private static vector ins string to stringified comps ( string str ) throws invalid name exception { int len = str . length ( ) ; vector components = new vector ( num ) ; char [ ] id = new char [ len ] ; char [ ] kind = new char [ len ] ; int id count , kind count ; boolean id mode ; for ( int i = num ; i < len ; ) { id count = kind count = num ;	Converts an INS-syntax string name into a Vector in whicheach element of the vector contains a stringified form ofa NameComponent.
private static name component parse component ( string comp str ) throws invalid name exception { name component comp = new name component ( ) ; int kind sep = - num ; int len = comp str . length ( ) ; int j = num ; char [ ] new str = new char [ len ] ; boolean escaped = bool ;	Return a NameComponent given its stringified form.
public void shutdown ( ) { poa poa = get poa ( ) ; try { poa . deactivate object ( poa . reference to id ( get reference ( ) ) ) ; } catch ( user exception ex ) { iiop . root logger . warn could not deactivate ir ( ex ) ; } }	Unexport this object.
protected org . omg . corba . object servant to reference ( servant servant ) { byte [ ] id = get object id ( ) ; try { repository . poa . activate object with id ( id , servant ) ; org . omg . corba . object ref = repository . poa . id to reference ( id ) ; return ref ; } catch ( wrong policy ex ) { iiop . root logger . debug ( str , ex ) ; } catch ( servant already active ex ) { iiop . root logger . debug ( str , ex ) ; } catch ( object already active ex ) { iiop . root logger . debug ( str , ex ) ; } catch ( object not active ex ) { iiop . root logger . debug ( str , ex ) ; } return null ; }	Convert a servant to a reference.
private security identity authenticate ( final string username , final string password ) { server authentication context context = this . security domain . create new authentication context ( ) ; password guess evidence evidence = null ; try { if ( password == null ) { if ( username == null ) { if ( context . authorize anonymous ( ) ) { context . succeed ( ) ; return context . get authorized identity ( ) ; } else { context . fail ( ) ; return null ; } } else {	Attempt to authenticate and authorize an username with the specified password evidence.
private static boolean is type matched ( class < ? > clz ) { if ( clz . equals ( string . class ) ) { return bool ; } else if ( clz . equals ( byte . class ) || clz . equals ( byte . class ) ) { return bool ; } else if ( clz . equals ( short . class ) || clz . equals ( short . class ) ) { return bool ; } else if ( clz . equals ( int . class ) || clz . equals ( integer . class ) ) { return bool ; } else if ( clz . equals ( long . class ) || clz . equals ( long . class ) ) { return bool ; } else if ( clz . equals ( float . class ) || clz . equals ( float . class ) ) { return bool ; } else if ( clz . equals ( double . class ) || clz . equals ( double . class ) ) { return bool ; } else if ( clz . equals ( boolean . class ) || clz . equals ( boolean . class ) ) { return bool ; } else if ( clz . equals ( char . class ) || clz . equals ( character . class ) ) { return bool ; } else if ( clz . equals ( inet address . class ) ) { return bool ; } else if ( clz . equals ( class . class ) ) { return bool ; } else if ( clz . equals ( properties . class ) ) { return bool ; } return bool ; }	Check whether the types that JCA Injection knows.
@ override public object lookup ( string name ) { final context names . bind info bind info = context names . bind info for ( name ) ; service controller < ? > binding service = container . get service ( bind info . get binder service name ( ) ) ; if ( binding service == null ) { return null ; } managed reference factory managed reference factory = managed reference factory . class . cast ( binding service . get value ( ) ) ; return managed reference factory . get reference ( ) . get instance ( ) ; }	SPI contract for this method.
@ override public void unbind ( string name ) { if ( name == null || name . is empty ( ) ) { throw messaging logger . root logger . cannot unbind jndi name ( ) ; } final context names . bind info bind info = context names . bind info for ( name ) ; service controller < ? > binding service = container . get service ( bind info . get binder service name ( ) ) ; if ( binding service == null ) { root logger . debugf ( str , name ) ; return ; }	Unbind the resource and wait until the corresponding binding service is effectively removed.
public static object instantiate bean ( bean meta data config bean config , bean info bean info , deployment reflection index index , module module ) throws throwable { joinpoint instantiate joinpoint = null ; value config [ ] parameters = new value config [ num ] ; string [ ] types = configurator . no params types ; constructor config ctor config = bean config . get constructor ( ) ; if ( ctor config != null ) { parameters = ctor config . get parameters ( ) ; types = configurator . get types ( parameters ) ; string factory class = ctor config . get factory class ( ) ; factory config factory = ctor config . get factory ( ) ; if ( factory class != null || factory != null ) { string factory method = ctor config . get factory method ( ) ; if ( factory method == null ) throw pojo logger . root logger . missing factory method ( bean config ) ; if ( factory class != null ) {	Instantiate bean.
public static void configure ( bean meta data config bean config , bean info bean info , module module , object bean , boolean nullify ) throws throwable { set < property config > properties = bean config . get properties ( ) ; if ( properties != null ) { list < property config > used = new array list < property config > ( ) ; for ( property config pc : properties ) { try { configure ( bean info , module , bean , pc , nullify ) ; used . add ( pc ) ; } catch ( throwable t ) { if ( nullify == bool ) { for ( property config upc : used ) { try { configure ( bean info , module , bean , upc , bool ) ; } catch ( throwable ignored ) { } } throw new start exception ( t ) ; } } } } }	Configure bean.
public static void dispatch lifecycle joinpoint ( bean info bean info , object bean , lifecycle config config , string default method ) throws throwable { if ( config != null && config . is ignored ( ) ) return ; joinpoint joinpoint = create joinpoint ( bean info , bean , config , default method ) ; if ( joinpoint != null ) joinpoint . dispatch ( ) ; }	Dispatch lifecycle joinpoint.
public static namespace context selector get current selector ( ) { namespace context selector selector = current selector . peek ( ) ; if ( selector != null ) { return selector ; } return default selector ; }	Get the current context selector for the current thread.
public static service name to bean name ( string name , bean state state ) { if ( state == null ) state = bean state . installed ; return jboss pojo . append ( name ) . append ( state . name ( ) ) ; }	Get MC bean name.
public static service name to instances name ( class < ? > clazz , bean state state ) { string cl name ; class loader class loader = clazz . get class loader ( ) ; if ( class loader != null ) cl name = class loader . to string ( ) ; else cl name = str ; if ( state == null ) state = bean state . installed ; return jboss pojo . append ( cl name , clazz . get name ( ) , state . name ( ) ) ; }	To instances name.
public ee get class by name ( string name ) { for ( ee module : available modules ) { final ee desc = module . get class description ( name ) ; if ( desc != null ) { return desc ; } } return null ; }	Look for a class description in all available modules.
@ override protected void process annotations ( final deployment unit deployment unit , final composite index composite index ) throws deployment unit processing exception { if ( metadata complete marker . is metadata complete ( deployment unit ) ) { return ; }	Process annotations and merge any available metadata at the same time.
private void post parse steps ( final virtual file persistence xml , final persistence unit metadata holder pu holder , final deployment unit deployment unit ) { for ( persistence unit metadata pu : pu holder . get persistence units ( ) ) {	Some of this might need to move to the install phase.
public static string validate descriptor ( string descriptor ) { if ( descriptor . length ( ) == num ) { throw ee logger . root logger . cannot be empty ( str ) ; } if ( descriptor . length ( ) > num ) { if ( descriptor . starts with ( str ) ) { if ( ! descriptor . ends with ( str ) ) { throw ee logger . root logger . invalid descriptor ( descriptor ) ; } } else if ( descriptor . starts with ( str ) ) { } else { throw ee logger . root logger . invalid descriptor ( descriptor ) ; } } else { char type = descriptor . char at ( num ) ; switch ( type ) { case str : case str : case str : case str : case str : case str : case str : case str : case str : break ; default : throw ee logger . root logger . invalid descriptor ( descriptor ) ; } } return descriptor ; }	performs basic validation on a descriptor.
void create ( final deployment dep ) { final deployment unit unit = ws . get required attachment ( dep , deployment unit . class ) ; war meta data war md = as . get optional attachment ( unit , war meta data . attachment key ) ; j jboss web md = war md != null ? war md . get merged j ( ) : null ; if ( war md == null ) { war md = new war meta data ( ) ; } if ( jboss web md == null ) { jboss web md = new j ( ) ; war md . set merged j ( jboss web md ) ; unit . put attachment ( war meta data . attachment key , war md ) ; } create web app descriptor ( dep , jboss web md ) ; create j ( dep , jboss web md ) ; dep . add attachment ( j . class , jboss web md ) ; }	Creates web meta data for EJB deployments.
private void create web app descriptor ( final deployment dep , final j jboss web md ) { ws . root logger . trace ( str ) ; create servlets ( dep , jboss web md ) ; create servlet mappings ( dep , jboss web md ) ; create security constraints ( dep , jboss web md ) ; create login config ( dep , jboss web md ) ; create security roles ( dep , jboss web md ) ; }	Creates web.xml descriptor meta data.
private string get auth method ( final deployment dep ) { for ( final endpoint ejb endpoint : dep . get service ( ) . get endpoints ( ) ) { final string bean auth method = ejb3 security accessor . get auth method ( ejb endpoint ) ; final boolean has bean auth method = bean auth method != null ; if ( has bean auth method ) {	Returns deployment authentication method.
public void deploy ( deployment phase context phase context ) throws deployment unit processing exception { final virtual file deployment root = phase context . get deployment unit ( ) . get attachment ( attachments . deployment root ) . get root ( ) ; if ( deployment root == null || ! deployment root . exists ( ) ) return ; virtual file service xml file = null ; if ( deployment root . is directory ( ) ) { service xml file = deployment root . get child ( service descriptor path ) ; } else if ( deployment root . get name ( ) . to lower case ( locale . english ) . ends with ( service descriptor suffix ) ) { service xml file = deployment root ; } if ( service xml file == null || ! service xml file . exists ( ) ) return ; final xml xml mapper = xml . factory . create ( ) ; final j j boss service xml descriptor parser = new j ( j . property replacer ( phase context . get deployment unit ( ) ) ) ; xml mapper . register root element ( new q ( str , str ) , j boss service xml descriptor parser ) ; xml mapper . register root element ( new q ( null , str ) , j boss service xml descriptor parser ) ; input stream xml stream = null ; try { xml stream = service xml file . open stream ( ) ; final xml reader = input factory . create xml ( xml stream ) ; final parse result < j > result = new parse result < j > ( ) ; xml mapper . parse document ( result , reader ) ; final j xml descriptor = result . get result ( ) ; if ( xml descriptor != null ) phase context . get deployment unit ( ) . put attachment ( j . attachment key , xml descriptor ) ; else throw sar logger . root logger . failed xml parsing ( service xml file ) ; } catch ( exception e ) { throw sar logger . root logger . failed xml parsing ( e , service xml file ) ; } finally { vfs . safe close ( xml stream ) ; } }	Process a deployment for jboss-service.xml files.
private void handle stateless session bean ( final ejb component , final module module , final deployment reflection index reflection index ) throws class not found exception , deployment unit processing exception { final class < ? > component class = class loading utils . load class ( component . get component class name ( ) , module ) ; final method identifier ejb create id = method identifier . get identifier ( void . class , str ) ; final method ejb create = class reflection index util . find method ( reflection index , component class , ejb create id ) ; if ( ejb create != null ) { final interceptor class description . builder builder = interceptor class description . builder ( ) ; builder . set post construct ( ejb create id ) ; component . add interceptor method override ( ejb create . get declaring class ( ) . get name ( ) , builder . build ( ) ) ; } final method identifier ejb remove id = method identifier . get identifier ( void . class , str ) ; final method ejb remove = class reflection index util . find method ( reflection index , component class , ejb remove id ) ; if ( ejb remove != null ) { final interceptor class description . builder builder = interceptor class description . builder ( ) ; builder . set pre destroy ( ejb remove id ) ; component . add interceptor method override ( ejb remove . get declaring class ( ) . get name ( ) , builder . build ( ) ) ; } }	Handles setting up the ejbCreate and ejbRemove methods for stateless session beans and MDB's.
public static class < ? > make stub class ( final class < ? > my class ) { final string stub class name = my class + str ; class loader cl = wild fly security manager . get current context class loader privileged ( ) ; if ( cl == null ) { cl = my class . get class loader ( ) ; } if ( cl == null ) { throw ejb logger . root logger . could not find class loader for stub ( stub class name ) ; } class < ? > the class ; try { the class = cl . load class ( stub class name ) ; } catch ( class not found exception e ) { try { final class file clazz = iiop . compile ( my class , stub class name ) ; the class = clazz . define ( cl , my class . get protection domain ( ) ) ; } catch ( throwable ex ) {	Makes a dynamic stub class, if it does not already exist.
protected byte [ ] get anonymous object id ( long n ) { string s = anon oid prefix + long . to string ( n ) ; return s . get bytes ( standard charsets . utf 8 ) ; }	Generate the ID of the n-th "anonymous" object created in this IR.
@ override public list < persistence provider > get persistence providers ( ) { list < persistence provider > providers copy = new array list < > ( providers . size ( ) ) ; synchronized ( persistence provider per class loader ) { if ( persistence provider per class loader . size ( ) > num ) {	Return a new instance of each persistence provider class.
public void clear cached deployment specific providers ( set < class loader > deployment class loaders ) { synchronized ( persistence provider per class loader ) { for ( class loader deployment class loader : deployment class loaders ) { persistence provider per class loader . remove ( deployment class loader ) ; } } }	Cleared at application undeployment time to remove any persistence providers that were deployed with the application.
public void add deployment specific persistence provider ( persistence provider persistence provider , set < class loader > deployment class loaders ) { synchronized ( persistence provider per class loader ) { for ( class loader deployment class loader : deployment class loaders ) { list < class < ? extends persistence provider > > list = persistence provider per class loader . get ( deployment class loader ) ; root logger . tracef ( str , list , deployment class loader ) ; if ( list == null ) { list = new array list < > ( ) ; persistence provider per class loader . put ( deployment class loader , list ) ; root logger . tracef ( str , list , deployment class loader ) ; } list . add ( persistence provider . get class ( ) ) ; root logger . tracef ( str , persistence provider . get class ( ) . get name ( ) , list ) ; } } }	Set at application deployment time to the persistence providers packaged in the application.
private class loader find parent module cl ( class loader class loader ) { class loader c = class loader ; while ( c != null && ! ( c instanceof module class loader ) ) { c = c . get parent ( ) ; } return c ; }	If a custom CL is in use we want to get the module CL it delegates to.
public void deploy ( deployment phase context phase context ) throws deployment unit processing exception { final deployment unit deployment unit = phase context . get deployment unit ( ) ; final module specification module specification = deployment unit . get attachment ( attachments . module specification ) ; final j service xml descriptor = deployment unit . get attachment ( j . attachment key ) ; if ( service xml descriptor == null ) { return ;	Add dependencies for modules required for manged bean deployments, if managed bean configurations are attachedto the deployment.
private static void add pu service ( final deployment phase context phase context , final array list < persistence unit metadata holder > pu list , final boolean start early , final platform platform ) throws deployment unit processing exception { if ( pu list . size ( ) > num ) { final deployment unit deployment unit = phase context . get deployment unit ( ) ; final module module = deployment unit . get attachment ( attachments . module ) ; final ee ee module description = deployment unit . get attachment ( org . jboss . as . ee . component . attachments . ee module description ) ; final service target service target = phase context . get service target ( ) ; final module class loader class loader = module . get class loader ( ) ; for ( persistence unit metadata holder holder : pu list ) { set annotation indexes ( holder , deployment unit ) ; for ( persistence unit metadata pu : holder . get persistence units ( ) ) {	Add one PU service per top level deployment that represents.
private static void set annotation indexes ( final persistence unit metadata holder pu holder , deployment unit deployment unit ) { final map < url , index > annotation indexes = new hash map < > ( ) ; do { for ( resource root root : deployment utils . all resource roots ( deployment unit ) ) { final index index = root . get attachment ( attachments . annotation index ) ; if ( index != null ) { try { root logger . tracef ( str , root . get root ( ) . to url ( ) ) ; annotation indexes . put ( root . get root ( ) . to url ( ) , index ) ; } catch ( url e ) { throw new runtime exception ( e ) ; } } } deployment unit = deployment unit . get parent ( ) ;	Setup the annotation index map.
private static persistence provider adaptor get persistence provider adaptor ( final persistence unit metadata pu , final persistence provider deployment holder persistence provider deployment holder , final deployment unit deployment unit , final persistence provider provider , final platform platform ) throws deployment unit processing exception { string adapter class = pu . get properties ( ) . get property ( configuration . adapter class ) ; if ( persistence provider deployment holder != null && adapter class != null ) { list < persistence provider adaptor > persistence provider adaptors = persistence provider deployment holder . get adapters ( ) ; for ( persistence provider adaptor persistence provider adaptor : persistence provider adaptors ) { if ( adapter class . equals ( persistence provider adaptor . get class ( ) . get name ( ) ) ) { return persistence provider adaptor ; } } } string adaptor module = pu . get properties ( ) . get property ( configuration . adapter module ) ; persistence provider adaptor adaptor ; adaptor = get per deployment shared persistence provider adaptor ( deployment unit , adaptor module , provider ) ; if ( adaptor == null ) { try {	Get the persistence provider adaptor.
private static persistence provider adaptor save per deployment shared persistence provider adaptor ( deployment unit deployment unit , string adaptor module , persistence provider adaptor adaptor , persistence provider provider ) { if ( deployment unit . get parent ( ) != null ) { deployment unit = deployment unit . get parent ( ) ; } synchronized ( deployment unit ) { map < string , persistence provider adaptor > map = deployment unit . get attachment ( provider adaptor map key ) ; string key ; if ( adaptor module != null ) { key = adaptor module ;	Will save the PersistenceProviderAdaptor at the top level application deployment unit level for sharing with other persistence units.
private static persistence provider lookup provider ( persistence unit metadata pu , persistence provider deployment holder persistence provider deployment holder , deployment unit deployment unit ) throws deployment unit processing exception { map < string , persistence provider > provider map = persistence provider deployment holder != null ? persistence provider deployment holder . get providers ( ) : null ; if ( provider map != null ) { synchronized ( provider map ) { if ( provider map . contains key ( pu . get persistence provider class name ( ) ) ) { root logger . tracef ( str , deployment unit . get name ( ) , pu . get persistence provider class name ( ) ) ; return provider map . get ( pu . get persistence provider class name ( ) ) ; } } } string configured persistence provider module = pu . get properties ( ) . get property ( configuration . provider module ) ; string persistence provider class name = pu . get persistence provider class name ( ) ; if ( persistence provider class name == null ) { persistence provider class name = configuration . provider class default ; } if ( configured persistence provider module != null ) { list < persistence provider > providers ; if ( configuration . provider module application supplied . equals ( configured persistence provider module ) ) { try {	Look up the persistence provider.
@ override public map < class < ? extends annotation > , set < class < ? > > > get annotated classes ( final set uris ) { return annotations ;	use a plain Set and it should work for both versions.
final ejb create ( final deployment dep ) { if ( ws . root logger . is trace enabled ( ) ) { ws . root logger . tracef ( str , dep . get simple name ( ) ) ; } final ejb . builder ejb archive md = new ejb . builder ( ) ; this . build enterprise beans meta data ( dep , ejb archive md ) ; this . build webservices meta data ( dep , ejb archive md ) ; return ejb archive md . build ( ) ; }	Builds universal EJB meta data model that is AS agnostic.
protected void build enterprise bean meta data ( final list < ejb > ws ejbs md , final ejb ejb endpoint , final j jboss webservices md ) { final slsb . builder ws ejb md = new slsb . builder ( ) ;	Builds JBoss agnostic EJB meta data.
void refresh participant ( operation context context ) { context . add step ( refresh handler , operation context . stage . model , bool ) ; }	refresh the attributes of this participant (the status attribute should have changed to PREPARED.
container analysis get analysis ( final class cls ) throws rmiiiop { container analysis ret = null ; boolean created = bool ; try { synchronized ( this ) { ret = lookup done ( cls ) ; if ( ret != null ) { return ret ; }	Returns an analysis.If the calling thread is currently doing an analysis of thisclass, an unfinished analysis is returned.
private container analysis lookup done ( class cls ) { soft reference ref = ( soft reference ) work done . get ( cls ) ; if ( ref == null ) return null ; container analysis ret = ( container analysis ) ref . get ( ) ; if ( ret == null ) work done . remove ( cls ) ;	Lookup an analysis in the fully done map.
private container analysis create work in progress ( final class cls ) { final container analysis analysis ; try { analysis = ( container analysis ) constructor . new instance ( cls ) ; } catch ( instantiation exception ex ) { throw new runtime exception ( ex . to string ( ) ) ; } catch ( illegal access exception ex ) { throw new runtime exception ( ex . to string ( ) ) ; } catch ( invocation target exception ex ) { throw new runtime exception ( ex . to string ( ) ) ; } work in progress . put ( new in progress key ( cls , thread . current thread ( ) ) , analysis ) ; return analysis ; }	Create new work-in-progress.
public string get idl ( ) { if ( idl module name == null ) { string pkg name = cls . get package ( ) . get name ( ) ; string buffer b = new string buffer ( ) ; while ( ! str . equals ( pkg name ) ) { int idx = pkg name . index of ( str ) ; string n = ( idx == - num ) ? pkg name : pkg name . substring ( num , idx ) ; b . append ( str ) . append ( util . java to idl ( n ) ) ; pkg name = ( idx == - num ) ? str : pkg name . substring ( idx + num ) ; } idl module name = b . to string ( ) ; } return idl module name ; }	Return the fully qualified IDL module name that thisanalysis should be placed in.
protected string to hex string ( int i ) { string s = integer . to hex string ( i ) . to upper case ( locale . english ) ; if ( s . length ( ) < num ) return str . substring ( num , num - s . length ( ) ) + s ; else return s ; }	Convert an integer to a 16-digit hex string.
protected string to hex string ( long l ) { string s = long . to hex string ( l ) . to upper case ( locale . english ) ; if ( s . length ( ) < num ) return str . substring ( num , num - s . length ( ) ) + s ; else return s ; }	Convert a long to a 16-digit hex string.
protected boolean is accessor ( method m ) { class return type = m . get return type ( ) ;	Check if a method is an accessor.
protected boolean is mutator ( method m ) {	Check if a method is a mutator.
protected boolean has non app exceptions ( method m ) { class [ ] ex = m . get exception types ( ) ; for ( int i = num ; i < ex . length ; ++ i ) if ( ! java . rmi . remote exception . class . is assignable from ( ex [ i ] ) ) return bool ; return bool ; }	Check if a method throws anything checked other thanjava.rmi.RemoteException and its subclasses.
protected string attribute read name ( string name ) { if ( name . starts with ( str ) ) name = name . substring ( num ) ; else if ( name . starts with ( str ) ) name = name . substring ( num ) ; else throw iiop . root logger . not an accessor ( name ) ; return name ; }	Convert an attribute read method name in Java format toan attribute name in Java format.
protected string attribute write name ( string name ) { if ( name . starts with ( str ) ) name = name . substring ( num ) ; else throw iiop . root logger . not an accessor ( name ) ; return name ; }	Convert an attribute write method name in Java format toan attribute name in Java format.
protected void fixup overloaded operation names ( ) throws rmiiiop { for ( int i = num ; i < methods . length ; ++ i ) { if ( ( m flags [ i ] & m overloaded ) == num ) continue ;	Fixup overloaded operation names.As specified in section 1.3.2.6.
protected void fixup case names ( ) throws rmiiiop { array list entries = get contained entries ( ) ; boolean [ ] clash = new boolean [ entries . size ( ) ] ; string [ ] upper names = new string [ entries . size ( ) ] ; for ( int i = num ; i < entries . size ( ) ; ++ i ) { abstract analysis aa = ( abstract analysis ) entries . get ( i ) ; clash [ i ] = bool ; upper names [ i ] = aa . get idl ( ) . to upper case ( locale . english ) ; for ( int j = num ; j < i ; ++ j ) { if ( upper names [ i ] . equals ( upper names [ j ] ) ) { clash [ i ] = bool ; clash [ j ] = bool ; } } } for ( int i = num ; i < entries . size ( ) ; ++ i ) { if ( ! clash [ i ] ) continue ; abstract analysis aa = ( abstract analysis ) entries . get ( i ) ; boolean no upper = bool ; string name = aa . get idl ( ) ; string buffer b = new string buffer ( name ) ; b . append ( str ) ; for ( int j = num ; j < name . length ( ) ; ++ j ) { if ( ! character . is upper case ( name . char at ( j ) ) ) continue ; if ( no upper ) no upper = bool ; else b . append ( str ) ; b . append ( j ) ; } aa . set idl ( b . to string ( ) ) ; } }	Fixup names differing only in case.As specified in section 1.3.2.7.
protected string escape ir ( string name ) { string buffer b = new string buffer ( ) ; for ( int i = num ; i < name . length ( ) ; ++ i ) { char c = name . char at ( i ) ; if ( c < num ) b . append ( c ) ; else b . append ( str ) . append ( to hex string ( ( int ) c ) ) ; } return b . to string ( ) ; }	Escape non-ISO characters for an IR name.
private void parse xts ( xml reader , model node subsystem ) throws xml { process attributes ( reader , ( index , attribute ) -> { final string value = reader . get attribute value ( index ) ; switch ( attribute ) { case url : environment url . parse and set parameter ( value , subsystem , reader ) ; break ; default : throw parse utils . unexpected attribute ( reader , index ) ; } } ) ;	Handle the xts-environment element.
private void parse default context propagation element ( xml reader , model node subsystem ) throws xml { process attributes ( reader , ( index , attribute ) -> { final string value = reader . get attribute value ( index ) ; switch ( attribute ) { case enabled : if ( value == null || ( ! value . to lower case ( ) . equals ( str ) && ! value . to lower case ( ) . equals ( str ) ) ) { throw parse utils . invalid attribute value ( reader , index ) ; } default context propagation . parse and set parameter ( value , subsystem , reader ) ; break ; default : throw parse utils . unexpected attribute ( reader , index ) ; } } ) ;	Handle the enable-client-handler element.
private void process attributes ( final xml reader , attribute processor < integer , attribute > attribute processor callback ) throws xml { final int count = reader . get attribute count ( ) ; for ( int i = num ; i < count ; i ++ ) { parse utils . require no namespace attribute ( reader , i ) ;	Iterating over all attributes got from the reader parameter.
public static list < persistence provider > load provider module by name ( string module name ) throws module load exception { final module loader module loader = module . get boot module loader ( ) ; module module = module loader . load module ( module identifier . from string ( module name ) ) ; final service loader < persistence provider > service loader = module . load service ( persistence provider . class ) ; list < persistence provider > result = new array list < > ( ) ; if ( service loader != null ) { for ( persistence provider provider1 : service loader ) {	Loads the specified JPA persistence provider module.
static abstract add step handler create add operation ( final string child type , final boolean allow sibling , collection < ? extends attribute definition > attributes ) { return new mq . add step handler ( attributes ) { @ override public void execute ( operation context context , model node operation ) throws operation failed exception { super . execute ( context , operation ) ; if ( ! allow sibling ) { context . add step ( check no other sibling ( child type ) , model ) ; } } } ; }	Create an ADD operation that can check that there is no other sibling when the resource is added.
@ override public void deploy ( deployment phase context phase context ) throws deployment unit processing exception {	Adds Java EE module as a dependency to any deployment unit which is an EJB deployment.
private boolean write attribute ( xml writer , simple attribute definition attribute , model node node , boolean start writen , string origin ) throws xml { if ( attribute . is marshallable ( node , bool ) ) { if ( ! start writen ) { start writen = bool ; writer . write start element ( origin ) ; } attribute . marshall as attribute ( node , bool , writer ) ; } return start writen ; }	todo, attribute.marshallAsAttribute should return boolean.
public id create session remote ( ) { control point control point = get control point ( ) ; if ( control point == null ) { return create session ( ) ; } else { try { run result result = control point . begin request ( ) ; if ( result == run result . rejected ) { throw ejb logger . root logger . container suspended ( ) ; } try { return create session ( ) ; } finally { control point . request complete ( ) ; } } catch ( ejb | component is stopped exception e ) { throw e ; } catch ( exception e ) { throw new ejb ( e ) ; } } }	creates a session using the global request controller.This should only be used by callers that service remote requests (i.e.
private string infer destination name ( string address ) { if ( address . starts with ( jms queue prefix ) ) { return address . substring ( jms queue prefix . length ( ) ) ; } else if ( address . starts with ( jms topic prefix ) ) { return address . substring ( jms topic prefix . length ( ) ) ; } else { return address ; } }	Infer the name of the JMS destination based on the queue's address.
public void register endpoint handlers ( final string endpoint class , final set < string > endpoint handlers ) { if ( ( endpoint class == null ) || ( endpoint handlers == null ) ) { throw new illegal argument exception ( ) ; } endpoint handlers map . put ( endpoint class , collections . unmodifiable set ( endpoint handlers ) ) ; }	Registers endpoint and its associated WS handlers.
set < string > get job xml names ( final string job name ) { if ( job names . contains key ( job name ) ) { return collections . unmodifiable set ( job names . get ( job name ) ) ; } return collections . empty set ( ) ; }	Returns the job XML file names which contain the job name.
private void init ( final class loader class loader ) {	Initializes the state of an instance.
protected string request uri ( http server exchange request ) { string uri = request . get relative path ( ) ; if ( uri == null || uri . equals ( str ) ) { uri = str ; } return uri ; }	Get the canonical request URI from the request mapping data requestPath.
public static resolve result create using url ( string url , hashtable env ) throws naming exception { cn ctx = new cn ( ) ; if ( env != null ) { env = ( hashtable ) env . clone ( ) ; } ctx . env = env ; string rest = ctx . init using url ( env != null ? ( org . omg . corba . orb ) env . get ( str ) : null , url , env ) ;	This method is used by the iiop and iiopname URL Context factories.
public java . lang . object lookup ( string name ) throws naming exception { return lookup ( new composite name ( name ) ) ; }	Converts the "String" name into a CompositeNamereturns the object resolved by the COS Naming api,resolve.
public void bind ( string name , java . lang . object obj ) throws naming exception { bind ( new composite name ( name ) , obj ) ; }	Converts the "String" name into a CompositeName object andperforms the bind operation.
private void call unbind ( name component [ ] path ) throws naming exception { if ( nc == null ) throw iiop . root logger . not a ( path . to string ( ) ) ; try { nc . unbind ( path ) ; } catch ( not found e ) {	Calls the unbind api of COS Naming and uses the exception mapperclass to map the exceptions.
public naming enumeration list bindings ( name name ) throws naming exception { if ( nc == null ) throw iiop . root logger . not a ( name . to string ( ) ) ; if ( name . size ( ) > num ) { try { java . lang . object obj = lookup ( name ) ; if ( obj instanceof cn ) { return new org . wildfly . iiop . openjdk . naming . jndi . cn ( ( cn ) obj , bool , env ) ; } else { throw new not context exception ( name . to string ( ) ) ; } } catch ( naming exception ne ) { throw ne ; } catch ( bad param e ) { naming exception ne = new not context exception ( name . to string ( ) ) ; ne . set root cause ( e ) ; throw ne ; } } return new org . wildfly . iiop . openjdk . naming . jndi . cn ( this , bool , env ) ; }	Returns a BindingEnumeration object which has a list of nameclass pairs.
private void call destroy ( naming context nc ) throws naming exception { if ( nc == null ) throw iiop . root logger . not a ( nc . to string ( ) ) ; try { nc . destroy ( ) ; } catch ( exception e ) { throw org . wildfly . iiop . openjdk . naming . jndi . exception mapper . map exception ( e , this , null ) ; } }	Calls the destroy on the COS Naming Server.
public void destroy subcontext ( name name ) throws naming exception { if ( nc == null ) throw iiop . root logger . not a ( name . to string ( ) ) ; naming context the nc = nc ; name component [ ] path = org . wildfly . iiop . openjdk . naming . jndi . cn . name to cos name ( name ) ; if ( name . size ( ) > num ) { try { javax . naming . context ctx = ( javax . naming . context ) call resolve ( path ) ; cn cnc = ( cn ) ctx ; the nc = cnc . nc ; cnc . close ( ) ;	Uses the callDestroy function to destroy the context.
private javax . naming . context call bind new context ( name component [ ] path ) throws naming exception { if ( nc == null ) throw iiop . root logger . not a ( path . to string ( ) ) ; try { naming context nctx = nc . bind new context ( path ) ; return new cn ( orb , nctx , env , make full name ( path ) ) ; } catch ( exception e ) { throw org . wildfly . iiop . openjdk . naming . jndi . exception mapper . map exception ( e , this , path ) ; } }	Calls the bind_new_context COS naming api to create a new subcontext.
public javax . naming . context create subcontext ( string name ) throws naming exception { return create subcontext ( new composite name ( name ) ) ; }	Uses the callBindNewContext convenience function to create a newcontext.
public java . lang . object lookup link ( string name ) throws naming exception { return lookup link ( new composite name ( name ) ) ; }	Is mapped to resolve in the COS Naming api.
public java . lang . object add to environment ( string prop name , java . lang . object prop value ) throws naming exception { if ( env == null ) { env = new hashtable ( num , num ) ; } else {	Adds to the environment for the current context.Record change but do not reinitialize ORB.
public java . lang . object remove from environment ( string prop name ) throws naming exception { if ( env != null && env . get ( prop name ) != null ) {	Record change but do not reinitialize ORB.
@ suppress warnings ( str ) static void add transformations ( model version version , resource transformation description builder builder ) { if ( j . version 5 0 0 . requires transformation ( version ) ) { builder . get attribute builder ( ) . set discard ( discard attribute checker . undefined , attribute . statistics enabled . get definition ( ) ) . add reject check ( reject attribute checker . defined , attribute . statistics enabled . get definition ( ) ) . end ( ) ; } if ( j . version 3 0 0 . requires transformation ( version ) ) { attribute converter type converter = new attribute converter . default attribute converter ( ) { @ override protected void convert attribute ( path address address , string name , model node value , transformation context context ) { if ( ! value . is defined ( ) ) { value . set ( address . get last element ( ) . get value ( ) ) ; } } } ; builder . get attribute builder ( ) . set discard ( new discard attribute checker . discard attribute value checker ( attribute . module . get definition ( ) . get default value ( ) ) , attribute . module . get definition ( ) ) . add reject check ( reject attribute checker . defined , attribute . module . get definition ( ) ) . set value converter ( type converter , deprecated attribute . type . get definition ( ) ) . end ( ) ; builder . add raw operation transformation override ( map operations . map get definition . get name ( ) , new simple operation transformer ( new legacy property map get operation transformer ( ) ) ) ; for ( string op name : operations . get all write attribute operation names ( ) ) { builder . add operation transformation override ( op name ) . inherit resource attribute definitions ( ) . set custom operation transformer ( new legacy property write operation transformer ( ) ) ; } } property resource definition . build transformation ( version , builder ) ; }	Builds transformations common to both stack protocols and transport.
public void remove security domain ( string security domain ) { security mgr map . remove ( security domain ) ; audit mgr map . remove ( security domain ) ; auth mgr map . remove ( security domain ) ; authz mgr map . remove ( security domain ) ; idm mgr map . remove ( security domain ) ; mapping mgr map . remove ( security domain ) ; jsse map . remove ( security domain ) ; }	Removes one security domain from the maps.
private object look up jndi ( string context name ) { object result = null ; try { context ctx = new initial context ( ) ; if ( context name . starts with ( security constants . jaas context root ) ) result = ctx . lookup ( context name ) ; else result = ctx . lookup ( security constants . jaas context root + context name ) ; } catch ( exception e ) { security logger . root logger . tracef ( str , context name , e . get localized message ( ) ) ; return null ; } return result ; }	Lookup a context in JNDI.
public static modular reference create ( final class < ? > type , final class < ? > factory class ) { return create ( type . get name ( ) , factory class ) ; }	Create a ModuleReference from a target type and factory class.
public static modular reference create ( final string class name , final class < ? > factory class ) { return new modular reference ( class name , factory class . get name ( ) , module . for class ( factory class ) . get identifier ( ) ) ; }	Create a ModuleReference from a target class name and factory class.
public static modular reference create ( final class < ? > type , final ref addr addr , final class < ? > factory class ) { return create ( type . get name ( ) , addr , factory class ) ; }	Create a ModuleReference from a target type, reference address and factory class.
static idl get idl ( type code type code , repository impl repository ) { tc tc kind = type code . kind ( ) ; if ( primitive def impl . is primitive tc ( tc kind ) ) return new primitive def impl ( type code , repository ) ; if ( tc kind == tc . tk sequence ) return repository . get sequence impl ( type code ) ; if ( tc kind == tc . tk value || tc kind == tc . tk value box || tc kind == tc . tk alias || tc kind == tc . tk struct || tc kind == tc . tk union || tc kind == tc . tk enum || tc kind == tc . tk objref ) { try { return ( idl ) repository . lookup id ( type code . id ( ) ) ; } catch ( bad kind ex ) { throw iiop . root logger . bad kind for type code ( tc kind . value ( ) ) ; } } throw iiop . root logger . bad kind for type code ( tc kind . value ( ) ) ; }	Return the LocalIDLType for the given TypeCode.
private static void wait for service ( final service controller < ? > controller ) throws operation failed exception { if ( controller . get state ( ) == service controller . state . up ) return ; final stability monitor monitor = new stability monitor ( ) ; monitor . add controller ( controller ) ; try { monitor . await stability ( num , milliseconds ) ; } catch ( final interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; throw security logger . root logger . interrupted waiting for security domain ( controller . get name ( ) . get simple name ( ) ) ; } finally { monitor . remove controller ( controller ) ; } if ( controller . get state ( ) != service controller . state . up ) { throw security logger . root logger . required security domain service not available ( controller . get name ( ) . get simple name ( ) ) ; } }	Wait for the required service to start up and fail otherwise.
private string compute masked password ( ) throws exception {	Method to compute masked password based on class attributes.
private void init security vault ( ) throws exception { try { this . vault = security vault factory . get ( ) ; this . vault . init ( get vault options map ( ) ) ; handshake ( ) ; } catch ( security vault exception e ) { throw security logger . root logger . security vault exception ( e ) ; } }	Initialize the underlying vault.
public void start vault session ( string vault alias ) throws exception { if ( vault alias == null ) { throw security logger . root logger . vault alias not specified ( ) ; } this . keystore masked password = ( org . jboss . security . util . is password command ( keystore password ) ) ? keystore password : compute masked password ( ) ; this . vault alias = vault alias ; init security vault ( ) ; }	Start the vault with given alias.
private void attribute created display ( string vault block , string attribute name ) { system . out . println ( security logger . root logger . vault attribute create display ( vault block , attribute name , secured attribute configuration string ( vault block , attribute name ) ) ) ; }	Display info about stored secured attribute.
public void vault configuration display ( ) { final string configuration = vault configuration ( ) ; system . out . println ( security logger . root logger . vault configuration title ( ) ) ; system . out . println ( str ) ; system . out . println ( str ) ; system . out . println ( configuration ) ; system . out . println ( str ) ; system . out . println ( str ) ; system . out . println ( str + configuration ) ; system . out . println ( str ) ; }	Display info about vault itself in form of AS7 configuration file.
public string vault configuration ( ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; sb . append ( str ) . append ( keystore url ) . append ( str ) . append ( str ) ; sb . append ( str ) . append ( keystore masked password ) . append ( str ) . append ( str ) ; sb . append ( str ) . append ( vault alias ) . append ( str ) . append ( str ) ; sb . append ( str ) . append ( salt ) . append ( str ) . append ( str ) ; sb . append ( str ) . append ( iteration count ) . append ( str ) . append ( str ) ; sb . append ( str ) . append ( encryption directory ) . append ( str ) ; sb . append ( str ) ; return sb . to string ( ) ; }	Returns vault configuration string in user readable form.
public static < t > t not null ( t value ) { if ( value == null ) throw connector logger . root logger . service not started ( ) ; return value ; }	convenient method to check notNull of value.
public static synchronized service name get deployment service name ( final string ra name , final activation raxml ) { if ( ra name == null ) throw connector logger . root logger . undefined var ( str ) ; service name service name = null ; modifiable resource adapter ra = ( modifiable resource adapter ) raxml ; if ( ra != null && ra . get id ( ) != null ) { service name = get deployment service name ( ra name , ra . get id ( ) ) ; } else { service name = get deployment service name ( ra name , ( string ) null ) ; } root logger . tracef ( str , ra name , raxml , service name ) ; return service name ; }	resource-adapter DMR resource.
public void insert value ( any any ) { if ( type == string . class ) any . insert wstring ( ( string ) value ) ;	Insert the constant value into the argument Any.
public boolean implies ( final jndi permission permission ) { return permission != null && ( ( action bits & permission . action bits ) == permission . action bits ) && implies path ( permission . get name ( ) ) ; }	Determine if this permission implies the other permission.
public string get actions ( ) { final string action string = this . action string ; if ( action string != null ) { return action string ; } int action bits = this . action bits ; if ( action bits == action all ) { return this . action string = str ; } int m = integer . lowest one bit ( action bits ) ; if ( m != num ) { string builder b = new string builder ( ) ; b . append ( get action ( m ) ) ; action bits &= ~ m ; while ( action bits != num ) { m = integer . lowest one bit ( action bits ) ; b . append ( str ) . append ( get action ( m ) ) ; action bits &= ~ m ; } return this . action string = b . to string ( ) ; } else { return this . action string = str ; } }	Get the actions string.
public string get name ( ) { final string s = log . get name ( ) ; final int i = s . last index of ( str ) ; return i != - num ? s . substring ( i + num , s . length ( ) ) : s ; }	Use the short class name as the default for the service name.
private void send state change notification ( int old state , int new state , string msg , throwable t ) { long now = system . current time millis ( ) ; attribute change notification state change notification = new attribute change notification ( this , get next notification sequence number ( ) , now , msg , str , str , new integer ( old state ) , new integer ( new state ) ) ; state change notification . set user data ( t ) ; send notification ( state change notification ) ; }	Helper for sending out state change notifications.
public object get value ( type type ) { if ( type == null || ( type instanceof class ) ) { return get class value ( ( class ) type ) ; } else if ( type instanceof parameterized type ) { parameterized type pt = ( parameterized type ) type ; return get pt value ( pt ) ; } else { throw pojo logger . root logger . unknown type ( type ) ; } }	Get value.
public service name get context service name ( ) { if ( context service name != null ) return context service name ; if ( get naming mode ( ) == component naming mode . create ) { return context names . context service name of component ( get application name ( ) , get module name ( ) , get component name ( ) ) ; } else if ( get naming mode ( ) == component naming mode . use module ) { return context names . context service name of module ( get application name ( ) , get module name ( ) ) ; } else { throw new illegal state exception ( ) ; } }	Get the context service name.
public set < interceptor description > get all interceptors ( ) { if ( all interceptors == null ) { all interceptors = new hash set < interceptor description > ( ) ; all interceptors . add all ( class interceptors ) ; if ( ! exclude default interceptors ) { all interceptors . add all ( default interceptors ) ; } for ( list < interceptor description > interceptors : method interceptors . values ( ) ) { all interceptors . add all ( interceptors ) ; } } return all interceptors ; }	Returns a combined map of class and method level interceptors.
public void add method interceptor ( method identifier method , interceptor description description ) {	Add a method interceptor class name.
public void add dependency ( service name service name ) { if ( service name == null ) { throw ee logger . root logger . null var ( str , str , component name ) ; } dependencies . add ( service name ) ; }	Add a dependency to this component.
public list < interceptor factory > get component interceptors ( method method ) { map < method , ordered item container < list < interceptor factory > > > map = component interceptors ; ordered item container < list < interceptor factory > > interceptors = map . get ( method ) ; if ( interceptors == null ) { return collections . empty list ( ) ; } list < list < interceptor factory > > sorted items = interceptors . get sorted items ( ) ; list < interceptor factory > ret = new array list < > ( ) ; for ( list < interceptor factory > item : sorted items ) { ret . add all ( item ) ; } return ret ; }	Gets the interceptor list for a given method.
public list < interceptor factory > get around timeout interceptors ( method method ) { map < method , ordered item container < interceptor factory > > map = timeout interceptors ; ordered item container < interceptor factory > interceptors = map . get ( method ) ; if ( interceptors == null ) { return collections . empty list ( ) ; } return interceptors . get sorted items ( ) ; }	Gets the around timeout interceptor list for a given method.
public void add timeout view interceptor ( final method method , interceptor factory factory , int priority ) { ordered item container < interceptor factory > interceptors = timeout interceptors . get ( method ) ; if ( interceptors == null ) { timeout interceptors . put ( method , interceptors = new ordered item container < interceptor factory > ( ) ) ; } interceptors . add ( factory , priority ) ; }	Adds a timeout interceptor factory to every method on the component.
public void add around construct interceptor ( interceptor factory interceptor factory , int priority ) { around construct interceptors . add ( collections . singleton list ( interceptor factory ) , priority ) ; }	Adds an around-construct interceptor.
public void add post construct interceptor ( interceptor factory interceptor factory , int priority ) { post construct interceptors . add ( collections . singleton list ( interceptor factory ) , priority ) ; }	Adds a post construct interceptor.
public void add pre destroy interceptor ( interceptor factory interceptor factory , int priority ) { pre destroy interceptors . add ( collections . singleton list ( interceptor factory ) , priority ) ; }	Adds a pre destroy interceptor.
public void add pre passivate interceptor ( interceptor factory interceptor factory , int priority ) { pre passivate interceptors . add ( collections . singleton list ( interceptor factory ) , priority ) ; }	Adds a pre passivate interceptor.
public void add post activate interceptor ( interceptor factory interceptor factory , int priority ) { post activate interceptors . add ( collections . singleton list ( interceptor factory ) , priority ) ; }	Adds a post activate interceptor.
public void set component create service factory ( final component create service factory component create service factory ) { if ( component create service factory == null ) { throw ee logger . root logger . null var ( str , str , get component name ( ) ) ; } this . component create service factory = component create service factory ; }	Set the component create service factory for this component.
protected void remove jndi ( operation context context , list < model node > entries ) { if ( entries . size ( ) > num ) { for ( int i = num ; i < entries . size ( ) ; i ++ ) { context names . bind info alias bind info = context names . bind info for ( entries . get ( i ) . as string ( ) ) ; context . remove service ( alias bind info . get binder service name ( ) ) ; } } }	Remove JNDI alias' binder services.The 1st JNDI entry is not removed by this method as it is already handled when removingthe pooled-connection-factory service.
public void accept ( final ejb . builder builder ) { final ejb remote transport provider = this . remote transport provider ; if ( remote transport provider != null ) { builder . add transport provider ( remote transport provider ) ; builder . add transport provider ( remote http transport provider ) ; } }	Perform the configuration of the transport provider.
public static service name context service name of component ( string app , string module , string comp ) { return component context service name . append ( app , module , comp ) ; }	Get the base service name of a component's JNDI namespace.
public static service name context service name of module ( string app , string module ) { return module context service name . append ( app , module ) ; }	Get the base service name of a module's JNDI namespace.
public static bind info bind info for env entry ( string app , string module , string comp , boolean use comp namespace , final string env entry name ) { if ( env entry name . starts with ( str ) ) { if ( use comp namespace ) { return bind info for ( app , module , comp , env entry name ) ; } else { if ( env entry name . starts with ( str ) ) { return bind info for ( app , module , module , str + env entry name . substring ( str . length ( ) ) ) ; } else { return bind info for ( app , module , module , env entry name ) ; } } } else { if ( use comp namespace ) { return bind info for ( app , module , comp , str + env entry name ) ; } else { return bind info for ( app , module , module , str + env entry name ) ; } } }	Get the service name of an environment entry.
public static bind info bind info for ( final string jndi name ) {	Get the service name of a NamingStore.
public concurrent map < principal , domain info > get cache ( ) { return new lru < > ( num , ( key , value ) -> { if ( value != null ) { value . logout ( ) ; } } ) ; }	Returns a default cache implementation.
private value member [ ] get value members ( ) { if ( value members != null ) return value members ; local contained [ ] c = contents ( definition kind . dk , bool ) ; value members = new value member [ c . length ] ; for ( int i = num ; i < c . length ; ++ i ) { value member def impl vmdi = ( value member def impl ) c [ i ] ; value members [ i ] = new value member ( vmdi . name ( ) , vmdi . id ( ) , ( ( local contained ) vmdi . defined in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type def ( ) , vmdi . access ( ) ) ; } return value members ; }	Create the valueMembers array, and return it.
private value member [ ] get value members for type code ( ) { local contained [ ] c = contents ( definition kind . dk , bool ) ; value member [ ] vms = new value member [ c . length ] ; for ( int i = num ; i < c . length ; ++ i ) { value member def impl vmdi = ( value member def impl ) c [ i ] ; vms [ i ] = new value member ( vmdi . name ( ) , null ,	Create a valueMembers array for TypeCode creation only, and return it.
private model node create subsystem root ( ) { model node subsystem address = new model node ( ) ; subsystem address . add ( model description constants . subsystem , federation extension . subsystem name ) ; subsystem address . protect ( ) ; return util . get empty operation ( add , subsystem address ) ; }	Creates the root subsystem's root address.
protected model node parse config ( xml reader , model element xml element , string key , model node last node , list < simple attribute definition > attributes , list < model node > add operations ) throws xml { if ( ! reader . get local name ( ) . equals ( xml element . get name ( ) ) ) { return null ; } model node model node = util . get empty operation ( add , null ) ; int attribute count = reader . get attribute count ( ) ; for ( int i = num ; i < attribute count ; i ++ ) { string attribute local name = reader . get attribute local name ( i ) ; if ( model element . for name ( attribute local name ) == null ) { throw unexpected attribute ( reader , i ) ; } } for ( simple attribute definition simple attribute definition : attributes ) { string attribute value = reader . get attribute value ( str , simple attribute definition . get xml name ( ) ) ; simple attribute definition . parse and set parameter ( attribute value , model node , reader ) ; } string name = xml element . get name ( ) ; if ( key != null ) { name = key ; if ( model node . has defined ( key ) ) { name = model node . get ( key ) . as string ( ) ; } else { string attribute value = reader . get attribute value ( str , key ) ; if ( attribute value != null ) { name = attribute value ; } } } model node . get ( model description constants . op addr ) . set ( last node . clone ( ) . get ( op addr ) . add ( xml element . get name ( ) , name ) ) ; add operations . add ( model node ) ; return model node ; }	Reads a element from the stream considering the parameters.
public void start ( start context context ) throws start exception { root logger . starting service ( ) ; try { naming context . set active naming store ( naming store . get value ( ) ) ; } catch ( throwable t ) { throw new start exception ( naming logger . root logger . failed to start ( str ) , t ) ; } }	Creates a new NamingServer and sets the naming context to use the naming server.
public static service name job operator service name ( final string deployment runtime name , final string subdeployment name ) { return services . deployment unit name ( deployment runtime name , subdeployment name ) . append ( str ) . append ( str ) ; }	Creates the service name used for the job operator registered for the deployment.
public void add component ( final component description description , final virtual file deployment root ) { for ( final view description view description : description . get views ( ) ) { list < view information > view components = components by view name . get ( view description . get view class name ( ) ) ; if ( view components == null ) { view components = new array list < view information > ( num ) ; components by view name . put ( view description . get view class name ( ) , view components ) ; } view components . add ( new view information ( view description , deployment root , description . get component name ( ) ) ) ; } list < description > components = components by name . get ( description . get component name ( ) ) ; if ( components == null ) { components by name . put ( description . get component name ( ) , components = new array list < description > ( num ) ) ; } components . add ( new description ( description , deployment root ) ) ; }	Add a component to this application.
public void add message destination ( final string name , final string resolved name , final virtual file deployment root ) { list < message destination mapping > components = message destination jndi mapping . get ( name ) ; if ( components == null ) { message destination jndi mapping . put ( name , components = new array list < message destination mapping > ( num ) ) ; } components . add ( new message destination mapping ( resolved name , deployment root ) ) ; }	Add a message destination to the application.
public set < view description > get components for view name ( final string view type , final virtual file deployment root ) { final list < view information > info = components by view name . get ( view type ) ; if ( info == null ) { return collections . < view description > empty set ( ) ; } final set < view description > ret = new hash set < view description > ( ) ; final set < view description > current dep = new hash set < view description > ( ) ; for ( view information i : info ) { if ( deployment root . equals ( i . deployment root ) ) { current dep . add ( i . view description ) ; } ret . add ( i . view description ) ; } if ( ! current dep . is empty ( ) ) { return current dep ; } return ret ; }	Get all views that have the given type in the application.
public set < component description > get components ( final string component name , final virtual file deployment root ) { if ( component name . contains ( str ) ) { final string [ ] parts = component name . split ( str ) ; string path = parts [ num ] ; if ( ! path . starts with ( str ) ) { path = str + path ; } final virtual file virtual path = deployment root . get child ( path ) ; final string name = parts [ num ] ; final list < description > info = components by name . get ( name ) ; if ( info == null ) { return collections . empty set ( ) ; } final set < component description > ret = new hash set < component description > ( ) ; for ( description i : info ) {	Get all components in the application that have the given name.
public set < view description > get components ( final string component name , final string view name , final virtual file deployment root ) { final list < view information > info = components by view name . get ( view name ) ; if ( info == null ) { return collections . < view description > empty set ( ) ; } if ( component name . contains ( str ) ) { final string [ ] parts = component name . split ( str ) ; string path = parts [ num ] ; if ( ! path . starts with ( str ) ) { path = str + path ; } final virtual file virtual path = deployment root . get child ( path ) ; final string name = parts [ num ] ; final set < view description > ret = new hash set < view description > ( ) ; for ( view information i : info ) { if ( i . bean name . equals ( name ) ) {	Get all views in the application that have the given name and view type.
public set < string > resolve message destination ( final string message dest name , final virtual file deployment root ) { if ( message dest name . contains ( str ) ) { final string [ ] parts = message dest name . split ( str ) ; string path = parts [ num ] ; if ( ! path . starts with ( str ) ) { path = str + path ; } final virtual file virtual path = deployment root . get child ( path ) ; final string name = parts [ num ] ; final set < string > ret = new hash set < string > ( ) ; final list < message destination mapping > data = message destination jndi mapping . get ( name ) ; if ( data != null ) { for ( final message destination mapping i : data ) {	Resolves a message destination name into a JNDI name.
private static void build transformers2 1 0 ( resource transformation description builder builder ) { resource transformation description builder hornetq server = builder . add child resource ( path element ( hornetq server ) ) ; resource transformation description builder address setting = hornetq server . add child resource ( address setting definition . path ) ; reject defined attribute with default value ( address setting , max redelivery delay , redelivery multiplier ) ; resource transformation description builder bridge = hornetq server . add child resource ( bridge definition . path ) ; bridge . get attribute builder ( ) . set value converter ( new double to big decimal converter ( ) , retry interval multiplier ) ; resource transformation description builder cluster connection = hornetq server . add child resource ( cluster connection definition . path ) ; cluster connection . get attribute builder ( ) . set value converter ( new double to big decimal converter ( ) , retry interval multiplier ) ; resource transformation description builder connection factory = hornetq server . add child resource ( connection factory definition . path ) ; connection factory . get attribute builder ( ) . set value converter ( new double to big decimal converter ( ) , retry interval multiplier ) ; resource transformation description builder pooled connection factory = hornetq server . add child resource ( pooled connection factory definition . path ) ; pooled connection factory . get attribute builder ( ) . set value converter ( new double to big decimal converter ( ) , retry interval multiplier ) ; }	Transformation for WildFly 8.1.0.Final.
private static void reject defined attribute with default value ( resource transformation description builder builder , attribute definition ... attrs ) { for ( attribute definition attr : attrs ) { builder . get attribute builder ( ) . set discard ( new discard attribute value checker ( attr . get default value ( ) ) , attr ) . add reject check ( defined , attr ) ; } }	Reject the attributes if they are defined or discard them if they are undefined or set to their default value.
public static void pop identity ( final context state cache state cache ) { remoting context . set connection ( state cache . get connection ( ) ) ; security context association . set security context ( state cache . get security context ( ) ) ; }	Pop the identity previously associated and restore internal state to it's previous value.
private void load ids manually ( ) { impl ids . put ( str , module identifier . create ( impl module ) ) ; api ids . put ( str , module identifier . create ( api module ) ) ; injection ids . put ( str , module identifier . create ( injection module ) ) ; all versions . add ( str ) ; active versions . add ( str ) ; }	just provide the default implementations.
private void check version integrity ( ) { active versions . add all ( all versions ) ; for ( string version : all versions ) { if ( ! api ids . contains key ( version ) ) { jsf . root logger . missing jsf ( version , api module ) ; active versions . remove ( version ) ; } if ( ! impl ids . contains key ( version ) ) { jsf . root logger . missing jsf ( version , impl module ) ; active versions . remove ( version ) ; } if ( ! injection ids . contains key ( version ) ) { jsf . root logger . missing jsf ( version , injection module ) ; active versions . remove ( version ) ; } } }	make sure that each version has api, impl, and injection.
string compute slot ( string jsf version ) { if ( jsf version == null ) return default slot ; if ( jsf version marker . jsf 2 0 . equals ( jsf version ) ) return default slot ; return jsf version ; }	If needed, convert old JSFVersionMarker values to slot values.
private type code get constant type code ( class cls ) throws ir { if ( cls == null ) throw iiop . root logger . invalid null class ( ) ; type code ret = constant type code map . get ( cls ) ; if ( ret == null ) throw iiop . root logger . bad class for constant ( cls . get name ( ) ) ; return ret ; }	Returns the TypeCode suitable for an IDL constant.
private void add type code ( class cls , type code type code ) throws ir { if ( cls == null ) throw iiop . root logger . invalid null class ( ) ; type code tc = ( type code ) type code map . get ( cls ) ; if ( tc != null ) throw iiop . root logger . duplicate type code for class ( cls . get name ( ) ) ; type code map . put ( cls , type code ) ; }	Add a new IDL TypeCode for a mapped class.
private module def impl ensure package exists ( local container c , string previous , string remainder ) throws ir { if ( str . equals ( remainder ) ) return ( module def impl ) c ;	Ensure that a package exists in the IR.This will create modules in the IR as needed.
private string [ ] add interfaces ( container analysis ca ) throws rmiiiop , ir { interface analysis [ ] interfaces = ca . get interfaces ( ) ; list base interfaces = new array list ( ) ; for ( int i = num ; i < interfaces . length ; ++ i ) { interface def impl idi = add interface ( interfaces [ i ] ) ; base interfaces . add ( idi . id ( ) ) ; } string [ ] str arr = new string [ base interfaces . size ( ) ] ; return ( string [ ] ) base interfaces . to array ( str arr ) ; }	Add a set of interfaces to the IR.
private string [ ] add abstract base valuetypes ( container analysis ca ) throws rmiiiop , ir { value analysis [ ] abstract valuetypes = ca . get abstract base valuetypes ( ) ; list abstract base valuetypes = new array list ( ) ; for ( int i = num ; i < abstract valuetypes . length ; ++ i ) { value def impl vdi = add value ( abstract valuetypes [ i ] ) ; abstract base valuetypes . add ( vdi . id ( ) ) ; } string [ ] str arr = new string [ abstract base valuetypes . size ( ) ] ; return ( string [ ] ) abstract base valuetypes . to array ( str arr ) ; }	Add a set of abstract valuetypes to the IR.
private void add class ( class cls ) throws rmiiiop , ir { if ( cls . is primitive ( ) ) return ;	Map the class and add its IIOP mapping to the repository.
private interface def impl add interface ( interface analysis ia ) throws rmiiiop , ir { interface def impl i def ; class cls = ia . get cls ( ) ;	Add an interface.
private value def impl add value ( value analysis va ) throws rmiiiop , ir { value def impl v def ; class cls = va . get cls ( ) ;	Add a value type.
private exception def impl add exception ( exception analysis ea ) throws rmiiiop , ir { exception def impl e def ; class cls = ea . get cls ( ) ;	Add an exception type.
private string get class level injection type ( final annotation instance annotation ) { boolean is pc = annotation . name ( ) . local ( ) . equals ( str ) ; return is pc ? entity manager class : entity managerfactory class ; }	Based on the the annotation type, its either entitymanager or entitymanagerfactory.
public void start ( final start context context ) throws start exception { if ( store == null ) { final service registry service registry = context . get controller ( ) . get service container ( ) ; final service name service name base = context . get controller ( ) . get name ( ) ; final service target service target = context . get child target ( ) ; store = read only ? new service based naming store ( service registry , service name base ) : new writable service based naming store ( service registry , service name base , service target ) ; } }	Creates the naming store if not provided by the constructor.
public void stop ( stop context context ) { if ( store != null ) { try { store . close ( ) ; store = null ; } catch ( naming exception e ) { throw naming logger . root logger . failed to destroy root context ( e ) ; } } }	Destroys the naming store.
public static void check allowed ( final method type method type ) { final interceptor context context = current invocation context . get ( ) ; if ( context == null ) { return ; } final component component = context . get private data ( component . class ) ; if ( ! ( component instanceof ejb ) ) { return ; } final invocation type invocation type = context . get private data ( invocation type . class ) ; ( ( ejb ) component ) . get allowed methods information ( ) . real check permission ( method type , invocation type ) ; }	Checks that the current method.
private void check transaction sync ( method type method type ) {	transaction sync is not affected by the current invocation, as multiple ejb methods may be invoked from afterCompletion.
private set < string > get all component classes ( deployment unit deployment unit , composite index index , war meta data meta data , tlds meta data tlds meta data ) { final set < string > classes = new hash set < string > ( ) ; get all component classes ( meta data . get merged j ( ) , classes ) ; if ( tlds meta data == null ) return classes ; if ( tlds meta data . get shared tlds ( deployment unit ) != null ) for ( tld meta data tld meta data : tlds meta data . get shared tlds ( deployment unit ) ) { get all component classes ( tld meta data , classes ) ; } if ( tlds meta data . get tlds ( ) != null ) for ( map . entry < string , tld meta data > tld meta data : tlds meta data . get tlds ( ) . entry set ( ) ) { get all component classes ( tld meta data . get value ( ) , classes ) ; } get all async listener classes ( index , classes ) ; return classes ; }	Gets all classes that are eligible for injection etc.
private map < string , timer impl > get waiting on tx completion timers ( ) { map < string , timer impl > timers = null ; if ( get transaction ( ) != null ) { timers = ( map < string , timer impl > ) tsr . get resource ( waiting on tx completion key ) ; } return timers == null ? collections . < string , timer impl > empty map ( ) : timers ; }	Returns an unmodifiable view of timers in the current transaction that are waiting for the transactionto finish.
private static map < string , object > get extra parameters ( final set < string > allowed keys , final map < string , object > parameters ) { map < string , object > extra parameters = new hash map < > ( ) ; for ( map . entry < string , object > parameter : parameters . entry set ( ) ) { if ( ! allowed keys . contains ( parameter . get key ( ) ) ) { extra parameters . put ( parameter . get key ( ) , parameter . get value ( ) ) ; } } for ( string extra param : extra parameters . key set ( ) ) { parameters . remove ( extra param ) ; } return extra parameters ; }	Extract extra parameters from the map of parameters.
public static map < string , object > get parameters ( final operation context context , final model node config , final map < string , string > mapping ) throws operation failed exception { map < string , string > from model = common attributes . params . unwrap ( context , config ) ; map < string , object > parameters = new hash map < > ( ) ; for ( map . entry < string , string > entry : from model . entry set ( ) ) { parameters . put ( mapping . get or default ( entry . get key ( ) , entry . get key ( ) ) , entry . get value ( ) ) ; } return parameters ; }	Get the parameters.
public static class < ? > to class ( type type ) { if ( type instanceof class ) { return ( class ) type ; } else if ( type instanceof parameterized type ) { parameterized type pt = ( parameterized type ) type ; return to class ( pt . get raw type ( ) ) ; } else { throw pojo logger . root logger . unknown type ( type ) ; } }	Turn type into class.
@ suppress warnings ( str ) public static object convert value ( class < ? > clazz , object value , boolean replace properties , boolean trim ) throws throwable { if ( clazz == null ) return value ; if ( value == null ) return null ; class < ? > value class = value . get class ( ) ;	Convert a value.
public static string [ ] get types ( value config [ ] values ) { if ( values == null || values . length == num ) return no params types ; string [ ] types = new string [ values . length ] ; for ( int i = num ; i < types . length ; i ++ ) types [ i ] = values [ i ] . get type ( ) ; return types ; }	Get types from values.
protected static boolean simple check ( string [ ] type names , class < ? > [ ] type infos ) { return type names != null && type infos != null && type names . length == type infos . length ; }	A simple null and length check.
public java . lang . object next ( ) throws naming exception { if ( more && counter >= binding list . value . length ) { get more ( ) ; } if ( more && counter < binding list . value . length ) { org . omg . cos naming . binding bndg = binding list . value [ counter ] ; counter ++ ; return map binding ( bndg ) ; } else { throw new no such element exception ( ) ; } }	Returns the next binding in the list.
private boolean get more ( ) throws naming exception { try { more = binding iter . next n ( batchsize , binding list ) ; counter = num ;	Get the next batch using _bindingIter.
private javax . naming . binding map binding ( org . omg . cos naming . binding bndg ) throws naming exception { java . lang . object obj = ctx . call resolve ( bndg . binding name ) ; name cname = org . wildfly . iiop . openjdk . naming . jndi . cn . cos name to name ( bndg . binding name ) ; try { obj = naming manager . get object instance ( obj , cname , ctx , env ) ; } catch ( naming exception e ) { throw e ; } catch ( exception e ) { naming exception ne = iiop . root logger . error generating object via factory ( ) ; ne . set root cause ( e ) ; throw ne ; }	Constructs a JNDI Binding object from the COS Naming bindingobject.
public void observe resources ( @ observes @ with annotations ( { health . class } ) process annotated type < ? extends health check > event ) { annotated type < ? extends health check > annotated type = event . get annotated type ( ) ; class < ? extends health check > java class = annotated type . get java class ( ) ; micro profile health logger . logger . infof ( str , java class ) ; delegates . add ( annotated type ) ; }	Discover all classes that implements HealthCheckProcedure.
public void close ( @ observes final before shutdown bs ) { health check instances . for each ( health check -> { health reporter . remove health check ( health check . get ( ) ) ; health check . pre destroy ( ) . dispose ( ) ; } ) ; health check instances . clear ( ) ; }	Called when the deployment is undeployed.Remove all the instances of {.
public object handle for locator ( final ejb < ? > locator ) { final org . omg . corba . object reference = reference for locator ( locator ) ; if ( locator instanceof ejb ) { return new iiop ( orb . get value ( ) . object to string ( reference ) ) ; } return new iiop ( orb . get value ( ) . object to string ( reference ) ) ; }	Gets a handle for the given ejb locator.
public static < e extends enum < e > > e as enum ( model node value , class < e > target class ) { return enum . value of ( target class , value . as string ( ) ) ; }	Returns the value of the node as an Enum value.
public static void skip ( input stream is , long amount ) throws io { long left to skip = amount ; long amount skipped = num ; while ( left to skip > num && amount skipped >= num ) { amount skipped = is . skip ( left to skip ) ; left to skip -= amount skipped ; } }	Ensure InputStream actually skips ahead the required number of bytes.
protected static void check not both elements ( xml reader , set < element > seen , element element1 , element element2 ) throws xml { if ( seen . contains ( element1 ) && seen . contains ( element2 ) ) { throw new xml ( messaging logger . root logger . only one required ( element1 . get local name ( ) , element2 . get local name ( ) ) , reader . get location ( ) ) ; } }	Check that not both elements have been defined.
public void add component ( component description description ) { final string component name = description . get component name ( ) ; final string component class name = description . get component class name ( ) ; if ( component name == null ) { throw ee logger . root logger . null var ( str , str , module name ) ; } if ( component class name == null ) { throw ee logger . root logger . null var ( str , str , module name ) ; } if ( components by name . contains key ( component name ) ) { throw ee logger . root logger . component already defined ( component name ) ; } components by name . put ( component name , description ) ; list < component description > list = components by class name . get ( component class name ) ; if ( list == null ) { components by class name . put ( component class name , list = new array list < component description > ( num ) ) ; } list . add ( description ) ; }	Add a component to this module.
public static void add class loaders ( class loader top level , set < class loader > all class loaders ) { deployment class loaders . put ( top level , all class loaders ) ; }	Maps a top level class loader to all CL's in the deployment.
public void unbind ( final name name ) throws naming exception { if ( is last component empty ( name ) ) { throw empty name exception ( ) ; } write lock . lock ( ) ; try { root . accept ( new unbind visitor ( name ) ) ; } finally { write lock . unlock ( ) ; } }	Unbind the entry in the provided location.
public object lookup ( final name name ) throws naming exception { if ( is empty ( name ) ) { final name empty name = new composite name ( str ) ; return new naming context ( empty name , this , new hashtable < string , object > ( ) ) ; } return root . accept ( new lookup visitor ( name ) ) ; }	Lookup the object value of a binding node in the tree.
public list < name class pair > list ( final name name ) throws naming exception { final name node name = name . is empty ( ) ? new composite name ( str ) : name ; return root . accept ( new list visitor ( node name ) ) ; }	List all NameClassPair instances at a given location in the tree.
public list < binding > list bindings ( final name name ) throws naming exception { final name node name = name . is empty ( ) ? new composite name ( str ) : name ; return root . accept ( new list bindings visitor ( node name ) ) ; }	List all the Binding instances at a given location in the tree.
public synchronized void add factory ( context handle factory factory ) { final string factory name = factory . get name ( ) ; if ( factory map . contains key ( factory name ) ) { throw ee logger . root logger . factory already exists ( this , factory name ) ; } factory map . put ( factory name , factory ) ; final comparator < context handle factory > comparator = new comparator < context handle factory > ( ) { @ override public int compare ( context handle factory o1 , context handle factory o2 ) { return integer . compare ( o1 . get chain priority ( ) , o2 . get chain priority ( ) ) ; } } ; sorted set < context handle factory > sorted set = new tree set < > ( comparator ) ; sorted set . add all ( factory map . values ( ) ) ; factory ordered list = new array list < > ( sorted set ) ; }	Adds a new factory.
public setup context handle save context ( context service context service , map < string , string > context object properties ) { final list < setup context handle > handles = new array list < > ( factory ordered list . size ( ) ) ; for ( context handle factory factory : factory ordered list ) { handles . add ( factory . save context ( context service , context object properties ) ) ; } return new chained setup context handle ( this , handles ) ; }	Saves the current invocation context on a chained context handle.
private void create io subsystem ( operation context context , map < path address , model node > migration operations , path address base address ) { resource root = context . read resource from root ( base address , bool ) ; if ( root . get children names ( subsystem ) . contains ( io . subsystem name ) ) {	We need to create the IO subsystem, if it does not already exist.
private void create welcome content handler ( map < path address , model node > migration operations ) { path address address = path address ( path element ( subsystem , undertow extension . subsystem name ) , path element ( constants . configuration , constants . handler ) ) ; migration operations . put ( address , create add operation ( address ) ) ; address = path address ( path element ( subsystem , undertow extension . subsystem name ) , path element ( constants . configuration , constants . handler ) , path element ( constants . file , str ) ) ; final model node add = create add operation ( address ) ; add . get ( constants . path ) . set ( new model node ( new value expression ( str ) ) ) ; migration operations . put ( address , add ) ; }	create a handler for serving welcome content.
public t get ( ) { try { boolean acquired = semaphore . try acquire ( timeout , time unit ) ; if ( ! acquired ) throw ejb logger . root logger . failed to acquire permit ( timeout , time unit ) ; } catch ( interrupted exception e ) { throw ejb logger . root logger . acquire semaphore interrupted ( ) ; } t bean = pool . poll ( ) ; if ( bean != null ) {	Get an instance without identity.Can be used by finders,create-methods, and activation.
protected void calculate operation analysis map ( ) { operation analysis map = new hash map ( ) ; operation analysis oa ;	Calculate the map that maps IDL operation names to operation analyses.Besides mapped operations, this map also contains the attributeaccessor and mutator operations.
public metric registration collect resource metrics ( final resource resource , immutable management resource registration management resource registration , function < path address , path address > resource address resolver ) { metric registration registration = new metric registration ( ) ; collect resource metrics0 ( resource , management resource registration , empty address , resource address resolver , registration ) ; return registration ; }	collect metrics from the resources.
protected deployment unit do prepare ( string context , class loader loader , map < string , string > url pattern to class name map , j jbwmd , webservices meta data metadata , j jbws metadata ) { class loader orig class loader = wild fly security manager . get current context class loader privileged ( ) ; ws unit = new ws ( loader , context , url pattern to class name map , jbwmd , metadata , jbws metadata ) ; try { wild fly security manager . set current context class loader privileged ( class loader provider . get default provider ( ) . get server integration class loader ( ) ) ; ws . get instance ( ) . build ( unit ) ; return unit ; } finally { wild fly security manager . set current context class loader privileged ( orig class loader ) ; } }	Prepare the ws Deployment and return a DeploymentUnit containing it.
protected void do deploy ( service target target , deployment unit unit ) { list < deployment aspect > aspects = get deployment aspects ( ) ; class loader orig class loader = wild fly security manager . get current context class loader privileged ( ) ; deployment dep = null ; try { wild fly security manager . set current context class loader privileged ( class loader provider . get default provider ( ) . get server integration class loader ( ) ) ; dep = unit . get attachment ( ws . deployment key ) ; dep . add attachment ( service target . class , target ) ; deployment aspect manager dam = new deployment aspect manager impl ( ) ; dam . set deployment aspects ( aspects ) ; dam . deploy ( dep ) ; } finally { if ( dep != null ) { dep . remove attachment ( service target . class ) ; } wild fly security manager . set current context class loader privileged ( orig class loader ) ; } }	Triggers the WS deployment aspects, which process the deployment andinstall the endpoint services.
protected context do publish ( service target target , deployment unit unit ) throws exception { deployment deployment = unit . get attachment ( ws . deployment key ) ; list < endpoint > endpoints = deployment . get service ( ) . get endpoints ( ) ;	Publish the webapp for the WS deployment unit.
protected void stop web app ( deployment deployment ) throws exception { web deployment controller context ; try { context = deployment . get attachment ( web deployment controller . class ) ; context . stop ( ) ; } catch ( exception e ) { throw ws . root logger . stop context phase failed ( e ) ; } try { context . destroy ( ) ; } catch ( exception e ) { throw ws . root logger . destroy context phase failed ( e ) ; } }	Stops the webapp serving the provided ws deployment.
public synchronized void start ( final start context context ) { if ( started ) { throw weld logger . root logger . already running ( str ) ; } started = bool ; weld logger . deployment logger . starting weld service ( deployment name ) ;	Starts the weld container.
public void register endpoint config ( final string endpoint class , final endpoint config config ) { if ( ( endpoint class == null ) || ( config == null ) ) { throw new illegal argument exception ( ) ; } endpoint config map . put ( endpoint class , config ) ; }	Registers endpoint and its config.
protected void retry timeout ( timer impl timer ) throws exception { boolean call timeout = bool ; timer . lock ( ) ; try { if ( timer . is active ( ) ) { ej timer logger . retrying timeout ( timer ) ; timer . set timer state ( timer state . retry timeout , thread . current thread ( ) ) ; timer service . persist timer ( timer , bool ) ; call timeout = bool ; } else { ej timer logger . timer not active ( timer ) ; } } finally { timer . unlock ( ) ; } if ( call timeout ) { this . call timeout ( timer ) ; } }	After a timeout failed the timer need to retried.The method must lock the timer for state check and update but not during callTimeout run.
protected void post timeout processing ( timer impl timer ) throws interrupted exception { timer . lock ( ) ; try { timer state timer state = timer . get state ( ) ; if ( timer state != timer state . canceled && timer state != timer state . expired ) { if ( timer . get interval ( ) == num ) { timer service . expire timer ( timer ) ; } else { timer . set timer state ( timer state . active , null ) ; } timer service . persist timer ( timer , bool ) ; } } finally { timer . unlock ( ) ; } }	After running the timer calculate the new state or expire the timer and persist it if changed.The method must lock the timer for state check and updates if overridden.
static method [ ] get declared methods ( final class < ? > c ) { if ( system . get security manager ( ) == null ) return c . get declared methods ( ) ; return access controller . do privileged ( new privileged action < method [ ] > ( ) { public method [ ] run ( ) { return c . get declared methods ( ) ; } } ) ; }	Get the declared methods.
static field [ ] get declared fields ( final class < ? > c ) { if ( system . get security manager ( ) == null ) return c . get declared fields ( ) ; return access controller . do privileged ( new privileged action < field [ ] > ( ) { public field [ ] run ( ) { return c . get declared fields ( ) ; } } ) ; }	Get the declared fields.
static constructor < ? > get constructor ( final class < ? > c , final class < ? > ... params ) throws no such method exception { if ( system . get security manager ( ) == null ) return c . get constructor ( params ) ; constructor < ? > result = access controller . do privileged ( new privileged action < constructor < ? > > ( ) { public constructor < ? > run ( ) { try { return c . get constructor ( params ) ; } catch ( no such method exception e ) { return null ; } } } ) ; if ( result != null ) return result ; throw new no such method exception ( ) ; }	Get the constructor.
static method get method ( final class < ? > c , final string name , final class < ? > ... params ) throws no such method exception { if ( system . get security manager ( ) == null ) return c . get method ( name , params ) ; method result = access controller . do privileged ( new privileged action < method > ( ) { public method run ( ) { try { return c . get method ( name , params ) ; } catch ( no such method exception e ) { return null ; } } } ) ; if ( result != null ) return result ; throw new no such method exception ( ) ; }	Get the method.
private void add messaging active mq ( operation context context , map < path address , model node > migration operations , boolean describe ) { resource root = context . read resource from root ( path address . empty address , bool ) ; if ( root . get children names ( extension ) . contains ( messaging activemq extension ) ) {	It's possible that the extension is already present.
private boolean parameter is allowed ( string name , string resource type ) { switch ( resource type ) { case remote acceptor : case http acceptor : case remote connector : case http connector :	Check if the name of the parameter is allowed for the given resourceType.
private void migrate generic transport ( model node add operation ) { string factory class = add operation . get ( factory class . get name ( ) ) . as string ( ) ; final string new factory class ; switch ( factory class ) { case hornetq netty acceptor factory : new factory class = artemis netty acceptor factory ; break ; case hornetq netty connector factory : new factory class = artemis netty connector factory ; break ; default : new factory class = factory class ; } add operation . get ( factory class . get name ( ) ) . set ( new factory class ) ; }	For generic acceptor and connectors, migrate their factory-class attributeif they are using the default Netty ones.
public boolean cancel ( boolean set flag ) { final atomic integer state ref = this . state ref ; int old val , new val ; do { old val = state ref . get ( ) ; if ( old val == st waiting ) { new val = st cancelled ; } else if ( old val == st cancelled ) { if ( ! set flag ) { return bool ; } new val = st cancelled flag set ; } else if ( old val == st cancelled flag set ) {	Attempt to cancel the corresponding invocation.
public boolean run if not cancelled ( ) { final atomic integer state ref = this . state ref ; int old val ; do { old val = state ref . get ( ) ; if ( old val == st cancelled || old val == st cancelled flag set ) { return bool ; } else if ( old val != st waiting ) { throw assert . unreachable code ( ) ; } } while ( ! state ref . compare and set ( old val , st started ) ) ; return bool ; }	Attempt to determine whether the invocation should proceed or whether it should be cancelled.
protected void set type internal ( final o i type ) { get database ( ) . check security ( o . resource generic . schema , o . permission update ) ; acquire schema write lock ( ) ; try { if ( i type == global ref . get type ( ) )	Change the type. It checks for compatibility between the change of type.
public boolean can execute indexed function without index ( o target , o context , o operator , object right ) { if ( this . identifier == null ) { return bool ; } return identifier . can execute indexed function without index ( target , context , operator , right ) ; }	tests if current expression is an indexed funciton AND that function can also be executed without using the index.
private static list < class < ? > > find classes ( final file i directory , string i package name , class loader i class loader ) throws class not found exception { final list < class < ? > > classes = new array list < class < ? > > ( ) ; if ( ! i directory . exists ( ) ) return classes ; i package name += str + i directory . get name ( ) ; string class name ; final file [ ] files = i directory . list files ( ) ; if ( files != null ) for ( file file : files ) { if ( file . is directory ( ) ) { if ( file . get name ( ) . contains ( str ) ) continue ; classes . add all ( find classes ( file , i package name , i class loader ) ) ; } else if ( file . get name ( ) . ends with ( class extension ) ) { class name = file . get name ( ) . substring ( num , file . get name ( ) . length ( ) - class extension . length ( ) ) ; classes . add ( class . for name ( i package name + str + class name , bool , i class loader ) ) ; } } return classes ; }	Recursive method used to find all classes in a given directory and subdirs.
public static list < class < ? > > get classess of interface ( string the package , class < ? > the interface , final class loader i class loader ) { list < class < ? > > class list = new array list < class < ? > > ( ) ; try { for ( class < ? > discovered : get classes for ( the package , i class loader ) ) { if ( arrays . as list ( discovered . get interfaces ( ) ) . contains ( the interface ) ) { class list . add ( discovered ) ; } } } catch ( class not found exception ex ) { o . instance ( ) . error ( null , str , ex ) ; } return class list ; }	Filters discovered classes to see if they implement a given interface.
public static class < ? > get generic multivalue type ( final field p ) { if ( p . get type ( ) instanceof class < ? > ) { final type generic type = p . get generic type ( ) ; if ( generic type != null && generic type instanceof parameterized type ) { final parameterized type pt = ( parameterized type ) generic type ; if ( pt . get actual type arguments ( ) != null && pt . get actual type arguments ( ) . length > num ) { if ( ( ( class < ? > ) pt . get raw type ( ) ) . is assignable from ( map . class ) ) { if ( pt . get actual type arguments ( ) [ num ] instanceof class < ? > ) { return ( class < ? > ) pt . get actual type arguments ( ) [ num ] ; } else if ( pt . get actual type arguments ( ) [ num ] instanceof parameterized type ) return ( class < ? > ) ( ( parameterized type ) pt . get actual type arguments ( ) [ num ] ) . get raw type ( ) ; } else if ( pt . get actual type arguments ( ) [ num ] instanceof class < ? > ) { return ( class < ? > ) pt . get actual type arguments ( ) [ num ] ; } else if ( pt . get actual type arguments ( ) [ num ] instanceof parameterized type ) return ( class < ? > ) ( ( parameterized type ) pt . get actual type arguments ( ) [ num ] ) . get raw type ( ) ; } } else if ( p . get type ( ) . is array ( ) ) return p . get type ( ) . get component type ( ) ; } return null ; }	Returns the generic class of multi-value objects.
@ override public object evaluate record ( final o i record , o i current result , final osql i condition , final object i left , final object i right , o i context , final o serializer ) { if ( i left == null || i right == null ) return bool ; return i left . to string ( ) . index of ( i right . to string ( ) ) > - num ; }	This is executed on non-indexed fields.
protected o derive field type ( o i record , string field name , o requested field type ) {	Derives the type of a field in a document.
public void update record ( final o record ) { if ( record . get identity ( ) . get cluster id ( ) != excluded cluster && record . get identity ( ) . is valid ( ) && ! record . is dirty ( ) && ! o . is tombstone ( record . get version ( ) ) ) { if ( underlying . get ( record . get identity ( ) ) != record ) underlying . put ( record ) ; } }	Pushes record to cache. Identifier of record used as access key.
public o find record ( final orid rid ) { o record ; record = underlying . get ( rid ) ; if ( record != null ) orient . instance ( ) . get profiler ( ) . update counter ( cache hit , str , num , str ) ; else orient . instance ( ) . get profiler ( ) . update counter ( cache miss , str , num , str ) ; return record ; }	Looks up for record in cache by it's identifier. Optionally look up in secondary cache and update primary with found record.
private map < string , set < string > > get minimal set of nodes for sharded query ( string local node , map < string , set < string > > cluster map , set < string > query clusters ) {	given a cluster map and a set of clusters involved in a query, tries to calculate the minimum number of nodes that will have tobe involved in the query execution, with clusters involved for each node.
private static list < o > move flatteded equalities left ( list < o > flattened where clause ) { if ( flattened where clause == null ) { return null ; } list < o > result = new array list < > ( ) ; for ( o block : flattened where clause ) { list < o > equality expressions = new array list < > ( ) ; list < o > non equality expressions = new array list < > ( ) ; o new block = block . copy ( ) ; for ( o exp : new block . get sub blocks ( ) ) { if ( exp instanceof o ) { if ( ( ( o ) exp ) . get operator ( ) instanceof o ) { equality expressions . add ( exp ) ; } else { non equality expressions . add ( exp ) ; } } else { non equality expressions . add ( exp ) ; } } o new and = new o ( - num ) ; new and . get sub blocks ( ) . add all ( equality expressions ) ; new and . get sub blocks ( ) . add all ( non equality expressions ) ; result . add ( new and ) ; } return result ; }	re-writes a list of flat AND conditions, moving left all the equality operations.
private static void add order by projections ( query planning info info ) { if ( info . order applied || info . expand || info . unwind != null || info . order by == null || info . order by . get items ( ) . size ( ) == num || info . projection == null || info . projection . get items ( ) == null || ( info . projection . get items ( ) . size ( ) == num && info . projection . get items ( ) . get ( num ) . is all ( ) ) ) { return ; } o new order by = info . order by == null ? null : info . order by . copy ( ) ; list < o > additional order by projections = calculate additional order by projections ( info . projection . get all aliases ( ) , new order by ) ; if ( additional order by projections . size ( ) > num ) { info . order by = new order by ;	creates additional projections for ORDER BY.
private static void extract sub queries ( query planning info info ) { sub query collector collector = new sub query collector ( ) ; if ( info . per record let clause != null ) { info . per record let clause . extract sub queries ( collector ) ; } int i = num ; int j = num ; for ( map . entry < o , o > entry : collector . get sub queries ( ) . entry set ( ) ) { o alias = entry . get key ( ) ; o query = entry . get value ( ) ; if ( query . refers to parent ( ) ) { add record level let ( info , alias , query , j ++ ) ; } else { add global let ( info , alias , query , i ++ ) ; } } collector . reset ( ) ; if ( info . where clause != null ) { info . where clause . extract sub queries ( collector ) ; } if ( info . projection != null ) { info . projection . extract sub queries ( collector ) ; } if ( info . order by != null ) { info . order by . extract sub queries ( collector ) ; } if ( info . group by != null ) { info . group by . extract sub queries ( collector ) ; } for ( map . entry < o , o > entry : collector . get sub queries ( ) . entry set ( ) ) { o alias = entry . get key ( ) ; o query = entry . get value ( ) ; if ( query . refers to parent ( ) ) { add record level let ( info , alias , query ) ; } else { add global let ( info , alias , query ) ; } } }	translates subqueries to LET statements.
private boolean is from clusters ( o rid , set < string > filter clusters , o database ) { if ( filter clusters == null ) { throw new illegal argument exception ( ) ; } string cluster name = database . get cluster name by id ( rid . get cluster ( ) . get value ( ) . int value ( ) ) ; return filter clusters . contains ( cluster name ) ; }	checks if this RID is from one of these clusters.
private boolean handle class with index for sort only ( o plan , o query target , set < string > filter clusters , query planning info info , o ctx , boolean profiling enabled ) { o schema = get schema from context ( ctx ) ; o clazz = schema . get class ( query target . get string value ( ) ) ; if ( clazz == null ) { clazz = schema . get view ( query target . get string value ( ) ) ; if ( clazz == null ) { throw new o ( str + query target ) ; } } for ( o idx : clazz . get indexes ( ) . stream ( ) . filter ( i -> i . supports ordered iterations ( ) ) . filter ( i -> i . get definition ( ) != null ) . collect ( collectors . to list ( ) ) ) { list < string > index fields = idx . get definition ( ) . get fields ( ) ; if ( index fields . size ( ) < info . order by . get items ( ) . size ( ) ) { continue ; } boolean index found = bool ; string order type = null ; for ( int i = num ; i < info . order by . get items ( ) . size ( ) ; i ++ ) { o order item = info . order by . get items ( ) . get ( i ) ; if ( order item . get collate ( ) != null ) { return bool ; } string index field = index fields . get ( i ) ; if ( i == num ) { order type = order item . get type ( ) ; } else { if ( order type == null || ! order type . equals ( order item . get type ( ) ) ) { index found = bool ; break ;	tries to use an index for sorting only. Also adds the fetch step to the execution plan.
private boolean is diamond hierarchy ( o clazz ) { set < o > traversed = new hash set < > ( ) ; list < o > stack = new array list < > ( ) ; stack . add ( clazz ) ; while ( ! stack . is empty ( ) ) { o current = stack . remove ( num ) ; traversed . add ( current ) ; for ( o sub : current . get subclasses ( ) ) { if ( traversed . contains ( sub ) ) { return bool ; } stack . add ( sub ) ; traversed . add ( sub ) ; } } return bool ; }	checks if a class is the top of a diamond hierarchy.
private boolean get order direction ( query planning info info ) { if ( info . order by == null ) { return null ; } string result = null ; for ( o item : info . order by . get items ( ) ) { if ( result == null ) { result = item . get type ( ) == null ? o . asc : item . get type ( ) ; } else { string new type = item . get type ( ) == null ? o . asc : item . get type ( ) ; if ( ! new type . equals ( result ) ) { return null ; } } } return result == null || result . equals ( o . asc ) ; }	returns TRUE if all the order clauses are ASC, FALSE if all are DESC, null otherwise.
private boolean requires multiple index lookups ( o key condition ) { for ( o o boolean expression : key condition . get sub blocks ( ) ) { if ( ! ( o boolean expression instanceof o ) ) { return bool ; } } return bool ; }	checks whether the condition has CONTAINSANY or similar expressions, that require multiple index evaluations.
private index search descriptor find best index for ( o ctx , set < o < ? > > indexes , o block , o clazz ) {	given a flat AND block and a set of indexes, returns the best index to be used to process it, with the complete description onhow to use it.
private list < index search descriptor > common factor ( list < index search descriptor > index search descriptors ) {	aggregates multiple index conditions that refer to the same key search.
public o create ( int strategy ) { optional < o > registered = o . get instance ( ) . get strategy ( strategy ) ; if ( registered . is present ( ) ) { return registered . get ( ) ; } map < o , o o > type handling strategies = new hash map < o , o o > ( ) ; switch ( strategy ) { case single orecord bytes : type handling strategies . put ( o . binary , new o o ( ) ) ; break ; case split orecord bytes : type handling strategies . put ( o . binary , new o o ( ) ) ; break ; case simple : default : break ; } o strategy instance = new o ( type handling strategies ) ; o . get instance ( ) . register strategy ( strategy , strategy instance ) ; return strategy instance ; }	Creates a new instance of the requested strategy.
public o allow ( final o . resource generic resource generic , string resource specific , final int i operation ) { if ( roles == null || roles . is empty ( ) ) { if ( document . field ( str ) != null && ! ( ( collection < o > ) document . field ( str ) ) . is empty ( ) ) { final o doc = document ; document = null ; from stream ( doc ) ; } else throw new o ( document . get database ( ) . get name ( ) , str + document . field ( str ) + str ) ; } final o role = check if allowed ( resource generic , resource specific , i operation ) ; if ( role == null ) throw new o ( document . get database ( ) . get name ( ) , str + document . field ( str ) + str + o . permission to string ( i operation ) + str + resource generic + str + resource specific ) ; return role ; }	Checks if the user has the permission to access to the requested resource for the requested operation.
public boolean is rule defined ( final o . resource generic resource generic , string resource specific ) { for ( o r : roles ) if ( r == null ) o . instance ( ) . warn ( this , str , get name ( ) ) ; else if ( r . has rule ( resource generic , resource specific ) ) return bool ; return bool ; }	Checks if a rule was defined for the user.
public static string get compact server status ( final o manager , final o distrib cfg ) { final string builder buffer = new string builder ( ) ; final collection < o > members = distrib cfg . field ( str ) ; if ( members != null ) { buffer . append ( members . size ( ) ) ; buffer . append ( str ) ; int member count = num ; for ( o m : members ) { if ( m == null ) continue ; if ( member count ++ > num ) buffer . append ( str ) ; final string server name = m . field ( str ) ; buffer . append ( server name ) ; buffer . append ( ( object ) m . field ( str ) ) ; final collection < string > databases = m . field ( str ) ; if ( databases != null ) { buffer . append ( str ) ; int db count = num ; for ( string db name : databases ) { final o db cfg = manager . get database configuration ( db name , bool ) ; if ( db cfg == null ) continue ; if ( db count ++ > num ) buffer . append ( str ) ; buffer . append ( db name ) ; buffer . append ( str ) ; buffer . append ( manager . get database status ( server name , db name ) ) ; buffer . append ( str ) ; buffer . append ( db cfg . get server role ( server name ) ) ; buffer . append ( str ) ; } buffer . append ( str ) ; } } buffer . append ( str ) ; } return buffer . to string ( ) ; }	Create a compact string with all the relevant information.
protected void init system database ( ) { final o default cfg = get storage ( o . system db name ) . load database configuration ( get default database config file ( ) ) ; default cfg . field ( str , bool ) ; final o sys cfg = new o ( default cfg ) ; sys cfg . remove server ( str ) ; message service . register database ( o . system db name , sys cfg ) ; sys cfg . add new node in server list ( get local node name ( ) ) ; }	Protecte system database from being replicated.
protected void load local databases ( ) { final list < string > dbs = new array list < string > ( server instance . get available storage names ( ) . key set ( ) ) ; collections . sort ( dbs ) ; for ( final string database name : dbs ) { if ( message service . get database ( database name ) == null ) { o . info ( this , node name , null , direction . none , str , database name ) ;	Initializes all the available server's databases as distributed.
@ override public void member removed ( final membership event i event ) { try { update last cluster change ( ) ; if ( i event . get member ( ) == null ) return ; final string node left name = get node name ( i event . get member ( ) ) ; if ( node left name == null ) return ; remove server ( node left name , bool ) ; } catch ( hazelcast instance not active exception | retryable hazelcast exception e ) { o . instance ( ) . error ( this , str , e ) ; } catch ( exception e ) { o . instance ( ) . error ( this , str , e , get node name ( i event . get member ( ) ) ) ; } }	Removes the node map entry.
@ override public string elect new lock manager ( ) { if ( hazelcast instance == null ) throw new hazelcast instance not active exception ( ) ; final i lock = hazelcast instance . get lock ( str ) ; lock . lock ( ) ; try {	Elects a new server as coordinator.
private void assign lock manager from cluster ( ) { string lock manager server = null ; while ( lock manager server == null ) { if ( active nodes . size ( ) == num ) {	ASSIGN THE LOCK MANAGER AT STARTUP.
public void commit ( ) { if ( ! active ) throw error ( str ) ; if ( level < num ) throw error ( str + level ) ; -- level ; if ( level == num ) { active = bool ; do commit ( ) ; } }	Commits the micro-transaction if it's a top-level micro-transaction.
public void rollback ( ) { if ( ! active ) throw error ( str ) ; if ( level < num ) throw error ( str + level ) ; -- level ; if ( level == num ) { active = bool ; do rollback ( ) ; } }	Rollbacks the micro-transaction if it's a top-level micro-transaction.
public void update identity after record commit ( final orid old rid , final orid new rid ) { if ( old rid . equals ( new rid ) ) return ;	Updates the record identity after its successful commit.
public void update record cache after rollback ( ) { final o database local cache = database . get local cache ( ) ; for ( o record operation : record operations . values ( ) ) database local cache . delete record ( record operation . get record ( ) . get identity ( ) ) ; }	Updates the record cache after unsuccessful micro-transaction commit.
public static void prepare for file creation or replacement ( path path , object requester , string operation ) throws io { if ( files . delete if exists ( path ) ) o . instance ( ) . warn ( requester , str , path , operation ) ; final path parent = path . get parent ( ) ; if ( parent != null ) files . create directories ( parent ) ; }	Prepares the path for a file creation or replacement.
public static void atomic move with fallback ( path source , path target , object requester ) throws io { try { files . move ( source , target , standard copy option . atomic move ) ; } catch ( atomic move not supported exception ignore ) { o . instance ( ) . warn ( requester , str , source , target ) ; files . move ( source , target ) ; } }	Tries to move a file from the source to the target atomically.
public list < pattern > get disjoint patterns ( ) { map < pattern node , string > reverse map = new identity hash map < > ( ) ; reverse map . put all ( this . alias to node . entry set ( ) . stream ( ) . collect ( collectors . to map ( x -> x . get value ( ) , x -> x . get key ( ) ) ) ) ; list < pattern > result = new array list < > ( ) ; while ( ! reverse map . is empty ( ) ) { pattern pattern = new pattern ( ) ; result . add ( pattern ) ; map . entry < pattern node , string > next node = reverse map . entry set ( ) . iterator ( ) . next ( ) ; set < pattern node > to visit = new hash set < > ( ) ; to visit . add ( next node . get key ( ) ) ; while ( to visit . size ( ) > num ) { pattern node current node = to visit . iterator ( ) . next ( ) ; to visit . remove ( current node ) ; if ( reverse map . contains key ( current node ) ) { pattern . alias to node . put ( reverse map . get ( current node ) , current node ) ; reverse map . remove ( current node ) ; for ( pattern edge x : current node . out ) { to visit . add ( x . in ) ; } for ( pattern edge x : current node . in ) { to visit . add ( x . out ) ; } } } pattern . recalculate num of edges ( ) ; } return result ; }	splits this pattern into multiple.
protected boolean execute only locally ( final string local node name , final o db cfg , final o exec , final collection < string > involved clusters , final collection < string > nodes ) { boolean execute locally = bool ; if ( exec . is idempotent ( ) ) { final int available nodes = nodes . size ( ) ;	Only idempotent commands that don't involve any other node can be executed locally.
@ override public void characters ( char [ ] ch , int start , int length ) throws sax { builder . append ( ch , start , length ) ; }	Collect up the characters, as element's characters may be split across multiple calls.
public boolean is connected ( ) { final socket s = socket ; return s != null && ! s . is closed ( ) && s . is connected ( ) && ! s . is input shutdown ( ) && ! s . is output shutdown ( ) ; }	Tells if the channel is connected.
public static short merge short from buffers ( final byte buffer buffer , final byte buffer buffer1 ) { short result = num ; result = ( short ) ( result | ( buffer . get ( ) & mask ) ) ; result = ( short ) ( result << size of byte in bits ) ; result = ( short ) ( result | ( buffer1 . get ( ) & mask ) ) ; return result ; }	Merge short value from two byte buffer.
public static void split short to buffers ( final byte buffer buffer , final byte buffer buffer1 , final short i value ) { buffer . put ( ( byte ) ( mask & ( i value > > > size of byte in bits ) ) ) ; buffer1 . put ( ( byte ) ( mask & i value ) ) ; }	Split short value into two byte buffer.
public object execute ( final map < object , object > i args ) { if ( type == null ) throw new o ( str ) ; final o database = get database ( ) ; final o source class = ( o ) database . get metadata ( ) . get schema ( ) . get class ( class name ) ; if ( source class == null ) throw new o ( str + class name + str ) ; o prop = ( o ) source class . get property ( field name ) ; if ( prop != null ) { if ( if not exists ) { return source class . properties ( ) . size ( ) ; } throw new o ( str + class name + str + field name + str ) ; }	Execute the CREATE PROPERTY.
@ override public o put ( object key , final o single value ) { if ( key == null ) { return this ; } key = get collating value ( key ) ; final set < string > words = split into words ( key . to string ( ) ) ;	Indexes a value and save the index.
@ override public boolean remove ( object key , final o value ) { if ( key == null ) { return bool ; } key = get collating value ( key ) ; final set < string > words = split into words ( key . to string ( ) ) ; final o removed = new o ( bool ) ; for ( final string word : words ) { acquire shared lock ( ) ; try { if ( api version == num ) { remove v0 ( value , removed , word ) ; } else if ( api version == num ) { remove v1 ( value , removed , word ) ; } else { throw new illegal state exception ( str + api version ) ; } } finally { release shared lock ( ) ; } } return removed . get value ( ) ; }	Splits passed in key on several words and remove records with keys equals to any item of split result and values equals topassed in value.
@ suppress warnings ( str ) public list < t > run ( final object ... i args ) { final o database = o . instance ( ) . get ( ) ; if ( database == null ) throw new o ( str ) ; ( ( o ) database . get metadata ( ) ) . make thread local schema snapshot ( ) ; try { set parameters ( i args ) ; object o = database . get storage ( ) . command ( this ) ; if ( o instanceof list ) { return ( list < t > ) o ; } else { return ( list < t > ) collections . singleton list ( o ) ; } } finally { ( ( o ) database . get metadata ( ) ) . clear thread local schema snapshot ( ) ; } }	Delegates to the OQueryExecutor the query execution.
public t run first ( final object ... i args ) { set limit ( num ) ; final list < t > result = execute ( i args ) ; return result != null && ! result . is empty ( ) ? result . get ( num ) : null ; }	Returns only the first record if any.
public void create ( ) throws io { acquire write lock ( ) ; try { acquire exclusive access ( ) ; open channel ( ) ; init ( ) ; set version ( o . current version ) ; version = o . current version ; init allocation mode ( ) ; } finally { release write lock ( ) ; } }	Creates the file.
private long check regions ( final long i offset , final long i length ) { acquire read lock ( ) ; try { if ( i offset < num || i offset + i length > size ) { throw new oio ( str + size + str + i offset + str + ( i offset + i length ) + str + this ) ; } return i offset + header size ; } finally { release read lock ( ) ; } }	ALWAYS ADD THE HEADER SIZE BECAUSE ON THIS TYPE IS ALWAYS NEEDED.
public void replace content with ( final path new content file ) throws io { acquire write lock ( ) ; try { close ( ) ; files . copy ( new content file , os file , standard copy option . replace existing ) ; open ( ) ; } finally { release write lock ( ) ; } }	Replaces the file content with the content of the provided file.
public object command ( final o i command ) { final boolean live = i command instanceof o ; final o database = o . instance ( ) . get ( ) ; final boolean asynch = i command instanceof o && ( ( o ) i command ) . is asynchronous ( ) ; o request = new o ( database , asynch , i command , live ) ; o response = network operation ( request , str + i command ) ; return response . get result ( ) ; }	Execute the command remotely and get the results back.
public void end request ( final o i network ) throws io { if ( i network == null ) return ; i network . flush ( ) ; i network . release write lock ( ) ; }	Ends the request and unlock the write lock.
protected string add host ( string host ) { if ( host . starts with ( localhost ) ) host = local ip + host . substring ( str . length ( ) ) ; if ( host . contains ( str ) ) host = host . substring ( num , host . index of ( str ) ) ;	Registers the remote server with port.
public o begin request ( final o network , final byte i command , o session ) throws io { network . begin request ( i command , session ) ; return network ; }	Acquire a network channel from the pool.
protected static o get database ( ) { o < ? > database owner = o . instance ( ) . get ( ) . get database owner ( ) ; if ( database owner instanceof o ) { return ( o ) database owner ; } else if ( database owner instanceof o ) { return new o ( ( o ) database owner ) ; } throw new illegal state exception ( str ) ; }	Gets the current thread database as a ODatabasePojoAbstract, wrapping it where necessary.
public o get connection ( final int i channel id , o protocol ) {	Retrieves the connection by id.
public void kill ( final o connection ) { if ( connection != null ) { final o protocol = connection . get protocol ( ) ; try {	Disconnects and kill the associated network manager.
public void interrupt ( final int i channel id ) { final o connection = connections . get ( i channel id ) ; if ( connection != null ) { final o protocol = connection . get protocol ( ) ; if ( protocol != null )	Interrupt the associated network manager.
public boolean disconnect ( final int i channel id ) { o . instance ( ) . debug ( this , str , i channel id ) ; final o connection = connections . remove ( i channel id ) ; if ( connection != null ) { o . invoke handler callback on client disconnection ( server , connection ) ; connection . close ( ) ; remove connection from session ( connection ) ;	Disconnects a client connections.
public void push distrib cfg2 clients ( final o i config ) { if ( i config == null ) return ; final set < string > pushed = new hash set < string > ( ) ; for ( o c : connections . values ( ) ) { if ( ! c . get data ( ) . supports legacy push messages ) continue ; try { final string remote address = c . get remote address ( ) ; if ( pushed . contains ( remote address ) )	Pushes the distributed configuration to all the connected clients.
public boolean swap ( int index , o new value ) { entries iterator iter = ( entries iterator ) raw iterator ( ) ; int curr index = num ; while ( iter . has next ( ) ) { iter . next ( ) ; if ( index == curr index ) { iter . swap value on current ( new value ) ; return bool ; } curr index ++ ; } return bool ; }	for internal use only.
@ override public void close ( ) { for ( map . entry < orid , locked record metadata > lock : locks . entry set ( ) ) { try { final locked record metadata locked record metadata = lock . get value ( ) ; if ( locked record metadata . strategy . equals ( o . locking strategy . exclusive lock ) ) { ( ( o ) get database ( ) . get storage ( ) . get underlying ( ) ) . release write lock ( lock . get key ( ) ) ; } else if ( locked record metadata . strategy . equals ( o . locking strategy . shared lock ) ) { ( ( o ) get database ( ) . get storage ( ) . get underlying ( ) ) . release read lock ( lock . get key ( ) ) ; } } catch ( exception e ) { o . instance ( ) . debug ( this , str + lock . get key ( ) , e ) ; } } locks . clear ( ) ; }	Closes the transaction and releases all the acquired locks.
public synchronized void synchronize schema ( ) { o database = ( ( o ) o . instance ( ) . get ( ) . get database owner ( ) ) ; collection < class < ? > > registered entities = database . get entity manager ( ) . get registered entities ( ) ; boolean automatic schema generation = database . is automatic schema generation ( ) ; boolean reload schema = bool ; for ( class < ? > i class : registered entities ) { if ( proxy . class . is assignable from ( i class ) || i class . is enum ( ) || o . is java type ( i class ) || i class . is anonymous class ( ) ) return ; if ( ! database . get metadata ( ) . get schema ( ) . exists class ( i class . get simple name ( ) ) ) { database . get metadata ( ) . get schema ( ) . create class ( i class . get simple name ( ) ) ; reload schema = bool ; } for ( class < ? > current class = i class ; current class != object . class ; ) { if ( automatic schema generation && ! current class . equals ( object . class ) && ! current class . equals ( o . class ) ) { ( ( o ) database . get metadata ( ) . get schema ( ) ) . generate schema ( current class , database . get underlying ( ) ) ; } string i class name = current class . get simple name ( ) ; current class = current class . get superclass ( ) ; if ( current class == null || current class . equals ( o . class ) )	Checks if all registered entities has schema generated, if not it generates it.
protected void update metadata ( final string i name , final string i description , final metric type i type ) { if ( i description != null && dictionary . put if absent ( i name , i description ) == null ) types . put ( i name , i type ) ; }	Updates the metric metadata.
@ override public o < rec > last ( ) { if ( cluster ids . length == num ) return this ; browsed records = num ; current cluster idx = cluster ids . length - num ; update cluster range ( ) ; current . set cluster id ( cluster ids [ current cluster idx ] ) ; reset current position ( ) ; prev position ( ) ; final o record = get record ( ) ; current record = read current record ( record , num ) ; if ( current record != null && ! include ( current record ) ) { current record = null ; has previous ( ) ; } return this ; }	Move the iterator to the end of the range.
public int next char ( ) throws io { if ( missed char != null ) {	Returns the next character from the input stream.
public object execute ( final map < object , object > i args ) { if ( record ids . is empty ( ) && sub query == null ) throw new o ( str ) ; if ( sub query != null ) { final list < o > result = new o sql ( sub query . to string ( ) ) . execute ( ) ; for ( o id : result ) record ids . add ( id . get identity ( ) ) ; } return o . find references ( record ids , class list ) ; }	Execute the FIND REFERENCES.
@ override public o on async replication error ( final o i callback ) { if ( i callback != null ) { on async replication error = new o ( ) { int retry = num ; @ override public action on async replication error ( throwable i exception , final int i retry ) { switch ( i callback . on async replication error ( i exception , ++ retry ) ) { case retry : execute ( ) ; break ; case ignore : } return action . ignore ; } } ; } else on async replication error = null ; return this ; }	Defines a callback to call in case of error during the asynchronous replication.
public void register ( final class < ? extends o > compression ) { try { final o temp instance = compression . new instance ( ) ; final string name = temp instance . name ( ) ; if ( compressions . contains key ( name ) ) throw new illegal argument exception ( str + name + str ) ; if ( compression classes . contains key ( temp instance . name ( ) ) ) throw new illegal argument exception ( str + name + str ) ; compression classes . put ( name , compression ) ; } catch ( exception e ) { o . instance ( ) . error ( this , str , e , compression ) ; } }	Registers a stateless implementations, the same instance will be shared on all the storages.
public int get open files limit ( boolean verbose , int recommended , int def limit ) { if ( platform . is linux ( ) ) { final oc . rlimit rlimit = new oc . rlimit ( ) ; final int result = c library . getrlimit ( oc . rlimit nofile , rlimit ) ; if ( result == num && rlimit . rlim cur > num ) { if ( verbose ) { o . instance ( ) . info no db ( this , str + str , rlimit . rlim cur , rlimit . rlim cur / num - num ) ; } if ( rlimit . rlim cur < recommended ) { o . instance ( ) . warn no db ( this , str , recommended ) ; } return ( int ) rlimit . rlim cur / num - num ; } else { if ( verbose ) { o . instance ( ) . info no db ( this , str ) ; } } } else if ( platform . is windows ( ) ) { if ( verbose ) { o . instance ( ) . info no db ( this , str , recommended ) ; } return recommended ; } if ( verbose ) { o . instance ( ) . info no db ( this , str , def limit ) ; } return def limit ; }	Detects limit of limit of open files.
public boolean allows indexed function execution on target ( o target , o context , o operator , object right ) { if ( this . child expressions . size ( ) != num ) { return bool ; } return this . child expressions . get ( num ) . allows indexed function execution on target ( target , context , operator , right ) ; }	tests if current expression is an indexed function AND that function can be used on this target.
public void move ( final int i from , final int i position ) { if ( i position == num ) return ; final int to = i from + i position ; final int size = i position > num ? buffer . length - to : buffer . length - i from ; system . arraycopy ( buffer , i from , buffer , to , size ) ; }	Move bytes left or right of an offset.
public void fill ( final int i length , final byte i filler ) { assure space for ( i length ) ; arrays . fill ( buffer , position , position + i length , i filler ) ; position += i length ; }	Fills the stream from current position writing iLength times the iFiller byte.
public o execute until return ( ) { if ( steps . size ( ) > num ) { last step = steps . get ( steps . size ( ) - num ) ; } for ( int i = num ; i < steps . size ( ) - num ; i ++ ) { script line step step = steps . get ( i ) ; if ( step . contains return ( ) ) { o return step = step . execute until return ( ctx ) ; if ( return step != null ) { last step = return step ; return last step ; } } o last result = step . sync pull ( ctx , num ) ; while ( last result . has next ( ) ) { while ( last result . has next ( ) ) { last result . next ( ) ; } last result = step . sync pull ( ctx , num ) ; } } this . last step = steps . get ( steps . size ( ) - num ) ; return last step ; }	executes all the script and returns last statement execution step, so that it can be executed from outside.
public o execute full ( ) { for ( int i = num ; i < steps . size ( ) ; i ++ ) { script line step step = steps . get ( i ) ; if ( step . contains return ( ) ) { o return step = step . execute until return ( ctx ) ; if ( return step != null ) { return return step ; } } o last result = step . sync pull ( ctx , num ) ; while ( last result . has next ( ) ) { while ( last result . has next ( ) ) { last result . next ( ) ; } last result = step . sync pull ( ctx , num ) ; } } return null ; }	executes the whole script and returns last statement ONLY if it's a RETURN, otherwise it returns null;.
@ override public object evaluate record ( final o i record , o i current result , final osql i condition , final object i left , final object i right , o i context , final o serializer ) { return bool ; }	At run-time the evaluation per record must return always true since the recordset are filtered at the beginning unless anoperator can work in both modes.
public object execute ( final map < object , object > i args ) { o db = get database ( ) ; db . begin ( ) ; if ( class name == null && cluster name == null ) throw new o ( str ) ; o shutdown graph = new o ( ) ; final boolean tx already begun = get database ( ) . get transaction ( ) . is active ( ) ; try { final set < o > source ri = osql . get instance ( ) . parse rid ( db , source , context , i args ) ;	Executes the command and return the ODocument object created.
public o load ( final o configuration ) throws o { lock . acquire write lock ( ) ; try { init configuration ( configuration ) ; final byte [ ] record = storage . read record ( config rid , null , bool , bool , null ) . get result ( ) . buffer ; if ( record == null ) throw new o ( str ) ; from stream ( record , num , record . length , stream charset ) ; } finally { lock . release write lock ( ) ; } return this ; }	This method load the record information by the internal cluster segment.
@ override public < ret extends o > ret parse ( o i request ) { final o text request = ( o ) i request ; if ( i request instanceof osql ) { request = ( osql < o > ) i request ; } else if ( i request instanceof osql ) { request = ( osql < o > ) i request ; } else {	this method parses the statement.
@ override public object execute ( map < object , object > i args ) { this . context . set input parameters ( i args ) ; return execute ( this . request , this . context , this . progress listener ) ; }	this method works statefully, using request and context variables from current Match statement. This method will be deprecatedin next releases.
private void update schedule starting at ( pattern node start node , set < pattern node > visited nodes , set < pattern edge > visited edges , map < string , set < string > > remaining dependencies , list < edge traversal > resulting schedule ) {	Start a depth-first traversal from the starting node, adding all viable unscheduled edges and vertices.
public void add index ( final o index definition ) { index definitions . add ( index definition ) ; if ( index definition instanceof o ) { if ( multi value definition index == - num ) multi value definition index = index definitions . size ( ) - num ; else throw new o ( str ) ; } collate . add collate ( index definition . get collate ( ) ) ; }	Add new indexDefinition in current composite.
public o split for aggregation ( aggregate projection split aggregate split , o ctx ) { if ( is aggregate ( ) ) { o result = new o ( - num ) ; result . alias = get projection alias ( ) ; result . expression = expression . split for aggregation ( aggregate split , ctx ) ; result . nested projection = nested projection ; return result ; } else { return this ; } }	INTERNAL USE ONLY this has to be invoked ONLY if the item is aggregate!!!.
public object to object determine type ( o source , o ctx ) { string class name = get class name for document ( ctx ) ; string type = get type for document ( ctx ) ; if ( class name != null || ( type != null && str . equals ignore case ( type ) ) ) { return to document ( source , ctx , class name ) ; } else { return to map ( source , ctx ) ; } }	choosing return type is based on existence of .
public o get collate ( object doc ) { if ( collate != null || operations chain == null || ! is field chain ( ) ) { return collate ; } if ( ! ( doc instanceof o ) ) { return null ; } field chain chain = get field chain ( ) ; o last doc = ( ( o ) doc ) . get record ( ) ; for ( int i = num ; i < chain . get item count ( ) - num ; i ++ ) { if ( last doc == null ) { return null ; } object next doc = last doc . field ( chain . get item name ( i ) ) ; if ( next doc == null || ! ( next doc instanceof o ) ) { return null ; } last doc = ( ( o ) next doc ) . get record ( ) ; } if ( last doc == null ) { return null ; } o schema class = last doc . get schema class ( ) ; if ( schema class == null ) { return null ; } o property = schema class . get property ( chain . get item name ( chain . get item count ( ) - num ) ) ; if ( property == null ) { return null ; } return property . get collate ( ) ; }	get the collate of this expression, based on the fully evaluated field chain starting from the passed object.
public string get string value ( ) { if ( value == null ) { return null ; } if ( value . contains ( str ) ) { return value . replace all ( str , str ) ; } return value ; }	returns the plain string representation of this identifier, with quoting removed from back-ticks.
private int advance probe ( int probe ) { probe ^= probe << num ;	Pseudo-randomly advances and records the given probe value for the given thread.
public object execute ( final map < object , object > i args ) { if ( cluster name == null ) throw new o ( str ) ; final o database = get database ( ) ;	Execute the DROP CLUSTER.
public static o build json from file ( string file path ) throws io { if ( file path == null ) { return null ; } file json file = new file ( file path ) ; if ( ! json file . exists ( ) ) { return null ; } file input stream is = new file input stream ( json file ) ; buffered reader rd = new buffered reader ( new input stream reader ( is , charset . for name ( str ) ) ) ; o json = new o ( ) ; string json text = o . read all text file ( rd ) ; json . from json ( json text , str ) ; return json ; }	It returns a ODocument starting from a json file.
public boolean check password ( final string i password , final string i hash ) { if ( i hash . starts with ( hash algorithm prefix ) ) { final string s = i hash . substring ( hash algorithm prefix . length ( ) ) ; return create sh ( i password ) . equals ( s ) ; } else if ( i hash . starts with ( pbkd algorithm prefix ) ) { final string s = i hash . substring ( pbkd algorithm prefix . length ( ) ) ; return check password with salt ( i password , s , pbkd algorithm ) ; } else if ( i hash . starts with ( pbkd sh algorithm prefix ) ) { final string s = i hash . substring ( pbkd sh algorithm prefix . length ( ) ) ; return check password with salt ( i password , s , pbkd sh algorithm ) ; }	Checks if an hash string matches a password, based on the algorithm found on hash string.
public string create hash ( final string i input , final string i algorithm , final boolean i include algorithm ) { if ( i input == null ) throw new illegal argument exception ( str ) ; if ( i algorithm == null ) throw new illegal argument exception ( str ) ; final string builder buffer = new string builder ( num ) ; final string algorithm = validate algorithm ( i algorithm ) ; if ( i include algorithm ) { buffer . append ( str ) ; buffer . append ( algorithm ) ; buffer . append ( str ) ; } final string transformed ; if ( hash algorithm . equals ignore case ( algorithm ) ) { transformed = create sh ( i input ) ; } else if ( pbkd algorithm . equals ignore case ( algorithm ) ) { transformed = create hash with salt ( i input , o . security user password salt iterations . get value as integer ( ) , algorithm ) ; } else if ( pbkd sh algorithm . equals ignore case ( algorithm ) ) { transformed = create hash with salt ( i input , o . security user password salt iterations . get value as integer ( ) , algorithm ) ; } else throw new illegal argument exception ( str + algorithm + str ) ; buffer . append ( transformed ) ; return buffer . to string ( ) ; }	Hashes the input string.
private static boolean is algorithm supported ( final string algorithm ) {	Returns true if the algorithm is supported by the current version of Java.
public o < ? > create ( final o index definition , final string cluster index name , final set < string > clusters to index , boolean rebuild , final o progress listener , final o value serializer ) { acquire exclusive lock ( ) ; try { configuration = index configuration instance ( new o ( ) . set tracking changes ( bool ) ) ; this . index definition = index definition ; if ( clusters to index != null ) this . clusters to index = new hash set < > ( clusters to index ) ; else this . clusters to index = new hash set < > ( ) ;	Creates the index.
@ override public iterable < vertex > vertices ( ) { if ( limit == num ) return collections . empty list ( ) ; o transaction = ( ( orient base graph ) graph ) . get raw graph ( ) . get transaction ( ) ; if ( transaction . is active ( ) && transaction . get entry count ( ) > num || has custom predicate ( ) ) {	Returns the result set of the query as iterable vertices.
@ override public iterable < edge > edges ( ) { if ( limit == num ) return collections . empty list ( ) ; if ( ( ( orient base graph ) graph ) . get raw graph ( ) . get transaction ( ) . is active ( ) || has custom predicate ( ) )	Returns the result set of the query as iterable edges.
@ override public int [ ] get partition key ( ) { if ( tasks . size ( ) == num )	Return the partition keys of all the sub-tasks.
@ override public long get distributed timeout ( ) { final long to = o . distributed crud task synch timeout . get value as long ( ) ; return to + ( ( to / num ) * tasks . size ( ) ) ; }	Computes the timeout according to the transaction size.
public features get features ( ) { make active ( ) ; if ( ! features initialized ) { features . supports duplicate edges = bool ; features . supports self loops = bool ; features . is persistent = bool ; features . supports vertex iteration = bool ; features . supports vertex index = bool ; features . ignores supplied ids = bool ; features . supports transactions = bool ; features . supports vertex key index = bool ; features . supports key indices = bool ; features . is wrapper = bool ; features . supports indices = bool ; features . supports vertex properties = bool ; features . supports edge properties = bool ;	Returns the current Graph settings.
private static boolean check changes filled up to ( final file changes changes container , final long page index ) { if ( changes container == null ) { return bool ; } else if ( changes container . is new || changes container . max new page index > - num ) { return page index < changes container . max new page index + num ; } else return ! changes container . truncate ; }	This check if a file was trimmed or trunked in the current atomic operation.
protected boolean parse timeout ( final string w ) throws o sql { if ( ! w . equals ( keyword timeout ) ) return bool ; string word = parser next word ( bool ) ; try { timeout ms = long . parse long ( word ) ; } catch ( number format exception ignore ) { throw parsing exception ( str + keyword timeout + str + word + str + keyword timeout + str ) ; } if ( timeout ms < num ) throw parsing exception ( str + keyword timeout + str + keyword timeout + str ) ; word = parser next word ( bool ) ; if ( word != null ) if ( word . equals ( timeout strategy . exception . to string ( ) ) ) timeout strategy = timeout strategy . exception ; else if ( word . equals ( timeout strategy . return . to string ( ) ) ) timeout strategy = timeout strategy . return ; else parser go back ( ) ; return bool ; }	Parses the timeout keyword if found.
protected string parse lock ( ) throws o sql { final string lock strategy = parser next word ( bool ) ; if ( ! lock strategy . equals ignore case ( str ) && ! lock strategy . equals ignore case ( str ) && ! lock strategy . equals ignore case ( str ) ) throw parsing exception ( str + keyword lock + str + lock strategy + str + keyword lock + str ) ; return lock strategy ; }	Parses the lock keyword if found.
public void create cluster ( final string class name , final string cluster name ) { final o current db = o . instance ( ) . get if defined ( ) ; try { final o sysdb = open system database ( ) ; try { if ( ! sysdb . exists cluster ( cluster name ) ) { o schema = sysdb . get metadata ( ) . get schema ( ) ; o cls = schema . get class ( class name ) ; if ( cls != null ) { cls . add cluster ( cluster name ) ; } else { o . instance ( ) . error ( this , str , null , class name ) ; } } } finally { sysdb . close ( ) ; } } finally { if ( current db != null ) o . instance ( ) . set ( current db ) ; else o . instance ( ) . remove ( ) ; } }	Adds the specified cluster to the class, if it doesn't already exist.
public void free cluster ( final int cid ) { final set < orid > to remove = new hash set < orid > ( underlying . size ( ) / num ) ; final set < orid > keys = new hash set < orid > ( underlying . keys ( ) ) ; for ( final orid id : keys ) if ( id . get cluster id ( ) == cid ) to remove . add ( id ) ; for ( final orid rid to remove : to remove ) underlying . remove ( rid to remove ) ; }	Remove all records belonging to specified cluster.
public void startup ( ) { underlying . startup ( ) ; orient . instance ( ) . get profiler ( ) . register hook value ( profiler prefix + str , str , metric type . size , new o ( ) { public object get value ( ) { return get size ( ) ; } } , profiler metadata prefix + str ) ; }	All operations running at cache initialization stage.
public void shutdown ( ) { underlying . shutdown ( ) ; if ( orient . instance ( ) . get profiler ( ) != null ) { orient . instance ( ) . get profiler ( ) . unregister hook value ( profiler prefix + str ) ; orient . instance ( ) . get profiler ( ) . unregister hook value ( profiler prefix + str ) ; orient . instance ( ) . get profiler ( ) . unregister hook value ( profiler prefix + str ) ; } }	All operations running at cache destruction stage.
public static o singleton ( object entity , o transformer ) { return new o ( collections . singleton list ( entity ) . iterator ( ) , transformer ) ; }	Result set with a single result;.
public o grant ( final o . resource generic resource generic , string resource specific , final int i operation ) { o rule = rules . get ( resource generic ) ; if ( rule == null ) { rule = new o ( resource generic , null , null ) ; rules . put ( resource generic , rule ) ; } rule . grant access ( resource specific , i operation ) ; rules . put ( resource generic , rule ) ; update roles document content ( ) ; return this ; }	Grant a permission to the resource.
public o revoke ( final o . resource generic resource generic , string resource specific , final int i operation ) { if ( i operation == permission none ) return this ; o rule = rules . get ( resource generic ) ; if ( rule == null ) { rule = new o ( resource generic , null , null ) ; rules . put ( resource generic , rule ) ; } rule . revoke access ( resource specific , i operation ) ; rules . put ( resource generic , rule ) ; update roles document content ( ) ; return this ; }	Revoke a permission to the resource.
public boolean result ( final object i record ) { final o record = ( ( o ) i record ) . get record ( ) ; if ( record instanceof o && compiled filter != null && ! boolean . true . equals ( this . compiled filter . evaluate ( record , ( o ) record , get context ( ) ) ) ) { return bool ; } try { if ( record . get identity ( ) . is valid ( ) ) { if ( returning . equals ignore case ( str ) ) all deleted records . add ( record ) ;	Deletes the current record.
private void reset ( ) { int count = num ; for ( int i = num ; i < table . length ; i ++ ) { count += long . bit count ( table [ i ] & one mask ) ; table [ i ] = ( table [ i ] > > > num ) & reset mask ; } size = ( size > > > num ) - ( count > > > num ) ; }	Reduces every counter by half of its original value.
private int index of ( final int item , final int i ) { long hash = seed [ i ] * item ; hash += hash > > num ; return ( ( int ) hash ) & table mask ; }	Returns the table index for the counter at the specified depth.
private int spread ( int x ) { x = ( ( x > > > num ) ^ x ) * num ; x = ( ( x > > > num ) ^ x ) * random seed ; return ( x > > > num ) ^ x ; }	Applies a supplemental hash function to a given hashCode, which defends against poor qualityhash functions.
public o < ? > create index ( final string i type ) { acquire schema read lock ( ) ; try { return owner . create index ( get full name ( ) , i type , global ref . get name ( ) ) ; } finally { release schema read lock ( ) ; } }	Creates an index on this property.
@ deprecated public o drop indexes ( ) { get database ( ) . check security ( o . resource generic . schema , o . permission delete ) ; acquire schema read lock ( ) ; try { final o index manager = get database ( ) . get metadata ( ) . get index manager ( ) ; final array list < o < ? > > related indexes = new array list < o < ? > > ( ) ; for ( final o < ? > index : index manager . get class indexes ( owner . get name ( ) ) ) { final o definition = index . get definition ( ) ; if ( o . index of ( definition . get fields ( ) , global ref . get name ( ) , new o ( ) ) > - num ) { if ( definition instanceof o ) { related indexes . add ( index ) ; } else { throw new illegal argument exception ( str + index . get name ( ) + str + index . get definition ( ) ) ; } } } for ( final o < ? > index : related indexes ) get database ( ) . get metadata ( ) . get index manager ( ) . drop index ( index . get name ( ) ) ; return this ; } finally { release schema read lock ( ) ; } }	Remove the index on property.
@ deprecated public o < ? > get index ( ) { acquire schema read lock ( ) ; try { set < o < ? > > indexes = owner . get involved indexes ( global ref . get name ( ) ) ; if ( indexes != null && ! indexes . is empty ( ) ) return indexes . iterator ( ) . next ( ) ; return null ; } finally { release schema read lock ( ) ; } }	Returns the first index defined for the property.
public o get linked class ( ) { acquire schema read lock ( ) ; try { if ( linked class == null && linked class name != null ) linked class = owner . owner . get class ( linked class name ) ; return linked class ; } finally { release schema read lock ( ) ; } }	Returns the linked class in lazy mode because while unmarshalling the class could be not loaded yet.
@ override public o to stream ( ) { internal acquire exclusive lock ( ) ; try { document . set internal status ( o . status . unmarshalling ) ; try { final o < o > indexes = new o < > ( document ) ; for ( final o < ? > i : this . indexes . values ( ) ) { indexes . add ( ( ( o < ? > ) i ) . update configuration ( ) ) ; } document . field ( config indexes , indexes , o . embeddedset ) ; } finally { document . set internal status ( o . status . loaded ) ; } document . set dirty ( ) ; return document ; } finally { internal release exclusive lock ( ) ; } }	Binds POJO to ODocument.
protected void remove listener ( final o listener ) { if ( listeners != null ) { listeners . remove ( listener ) ; if ( listeners . is empty ( ) ) listeners = null ; } }	Remove the current event listener.
public o register database ( final string i database name , o cfg ) { final o ddb = databases . get ( i database name ) ; if ( ddb != null ) return ddb ; return new o ( manager , this , i database name , cfg , manager . get server instance ( ) ) ; }	Creates a distributed database instance if not defined yet.
public void timeout request ( final long msg id ) { final o asynch mgr = responses by request ids . remove ( msg id ) ; if ( asynch mgr != null ) asynch mgr . timeout ( ) ; }	Removes a response manager because in timeout.
public o copy ( ) { o database = new o ( get shared context ( ) . get storage ( ) ) ; database . init ( config , this . shared context ) ; string user ; if ( get user ( ) != null ) { user = get user ( ) . get name ( ) ; } else { user = null ; } database . internal open ( user , null , bool ) ; database . call on open listeners ( ) ; this . activate on current thread ( ) ; return database ; }	Returns a copy of current database if it's open.
public boolean try merge ( final o other value , boolean i merge single items of multi value fields ) { if ( ! is embedded ( ) && ! other value . is embedded ( ) ) { final osb this tree = ( osb ) delegate ; final osb other tree = ( osb ) other value . delegate ; if ( this tree . get collection pointer ( ) . equals ( other tree . get collection pointer ( ) ) ) { this tree . merge changes ( other tree ) ; uuid = other value . uuid ; return bool ; } } else if ( i merge single items of multi value fields ) { final iterator < o > iter = other value . raw iterator ( ) ; while ( iter . has next ( ) ) { final o value = iter . next ( ) ; if ( value != null ) { final iterator < o > local iter = raw iterator ( ) ; boolean found = bool ; while ( local iter . has next ( ) ) { final o v = local iter . next ( ) ; if ( value . equals ( v ) ) { found = bool ; break ; } } if ( ! found ) add ( value ) ; } } return bool ; } return bool ; }	IMPORTANT! Only for internal usage.
private void replace with sb ( o pointer ) { delegate . request delete ( ) ; final osb tree bag = new osb ( ) ; tree bag . set collection pointer ( pointer ) ; tree bag . set owner ( delegate . get owner ( ) ) ; for ( o < o , o > listener : delegate . get change listeners ( ) ) tree bag . add change listener ( listener ) ; delegate = tree bag ; }	Silently replace delegate by tree implementation.
public static object transform result ( object result ) { if ( java8 method is array == null || ! ( result instanceof map ) ) { return result ; }	Manages cross compiler compatibility issues.
public object execute ( final map < object , object > i args ) { if ( cluster name == null ) throw new o ( str ) ; final o database = get database ( ) ; final int cluster id = database . get cluster id by name ( cluster name ) ; if ( cluster id > - num ) throw new o sql ( str + cluster name + str ) ; if ( blob ) { if ( requested id == - num ) { return database . add blob cluster ( cluster name ) ; } else { throw new o ( str ) ; } } else { if ( requested id == - num ) { return database . add cluster ( cluster name ) ; } else { return database . add cluster ( cluster name , requested id , null ) ; } } }	Execute the CREATE CLUSTER.
public void close ( ) { lock ( ) ; try { if ( this . eviction task != null ) { this . eviction task . cancel ( ) ; } for ( entry < string , o < string , db > > pool : pools . entry set ( ) ) { for ( db db : pool . get value ( ) . get resources ( ) ) { pool . get value ( ) . close ( ) ; try { o . instance ( ) . debug ( this , str , db . get name ( ) ) ; ( ( o ) db ) . force close ( ) ; o . instance ( ) . debug ( this , str , db . get name ( ) ) ; } catch ( exception e ) { o . instance ( ) . debug ( this , str , e . to string ( ) ) ; } } } } finally { unlock ( ) ; } }	Closes all the databases.
public void on storage unregistered ( final o i storage ) { final string storage url = i storage . get url ( ) ; lock ( ) ; try { set < string > pool to close = null ; for ( entry < string , o < string , db > > e : pools . entry set ( ) ) { final int pos = e . get key ( ) . index of ( str ) ; final string db name = e . get key ( ) . substring ( pos + num ) ; if ( storage url . equals ( db name ) ) { if ( pool to close == null ) pool to close = new hash set < string > ( ) ; pool to close . add ( e . get key ( ) ) ; } } if ( pool to close != null ) for ( string pool : pool to close ) remove ( pool ) ; } finally { unlock ( ) ; } }	Removes from memory the pool associated to the closed storage.
public static set < string > get function names ( ) { final set < string > types = new hash set < string > ( ) ; final iterator < osql > ite = get function factories ( ) ; while ( ite . has next ( ) ) { types . add all ( ite . next ( ) . get function names ( ) ) ; } return types ; }	Iterates on all factories and append all function names.
public static set < string > get collate names ( ) { final set < string > types = new hash set < string > ( ) ; final iterator < o > ite = get collate factories ( ) ; while ( ite . has next ( ) ) { types . add all ( ite . next ( ) . get names ( ) ) ; } return types ; }	Iterates on all factories and append all collate names.
public static set < string > get command names ( ) { final set < string > types = new hash set < string > ( ) ; final iterator < o sql > ite = get command factories ( ) ; while ( ite . has next ( ) ) { types . add all ( ite . next ( ) . get command names ( ) ) ; } return types ; }	Iterates on all factories and append all command names.
private tuple < integer , o > get field size and type from current position ( bytes container bytes ) { int field size = o . read as integer ( bytes ) ; o type = read o ( bytes , bool ) ; return new tuple < > ( field size , type ) ; }	use only for named fields.
public o write status ( final int i http code , final string i reason ) throws io { response . write status ( i http code , i reason ) ; return this ; }	Sets the response's status as HTTP code and reason.
public o write headers ( final string i content type , final boolean i keep alive ) throws io { response . write headers ( i content type , i keep alive ) ; return this ; }	Sets the response's headers specifying when using the keep-alive or not.
public o write records ( final object i records , final string i fetch plan ) throws io { response . write records ( i records , i fetch plan ) ; return this ; }	Writes records as response specifying a fetch-plan to serialize nested records.
public o write record ( final o i record , final string i fetch plan ) throws io { response . write record ( i record , i fetch plan , null ) ; return this ; }	Writes a record as response.
public o send ( final int i code , final string i reason , final string i content type , final object i content ) throws io { response . send ( i code , i reason , i content type , i content , null ) ; return this ; }	Sends the complete HTTP response in one call.
public o send stream ( final int i code , final string i reason , final string i content type , final input stream i content , final long i size ) throws io { response . send stream ( i code , i reason , i content type , i content , i size ) ; return this ; }	Sends the complete HTTP response in one call specifying a stream as content.
public o open ( string name , string user , string password ) { return new o ( ( o ) orient db . open ( name , user , password ) ) ; }	Open a database specified by name using the username and password if needed.
@ override public void close ( ) { if ( is closed ( ) ) return ; check openness ( ) ; if ( owner pool != null && owner pool . get connections in current thread ( get url ( ) , user name ) > num ) { owner pool . release ( this ) ; return ; } try { commit ( bool ) ; } catch ( exception e ) { o . instance ( ) . error ( this , str , e , get name ( ) ) ; } try { call on close listeners ( ) ; } catch ( exception e ) { o . instance ( ) . error ( this , str , e , get name ( ) ) ; } get local cache ( ) . clear ( ) ; if ( owner pool != null ) { final o local copy = owner pool ; owner pool = null ; local copy . release ( this ) ; } o . instance ( ) . remove ( ) ; }	Avoid to close it but rather release itself to the owner pool.
@ override public uuid listen for changes ( o collection ) { uuid owner uuid = collection . get temporary id ( ) ; if ( owner uuid != null ) { final o pointer = collection . get pointer ( ) ; map < uuid , o > changed pointers = collection pointer changes . get ( ) ; if ( pointer != null && pointer . is valid ( ) ) { changed pointers . put ( owner uuid , pointer ) ; } } return null ; }	Change UUID to null to prevent its serialization to disk.
public void complete component operation ( ) { final component current component = components stack . peek ( ) ; if ( current component == null ) return ; current component . operation count -- ; if ( current component . operation count == num ) { final string component name = current component . name ; performance counters holder c holder = counters by component . compute if absent ( component name , k -> current component . type . new counters holder ( ) ) ; c holder . operations count ++ ; components stack . pop ( ) ; make snapshot if needed ( - num ) ; } }	Indicates that the most earliest component in stack of components has completed it's operation, so performance data for thiscomponent is stopped to be gathered.
public void push component counters ( map < string , performance counters holder > counters ) { if ( snapshot == null ) return ; for ( map . entry < string , performance counters holder > entry : snapshot . counters by component . entry set ( ) ) { final string component name = entry . get key ( ) ; performance counters holder holder = counters . compute if absent ( component name , k -> entry . get value ( ) . new instance ( ) ) ; entry . get value ( ) . push data ( holder ) ; } }	Takes performance data are split by components from last snapshot and aggregates them with data passed inside method asparameter.
public writ cache counters holder push write cache counters ( writ cache counters holder holder ) { if ( snapshot == null ) return holder ; if ( snapshot . writ cache counters holder == null ) return holder ; if ( holder == null ) holder = new writ cache counters holder ( ) ; snapshot . writ cache counters holder . push data ( holder ) ; return holder ; }	Takes write cache performance data from last snapshot and aggregates them with data passed inside method as parameter.
public storage counters holder push storage counters ( storage counters holder holder ) { if ( snapshot == null ) return holder ; if ( snapshot . storage counters holder == null ) return holder ; if ( holder == null ) holder = new storage counters holder ( ) ; snapshot . storage counters holder . push data ( holder ) ; return holder ; }	Takes storage performance data from last snapshot and aggregates them with data passed inside method as parameter.
public wal push wal ( wal holder ) { if ( snapshot == null ) return holder ; if ( snapshot . wal counters holder == null ) return holder ; if ( holder == null ) holder = new wal ( ) ; snapshot . wal counters holder . push data ( holder ) ; return holder ; }	Takes write ahead log data from last snapshot and aggregates them with data passed inside method as parameter.
public void push component counters ( string name , performance counters holder holder ) { if ( snapshot == null ) return ; final performance counters holder counters holder = snapshot . counters by component . get ( name ) ; if ( counters holder != null ) { counters holder . push data ( holder ) ; } }	Takes performance data for component from last snapshot and aggregates them with data passed inside method as parameter.
public void stop write cache flush timer ( int pages flushed ) {	Stops and records results of timer which counts how much time was spent on operation of flush pages in write cache.
public void stop fuzzy checkpoint timer ( ) { if ( writ cache counters holder == null ) writ cache counters holder = new writ cache counters holder ( ) ; final long end ts = nano timer . get nano ( ) ; final long time diff = ( end ts - time stamps . pop ( ) ) ; writ cache counters holder . fuzzy checkpoint count ++ ; writ cache counters holder . fuzzy checkpoint time += time diff ; make snapshot if needed ( end ts ) ; }	Stops and records results of timer which counts how much time was spent on fuzzy checkpoint operation.
public void stop full checkpoint timer ( ) { final long end ts = nano timer . get nano ( ) ; final long time diff = ( end ts - time stamps . pop ( ) ) ; if ( storage counters holder == null ) storage counters holder = new storage counters holder ( ) ; storage counters holder . full checkpoint operations count ++ ; storage counters holder . full checkpoint operations time += time diff ; make snapshot if needed ( end ts ) ; }	Stops and records results of timer which counts how much time was spent on full checkpoint operation.
public void stop commit timer ( ) { final long end ts = nano timer . get nano ( ) ; final long time diff = ( end ts - time stamps . pop ( ) ) ; performance counters holder . commit time += time diff ; performance counters holder . commit count ++ ; make snapshot if needed ( end ts ) ; }	Stops and records results of timer which counts how much time was spent on atomic operation commit.
public void stop wal ( boolean is start record , boolean is stop record ) { final long end ts = nano timer . get nano ( ) ; final long time diff = ( end ts - time stamps . pop ( ) ) ; if ( wal counters holder == null ) wal counters holder = new wal ( ) ; wal counters holder . log record count ++ ; wal counters holder . log record time += time diff ; if ( is start record ) { wal counters holder . start record count ++ ; wal counters holder . start record time += time diff ; } else if ( is stop record ) { wal counters holder . stop record count ++ ; wal counters holder . stop record time += time diff ; } make snapshot if needed ( end ts ) ; }	Stops and records results of timer which counts how much time was spent on logging of single write ahead log record.
public void stop wal ( ) { final long end ts = nano timer . get nano ( ) ; final long time diff = ( end ts - time stamps . pop ( ) ) ; if ( wal counters holder == null ) wal counters holder = new wal ( ) ; wal counters holder . flush count ++ ; wal counters holder . flush time += time diff ; make snapshot if needed ( end ts ) ; }	Stops timer and records how much time was spent on flushing of data from write ahead log cache.
protected static o parse ( string statement ) throws o sql { try { o db = o . instance ( ) . get if defined ( ) ; input stream is ; if ( db == null ) { is = new byte array input stream ( statement . get bytes ( ) ) ; } else { try { is = new byte array input stream ( statement . get bytes ( db . get storage ( ) . get configuration ( ) . get charset ( ) ) ) ; } catch ( unsupported encoding exception e2 ) { o . instance ( ) . warn ( null , str + db + str + db . get storage ( ) . get configuration ( ) . get charset ( ) ) ; is = new byte array input stream ( statement . get bytes ( ) ) ; } } orient sql osql = null ; if ( db == null ) { osql = new orient sql ( is ) ; } else { try { osql = new orient sql ( is , db . get storage ( ) . get configuration ( ) . get charset ( ) ) ; } catch ( unsupported encoding exception e2 ) { o . instance ( ) . warn ( null , str + db + str + db . get storage ( ) . get configuration ( ) . get charset ( ) ) ; osql = new orient sql ( is ) ; } } o result = osql . parse ( ) ; result . original statement = statement ; return result ; } catch ( parse exception e ) { throw parsing exception ( e , statement ) ; } catch ( token mgr error e2 ) { throw parsing exception ( e2 , statement ) ; } return null ; }	parses an SQL statement and returns the corresponding executor.
protected void init receive messages ( ) throws io { message thread = new thread ( ( ) -> { while ( ! thread . interrupted ( ) ) { receive messages ( ) ; } } ) ; message thread . set name ( str ) ; message thread . set daemon ( bool ) ; message thread . start ( ) ; }	inits the procedure that listens to pings from other servers, eg. that discovers other nodes in the network.
protected void init check disconnect ( ) { disconnect timer = new timer task ( ) { public void run ( ) { try { check if known servers are alive ( ) ; if ( running ) { init check disconnect ( ) ; } } catch ( exception e ) { e . print stack trace ( ) ; } } } ; task scheduler . schedule once ( disconnect timer , discovery ping interval millis ) ; }	inits the procedure that checks if a server is no longer available, ie. if he did not ping for a long time.
void remove record ( ) { check if attached ( ) ; final orient base graph graph = get graph ( ) ; graph . set current graph in thread local ( ) ; graph . auto start transaction ( ) ; if ( check deleted in tx ( ) ) graph . throw record not found exception ( get identity ( ) , str + get identity ( ) + str ) ; try { get record ( ) . load ( ) ; } catch ( o e ) { graph . throw record not found exception ( get identity ( ) , e . get message ( ) ) ; } get record ( ) . delete ( ) ; }	Removes the Element from the Graph.
@ override public void set property ( final string key , final object value ) { if ( check deleted in tx ( ) ) graph . throw record not found exception ( get identity ( ) , str + get identity ( ) + str ) ; validate property ( this , key , value ) ; final orient base graph graph = get graph ( ) ; if ( graph != null ) graph . auto start transaction ( ) ; get record ( ) . field ( key , value ) ; if ( graph != null ) save ( ) ; }	Sets a Property value.
@ override public < t > t remove property ( final string key ) { if ( check deleted in tx ( ) ) throw new illegal state exception ( str + get identity ( ) + str ) ; final orient base graph graph = get graph ( ) ; if ( graph != null ) graph . auto start transaction ( ) ; final object old value = get record ( ) . remove field ( key ) ; if ( graph != null ) save ( ) ; return ( t ) old value ; }	Removes a Property.
protected string check for class in schema ( final string class name ) { if ( class name == null ) return null ; orient base graph graph = get graph ( ) ; if ( graph == null ) return class name ; final o schema = graph . get raw graph ( ) . get metadata ( ) . get schema ( ) ; if ( ! schema . exists class ( class name ) ) {	Check if a class already exists, otherwise create it at the fly.
public static o wrap ( o < ? > source , o cursor , long index rebuild version ) { if ( cursor instanceof o ) return cursor ; if ( cursor instanceof o ) { return new o ( source , cursor , index rebuild version ) ; } return new o ( source , cursor , index rebuild version ) ; }	Wraps courser only if it is not already wrapped.
public o ml define vertex attribute strategy ( final string i attribute name , final o ml i strategy ) { vertex props strategy . put ( i attribute name , i strategy ) ; return this ; }	Define custom strategy to use for vertex attribute.
public o ml define edge attribute strategy ( final string i attribute name , final o ml i strategy ) { edge props strategy . put ( i attribute name , i strategy ) ; return this ; }	Define custom strategy to use for edge attribute.
public list < o > get new record entries by class ( final o i class , final boolean i polymorphic ) { final list < o > result = new array list < o > ( ) ; if ( i class == null )	Called by class iterator.
public list < o > get new record entries by cluster ids ( final int [ ] i ids ) { final list < o > result = new array list < o > ( ) ; if ( i ids == null )	Called by cluster iterator.
public void add index entry ( final o < ? > delegate , final string i index name , final o . operation i operation , final object key , final o i value , boolean client track only ) { o index entry = index entries . get ( i index name ) ; if ( index entry == null ) { index entry = new o ( ) ; index entries . put ( i index name , index entry ) ; } if ( i operation == operation . clear ) index entry . set cleared ( ) ; else { o changes = index entry . get changes per key ( key ) ; changes . client track only = client track only ; changes . add ( i value , i operation ) ; if ( i value == null ) return ; list < o > transaction index operations = record index operations . get ( i value . get identity ( ) ) ; if ( transaction index operations == null ) { transaction index operations = new array list < o > ( ) ; record index operations . put ( i value . get identity ( ) . copy ( ) , transaction index operations ) ; } transaction index operations . add ( new o ( i index name , key , i operation ) ) ; } }	Bufferizes index changes to be flushed at commit time.
private static set < o > merge set ( set < o > target , set < o > source ) { if ( source != null ) { if ( target == null ) { return source ; } else { if ( target . size ( ) > source . size ( ) ) { target . add all ( source ) ; return target ; } else { source . add all ( target ) ; return source ; } } } else { return target ; } }	Merge the two set try to use the optimum case.
@ suppress warnings ( str ) public boolean result ( final object i record ) { final o record = ( ( o ) i record ) . get record ( ) ; if ( is update edge ( ) && ! is record instance of ( i record , str ) ) { throw new o ( str ) ; } if ( compiled filter != null ) {	Update current record.
public boolean can execute indexed function without index ( o target , o context , o operator , object right ) { osql function = osql . get instance ( ) . get function ( name . get string value ( ) ) ; if ( function instanceof o sql ) { return ( ( o sql ) function ) . can execute inline ( target , operator , right , context , this . get params ( ) . to array ( new o [ ] { } ) ) ; } return bool ; }	tests if current function is an indexed function AND that function can also be executed without using the index.
private set < comparable > prepare keys ( o < ? > index , object keys ) { final o index definition = index . get definition ( ) ; if ( keys instanceof collection ) { final set < comparable > new keys = new tree set < comparable > ( ) ; for ( object o : ( ( collection ) keys ) ) { new keys . add ( ( comparable ) index definition . create value ( o ) ) ; } return new keys ; } else { return collections . singleton ( ( comparable ) index definition . create value ( keys ) ) ; } }	Make type conversion of keys for specific index.
void write page ( byte buffer page , long page index ) throws io { synchronized ( lock object ) { last access time = system . nano time ( ) ; if ( page index >= first cached page && page index <= first cached page + page cache . size ( ) ) { if ( page index < first cached page + page cache . size ( ) ) { page cache . set ( ( int ) ( page index - first cached page ) , page ) ; } else { page cache . add ( page ) ; } } else if ( page cache . is empty ( ) ) { page cache . add ( page ) ; first cached page = page index ; } last written page = page ; last written page index = page index ; if ( page cache . size ( ) * owal . page size >= buffer size + owal . page size ) { flush all buffer pages except last one ( ) ; } } }	Writes page with given page index to the cache and eventually writes it to the file.
byte [ ] read page ( long page index ) throws io { synchronized ( lock object ) { last access time = system . nano time ( ) ; if ( page index == last written page index ) { return last written page . array ( ) ; } if ( page index >= first cached page && page index < first cached page + page cache . size ( ) ) { final byte buffer buffer = page cache . get ( ( int ) ( page index - first cached page ) ) ; return buffer . array ( ) ; } final byte buffer buffer = byte buffer . allocate ( owal . page size ) . order ( byte order . native order ( ) ) ; init file ( ) ; seg channel . position ( page index * owal . page size ) ; read byte buffer ( buffer , seg channel ) ; return buffer . array ( ) ; } }	Read page content with given index from cache or file.
void truncate ( long page index ) throws io { synchronized ( lock object ) { last access time = system . nano time ( ) ; flush buffer ( ) ; last written page index = - num ; last written page = null ; seg channel . truncate ( page index * owal . page size ) ; } }	Flushes all buffered pages and truncates file till passed in page index.
public void open ( ) throws io { synchronized ( lock object ) { last access time = system . nano time ( ) ; init file ( ) ; long pages count = seg channel . size ( ) / owal . page size ; if ( seg channel . size ( ) % owal . page size > num ) { o . instance ( ) . error ( this , str , null ) ; seg channel . truncate ( owal . page size * pages count ) ; } first cached page = - num ; page cache . clear ( ) ; last written page = null ; last written page index = - num ; } }	Initializes cache and opens underlying file.
public boolean is replication active ( final string i cluster name , final string i local node ) { final collection < string > servers = get cluster configuration ( i cluster name ) . field ( servers ) ; if ( servers != null && ! servers . is empty ( ) ) { return bool ; } return bool ; }	Returns true if the replication is active, otherwise false.
public new node strategies get new node strategy ( ) { final string value = configuration . field ( new node strategy ) ; if ( value != null ) return new node strategies . value of ( value . to upper case ( locale . english ) ) ; return new node strategies . static ; }	Returns the new node strategy between "dynamic" and "static".
public boolean is execution mode synchronous ( final string i cluster name ) { object value = get cluster configuration ( i cluster name ) . field ( execution mode ) ; if ( value == null ) { value = configuration . field ( execution mode ) ; if ( value == null ) return null ; } if ( value . to string ( ) . equals ignore case ( str ) ) return null ; return value . to string ( ) . equals ignore case ( execution mode synchronous ) ; }	Returns the execution mode if synchronous.
public boolean is read your writes ( final string i cluster name ) { object value = get cluster configuration ( i cluster name ) . field ( read your writes ) ; if ( value == null ) { value = configuration . field ( read your writes ) ; if ( value == null ) { o . instance ( ) . warn ( this , str , read your writes , i cluster name ) ; return bool ; } } return ( boolean ) value ; }	Reads your writes.
public map < string , collection < string > > get server cluster map ( collection < string > i cluster names , final string i local node , final boolean optimize for local only ) { if ( i cluster names == null || i cluster names . is empty ( ) ) i cluster names = default cluster name ; final map < string , collection < string > > servers = new hash map < string , collection < string > > ( i cluster names . size ( ) ) ;	Returns the list of servers that can manage a list of clusters.
public set < string > get servers ( collection < string > i cluster names ) { if ( i cluster names == null || i cluster names . is empty ( ) ) return get all configured servers ( ) ; final set < string > partitions = new hash set < string > ( i cluster names . size ( ) ) ; for ( string p : i cluster names ) { final list < string > server list = get cluster configuration ( p ) . field ( servers ) ; if ( server list != null ) { for ( string s : server list ) if ( ! s . equals ( new node tag ) ) partitions . add ( s ) ; } } return partitions ; }	Returns the set of server names involved on the passed cluster collection.
public boolean is server containing all clusters ( final string server , collection < string > clusters ) { if ( clusters == null || clusters . is empty ( ) ) clusters = default cluster name ; for ( string cluster : clusters ) { final list < string > server list = get cluster configuration ( cluster ) . field ( servers ) ; if ( server list != null ) { if ( ! server list . contains ( server ) ) return bool ; } } return bool ; }	Returns true if the local server has all the requested clusters.
public boolean is server containing cluster ( final string server , string cluster ) { if ( cluster == null ) cluster = all wildcard ; final list < string > server list = get cluster configuration ( cluster ) . field ( servers ) ; if ( server list != null ) { return server list . contains ( server ) ; } return bool ; }	Returns true if the local server has the requested cluster.
public list < string > get master servers ( ) { final list < string > server list = get cluster configuration ( null ) . field ( servers ) ; if ( server list != null ) {	Returns an ordered list of master server.
public set < string > get all configured servers ( ) { final set < string > servers = new hash set < string > ( ) ; for ( string p : get cluster names ( ) ) { final list < string > server list = get cluster configuration ( p ) . field ( servers ) ; if ( server list != null ) { for ( string s : server list ) if ( ! s . equals ( new node tag ) ) servers . add ( s ) ; } } return servers ; }	Returns the complete list of servers found in configuration.
public set < string > get clusters on server ( final string i node name ) { final set < string > clusters = new hash set < string > ( ) ; for ( string cl : get cluster names ( ) ) { final list < string > servers = get servers ( cl , null ) ; if ( servers . contains ( i node name ) ) clusters . add ( cl ) ; } return clusters ; }	Returns the set of clusters managed by a server.
public set < string > get clusters owned by server ( final string i node name ) { final set < string > clusters = new hash set < string > ( ) ; for ( string cl : get cluster names ( ) ) { if ( i node name . equals ( get cluster owner ( cl ) ) ) clusters . add ( cl ) ; } return clusters ; }	Returns the set of clusters where server is the owner.
public string get cluster owner ( final string i cluster name ) { string owner ; final o clusters = get configured clusters ( ) ;	Returns the owner server for the given cluster excluding the passed node.
public string get configured cluster owner ( final string i cluster name ) { string owner = null ; final o clusters = get configured clusters ( ) ;	Returns the static owner server for the given cluster.
public list < string > get configured servers ( final string i cluster name ) { final collection < ? extends string > list = ( collection < ? extends string > ) get cluster configuration ( i cluster name ) . field ( servers ) ; return list != null ? new array list < string > ( list ) : null ; }	Returns the configured server list for the requested cluster.
public set < string > get registered servers ( ) { final o servers = configuration . field ( servers ) ; final set < string > result = new hash set < string > ( ) ; if ( servers != null ) for ( string s : servers . field names ( ) ) result . add ( s ) ; return result ; }	Returns the registered servers.
public set < string > get data centers ( ) { final o dcs = configuration . field ( dcs ) ; if ( dcs == null ) return collections . empty set ; final set < string > result = new hash set < string > ( ) ; for ( string dc : dcs . field names ( ) ) { result . add ( dc ) ; } return result ; }	Returns all the configured data centers' names, if any.
public int get data center write quorum ( final string data center ) { final o dc = get data center configuration ( data center ) ; object wq = dc . field ( write quorum ) ; if ( wq instanceof string ) { if ( wq . to string ( ) . equals ignore case ( o . quorum majority ) ) { final list < string > servers = dc . field ( servers ) ; wq = servers . size ( ) / num + num ; } else if ( wq . to string ( ) . equals ignore case ( o . quorum all ) ) { final list < string > servers = dc . field ( servers ) ; wq = servers . size ( ) ; } } return ( integer ) wq ; }	Returns the data center write quorum.
public boolean is sharded ( ) { final o all cluster = get cluster configuration ( all wildcard ) ; if ( all cluster != null ) { final list < string > all servers = all cluster . field ( servers ) ; if ( all servers != null && ! all servers . is empty ( ) ) { for ( string cl : get cluster names ( ) ) { final list < string > servers = get servers ( cl , null ) ; if ( servers != null && ! servers . is empty ( ) && ! all servers . contains all ( servers ) ) return bool ; } } } return bool ; }	Returns true if the database is sharded across servers.
public list < string > get data center servers ( final string data center ) { final o dc = get data center configuration ( data center ) ; final list < string > servers = dc . field ( servers ) ; if ( servers == null || servers . is empty ( ) ) throw new o ( str + data center + str ) ; return new array list < string > ( servers ) ; }	Returns the list of servers in a data center.
public string get data center of server ( final string server ) { final o dcs = configuration . field ( dcs ) ; if ( dcs != null ) { for ( string dc : dcs . field names ( ) ) { final o dc config = dcs . field ( dc ) ; if ( dc config != null ) { final list < string > dc servers = dc config . field ( str ) ; if ( dc servers != null && ! dc servers . is empty ( ) ) { if ( dc servers . contains ( server ) )	Returns the data center where the server belongs.
public object get global read quorum ( final string i cluster name ) { object value = get cluster configuration ( i cluster name ) . field ( read quorum ) ; if ( value == null ) value = configuration . field ( read quorum ) ; return value ; }	Returns the global read quorum.
public int get write quorum ( final string cluster name , final int total configured master servers , final string server ) { integer over write = overwrite write quorum . get ( ) ; if ( over write != null ) return over write . int value ( ) ; else return get quorum ( str , cluster name , total configured master servers , default write quorum , server ) ; }	Returns the write quorum.
protected o get cluster configuration ( string i cluster name ) { final o clusters = get configured clusters ( ) ; if ( i cluster name == null ) i cluster name = all wildcard ; final o cfg ; if ( ! clusters . contains field ( i cluster name ) )	Gets the document representing the cluster configuration.
private o get data center configuration ( final string data center ) { final o dcs = configuration . field ( dcs ) ; if ( dcs != null ) return dcs . field ( data center ) ; throw new o ( str + data center + str ) ; }	Gets the document representing the dc configuration.
public static void clear init stack ( ) { final thread local < deque < orient base graph > > is = initialization stack ; if ( is != null ) is . get ( ) . clear ( ) ; final thread local < orient base graph > ag = active graph ; if ( ag != null ) ag . remove ( ) ; }	Internal use only.
@ suppress warnings ( str ) @ override public < t extends element > index < t > get index ( final string index name , final class < t > index class ) { make active ( ) ; final o index manager = get database ( ) . get metadata ( ) . get index manager ( ) ; final o idx = index manager . get index ( index name ) ; if ( idx == null || ! has index class ( idx ) ) return null ; final index < ? extends element > index = new orient index ( this , idx ) ; if ( index class . is assignable from ( index . get index class ( ) ) ) return ( index < t > ) index ; else throw exception factory . index does not support class ( index name , index class ) ; }	Returns an index by name and class.
public void drop index ( final string index name ) { make active ( ) ; execute outside tx ( new o < object , orient base graph > ( ) { @ override public object call ( orient base graph g ) { try { final o index manager = get raw graph ( ) . get metadata ( ) . get index manager ( ) ; final o index = index manager . get index ( index name ) ; o metadata = index . get configuration ( ) . field ( str ) ; string record map index name = null ; if ( metadata != null ) { record map index name = metadata . field ( orient index . config record map name ) ; } index manager . drop index ( index name ) ; if ( record map index name != null ) get raw graph ( ) . get metadata ( ) . get index manager ( ) . drop index ( record map index name ) ; save index configuration ( ) ; return null ; } catch ( exception e ) { g . rollback ( ) ; throw new runtime exception ( e . get message ( ) , e ) ; } } } , str , index name , str ) ; }	Drops an index by name.
@ override public orient vertex add vertex ( final object id ) { make active ( ) ; return add vertex ( id , ( object [ ] ) null ) ; }	Creates a new unconnected vertex with no fields in the Graph.
@ override public orient edge add edge ( final object id , vertex out vertex , vertex in vertex , final string label ) { make active ( ) ; string class name = null ; string cluster name = null ; if ( id != null ) { if ( id instanceof string ) {	Creates an edge between a source Vertex and a destination Vertex setting label as Edge's label.
public orient vertex get vertex ( final object id ) { make active ( ) ; if ( null == id ) throw exception factory . vertex id can not be null ( ) ; if ( id instanceof orient vertex ) return ( orient vertex ) id ; else if ( id instanceof o ) return get vertex instance ( ( o ) id ) ; set current graph in thread local ( ) ; orid rid ; if ( id instanceof o ) rid = ( ( o ) id ) . get identity ( ) ; else { try { rid = new o ( id . to string ( ) ) ; } catch ( illegal argument exception iae ) {	Returns a vertex by an ID.
public iterable < vertex > get vertices of class ( final string i class name , final boolean i polymorphic ) { make active ( ) ; final o cls = get raw graph ( ) . get metadata ( ) . get schema ( ) . get class ( i class name ) ; if ( cls == null ) throw new illegal argument exception ( str + i class name + str ) ; if ( ! cls . is sub class of ( orient vertex type . class name ) ) throw new illegal argument exception ( str + i class name + str ) ; return new orient element scan iterable < vertex > ( this , i class name , i polymorphic ) ; }	Get all the Vertices in Graph of a specific vertex class and all sub-classes only if iPolymorphic is true.
public iterable < edge > get edges of class ( final string i class name , final boolean i polymorphic ) { make active ( ) ; final o cls = get raw graph ( ) . get metadata ( ) . get schema ( ) . get class ( i class name ) ; if ( cls == null ) throw new illegal argument exception ( str + i class name + str ) ; if ( ! cls . is sub class of ( orient edge type . class name ) ) throw new illegal argument exception ( str + i class name + str ) ; return new orient element scan iterable < edge > ( this , i class name , i polymorphic ) ; }	Get all the Edges in Graph of a specific edges class and all sub-classes only if iPolymorphic is true.
public orient edge get edge ( final object id ) { make active ( ) ; if ( null == id ) throw exception factory . edge id can not be null ( ) ; if ( id instanceof orient edge ) return ( orient edge ) id ; else if ( id instanceof o ) return new orient edge ( this , ( o ) id ) ; final o rec ; if ( id instanceof o ) rec = ( o ) id ; else { final string str = id . to string ( ) ; int pos = str . index of ( str ) ; if ( pos > - num ) {	Returns a edge by an ID.
public orient base graph reuse ( final o i database ) { o . instance ( ) . set ( i database ) ; this . url = i database . get url ( ) ; database = i database ; make active ( ) ; return this ; }	Reuses the underlying database avoiding to create and open it every time.
public void shutdown ( boolean close db , boolean commit tx ) { make active ( ) ; try { if ( ! is closed ( ) ) { if ( commit tx ) { final o storage = get database ( ) . get storage ( ) . get underlying ( ) ; if ( storage instanceof o ) { if ( ( ( o ) storage ) . get wal ( ) != null ) get database ( ) . commit ( ) ; } else { get database ( ) . commit ( ) ; } } else if ( close db ) { get database ( ) . rollback ( ) ; } } } catch ( o e ) { throw e ; } catch ( runtime exception e ) { o . instance ( ) . error ( this , str + url , e ) ; throw e ; } catch ( exception e ) { o . instance ( ) . error ( this , str + url , e ) ; throw o . wrap exception ( new o ( str + url ) , e ) ; } finally { try { if ( close db ) { get database ( ) . close ( ) ; if ( get database ( ) . is pooled ( ) ) { database = null ; } } poll graph from stack ( close db ) ; } catch ( exception e ) { o . instance ( ) . error ( this , str + url , e ) ; } } url = null ; username = null ; password = null ; if ( ! close db ) get database ( ) . activate on current thread ( ) ; }	Closes the Graph. After closing the Graph cannot be used.
public orient vertex type get vertex base type ( ) { make active ( ) ; return new orient vertex type ( this , get raw graph ( ) . get metadata ( ) . get schema ( ) . get class ( orient vertex type . class name ) ) ; }	Returns the V persistent class as OrientVertexType instance.
public orient vertex type get vertex type ( final string i type name ) { make active ( ) ; final o cls = get raw graph ( ) . get metadata ( ) . get schema ( ) . get class ( i type name ) ; if ( cls == null ) return null ; orient vertex type . check type ( cls ) ; return new orient vertex type ( this , cls ) ; }	Returns the persistent class for type iTypeName as OrientVertexType instance.
public orient vertex type create vertex type ( final string i class name , final int clusters ) { make active ( ) ; return create vertex type ( i class name , ( string ) null , clusters ) ; }	Creates a new Vertex persistent class.
public void drop vertex type ( final string i type name ) { make active ( ) ; if ( get database ( ) . count class ( i type name ) > num ) throw new o ( str + i type name + str ) ; execute outside tx ( new o < o , orient base graph > ( ) { @ override public o call ( final orient base graph g ) { o raw graph = get raw graph ( ) ; raw graph . get metadata ( ) . get schema ( ) . drop class ( i type name ) ; return null ; } } , str , i type name , str ) ; }	Drop a vertex class.
public orient edge type get edge type ( final string i type name ) { make active ( ) ; final o cls = get raw graph ( ) . get metadata ( ) . get schema ( ) . get class ( i type name ) ; if ( cls == null ) return null ; orient edge type . check type ( cls ) ; return new orient edge type ( this , cls ) ; }	Returns the persistent class for type iTypeName as OrientEdgeType instance.
public orient edge type create edge type ( final string i class name , final int clusters ) { make active ( ) ; return create edge type ( i class name , ( string ) null , clusters ) ; }	Creates a new Edge persistent class.
public orient element get element ( final object id ) { make active ( ) ; if ( null == id ) throw new illegal argument exception ( str ) ; if ( id instanceof orient element ) return ( orient element ) id ; o rec ; if ( id instanceof o ) rec = ( o ) id ; else try { rec = new o ( id . to string ( ) ) ; } catch ( illegal argument exception iae ) {	Returns a graph element, vertex or edge, starting from an ID.
public < t extends element > void drop key index ( final string key , final class < t > element class ) { make active ( ) ; if ( element class == null ) throw exception factory . class for element cannot be null ( ) ; execute outside tx ( new o < o , orient base graph > ( ) { @ override public o call ( final orient base graph g ) { final string class name = get class name ( element class ) ; get raw graph ( ) . get metadata ( ) . get index manager ( ) . drop index ( class name + str + key ) ; return null ; } } , str , element class . get simple name ( ) , str , key , str ) ; }	Drops the index against a field name.
@ override public void remove background exception listener ( final o listener ) { final list < weak reference < o > > items to remove = new array list < > ( num ) ; for ( final weak reference < o > ref : background exception listeners ) { final o l = ref . get ( ) ; if ( l != null && l . equals ( listener ) ) { items to remove . add ( ref ) ; } } background exception listeners . remove all ( items to remove ) ; }	Removes listener which is triggered if exception is cast inside background flush data thread.
private void fire background data flush exception event ( final throwable e ) { for ( final weak reference < o > ref : background exception listeners ) { final o listener = ref . get ( ) ; if ( listener != null ) { listener . on exception ( e ) ; } } }	Fires event about exception is thrown in data flush thread.
public void stop monitoring ( ) { switch lock . acquire write lock ( ) ; try { enabled = bool ; final performance counters holder counters holder = component type . general . new counters holder ( ) ; final map < string , performance counters holder > component counters holder = new hash map < > ( ) ; writ cache counters holder writ cache counters holder = dead threads statistic . writ cache counters holder ; storage counters holder storage counters holder = dead threads statistic . storage counters holder ; wal wal counters holder = dead threads statistic . wal counters holder ; dead threads statistic . counters holder . push data ( counters holder ) ; component counters holder . put all ( dead threads statistic . counters by components ) ; dead threads statistic = null ; for ( o statistic : statistics . values ( ) ) { statistic . push system counters ( counters holder ) ; statistic . push component counters ( component counters holder ) ; writ cache counters holder = statistic . push write cache counters ( writ cache counters holder ) ; storage counters holder = statistic . push storage counters ( storage counters holder ) ; wal counters holder = statistic . push wal ( wal counters holder ) ; } statistics . clear ( ) ; post measurement statistic = new immutable statistic ( counters holder , component counters holder , writ cache counters holder , storage counters holder , wal counters holder ) ; } finally { switch lock . release write lock ( ) ; } }	Stops monitoring of performance statistic for whole system.
public void register m ( string storage name , int storage id ) { if ( mbean is registered . compare and set ( bool , bool ) ) { try { final m server = management factory . get platform m ( ) ; final object name mbean name = new object name ( get m ( storage name , storage id ) ) ; if ( ! server . is registered ( mbean name ) ) { server . register m ( new o m ( this ) , mbean name ) ; } else { mbean is registered . set ( bool ) ; o . instance ( ) . warn ( this , str + str , mbean name . get canonical name ( ) ) ; } } catch ( malformed object name exception | instance already exists exception | m | m e ) { throw o . wrap exception ( new o ( str ) , e ) ; } } }	Registers JMX bean for current manager.
public void unregister m ( string storage name , int storage id ) { if ( storage name == null ) { o . instance ( ) . warn no db ( this , str ) ; } if ( mbean is registered . compare and set ( bool , bool ) ) { try { final m server = management factory . get platform m ( ) ; final object name mbean name = new object name ( get m ( storage name , storage id ) ) ; server . unregister m ( mbean name ) ; } catch ( malformed object name exception | instance not found exception | m e ) { throw o . wrap exception ( new o ( str ) , e ) ; } } }	Deregisters JMX bean for current manager.
private writ cache counters holder fetch write cache counters ( ) {	Iterates over all live threads and accumulates write performance statics gathered form threads,also accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.
private void fetch system counters ( performance counters holder counters holder ) {	Iterates over all live threads and accumulates performance statics gathered form threads on system level,also accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.
private void fetch component counters ( string component name , performance counters holder component counters holder ) {	Iterates over all live threads and accumulates performance statics gathered form threads for provided component,also accumulates statistic from dead threads which were alive when when gathering of performance measurements is started.
public string get property ( final string i name , final string i default value ) { if ( properties == null ) return null ; for ( o p : properties ) { if ( p . name . equals ( i name ) ) return p . value ; } return null ; }	Returns the property value configured, if any.
public < ret > ret detach ( final object i pojo , boolean return non proxied instance ) { return ( ret ) o . detach ( i pojo , this , return non proxied instance ) ; }	Method that detaches all fields contained in the document to the given object.
public int get version ( final object i pojo ) { check openness ( ) ; final o record = get record by user object ( i pojo , bool ) ; if ( record != null ) return record . get version ( ) ; return o . get object version ( i pojo ) ; }	Returns the version number of the object.
public < ret extends o > ret command ( final o i command ) { return ( ret ) new o sql ( this , underlying . command ( i command ) ) ; }	Returns a wrapped OCommandRequest instance to catch the result-set by converting it before to return to the user application.
public void set dirty ( final object i pojo ) { if ( i pojo == null ) return ; final o record = get record by user object ( i pojo , bool ) ; if ( record == null ) throw new o ( str + i pojo + str ) ; record . set dirty ( ) ; }	Sets as dirty a POJO.
public void unset dirty ( final object i pojo ) { if ( i pojo == null ) return ; final o record = get record by user object ( i pojo , bool ) ; if ( record == null ) return ; o . unset dirty ( record ) ; }	Sets as not dirty a POJO.
private static set < string > get index types ( ) { final set < string > types = new hash set < > ( ) ; final iterator < o > ite = get all factories ( ) ; while ( ite . has next ( ) ) { types . add all ( ite . next ( ) . get types ( ) ) ; } return types ; }	Iterates on all factories and append all index types.
public static set < string > get index engines ( ) { final set < string > engines = new hash set < > ( ) ; final iterator < o > ite = get all factories ( ) ; while ( ite . has next ( ) ) { engines . add all ( ite . next ( ) . get algorithms ( ) ) ; } return engines ; }	Iterates on all factories and append all index engines.
public list < string > get missing nodes ( ) { synchronous responses lock . lock ( ) ; try { final list < string > missing nodes = new array list < string > ( ) ; for ( map . entry < string , object > entry : responses . entry set ( ) ) if ( entry . get value ( ) == no response ) missing nodes . add ( entry . get key ( ) ) ; return missing nodes ; } finally { synchronous responses lock . unlock ( ) ; } }	Returns the list of node names that didn't provide a response.
protected list < o > get conflict responses ( ) { final list < o > servers = new array list < o > ( ) ; int best group so far = get best responses group ( ) ; for ( int i = num ; i < response groups . size ( ) ; ++ i ) { if ( i != best group so far ) { for ( o r : response groups . get ( i ) ) servers . add ( r ) ; } } return servers ; }	Returns all the responses in conflict.
protected int get best responses group ( ) { int max coherent responses = num ; int best group so far = num ; for ( int i = num ; i < response groups . size ( ) ; ++ i ) { final int current group size = response groups . get ( i ) . size ( ) ; if ( current group size > max coherent responses ) { max coherent responses = current group size ; best group so far = i ; } } return best group so far ; }	Returns the biggest response group.
private boolean compute quorum response ( boolean reached timeout ) { if ( quorum response != null )	Computes the quorum response if possible by returning true and setting the field quorumResponse with the ODistributedResponse.
protected list < o > get received responses ( ) { final list < o > parsed = new array list < o > ( ) ; for ( object r : responses . values ( ) ) if ( r != no response ) parsed . add ( ( o ) r ) ; return parsed ; }	Returns the received response objects.
public static o get ( string statement , o ctx , o db ) { if ( db == null ) { throw new illegal argument exception ( str ) ; } if ( statement == null ) { return null ; } o resource = db . get shared context ( ) . get execution plan cache ( ) ; o result = resource . get internal ( statement , ctx , db ) ; return result ; }	returns an already prepared SQL execution plan, taking it from the cache if it exists or creating a new one if it doesn't.
public boolean allows indexed function execution on target ( o target , o context ) { return left . allows indexed function execution on target ( target , context , operator , right . execute ( ( o ) null , context ) ) ; }	tests if current expression involves an indexed function AND that function can be used on this target.
public string get library ( final o < ? > db , final string i language ) { if ( db == null )	Formats the library of functions for a language.
public void release database engine ( final string i language , final string i database name , final o . pool entry < script engine > pool entry ) { final o db manager = db managers . get ( i database name ) ;	Acquires a database engine from the pool. Once finished using it, the instance MUST be returned in the pool by calling themethod.
long get next position ( final o atomic operation ) throws io { final long filled up to = get filled up to ( atomic operation , file id ) ; final long page index = filled up to - num ; final o cache entry = load page for read ( atomic operation , file id , page index , bool , num ) ; try { final o bucket = new o ( cache entry , bool ) ; final int bucket size = bucket . get size ( ) ; return page index * o . max entries + bucket size ; } finally { release page from read ( atomic operation , cache entry ) ; } }	Returns the next position available.
private int update size ( ) { int size = num ; if ( collection pointer != null ) { final osb < o , integer > tree = load tree ( ) ; if ( tree == null ) { throw new illegal state exception ( str ) ; } try { size = tree . get real bag size ( changes ) ; } finally { release tree ( ) ; } } else { for ( change change : changes . values ( ) ) { size += change . apply to ( num ) ; } } for ( o diff : new entries . values ( ) ) { size += diff . get value ( ) ; } this . size = size ; return size ; }	Recalculates real bag size.
public v get value ( int index ) { int entry position = get int value ( positions array offset + index * o . int size ) ;	Obtains the value stored under the given index in this bucket.
boolean can be used by order by after filter ( o < ? > index , list < string > equals filter fields , list < o < string , string > > ordered fields ) { if ( ordered fields . is empty ( ) ) return bool ; if ( ! index . supports ordered iterations ( ) ) return bool ; final o definition = index . get definition ( ) ; final list < string > index fields = definition . get fields ( ) ; int end index = math . min ( index fields . size ( ) , equals filter fields . size ( ) ) ; final string first order = ordered fields . get ( num ) . get value ( ) ;	checks if, given a list of "=" conditions and a set of ORDER BY fields.
public static int index of outside strings ( final string i text , final char i to find , int i from , int i to ) { if ( i to == - num ) i to = i text . length ( ) - num ; if ( i from == - num ) i from = i text . length ( ) - num ; char c ; char string char = str ; boolean escape = bool ; final string builder buffer = new string builder ( num ) ; int i = i from ; while ( bool ) { c = i text . char at ( i ) ; if ( ! escape && c == str && ( ( i + num ) < i text . length ( ) ) ) { if ( i text . char at ( i + num ) == str ) { i = read unicode ( i text , i + num , buffer ) ; } else escape = bool ; } else { if ( c == str || c == str ) {	Finds a character inside a string specyfing the limits and direction.
public static int jump white spaces ( final char sequence i text , final int i current position , final int i max position ) { return jump ( i text , i current position , i max position , common jump ) ; }	Jump white spaces.
public static int jump ( final char sequence i text , int i current position , final int i max position , final string i jump chars ) { if ( i current position < num ) return - num ; final int size = i max position > - num ? math . min ( i max position , i text . length ( ) ) : i text . length ( ) ; final int jump char size = i jump chars . length ( ) ; boolean found = bool ; char c ; for ( ; i current position < size ; ++ i current position ) { found = bool ; c = i text . char at ( i current position ) ; for ( int jump index = num ; jump index < jump char size ; ++ jump index ) { if ( i jump chars . char at ( jump index ) == c ) { found = bool ; break ; } } if ( ! found ) break ; } return i current position >= size ? - num : i current position ; }	Jump some characters reading from an offset of a String.
public o set fetch plan ( final string fetch plan ) { o . check fetch plan valid ( fetch plan ) ; if ( fetch plan != null && fetch plan . length ( ) == num ) this . fetch plan = null ; else this . fetch plan = fetch plan ; return this ; }	Sets the fetch plan to use.
@ override public void enqueue repair record ( final o rid ) { if ( ! active ) return ; if ( rid == null || ! rid . is persistent ( ) ) return ; if ( rid . get cluster position ( ) < - num )	Adds the record to repair int the map of records and cluster.
@ override public void cancel repair record ( final o rid ) { if ( ! active ) return ; if ( rid . get cluster position ( ) < - num )	Cancel the repair against a record because the update succeed.
@ override public void enqueue repair cluster ( final int cluster id ) { if ( ! active ) return ; if ( cluster id < - num )	Enqueues the request to repair a cluster.
private map < string , set < string > > get dependencies ( pattern pattern ) { map < string , set < string > > result = new hash map < string , set < string > > ( ) ; for ( pattern node node : pattern . alias to node . values ( ) ) { set < string > current dependencies = new hash set < string > ( ) ; o filter = alias filters . get ( node . alias ) ; if ( filter != null && filter . get base expression ( ) != null ) { list < string > involved aliases = filter . get base expression ( ) . get match pattern involved aliases ( ) ; if ( involved aliases != null ) { current dependencies . add all ( involved aliases ) ; } } result . put ( node . alias , current dependencies ) ; } return result ; }	Calculate the set of dependency aliases for each alias in the pattern.
public synchronized object create pojo ( final string i class name ) throws o { if ( i class name == null ) throw new illegal argument exception ( str ) ; final class < ? > entity class = class handler . get entity class ( i class name ) ; try { if ( entity class != null ) return create instance ( entity class ) ; } catch ( exception e ) { throw o . wrap exception ( new o ( str + i class name + str ) , e ) ; } try {	Create a POJO by its class name.
public synchronized void register entity classes ( final collection < string > i class names , final class loader i class loader ) { o . instance ( ) . debug ( this , str , i class names ) ; try { register entity classes ( o . get classes for ( i class names , i class loader ) ) ; } catch ( class not found exception e ) { throw o . wrap exception ( new o ( str ) , e ) ; } }	Registers provided classes.
public synchronized void register entity classes ( class < ? > a class , boolean recursive ) { if ( recursive ) { class handler . register entity class ( a class ) ; field [ ] declared fields = a class . get declared fields ( ) ; for ( field declared field : declared fields ) { class < ? > declared field type = declared field . get type ( ) ; if ( ! class handler . contains entity class ( declared field type ) ) { register entity classes ( declared field type , recursive ) ; } } } else { class handler . register entity class ( a class ) ; } }	Scans all classes accessible from the context class loader which belong to the given class and all it's attributes - classes.
public synchronized void set class handler ( final o i class handler ) { iterator < entry < string , class < ? > > > iterator = class handler . get classes entry set ( ) . iterator ( ) ; while ( iterator . has next ( ) ) { entry < string , class < ? > > entry = iterator . next ( ) ; boolean force schema reload = ! iterator . has next ( ) ; i class handler . register entity class ( entry . get value ( ) , force schema reload ) ; } this . class handler = i class handler ; }	Sets the received handler as default and merges the classes all together.
public db acquire ( final string i name , final string i user name , final string i user password ) { setup ( ) ; return db pool . acquire ( i name , i user name , i user password ) ; }	Acquires a connection from the pool.
public int get available connections ( final string name , final string user name ) { setup ( ) ; return db pool . get available connections ( name , user name ) ; }	Returns amount of available connections which you can acquire for given source and user name.
public db acquire ( final string i name , final string i user name , final string i user password , final map < string , object > i optional params ) { setup ( ) ; return db pool . acquire ( i name , i user name , i user password , i optional params ) ; }	Acquires a connection from the pool specifying options.
public object execute ( final map < object , object > i args ) { final o database = get database ( ) ; database . check security ( o . resource generic . cluster , str , o . permission update ) ; if ( ! ( database instanceof o ) ) { throw new o ( str ) ; } final o d manager = ( o ) ( ( o ) database ) . get distributed manager ( ) ; if ( d manager == null || ! d manager . is enabled ( ) ) throw new o ( str ) ; final string database name = database . get name ( ) ; try { if ( this . parsed statement . mode full ) { return replace cluster ( d manager , database , d manager . get server instance ( ) , database name , this . parsed statement . cluster name . get string value ( ) ) ; }	Execute the SYNC CLUSTER.
public static synchronized < t extends object > iterator < t > lookup provider with orient class loader ( class < t > clazz ) { return lookup provider with orient class loader ( clazz , o . class . get class loader ( ) ) ; }	Switch to the OrientDb classloader before lookups on ServiceRegistry for implementation of the given Class. Useful under OSGIand generally under applications where jars are loaded by another class loader.
public static void check cache memory configuration ( ) { final long max heap size = runtime . get runtime ( ) . max memory ( ) ; final long max cache size = get max cache memory size ( ) ; final o . memory limit result physical memory = o . instance ( ) . get memory limit ( bool ) ; if ( max heap size != long . max value && physical memory != null && max heap size + max cache size > physical memory . memory limit ) o . instance ( ) . warn no db ( o . class , str + max heap size + str + str + max cache size + str + str + physical memory + str + str + str ) ; }	Checks the OrientDB cache memory configuration and emits a warning if configuration is invalid.
public static vertex vertex from json ( final json json , final element factory factory , final son mode , final set < string > property keys ) throws io { final o son graphson = new o son ( mode , factory , property keys , null ) ; return graphson . vertex from json ( json ) ; }	Reads an individual Vertex from JSON.
public static edge edge from json ( final json json , final vertex out , final vertex in , final element factory factory , final son mode , final set < string > property keys ) throws io { final o son graphson = new o son ( mode , factory , null , property keys ) ; return graphson . edge from json ( json , out , in ) ; }	Reads an individual Edge from JSON.
public static json json from element ( final element element , final set < string > property keys , final son mode ) throws json { final o son graphson = element instanceof edge ? new o son ( mode , null , null , property keys ) : new o son ( mode , null , property keys , null ) ; return graphson . json from element ( element ) ; }	Creates a Jettison JSONObject from a graph element.
public static object node object node from element ( final element element , final set < string > property keys , final son mode ) { final o son graphson = element instanceof edge ? new o son ( mode , null , null , property keys ) : new o son ( mode , null , property keys , null ) ; return graphson . object node from element ( element ) ; }	Creates a Jackson ObjectNode from a graph element.
public void execute import ( o cfg , o server ) { oetl job = new oetl ( cfg , server , new oetl ( ) { @ override public void on end ( oetl etl job ) { current job = null ; } } ) ; job . validate ( ) ; current job = job ; pool . execute ( job ) ; }	Executes import with configuration;.
public o status ( ) { o status = new o ( ) ; collection < o > jobs = new array list < o > ( ) ; if ( current job != null ) { jobs . add ( current job . status ( ) ) ; } status . field ( str , jobs ) ; return status ; }	Status of the Running Jobs.
public map < string , set < string > > get active data center map ( ) { map < string , set < string > > result = new hash map < > ( ) ; o cfg = get distributed configuration ( ) ; set < string > servers = cfg . get registered servers ( ) ; for ( string server : servers ) { string dc = cfg . get data center of server ( server ) ; set < string > dc config = result . get ( dc ) ; if ( dc config == null ) { dc config = new hash set < > ( ) ; result . put ( dc , dc config ) ; } dc config . add ( server ) ; } return result ; }	returns the data center map for current deploy. The keys are data center names, the values are node names per data center.
protected static string separate algorithm ( final string cipher transform ) { string [ ] array = cipher transform . split ( str ) ; if ( array . length > num ) return array [ num ] ; return null ; }	Returns the secret key algorithm portion of the cipher transformation.
public static o from config ( final o key config ) { if ( key config . uses key string ( ) ) { return from string ( key config . get key algorithm ( ) , key config . get key string ( ) ) ; } else if ( key config . uses key file ( ) ) { return from file ( key config . get key algorithm ( ) , key config . get key file ( ) ) ; } else if ( key config . uses keystore ( ) ) { return from keystore ( key config . get keystore file ( ) , key config . get keystore password ( ) , key config . get keystore key alias ( ) , key config . get keystore key password ( ) ) ; } else { throw new o ( str ) ; } }	Creates an OSymmetricKey from an OSymmetricKeyConfig interface.
public static o from file ( final string algorithm , final string path ) { string base64 key = null ; try { java . io . file input stream fis = null ; try { fis = new java . io . file input stream ( o . resolve system variables ( path ) ) ; return from stream ( algorithm , fis ) ; } finally { if ( fis != null ) fis . close ( ) ; } } catch ( exception ex ) { throw o . wrap exception ( new o ( str + ex . get message ( ) ) , ex ) ; } }	Creates an OSymmetricKey from a file containing a Base64 key.
public static o from stream ( final string algorithm , final input stream is ) { string base64 key = null ; try { base64 key = oio . read stream as string ( is ) ; } catch ( exception ex ) { throw o . wrap exception ( new o ( str + ex . get message ( ) ) , ex ) ; } return new o ( algorithm , base64 key ) ; }	Creates an OSymmetricKey from an InputStream containing a Base64 key.
public string encrypt ( final string transform , final byte [ ] bytes ) { string encoded json = null ; if ( secret key == null ) throw new o ( str ) ; if ( transform == null ) throw new o ( str ) ; try {	This method encrypts an array of bytes.
public void save to stream ( final output stream os ) { if ( os == null ) throw new o ( str ) ; try { final output stream writer osw = new output stream writer ( os ) ; try { final buffered writer writer = new buffered writer ( osw ) ; try { writer . write ( get base64 key ( ) ) ; } finally { writer . close ( ) ; } } finally { os . close ( ) ; } } catch ( exception ex ) { throw o . wrap exception ( new o ( str + ex . get message ( ) ) , ex ) ; } }	Saves the internal SecretKey to the specified OutputStream as a Base64 String.
public void save to keystore ( final output stream os , final string ks passwd , final string key alias , final string key passwd ) { if ( os == null ) throw new o ( str ) ; if ( ks passwd == null ) throw new o ( str ) ; if ( key alias == null ) throw new o ( str ) ; if ( key passwd == null ) throw new o ( str ) ; try { key store ks = key store . get instance ( str ) ; char [ ] ks passwd ca = ks passwd . to char array ( ) ; char [ ] key passwd ca = key passwd . to char array ( ) ;	Saves the internal SecretKey as a KeyStore.
public o set child ( final o i context ) { if ( i context == null ) { if ( child != null ) {	Set the inherited context avoiding to copy all the values every time.
public synchronized boolean add to unique result ( object o ) { object to add = o ; if ( o instanceof o && ( ( o ) o ) . get identity ( ) . is new ( ) ) { to add = new o ( ( o ) o ) ; } return this . unique result . add ( to add ) ; }	adds an item to the unique result set.
private object get value as object or map ( o i record , string i field value , o i type , o i linked type , map < string , character > i field types , boolean i no map , string i options ) { final string [ ] fields = o . get words ( i field value . substring ( num , i field value . length ( ) - num ) , str , bool ) ; if ( fields == null || fields . length == num ) if ( i no map ) { o res = new o ( ) ; o . add owner ( res , i record ) ; return res ; } else return new hash map < string , object > ( ) ; if ( i no map || has type field ( fields ) ) { return get value as record ( i record , i field value , i type , i options , fields ) ; } else { return get value as map ( i record , i field value , i linked type , i field types , bool , i options , fields ) ; } }	OBJECT OR MAP. CHECK THE TYPE ATTRIBUTE TO KNOW IT.
protected string authenticate ( final string username , final string password , final string i database name ) throws io { o db = null ; string user rid = null ; try { db = ( o ) server . open database ( i database name , username , password ) ; user rid = ( db . get user ( ) == null ? str : db . get user ( ) . get document ( ) . get identity ( ) . to string ( ) ) ; } catch ( o e ) {	null is returned in all other cases and means authentication was unsuccessful.
@ suppress warnings ( str ) public static object get map entry ( final map < string , ? > i map , final object i key ) { if ( i map == null || i key == null ) return null ; if ( i key instanceof string ) { string i name = ( string ) i key ; int pos = i name . index of ( str ) ; if ( pos > - num ) i name = i name . substring ( num , pos ) ; final object value = i map . get ( i name ) ; if ( value == null ) return null ; if ( pos > - num ) { final string rest field name = i name . substring ( pos + num ) ; if ( value instanceof o ) return get field value ( value , rest field name ) ; else if ( value instanceof map < ? , ? > ) return get map entry ( ( map < string , ? > ) value , rest field name ) ; } return value ; } else return i map . get ( i key ) ; }	Retrieves the value crossing the map with the dotted notation.
protected o get record ( ) { final o record ; if ( reused record != null ) {	Return the record to use for the operation.
protected o read current record ( o i record , final int i movement ) { if ( limit > - num && browsed records >= limit )	Read the current record and increment the counter if the record was found.
public orient graph get tx ( ) { final orient graph g ; if ( pool == null ) { g = ( orient graph ) get tx graph impl factory ( ) . get graph ( get database ( ) , user , password , settings ) ; } else {	Gets transactional graph with the database from pool if pool is configured.
public orient graph no tx get no tx ( ) { final orient graph no tx g ; if ( pool == null ) { g = ( orient graph no tx ) get no tx graph impl factory ( ) . get graph ( get database ( ) , user , password , settings ) ; } else {	Gets non transactional graph with the database from pool if pool is configured.
public orient graph factory setup pool ( final int i min , final int i max ) { if ( pool != null ) { pool . close ( ) ; } pool = new o ( url , user , password , num , i max ) . set auto create ( bool ) ; properties . entry set ( ) . for each ( p -> pool . set property ( p . get key ( ) , p . get value ( ) ) ) ; return this ; }	Setting up the factory to use database pool instead of creation a new instance of database connection each time.
public object get property ( final string i name ) { return properties . get ( i name . to lower case ( locale . english ) ) ; }	Gets the property value.
@ suppress warnings ( str ) @ override public void stop transaction ( final conclusion conclusion ) { make active ( ) ; if ( get database ( ) . is closed ( ) || get database ( ) . get transaction ( ) instanceof o || get database ( ) . get transaction ( ) . get status ( ) != txstatus . begun ) return ; if ( conclusion . success == conclusion ) commit ( ) ; else rollback ( ) ; }	Closes a transaction.
final public token get next token ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token source . get next token ( ) ; jj ntk = - num ; jj gen ++ ; return token ; }	Get the next Token.
final public token get token ( int index ) { token t = token ; for ( int i = num ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token source . get next token ( ) ; } return t ; }	Get the specific Token.
@ override public iterable < vertex > get vertices ( final direction i direction , final string ... i labels ) { set current graph in thread local ( ) ; orient base graph . get edge class names ( get graph ( ) , i labels ) ; orient base graph . encode class names ( i labels ) ; final o doc = get record ( ) ; final o < vertex > iterable = new o < vertex > ( ) ; for ( o < string , direction , string > connection field : get connection fields ( i direction , i labels ) ) { string field name = connection field . get key ( ) ; o < direction , string > connection = connection field . get value ( ) ; final object field value = doc . raw field ( field name ) ; if ( field value != null ) if ( field value instanceof o ) { add single vertex ( doc , iterable , field name , connection , field value , i labels ) ; } else if ( field value instanceof collection < ? > ) { collection < ? > coll = ( collection < ? > ) field value ; if ( coll . size ( ) == num ) {	Returns a lazy iterable instance against vertices.
@ override public void remove ( ) { check class ( ) ; final orient base graph graph = check if attached ( ) ; graph . set current graph in thread local ( ) ; graph . auto start transaction ( ) ; final o doc = get record ( ) ; if ( doc == null ) throw exception factory . vertex with id does not exist ( this . get id ( ) ) ; map < string , list < o > > tree ridbag edges to remove = new hash map < string , list < o > > ( ) ; if ( ! graph . get raw graph ( ) . get transaction ( ) . is active ( ) ) { for ( string field name : doc . field names ( ) ) { final o < direction , string > connection = get connection ( direction . both , field name ) ; if ( connection == null )	Removes the current Vertex from the Graph.
@ override public edge add edge ( final string label , vertex in vertex ) { if ( in vertex instanceof partition vertex )	Creates an edge between current Vertex and a target Vertex setting label as Edge's label.
public orient edge add edge ( final string label , final orient vertex in vertex , final string i class name ) { return add edge ( label , in vertex , i class name , null , ( object [ ] ) null ) ; }	Creates an edge between current Vertex and a target Vertex setting label as Edge's label.
public string get connection class ( final direction i direction , final string i field name ) { if ( i direction == direction . out ) { if ( i field name . length ( ) > connection out prefix . length ( ) ) return i field name . substring ( connection out prefix . length ( ) ) ; } else if ( i direction == direction . in ) { if ( i field name . length ( ) > connection in prefix . length ( ) ) return i field name . substring ( connection in prefix . length ( ) ) ; } return orient edge type . class name ; }	Used to extract the class name from the vertex's field.
protected o < direction , string > get connection ( final direction i direction , final string i field name , string ... i class names ) { if ( i class names != null && i class names . length == num && i class names [ num ] . equals ignore case ( str ) )	Determines if a field is a connections or not.
private void process broken rids ( set < orid > broken rids ) throws io , parse exception { if ( exporter version >= num ) { listener . on message ( str ) ; json reader . read next ( ojson . begin collection ) ; while ( bool ) { json reader . read next ( ojson . next in array ) ; final o record id = new o ( json reader . get value ( ) ) ; broken rids . add ( record id ) ; if ( json reader . last char ( ) == str ) break ; } } if ( migrate links ) { if ( exporter version >= num ) listener . on message ( broken rids . size ( ) + str + str ) ; migrate links in imported documents ( broken rids ) ; } }	just read collection so import process can continue.
protected map < method , object > get console methods ( ) { if ( methods != null ) return methods ;	Returns a map of all console method and the object they can be called on.
@ override public object execute on local node ( final o req id , final o task , final o database ) { if ( database != null && ! ( database . get storage ( ) instanceof o ) ) throw new o ( str + database . get name ( ) + str + database . get storage ( ) . get class ( ) . get name ( ) ) ; final o manager = this ; return o . execute as distributed ( new callable < object > ( ) { @ override public object call ( ) throws exception { try { final object result = task . execute ( req id , server instance , manager , database ) ; if ( result instanceof throwable && ! ( result instanceof o ) )	Executes the request on local node. In case of error returns the Exception itself.
@ override public int get nodes with status ( final collection < string > i nodes , final string database name , final db status ... statuses ) { for ( iterator < string > it = i nodes . iterator ( ) ; it . has next ( ) ; ) { final string node = it . next ( ) ; if ( ! is node status equals to ( node , database name , statuses ) ) it . remove ( ) ; } return i nodes . size ( ) ; }	Returns the nodes with the requested status.
protected void wait for next retry ( ) { try { thread . sleep ( new random ( ) . next int ( max delay - num ) + num ) ; } catch ( interrupted exception e ) { o . instance ( ) . error ( this , str , e ) ; } }	Wait before to retry.
public string get argument ( final int i position ) { return args != null && args . length > i position ? args [ i position ] : null ; }	Returns the argument by position.
public int has parameters ( final string ... i names ) { int found = num ; if ( i names != null && request . parameters != null ) for ( string name : i names ) found += request . parameters . contains key ( name ) ? num : num ; return found ; }	Checks how many parameters have been received.
@ deprecated public synchronized o connect ( final string i user name , final string i user password ) throws io { final string username ; final string password ; o ci = o . instance ( ) . new credential interceptor ( ) ; if ( ci != null ) { ci . intercept ( storage . get url ( ) , i user name , i user password ) ; username = ci . get username ( ) ; password = ci . get password ( ) ; } else { username = i user name ; password = i user password ; } o request = new o ( username , password ) ; network admin operation ( ( network , session ) -> { o node session = session . get or create server session ( network . get server url ( ) ) ; try { network . begin request ( request . get command ( ) , session ) ; request . write ( network , session ) ; } finally { network . end request ( ) ; } o response = request . create response ( ) ; try { network . begin response ( node session . get session id ( ) , bool ) ; response . read ( network , session ) ; } finally { storage . end response ( network ) ; } return null ; } , str + storage . get url ( ) + str ) ; return this ; }	Connects to a remote server.
@ deprecated public synchronized map < string , string > list databases ( ) throws io { o request = new o ( ) ; o response = network admin operation ( request , str ) ; return response . get databases ( ) ; }	Returns the list of databases on the connected remote server.
@ deprecated public synchronized o get server info ( ) throws io { o request = new o ( ) ; o response = network admin operation ( request , str ) ; o res = new o ( ) ; res . from json ( response . get result ( ) ) ; return res ; }	Returns the server information in form of document.
public synchronized boolean exists database ( final string i database name , final string storage type ) throws io { o request = new o ( i database name , storage type ) ; o response = network admin operation ( request , str + storage . get name ( ) ) ; return response . is exists ( ) ; }	Checks if a database exists in the remote server.
public synchronized o drop database ( final string i database name , final string storage type ) throws io { o request = new o ( i database name , storage type ) ; o response = network admin operation ( request , str + storage . get name ( ) ) ; ourl connection = ourl . parse ( get url ( ) ) ; db remote = ( db ) o . get or create remote factory ( connection . get path ( ) ) ; remote . force database close ( i database name ) ; o . instance ( ) . remove ( ) ; return this ; }	Drops a database from a remote server instance.
public synchronized o freeze database ( final string storage type ) throws io { o request = new o ( storage . get name ( ) , storage type ) ; o response = network admin operation ( request , str + storage . get name ( ) ) ; return this ; }	Freezes the database by locking it in exclusive mode.
public synchronized o release database ( final string storage type ) throws io { o request = new o ( storage . get name ( ) , storage type ) ; o response = network admin operation ( request , str + storage . get name ( ) ) ; return this ; }	Releases a frozen database.
public o cluster status ( ) { o request = new o ( ) ; o response = storage . network operation ( request , str ) ; o . instance ( ) . debug ( this , str , response . get cluster config ( ) . to json ( str ) ) ; return response . get cluster config ( ) ; }	Gets the cluster status.
public static orient graph get graph ( final boolean auto start tx , o should be shut down ) { final o database = o . instance ( ) . get ( ) ; final orient base graph result = orient base graph . get active graph ( ) ; if ( result != null && ( result instanceof orient graph ) ) { final o graph db = result . get raw graph ( ) ;	Returns a Transactional OrientGraph implementation from the current database in thread local.
protected void parse retry ( ) throws o sql { retry = integer . parse int ( parser next word ( bool ) ) ; string temp = parse optional word ( bool ) ; if ( temp . equals ( str ) ) { wait = integer . parse int ( parser next word ( bool ) ) ; } else parser go back ( ) ; }	Parses the RETRY number of times.
public o save record ( final o i record , final string i cluster name , final operation mode i mode , boolean i force create , final o < ? extends number > i record created callback , o < integer > i record updated callback ) { try { return database . save all ( i record , i cluster name , i mode , i force create , i record created callback , i record updated callback ) ; } catch ( exception e ) {	Update the record.
public void delete record ( final o i record , final operation mode i mode ) { if ( ! i record . get identity ( ) . is persistent ( ) ) return ; try { database . execute delete record ( i record , i record . get version ( ) , bool , i mode , bool ) ; } catch ( exception e ) {	Deletes the record.
public string get authentication header ( string database name ) { string header ;	databaseName may be null.
public string authenticate ( final string username , final string password ) { string principal = null ; try { if ( get server ( ) != null ) {	This will authenticate username using the system database.
public boolean is authorized ( final string username , final string resource ) { if ( username == null || resource == null ) return bool ; try { if ( get server ( ) != null ) { o user = get server ( ) . get security ( ) . get system user ( username , null ) ; if ( user != null && user . get account status ( ) == o . statuses . active ) { o role = null ; o . resource generic rg = o . map legacy resource to generic resource ( resource ) ; if ( rg != null ) { string specific resource = o . map legacy resource to specific resource ( resource ) ; if ( specific resource == null || specific resource . equals ( str ) ) { specific resource = null ; } role = user . check if allowed ( rg , specific resource , o . permission execute ) ; } return role != null ; } } } catch ( exception ex ) { o . instance ( ) . error ( this , str , ex ) ; } return bool ; }	Checks to see if a.
@ override public void run ( ) { if ( server != null ) if ( ! server . shutdown ( ) ) {	Catch the JVM exit and assure to shutdown the Orient Server.
public void adjust begin line column ( int new line , int new col ) { int start = token begin ; int len ; if ( bufpos >= token begin ) { len = bufpos - token begin + in buf + num ; } else { len = bufsize - token begin + bufpos + num + in buf ; } int i = num , j = num , k = num ; int next col diff = num , column diff = num ; while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { bufline [ j ] = new line ; next col diff = column diff + bufcolumn [ k ] - bufcolumn [ j ] ; bufcolumn [ j ] = new col + column diff ; column diff = next col diff ; i ++ ; } if ( i < len ) { bufline [ j ] = new line ++ ; bufcolumn [ j ] = new col + column diff ; while ( i ++ < len ) { if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = new line ++ ; else bufline [ j ] = new line ; } } line = bufline [ j ] ; column = bufcolumn [ j ] ; }	Method to adjust line and column numbers for the start of a token.
protected void set bucket pointer ( int page offset , o value ) throws io { set long value ( page offset , value . get page index ( ) ) ; set int value ( page offset + o . long size , value . get page offset ( ) ) ; }	Write a bucket pointer to specific location.
protected o get bucket pointer ( int offset ) { final long page index = get long value ( offset ) ; final int page offset = get int value ( offset + o . long size ) ; return new o ( page index , page offset ) ; }	Read bucket pointer from page.
public o end atomic operation ( boolean rollback ) throws io { final o operation = current operation . get ( ) ; if ( operation == null ) { o . instance ( ) . error ( this , str , null ) ; throw new o ( str ) ; } int counter = operation . get counter ( ) ; operation . decrement counter ( ) ; assert counter > num ; final o lsn ; try { if ( rollback ) { operation . rollback ( ) ; } if ( counter == num ) { try { final boolean use wal = use wal ( ) ; if ( ! operation . is rollback ( ) ) { lsn = operation . commit changes ( use wal ? write ahead log : null ) ; } else { lsn = null ; } if ( track atomic operations ) { active atomic operations . remove ( operation . get operation unit id ( ) ) ; } } finally { final iterator < string > locked object iterator = operation . locked objects ( ) . iterator ( ) ; while ( locked object iterator . has next ( ) ) { final string locked object = locked object iterator . next ( ) ; locked object iterator . remove ( ) ; lock manager . release lock ( this , locked object , o . lock . exclusive ) ; } current operation . set ( null ) ; } } else { lsn = null ; } } catch ( error e ) { final o st = storage ; if ( st != null ) { st . handle jvm ( e ) ; } counter = num ; throw e ; } finally { if ( counter == num ) { atomic operations count . decrement ( ) ; } } return lsn ; }	Ends the current atomic operation on this manager.
public void acquire exclusive lock till operation complete ( o operation , string lock name ) { if ( operation . contains in locked objects ( lock name ) ) { return ; } lock manager . acquire lock ( lock name , o . lock . exclusive ) ; operation . add locked object ( lock name ) ; }	Acquires exclusive lock with the given lock name in the given atomic operation.
public void change maximum amount of memory ( final long read cache max memory ) throws illegal state exception { memory data memory data ; memory data new memory data ; final int new memory size = normalize memory ( read cache max memory , page size ) ; do { memory data = memory data container . get ( ) ; if ( memory data . max size == new memory size ) { return ; } if ( ( num * memory data . pinned pages / new memory size ) > percent of pinned pages ) { throw new illegal state exception ( str + str + percent of pinned pages ) ; } new memory data = new memory data ( new memory size , memory data . pinned pages ) ; } while ( ! memory data container . compare and set ( memory data , new memory data ) ) ;	Changes amount of memory which may be used by given cache.
private void listen ( final string i host name , final string i host port range , final string i protocol name , class < ? extends o > protocol class ) { for ( int port : get ports ( i host port range ) ) { inbound addr = new inet socket address ( i host name , port ) ; try { server socket = socket factory . create server socket ( port , num , inet address . get by name ( i host name ) ) ; if ( server socket . is bound ( ) ) { o . instance ( ) . info ( this , str + i protocol name + str + inbound addr . get address ( ) . get host address ( ) + str + inbound addr . get port ( ) + str + protocol version + str + socket factory . get name ( ) + str ) ; return ; } } catch ( bind exception be ) { o . instance ( ) . warn ( this , str , i host name , port ) ; } catch ( socket exception se ) { o . instance ( ) . error ( this , str , se ) ; throw new runtime exception ( se ) ; } catch ( io ioe ) { o . instance ( ) . error ( this , str , ioe ) ; system . err . println ( str ) ; throw new runtime exception ( ioe ) ; } } o . instance ( ) . error ( this , str , null , i host port range , i host name ) ; throw new o ( str ) ; }	Initialize a server socket for communicating with the client.
private void read parameters ( final o i server config , final o [ ] i parameters ) { configuration = new o ( i server config ) ;	Initializes connection parameters by the reading XML configuration.
public void shutdown ( ) { if ( shutdown flag . compare and set ( bool , bool ) ) { try { if ( log manager . get log manager ( ) instanceof shutdown log manager ) ( ( shutdown log manager ) log manager . get log manager ( ) ) . shutdown ( ) ; } catch ( no class def found error ignore ) {	Shutdowns this log manager.
public void add ( k key , v item ) throws interrupted exception { if ( ! item . is open ( ) ) throw new illegal argument exception ( str ) ; check open files limit ( ) ; final o < k , v > closable entry = new o < k , v > ( item ) ; final o < k , v > old entry = data . put if absent ( key , closable entry ) ; if ( old entry != null ) { throw new illegal state exception ( str + key + str ) ; } log add ( closable entry ) ; }	Adds item to the container.Item should be in open state.
public v remove ( k key ) { final o < k , v > removed = data . remove ( key ) ; if ( removed != null ) { long pre status = removed . make retired ( ) ; if ( o . is open ( pre status ) ) { count closed files ( ) ; } log removed ( removed ) ; return removed . get ( ) ; } return null ; }	Removes item associated with passed in key.
public o < k , v > acquire ( k key ) throws interrupted exception { check open files limit ( ) ; final o < k , v > entry = data . get ( key ) ; if ( entry == null ) return null ; boolean log open = bool ; entry . acquire state lock ( ) ; try { if ( entry . is retired ( ) || entry . is dead ( ) ) { return null ; } else if ( entry . is closed ( ) ) { entry . make acquired from closed ( entry . get ( ) ) ; log open = bool ; } else if ( entry . is open ( ) ) { entry . make acquired from open ( ) ; } else { entry . increment acquired ( ) ; } } finally { entry . release state lock ( ) ; } if ( log open ) { log open ( entry ) ; } else { log acquire ( entry ) ; } assert entry . get ( ) . is open ( ) ; return entry ; }	Acquires item associated with passed in key in container.It is guarantied that item will not be closed if limit of open items will be exceeded and container will close rarely useditems.
public v get ( k key ) { final o < k , v > entry = data . get ( key ) ; if ( entry != null ) return entry . get ( ) ; return null ; }	Returns item without acquiring it.
public void clear ( ) { lru lock . lock ( ) ; try { data . clear ( ) ; open files . set ( num ) ; for ( int n = num ; n < number of read buffers ; n ++ ) { final atomic reference < o < k , v > > [ ] buffer = read buffers [ n ] ; for ( int i = num ; i < read buffer size ; i ++ ) { buffer [ i ] . set ( null ) ; } read buffer read count [ n ] = num ; read buffer write count [ n ] . set ( num ) ; read buffer drain at write count [ n ] . set ( num ) ; } state buffer . clear ( ) ; while ( lru list . poll ( ) != null ) ; } finally { lru lock . unlock ( ) ; } }	Clears all content.
public boolean close ( k key ) { empty buffers ( ) ; final o < k , v > entry = data . get ( key ) ; if ( entry == null ) return bool ; if ( entry . make closed ( ) ) { count closed files ( ) ; return bool ; } return bool ; }	Closes item related to passed in key.Item will be closed if it exists and is not acquired.
private void empty read buffers ( ) { for ( int n = num ; n < number of read buffers ; n ++ ) { atomic reference < o < k , v > > [ ] buffer = read buffers [ n ] ; long write count = read buffer drain at write count [ n ] . get ( ) ; long counter = read buffer read count [ n ] ; while ( bool ) { final int buffer index = ( int ) ( counter & read buffer index mask ) ; final atomic reference < o < k , v > > eref = buffer [ buffer index ] ; final o < k , v > entry = eref . get ( ) ; if ( entry == null ) break ; apply read ( entry ) ; counter ++ ; eref . lazy set ( null ) ; } read buffer read count [ n ] = counter ; read buffer drain at write count [ n ] . lazy set ( write count ) ; } }	Read content of all read buffers and reorder elements inside of LRU list to update internal statistic.Method has to be wrapped by LRU lock.
private void after write ( runnable task ) { state buffer . add ( task ) ; drain status . lazy set ( drain status . required ) ; try to drain buffers ( ) ; }	Method is used to log operations which change content of the container.Such changes should be flushed immediately to update content of LRU list.
private void after read ( o < k , v > entry ) { final int buffer index = read buffer index ( ) ; final long write count = put entry in read buffer ( entry , buffer index ) ; drain read buffers if needed ( buffer index , write count ) ; }	Method is used to log operations which do not change LRU list content but affect order of items inside of LRU list.Such changes may be delayed till buffer will be full.
private long put entry in read buffer ( o < k , v > entry , int buffer index ) {	Adds entry to the read buffer with selected index and returns amount of writes to this buffer since creation of this container.
private static int closest power of two ( int value ) { int n = value - num ; n |= n > > > num ; n |= n > > > num ; n |= n > > > num ; n |= n > > > num ; n |= n > > > num ; return ( n < num ) ? num : ( n >= ( num << num ) ) ? num << num : n + num ; }	Finds closest power of two for given integer value.
public boolean on event ( o push request ) { o old = o . instance ( ) . get if defined ( ) ; try { database . activate on current thread ( ) ; if ( push request . get status ( ) == o . error ) { on error ( push request . get error code ( ) . new exception ( push request . get error message ( ) , null ) ) ; return bool ; } else { for ( o result : push request . get events ( ) ) { switch ( result . get event type ( ) ) { case o . create event : listener . on create ( database , result . get current value ( ) ) ; break ; case o . update event : listener . on update ( database , result . get old value ( ) , result . get current value ( ) ) ; break ; case o . delete event : listener . on delete ( database , result . get current value ( ) ) ; break ; } } if ( push request . get status ( ) == o . end ) { on end ( ) ; return bool ; } } return bool ; } finally { o . instance ( ) . set ( old ) ; } }	Return true if the push request require an unregister.
private void convert ( final object i key ) { if ( converted ) return ; if ( super . contains key ( i key ) ) return ; object o = underlying . get ( string . value of ( i key ) ) ; if ( o instanceof number ) super . put ( i key , enum class . get enum constants ( ) [ ( ( number ) o ) . int value ( ) ] ) ; else super . put ( i key , enum . value of ( enum class , o . to string ( ) ) ) ; }	Assure that the requested key is converted.
protected void convert all ( ) { if ( converted ) return ; for ( java . util . map . entry < object , object > e : underlying . entry set ( ) ) { if ( e . get value ( ) instanceof number ) super . put ( e . get key ( ) , enum class . get enum constants ( ) [ ( ( number ) e . get value ( ) ) . int value ( ) ] ) ; else super . put ( e . get key ( ) , enum . value of ( enum class , e . get value ( ) . to string ( ) ) ) ; } converted = bool ; }	Converts all the items.
@ suppress warnings ( str ) public < t > o < t > get object serializer ( final o type ) { return ( o < t > ) serializer type map . get ( type ) ; }	Obtain OBinarySerializer realization for the OType.
private void init shutdown queue ( ) { add shutdown handler ( new o ( ) ) ; add shutdown handler ( new o db ( ) ) ; add shutdown handler ( new o ( ) ) ; add shutdown handler ( new o ( ) ) ; add shutdown handler ( new o ( ) ) ; }	Adds shutdown handlers in order which will be used during execution of shutdown.
public o get engine ( final string engine name ) { engine lock . read lock ( ) . lock ( ) ; try { return engines . get ( engine name ) ; } finally { engine lock . read lock ( ) . unlock ( ) ; } }	Returns the engine by its name.
private readers entry add state ( ) { final atomic integer state = new atomic integer ( srwl state not reading ) ; final readers entry new entry = new readers entry ( state ) ; entry . set ( new entry ) ; readers state list . add ( state ) ; readers state array ref . set ( null ) ; return new entry ; }	Creates a new ReadersEntry instance for the current thread andits associated AtomicInteger to store the state of the Reader.
public o authenticate ( final o auth token ) { final string db name = get database ( ) . get name ( ) ; if ( auth token . get is valid ( ) != bool ) { throw new o ( db name , str ) ; } o user = auth token . get user ( get database ( ) ) ; if ( user == null && auth token . get user name ( ) != null ) {	Token MUST be validated before being passed to this method.
public o create metadata ( ) { final o database = get database ( ) ; o identity class = database . get metadata ( ) . get schema ( ) . get class ( o . class name ) ;	Repairs the security structure if broken by creating the ADMIN role and user with default password.
public boolean try acquire read lock ( long timeout ) { final o l holds = lock holds . get ( ) ; final int holds = l holds . int value ( ) ; if ( holds > num ) {	Tries to acquire lock during provided interval of time and returns either if provided time interval was passed orif lock was acquired.
@ override public orient vertex get vertex ( final direction direction ) { final orient base graph graph = set current graph in thread local ( ) ; if ( direction . equals ( direction . out ) ) return graph . get vertex ( get out vertex ( ) ) ; else if ( direction . equals ( direction . in ) ) return graph . get vertex ( get in vertex ( ) ) ; else throw exception factory . both is not supported ( ) ; }	Returns the connected incoming or outgoing vertex.
@ override public object get id ( ) { if ( raw element == null )	Returns the Edge Id assuring to save it if it's transient yet.
@ override public void set property ( final string key , final object value ) { set current graph in thread local ( ) ; if ( raw element == null )	Set a Property value.
@ override public < t > t remove property ( string key ) { set current graph in thread local ( ) ; if ( raw element != null )	Removed a Property.
@ override public void clear ( ) throws io { boolean rollback = bool ; final o atomic operation = start atomic operation ( bool ) ; try { final lock lock = file lock manager . acquire exclusive lock ( file id ) ; try { final queue < o > sub trees to delete = new linked list < > ( ) ; final o cache entry = load page for write ( atomic operation , file id , root bucket pointer . get page index ( ) , bool , bool ) ; try { osb < k , v > root bucket = new osb < > ( cache entry , root bucket pointer . get page offset ( ) , key serializer , value serializer , this ) ; add children to queue ( sub trees to delete , root bucket ) ; root bucket . shrink ( num ) ; root bucket = new osb < > ( cache entry , root bucket pointer . get page offset ( ) , bool , key serializer , value serializer , this ) ; root bucket . set tree size ( num ) ; } finally { release page from write ( atomic operation , cache entry ) ; } recycle sub trees ( sub trees to delete , atomic operation ) ; } finally { lock . unlock ( ) ; } } catch ( final exception e ) { rollback = bool ; throw e ; } finally { end atomic operation ( rollback ) ; } }	Removes all entries from bonsai tree.
@ override public void delete ( ) throws io { boolean rollback = bool ; final o atomic operation = start atomic operation ( bool ) ; try { final lock lock = file lock manager . acquire exclusive lock ( file id ) ; try { final queue < o > sub trees to delete = new linked list < > ( ) ; sub trees to delete . add ( root bucket pointer ) ; recycle sub trees ( sub trees to delete , atomic operation ) ; } finally { lock . unlock ( ) ; } } catch ( final exception e ) { rollback = bool ; throw e ; } finally { end atomic operation ( rollback ) ; } }	Deletes a whole tree.
public void end ( ) { final o v class = db . get metadata ( ) . get schema ( ) . get class ( vertex class ) ; try { running threads = new atomic integer ( parallel ) ; for ( int i = num ; i < parallel - num ; i ++ ) { thread t = new batch importer job ( i , v class ) ; t . start ( ) ; } thread t = new batch importer job ( parallel - num , v class ) ; t . run ( ) ; if ( running threads . get ( ) > num ) { synchronized ( running threads ) { while ( running threads . get ( ) > num ) { try { running threads . wait ( ) ; } catch ( interrupted exception e ) { } } } } } finally { db . activate on current thread ( ) ; db . declare intent ( null ) ; db . close ( ) ; if ( wal active ) o . use wal . set value ( bool ) ; } }	Flushes data to db and closes the db.
public void create vertex ( final long v ) { last = last < v ? v : last ; final list < long > out list = out . get ( v ) ; if ( out list == null ) { out . put ( v , new array list < long > ( average edge number per node <= num ? num : average edge number per node ) ) ; } }	Creates a new vertex.
protected boolean parse strategy ( final string w ) throws o sql { if ( ! w . equals ( keyword strategy ) ) return bool ; final string strategy word = parser next word ( bool ) ; try { traverse . set strategy ( o . strategy . value of ( strategy word . to upper case ( locale . english ) ) ) ; } catch ( illegal argument exception ignore ) { throw parsing exception ( str + keyword strategy + str + arrays . to string ( o . strategy . values ( ) ) ) ; } return bool ; }	Parses the strategy keyword if found.
private list < record info > get positions from embedded collection ( final bytes container bytes , int serializer version ) { list < record info > ret list = new array list < > ( ) ; int number of elements = o . read as integer ( bytes ) ;	returns begin position and length for each value in embedded collection.
public object execute ( final map < object , object > i args ) { if ( new records == null && content == null && sub query == null ) throw new o ( str ) ; final o command parameters = new o ( i args ) ; if ( index name != null ) { if ( new records == null ) throw new o ( str ) ; final o < ? > index = get database ( ) . get metadata ( ) . get index manager ( ) . get index ( index name ) ; if ( index == null ) throw new o ( str + index name + str ) ;	Execute the INSERT and return the ODocument object created.
protected boolean fix link ( final object field value ) { if ( field value instanceof o ) { final orid id = ( ( o ) field value ) . get identity ( ) ; if ( id . get cluster id ( ) == num && id . get cluster position ( ) == num ) return bool ; if ( id . is valid ( ) ) if ( id . is persistent ( ) ) { final o connected = ( ( o ) field value ) . get record ( ) ; if ( connected == null ) return bool ; } else return bool ; } return bool ; }	Checks if the link must be fixed.
public static o fill ( final o record , final orid i rid , final int i version , final byte [ ] i buffer , final boolean i dirty ) { final o rec = ( o ) record ; rec . fill ( i rid , i version , i buffer , i dirty ) ; return rec ; }	Internal only. Fills in one shot the record.
public static void set version ( final o record , final int i version ) { final o rec = ( o ) record ; rec . set version ( i version ) ; }	Internal only. Sets the version.
public static byte get record type ( final o record ) { if ( record instanceof o ) { return ( ( o ) record ) . get record type ( ) ; } final o rec = ( o ) record . get record ( ) ; return rec . get record type ( ) ; }	Internal only. Return the record type.
public void init database instance ( ) { if ( database == null ) { for ( int retry = num ; retry < num ; ++ retry ) { try { database = distributed . get database instance ( ) ;	Opens the database.
public string print exception stack trace ( exception e , string level ) {	Builds the exception stack trace and prints it according to a level passed as argument.
private void convert link2 record ( final object i key ) { if ( status == multivalue content type . all records ) return ; final object value ; if ( i key instanceof orid ) value = i key ; else value = super . get ( i key ) ; if ( value != null && value instanceof orid ) { final orid rid = ( orid ) value ; marshalling = bool ; try { try {	Convert the item with the received key to a record.
public void register command ( final o i server command instance ) { for ( string name : i server command instance . get names ( ) ) if ( o . contains ( name , str ) ) { rest commands . put ( name , i server command instance ) ; } else if ( o . contains ( name , str ) ) wildcard commands . put ( name , i server command instance ) ; else exact commands . put ( name , i server command instance ) ; i server command instance . configure ( server ) ; }	Register all the names for the same instance.
protected o create server user ( final o user doc ) { o user cfg = null ; if ( user doc . contains field ( str ) && user doc . contains field ( str ) ) { final string user = user doc . field ( str ) ; final string resources = user doc . field ( str ) ; string password = user doc . field ( str ) ; if ( password == null ) password = str ; user cfg = new o ( user , password , resources ) ; } return user cfg ; }	Derived implementations can override this method to provide new server user implementations.
public list < o > analyze condition ( osql condition , final o schema class , o context ) { final list < o > index search results = new array list < o > ( ) ; o last condition = analyze filter branch ( schema class , condition , index search results , context ) ; if ( index search results . is empty ( ) && last condition != null ) { index search results . add ( last condition ) ; } collections . sort ( index search results , new comparator < o > ( ) { public int compare ( final o search result one , final o search result two ) { return search result two . get field count ( ) - search result one . get field count ( ) ; } } ) ; return index search results ; }	Analyzes a query filter for a possible indexation options.
private o create indexed property ( final osql i condition , final object i item , o ctx ) { if ( i item == null || ! ( i item instanceof osql ) ) { return null ; } if ( i condition . get left ( ) instanceof osql && i condition . get right ( ) instanceof osql ) { return null ; } final osql item = ( osql ) i item ; if ( item . has chain operators ( ) && ! item . is field chain ( ) ) { return null ; } boolean inverted = i condition . get right ( ) == i item ; final object orig value = inverted ? i condition . get left ( ) : i condition . get right ( ) ; o operator = i condition . get operator ( ) ; if ( inverted ) { if ( operator instanceof o ) { operator = new o ( ) ; } else if ( operator instanceof o ) { operator = new o ( ) ; } else if ( operator instanceof o ) { operator = new o ( ) ; } else if ( operator instanceof o ) { operator = new o ( ) ; } else if ( operator instanceof o ) { operator = new o ( ) ; } else if ( operator instanceof o ) { operator = new o ( ) ; } } if ( i condition . get operator ( ) instanceof o || operator instanceof o ) { return new o ( operator , item . get field chain ( ) , orig value ) ; } final object value = osql . get value ( orig value , null , ctx ) ; return new o ( operator , item . get field chain ( ) , value ) ; }	Add SQL filter field to the search candidate list.
public void attach ( final object self ) throws illegal argument exception , illegal access exception , no such method exception , invocation target exception { for ( class < ? > current class = self . get class ( ) ; current class != object . class ; ) { if ( proxy . class . is assignable from ( current class ) ) { current class = current class . get superclass ( ) ; continue ; } for ( field f : current class . get declared fields ( ) ) { final string field name = f . get name ( ) ; final class < ? > declaring class = f . get declaring class ( ) ; if ( o . is transient field ( declaring class , field name ) || o . is version field ( declaring class , field name ) || o . is id field ( declaring class , field name ) ) continue ; object value = o . get field value ( f , self ) ; value = set value ( self , field name , value ) ; o . set field value ( f , self , value ) ; } current class = current class . get superclass ( ) ; if ( current class == null || current class . equals ( o . class ) )	Method that attaches all data contained in the object to the associated document.
private o get index class ( o ctx ) { if ( class name == null ) { return null ; } o result = ctx . get database ( ) . get metadata ( ) . get schema ( ) . get class ( class name . get string value ( ) ) ; if ( result == null ) { throw new o ( str + class name ) ; } return result ; }	calculates the indexed class based on the class name.
protected long next with new current value ( long current value , boolean execute via distributed ) throws o , o { if ( ! execute via distributed ) {	first set new current value then call next.
public void truncate ( ) throws io { o db = get database ( ) ; db . check security ( o . resource generic . class , o . permission update ) ; if ( is sub class of ( o . restricted classname ) ) { throw new o ( str + get name ( ) + str + o . restricted classname + str ) ; } final o storage = db . get storage ( ) ; acquire schema read lock ( ) ; try { for ( int id : cluster ids ) { o cl = storage . get cluster by id ( id ) ; db . check for cluster permissions ( cl . get name ( ) ) ; cl . truncate ( ) ; } for ( o < ? > index : get class indexes ( ) ) index . clear ( ) ; set < o < ? > > superclass indexes = new hash set < o < ? > > ( ) ; superclass indexes . add all ( get indexes ( ) ) ; superclass indexes . remove all ( get class indexes ( ) ) ; for ( o index : superclass indexes ) { index . rebuild ( ) ; } } finally { release schema read lock ( ) ; } }	Truncates all the clusters the class uses.
protected o add base class ( final o i base class ) { check recursion ( i base class ) ; if ( subclasses == null ) subclasses = new array list < o > ( ) ; if ( subclasses . contains ( i base class ) ) return this ; subclasses . add ( i base class ) ; add polymorphic cluster ids with inheritance ( i base class ) ; return this ; }	Adds a base class to the current one.
protected void add polymorphic cluster ids ( final o i base class ) { set < integer > clusters = new tree set < integer > ( ) ; for ( int cluster id : polymorphic cluster ids ) { clusters . add ( cluster id ) ; } for ( int cluster id : i base class . polymorphic cluster ids ) { if ( clusters . add ( cluster id ) ) { try { add cluster id to indexes ( cluster id ) ; } catch ( runtime exception e ) { o . instance ( ) . warn ( this , str , e , cluster id , get name ( ) ) ; clusters . remove ( cluster id ) ; } } } polymorphic cluster ids = new int [ clusters . size ( ) ] ; int i = num ; for ( integer cluster : clusters ) { polymorphic cluster ids [ i ] = cluster ; i ++ ; } }	Add different cluster id to the "polymorphic cluster ids" array.
private static o link to stream ( final string builder buffer , final o i parent record , object i linked ) { if ( i linked == null )	Serialize the link.
public final void release ( o pointer ) { if ( track ) { pointer mapping . remove ( pointer ) ; } long pool size = pointers pool size . increment and get ( ) ; if ( pool size > this . pool size ) { pointers pool size . decrement and get ( ) ; allocator . deallocate ( pointer ) ; } else { pointers pool . add ( pointer ) ; } }	Put buffer which is not used any more back to the pool or frees direct memory if pool is full.
public void check memory leaks ( ) { boolean detected = bool ; if ( track ) { for ( map . entry < o , pointer tracker > entry : pointer mapping . entry set ( ) ) { o . instance ( ) . error no db ( this , str , entry . get value ( ) . allocation , system . identity hash code ( entry . get key ( ) ) ) ; detected = bool ; } } assert ! detected ; }	Checks whether there are not released buffers in the pool.
public void clear ( ) { for ( o pointer : pointers pool ) { allocator . deallocate ( pointer ) ; } pointers pool . clear ( ) ; pointers pool size . set ( num ) ; for ( o pointer : pointer mapping . key set ( ) ) { allocator . deallocate ( pointer ) ; } pointer mapping . clear ( ) ; }	Clears pool and dealocates memory.
public static int bytes2int ( final byte [ ] b , final int offset ) { return ( b [ offset ] ) << num | ( num & b [ offset + num ] ) << num | ( num & b [ offset + num ] ) << num | ( ( num & b [ offset + num ] ) ) ; }	Convert the byte array to an int starting from the given offset.
@ override public void on open ( final o i database ) { if ( ! is related to local server ( i database ) ) return ; if ( is offline ( ) && status != node status . starting ) return ; final o curr db = o . instance ( ) . get if defined ( ) ; try { final string db name = i database . get name ( ) ; final o cfg = get database configuration ( db name ) ; if ( cfg == null ) return ; } catch ( hazelcast exception e ) { throw o . wrap exception ( new o ( str ) , e ) ; } catch ( hazelcast instance not active exception e ) { throw o . wrap exception ( new o ( str ) , e ) ; } finally {	Auto register myself as hook.
public boolean install clusters of class ( final o i database , final o i class , o cfg ) { final string database name = i database . get name ( ) ; if ( i class . is abstract ( ) ) return bool ;	Guarantees that each class has own master cluster.
protected void dump servers status ( ) { final o cfg = get cluster configuration ( ) ; final string compact status = o . get compact server status ( this , cfg ) ; if ( ! last server dump . equals ( compact status ) ) { last server dump = compact status ; o . info ( this , get local node name ( ) , null , direction . none , str , get lock manager server ( ) , o . format server status ( this , cfg ) ) ; } }	Avoids to dump the same configuration twice if it's unchanged since the last time.
public static int index of ( final object [ ] array , final comparable object ) { for ( int i = num ; i < array . length ; ++ i ) { if ( object . compare to ( array [ i ] ) == num )	This method is used to find an item in an array.
public static int index of ( final int [ ] array , final int object ) { for ( int i = num ; i < array . length ; ++ i ) { if ( array [ i ] == object )	This method is used to find a number in an array.
@ override public set < string > get involved clusters ( ) { final set < string > clusters = new hash set < string > ( ) ; if ( parsed target != null ) { final o db = get database ( ) ; if ( parsed target . get target query ( ) != null && parsed target . get target records ( ) instanceof o sql ) {	Determine clusters that are used in select operation.
@ override protected boolean handle result ( final o i record , final o i context ) { last record = i record ; if ( ( ordered fields . is empty ( ) || fully sorted by index || is rid only sort ( ) ) && skip > num && this . unwind fields == null && this . expand target == null ) { last record = null ; skip -- ; return bool ; } if ( ! add result ( last record , i context ) ) { return bool ; } return continue searching ( ) ; }	Handles the record in result.
public int get temporary rid ( final o i context ) { final o parent query = ( o ) i context . get variable ( str ) ; return parent query != null && parent query != this ? parent query . get temporary rid ( i context ) : serial temp rid . get and increment ( ) ; }	Returns the temporary RID counter assuring it's unique per query tree.
protected void report tip ( final string i message ) { orient . instance ( ) . get profiler ( ) . report tip ( i message ) ; list < string > tips = ( list < string > ) context . get variable ( str ) ; if ( tips == null ) { tips = new array list < string > ( num ) ; context . set variable ( str , tips ) ; } tips . add ( i message ) ; }	Report the tip to the profiler and collect it in context to be reported by tools like Studio.
protected boolean parse fetchplan ( final string w ) throws o sql { if ( ! w . equals ( keyword fetchplan ) ) { return bool ; } parser skip white spaces ( ) ; int start = parser get current position ( ) ; parser next word ( bool ) ; int end = parser get current position ( ) ; parser skip white spaces ( ) ; int position = parser get current position ( ) ; while ( ! parser is ended ( ) ) { final string word = oio . get string content ( parser next word ( bool ) ) ; if ( ! o . pattern fetch plan . matcher ( word ) . matches ( ) ) { break ; } end = parser get current position ( ) ; parser skip white spaces ( ) ; position = parser get current position ( ) ; } parser set current position ( position ) ; if ( end < num ) { fetch plan = oio . get string content ( parser text . substring ( start ) ) ; } else { fetch plan = oio . get string content ( parser text . substring ( start , end ) ) ; } request . set fetch plan ( fetch plan ) ; return bool ; }	Parses the fetchplan keyword if found.
protected boolean parse no cache ( final string w ) throws o sql { if ( ! w . equals ( keyword nocache ) ) return bool ; no cache = bool ; return bool ; }	Parses the NOCACHE keyword if found.
private boolean optimize sort ( o i schema class ) { o cursor = get optimized sort cursor ( i schema class ) ; if ( cursor != null ) { fetch values from index cursor ( cursor ) ; return bool ; } return bool ; }	Use index to order documents by provided fields.
public o status ( ) { synchronized ( listener ) { o status = new o ( ) ; status . field ( str , cfg ) ; status . field ( str , this . status ) ; string last batch log = str ; if ( this . message handler != null ) { last batch log = extract batch log ( ) ; } status . field ( str , last batch log ) ; if ( this . status == status . finished ) { listener . notify all ( ) ; } return status ; } }	Single Job Status.
@ suppress warnings ( str ) public < ret > ret execute ( final object ... i args ) { set parameters ( i args ) ; o . instance . get ( ) . on async replication ok = on async replication ok ; o . instance . get ( ) . on async replication error = on async replication error ; return ( ret ) o . instance ( ) . get ( ) . get storage ( ) . command ( this ) ; }	Delegates the execution to the configured command executor.
public final void handle jvm ( final error e ) { if ( jvm error . compare and set ( null , e ) ) { o . instance ( ) . error no db ( this , str , e ) ; } }	That is internal method which is called once we encounter any error inside of JVM.
@ suppress warnings ( str ) public boolean validated put index value ( int index id , final object key , final orid value , final o . validator < object , orid > validator ) throws o { index id = extract internal id ( index id ) ; try { if ( transaction . get ( ) != null ) { return do validated put index value ( index id , key , value , validator ) ; } check openness ( ) ; state lock . acquire read lock ( ) ; try { check openness ( ) ; check low disk space requests and read only conditions ( ) ; return do validated put index value ( index id , key , value , validator ) ; } finally { state lock . release read lock ( ) ; } } catch ( final o ie ) { throw log and prepare for rethrow ( ie ) ; } catch ( final runtime exception ee ) { throw log and prepare for rethrow ( ee ) ; } catch ( final error ee ) { throw log and prepare for rethrow ( ee ) ; } catch ( final throwable t ) { throw log and prepare for rethrow ( t ) ; } }	Puts the given value under the given key into this storage for the index with the given index id.
public void rollback ( final o micro transaction ) { try { check openness ( ) ; state lock . acquire read lock ( ) ; try { try { check openness ( ) ; if ( transaction . get ( ) == null ) { return ; } if ( transaction . get ( ) . get micro transaction ( ) . get id ( ) != micro transaction . get id ( ) ) { throw new o ( str + str ) ; } make storage dirty ( ) ; rollback storage tx ( ) ; micro transaction . update record cache after rollback ( ) ; tx rollback . increment and get ( ) ; } catch ( final io e ) { throw o . wrap exception ( new o ( str ) , e ) ; } finally { transaction . set ( null ) ; } } finally { state lock . release read lock ( ) ; } } catch ( final runtime exception ee ) { throw log and prepare for rethrow ( ee ) ; } catch ( final error ee ) { throw log and prepare for rethrow ( ee ) ; } catch ( final throwable t ) { throw log and prepare for rethrow ( t ) ; } }	Rollbacks the given micro-transaction.
@ override public final object command ( final o i command ) { try { while ( bool ) { try { final o executor = o . instance ( ) . get executor ( i command ) ;	Executes the command request and return the result back.
private int register cluster ( final o cluster ) { final int id ; if ( cluster != null ) {	Register the cluster internally.
public object set property ( final string i name , final object i value ) { if ( i value != null ) { return properties . put ( i name . to lower case ( locale . english ) , i value ) ; } else { return properties . remove ( i name . to lower case ( locale . english ) ) ; } }	Sets a property value.
public object execute ( final map < object , object > i args ) { if ( class name == null ) throw new o ( str ) ; final o database = get database ( ) ; boolean already exists = database . get metadata ( ) . get schema ( ) . exists class ( class name ) ; if ( ! already exists || ! if not exists ) { if ( clusters != null ) database . get metadata ( ) . get schema ( ) . create class ( class name , clusters , super classes . to array ( new o [ num ] ) ) ; else database . get metadata ( ) . get schema ( ) . create class ( class name , cluster ids , super classes . to array ( new o [ num ] ) ) ; } return database . get metadata ( ) . get schema ( ) . get classes ( ) . size ( ) ; }	Execute the CREATE CLASS.
public object execute ( final map < object , object > i args ) { final o database = get database ( ) ; database . check security ( o . resource generic . database , str , o . permission update ) ; final o stg = database . get storage ( ) ; if ( ! ( stg instanceof o ) ) throw new o ( str ) ; final o d stg = ( o ) stg ; final o d manager = ( o ) d stg . get distributed manager ( ) ; if ( d manager == null || ! d manager . is enabled ( ) ) throw new o ( str ) ; final string database name = database . get name ( ) ; return d manager . install database ( bool , database name , parsed statement . is force ( ) , ! parsed statement . is full ( ) ) ; }	Execute the SYNC DATABASE.
public o < o > delete ( final orid i record , final int i version ) { o record = load ( i record ) ; o . set version ( record , i version ) ; delete ( record ) ; return this ; }	Deletes the record checking the version.
public o . result callback hooks ( final o . type type , final o id ) { if ( id == null || hooks . is empty ( ) || id . get identity ( ) . get cluster id ( ) == num ) return o . result . record not changed ; final o . scope scope = o . scope . type to scope ( type ) ; final int scope ordinal = scope . ordinal ( ) ; final orid identity = id . get identity ( ) . copy ( ) ; if ( ! push in hook ( identity ) ) return o . result . record not changed ; try { final o rec = id . get record ( ) ; if ( rec == null ) return o . result . record not changed ; final o . run mode run mode = o . instance . get run mode ( ) ; boolean record changed = bool ; for ( o hook : hooks by scope [ scope ordinal ] ) { switch ( run mode ) { case default :	Callback the registered hooks if any.
public o delete ( final orid i record ) { check openness ( ) ; check if active ( ) ; final o rec = load ( i record ) ; if ( rec != null ) delete ( rec ) ; return this ; }	Deletes the record without checking the version.
public long count view ( final string view name ) { final o cls = get metadata ( ) . get immutable schema snapshot ( ) . get view ( view name ) ; if ( cls == null ) throw new illegal argument exception ( str + cls + str ) ; return count class ( cls , bool ) ; }	Returns the number of the records of the class iClassName.
public long count class ( final string i class name , final boolean i polymorphic ) { final o cls = get metadata ( ) . get immutable schema snapshot ( ) . get class ( i class name ) ; if ( cls == null ) throw new illegal argument exception ( str + cls + str ) ; return count class ( cls , i polymorphic ) ; }	Returns the number of the records of the class iClassName considering also sub classes if polymorphic is true.
@ override public o activate on current thread ( ) { final o tl = o . instance ( ) ; if ( tl != null ) tl . set ( this ) ; return this ; }	Activates current database instance on current thread.
public void register ( final o i encryption ) { try { final string name = i encryption . name ( ) ; if ( instances . contains key ( name ) ) throw new illegal argument exception ( str + name + str ) ; if ( classes . contains key ( name ) ) throw new illegal argument exception ( str + name + str ) ; instances . put ( name , i encryption ) ; } catch ( exception e ) { o . instance ( ) . error ( this , str , e , i encryption ) ; } }	Registers a stateful implementations, a new instance will be created for each storage.
private int get relative index ( long pos ) { int current size = num ; current chunk index = num ;	Calculates the index within a binary chunk corresponding to the given absolute position within this BLOB.
protected string parser optional word ( final boolean i upper case ) { parser previous pos = parser current pos ; parser next word ( i upper case ) ; if ( parser last word . length ( ) == num ) return null ; return parser last word . to string ( ) ; }	Parses the next word.
protected string parser required word ( final boolean i upper case , final string i custom message , string i separators ) { if ( i separators == null ) i separators = str ; parser next word ( i upper case , i separators ) ; if ( parser last word . length ( ) == num ) throw syntax error exception ( i custom message ) ; if ( parser last word . char at ( num ) == str && parser last word . char at ( parser last word . length ( ) - num ) == str ) { return parser last word . substring ( num , parser last word . length ( ) - num ) ; } return parser last word . to string ( ) ; }	Parses the next word.
protected int parser next chars ( final boolean i upper case , final boolean i mandatory , final string ... i candidate words ) { parser previous pos = parser current pos ; parser skip white spaces ( ) ; parser escape sequence count = num ; parser last word . set length ( num ) ; final string [ ] processed words = arrays . copy of ( i candidate words , i candidate words . length ) ;	Parses the next sequence of chars.
protected boolean parser optional keyword ( final string ... i words ) { parser next word ( bool , str ) ; if ( parser last word . length ( ) == num ) return bool ;	Parses optional keywords between the iWords.
private boolean parser check separator ( final char c , final string i separator chars ) { for ( int sep index = num ; sep index < i separator chars . length ( ) ; ++ sep index ) { if ( i separator chars . char at ( sep index ) == c ) { parser last separator = c ; return bool ; } } return bool ; }	Check for a separator.
public object execute ( final map < object , object > i args ) { if ( class name == null ) { throw new o ( str ) ; } final o database = get database ( ) ; if ( if exists && ! database . get metadata ( ) . get schema ( ) . exists class ( class name ) ) { return bool ; } final o cls = database . get metadata ( ) . get schema ( ) . get class ( class name ) ; if ( cls == null ) { return null ; } final long records = cls . count ( bool ) ; if ( records > num && ! unsafe ) {	Execute the DROP CLASS.
private void clear configuration files ( ) throws io { final path file = storage path . resolve ( name ) ; files . delete if exists ( file ) ; final path backup file = storage path . resolve ( backup name ) ; files . delete if exists ( backup file ) ; }	Remove both backup and primary configuration files on delete.
public int get as byte array offset ( ) { if ( position >= length ) return - num ; final int begin = position ; final int size = o . bytes2int ( buffer , position ) ; position += o . size int + size ; return begin ; }	Browse the stream but just return the begin of the byte array.
protected string extract ( string token type ) { o access token = get token ( ) ; return string . format ( str , token type , access token . get value ( ) ) ; }	Extracts the token extract id the access token exists or returning an empty extractif there is no one on the context it may occasionally causes Unauthorized responsesince the token extract is empty.
protected o acquire access token ( ) throws user redirect required exception { access token request token request = o auth2 client context . get access token request ( ) ; if ( token request == null ) { throw new access token required exception ( str + resource . get id ( ) + str , resource ) ; } string state key = token request . get state key ( ) ; if ( state key != null ) { token request . set preserved state ( o auth2 client context . remove preserved state ( state key ) ) ; } o existing token = o auth2 client context . get access token ( ) ; if ( existing token != null ) { o auth2 client context . set access token ( existing token ) ; } o obtainable access token ; obtainable access token = access token provider . obtain access token ( resource , token request ) ; if ( obtainable access token == null || obtainable access token . get value ( ) == null ) { throw new illegal state exception ( str ) ; } o auth2 client context . set access token ( obtainable access token ) ; return obtainable access token ; }	Try to acquire the token using a access token provider.
public boolean copy token ( ) { if ( context . get access token ( ) == null ) { authentication authentication = security context holder . get context ( ) . get authentication ( ) ; if ( authentication != null ) { object details = authentication . get details ( ) ; if ( details instanceof o ) { o holder = ( o ) details ; string token = holder . get token value ( ) ; o access token = new o ( token ) ; string token type = holder . get token type ( ) ; if ( token type != null ) { access token . set token type ( token type ) ; } context . set access token ( access token ) ; return bool ; } } } return bool ; }	Attempt to copy an access token from the security context into the oauth2 context.
protected boolean no more characters ( ) throws io { if ( avail == num ) { avail = is . read ( buffer ) ; if ( avail <= num ) { avail = num ; return bool ; } pos = num ; } return bool ; }	Checks whether no more bytes will be returned.
public int read line ( final byte [ ] array , final enum set < line terminator > terminators ) throws io { return read line ( array , num , array . length , terminators ) ; }	Reads a line into the given byte array.
private long skip by reading ( final long n ) throws io { long to skip = n ; int len ; while ( to skip > num ) { len = is . read ( buffer , num , ( int ) math . min ( buffer . length , to skip ) ) ; if ( len > num ) to skip -= len ; else break ; } return n - to skip ; }	Skips the given amount of bytes by repeated reads.
public static void ensure offset length ( final int array length , final int offset , final int length ) { if ( offset < num ) throw new array index out of bounds exception ( str + offset + str ) ; if ( length < num ) throw new illegal argument exception ( str + length + str ) ; if ( offset + length > array length ) throw new array index out of bounds exception ( str + ( offset + length ) + str + array length + str ) ; }	Ensures that a range given by an offset and a length fits an array of given length.
protected static void swap ( final swapper swapper , int a , int b , final int n ) { for ( int i = num ; i < n ; i ++ , a ++ , b ++ ) swapper . swap ( a , b ) ; }	Swaps two sequences of elements using a provided swapper.
public static int murmur hash3 ( int x ) { x ^= x > > > num ; x *= num ; x ^= x > > > num ; x *= num ; x ^= x > > > num ; return x ; }	Avalanches the bits of an integer by applying the finalisation step of MurmurHash3.
public static long murmur hash3 ( long x ) { x ^= x > > > num ; x *= num ; x ^= x > > > num ; x *= num ; x ^= x > > > num ; return x ; }	Avalanches the bits of a long integer by applying the finalisation step of MurmurHash3.
@ override public int write ( final byte buffer byte buffer ) throws io { ensure open ( ) ; final int remaining = byte buffer . remaining ( ) ; if ( inspectable < buffer . length ) {	Appends the content of a specified buffer to the end of the currently represented stream.
public void truncate ( final long size ) throws file not found exception , io { file channel . truncate ( math . max ( size , write position ) ) ; }	Truncates the overflow file to a given size if possible.
@ override public void position ( final long new position ) throws io { flush ( ) ; if ( repositionable stream != null ) repositionable stream . position ( new position ) ; else if ( file channel != null ) file channel . position ( new position ) ; else throw new unsupported operation exception ( str ) ; }	Repositions the stream. Note that this method performs a {.
private final void no fail refresh end metrics reporting ( consumer refresh metrics refresh metrics ) { try { refresh end metrics reporting ( refresh metrics ) ; } catch ( exception e ) {	Metrics reporting implementation is provided by the extending subclass.
public void await successful completion of current tasks ( ) throws interrupted exception , execution exception { for ( future < ? > f : futures ) { f . get ( ) ; } futures . clear ( ) ; }	Await successful completion of all previously submitted tasks.
public stream < s > find matches ( q query ) { object [ ] query array = match fields . stream ( ) . map ( mf -> mf . extract ( query ) ) . to array ( ) ; hollow hash index result matches = hhi . find matches ( query array ) ; if ( matches == null ) { return stream . empty ( ) ; } return matches . stream ( ) . map to obj ( i -> select field . extract ( api , i ) ) ; }	Finds matches for a given query.
private set < string > find compaction targets ( ) { list < hollow schema > schemas = hollow schema sorter . dependency ordered schema list ( read engine . get schemas ( ) ) ; set < string > types to compact = new hash set < string > ( ) ; for ( hollow schema schema : schemas ) { if ( is compaction candidate ( schema . get name ( ) ) ) { if ( ! candidate is dependent on any targeted type ( schema . get name ( ) , types to compact ) ) types to compact . add ( schema . get name ( ) ) ; } } return types to compact ; }	Find candidate types for compaction.
@ override public void clean snapshots ( ) { file [ ] files = get files by type ( hollow producer . blob . type . snapshot . prefix ) ; if ( files == null || files . length <= num of snapshots to keep ) { return ; } sort by last modified ( files ) ; for ( int i = num of snapshots to keep ; i < files . length ; i ++ ) { file file = files [ i ] ; boolean deleted = file . delete ( ) ; if ( ! deleted ) { log . warning ( str + file . get path ( ) ) ; } } }	Cleans snapshot to keep the last 'n' snapshots.
public static int field hash code ( hollow object type data access type access , int ordinal , int field position ) { hollow object schema schema = type access . get schema ( ) ; switch ( schema . get field type ( field position ) ) { case boolean : boolean bool = type access . read boolean ( ordinal , field position ) ; return boolean hash code ( bool ) ; case bytes : case string : return type access . find var length field hash code ( ordinal , field position ) ; case double : double d = type access . read double ( ordinal , field position ) ; return double hash code ( d ) ; case float : float f = type access . read float ( ordinal , field position ) ; return float hash code ( f ) ; case int : return int hash code ( type access . read int ( ordinal , field position ) ) ; case long : long l = type access . read long ( ordinal , field position ) ; return long hash code ( l ) ; case reference : return type access . read ordinal ( ordinal , field position ) ; } throw new illegal state exception ( str + schema . get field type ( field position ) ) ; }	Hash a field in an OBJECT record.
public static void remove referenced outside closure ( hollow read state engine state engine , map < string , bit set > matches ) { list < hollow schema > ordered schemas = hollow schema sorter . dependency ordered schema list ( state engine ) ; collections . reverse ( ordered schemas ) ; for ( hollow schema referenced schema : ordered schemas ) { if ( matches . contains key ( referenced schema . get name ( ) ) ) { for ( hollow schema referencer schema : ordered schemas ) { if ( referencer schema == referenced schema ) break ; if ( matches . contains key ( referenced schema . get name ( ) ) && matches . get ( referenced schema . get name ( ) ) . cardinality ( ) > num ) traverse references outside closure ( state engine , referencer schema . get name ( ) , referenced schema . get name ( ) , matches , remove referenced outside closure ) ; } } } }	Remove any records from the given selection which are referenced by other records not in the selection.
@ override public void on announcement complete ( com . netflix . hollow . api . producer . status status , hollow producer . read state read state , long version , duration elapsed ) { boolean is announcement success = bool ; long data size bytes = num ; if ( status . get type ( ) == com . netflix . hollow . api . producer . status . status type . success ) { is announcement success = bool ; last announcement success time nano optional = optional long . of ( system . nano time ( ) ) ; } hollow read state engine state engine = read state . get state engine ( ) ; data size bytes = state engine . calc approx data size ( ) ; announcement metrics builder . set data size bytes ( data size bytes ) . set is announcement success ( is announcement success ) . set announcement duration millis ( elapsed . to millis ( ) ) ; last announcement success time nano optional . if present ( announcement metrics builder :: set last announcement success time nano ) ; announcement metrics reporting ( announcement metrics builder . build ( ) ) ; }	Reports announcement-related metrics.
@ override public void on cycle complete ( com . netflix . hollow . api . producer . status status , hollow producer . read state read state , long version , duration elapsed ) { boolean is cycle success ; long cycle end time nano = system . nano time ( ) ; if ( status . get type ( ) == com . netflix . hollow . api . producer . status . status type . success ) { is cycle success = bool ; consecutive failures = num ; last cycle success time nano optional = optional long . of ( cycle end time nano ) ; } else { is cycle success = bool ; consecutive failures ++ ; } cycle metrics builder . set consecutive failures ( consecutive failures ) . set cycle duration millis ( elapsed . to millis ( ) ) . set is cycle success ( is cycle success ) ; last cycle success time nano optional . if present ( cycle metrics builder :: set last cycle success time nano ) ; cycle metrics reporting ( cycle metrics builder . build ( ) ) ; }	On cycle completion this method reports cycle metrics.
private map < string , string > read header tags ( data input stream dis ) throws io { int num header tags = dis . read short ( ) ; map < string , string > header tags = new hash map < string , string > ( ) ; for ( int i = num ; i < num header tags ; i ++ ) { header tags . put ( dis . read utf ( ) , dis . read utf ( ) ) ; } return header tags ; }	Map of string header tags reading.
public record primary key extract primary key ( object o ) { hollow object type mapper type mapper = ( hollow object type mapper ) get type mapper ( o . get class ( ) , null , null ) ; return new record primary key ( type mapper . get type name ( ) , type mapper . extract primary key ( o ) ) ; }	Extracts the primary key from the specified POJO.
public void clear all ( ) { thread safe bit set segments segments = this . segments . get ( ) ; for ( int i = num ; i < segments . num segments ( ) ; i ++ ) { atomic long array segment = segments . get segment ( i ) ; for ( int j = num ; j < segment . length ( ) ; j ++ ) { segment . set ( j , num ) ; } } }	Clear all bits to 0.
public static void read ordinals ( data input stream dis , hollow type state listener [ ] listeners ) throws io { int num longs = dis . read int ( ) ; int current ordinal = num ; for ( int i = num ; i < num longs ; i ++ ) { long l = dis . read long ( ) ; notify populated ordinals ( l , current ordinal , listeners ) ; current ordinal += num ; } }	Read populated ordinals as a bit set from a stream, and notify a listener for each populated ordinal.
public long size ( ) { sparse bit set current ; long size ; do { current = sparse bit set volatile ; size = current . estimate bits used ( ) ; } while ( current != sparse bit set volatile ) ; return size ; }	Estimate the total number of bits used to represent the integer set.
private static string get field value ( hollow diff view row row , boolean use from ) { field field = use from ? row . get field pair ( ) . get from ( ) : row . get field pair ( ) . get to ( ) ; if ( row . get field pair ( ) . is leaf node ( ) ) { return field . get value ( ) == null ? str : field . get value ( ) . to string ( ) . replace ( str , str ) ; } else { string suffix = field . get value ( ) == null ? str : str ; return str + field . get type name ( ) + str + suffix ; } }	Returns a String representation of the provided row's field value.
public void copy ( byte data src , long src pos , long dest pos , long length ) { for ( long i = num ; i < length ; i ++ ) { set ( dest pos ++ , src . get ( src pos ++ ) ) ; } }	Copy bytes from another ByteData to this array.
public int copy ( long src pos , byte [ ] data , int dest pos , int length ) { int segment size = num << log2 of segment size ; int remaining bytes in segment = ( int ) ( segment size - ( src pos & bitmask ) ) ; int data position = dest pos ; while ( length > num ) { byte [ ] segment = segments [ ( int ) ( src pos > > > log2 of segment size ) ] ; int bytes to copy from segment = math . min ( remaining bytes in segment , length ) ; system . arraycopy ( segment , ( int ) ( src pos & bitmask ) , data , data position , bytes to copy from segment ) ; data position += bytes to copy from segment ; src pos += bytes to copy from segment ; remaining bytes in segment = segment size - ( int ) ( src pos & bitmask ) ; length -= bytes to copy from segment ; } return data position - dest pos ; }	copies exactly data.length bytes from this SegmentedByteArray into the provided byte array.
public boolean range equals ( long range start , segmented byte array compare to , long cmp start , int length ) { for ( int i = num ; i < length ; i ++ ) if ( get ( range start + i ) != compare to . get ( cmp start + i ) ) return bool ; return bool ; }	checks equality for a specified range of bytes in two arrays.
public void ordered copy ( segmented byte array src , long src pos , long dest pos , long length ) { int segment length = num << log2 of segment size ; int current segment = ( int ) ( dest pos > > > log2 of segment size ) ; int segment start pos = ( int ) ( dest pos & bitmask ) ; int remaining bytes in segment = segment length - segment start pos ; while ( length > num ) { int bytes to copy from segment = ( int ) math . min ( remaining bytes in segment , length ) ; ensure capacity ( current segment ) ; int copied bytes = src . ordered copy ( src pos , segments [ current segment ] , segment start pos , bytes to copy from segment ) ; src pos += copied bytes ; length -= copied bytes ; segment start pos = num ; remaining bytes in segment = segment length ; current segment ++ ; } }	Copies the data from the provided source array into this array, guaranteeing thatif the update is seen by another thread, then all other writes prior to this callare also visible to that thread.
public int ordered copy ( long src pos , byte [ ] data , int dest pos , int length ) { int segment size = num << log2 of segment size ; int remaining bytes in segment = ( int ) ( segment size - ( src pos & bitmask ) ) ; int data position = dest pos ; while ( length > num ) { byte [ ] segment = segments [ ( int ) ( src pos > > > log2 of segment size ) ] ; int bytes to copy from segment = math . min ( remaining bytes in segment , length ) ; ordered copy ( segment , ( int ) ( src pos & bitmask ) , data , data position , bytes to copy from segment ) ; data position += bytes to copy from segment ; src pos += bytes to copy from segment ; remaining bytes in segment = segment size - ( int ) ( src pos & bitmask ) ; length -= bytes to copy from segment ; } return data position - dest pos ; }	copies exactly data.length bytes from this SegmentedByteArray into the provided byte array,guaranteeing that if the update is seen by another thread, then all other writes prior tothis call are also visible to that thread.
public void read from ( input stream is , long length ) throws io { int segment size = num << log2 of segment size ; int segment = num ; byte scratch [ ] = new byte [ segment size ] ; while ( length > num ) { ensure capacity ( segment ) ; long bytes to copy = math . min ( segment size , length ) ; long bytes copied = num ; while ( bytes copied < bytes to copy ) { bytes copied += is . read ( scratch , ( int ) bytes copied , ( int ) ( bytes to copy - bytes copied ) ) ; } ordered copy ( scratch , num , segments [ segment ++ ] , num , ( int ) bytes copied ) ; length -= bytes copied ; } }	Copy bytes from the supplied InputStream into this array.
public void write to ( output stream os , long start position , long len ) throws io { int segment size = num << log2 of segment size ; int remaining bytes in segment = segment size - ( int ) ( start position & bitmask ) ; long remaining bytes in copy = len ; while ( remaining bytes in copy > num ) { long bytes to copy from segment = math . min ( remaining bytes in segment , remaining bytes in copy ) ; os . write ( segments [ ( int ) ( start position > > > log2 of segment size ) ] , ( int ) ( start position & bitmask ) , ( int ) bytes to copy from segment ) ; start position += bytes to copy from segment ; remaining bytes in segment = segment size - ( int ) ( start position & bitmask ) ; remaining bytes in copy -= bytes to copy from segment ; } }	Write a portion of this data to an OutputStream.
private void ensure capacity ( int segment index ) { while ( segment index >= segments . length ) { segments = arrays . copy of ( segments , segments . length * num / num ) ; } if ( segments [ segment index ] == null ) { segments [ segment index ] = memory recycler . get byte array ( ) ; } }	Ensures that the segment at segmentIndex exists.
public int get position ( string field name ) { integer index = name field index lookup . get ( field name ) ; if ( index == null ) { return - num ; } return index ; }	Returns the position of a field previously added to the map, or -1 if the field has not been added to the map.The positions of the fields are hashed into the hashedPositionArray by the hashCode of the fieldName.
private long calculate deduped sizes and total number of select buckets ( multi linked element array element array , growing segmented long array match index hash and size array ) { long total buckets = num ; long max size = num ; int [ ] select array = new int [ num ] ; for ( int i = num ; i < element array . num lists ( ) ; i ++ ) { int list size = element array . list size ( i ) ; int set size = num ; int predicted buckets = hash codes . hash table size ( list size ) ; int hash mask = predicted buckets - num ; if ( predicted buckets > select array . length ) select array = new int [ predicted buckets ] ; for ( int j = num ; j < predicted buckets ; j ++ ) select array [ j ] = - num ; hollow ordinal iterator iter = element array . iterator ( i ) ; int select ordinal = iter . next ( ) ; while ( select ordinal != hollow ordinal iterator . no more ordinals ) { int hash = hash codes . hash int ( select ordinal ) ; int bucket = hash & hash mask ; while ( bool ) { if ( select array [ bucket ] == select ordinal ) break ; if ( select array [ bucket ] == - num ) { select array [ bucket ] = select ordinal ; set size ++ ; break ; } bucket = ( bucket + num ) & hash mask ; } select ordinal = iter . next ( ) ; } long match index hash and size = match index hash and size array . get ( i ) ; match index hash and size |= ( long ) set size << num ; match index hash and size array . set ( i , match index hash and size ) ; total buckets += hash codes . hash table size ( set size ) ; if ( set size > max size ) max size = set size ; } return total buckets | ( long ) bits required to represent value ( max size ) << num ; }	Called after initial pass.Returns the sum total number of select buckets in the low 7 bytes, and the bits required for the max set size in the high 1 byte.
protected static boolean has collections in data set ( hollow dataset dataset ) { for ( hollow schema schema : dataset . get schemas ( ) ) { if ( ( schema instanceof hollow list schema ) || ( schema instanceof hollow set schema ) || ( schema instanceof hollow map schema ) ) { return bool ; } } return bool ; }	Determines whether DataSet contains any collections schema.
public void generate files ( file directory ) throws io { if ( package name != null && ! package name . trim ( ) . is empty ( ) ) { string package dir = package name . replace ( str , file . separator ) ; if ( ! directory . get absolute path ( ) . ends with ( package dir ) ) { directory = new file ( directory , package dir ) ; } } directory . mkdirs ( ) ; api api class generator = new api ( package name , api classname , dataset , parameterize class names , config ) ; api api factory generator = new api ( package name , api classname , dataset , config ) ; hollow hash index generator hash index generator = new hollow hash index generator ( package name , api classname , dataset , config ) ; generate file ( directory , api class generator ) ; generate file ( directory , api factory generator ) ; generate file ( directory , hash index generator ) ; generate files for hollow schemas ( directory ) ; }	Generate files under the specified directory.
protected void generate files for hollow schemas ( file directory ) throws io { for ( hollow schema schema : dataset . get schemas ( ) ) { string type = schema . get name ( ) ; if ( config . is use hollow primitive types ( ) && hollow code generation utils . is primitive type ( type ) ) continue ;	Generate files based on dataset schemas under the specified directory.
public boolean key matches ( int ordinal , object ... keys ) { if ( keys . length != field path indexes . length ) return bool ; for ( int i = num ; i < keys . length ; i ++ ) { if ( ! key matches ( keys [ i ] , ordinal , i ) ) return bool ; } return bool ; }	Determine whether or not the specified ordinal contains the provided primary key value.
public object [ ] get record key ( int ordinal ) { object [ ] results = new object [ field path indexes . length ] ; for ( int i = num ; i < field path indexes . length ; i ++ ) { results [ i ] = read value ( ordinal , i ) ; } return results ; }	Retrieve the primary key value for the specified ordinal.
public static field path < object field segment > create field path for primary key ( hollow dataset dataset , string type , string path ) { boolean auto expand = ! path . ends with ( str ) ; path = auto expand ? path : path . substring ( num , path . length ( ) - num ) ; field path < field segment > fp = create field path ( dataset , type , path , auto expand , bool , bool ) ;	Creates an object-based field path given a data set and the field path in symbolic form conforming to pathsassociated with a primary key.
public static field path < field segment > create field path for hash index ( hollow dataset dataset , string type , string path ) { return create field path ( dataset , type , path , bool , bool , bool ) ; }	Creates a field path given a data set and the field path in symbolic form conforming to pathsassociated with a hash index.
public void put ( object obj , int ordinal ) { int hash code = system . identity hash code ( obj ) ; int segment = segment ( hash code ) ; segments [ segment ] . put ( obj , hash code , ordinal ) ; }	Associating the obj with an ordinal.
private void initialize ( ) { string last ref type = this . field path . get last ref type in path ( ) ;	initialize field positions and field paths.
public boolean contains ( string key ) { if ( key == null ) throw new illegal argument exception ( str ) ; tst current ; boolean result ; do { current = prefix index volatile ; result = current . contains ( key ) ; } while ( current != this . prefix index volatile ) ; return result ; }	Check if the given key exists in the index.
public void add field ( string type , string object field ) { object filter config type config = specified field configs . get ( type ) ; if ( type config == null ) { type config = new object filter config ( ) ; specified field configs . put ( type , type config ) ; } type config . add field ( object field ) ; }	Add an individual field from an OBJECT schema.
public static list < hollow schema > dependency ordered schema list ( collection < hollow schema > schemas ) { dependency index idx = new dependency index ( ) ; map < string , hollow schema > schema map = new hash map < string , hollow schema > ( ) ; for ( hollow schema schema : schemas ) { schema map . put ( schema . get name ( ) , schema ) ; idx . index schema ( schema , schemas ) ; } list < hollow schema > ordered schemas = new array list < hollow schema > ( ) ; while ( idx . has more types ( ) ) ordered schemas . add ( schema map . get ( idx . get next type ( ) ) ) ; return ordered schemas ; }	Dependency types come before dependent types.
public void init with next major version defaults ( ) { use package grouping = bool ; use boolean field ergonomics = bool ; reserve primary key index for type with primary key = bool ; use hollow primitive types = bool ; restrict api to field type = bool ; use verbose to string = bool ; }	Make it easier to automatically use defaults for next major version.
public long get ( long index ) { int segment index = ( int ) ( index > > log2 of segment size ) ; if ( segment index >= segments . length || segments [ segment index ] == null ) return num ; int long in segment = ( int ) ( index & bitmask ) ; return segments [ segment index ] [ long in segment ] ; }	Get the value of the byte at the specified index.
public map < string , bit set > find matching records ( string field name , string field value ) { map < string , bit set > matches = new hash map < string , bit set > ( ) ; for ( hollow type read state type state : read engine . get type states ( ) ) { augment matching records ( type state , field name , field value , matches ) ; } return matches ; }	Match any records which include a field with the provided fieldName and value.
public map < string , bit set > find matching records ( string type name , string field name , string field value ) { map < string , bit set > matches = new hash map < string , bit set > ( ) ; hollow type read state type state = read engine . get type state ( type name ) ; if ( type state != null ) augment matching records ( type state , field name , field value , matches ) ; return matches ; }	Match any records of the specified type, which have the specified field set to the specified value.
public void set element match paths ( string ... paths ) { reset results ( ) ; this . element paths = paths ; this . element key paths = null ; this . element non key paths = null ; }	Set the paths for which we will inspect differences across the two states.
public void set element key paths ( string ... paths ) { reset results ( ) ; element key paths = new bit set ( element paths . length ) ; for ( int i = num ; i < paths . length ; i ++ ) { int element path idx = get element path idx ( paths [ i ] ) ; if ( element path idx == - num ) throw new illegal argument exception ( str + paths [ i ] ) ; element key paths . set ( element path idx ) ; } element non key paths = new bit set ( element paths . length ) ; element non key paths . set ( num , element paths . length ) ; element non key paths . and not ( element key paths ) ; }	Optionally specify paths for which we will match records within an individual type's hierarchy.
public void restore from last state ( ) { producer . initialize data model ( data model ) ; long latest announced version = announcement watcher . get latest version ( ) ; if ( latest announced version == hollow filesystem announcement watcher . no announcement available || latest announced version < num ) { return ; } restore ( latest announced version , blob retriever ) ; }	Initializes the data model and restores from existing state.
public long run cycle ( ) { long records removed = count records to remove ( ) ; long records added or modified = this . mutations . values ( ) . size ( ) - records removed ; try { long version = producer . run cycle ( populator ) ; if ( version == last sucessful cycle ) { return version ; } listeners . fire incremental cycle complete ( version , records added or modified , records removed , new hash map < string , object > ( cycle metadata ) ) ;	Runs a Hollow Cycle, if successful, cleans the mutations map.
public void exclude key ( hollow primary key index idx , object ... key ) { int exclude ordinal = idx . get matching ordinal ( key ) ; if ( exclude ordinal >= num ) { bit set excluded ordinals = this . excluded ordinals . get ( idx . get type state ( ) ) ; if ( excluded ordinals == null ) { excluded ordinals = new bit set ( idx . get type state ( ) . max ordinal ( ) + num ) ; this . excluded ordinals . put ( idx . get type state ( ) , excluded ordinals ) ; } excluded ordinals . set ( exclude ordinal ) ; } }	Exclude the record which matches the specified key.
public void exclude referenced objects ( ) { set < hollow read state engine > state engines = new hash set < hollow read state engine > ( ) ; for ( map . entry < hollow type read state , bit set > entry : excluded ordinals . entry set ( ) ) state engines . add ( entry . get key ( ) . get state engine ( ) ) ; for ( hollow read state engine state engine : state engines ) { map < string , bit set > type bit sets for state engine = new hash map < string , bit set > ( ) ; for ( map . entry < hollow type read state , bit set > entry : excluded ordinals . entry set ( ) ) { if ( entry . get key ( ) . get state engine ( ) == state engine ) { string type = entry . get key ( ) . get schema ( ) . get name ( ) ; type bit sets for state engine . put ( type , bit set . value of ( entry . get value ( ) . to long array ( ) ) ) ; } } transitive set traverser . add transitive matches ( state engine , type bit sets for state engine ) ; for ( map . entry < string , bit set > entry : type bit sets for state engine . entry set ( ) ) excluded ordinals . put ( state engine . get type state ( entry . get key ( ) ) , entry . get value ( ) ) ; } }	Exclude any objects which are referenced by excluded objects.
public void write header ( hollow blob header header , data output stream dos ) throws io {	Write the header to the data output stream.
void calculate type metrics ( hollow read state engine hollow read state engine ) { collection < hollow type read state > type states = hollow read state engine . get type states ( ) ; if ( type states == null ) return ; total heap footprint = num ; total populated ordinals = num ; for ( hollow type read state type state : type states ) { long heap cost = type state . get approximate heap footprint in bytes ( ) ; total heap footprint += heap cost ; int populated ordinals = type state . get populated ordinals ( ) . cardinality ( ) ; total populated ordinals += populated ordinals ; string type = type state . get schema ( ) . get name ( ) ; type heap footprint . put ( type , heap cost ) ; type populated ordinals . put ( type , populated ordinals ) ; } }	Calculates the memory heap footprint and populated ordinals per type and total.
public void write data to ( byte data buffer buf ) { for ( int i = num ; i < field data . length ; i ++ ) { write field ( buf , i ) ; } }	Concatenates all fields, in order, to the ByteDataBuffer supplied.
private static void write fixed length int ( byte data buffer field buffer , int int bits ) { field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits ) ) ; }	Write 4 consecutive bytes.
private static void write fixed length long ( byte data buffer field buffer , long int bits ) { field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits > > > num ) ) ; field buffer . write ( ( byte ) ( int bits ) ) ; }	Write 8 consecutive bytes.
public void return ordinal to pool ( int ordinal ) { if ( size == free ordinals . length ) { free ordinals = arrays . copy of ( free ordinals , free ordinals . length * num / num ) ; } free ordinals [ size ] = ordinal ; size ++ ; }	Return an ordinal to the pool after the object to which it was assigned is discarded.
public void sort ( ) { arrays . sort ( free ordinals , num , size ) ;	Ensure that all future ordinals are returned in ascending order.
public static int hash ( object key [ ] , field type field type [ ] ) { int hash = num ; for ( int i = num ; i < key . length ; i ++ ) { hash *= num ; hash ^= hash ( key [ i ] , field type [ i ] ) ; } return hash ; }	Hash a key.
public static int hash ( object key , field type field type ) { switch ( field type ) { case int : return hash codes . hash int ( ( ( integer ) key ) . int value ( ) ) ; case long : long long val = ( ( long ) key ) . long value ( ) ; return hash codes . hash int ( ( int ) ( long val ^ ( long val > > > num ) ) ) ; case reference : return hash codes . hash int ( ( ( integer ) key ) . int value ( ) ) ; case bytes : return hash codes . hash int ( hash codes . hash code ( ( byte [ ] ) key ) ) ; case string : return hash codes . hash int ( key . hash code ( ) ) ; case boolean : return hash codes . hash int ( ( ( boolean ) key ) . boolean value ( ) ? num : num ) ; case double : long long bits = double . double to raw long bits ( ( ( double ) key ) . double value ( ) ) ; return hash codes . hash int ( ( int ) ( long bits ^ ( long bits > > > num ) ) ) ; case float : return hash codes . hash int ( float . float to raw int bits ( ( ( float ) key ) . float value ( ) ) ) ; default : throw new illegal argument exception ( str + field type ) ; } }	Hash a single key field.
private void resize storage ( ) { int current elements per node = max elements per node ; int new elements per node = ( int ) ( current elements per node * resize multiple ) ; if ( new elements per node <= current elements per node ) { throw new illegal state exception ( str + current elements per node + str + new elements per node ) ; } fixed length element array new storage = new fixed length element array ( memory recycler , num nodes * bits per element * new elements per node ) ; long stream . range ( num , num nodes ) . for each ( node index -> { long current bucket start = node index * current elements per node * bits per element ; long new bucket start = node index * new elements per node * bits per element ; for ( int offset = num ; offset < current elements per node ; offset ++ ) { long element = storage . get element value ( current bucket start + offset * bits per element , bits per element , element mask ) ; if ( element == no element ) { break ;	Resize the underlying storage to a multiple of what it currently is.
private int find free ordinal ( int preferred ordinal ) { if ( preferred ordinal != - num && unused previous ordinals . get ( preferred ordinal ) ) { unused previous ordinals . clear ( preferred ordinal ) ; return preferred ordinal ; } return free ordinal tracker . get free ordinal ( ) ; }	If the preferredOrdinal has not already been used, mark it and use it.
public void prepare for write ( ) { int max ordinal = num ; atomic long array pao = pointers and ordinals ; for ( int i = num ; i < pao . length ( ) ; i ++ ) { long key = pao . get ( i ) ; if ( key != empty bucket value ) { int ordinal = ( int ) ( key > > > bits per pointer ) ; if ( ordinal > max ordinal ) { max ordinal = ordinal ; } } } long [ ] pbo = new long [ max ordinal + num ] ; arrays . fill ( pbo , - num ) ; for ( int i = num ; i < pao . length ( ) ; i ++ ) { long key = pao . get ( i ) ; if ( key != empty bucket value ) { int ordinal = ( int ) ( key > > > bits per pointer ) ; pbo [ ordinal ] = key & pointer mask ; } } pointers by ordinal = pbo ; }	Create an array mapping the ordinals to pointers, so that they can be easily looked upwhen writing to blob streams.
private boolean compare ( byte data buffer serialized representation , long key ) { long position = key & pointer mask ; int size of data = var int . read v ( byte data . get underlying array ( ) , position ) ; if ( size of data != serialized representation . length ( ) ) { return bool ; } position += var int . size of v ( size of data ) ; for ( int i = num ; i < size of data ; i ++ ) { if ( serialized representation . get ( i ) != byte data . get ( position ++ ) ) { return bool ; } } return bool ; }	Compare the byte sequence contained in the supplied ByteDataBuffer with thesequence contained in the map pointed to by the specified key, byte by byte.
private void grow key array ( ) { int new size = pointers and ordinals . length ( ) << num ; if ( new size < num ) { throw new illegal state exception ( str + str + str + pointers and ordinals . length ( ) + str + new size ) ; } grow key array ( new size ) ; }	Grow the key array.
private int rehash previously added data ( long key ) { long position = key & pointer mask ; int size of data = var int . read v ( byte data . get underlying array ( ) , position ) ; position += var int . size of v ( size of data ) ; return hash codes . hash code ( byte data . get underlying array ( ) , position , size of data ) ; }	Get the hash code for the byte array pointed to by the specified key.
private atomic long array empty key array ( int size ) { atomic long array arr = new atomic long array ( size ) ;	Create an AtomicLongArray of the specified size, each value in the array will be EMPTY_BUCKET_VALUE.
public boolean is match equal ( int match idx , hollow indexer value traverser other traverser , int other match idx ) { for ( int i = num ; i < get num field paths ( ) ; i ++ ) { if ( ! hollow read field utils . fields are equal ( ( hollow object type data access ) field type data access [ i ] , field match lists [ i ] . get ( match idx ) , field schema position [ i ] , ( hollow object type data access ) other traverser . field type data access [ i ] , other traverser . field match lists [ i ] . get ( other match idx ) , other traverser . field schema position [ i ] ) ) return bool ; } return bool ; }	This method assumes the other traverser has the same match fields specified in the same order.
public t find match ( q key ) { object [ ] key array = match fields . stream ( ) . map ( mf -> mf . extract ( key ) ) . to array ( ) ; int ordinal = hpki . get matching ordinal ( key array ) ; if ( ordinal == - num ) { return null ; } return unique type extractor . extract ( api , ordinal ) ; }	Finds the unique object, an instance of the unique type, for a given key.
read state helper swap ( ) { return new read state helper ( new read state ( current . get version ( ) , pending . get state engine ( ) ) , new read state ( pending . get version ( ) , current . get state engine ( ) ) ) ; }	Swap underlying state engines between current and pending while keeping the versions consistent;used after delta integrity checks have altered the underlying state engines.
public static int hash table size ( int num elements ) throws illegal argument exception { if ( num elements < num ) { throw new illegal argument exception ( str + num elements ) ; } else if ( num elements > hash table max size ) { throw new illegal argument exception ( str + num elements ) ; } if ( num elements == num ) return num ; if ( num elements < num ) return num elements * num ;	Determine size of hash table capable of storing the specified number of elements with a loadfactor applied.
public long run compaction cycle ( hollow compactor . compaction config config ) { if ( config != null && read states . has current ( ) ) { final hollow compactor compactor = new hollow compactor ( get write engine ( ) , read states . current ( ) . get state engine ( ) , config ) ; if ( compactor . needs compaction ( ) ) { return run cycle ( new state -> compactor . compact ( ) ) ; } } return no announcement available ; }	Run a compaction cycle, will produce a data state with exactly the same data as currently, butreorganized so that ordinal holes are filled.
public void write snapshot ( output stream os ) throws io { state engine . prepare for write ( ) ; data output stream dos = new data output stream ( os ) ; write header ( dos , state engine . get schemas ( ) , bool ) ; var int . write v ( dos , state engine . get ordered type states ( ) . size ( ) ) ; simultaneous executor executor = new simultaneous executor ( get class ( ) , str ) ; for ( final hollow type write state type state : state engine . get ordered type states ( ) ) { executor . execute ( new runnable ( ) { public void run ( ) { type state . calculate snapshot ( ) ; } } ) ; } try { executor . await successful completion ( ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } for ( hollow type write state type state : state engine . get ordered type states ( ) ) { hollow schema schema = type state . get schema ( ) ; schema . write to ( dos ) ; write num shards ( dos , type state . get num shards ( ) ) ; type state . write snapshot ( dos ) ; } os . flush ( ) ; }	Write the current state as a snapshot blob.
public void write delta ( output stream os ) throws io { state engine . prepare for write ( ) ; if ( state engine . is restored ( ) ) state engine . ensure all necessary states restored ( ) ; list < hollow schema > changed types = changed types ( ) ; data output stream dos = new data output stream ( os ) ; write header ( dos , changed types , bool ) ; var int . write v ( dos , changed types . size ( ) ) ; simultaneous executor executor = new simultaneous executor ( get class ( ) , str ) ; for ( final hollow type write state type state : state engine . get ordered type states ( ) ) { executor . execute ( new runnable ( ) { public void run ( ) { if ( type state . has changed since last cycle ( ) ) type state . calculate delta ( ) ; } } ) ; } try { executor . await successful completion ( ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } for ( hollow type write state type state : state engine . get ordered type states ( ) ) { if ( type state . has changed since last cycle ( ) ) { hollow schema schema = type state . get schema ( ) ; schema . write to ( dos ) ; write num shards ( dos , type state . get num shards ( ) ) ; type state . write delta ( dos ) ; } } os . flush ( ) ; }	Serialize the changes necessary to transition a consumer from the previous stateto the current state as a delta blob.
private void add to set if not primitive or collection ( set < string > schema name set , string ... schema names ) { for ( string schema name : schema names ) {	Adds the schema name to the set if the schema name doesn't correspond to a Hollowprimitive type.
public static string normalize field path to param name ( string field path ) { string result = null ; if ( field path . contains ( str ) ) { string [ ] parts = field path . split ( str ) ; string builder sb = new string builder ( ) ; sb . append ( lowercase ( parts [ num ] ) ) ; for ( int i = num ; i < parts . length ; i ++ ) { sb . append ( uppercase ( parts [ i ] ) ) ; } result = sb . to string ( ) ; } else { result = lowercase ( field path ) ; } if ( result . ends with ( str ) ) { return result . substring ( num , result . length ( ) - num ) ; } return result ; }	Convert field path into Param nameEg:- Actor {.
private void reindex hash index ( ) { hollow hash index builder builder = new hollow hash index builder ( state engine , type , select field , match fields ) ; builder . build index ( ) ; this . hash state volatile = new hollow hash index state ( builder ) ; }	Recreate the hash index entirely.
public hollow hash index result find matches ( object ... query ) { int hash code = num ; for ( int i = num ; i < query . length ; i ++ ) { if ( query [ i ] == null ) throw new illegal argument exception ( str + i ) ; hash code ^= hash codes . hash int ( key hash code ( query [ i ] , i ) ) ; } hollow hash index result result ; hollow hash index state hash state ; do { result = null ; hash state = hash state volatile ; long bucket = hash code & hash state . get match hash mask ( ) ; long hash bucket bit = bucket * hash state . get bits per match hash entry ( ) ; boolean bucket is empty = hash state . get match hash table ( ) . get element value ( hash bucket bit , hash state . get bits per traverser field ( ) [ num ] ) == num ; while ( ! bucket is empty ) { if ( match is equal ( hash state . get match hash table ( ) , hash bucket bit , query ) ) { int select size = ( int ) hash state . get match hash table ( ) . get element value ( hash bucket bit + hash state . get bits per match hash key ( ) , hash state . get bits per select table size ( ) ) ; long select bucket pointer = hash state . get match hash table ( ) . get element value ( hash bucket bit + hash state . get bits per match hash key ( ) + hash state . get bits per select table size ( ) , hash state . get bits per select table pointer ( ) ) ; result = new hollow hash index result ( hash state , select bucket pointer , select size ) ; break ; } bucket = ( bucket + num ) & hash state . get match hash mask ( ) ; hash bucket bit = bucket * hash state . get bits per match hash entry ( ) ; bucket is empty = hash state . get match hash table ( ) . get element value ( hash bucket bit , hash state . get bits per traverser field ( ) [ num ] ) == num ; } } while ( hash state != hash state volatile ) ; return result ; }	Query the index.
public void trigger async refresh with random delay ( int max delay millis ) { random rand = new random ( ) ; int delay millis = max delay millis > num ? rand . next int ( max delay millis ) : num ; trigger async refresh with delay ( delay millis ) ; }	Triggers async refresh after some random number of milliseconds have passed,between now and the specified maximum number of milliseconds.Any subsequent calls for async refresh will not begin until after the specified delayhas completed.
public void trigger async refresh with delay ( int delay millis ) { final hollow client client = this . client ; final long target begin time = system . current time millis ( ) + delay millis ; refresh executor . execute ( new runnable ( ) { public void run ( ) { try { long delay = target begin time - system . current time millis ( ) ; if ( delay > num ) thread . sleep ( delay ) ; client . trigger refresh ( ) ; } catch ( throwable th ) { log . log ( level . severe , str , th ) ; } } } ) ; }	Triggers async refresh after the specified number of milliseconds has passed.Any subsequent calls for async refresh will not begin until after the specified delayhas completed.
public hollow type diff add type diff ( string type , string ... primary key paths ) { hollow type diff type diff = new hollow type diff ( this , type , primary key paths ) ; if ( type diff . has any data ( ) ) type diffs . put ( type , type diff ) ; return type diff ; }	Add a type to be included in the diff report.
public static void write v ( output stream out , int value ) throws io { if ( value > num || value < num ) out . write ( ( byte ) ( num | ( ( value > > > num ) ) ) ) ; if ( value > num || value < num ) out . write ( ( byte ) ( num | ( ( value > > > num ) & num ) ) ) ; if ( value > num || value < num ) out . write ( ( byte ) ( num | ( ( value > > > num ) & num ) ) ) ; if ( value > num || value < num ) out . write ( ( byte ) ( num | ( ( value > > > num ) & num ) ) ) ; out . write ( ( byte ) ( value & num ) ) ; }	Encode the specified int as a variable length integer into the supplied OutputStream.
public static int write v ( byte data [ ] , int pos , int value ) { if ( value > num || value < num ) data [ pos ++ ] = ( ( byte ) ( num | ( ( value > > > num ) ) ) ) ; if ( value > num || value < num ) data [ pos ++ ] = ( ( byte ) ( num | ( ( value > > > num ) & num ) ) ) ; if ( value > num || value < num ) data [ pos ++ ] = ( ( byte ) ( num | ( ( value > > > num ) & num ) ) ) ; if ( value > num || value < num ) data [ pos ++ ] = ( ( byte ) ( num | ( ( value > > > num ) & num ) ) ) ; data [ pos ++ ] = ( byte ) ( value & num ) ; return pos ; }	Write the value as a VarInt into the array, starting at the specified position.
public static int read v ( input stream in ) throws io { byte b = ( byte ) in . read ( ) ; if ( b == ( byte ) num ) throw new runtime exception ( str ) ; int value = b & num ; while ( ( b & num ) != num ) { b = ( byte ) in . read ( ) ; value <<= num ; value |= ( b & num ) ; } return value ; }	Read a variable length integer from the supplied InputStream.
public static long read v ( input stream in ) throws io { byte b = ( byte ) in . read ( ) ; if ( b == ( byte ) num ) throw new runtime exception ( str ) ; long value = b & num ; while ( ( b & num ) != num ) { b = ( byte ) in . read ( ) ; value <<= num ; value |= ( b & num ) ; } return value ; }	Read a variable length long from the supplied InputStream.
protected final void add view internal ( view child , int index , view group . layout params params ) { super . add view ( child , index , params ) ; }	Used internally for adding view. Need because we override addView topass-through to the Refreshable View.
protected final void refresh loading views size ( ) { final int maximum pull scroll = ( int ) ( get maximum pull scroll ( ) * num ) ; int p left = get padding left ( ) ; int p top = get padding top ( ) ; int p right = get padding right ( ) ; int p bottom = get padding bottom ( ) ; switch ( get pull to refresh scroll direction ( ) ) { case horizontal : if ( m mode . show header loading layout ( ) ) { m header layout . set width ( maximum pull scroll ) ; p left = - maximum pull scroll ; } else { p left = num ; } if ( m mode . show footer loading layout ( ) ) { m footer layout . set width ( maximum pull scroll ) ; p right = - maximum pull scroll ; } else { p right = num ; } break ; case vertical : if ( m mode . show header loading layout ( ) ) { m header layout . set height ( maximum pull scroll ) ; p top = - maximum pull scroll ; } else { p top = num ; } if ( m mode . show footer loading layout ( ) ) { m footer layout . set height ( maximum pull scroll ) ; p bottom = - maximum pull scroll ; } else { p bottom = num ; } break ; } if ( debug ) { log . d ( log tag , string . format ( str , p left , p top , p right , p bottom ) ) ; } set padding ( p left , p top , p right , p bottom ) ; }	Re-measure the Loading Views height, and adjust internal padding asnecessary.
protected void update ui ( ) {	Updates the View State when the mode has been set.
private void pull event ( ) { final int new scroll value ; final int item dimension ; final float initial motion value , last motion value ; switch ( get pull to refresh scroll direction ( ) ) { case horizontal : initial motion value = m initial motion x ; last motion value = m last motion x ; break ; case vertical : default : initial motion value = m initial motion y ; last motion value = m last motion y ; break ; } switch ( m current mode ) { case pull from end : new scroll value = math . round ( math . max ( initial motion value - last motion value , num ) / friction ) ; item dimension = get footer size ( ) ; break ; case pull from start : default : new scroll value = math . round ( math . min ( initial motion value - last motion value , num ) / friction ) ; item dimension = get header size ( ) ; break ; } set header scroll ( new scroll value ) ; if ( new scroll value != num && ! is refreshing ( ) ) { float scale = math . abs ( new scroll value ) / ( float ) item dimension ; switch ( m current mode ) { case pull from end : m footer layout . on pull ( scale ) ; break ; case pull from start : default : m header layout . on pull ( scale ) ; break ; } if ( m state != state . pull to refresh && item dimension >= math . abs ( new scroll value ) ) { set state ( state . pull to refresh ) ; } else if ( m state == state . pull to refresh && item dimension < math . abs ( new scroll value ) ) { set state ( state . release to refresh ) ; } } }	Actions a Pull Event.
given rule builder < t , u > given ( string name , t value ) { return given ( new fact < t > ( name , value ) ) ; }	Adds a fact to the Rule.
@ safe varargs public final given rule builder < t , u > given ( name value referable ... facts ) { rule . add facts ( facts ) ; return this ; }	Adds one or more facts into the Rule.
public static rule builder < object , object > create ( class < ? extends rule > rule class , rule chain action type action type ) { return new rule builder < > ( rule class , action type ) ; }	Returns a new RuleBuilder for the specified Rule class.
public static rule builder < object , object > create ( ) { rule builder < object , object > rule = new rule builder < > ( golden rule . class ) ; rule . fact type = object . class ; return rule ; }	Returns a new RuleBuilder for the default Rule type.
public < s > rule builder < s , u > with fact type ( class < s > fact type ) { rule builder < s , u > builder = new rule builder < > ( rule class ) ; builder . fact type = fact type ; builder . result type = result type ; builder . action type = action type ; return builder ; }	Specifies the fact type for the Rule being built.
public < s > rule builder < t , s > with result type ( class < s > result type ) { rule builder < t , s > builder = new rule builder < > ( rule class ) ; builder . fact type = fact type ; builder . result type = result type ; builder . action type = action type ; builder . name = name ; return builder ; }	Specifies the Result type for the Rule being built.
@ suppress warnings ( str ) public given rule builder < t , u > given ( string name , t value ) { rule < t , u > rule = name . map ( rule name -> ( rule < t , u > ) new auditable rule < t , u > ( new rule ( ) , rule name ) ) . or else ( new rule ( ) ) ; if ( rule == null ) { throw new illegal state exception ( str ) ; } return new given rule builder < t , u > ( rule , new fact < t > ( name , value ) ) ; }	Adds a fact to the Rule using a name value pair to specify a new fact.
@ suppress warnings ( str ) @ safe varargs public final given rule builder < t , u > given ( name value referable ... facts ) { rule < t , u > rule = name . map ( name -> ( rule < t , u > ) new auditable rule < t , u > ( new rule ( ) , name ) ) . or else ( new rule ( ) ) ; if ( rule == null ) { throw new illegal state exception ( str ) ; } return new given rule builder < t , u > ( rule , facts ) ; }	Adds one or more facts to the Rule.
@ suppress warnings ( str ) public then rule builder < t , u > then ( consumer < name value referable type convertible map < t > > action ) { rule < t , u > rule = name . map ( name -> ( rule < t , u > ) new auditable rule < t , u > ( new rule ( ) , name ) ) . or else ( new rule ( ) ) ; if ( rule == null ) { throw new illegal state exception ( str ) ; } return new then rule builder < t , u > ( rule , action ) ; }	Adds an action as a Consumer to the Rule.
protected object get rule instance ( class < ? > rule ) { try { return rule . new instance ( ) ; } catch ( instantiation exception | illegal access exception ex ) { logger . warn ( str + rule + str , ex ) ; } return null ; }	Returns a rule instance For container aware contexts (like Spring, Guice, Weld, etc.) override this method and instantiate the rulevia the container.
public static optional < field > get annotated field ( class annotation , class clazz ) { list < field > fields = get annotated fields ( annotation , clazz ) ; return optional . of nullable ( fields . size ( ) > num ? fields . get ( num ) : null ) ; }	Method getAnnotatedField gets the first annotated field of the type of annotation specified.
public static optional < method > get annotated method ( class annotation , class clazz ) { list < method > methods = get annotated methods ( annotation , clazz ) ; return optional . of nullable ( methods . size ( ) > num ? methods . get ( num ) : null ) ; }	Method getAnnotatedMethod the first annotated method of the type of annotation specified.
@ suppress warnings ( str ) public static < a extends annotation > a get annotation ( class < a > annotation , class < ? > clazz ) { return optional . of nullable ( clazz . get annotation ( annotation ) ) . or else ( ( a ) arrays . stream ( clazz . get declared annotations ( ) ) . flat map ( anno -> arrays . stream ( anno . get class ( ) . get interfaces ( ) ) . flat map ( iface -> arrays . stream ( iface . get declared annotations ( ) ) ) ) . filter ( annotation :: is instance ) . find first ( ) . or else ( null ) ) ; }	Method getAnnotation returns the annotation on a class or its parent annotation.
public void register rule ( auditable rule ) { lock . write lock ( ) . lock ( ) ; try { audit map . put ( rule . get name ( ) , new hash map < > ( ) ) ; } finally { lock . write lock ( ) . unlock ( ) ; } }	Registers a rule to be audited.
public void update rule status ( auditable rule , rule status status ) { lock . read lock ( ) . lock ( ) ; try { if ( audit map . contains key ( rule . get name ( ) ) ) { lock . read lock ( ) . unlock ( ) ; lock . write lock ( ) . lock ( ) ; try { audit map . get ( rule . get name ( ) ) . put ( thread . current thread ( ) . get id ( ) , status ) ; lock . read lock ( ) . lock ( ) ; } finally { lock . write lock ( ) . unlock ( ) ; } } } finally { lock . read lock ( ) . unlock ( ) ; } }	Updates the status of the rule & stores the status with the Auditor.
public map < string , rule status > get rule status map ( ) { lock . read lock ( ) . lock ( ) ; try { return audit map . key set ( ) . stream ( ) . collect ( collectors . to map ( key -> key , key -> audit map . get ( key ) . get or default ( thread . current thread ( ) . get id ( ) , rule status . pending ) ) ) ; } finally { lock . read lock ( ) . unlock ( ) ; } }	Gets a map of each rule name with its associated status.
public < u > rule book with result type builder < u > with result type ( class < u > result type ) { result type = result type ; return new rule book with result type builder < u > ( ( new rule book builder < u > ( this ) ) . new rule book ( ) ) ; }	Specifies the Result type for the RuleBook.
public then rule builder < t , u > then ( consumer < name value referable type convertible map < t > > action ) { rule . add action ( action ) ; return this ; }	Adds a then action into the Rule.
public then rule builder < t , u > then ( bi consumer < name value referable type convertible map < t > , result < u > > action ) { rule . add action ( action ) ; return this ; }	Addds a then action into the Rule.
public void reset ( ) { lock . read lock ( ) . lock ( ) ; try { if ( default value == null ) { return ; } } finally { lock . read lock ( ) . unlock ( ) ; } set value ( default value ) ; }	Resets the value of the Result to its default value.
@ suppress warnings ( str ) public < t > rule book rule with fact type builder < t , u > with fact type ( class < t > fact type ) { rule < t , u > rule = ( rule < t , u > ) rule builder . create ( rule class ) . with fact type ( fact type ) . build ( ) ; rule book . add rule ( rule ) ; return new rule book rule with fact type builder < > ( rule ) ; }	Specifies the fact type.
protected list < class < ? > > get pojo rules ( ) { reflections reflections = new reflections ( package ) ; list < class < ? > > rules = reflections . get types annotated with ( com . deliveredtechnologies . rulebook . annotation . rule . class ) . stream ( ) . filter ( rule -> rule . get annotated superclass ( ) != null )	Gets the POJO Rules to be used by the RuleBook via reflection of the specified package.
private string read empty line or end table ( final buffered reader table content ) throws io { final string column = table content . read line ( ) ; if ( column != null && column . starts with ( end table ) ) { return end table ; } if ( column == null || ! column . is empty ( ) ) { throw new illegal argument exception ( string . format ( str , column ) ) ; } return str ; }	Reads empty line or throw an exception if a none empty line was found.
private service [ ] to array ( list < service > services ) { if ( services == null ) { return new service [ num ] ; } if ( services instanceof array list ) { return ( ( array list < service > ) services ) . to array ( new service [ services . size ( ) ] ) ; } else { service [ ] ret = new service [ services . size ( ) ] ; for ( int i = num ; i < services . size ( ) ; i ++ ) { ret [ i ] = services . get ( i ) ; } return ret ; } }	convert list to array, never returns null.
private list < string > get ports from build configuration ( image configuration image ) {	Examine images for build configuration and extract all ports.
private list < service port > extract ports from config ( ) { list < service port > ret = new linked list < > ( ) ; string ports = get config ( config . port ) ; if ( ports != null ) { for ( string port : string utils . split ( ports , str ) ) { ret . add ( parse port mapping ( port ) ) ; } } return ret ; }	Config can override ports.
private service port parse port mapping ( string port ) { matcher matcher = port mapping pattern . matcher ( port ) ; if ( ! matcher . matches ( ) ) { log . error ( str , port ) ; throw new illegal argument exception ( str + port ) ; } int service port = integer . parse int ( matcher . group ( str ) ) ; string optional target port = matcher . group ( str ) ; string protocol = get protocol ( matcher . group ( str ) ) ; service port builder builder = new service port builder ( ) . with port ( service port ) . with protocol ( protocol ) . with name ( get default port name ( service port , protocol ) ) ;	parse config specified ports.
private void add port if not null ( list < service port > ret , service port port ) { if ( port != null ) { ret . add ( port ) ; } }	null ports can happen for ignored mappings.
private service port shift or null ( list < service port > ports ) { if ( ! ports . is empty ( ) ) { return ports . remove ( num ) ; } return null ; }	remove first element of list or null if list is empty.
private void add missing service parts ( service builder service , service default service ) {	Merge services of same name with the default service.
public void append image stream resource ( image name image name , file target ) throws mojo execution exception { string tag = string utils . is blank ( image name . get tag ( ) ) ? str : image name . get tag ( ) ; try { image stream is = new image stream builder ( ) . with new metadata ( ) . with name ( image name . get simple name ( ) ) . end metadata ( ) . with new spec ( ) . add new tag ( ) . with name ( tag ) . with new from ( ) . with kind ( str ) . end from ( ) . end tag ( ) . end spec ( ) . build ( ) ; create or update image stream tag ( client , image name , is ) ; append image stream to file ( is , target ) ; log . info ( str , image name . get simple name ( ) , target ) ; } catch ( kubernetes client exception e ) { kubernetes resource util . handle kubernetes client exception ( e , this . log ) ; } catch ( io e ) { throw new mojo execution exception ( string . format ( str , image name . get full name ( ) , target . get absolute file ( ) , e . get message ( ) ) , e ) ; } }	Save the images stream to a file.
private static boolean ports match ( service port service port , int or string int or string ) { if ( int or string != null ) { integer port = service port . get port ( ) ; integer int val = int or string . get int val ( ) ; string str val = int or string . get str val ( ) ; if ( int val != null ) { if ( port != null ) { return port . int value ( ) == int val . int value ( ) ; } else {	Returns true if the given servicePort matches the intOrString value.
private static string service to port or blank ( string service name ) { string env var name = to service port environment variable ( service name ) ; return get env var or system property ( env var name , str ) ; }	Returns the named port for the given service name or blank.
private static string get service host and port ( string service name , string default host , string default port ) { string service env var prefix = get service env var prefix ( service name ) ; string host env var = service env var prefix + str ; string port env var = service env var prefix + str ; string host = get env var or system property ( host env var , host env var , default host ) ; string port = get env var or system property ( port env var , port env var , default port ) ; string answer = host + str + port ; return answer ; }	Returns the service host and port for the given environment variable name.
public static void put if absent ( map < string , string > map , string name , string value ) { if ( ! map . contains key ( name ) ) { map . put ( name , value ) ; } }	Adds the given key and value pair into the map if the map does not already contain a value for that key.
public static void merge if absent ( map < string , string > map , map < string , string > to merge ) { for ( map . entry < string , string > entry : to merge . entry set ( ) ) { put if absent ( map , entry . get key ( ) , entry . get value ( ) ) ; ; } }	Add all values of a map to another map, but onlfy if not already existing.
public static < k , v > map < k , v > merge maps ( map < k , v > map1 , map < k , v > map2 ) { map < k , v > answer = new hash map < > ( ) ; if ( map2 != null ) { answer . put all ( map2 ) ; } if ( map1 != null ) { answer . put all ( map1 ) ; } return answer ; }	Returns a new map with all the entries of map1 and any from map2 which don't override map1.Can handle either maps being null.
public static void put all if not null ( map < string , string > ret , map < string , string > to put ) { if ( to put != null ) { ret . put all ( to put ) ; } }	Copies all of the elements i.e., the mappings, from toPut map into ret, if toPut isn't null.
private void wait until pod is ready ( string pod name , int n await timeout , final logger log ) throws interrupted exception { final count down latch ready latch = new count down latch ( num ) ; try ( watch watch = client . pods ( ) . with name ( pod name ) . watch ( new watcher < pod > ( ) { @ override public void event received ( action action , pod a pod ) { if ( kubernetes helper . is pod ready ( a pod ) ) { ready latch . count down ( ) ; } } @ override public void on close ( kubernetes client exception e ) {	A Simple utility function to watch over pod until it gets ready.
public static string validate kubernetes id ( string current value , string description ) throws illegal argument exception { if ( string utils . is blank ( current value ) ) { throw new illegal argument exception ( str + description + str ) ; } int size = current value . length ( ) ; for ( int i = num ; i < size ; i ++ ) { char ch = current value . char at ( i ) ; if ( character . is upper case ( ch ) ) { throw new illegal argument exception ( str + ch + str + i + str + description + str + current value ) ; } } return current value ; }	Validates that the given value is valid according to the kubernetes ID parsing rules, throwing an exception if not.
@ suppress warnings ( str ) public static list < has metadata > to item list ( object entity ) throws io { if ( entity instanceof list ) { return ( list < has metadata > ) entity ; } else if ( entity instanceof has metadata [ ] ) { has metadata [ ] array = ( has metadata [ ] ) entity ; return arrays . as list ( array ) ; } else if ( entity instanceof kubernetes list ) { kubernetes list config = ( kubernetes list ) entity ; return config . get items ( ) ; } else if ( entity instanceof template ) { template objects = ( template ) entity ; return objects . get objects ( ) ; } else { list < has metadata > answer = new array list < > ( ) ; if ( entity instanceof has metadata ) { answer . add ( ( has metadata ) entity ) ; } return answer ; } }	Loads the Kubernetes JSON and converts it to a list of entities.
public static string get resource version ( has metadata entity ) { if ( entity != null ) { object meta metadata = entity . get metadata ( ) ; if ( metadata != null ) { string resource version = metadata . get resource version ( ) ; if ( string utils . is not blank ( resource version ) ) { return resource version ; } } } return null ; }	Returns the resource version for the entity or null if it does not have one.
public static boolean is pod ready ( pod pod ) { if ( ! is pod running ( pod ) ) { return bool ; } pod status pod status = pod . get status ( ) ; if ( pod status == null ) { return bool ; } list < pod condition > conditions = pod status . get conditions ( ) ; if ( conditions == null || conditions . is empty ( ) ) { return bool ; }	Returns true if the pod is running and ready.
private static context get current context ( config config ) { string context name = config . get current context ( ) ; if ( context name != null ) { list < named context > contexts = config . get contexts ( ) ; if ( contexts != null ) { for ( named context context : contexts ) { if ( objects . equals ( context name , context . get name ( ) ) ) { return context . get context ( ) ; } } } } return null ; }	Returns the current context in the given config.
private boolean has route ( final kubernetes list builder list builder , final string name ) { final atomic boolean answer = new atomic boolean ( bool ) ; list builder . accept ( new typed visitor < route builder > ( ) { @ override public void visit ( route builder builder ) { object meta metadata = builder . get metadata ( ) ; if ( metadata != null && name . equals ( metadata . get name ( ) ) ) { answer . set ( bool ) ; } } } ) ; return answer . get ( ) ; }	Returns true if we already have a route created for the given name.
public static boolean has resource ( maven project project , string ... paths ) { url compile class loader = get compile class loader ( project ) ; for ( string path : paths ) { try { if ( compile class loader . get resource ( path ) != null ) { return bool ; } } catch ( throwable e ) {	Returns true if any of the given resources could be found on the given class loader.
private static map < string , object > read and enrich fragment ( platform mode platform mode , resource versioning api versions , file file , string app name ) throws io { pattern pattern = pattern . compile ( filename pattern , pattern . case insensitive ) ; matcher matcher = pattern . matcher ( file . get name ( ) ) ; if ( ! matcher . matches ( ) ) { throw new illegal argument exception ( string . format ( str , file . get name ( ) ) ) ; } string name = matcher . group ( str ) ; string type = matcher . group ( str ) ; string ext = matcher . group ( str ) . to lower case ( ) ; string kind ; map < string , object > fragment = read fragment ( file , ext ) ; if ( type != null ) { kind = get and validate kind from type ( file , type ) ; } else {	Read fragment and add default values.
public static list < env var > convert to env var list ( map < string , string > env vars ) { list < env var > env list = new linked list < > ( ) ; for ( map . entry < string , string > entry : env vars . entry set ( ) ) { string name = entry . get key ( ) ; string value = entry . get value ( ) ; if ( name != null ) { env var env = new env var builder ( ) . with name ( name ) . with value ( value ) . build ( ) ; env list . add ( env ) ; } } return env list ; }	Convert a map of env vars to a list of K8s EnvVar objects.
public static has metadata merge resources ( has metadata item1 , has metadata item2 , logger log , boolean switch on local customisation ) { if ( item1 instanceof deployment && item2 instanceof deployment ) { return merge deployments ( ( deployment ) item1 , ( deployment ) item2 , log , switch on local customisation ) ; } if ( item1 instanceof config map && item2 instanceof config map ) { config map cm1 = ( config map ) item1 ; config map cm2 = ( config map ) item2 ; return merge config maps ( cm1 , cm2 , log , switch on local customisation ) ; } merge metadata ( item1 , item2 ) ; return item1 ; }	Merges the given resources together into a single resource.If switchOnLocalCustomisation is false then the overrides from item2 are merged into item1.
private static map < string , string > merge maps and remove empty strings ( map < string , string > override map , map < string , string > original map ) { map < string , string > answer = map util . merge maps ( override map , original map ) ; set < map . entry < string , string > > entries = override map . entry set ( ) ; for ( map . entry < string , string > entry : entries ) { string value = entry . get value ( ) ; if ( value == null || value . is empty ( ) ) { string key = entry . get key ( ) ; answer . remove ( key ) ; } } return answer ; }	Returns a merge of the given maps and then removes any resulting empty string values (which is the way to remove, say, a label or annotationwhen overriding.
private static boolean is local customisation ( pod spec pod spec ) { list < container > containers = pod spec . get containers ( ) != null ? pod spec . get containers ( ) : collections . < container > empty list ( ) ; for ( container container : containers ) { if ( string utils . is not blank ( container . get image ( ) ) ) { return bool ; } } return bool ; }	we could also use an annotation?.
private map < string , string > read config ( file f ) throws io { map < string , string > map ; if ( f . get name ( ) . ends with ( json extension ) ) { map = flatten ( json mapper . read value ( f , map . class ) ) ; } else if ( f . get name ( ) . ends with ( yaml extension ) || f . get name ( ) . ends with ( yml extension ) ) { map = flatten ( yaml mapper . read value ( f , map . class ) ) ; } else if ( f . get name ( ) . ends with ( properties extension ) ) { properties properties = new properties ( ) ; properties . load ( new file input stream ( f ) ) ; map = properties to map ( properties ) ; } else { throw new illegal argument exception ( str + f . get name ( ) + str ) ; } return map ; }	Reads the configuration from the file.
private void add port if valid ( map < string , integer > map , string key , string port ) { if ( string utils . is not blank ( port ) ) { string t = port . trim ( ) ; if ( t . matches ( number regex ) ) { map . put ( key , integer . parse int ( t ) ) ; } } }	Adds a port to the list.
public string get docker json config string ( final settings settings , final string server id ) { server server = get server ( settings , server id ) ; if ( server == null ) { return str ; } json object auth = new json object ( ) ; auth . add ( str , new json primitive ( server . get username ( ) ) ) ; auth . add ( str , new json primitive ( server . get password ( ) ) ) ; string mail = get configuration value ( server , str ) ; if ( ! string utils . is blank ( mail ) ) { auth . add ( str , new json primitive ( mail ) ) ; } json object json = new json object ( ) ; json . add ( server id , auth ) ; return json . to string ( ) ; }	Method used in MOJO.
public optional < map < string , object > > get plugin configuration ( string system , string id ) { return plugin config lookup . apply ( system , id ) ; }	Gets plugin configuration values.
public optional < map < string , object > > get secret configuration ( string id ) { return secret config lookup . apply ( id ) ; }	Gets configuration values. Since there can be inner values,it returns a Map of Objects where an Object can be asimple type, List or another Map.
public static void download ( logger log , url download url , file target ) throws mojo execution exception { log . progress start ( ) ; try { ok http client client = new ok http client . builder ( ) . read timeout ( num , time unit . minutes ) . build ( ) ; request request = new request . builder ( ) . url ( download url ) . build ( ) ; response response = client . new call ( request ) . execute ( ) ; try ( output stream out = new file output stream ( target ) ; input stream im = response . body ( ) . byte stream ( ) ) { long length = response . body ( ) . content length ( ) ; input stream in = response . body ( ) . byte stream ( ) ; byte [ ] buffer = new byte [ num ] ; long read bytes = num ; while ( bool ) { int len = in . read ( buffer ) ; read bytes += len ; log . progress update ( target . get name ( ) , str , get progress bar ( read bytes , length ) ) ; if ( len <= num ) { out . flush ( ) ; break ; } out . write ( buffer , num , len ) ; } } } catch ( io e ) { throw new mojo execution exception ( str + download url + str + target + str + e , e ) ; } finally { log . progress finished ( ) ; } }	Download with showing the progress a given URL and store it in a file.
public static int compare versions ( string v1 , string v2 ) { string [ ] components1 = split ( v1 ) ; string [ ] components2 = split ( v2 ) ; int diff ; int length = math . min ( components1 . length , components2 . length ) ; for ( int i = num ; i < length ; i ++ ) { string s1 = components1 [ i ] ; string s2 = components2 [ i ] ; integer i1 = try parse integer ( s1 ) ; integer i2 = try parse integer ( s2 ) ; if ( i1 != null && i2 != null ) { diff = i1 . compare to ( i2 ) ; } else {	Compares two version strings such that "1.10.1" > "1.4" etc.
public static processor config blend profile with configuration ( processor configuration extractor config extractor , string profile , file resource dir , processor config config ) throws io {	Find an enricher or generator config, possibly via a profile and merge it with a given configuration.
public static profile lookup ( string name , file directory ) throws io {	Lookup profiles from a given directory and merge it with a profile of thesame name found in the classpath.
private static list < profile > read profile from classpath ( string name ) throws io { list < profile > ret = new array list < > ( ) ; ret . add all ( read all from classpath ( name , str ) ) ; ret . add all ( read all from classpath ( name , str ) ) ; return ret ; }	Read all default profiles first, then merge in custom profiles found on the classpath.
public static list < profile > read all from classpath ( string name , string ext ) throws io { list < profile > ret = new array list < > ( ) ; for ( string location : get meta inf profile paths ( ext ) ) { for ( string url : class util . get resources ( location ) ) { for ( profile profile : from yaml ( new url ( url ) . open stream ( ) ) ) { if ( name . equals ( profile . get name ( ) ) ) { ret . add ( profile ) ; } } } } return ret ; }	Read all profiles found in the classpath.
private static file find profile yaml ( file directory ) { for ( string profile file : profile filenames ) { file ret = new file ( directory , string . format ( profile file , str ) ) ; if ( ret . exists ( ) ) { return ret ; } } return null ; }	check for various variations of profile files.
private static list < string > get meta inf profile paths ( string ext ) { list < string > ret = new array list < > ( profile filenames . length ) ; for ( string p : profile filenames ) { ret . add ( str + get profile file name ( p , ext ) ) ; } return ret ; }	prepend meta-inf location.
public static list < profile > from yaml ( input stream is ) throws io { type reference < list < profile > > type ref = new type reference < list < profile > > ( ) { } ; return mapper . read value ( is , type ref ) ; }	Load a profile from an input stream. This must be in YAML format.
private string get image pull policy ( resource config resource config , string default value ) { if ( resource config != null ) { return resource config . get image pull policy ( ) != null ? resource config . get image pull policy ( ) : default value ; } return default value ; }	This method overrides the ImagePullPolicy value by the value provided inXML config.
protected boolean is open shift mode ( ) { properties properties = get context ( ) . get configuration ( ) . get properties ( ) ; if ( properties != null ) { return runtime mode . is open shift mode ( properties ) ; } return bool ; }	Returns true if we are in OpenShift S2I binary building mode.
protected int get replica count ( kubernetes list builder builder , resource config xml resource config , int default value ) { if ( xml resource config != null ) { list < has metadata > items = builder . build items ( ) ; for ( has metadata item : items ) { if ( item instanceof deployment ) { if ( ( ( deployment ) item ) . get spec ( ) . get replicas ( ) != null ) { return ( ( deployment ) item ) . get spec ( ) . get replicas ( ) ; } } if ( item instanceof deployment config ) { if ( ( ( deployment config ) item ) . get spec ( ) . get replicas ( ) != null ) { return ( ( deployment config ) item ) . get spec ( ) . get replicas ( ) ; } } } return xml resource config . get replicas ( ) > num ? xml resource config . get replicas ( ) : default value ; } return default value ; }	This method just makes sure that the replica count provided in XML configoverrides the default option; and resource fragments are always giventopmost priority.
public static element first child ( element element , string name ) { node list nodes = element . get child nodes ( ) ; if ( nodes != null ) { for ( int i = num , size = nodes . get length ( ) ; i < size ; i ++ ) { node item = nodes . item ( i ) ; if ( item instanceof element ) { element child element = ( element ) item ; if ( name . equals ( child element . get tag name ( ) ) ) { return child element ; } } } } return null ; }	Returns the first child element for the given name.
public void install template ( template entity , string source name ) { open shift client open shift client = get open shift client ( ) ; if ( open shift client == null ) {	Installs the template into the namespace without processing it.
private int remove tag by name ( list < tag reference > tags , string tag name ) { list < tag reference > remove tags = new array list < > ( ) ; for ( tag reference tag : tags ) { if ( objects . equals ( tag name , tag . get name ( ) ) ) { remove tags . add ( tag ) ; } } tags . remove all ( remove tags ) ; return remove tags . size ( ) ; }	Removes all the tags with the given name.
public boolean apply namespace ( namespace entity ) { string namespace = get or create metadata ( entity ) . get name ( ) ; log . info ( str + namespace ) ; string name = get name ( entity ) ; objects . require non null ( name , str + entity ) ; namespace old = kubernetes client . namespaces ( ) . with name ( name ) . get ( ) ; if ( ! is running ( old ) ) { try { object answer = kubernetes client . namespaces ( ) . create ( entity ) ; log generated entity ( str , namespace , entity , answer ) ; return bool ; } catch ( exception e ) { on apply error ( str + name + str + e . get message ( ) , e ) ; } } return bool ; }	Returns true if the namespace is created.
public boolean apply project ( project project ) { return apply project request ( new project request builder ( ) . with display name ( project . get metadata ( ) . get name ( ) ) . with metadata ( project . get metadata ( ) ) . build ( ) ) ; }	Creates and return a project in openshift.
public boolean apply project request ( project request entity ) { string namespace = get or create metadata ( entity ) . get name ( ) ; log . info ( str + namespace ) ; string name = get name ( entity ) ; objects . require non null ( name , str + entity ) ; open shift client openshift client = get open shift client ( ) ; if ( openshift client == null ) { log . warn ( str + namespace + str ) ; return bool ; } boolean exists = check namespace ( name ) ;	Returns true if the ProjectRequest is created.
protected string get namespace ( has metadata entity ) { string answer = kubernetes helper . get namespace ( entity ) ; if ( string utils . is blank ( answer ) ) { answer = get namespace ( ) ; }	Returns the namespace defined in the entity or the configured namespace.
protected void on apply error ( string message , exception e ) { log . error ( message , e ) ; throw new runtime exception ( message , e ) ; }	Logs an error applying some JSON to Kubernetes and optionally throws an exception.
@ override public void create ( platform mode platform mode , kubernetes list builder builder ) { final string name = config . get namespace ( ) ; if ( name == null || name . is empty ( ) ) { return ; } if ( ! kubernetes resource util . check for kind ( builder , namespace kinds ) ) { string type = get config ( config . type ) ; if ( str . equals ignore case ( type ) || str . equals ignore case ( type ) ) { if ( platform mode == platform mode . kubernetes ) { log . info ( str + config . get namespace ( ) ) ; namespace namespace = handler hub . get namespace handler ( ) . get namespace ( config . get namespace ( ) ) ; builder . add to namespace items ( namespace ) ; } else { log . info ( str + config . get namespace ( ) ) ; project project = handler hub . get project handler ( ) . get project ( config . get namespace ( ) ) ; builder . add to project items ( project ) ; } } } }	This method will create a default Namespace or Project if a namespace property isspecified in the xml resourceConfig or as a parameter to a mojo.
@ override public void enrich ( platform mode platform mode , kubernetes list builder builder ) { builder . accept ( new typed visitor < object meta builder > ( ) { private string get namespace name ( ) { string name = null ; if ( config . get namespace ( ) != null && ! config . get namespace ( ) . is empty ( ) ) { name = config . get namespace ( ) ; } name = builder . get items ( ) . stream ( ) . filter ( item -> arrays . as list ( namespace kinds ) . contains ( item . get kind ( ) ) ) . find first ( ) . get ( ) . get metadata ( ) . get name ( ) ; return name ; } @ override public void visit ( object meta builder meta builder ) { if ( ! kubernetes resource util . check for kind ( builder , namespace kinds ) ) { return ; } string name = get namespace name ( ) ; if ( name == null || name . is empty ( ) ) { return ; } meta builder . with namespace ( name ) . build ( ) ; } } ) ;	This method will annotate all the items in the KubernetesListBuilder with thecreated new namespace or project.
protected map < string , string > get env ( boolean pre package phase ) throws mojo execution exception { map < string , string > ret = new hash map < > ( ) ; if ( ! is fat jar ( ) ) { string main class = get config ( config . main class ) ; if ( main class == null ) { main class = main class detector . get main class ( ) ; if ( main class == null ) { if ( ! pre package phase ) { throw new mojo execution exception ( str ) ; } } } if ( main class != null ) { log . verbose ( str , main class ) ; ret . put ( java main class env var , main class ) ; } } list < string > java options = get extra java options ( ) ; if ( java options . size ( ) > num ) { ret . put ( java options , string utils . join ( java options . iterator ( ) , str ) ) ; } return ret ; }	Hook for adding extra environment vars.
public static integer duration seconds ( string duration ) { big decimal ns = duration ns ( duration ) ; if ( ns == null ) { return null ; } big decimal sec = ns . divide ( new big decimal ( num ) ) ; if ( sec . compare to ( new big decimal ( integer . max value ) ) > num ) { throw new illegal argument exception ( str ) ; } return sec . int value ( ) ; }	Parses a duration string anr returns its value in seconds.
public static big decimal duration ns ( string duration p ) { if ( duration p == null ) { return null ; } string duration = duration p . trim ( ) ; if ( duration . length ( ) == num ) { return null ; } int unit pos = num ; while ( unit pos < duration . length ( ) && ( character . is digit ( duration . char at ( unit pos ) ) || duration . char at ( unit pos ) == str ) ) { unit pos ++ ; } if ( unit pos >= duration . length ( ) ) { throw new illegal argument exception ( str + duration ) ; } string tail = duration . substring ( unit pos ) ; long multiplier = null ; integer unit end = null ; for ( int i = num ; i < time units . length ; i ++ ) { if ( tail . starts with ( time units [ i ] ) ) { multiplier = unit multipliers [ i ] ; unit end = unit pos + time units [ i ] . length ( ) ; break ; } } if ( multiplier == null ) { throw new illegal argument exception ( str + duration ) ; } big decimal value = new big decimal ( duration . substring ( num , unit pos ) ) ; value = value . multiply ( big decimal . value of ( multiplier ) ) ; string remaining = duration . substring ( unit end ) ; big decimal remaining value = duration ns ( remaining ) ; if ( remaining value != null ) { value = value . add ( remaining value ) ; } return value ; }	Parses a duration string anr returns its value in nanoseconds.
protected string [ ] scan files ( string ... patterns ) { string build output dir = project . get build ( ) . get directory ( ) ; if ( build output dir != null && new file ( build output dir ) . exists ( ) ) { directory scanner directory scanner = new directory scanner ( ) ; directory scanner . set basedir ( build output dir ) ; directory scanner . set includes ( patterns ) ; directory scanner . scan ( ) ; return directory scanner . get included files ( ) ; } else { return new string [ num ] ; } }	Scan the project's output directory for certain files.
protected void disable open shift features ( apply service apply service ) {	Lets disable OpenShift-only features if we are not running on OpenShift.
private boolean service has ingress rule ( list < ingress > ingresses , service service ) { string service name = kubernetes helper . get name ( service ) ; for ( ingress ingress : ingresses ) { ingress spec spec = ingress . get spec ( ) ; if ( spec == null ) { break ; } list < ingress rule > rules = spec . get rules ( ) ; if ( rules == null ) { break ; } for ( ingress rule rule : rules ) { http http = rule . get http ( ) ; if ( http == null ) { break ; } list < http > paths = http . get paths ( ) ; if ( paths == null ) { break ; } for ( http path : paths ) { ingress backend backend = path . get backend ( ) ; if ( backend == null ) { break ; } if ( objects . equals ( service name , backend . get service name ( ) ) ) { return bool ; } } } } return bool ; }	Returns true if there is an existing ingress rule for the given service.
public map < string , list < string > > parse ( final input stream mapping ) { final properties mapping properties = new properties ( ) ; try { mapping properties . load ( mapping ) ; final map < string , list < string > > serialized content = new hash map < > ( ) ; final set < string > kinds = mapping properties . string property names ( ) ; for ( string kind : kinds ) { final string filenames = mapping properties . get property ( kind ) ; final string [ ] filename types = filenames . split ( str ) ; final list < string > scanned filetypes = new array list < > ( ) ; for ( final string filename type : filename types ) { scanned filetypes . add ( filename type . trim ( ) ) ; } serialized content . put ( kind , scanned filetypes ) ; } return serialized content ; } catch ( io e ) { throw new illegal state exception ( e ) ; } }	This method reads properties file to load custom mapping between kinds and filenames. ConfigMap=cm, configmapService=service .
private string get default icon ref ( ) { project class loaders cls = get context ( ) . get project class loaders ( ) ; if ( cls . is class in compile classpath ( bool , str ) || get context ( ) . has dependency ( str , null ) ) { return str ; } if ( cls . is class in compile classpath ( bool , str ) ) { return str ; } if ( get context ( ) . has plugin ( null , spring boot configuration helper . spring boot maven plugin artifact id ) || cls . is class in compile classpath ( bool , str ) ) { return str ; } if ( cls . is class in compile classpath ( bool , str ) ) { return str ; } if ( cls . is class in compile classpath ( bool , str , str ) ) { return str ; } if ( get context ( ) . has plugin ( str , str ) || get context ( ) . has dependency ( str , null ) ) { return str ; } if ( get context ( ) . has plugin ( str , str ) || get context ( ) . has dependency ( str , null ) ) {	Lets use the project and its classpath to try figure out what default icon to use.
private void copy app config files ( file app build dir , file app config dir ) throws io { file [ ] files = app config dir . list files ( ) ; if ( files != null ) { app build dir . mkdirs ( ) ; for ( file file : files ) { file out file = new file ( app build dir , file . get name ( ) ) ; if ( file . is directory ( ) ) { copy app config files ( out file , file ) ; } else { files . copy ( file , out file ) ; } } } }	Copies any local configuration files into the app directory.
protected static properties get properties resource ( url resource ) { properties answer = new properties ( ) ; if ( resource != null ) { try ( input stream stream = resource . open stream ( ) ) { answer . load ( stream ) ; } catch ( io e ) { throw new illegal state exception ( str + resource , e ) ; } } return answer ; }	Returns the given properties resource on the project classpath if found or an empty properties object if not.
public static optional < string > get spring boot version ( maven project maven project ) { return optional . of nullable ( maven util . get dependency version ( maven project , spring boot configuration helper . spring boot group id , spring boot configuration helper . spring boot artifact id ) ) ; }	Determine the spring-boot major version for the current project.
private void enrich ( platform mode platform mode , final processor config enricher config , final kubernetes list builder builder , final list < enricher > enricher list ) { loop ( enricher config , enricher -> { enricher . enrich ( platform mode , builder ) ; return null ; } ) ; }	Allow enricher to add Metadata to the resources.
public map < string , string > get raw config ( ) { return configuration . get processor config ( ) . or else ( processor config . empty ) . get config map ( name ) ; }	Get the raw, untyped configuration or an empty map.
private static map < string , object > get flattened map ( map < string , object > source ) { map < string , object > result = new linked hash map < > ( ) ; build flattened map ( result , source , null ) ; return result ; }	Build a flattened representation of the Yaml tree.
protected static template get singleton template ( kubernetes list resources ) {	Returns the Template if the list contains a single Template only otherwise returns null.
private date get build reference date ( ) throws mojo execution exception {	get a reference date.
public string get ( configs . key key , string default val ) { string key val = key != null ? key . name ( ) : str ; string val = config != null ? config . get config ( name , key . name ( ) ) : null ; if ( val == null ) { string full key = generator prop prefix + str + name + str + key ; val = configs . get system property with maven property as fallback ( properties , full key ) ; } return val != null ? val : default val ; }	Get a config value with a default.
public map < string , string > get config map ( string name ) { return config . contains key ( name ) ? collections . unmodifiable map ( config . get ( name ) ) : collections . < string , string > empty map ( ) ; }	Return full configuration as raw string-string values.
public < t extends named > list < t > prepare processors ( list < t > named list , string type ) { list < t > ret = new array list < > ( ) ; map < string , t > lookup = new hash map < > ( ) ; for ( t named : named list ) { lookup . put ( named . get name ( ) , named ) ; } for ( string inc : includes ) { if ( use ( inc ) ) { t named = lookup . get ( inc ) ; if ( named == null ) { list < string > keys = new array list < > ( lookup . key set ( ) ) ; collections . sort ( keys ) ; throw new illegal argument exception ( str + type + str + inc + str + str + type + str + string utils . join ( keys , str ) ) ; } ret . add ( named ) ; } } return ret ; }	Order elements according to the order provided by the include statements.If no includes has been configured, return the given list unaltered.Otherwise arrange the elements from the list in to the include order and return a newlist.If an include specifies an element which does not exist, an exception is thrown.
protected void add from ( build image configuration . builder builder ) { string from mode = get config with fallback ( config . from mode , str , get from mode default ( context . get runtime mode ( ) ) ) ; string from = get config with fallback ( config . from , str , null ) ; if ( str . equals ignore case ( from mode ) ) { string from image = from ; if ( from image == null ) { from image = from selector != null ? from selector . get from ( ) : null ; } builder . from ( from image ) ; log . info ( str , from image ) ; } else if ( str . equals ignore case ( from mode ) ) { map < string , string > from ext = new hash map < > ( ) ; if ( from != null ) { image name i name = new image name ( from ) ;	Add the base image either from configuration or from a given selector.
private string get from mode default ( runtime mode mode ) { if ( mode == runtime mode . openshift && from selector != null && from selector . is red hat ( ) ) { return str ; } else { return str ; } }	Use "istag" as default for "redhat" versions of this plugin.
protected string get image name ( ) { if ( runtime mode . is open shift mode ( get project ( ) . get properties ( ) ) ) { return get config with fallback ( config . name , str , str ) ; } else { return get config with fallback ( config . name , str , str ) ; } }	Get Image name with a standard default.
protected string get registry ( ) { if ( ! runtime mode . is open shift mode ( get project ( ) . get properties ( ) ) ) { return get config with fallback ( config . registry , str , null ) ; } return null ; }	Get the docker registry where the image should be located.It returns null in Openshift mode.
boolean is online ( ) { string is online = get config ( config . online ) ; if ( is online != null ) { return configs . as boolean ( is online ) ; } boolean ret = as boolean from global prop ( str ) ; return ret != null ? ret : get default online ( ) ; }	Returns true if in offline mode, "false" if not speciied.Can be overriden by.
protected string get external service url ( string service name , string protocol ) { if ( ! is online ( ) ) { get log ( ) . info ( str + service name + str ) ; return null ; } else { try { kubernetes client kubernetes = get kubernetes ( ) ; string ns = kubernetes . get namespace ( ) ; if ( string utils . is blank ( ns ) ) { ns = get namespace ( ) ; } service service = kubernetes . services ( ) . in namespace ( ns ) . with name ( service name ) . get ( ) ; return service != null ? service url util . get service url ( kubernetes , service name , ns , protocol , bool ) : null ; } catch ( throwable e ) { throwable cause = e ; boolean not found = bool ; boolean connect error = bool ; stack < throwable > stack = unfold exceptions ( e ) ; while ( ! stack . is empty ( ) ) { throwable t = stack . pop ( ) ; if ( t instanceof connect exception || str . equals ( t . get message ( ) ) ) { get log ( ) . warn ( str , service name , cause . get message ( ) ) ; return null ; } else if ( t instanceof illegal argument exception || t . get message ( ) != null && t . get message ( ) . matches ( str ) ) { get log ( ) . warn ( str , cause . get message ( ) ) ; return null ; } ; } get log ( ) . warn ( str , service name , cause . get message ( ) ) ; return null ; } } }	Returns the external access to the given service name.
protected boolean as boolean from global prop ( string prop ) { string value = get context ( ) . get configuration ( ) . get property ( prop ) ; if ( value == null ) { value = system . get property ( prop ) ; } return value != null ? boolean . value of ( value ) : null ; }	Check a global prop from the project or system props.
private jest client create jest client ( string uri ) { http client config . builder builder = new http client config . builder ( uri ) . max total connection ( properties . get max total connection ( ) ) . default max total connection per route ( properties . get default max total connection per route ( ) ) . max connection idle time ( properties . get max connection idle time ( ) , time unit . milliseconds ) . read timeout ( properties . get read timeout ( ) ) . multi threaded ( properties . get multi threaded ( ) ) ; if ( string utils . has text ( this . properties . get username ( ) ) ) { builder . default credentials ( this . properties . get username ( ) , this . properties . get password ( ) ) ; } string proxy host = this . properties . get proxy ( ) . get host ( ) ; if ( string utils . has text ( proxy host ) ) { integer proxy port = this . properties . get proxy ( ) . get port ( ) ; assert . not null ( proxy port , str ) ; builder . proxy ( new http host ( proxy host , proxy port ) ) ; } list < http client config builder customizer > config builder customizers = builder customizers != null ? builder customizers . get if available ( ) : new array list < > ( ) ; if ( ! collection utils . is empty ( config builder customizers ) ) { logger . info ( str ) ; config builder customizers . stream ( ) . for each ( customizer -> customizer . customize ( builder ) ) ; logger . info ( str ) ; } jest client factory factory = jest client factory != null ? jest client factory : new jest client factory ( ) ; factory . set http client config ( builder . build ( ) ) ; return factory . get object ( ) ; }	Create Jest client with URI.
private int create internal node ( ) throws node validation exception { if ( logger . is info enabled ( ) ) { logger . info ( str ) ; } int port = socket utils . find available tcp port ( ) ; string cluster name = internal test cluster name + uuid . random uuid ( ) ; settings . builder settings builder = settings . builder ( ) . put ( str , cluster name ) . put ( str , str ) . put ( str , string . value of ( port ) ) ; if ( this . es nodeproperties != null ) { this . es nodeproperties . get properties ( ) . for each ( settings builder :: put ) ; } collection < class < ? extends plugin > > plugins = scan plugins ( ) ; plugins . add ( netty4 plugin . class ) ; this . node = new internal node ( settings builder . build ( ) , plugins ) . start ( ) ; return integer . parse int ( settings builder . get ( str ) ) ; }	Create internal Elasticsearch node.
@ suppress warnings ( str ) private static collection < class < ? extends plugin > > scan plugins ( ) { class path scanning candidate component provider component provider = new class path scanning candidate component provider ( bool ) ; component provider . add include filter ( new assignable type filter ( plugin . class ) ) ; return component provider . find candidate components ( str ) . stream ( ) . map ( bean definition :: get bean class name ) . map ( name -> { try { return ( class < ? extends plugin > ) class . for name ( name ) ; } catch ( class not found exception e ) { logger . warn ( str , e ) ; return null ; } } ) . collect ( collectors . to set ( ) ) ; }	List all official ES plugins available on ClassPath.
public static american express rewards balance from json ( string json string ) throws json { json json = new json ( json string ) ; american express rewards balance rewards balance = new american express rewards balance ( ) ; if ( json . has ( error key ) ) { json error json = json . get json ( error key ) ; rewards balance . m error message = error json . get string ( error message key ) ; rewards balance . m error code = error json . get string ( error code key ) ; } rewards balance . m conversion rate = json . opt string ( json , conversion rate key , null ) ; rewards balance . m currency amount = json . opt string ( json , currency amount key , null ) ; rewards balance . m currency iso code = json . opt string ( json , currency iso code key , null ) ; rewards balance . m request id = json . opt string ( json , request id key , null ) ; rewards balance . m rewards amount = json . opt string ( json , rewards amount key , null ) ; rewards balance . m rewards unit = json . opt string ( json , rewards unit key , null ) ; return rewards balance ; }	Used to parse a response from the Braintree Gateway to be used for American Express rewards balance.
public static void get rewards balance ( final braintree fragment fragment , final string nonce , final string currency iso code ) { fragment . wait for configuration ( new configuration listener ( ) { @ override public void on configuration fetched ( configuration configuration ) { string get rewards balance url = uri . parse ( amex rewards balance path ) . build upon ( ) . append query parameter ( str , nonce ) . append query parameter ( str , currency iso code ) . build ( ) . to string ( ) ; fragment . send analytics event ( str ) ; fragment . get http client ( ) . get ( get rewards balance url , new http response callback ( ) { @ override public void success ( string response body ) { fragment . send analytics event ( str ) ; try { fragment . post american express callback ( american express rewards balance . from json ( response body ) ) ; } catch ( json e ) { fragment . send analytics event ( str ) ; fragment . post callback ( e ) ; } } @ override public void failure ( exception exception ) { fragment . post callback ( exception ) ; fragment . send analytics event ( str ) ; } } ) ; } } ) ; }	Gets the rewards balance associated with a Braintree nonce.
public static pay pal payment resource from json ( string json string ) throws json { json json = new json ( json string ) ; pay pal payment resource pay pal payment resource = new pay pal payment resource ( ) ; json redirect json = json . opt json ( payment resource key ) ; if ( redirect json != null ) { pay pal payment resource . redirect url ( json . opt string ( redirect json , redirect url key , str ) ) ; } else { redirect json = json . opt json ( agreement setup key ) ; pay pal payment resource . redirect url ( json . opt string ( redirect json , approval url key , str ) ) ; } return pay pal payment resource ; }	Create a PayPalPaymentResource from a jsonString.
@ override public void get ( string path , http response callback callback ) { if ( path == null ) { post callback on main thread ( callback , new illegal argument exception ( str ) ) ; return ; } uri uri ; if ( path . starts with ( str ) ) { uri = uri . parse ( path ) ; } else { uri = uri . parse ( m base url + path ) ; } if ( m authorization instanceof client token ) { uri = uri . build upon ( ) . append query parameter ( authorization fingerprint key , ( ( client token ) m authorization ) . get authorization fingerprint ( ) ) . build ( ) ; } super . get ( uri . to string ( ) , callback ) ; }	Make a HTTP GET request to Braintree using the base url, path and authorization provided.If the path is a full url, it will be used instead of the previously provided url.
@ override public void post ( string path , string data , http response callback callback ) { try { if ( m authorization instanceof client token ) { data = new json ( data ) . put ( authorization fingerprint key , ( ( client token ) m authorization ) . get authorization fingerprint ( ) ) . to string ( ) ; } super . post ( path , data , callback ) ; } catch ( json e ) { post callback on main thread ( callback , e ) ; } }	Make a HTTP POST request to Braintree using the base url, path and authorization provided.If the path is a full url, it will be used instead of the previously provided url.
static venmo configuration from json ( json json ) { if ( json == null ) { json = new json ( ) ; } venmo configuration venmo configuration = new venmo configuration ( ) ; venmo configuration . m access token = json . opt string ( json , access token key , str ) ; venmo configuration . m environment = json . opt string ( json , environment key , str ) ; venmo configuration . m merchant id = json . opt string ( json , merchant id key , str ) ; return venmo configuration ; }	Parses the Venmo configuration from json.
public static void collect device data ( braintree fragment fragment , braintree response listener < string > listener ) { collect device data ( fragment , null , listener ) ; }	Collect device information for fraud identification purposes.
public static void collect device data ( final braintree fragment fragment , final string merchant id , final braintree response listener < string > listener ) { fragment . wait for configuration ( new configuration listener ( ) { @ override public void on configuration fetched ( configuration configuration ) { final json device data = new json ( ) ; try { string client metadata id = get pay pal client metadata id ( fragment . get application context ( ) ) ; if ( ! text utils . is empty ( client metadata id ) ) { device data . put ( correlation id key , client metadata id ) ; } } catch ( json ignored ) { } if ( configuration . get kount ( ) . is enabled ( ) ) { final string id ; if ( merchant id != null ) { id = merchant id ; } else { id = configuration . get kount ( ) . get kount merchant id ( ) ; } try { final string device session id = uuid . get formatted uuid ( ) ; start device collector ( fragment , id , device session id , new braintree response listener < string > ( ) { @ override public void on response ( string session id ) { try { device data . put ( device session id key , device session id ) ; device data . put ( fraud merchant id key , id ) ; } catch ( json ignored ) { } listener . on response ( device data . to string ( ) ) ; } } ) ; } catch ( class not found exception | no class def found error | number format exception ignored ) { listener . on response ( device data . to string ( ) ) ; } } else { listener . on response ( device data . to string ( ) ) ; } } } ) ; }	Collect device information for fraud identification purposes.
public static void collect pay pal device data ( final braintree fragment fragment , final braintree response listener < string > listener ) { final json device data = new json ( ) ; try { string client metadata id = get pay pal client metadata id ( fragment . get application context ( ) ) ; if ( ! text utils . is empty ( client metadata id ) ) { device data . put ( correlation id key , client metadata id ) ; } } catch ( json ignored ) { } listener . on response ( device data . to string ( ) ) ; }	Collect PayPal device information for fraud identification purposes.
public static string get pay pal client metadata id ( context context ) { try { return pay pal one touch core . get client metadata id ( context ) ; } catch ( no class def found error ignored ) { } try { return pay pal data collector . get client metadata id ( context ) ; } catch ( no class def found error ignored ) { } return str ; }	Collect device information for fraud identification purposes from PayPal only.
@ suppress lint ( str ) public static boolean is signature valid ( context context , string package name , string certificate subject , string certificate issuer , int public key hash code ) { if ( ! s enable signature verification ) { return bool ; } package manager package manager = context . get package manager ( ) ; signature [ ] signatures ; try { signatures = package manager . get package info ( package name , package manager . get signatures ) . signatures ; } catch ( name not found exception e ) { return bool ; } input stream cert stream = null ; boolean validated = ( signatures . length != num ) ; for ( signature signature : signatures ) { try { cert stream = new byte array input stream ( signature . to byte array ( ) ) ; x509 certificate x509 cert = ( x509 certificate ) certificate factory . get instance ( str ) . generate certificate ( cert stream ) ; string subject = x509 cert . get subject x500 principal ( ) . get name ( ) ; string issuer = x509 cert . get issuer x500 principal ( ) . get name ( ) ; int actual public key hash code = x509 cert . get public key ( ) . hash code ( ) ; validated &= ( certificate subject . equals ( subject ) && certificate issuer . equals ( issuer ) && public key hash code == actual public key hash code ) ; if ( ! validated ) { return bool ; } } catch ( certificate exception e ) { return bool ; } finally { try { if ( cert stream != null ) { cert stream . close ( ) ; } } catch ( io ignored ) { } } } return validated ; }	Check if an app has the correct, matching, signature.
public static string opt string ( json json , string name , string fallback ) { if ( json . is null ( name ) ) { return fallback ; } else { return json . opt string ( name , fallback ) ; } }	Returns the value mapped by name if it exists, coercing it if necessary, or fallback if no such mapping exists.This is a work around for http://code.google.com/p/android/issues/detail?id=13830 returning "null" if the jsonvalue is null.
public static list < payment method nonce > parse payment method nonces ( string json body ) throws json { json payment methods = new json ( json body ) . get json ( payment method nonce collection key ) ; if ( payment methods == null ) { return collections . empty list ( ) ; } list < payment method nonce > payment methods nonces = new array list < > ( ) ; json json ; payment method nonce payment method nonce ; for ( int i = num ; i < payment methods . length ( ) ; i ++ ) { json = payment methods . get json ( i ) ; payment method nonce = parse payment method nonces ( json , json . get string ( payment method type key ) ) ; if ( payment method nonce != null ) { payment methods nonces . add ( payment method nonce ) ; } } return payment methods nonces ; }	Parses a response from the Braintree gateway for a list of payment method nonces.
public checkout recipe get browser checkout config ( ) { for ( checkout recipe recipe : m checkout recipes in decreasing priority order ) { if ( recipe . get target ( ) == request target . browser ) { return recipe ; } } return null ; }	Returns the browser recipe that can handle checkout, or null if there is none.
public billing agreement recipe get browser billing agreement config ( ) { for ( billing agreement recipe recipe : m billing agreement recipes in decreasing priority order ) { if ( recipe . get target ( ) == request target . browser ) { return recipe ; } } return null ; }	Returns the browser recipe that can handle billing agreement, or null if there is none.
public void get ( final string path , final http response callback callback ) { if ( path == null ) { post callback on main thread ( callback , new illegal argument exception ( str ) ) ; return ; } final string url ; if ( path . starts with ( str ) ) { url = path ; } else { url = m base url + path ; } m thread pool . submit ( new runnable ( ) { @ override public void run ( ) { url connection = null ; try { connection = init ( url ) ; connection . set request method ( method get ) ; post callback on main thread ( callback , parse response ( connection ) ) ; } catch ( exception e ) { post callback on main thread ( callback , e ) ; } finally { if ( connection != null ) { connection . disconnect ( ) ; } } } } ) ; }	Make a HTTP GET request to using the base url and path provided.
public void post ( final string path , final string data , final http response callback callback ) { if ( path == null ) { post callback on main thread ( callback , new illegal argument exception ( str ) ) ; return ; } m thread pool . submit ( new runnable ( ) { @ override public void run ( ) { try { post callback on main thread ( callback , post ( path , data ) ) ; } catch ( exception e ) { post callback on main thread ( callback , e ) ; } } } ) ; }	Make a HTTP POST request using the base url and path provided.
public string post ( string path , string data ) throws exception { url connection = null ; try { if ( path . starts with ( str ) ) { connection = init ( path ) ; } else { connection = init ( m base url + path ) ; } connection . set request property ( str , str ) ; connection . set request method ( method post ) ; connection . set do output ( bool ) ; write output stream ( connection . get output stream ( ) , data ) ; return parse response ( connection ) ; } finally { if ( connection != null ) { connection . disconnect ( ) ; } } }	Performs a synchronous post request.
public static void approve payment ( braintree fragment fragment , local payment request request ) { fragment . browser switch ( braintree request codes . local payment , request . get approval url ( ) ) ; fragment . send analytics event ( payment type for analytics ( ) + str ) ; }	Initiates the browser switch for a payment flow by opening a browser where the customer can authenticate with their bank.
public < t extends braintree listener > void add listener ( t listener ) { if ( listener instanceof configuration listener ) { m configuration listener = ( configuration listener ) listener ; } if ( listener instanceof braintree cancel listener ) { m cancel listener = ( braintree cancel listener ) listener ; } if ( listener instanceof payment method nonces updated listener ) { m payment method nonces updated listener = ( payment method nonces updated listener ) listener ; } if ( listener instanceof payment method nonce created listener ) { m payment method nonce created listener = ( payment method nonce created listener ) listener ; } if ( listener instanceof payment method nonce deleted listener ) { m payment method nonce deleted listener = ( payment method nonce deleted listener ) listener ; } if ( listener instanceof braintree payment result listener ) { m braintree payment result listener = ( braintree payment result listener ) listener ; } if ( listener instanceof braintree error listener ) { m error listener = ( braintree error listener ) listener ; } if ( listener instanceof union pay listener ) { m union pay listener = ( union pay listener ) listener ; } if ( listener instanceof american express listener ) { m american express listener = ( american express listener ) listener ; } flush callbacks ( ) ; }	Adds a listener.
public < t extends braintree listener > void remove listener ( t listener ) { if ( listener instanceof configuration listener ) { m configuration listener = null ; } if ( listener instanceof braintree cancel listener ) { m cancel listener = null ; } if ( listener instanceof payment method nonces updated listener ) { m payment method nonces updated listener = null ; } if ( listener instanceof payment method nonce created listener ) { m payment method nonce created listener = null ; } if ( listener instanceof payment method nonce deleted listener ) { m payment method nonce deleted listener = null ; } if ( listener instanceof braintree payment result listener ) { m braintree payment result listener = null ; } if ( listener instanceof braintree error listener ) { m error listener = null ; } if ( listener instanceof union pay listener ) { m union pay listener = null ; } if ( listener instanceof american express listener ) { m american express listener = null ; } }	Removes a previously added listener.
public static void request billing agreement ( braintree fragment fragment , pay pal request request , pay pal approval handler handler ) { if ( request . get amount ( ) == null ) { fragment . send analytics event ( str ) ; if ( request . should offer credit ( ) ) { fragment . send analytics event ( str ) ; } request one time payment ( fragment , request , bool , handler ) ; } else { fragment . post callback ( new braintree exception ( str ) ) ; } }	Starts the Billing Agreement flow for PayPal with custom PayPal approval handler.
protected static void on activity result ( final braintree fragment fragment , int result code , intent data ) { request request = get persisted request ( fragment . get application context ( ) ) ; string payment type = payment type for request ( request ) ; string switch type = switch type for intent ( data ) ; string event prefix = payment type + str + switch type ; if ( result code == app compat activity . result ok && data != null && request != null ) { result result = pay pal one touch core . parse response ( fragment . get application context ( ) , request , data ) ; switch ( result . get result type ( ) ) { case error : fragment . post callback ( new browser switch exception ( result . get error ( ) . get message ( ) ) ) ; fragment . send analytics event ( event prefix + str ) ; break ; case cancel : fragment . post cancel callback ( braintree request codes . paypal ) ; fragment . send analytics event ( event prefix + str ) ; break ; case success : on success ( fragment , data , request , result ) ; fragment . send analytics event ( event prefix + str ) ; break ; } } else { fragment . send analytics event ( event prefix + str ) ; if ( result code != app compat activity . result canceled ) { fragment . post cancel callback ( braintree request codes . paypal ) ; } } }	The result from PayPal's request.
private static pay pal account builder parse response ( pay pal request paypal request , request request , result result , intent intent ) { pay pal account builder paypal account builder = new pay pal account builder ( ) . client metadata id ( request . get client metadata id ( ) ) ; if ( paypal request != null && paypal request . get merchant account id ( ) != null ) { paypal account builder . merchant account id ( paypal request . get merchant account id ( ) ) ; } if ( request instanceof checkout request && paypal request != null ) { paypal account builder . intent ( paypal request . get intent ( ) ) ; } if ( is app switch ( intent ) ) { paypal account builder . source ( str ) ; } else { paypal account builder . source ( str ) ; } paypal account builder . one touch core data ( result . get response ( ) ) ; return paypal account builder ; }	Parse the PayPal response URL using OneTouchCore.
public static void add nouns to dictionary ( list < string > words ) { open korean text processor . add nouns to dictionary ( java converters . as scala buffer converter ( words ) . as scala ( ) ) ; }	Add user-defined words to the noun dictionary.
public static void remove word from dictionary ( korean pos java pos , list < string > words ) { open korean text processor . remove words from dictionary ( korean pos . with name ( pos . to string ( ) ) , java converters . as scala buffer converter ( words ) . as scala ( ) ) ; }	Remove user-defined word List from the dictionary for the specified KoreanPos.
public static list < string > tokens to java string list ( seq < korean token > tokens , boolean keep space ) { iterator < korean token > tokenized = tokens . iterator ( ) ; list < string > output = new linked list < > ( ) ; while ( tokenized . has next ( ) ) { final korean token token = tokenized . next ( ) ; if ( keep space || token . pos ( ) != korean pos . space ( ) ) { output . add ( token . text ( ) ) ; } } return output ; }	Tokenize with the builder options into a String Iterable.
public static list < korean phrase extractor . korean phrase > extract phrases ( seq < korean token > tokens , boolean filter spam , boolean include hashtags ) { seq < korean phrase extractor . korean phrase > seq = open korean text processor . extract phrases ( tokens , filter spam , include hashtags ) ; return to java list ( seq ) ; }	Extract phrases from Korean input text.
public static string detokenize ( list < string > tokens ) { return open korean text processor . detokenize ( java converters . as scala buffer converter ( tokens ) . as scala ( ) ) ; }	Detokenize the input list of words.
public static byte buffer fetch from ( byte buffer buf , readable byte channel ch , int size ) throws io { byte buffer result = buf . duplicate ( ) ; result . limit ( size ) ; nio . read from channel ( ch , result ) ; result . flip ( ) ; return result ; }	Reads size amount of bytes from ch into a new ByteBuffer allocated from abuffer buf.
public static byte buffer join nal ( list < byte buffer > nal units ) { int size = num ; for ( byte buffer nal : nal units ) { size += num + nal . remaining ( ) ; } byte buffer allocate = byte buffer . allocate ( size ) ; join nal ( nal units , allocate ) ; return allocate ; }	Joins buffers containing individual NAL units into a single AnnexBdelimited buffer.
public static void join nal ( list < byte buffer > nal units , byte buffer out ) { for ( byte buffer nal : nal units ) { out . put int ( num ) ; out . put ( nal . duplicate ( ) ) ; } }	Joins buffers containing individual NAL units into a single AnnexBdelimited buffer.
public static profile for int ( int i ) { profile p ; if ( i <= num || i > all . length ) p = unknown ; else p = all [ i - num ] ; return p ; }	Returns a profile instance for the given index.
public static void normalize and generate fixed precision ( double [ ] taps , int prec bits , short [ ] out ) { double sum = num ; for ( int i = num ; i < taps . length ; i ++ ) { sum += taps [ i ] ; } int sum fix = num ; int prec num = num << prec bits ; for ( int i = num ; i < taps . length ; i ++ ) { double d = ( taps [ i ] * prec num ) / sum + prec num ; int s = ( int ) d ; taps [ i ] = d - s ; out [ i ] = ( short ) ( s - prec num ) ; sum fix += out [ i ] ; } long taps taken = num ; while ( sum fix < prec num ) { int max i = - num ; for ( int i = num ; i < taps . length ; i ++ ) { if ( ( taps taken & ( num << i ) ) == num && ( max i == - num || taps [ i ] > taps [ max i ] ) ) max i = i ; } out [ max i ] ++ ; sum fix ++ ; taps taken |= ( num << max i ) ; } for ( int i = num ; i < taps . length ; i ++ ) { taps [ i ] += out [ i ] ; if ( ( taps taken & ( num << i ) ) != num ) taps [ i ] -= num ; } }	Converts floating point taps to fixed precision taps.
public final state read to next marker partial ( byte buffer out ) throws io { if ( done ) return state . stop ; int skip one marker = cur marker >= num && cur marker <= num ? num : num ; int written = out . position ( ) ; do { while ( buf . has remaining ( ) ) { if ( cur marker >= num && cur marker <= num ) { if ( skip one marker == num ) { return state . done ; } -- skip one marker ; } if ( ! out . has remaining ( ) ) return state . more data ; out . put ( ( byte ) ( cur marker > > > num ) ) ; cur marker = ( cur marker << num ) | ( buf . get ( ) & num ) ; } buf = nio . fetch from channel ( channel , fetch size ) ; pos += buf . remaining ( ) ; } while ( buf . has remaining ( ) ) ; written = out . position ( ) - written ; if ( written > num && cur marker >= num && cur marker <= num ) return state . done ; for ( ; bytes in marker > num && out . has remaining ( ) ; ) { out . put ( ( byte ) ( cur marker > > > num ) ) ; cur marker = ( cur marker << num ) ; -- bytes in marker ; if ( cur marker >= num && cur marker <= num ) return state . done ; } if ( bytes in marker == num ) { done = bool ; return state . stop ; } else { return state . more data ; } }	Reads one full segment till the next marker.
public byte buffer read to next marker new buffer ( ) throws io { if ( done ) return null ; list < byte buffer > buffers = new array list < byte buffer > ( ) ; read to next marker buffers ( buffers ) ; return nio . combine buffers ( buffers ) ; }	Reads one full segment till the next marker.
public int get max available frame ( ) { if ( max available frame == - num ) { int first point = num ; for ( int i = max max ; i > num ; i /= num ) { if ( new file ( string . format ( name pattern , i ) ) . exists ( ) ) { first point = i ; break ; } } int pos = first point ; for ( int interv = first point / num ; interv > num ; interv /= num ) { if ( new file ( string . format ( name pattern , pos + interv ) ) . exists ( ) ) { pos += interv ; } } max available frame = pos ; logger . info ( str + max available frame ) ; } return math . min ( max available frame , max frames ) ; }	Finds maximum frame of a sequence by bisecting the range.Performs at max at max 48 Stat calls ( 2*log2(MAX_MAX) ).
public boolean modify ( file file , m edit ) throws io { seekable byte channel fi = null ; try { fi = nio . rw channel ( file ) ; list < tuple . 2 < atom , byte buffer > > fragments = do the fix ( fi , edit ) ; if ( fragments == null ) return bool ;	Tries to modify movie header in place according to what's implemented inthe edit, the file gets pysically modified if the operation issuccessful.
public static long get edited duration ( trak box track ) { list < edit > edits = track . get edits ( ) ; if ( edits == null ) return track . get duration ( ) ; long duration = num ; for ( edit edit : edits ) { duration += edit . get duration ( ) ; } return duration ; }	Calculates track duration considering edits.
public static long frame to timevalue ( trak box trak , int frame number ) { time to sample box stts = node box . find first path ( trak , time to sample box . class , box . path ( str ) ) ; time to sample entry [ ] time to samples = stts . get entries ( ) ; long pts = num ; int stts ind = num , stts sub ind = frame number ; while ( stts sub ind >= time to samples [ stts ind ] . get sample count ( ) ) { stts sub ind -= time to samples [ stts ind ] . get sample count ( ) ; pts += time to samples [ stts ind ] . get sample count ( ) * time to samples [ stts ind ] . get sample duration ( ) ; stts ind ++ ; } return pts + time to samples [ stts ind ] . get sample duration ( ) * stts sub ind ; }	Finds timevalue of a frame numbermight be an expensive operation sinse it traverses compressed time tosample table.
public static int timevalue to frame ( trak box trak , long tv ) { time to sample entry [ ] tts = node box . find first path ( trak , time to sample box . class , box . path ( str ) ) . get entries ( ) ; int frame = num ; for ( int i = num ; tv > num && i < tts . length ; i ++ ) { long rem = tv / tts [ i ] . get sample duration ( ) ; tv -= tts [ i ] . get sample count ( ) * tts [ i ] . get sample duration ( ) ; frame += tv > num ? tts [ i ] . get sample count ( ) : rem ; } return frame ; }	Finds frame by timevalue.
public static long media to edited ( trak box trak , long media tv , int movie timescale ) { if ( trak . get edits ( ) == null ) return media tv ; long accum = num ; for ( edit edit : trak . get edits ( ) ) { if ( media tv < edit . get media time ( ) ) return accum ; long duration = trak . rescale ( edit . get duration ( ) , movie timescale ) ; if ( edit . get media time ( ) != - num && ( media tv >= edit . get media time ( ) && media tv < edit . get media time ( ) + duration ) ) { accum += media tv - edit . get media time ( ) ; break ; } accum += duration ; } return accum ; }	Converts media timevalue to edited timevalue.
public static long edited to media ( trak box trak , long edited tv , int movie timescale ) { if ( trak . get edits ( ) == null ) return edited tv ; long accum = num ; for ( edit edit : trak . get edits ( ) ) { long duration = trak . rescale ( edit . get duration ( ) , movie timescale ) ; if ( accum + duration > edited tv ) { return edit . get media time ( ) + edited tv - accum ; } accum += duration ; } return accum ; }	Converts edited timevalue to media timevalue.
public static int qt player frame no ( movie box movie , int media frame no ) { trak box video track = movie . get video track ( ) ; long edited tv = media to edited ( video track , frame to timevalue ( video track , media frame no ) , movie . get timescale ( ) ) ; return tv2 qt ( movie , edited tv ) ; }	Calculates frame number as it shows in quicktime player.
public static string qt player time ( movie box movie , int media frame no ) { trak box video track = movie . get video track ( ) ; long edited tv = media to edited ( video track , frame to timevalue ( video track , media frame no ) , movie . get timescale ( ) ) ; int sec = ( int ) ( edited tv / video track . get timescale ( ) ) ; return string . format ( str , sec / num ) + str + string . format ( str , ( sec % num ) / num ) + str + string . format ( str , sec % num ) ; }	Calculates and formats standard time as in Quicktime player.
public static int timevalue to timecode frame ( trak box timecode track , rational large tv , int movie timescale ) { timecode sample entry se = ( timecode sample entry ) timecode track . get sample entries ( ) [ num ] ; return ( int ) ( ( num * tv . multiply s ( se . get timescale ( ) ) / se . get frame duration ( ) ) + num ) / num ; }	Converts timevalue to frame number based on timecode track.
public static string format timecode ( trak box timecode track , int counter ) { timecode sample entry tmcd = node box . find first path ( timecode track , timecode sample entry . class , box . path ( str ) ) ; byte nf = tmcd . get num frames ( ) ; string tc = string . format ( str , counter % nf ) ; counter /= nf ; tc = string . format ( str , counter % num ) + str + tc ; counter /= num ; tc = string . format ( str , counter % num ) + str + tc ; counter /= num ; tc = string . format ( str , counter ) + str + tc ; return tc ; }	Formats tape timecode based on frame counter.
public static int 7 ( int val0 , int val1 , int val2 , int val3 , int val4 , int val5 , int val6 ) { return ( num << num ) | ( ( val0 & num ) << num ) | ( ( val1 & num ) << num ) | ( ( val2 & num ) << num ) | ( ( val3 & num ) << num ) | ( ( val4 & num ) << num ) | ( ( val5 & num ) << num ) | ( ( val6 & num ) ) ; }	Creates packed 4bit list with 7 values in it.
public static int set ( int list , int val , int n ) { int cnt = ( list > > num ) & num ; int newc = n + num ; cnt = newc > cnt ? newc : cnt ; return ( list & clear mask [ n ] ) | ( ( val & num ) << ( n << num ) ) | ( cnt << num ) ; }	Sets a 4 bit value into the list.
public boolean matches ( color space input color ) { if ( input color == this ) return bool ; if ( input color == any || this == any ) return bool ; if ( ( input color == any interleaved || this == any interleaved || input color == any planar || this == any planar ) && input color . planar == this . planar ) return bool ; return bool ; }	Determines if two colors match.
public size comp size ( size size , int comp ) { if ( comp width [ comp ] == num && comp height [ comp ] == num ) return size ; return new size ( size . get width ( ) > > comp width [ comp ] , size . get height ( ) > > comp height [ comp ] ) ; }	Calculates the component size based on the fullt size and color subsampling of the given component index.
public static m create raw m ( seekable byte channel input ) throws io { return new m ( input ) { @ override protected m new track ( trak box trak ) { return new m ( movie , trak , this . input ) ; } } ; }	does not modify packets.
protected int read cache ( boolean peek ) throws aac { int i ; if ( pos > buffer . length - word bytes ) throw aac . end of stream ( ) ; else i = ( ( buffer [ pos ] & byte mask ) << num ) | ( ( buffer [ pos + num ] & byte mask ) << num ) | ( ( buffer [ pos + num ] & byte mask ) << num ) | ( buffer [ pos + num ] & byte mask ) ; if ( ! peek ) pos += word bytes ; return i ; }	Reads the next four bytes.
public static wav header create wav header ( audio format format , int samples ) { wav header w = new wav header ( str , num , str , new fmt chunk ( ( short ) num , ( short ) format . get channels ( ) , format . get sample rate ( ) , format . get sample rate ( ) * format . get channels ( ) * ( format . get sample size in bits ( ) > > num ) , ( short ) ( format . get channels ( ) * ( format . get sample size in bits ( ) > > num ) ) , ( short ) format . get sample size in bits ( ) ) , num , calc data size ( format . get channels ( ) , format . get sample size in bits ( ) > > num , samples ) ) ; return w ; }	Creates wav header for the specified audio format.
public static wav header multi channel wav ( wav header [ ] headers ) { wav header w = empty wav header ( ) ; int total size = num ; for ( int i = num ; i < headers . length ; i ++ ) { wav header wav header = headers [ i ] ; total size += wav header . data size ; } w . data size = total size ; fmt chunk fmt = headers [ num ] . fmt ; int bits per sample = fmt . bits per sample ; int bytes per sample = bits per sample / num ; int sample rate = ( int ) fmt . sample rate ; w . fmt . bits per sample = ( short ) bits per sample ; w . fmt . block align = ( short ) ( headers . length * bytes per sample ) ; w . fmt . byte rate = headers . length * bytes per sample * sample rate ; w . fmt . num channels = ( short ) headers . length ; w . fmt . sample rate = sample rate ; return w ; }	Takes single channel wavs as input produces multi channel wav.
public static aac parse m ( byte [ ] data ) throws aac { final i in = bit stream . create bit stream ( data ) ; final aac config = new aac ( ) ; try { config . profile = read profile ( in ) ; int sf = in . read bits ( num ) ; if ( sf == num ) config . sample frequency = sample frequency . for frequency ( in . read bits ( num ) ) ; else config . sample frequency = sample frequency . for int ( sf ) ; config . channel configuration = channel configuration . for int ( in . read bits ( num ) ) ; profile cp = config . profile ; if ( aac sbr == cp ) { config . ext profile = cp ; config . sbr present = bool ; sf = in . read bits ( num ) ;	Parses the input arrays as a DecoderSpecificInfo, as used in MP4containers.
public void encode ( int symbol , context cm ) throws io { int range lps = mq . p lps [ cm . get state ( ) ] ; if ( symbol == cm . get mps ( ) ) { range -= range lps ; offset += range lps ; if ( range < num ) { while ( range < num ) renormalize ( ) ; cm . set state ( mq . transit mps [ cm . get state ( ) ] ) ; } } else { range = range lps ; while ( range < num ) renormalize ( ) ; if ( mq . mps switch [ cm . get state ( ) ] != num ) cm . set mps ( num - cm . get mps ( ) ) ; cm . set state ( mq . transit lps [ cm . get state ( ) ] ) ; } }	Encodes one symbol either 0 or 1.
public static pair < list < edit > > split ( movie box movie , trak box track , long tv mv ) { return split edits ( track . get edits ( ) , new rational ( track . get timescale ( ) , movie . get timescale ( ) ) , tv mv ) ; }	Splits track on the timevalue specified.
public void decode frame ( byte [ ] frame , sample buffer buffer ) throws aac { if ( frame != null ) in . set data ( frame ) ; logger . debug ( str + in . get bits left ( ) ) ; try { decode ( buffer ) ; } catch ( aac e ) { if ( ! e . is end of stream ( ) ) throw e ; else logger . warn ( str ) ; } }	Decodes one frame of AAC data in frame mode and returns the raw PCM data.
public void set big endian ( boolean big endian ) { if ( big endian != this . big endian ) { byte tmp ; for ( int i = num ; i < data . length ; i += num ) { tmp = data [ i ] ; data [ i ] = data [ i + num ] ; data [ i + num ] = tmp ; } this . big endian = big endian ; } }	Sets the endianness for the data.
public void deblock mbp ( mb cur , mb left , mb top ) { int [ ] [ ] vert strength = new int [ num ] [ num ] ; int [ ] [ ] horiz strength = new int [ num ] [ num ] ; calc strength for blocks ( cur , left , vert strength , lookup idx p v , lookup idx q v ) ; calc strength for blocks ( cur , top , horiz strength , lookup idx p h , lookup idx q h ) ; deblock mb ( cur , left , top , vert strength , horiz strength ) ; }	Deblocks P-macroblock.
public void encode native frame ( picture pic ) throws io { if ( pic . get color ( ) != color space . rgb ) throw new illegal argument exception ( str ) ; color space sink color = sink . get input color ( ) ; loaner picture to encode ; if ( sink color != null ) { to encode = pixel store . get picture ( pic . get width ( ) , pic . get height ( ) , sink color ) ; transform . transform ( pic , to encode . get picture ( ) ) ; } else { to encode = new loaner picture ( pic , num ) ; } packet pkt = packet . create packet ( null , timestamp , fps . get num ( ) , fps . get den ( ) , frame no , frame type . key , null ) ; sink . output video frame ( new video frame with packet ( pkt , to encode ) ) ; if ( sink color != null ) pixel store . put back ( to encode ) ; timestamp += fps . get den ( ) ; frame no ++ ; }	Encodes a frame into a movie.
public static byte [ ] ebml encode len ( long value , int length ) { byte [ ] b = new byte [ length ] ; for ( int idx = num ; idx < length ; idx ++ ) {	Encodes unsigned integer with given length.
public static int ebml length ( long v ) { if ( v == num ) return num ; int length = num ; while ( length > num && ( v & ebml length masks [ length ] ) == num ) length -- ; return length ; }	This method is used mostly during writing EBML bitstream. It answers the following question "How many bytes should be used to encode unsigned integer value".
public void add packet ( flv pkt ) throws io { if ( ! write packet ( write buf , pkt ) ) { write buf . flip ( ) ; start of last packet -= out . write ( write buf ) ; write buf . clear ( ) ; if ( ! write packet ( write buf , pkt ) ) throw new runtime exception ( str ) ; } }	Add a packet to the underlying file.
public boolean reposition file ( ) throws io { int payload size = num ; for ( int i = num ; i < reposition buffer reads ; i ++ ) { while ( read buf . has remaining ( ) ) { payload size = ( ( payload size & num ) << num ) | ( read buf . get ( ) & num ) ; int pointer pos = read buf . position ( ) + num + payload size ; if ( read buf . position ( ) >= num && pointer pos < read buf . limit ( ) - num && read buf . get int ( pointer pos ) - payload size == num ) { read buf . position ( read buf . position ( ) - num ) ; return bool ; } } initial read ( ch ) ; if ( ! read buf . has remaining ( ) ) break ; } return bool ; }	Searching for the next tag in a file after corrupt segment.
public int decode bin ( int m ) { int bin ; int q idx = ( range > > num ) & num ; int r lps = m . range lps [ q idx ] [ cm [ num ] [ m ] ] ; range -= r lps ; int rs8 = range << num ; if ( code < rs8 ) {	Decodes one bin from arithmetice code word.
public int decode bin bypass ( ) { code <<= num ; -- n bits pending ; if ( n bits pending <= num ) read one byte ( ) ; int tmp = code - ( range << num ) ; if ( tmp < num ) {	Special decoding process for symbols with uniform distribution.
public static final byte buffer goto marker ( byte buffer buf , int n , int mmin , int mmax ) { if ( ! buf . has remaining ( ) ) return null ; int from = buf . position ( ) ; byte buffer result = buf . slice ( ) ; result . order ( byte order . big endian ) ; int val = num ; while ( buf . has remaining ( ) ) { val = ( val << num ) | ( buf . get ( ) & num ) ; if ( val >= mmin && val <= mmax ) { if ( n == num ) { buf . position ( buf . position ( ) - num ) ; result . limit ( buf . position ( ) - from ) ; break ; } -- n ; } } return result ; }	Finds next Nth MPEG bitstream marker 0x000001xx and returns the data thatpreceeds it as a ByteBuffer sliceSegment byte order is always little endian.
public static sample frequency for int ( int i ) { final sample frequency freq ; if ( i >= num && i < num ) freq = values ( ) [ i ] ; else freq = sample frequency none ; return freq ; }	Returns a sample frequency instance for the given index.
@ override public void predict plane ( byte [ ] ref , int ref x , int ref y , int ref w , int ref h , int ref vert step , int ref vert off , int [ ] tgt , int tgt y , int tgt w , int tgt h , int tgt vert step ) { super . predict plane ( ref , ref x << num , ref y << num , ref w , ref h , ref vert step , ref vert off , tgt , tgt y , tgt w << num , tgt h << num , tgt vert step ) ; }	this may be a result of color greening out in long GOPs.
public static final void start ( int [ ] block , int dc ) { dc <<= dc shift ; for ( int i = num ; i < num ; i += num ) { block [ i + num ] = dc ; block [ i + num ] = dc ; block [ i + num ] = dc ; block [ i + num ] = dc ; } }	Starts DCT reconstructionFaster then call to 'coeff' with ind = 0.
public static final void coeff ( int [ ] block , int ind , int level ) { for ( int i = num ; i < num ; i += num ) { block [ i ] += coeff [ ind ] [ i ] * level ; block [ i + num ] += coeff [ ind ] [ i + num ] * level ; block [ i + num ] += coeff [ ind ] [ i + num ] * level ; block [ i + num ] += coeff [ ind ] [ i + num ] * level ; } }	Recalculates image based on new DCT coefficient.
public static final void finish ( int block [ ] ) { for ( int i = num ; i < num ; i += num ) { block [ i ] = div ( block [ i ] ) ; block [ i + num ] = div ( block [ i + num ] ) ; block [ i + num ] = div ( block [ i + num ] ) ; block [ i + num ] = div ( block [ i + num ] ) ; } }	Finalizes DCT calculation.
public void concat bits ( bits buffer a ) { if ( a . len == num ) return ; int al = a . bufa ; int ah = a . bufb ; int bl , bh ; if ( len > num ) {	merge bits of a to b.
static int rewind reverse32 ( int v , int len ) { v = ( ( v > > s [ num ] ) & b [ num ] ) | ( ( v << s [ num ] ) & ~ b [ num ] ) ; v = ( ( v > > s [ num ] ) & b [ num ] ) | ( ( v << s [ num ] ) & ~ b [ num ] ) ; v = ( ( v > > s [ num ] ) & b [ num ] ) | ( ( v << s [ num ] ) & ~ b [ num ] ) ; v = ( ( v > > s [ num ] ) & b [ num ] ) | ( ( v << s [ num ] ) & ~ b [ num ] ) ; v = ( ( v > > s [ num ] ) & b [ num ] ) | ( ( v << s [ num ] ) & ~ b [ num ] ) ;	32 bit rewind and reverse.
protected int seek to key frame ( int frame ) throws io { if ( video input track instanceof seekable demuxer track ) { seekable demuxer track seekable = ( seekable demuxer track ) video input track ; seekable . goto sync frame ( frame ) ; return ( int ) seekable . get cur frame ( ) ; } else { logger . warn ( str + video input track + str ) ; return - num ; } }	Seeks to a previous key frame prior or on the given frame, if the track isnot seekable returns 0.
protected loaner picture get pixel buffer ( byte buffer first frame ) { video codec meta video meta = get video codec meta ( ) ; size size = video meta . get size ( ) ; return pixel store . get picture ( ( size . get width ( ) + num ) & ~ num , ( size . get height ( ) + num ) & ~ num , video meta . get color ( ) ) ; }	Returns a pixel buffer of a suitable size to hold the given video frame.
private int get gain change point id ( int lngain ) { for ( int i = num ; i < id gain ; i ++ ) { if ( lngain == ln gain [ i ] ) return i ; } return num ;	transformes the exponent value of the gain to the id of the gain changepoint.
public static int [ ] from byte ( byte [ ] b , int depth , boolean is be ) { if ( depth == num ) if ( is be ) return from24 be ( b ) ; else return from24 le ( b ) ; else if ( depth == num ) if ( is be ) return from16 be ( b ) ; else return from16 le ( b ) ; throw new not supported exception ( str + depth + str + ( is be ? str : str ) + str ) ; }	Generic byte-array to integer-array conversionConverts each depth-bit sequence from the input byte array into integer.
public static byte [ ] to byte ( int [ ] ia , int depth , boolean is be ) { if ( depth == num ) if ( is be ) return to24 be ( ia ) ; else return to24 le ( ia ) ; else if ( depth == num ) if ( is be ) return to16 be ( ia ) ; else return to16 le ( ia ) ; throw new not supported exception ( str + depth + str + ( is be ? str : str ) + str ) ; }	Generic integer-array to byte-array conversionConverts each integer into depth-bit sequence in the output byte array.
public static void to float ( audio format format , byte buffer buf , float buffer float buf ) { if ( ! format . is signed ( ) ) throw new not supported exception ( str ) ; if ( format . get sample size in bits ( ) != num && format . get sample size in bits ( ) != num ) throw new not supported exception ( format . get sample size in bits ( ) + str ) ; if ( format . is big endian ( ) ) { if ( format . get sample size in bits ( ) == num ) { to float16 be ( buf , float buf ) ; } else { to float24 be ( buf , float buf ) ; } } else { if ( format . get sample size in bits ( ) == num ) { to float16 le ( buf , float buf ) ; } else { to float24 le ( buf , float buf ) ; } } }	Converts PCM samples stored in buf and described with format to floatarray representation.
public static void from float ( float buffer float buf , audio format format , byte buffer buf ) { if ( ! format . is signed ( ) ) throw new not supported exception ( str ) ; if ( format . get sample size in bits ( ) != num && format . get sample size in bits ( ) != num ) throw new not supported exception ( format . get sample size in bits ( ) + str ) ; if ( format . is big endian ( ) ) { if ( format . get sample size in bits ( ) == num ) { from float16 be ( buf , float buf ) ; } else { from float24 be ( buf , float buf ) ; } } else { if ( format . get sample size in bits ( ) == num ) { from float16 le ( buf , float buf ) ; } else { from float24 le ( buf , float buf ) ; } } }	Converts float PCM samples stored in floatBuf to integer representationaccording to format and stores them in buf.
public static void interleave ( audio format format , byte buffer [ ] ins , byte buffer outb ) { int bytes per sample = format . get sample size in bits ( ) > > num ; int bytes per frame = bytes per sample * ins . length ; int max = num ; for ( int i = num ; i < ins . length ; i ++ ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; for ( int frames = num ; frames < max && outb . remaining ( ) >= bytes per frame ; frames ++ ) { for ( int j = num ; j < ins . length ; j ++ ) { if ( ins [ j ] . remaining ( ) < bytes per sample ) { for ( int i = num ; i < bytes per sample ; i ++ ) outb . put ( ( byte ) num ) ; } else { for ( int i = num ; i < bytes per sample ; i ++ ) { outb . put ( ins [ j ] . get ( ) ) ; } } } } }	Interleaves audio samples in ins into outb using sample size from theformat.
public static void deinterleave ( audio format format , byte buffer inb , byte buffer [ ] outs ) { int bytes per sample = format . get sample size in bits ( ) > > num ; int bytes per frame = bytes per sample * outs . length ; while ( inb . remaining ( ) >= bytes per frame ) { for ( int j = num ; j < outs . length ; j ++ ) { for ( int i = num ; i < bytes per sample ; i ++ ) { outs [ j ] . put ( inb . get ( ) ) ; } } } }	Deinterleaves audio samples from inb into outs using sample size fromformat.
public size get coded size ( ) { sample entry se = get sample entries ( ) [ num ] ; if ( ! ( se instanceof video sample entry ) ) throw new illegal argument exception ( str ) ; video sample entry vse = ( video sample entry ) se ; return new size ( vse . get width ( ) , vse . get height ( ) ) ; }	Retrieves coded size of this video track.Note: May be different from video display dimension.
public static int [ ] build wipe map ( int pic width in mbs , int pic height in mbs , int size of upper left group , boolean change direction ) { int pic size in mbs = pic width in mbs * pic height in mbs ; int [ ] groups = new int [ pic size in mbs ] ; int change direction int = change direction ? num : num ; int k = num ; for ( int j = num ; j < pic width in mbs ; j ++ ) { for ( int i = num ; i < pic height in mbs ; i ++ ) { int mb addr = i * pic width in mbs + j ; if ( k ++ < size of upper left group ) { groups [ mb addr ] = change direction int ; } else { groups [ mb addr ] = num - change direction int ; } } } return groups ; }	A macroblock to slice group map that fills frame column by column.
protected static ul [ ] read ul ( byte buffer bb ) { int count = bb . get int ( ) ; bb . get int ( ) ; ul [ ] result = new ul [ count ] ; for ( int i = num ; i < count ; i ++ ) { result [ i ] = ul . read ( bb ) ; } return result ; }	Utility method to read a batch of ULS.
protected static int [ ] read int32 batch ( byte buffer bb ) { int count = bb . get int ( ) ; bb . get int ( ) ; int [ ] result = new int [ count ] ; for ( int i = num ; i < count ; i ++ ) { result [ i ] = bb . get int ( ) ; } return result ; }	Utility method to read a batch of int32.
public static int calc mv ( int a , int b , int c , int d , boolean a avb , boolean b avb , boolean c avb , boolean d avb , int ref , int comp ) { if ( ! c avb ) { c = d ; c avb = d avb ; } if ( a avb && ! b avb && ! c avb ) { b = c = a ; b avb = c avb = a avb ; } a = a avb ? a : null vector ; b = b avb ? b : null vector ; c = c avb ? c : null vector ; if ( mv ref ( a ) == ref && mv ref ( b ) != ref && mv ref ( c ) != ref ) return mv c ( a , comp ) ; else if ( mv ref ( b ) == ref && mv ref ( a ) != ref && mv ref ( c ) != ref ) return mv c ( b , comp ) ; else if ( mv ref ( c ) == ref && mv ref ( a ) != ref && mv ref ( b ) != ref ) return mv c ( c , comp ) ; return mv c ( a , comp ) + mv c ( b , comp ) + mv c ( c , comp ) - min ( mv c ( a , comp ) , mv c ( b , comp ) , mv c ( c , comp ) ) - max ( mv c ( a , comp ) , mv c ( b , comp ) , mv c ( c , comp ) ) ; }	Calculates median prediction.
public encoded frame encode frame ( picture pic , byte buffer out ) { if ( pic . get color ( ) != color space . yu j ) throw new illegal argument exception ( str + pic . get color ( ) ) ; if ( frame number >= key interval ) { frame number = num ; } slice type slice type = frame number == num ? slice type . i : slice type . p ; boolean idr = frame number == num ; byte buffer data = do encode frame ( pic , out , idr , frame number ++ , slice type ) ; return new encoded frame ( data , idr ) ; }	Encode this picture into h.264 frame.
public byte buffer encode idr ( picture pic , byte buffer out ) { frame number = num ; return do encode frame ( pic , out , bool , frame number , slice type . i ) ; }	Encode this picture as an IDR frame. IDR frame starts a new independentlydecodeable video sequence.
public byte buffer encode p ( picture pic , byte buffer out ) { frame number ++ ; return do encode frame ( pic , out , bool , frame number , slice type . p ) ; }	Encode this picture as a P-frame.
public java . util . collection < codec . id > get supported codecs ( ) { final java . util . list < codec . id > retval = new java . util . linked list < codec . id > ( ) ; final java . util . set < codec . id > unique set = new java . util . hash set < codec . id > ( ) ; int num codecs = get num supported codecs ( ) ; for ( int i = num ; i < num codecs ; i ++ ) { codec . id id = get supported codec id ( i ) ;	Returns a list of all codecs supported for this Object.
public java . util . collection < long > get supported tags ( ) { final java . util . list < long > retval = new java . util . linked list < long > ( ) ; final java . util . set < long > unique set = new java . util . hash set < long > ( ) ; int num codecs = get num supported codecs ( ) ; for ( int i = num ; i < num codecs ; i ++ ) { long tag = get supported codec tag ( i ) ; codec . id id = get supported codec id ( i ) ;	Returns a list of all codec tags supported for this container.
final boolean add reference ( final jni ref ) {	Add a reference to the set of references we'll collect.
void gc internal ( ) { jni ref = null ; while ( ( ref = ( jni ) m ref queue . poll ( ) ) != null ) { ref . delete ( ) ; } }	The actual GC;.
final public void flush ( ) { blocking lock ( ) ; try { int num survivors = sweep and collect ( ) ; for ( int i = num ; i < num survivors ; i ++ ) { final jni ref = m valid references [ i ] ; if ( ref != null ) ref . delete ( ) ; } sweep and collect ( ) ;	Internal Only.Immediately frees all active objects in the system.
@ suppress warnings ( str ) public static void load ( string appname , jni library ) {	Load the given library into the given application.This method first searches in the classpath for native libraries that arebundled in there, and only if no matches are found, will it search therun-time paths of each OS.
private boolean unpack library ( string path ) { boolean retval = bool ; try { final enumeration < url > c = jni . class . get class loader ( ) . get resources ( path ) ; while ( c . has more elements ( ) ) { final url url = c . next element ( ) ; log . trace ( str , path , url ) ; if ( url == null ) return bool ; boolean unpacked = bool ; file lib ; if ( url . get protocol ( ) . to lower case ( ) . equals ( str ) ) {	Looks for a URL in a classpath, and if found, unpacks it.
private static void delete temporary files ( ) { final file dir = get tmp dir ( ) ; final filename filter filter = new filename filter ( ) { public boolean accept ( file dir , string name ) { return name . ends with ( humble temp extension ) ; } } ; final file markers [ ] = dir . list files ( filter ) ; for ( file marker : markers ) { final string marker name = marker . get name ( ) ; final string lib name = marker name . substring ( num , marker name . length ( ) - humble temp extension . length ( ) ) ; final file lib = new file ( marker . get parent file ( ) , lib name ) ; if ( ! lib . exists ( ) || lib . delete ( ) ) marker . delete ( ) ; } }	Finds all ".humble" temp files in the temp directory and nukes them.
public static audio channel . layout get default layout ( int num channels ) { return audio channel . layout . swig to enum ( jni . get default layout ( num channels ) ) ; }	Return default channel layout for a given number of channels.
public static audio channel . type get channel from layout at index ( audio channel . layout layout , int index ) { return audio channel . type . swig to enum ( jni . get channel from layout at index ( layout . swig value ( ) , index ) ) ; }	Get the channel with the given index in channel_layout.
public static media packet make ( ) { long c ptr = jni . make swig 0 ( ) ; return ( c ptr == num ) ? null : new media packet ( c ptr , bool ) ; }	Create a new Packet.
public static string get version info ( ) { final class < ? > c = version . class ; final string builder b = new string builder ( ) ; final package p = c . get package ( ) ; b . append ( str + c . get canonical name ( ) + str ) ; b . append ( str + p . get specification vendor ( ) + str ) ; b . append ( str + p . get specification title ( ) + str ) ; b . append ( str + p . get specification version ( ) + str ) ; b . append ( str + p . get implementation vendor ( ) + str ) ; b . append ( str + p . get implementation title ( ) + str ) ; b . append ( str + p . get implementation version ( ) + str ) ; return b . to string ( ) ; }	Prints the version of this library to System.out along withsome information on what this jar is.
public static rational get default time base ( ) { long c ptr = jni . get default time base ( ) ; return ( c ptr == num ) ? null : new rational ( c ptr , bool ) ; }	The default timebase used by media if not otherwise specified.
public static demuxer make ( ) { long c ptr = jni . make ( ) ; return ( c ptr == num ) ? null : new demuxer ( c ptr , bool ) ; }	Create a new Demuxer.
private static void play video ( string filename ) throws interrupted exception , io { demuxer demuxer = demuxer . make ( ) ; demuxer . open ( filename , null , bool , bool , null , null ) ; int num streams = demuxer . get num streams ( ) ; int video stream id = - num ; long stream start time = global . no pts ; decoder video decoder = null ; for ( int i = num ; i < num streams ; i ++ ) { final demuxer stream stream = demuxer . get stream ( i ) ; stream start time = stream . get start time ( ) ; final decoder decoder = stream . get decoder ( ) ; if ( decoder != null && decoder . get codec type ( ) == media descriptor . type . media video ) { video stream id = i ; video decoder = decoder ;	Opens a file, and plays the video from it on a screen at the right rate.
private static buffered image display video at correct time ( long stream start time , final media picture picture , final media picture converter converter , buffered image image , final image frame window , long system start time , final rational system time base , final rational stream timebase ) throws interrupted exception { long stream timestamp = picture . get time stamp ( ) ;	Takes the video picture and displays it at the right time.
public static codec descriptor make ( codec . id id ) { long c ptr = jni . make ( id . swig value ( ) ) ; return ( c ptr == num ) ? null : new codec descriptor ( c ptr , bool ) ; }	Get the descriptor for the given id.
public static void print option ( java . io . print stream stream , configurable config obj , property prop ) { if ( prop . get type ( ) != property . type . property flags ) { stream . printf ( str , prop . get name ( ) , config obj . get property as string ( prop . get name ( ) ) , prop . get type ( ) ) ; } else {	Print information about the property on the configurable object.
static io register factory ( string protocol prefix ) { url manager = url . get manager ( ) ; manager . register factory ( protocol prefix , m factory ) ; return m factory ; }	Register a new protocol name for this factory that Humble.IO will use forthe given protocol.
static public string generate unique name ( object src , string extension ) { string builder builder = new string builder ( ) ; builder . append ( uuid . random uuid ( ) . to string ( ) ) ; if ( src != null ) { builder . append ( str ) ; builder . append ( src . get class ( ) . get name ( ) ) ; builder . append ( str ) ; builder . append ( integer . to hex string ( src . hash code ( ) ) ) ; } if ( extension != null ) { builder . append ( extension ) ; } return builder . to string ( ) ; }	Generates a unique name suitable for using in the map methods for the URLparameter.
public static media audio resampler make ( audio channel . layout out layout , int out sample rate , audio format . type out format , audio channel . layout in layout , int in sample rate , audio format . type in format ) { long c ptr = jni . make ( out layout . swig value ( ) , out sample rate , out format . swig value ( ) , in layout . swig value ( ) , in sample rate , in format . swig value ( ) ) ; return ( c ptr == num ) ? null : new media audio resampler ( c ptr , bool ) ; }	Create a new MediaAudioResampler.
public java . util . collection < rational > get supported video frame rates ( ) { java . util . list < rational > retval = new java . util . linked list < rational > ( ) ; int count = get num supported video frame rates ( ) ; for ( int i = num ; i < count ; i ++ ) { rational rate = get supported video frame rate ( i ) ; if ( rate != null ) retval . add ( rate ) ; } return retval ; }	Returns a list of supported frame-rates this codec can encodevideo to.
public java . util . collection < pixel format . type > get supported video pixel formats ( ) { java . util . list < pixel format . type > retval = new java . util . linked list < pixel format . type > ( ) ; int count = get num supported video pixel formats ( ) ; for ( int i = num ; i < count ; i ++ ) { pixel format . type type = get supported video pixel format ( i ) ; if ( type != null && type != pixel format . type . pix fmt none ) retval . add ( type ) ; } return retval ; }	Returns a list of supported pixel formats this codec can encodevideo in.
public java . util . collection < integer > get supported audio sample rates ( ) { java . util . list < integer > retval = new java . util . linked list < integer > ( ) ; int count = get num supported audio sample rates ( ) ; for ( int i = num ; i < count ; i ++ ) { int rate = get supported audio sample rate ( i ) ; if ( rate != num ) retval . add ( rate ) ; } return retval ; }	Returns a list of supported audio sample rates this codec can encodeaudio in.
public java . util . collection < audio format . type > get supported audio formats ( ) { java . util . list < audio format . type > retval = new java . util . linked list < audio format . type > ( ) ; int count = get num supported audio formats ( ) ; for ( int i = num ; i < count ; i ++ ) { audio format . type fmt = get supported audio format ( i ) ; if ( fmt != null && fmt != audio format . type . sample fmt none ) retval . add ( fmt ) ; } return retval ; }	Returns a list of supported audio sample formats this codec can encodeaudio in.
public java . util . collection < audio channel . layout > get supported audio channel layouts ( ) { java . util . list < audio channel . layout > retval = new java . util . linked list < audio channel . layout > ( ) ; int count = get num supported audio channel layouts ( ) ; for ( int i = num ; i < count ; i ++ ) { audio channel . layout layout = get supported audio channel layout ( i ) ; if ( layout != audio channel . layout . ch layout unknown ) retval . add ( layout ) ; } return retval ; }	Returns a list of supported audio channel layouts this codec can encodeaudio in.
public void set flag ( coder . flag flag , boolean value ) { jni . set flag ( swig c , this , flag . swig value ( ) , value ) ; }	Set a flag to true or false.
public void set flag2 ( coder . flag2 flag , boolean value ) { jni . set flag2 ( swig c , this , flag . swig value ( ) , value ) ; }	Set a flag2 to true or false.
public decoder get decoder ( ) { long c ptr = jni . get decoder ( swig c , this ) ; return ( c ptr == num ) ? null : new decoder ( c ptr , bool ) ; }	Get the decoder that can decode the information in this Demuxer stream.
public demuxer get demuxer ( ) { long c ptr = jni . get demuxer ( swig c , this ) ; return ( c ptr == num ) ? null : new demuxer ( c ptr , bool ) ; }	Get the Demuxer this DemuxerStream belongs to.
public static java . util . collection < muxer format > get formats ( ) { java . util . collection < muxer format > retval = new java . util . hash set < muxer format > ( ) ; int count = get num formats ( ) ; for ( int i = num ; i < count ; ++ i ) { muxer format fmt = get format ( i ) ; if ( fmt != null ) retval . add ( fmt ) ; } return retval ; }	Return a collection of all output formats installed on this system.
public static filter graph make ( ) { long c ptr = jni . make ( ) ; return ( c ptr == num ) ? null : new filter graph ( c ptr , bool ) ; }	Creates a new FilterGraph.
public bit stream filter type get type ( ) { long c ptr = jni . get type ( swig c , this ) ; return ( c ptr == num ) ? null : new bit stream filter type ( c ptr , bool ) ; }	Get the type of this filter.
public java . nio . byte buffer get byte buffer ( int offset , int length ) { return get byte buffer ( offset , length , null ) ; }	Returns up to length bytes, starting at offset in the underlyingbuffer we're managing.
public static audio frame make ( final audio format audio format ) { try { return new audio frame ( audio format ) ; } catch ( line unavailable exception e ) { log . error ( str , e . get message ( ) ) ; return null ; } }	Get a connection to the speaker, if available.
protected static media picture resample ( media picture input , media picture resampler resampler ) {	Re-sample a picture.
protected void validate image ( buffered image image ) {	Test that the passed image is valid and conforms to theconverters specifications.
protected void validate picture ( media picture picture ) {	Test that the passed picture is valid and conforms to theconverters specifications.
public filter graph get filter graph ( ) { long c ptr = jni . get filter graph ( swig c , this ) ; return ( c ptr == num ) ? null : new filter graph ( c ptr , bool ) ; }	Get the FilterGraph this FilterLink belongs to.
public key value bag get meta data ( ) { long c ptr = jni . get meta data ( swig c , this ) ; return ( c ptr == num ) ? null : new key value bag ( c ptr , bool ) ; }	Get any meta-data associated with this media item.
public static cpu get cpu ( string java cpu ) { final cpu java arch ; final string java cpu = java cpu != null ? java cpu . to lower case ( ) : str ;	Get the CPU architecture based on the passed in javaCPUArch specifier.The string should be of a format returned from {.
public static cpu get cpu gnu ( string gnu string ) { final string native cpu = gnu string . to lower case ( ) ; final cpu native arch ;	Return a CPUArch from parsing a GNU autoconf triple.For example "x86_64-w64-mingw32" will return {.
public static os get os ( string os name ) { final os retval ; if ( os name != null && os name . length ( ) > num ) { if ( os name . starts with ( str ) ) retval = os . windows ; else if ( os name . starts with ( str ) ) retval = os . mac ; else if ( os name . starts with ( str ) ) retval = os . linux ; else retval = os . unknown ; } else retval = os . unknown ; return retval ; }	Get the OSFamily based on the passed in osName specifier.The string should be of a format returned from {.
public static os get os gnu ( string gnu string ) { final string native os = ( gnu string != null ? gnu string . to lower case ( ) : str ) ; final os retval ; if ( native os . starts with ( str ) || native os . starts with ( str ) ) retval = os . windows ; else if ( native os . starts with ( str ) ) retval = os . mac ; else if ( native os . starts with ( str ) ) retval = os . linux ; else retval = os . unknown ; return retval ; }	Return an OS Family from parsing a GNU autoconf triple.For example "x86_64-w64-mingw32" will return {.
private static void play sound ( string filename ) throws interrupted exception , io , line unavailable exception { demuxer demuxer = demuxer . make ( ) ; demuxer . open ( filename , null , bool , bool , null , null ) ; int num streams = demuxer . get num streams ( ) ; int audio stream id = - num ; decoder audio decoder = null ; for ( int i = num ; i < num streams ; i ++ ) { final demuxer stream stream = demuxer . get stream ( i ) ; final decoder decoder = stream . get decoder ( ) ; if ( decoder != null && decoder . get codec type ( ) == media descriptor . type . media audio ) { audio stream id = i ; audio decoder = decoder ;	Opens a file, and plays the audio from it on the speakers.
synchronized void load library0 ( string a library name , long a major version ) { if ( already loaded library ( a library name , a major version ) )	This is the method that actually loads the library.
void set loaded library ( string a library name , long a major version ) { set < long > found versions = m loaded libraries . get ( a library name ) ; if ( found versions == null ) { found versions = new hash set < long > ( ) ; m loaded libraries . put ( a library name , found versions ) ; } found versions . add ( a major version ) ; }	Tell the cache that we've loaded this version.
boolean load candidate library ( string a library name , long a major version , list < string > a lib candidates ) { boolean retval = bool ; for ( string candidate : a lib candidates ) { log . trace ( str , new object [ ] { a library name , a major version == null ? str : a major version . long value ( ) , candidate } ) ; file candidate file = new file ( candidate ) ; if ( candidate file . exists ( ) ) { string abs path = candidate file . get absolute path ( ) ; try { log . trace ( str , new object [ ] { a library name , a major version == null ? str : a major version . long value ( ) , abs path } ) ;	Iterates through the set of aLibCandidates until it succeeds in loading alibrary.
private void initialize search paths ( ) { string path var = null ; if ( m java prop paths == null ) { path var = system . get property ( str , str ) ; log . trace ( str , path var ) ; m java prop paths = get entities from path ( path var ) ; } if ( m java env paths == null ) { string env var = get system runtime library path var ( ) ; path var = system . getenv ( env var ) ; log . trace ( str , env var , path var ) ; m java env paths = get entities from path ( path var ) ; } }	Initialize the paths we'll search for libraries in.
boolean already loaded library ( string a library name , long a major version ) { boolean retval = bool ; set < long > found versions = m loaded libraries . get ( a library name ) ; if ( found versions != null ) {	Checks our cache to see if we've already loaded this library.We will also detect if we've already loaded another version of thislibrary, and log a warning, but otherwise will return false in that case.
public void delete ( ) {	Explicitly deletes the underlying native storage used bythe object this object references.
public muxer stream get stream ( int position ) throws java . lang . interrupted exception , java . io . io { long c ptr = jni . get stream ( swig c , this , position ) ; return ( c ptr == num ) ? null : new muxer stream ( c ptr , bool ) ; }	Get the MuxerStream at the given position.
public muxer get muxer ( ) { long c ptr = jni . get muxer ( swig c , this ) ; return ( c ptr == num ) ? null : new muxer ( c ptr , bool ) ; }	Get the Muxer that this stream belongs to.
public static set script transaction make script tx ( private key account sender , string script , byte chain id , long fee , long timestamp ) { return new set script transaction ( sender , script , chain id , fee , timestamp ) ; }	Creates a signed SetScript object.
public static byte [ ] decode ( string input ) throws illegal argument exception { if ( input . starts with ( str ) ) input = input . substring ( num ) ; if ( input . length ( ) == num ) return new byte [ num ] ;	Decodes the given base58 string into the original data bytes.
public static string generate seed ( ) { byte [ ] bytes = new byte [ num ] ; new secure random ( ) . next bytes ( bytes ) ; byte [ ] rhash = hash ( bytes , num , num , sh ) ; bytes [ num ] = rhash [ num ] ; big integer rand = new big integer ( bytes ) ; big integer mask = new big integer ( new byte [ ] { num , num , num , - num } ) ;	Generates a 15-word random seed.
public transaction get transaction ( string tx id ) throws io { return waves json mapper . convert value ( send ( str + tx id ) , transaction . class ) ; }	Returns object by its ID.
public list < transaction > get address transactions ( string address , int limit ) throws io { return get address transactions ( address , limit , null ) ; }	Returns transactions by address with limit.
public list < transaction > get address transactions ( string address , int limit , string after ) throws io { string request url = string . format ( str , address , limit ) ; if ( after != null ) { request url += string . format ( str , after ) ; } return waves json mapper . < list < list < transaction > > > convert value ( send ( request url ) , new type reference < list < list < transaction > > > ( ) { } ) . get ( num ) ; }	Returns transactions by address with limit after passed transaction id.
public list < block header > get block header seq ( int from , int to ) throws io { string path = string . format ( str , from , to ) ; http response r = exec ( request ( path ) ) ; return parse ( r , block header list ) ; }	Returns seq of block headers.
public block get block ( string signature ) throws io { return waves json mapper . convert value ( send ( str + signature ) , block . class ) ; }	Returns block by its signature.
public string send ( transaction tx ) throws io { return parse ( exec ( request ( tx ) ) , str ) . as text ( ) ; }	Sends a signed object and returns its ID.
public string set script ( private key account from , string script , byte chain id , long fee ) throws io { return send ( transactions . make script tx ( from , compile script ( script ) , chain id , fee ) ) ; }	Sets a validating script for an account.
public string compile script ( string script ) throws io { if ( script == null || script . is empty ( ) ) { return null ; } http post request = new http post ( uri . resolve ( str ) ) ; request . set entity ( new string entity ( script ) ) ; return parse ( exec ( request ) , str ) . as text ( ) ; }	Compiles a script.
public void write primitive array ( object array , int off , int len ) throws io { class < ? > component type = array . get class ( ) . get component type ( ) ; if ( component type == byte . class ) { write raw bytes ( ( byte [ ] ) array , off , len ) ; } else if ( component type == char . class ) { write f ( ( char [ ] ) array , off , len ) ; } else if ( component type == short . class ) { write f ( ( short [ ] ) array , off , len ) ; } else if ( component type == int . class ) { write f ( ( int [ ] ) array , off , len ) ; } else if ( component type == double . class ) { write f ( ( double [ ] ) array , off , len ) ; } else if ( component type == float . class ) { write f ( ( float [ ] ) array , off , len ) ; } else if ( component type == long . class ) { write f ( ( long [ ] ) array , off , len ) ; } else if ( component type == boolean . class ) { write f ( ( boolean [ ] ) array , off , len ) ; } else { throw new runtime exception ( str ) ; } }	write prim array no len no tag.
@ override public void flush ( ) throws io { if ( out stream != null ) out stream . write ( get buffer ( ) , num , ( int ) pos ) ; pos = num ; }	writes current buffer to underlying output and resets buffer.
public int to memory ( object o , long address , int available size ) throws io { out . reset for re use ( ) ; write target . set base ( address , available size ) ; out . write object ( o ) ; int written = out . get written ( ) ; return written ; }	throws FSTBufferTooSmallException in case object does not fit into given range.
@ override public fst read class ( ) throws io , class not found exception { if ( last direct class != null ) { fst cl info = conf . get cl ( ) . get cl ( last direct class , conf ) ; last direct class = null ; return cl info ; } return null ; }	in case readClass already reads full minbin value.
public int to byte array ( object obj , byte result [ ] , int result offset , int avaiable size ) { output . reset for re use ( ) ; try { output . write object ( obj ) ; } catch ( io e ) { fst . < runtime exception > rethrow ( e ) ; } int written = output . get written ( ) ; if ( written > avaiable size ) { throw fst . instance ; } system . arraycopy ( output . get buffer ( ) , num , result , result offset , written ) ; return written ; }	will throw an FSTBufferTooSmallException if buffer is too small.
public void set mmf ( file file , file channel file channel , cleaner cleaner ) { this . file = file ; this . file channel = file channel ; this . cleaner = cleaner ; }	hack to update underlying file in slices handed out to app.
public static int get specificity ( final class < ? > clazz ) { if ( clazz == null ) return num ; final lineage info lineage info = fst . get lineage info ( clazz ) ; return lineage info == null ? num : lineage info . specificity ; }	Returns the specificity of the specified class as defined above.
public void resize store ( long required , long maxgrowbytes ) { if ( mapped file == null ) throw new runtime exception ( str + required ) ; if ( required <= memory . length ( ) ) return ; mutation count ++ ; system . out . println ( str + mapped file + str + required + str + num elem ) ; long tim = system . current time millis ( ) ; ( ( mmf ) memory ) . free and close ( ) ; memory = null ; try { file mf = new file ( mapped file ) ; file output stream f = new file output stream ( mf , bool ) ; long len = mf . length ( ) ; required = required + math . min ( required , maxgrowbytes ) ; byte [ ] to write = new byte [ num ] ; long max = ( required - len ) / num ; for ( long i = num ; i < max + num ; i ++ ) { f . write ( to write ) ; } f . flush ( ) ; f . close ( ) ; reset mem ( mapped file , mf . length ( ) ) ; system . out . println ( str + ( system . current time millis ( ) - tim ) + str + num elem ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	PRIVILEGED method. You gotta know what your doing here ..currently a very expensive operation .. frees everything, resize file and remap.Remapping involves rebuild of index.
public void remove binary ( byte source key ) { check thread ( ) ; if ( key . length ( ) != key len ) throw new runtime exception ( str + key len ) ; mutation count ++ ; long rem = index . get ( key ) ; if ( rem != num ) { index . remove ( key ) ; dec elems ( ) ; remove entry ( rem ) ; } }	remove the key from the binary map.
void write string asc ( string name ) throws io { int len = name . length ( ) ; if ( len >= num ) { throw new runtime exception ( str ) ; } write f ( ( byte ) len ) ; buffout . ensure free ( len ) ; if ( asc string cache == null || asc string cache . length < len ) asc string cache = new byte [ len ] ; name . get bytes ( num , len , asc string cache , num ) ; write raw bytes ( asc string cache , num , len ) ; }	length < 127 !!!!!.
@ override public void set outstream ( output stream outstream ) { if ( buffout == null ) {	if output stream is null, just encode into a byte array.
public static fst create json configuration ( boolean pretty print , boolean share references ) { if ( share references && pretty print ) { throw new runtime exception ( str ) ; } return create json configuration ( pretty print , share references , null ) ; }	create a json conf with given attributes.
public static fst create struct configuration ( ) { fst conf = new fst ( null ) ; conf . set struct mode ( bool ) ; return conf ; }	special configuration used internally for struct emulation.
public int calc object size bytes not a ( object obj ) throws io { byte array output stream bout = new byte array output stream ( num ) ; fst ou = new fst ( bout , this ) ; ou . write object ( obj , obj . get class ( ) ) ; ou . close ( ) ; return bout . to byte array ( ) . length ; }	for optimization purposes, do not use to benchmark processing time or in a regular program asthis methods creates a temporary binaryoutputstream and serializes the object in order to measure thesize.
public void clear caches ( ) { try { fst . cached buffer . set ( null ) ; while ( ! cache lock . compare and set ( bool , bool ) ) {	clear cached softref's and ThreadLocal.
public fst get object input ( input stream in ) { fst fst object input = get in ( ) ; try { fst object input . reset for reuse ( in ) ; return fst object input ; } catch ( io e ) { fst . < runtime exception > rethrow ( e ) ; } return null ; }	utility for thread safety and reuse.
public fst get object input ( byte arr [ ] , int len ) { fst fst object input = get in ( ) ; try { fst object input . reset for reuse use array ( arr , len ) ; return fst object input ; } catch ( io e ) { fst . < runtime exception > rethrow ( e ) ; } return null ; }	take the given array as input.
public fst get object input copy from ( byte arr [ ] , int off , int len ) { fst fst object input = get in ( ) ; try { fst object input . reset for reuse copy array ( arr , off , len ) ; return fst object input ; } catch ( io e ) { fst . < runtime exception > rethrow ( e ) ; } return null ; }	take the given array and copy it to input. the array IS copied.
public fst get object output ( output stream out ) { fst fst object output = get out ( ) ; fst object output . reset for re use ( out ) ; return fst object output ; }	utility for thread safety and reuse.
public fst register cross platform class mapping ( string [ ] [ ] keys and vals ) { for ( int i = num ; i < keys and vals . length ; i ++ ) { string [ ] keys and val = keys and vals [ i ] ; register cross platform class mapping ( keys and val [ num ] , keys and val [ num ] ) ; } return this ; }	init right after creation of configuration, not during operation as it is not threadsafe regarding mutationcurrently only for minbin serialization.
public string get cp ( class cl ) { string res = minbin names reverse . get ( cl . get name ( ) ) ; if ( res == null ) { if ( cl . is anonymous class ( ) ) { return get cp ( cl . get superclass ( ) ) ; } return cl . get name ( ) ; } return res ; }	get cross platform symbolic class identifier.
public void write int ( byte type , long data ) { if ( ! min bin . is primitive ( type ) || min bin . is array ( type ) ) throw new runtime exception ( str ) ; write out ( type ) ; write raw int ( type , data ) ; }	write an int type with header.
protected void write raw int ( byte type , long data ) { int num bytes = min bin . extract num bytes ( type ) ; for ( int i = num ; i < num bytes ; i ++ ) { write out ( ( byte ) ( data & num ) ) ; data = data > > > num ; } }	encode int without header tag.
public void write int packed ( long data ) { if ( data <= byte . max value && data >= byte . min value ) write int ( min bin . int 8 , data ) ; else if ( data <= short . max value && data >= short . min value ) write int ( min bin . int 16 , data ) ; else if ( data <= integer . max value && data >= integer . min value ) write int ( min bin . int 32 , data ) ; else if ( data <= long . max value && data >= long . min value ) write int ( min bin . int 64 , data ) ; }	encode int using only as much bytes as needed to represent it.
public void write raw ( byte [ ] buffered name , int i , int length ) { if ( pos + length >= bytez . length - num ) { resize ( ) ; } system . arraycopy ( buffered name , i , bytez , pos , length ) ; pos += length ; }	allow write through to underlying byte for performance reasons.
protected fst . fst get cached fi ( class ... possibles ) { if ( refs == null ) { refs = refs local . get ( ) ; } if ( cur depth >= refs . length ) { return new fst . fst ( possibles , null , bool ) ; } else { fst . fst inf = refs [ cur depth ] ; if ( inf == null ) { inf = new fst . fst ( possibles , null , bool ) ; refs [ cur depth ] = inf ; return inf ; } inf . set possible classes ( possibles ) ; return inf ; } }	avoid creation of dummy ref.
protected void object will be written ( object obj , int stream position ) { if ( listener != null ) { listener . object will be written ( obj , stream position ) ; } }	hook for debugging profiling. register a FSTSerialisationListener to use.
protected void object has been written ( object obj , int old stream position , int stream position ) { if ( listener != null ) { listener . object has been written ( obj , old stream position , stream position ) ; } }	hook for debugging profiling. empty impl, you need to subclass to make use of this hook.
protected fst get fst clazz info ( fst . fst referencee , class clazz ) { fst serialization info = null ; fst last info = referencee . last info ; if ( last info != null && last info . get clazz ( ) == clazz && last info . conf == conf ) { serialization info = last info ; } else { serialization info = get class info registry ( ) . get cl ( clazz , conf ) ; referencee . last info = serialization info ; } return serialization info ; }	if class is same as last referenced, returned cached clzinfo, else do a lookup.
protected void write array ( fst . fst referencee , object array ) throws io { if ( array == null ) { get codec ( ) . write class ( object . class ) ; get codec ( ) . write f ( - num ) ; return ; } final int len = array . get length ( array ) ; class < ? > component type = array . get class ( ) . get component type ( ) ; get codec ( ) . write class ( array . get class ( ) ) ; get codec ( ) . write f ( len ) ; if ( ! component type . is array ( ) ) { if ( get codec ( ) . is primitive array ( array , component type ) ) { get codec ( ) . write primitive array ( array , num , len ) ; } else {	incoming array is already registered.
public void set string ( string s ) { if ( s == null ) { set len ( num ) ; return ; } if ( s . length ( ) > chars len ( ) ) { throw new runtime exception ( str + s . length ( ) + str + chars len ( ) ) ; } for ( int i = num ; i < s . length ( ) ; i ++ ) { chars ( i , s . char at ( i ) ) ; } len = s . length ( ) ; }	modify content of this StructString. The length of the new String must not exceedthe length of internal char array.
@ override public void write primitive array ( object array , int start , int length ) throws io { out . write array ( array , start , length ) ; }	does not write class tag and length.
public fst finish change tracking ( ) { tracker . snapshot changes ( ( int ) get offset ( ) , get base ( ) ) ; fst res = tracker ; tracker = null ; return res ; }	works only if change tracking is enabled.
public void snapshot changes ( int origin base , bytez origin ) { int sum len = num ; for ( int i = num ; i < cur index ; i ++ ) { sum len += change length [ i ] ; } snapshot = new byte [ sum len ] ; int target idx = num ; for ( int i = num ; i < cur index ; i ++ ) { int change offset = change offsets [ i ] ; int len = change length [ i ] ; for ( int ii = num ; ii < len ; ii ++ ) { snapshot [ target idx ++ ] = origin . get ( change offset + ii ) ; } } rebase ( origin base ) ; }	collects all changes and rebases.
public int register object for write ( object o , int stream position , fst clz info , int re use type [ ] ) { if ( disabled ) { return integer . min value ; }	add an object to the register, return handle if already present. Called during write only.
@ override public int to byte array ( object o , byte arr [ ] , int start index , int available size ) { out . reset for re use ( ) ; write target . set base ( arr , start index , available size ) ; try { out . write object ( o ) ; } catch ( io e ) { fst . < runtime exception > rethrow ( e ) ; } int written = out . get written ( ) ; return written ; }	throws FSTBufferTooSmallExcpetion in case object does not fit into given rangeZero Copy method.
@ override public object to object ( byte arr [ ] , int start index , int available size ) { try { in . reset for reuse ( null ) ; read target . set base ( arr , start index , available size ) ; object o = in . read object ( ) ; return o ; } catch ( exception e ) { fst . < runtime exception > rethrow ( e ) ; } return null ; }	throws FSTBufferTooSmallExcpetion in case object does not fit into given range.
public byte [ ] read byte array ( int len ) { if ( available ( ) < len ) { throw new runtime exception ( str ) ; } byte b [ ] = new byte [ len ] ; int count = num ; while ( poll index != add index && count < len ) { b [ count ++ ] = storage . get ( poll index ++ ) ; if ( poll index >= storage . length ( ) ) { poll index = num ; } } return b ; }	convenience method to read len byte array. Throws an excpetion if not enough data is present.
public int read int ( ) { if ( available ( ) < num ) { throw new runtime exception ( str ) ; } int ch1 = poll ( ) ; int ch2 = poll ( ) ; int ch3 = poll ( ) ; int ch4 = poll ( ) ; return ( ch4 << num ) + ( ch3 << num ) + ( ch2 << num ) + ( ch1 << num ) ; }	read an int. throws an exception if not enough data is present.
public void back ( int len ) { if ( poll index >= len ) poll index -= len ; else poll index = poll index + capacity ( ) - len ; }	'unread' len bytes.
public void set thread pool enabled ( boolean value ) { if ( value && ( thread pool == null ) ) { thread pool = executors . new cached thread pool ( ) ; } thread pool enabled = value ; }	Set thread pool enabled.This thread pool is not for the service threads, it is for the user service method.If your service method takes a long time, or will be blocked, please set this property to be true.
public static void start embedded cassandra ( file file , string tmp dir , long timeout ) throws io , configuration exception { if ( cassandra daemon != null ) { return ; } check config name for restart ( file . get absolute path ( ) ) ; log . debug ( str ) ; log . debug ( str ) ; system . set property ( str , str + file . get absolute path ( ) ) ; system . set property ( str , str ) ; system . set property ( str , str ) ;	Set embedded cassandra up and spawn it in a new thread.
public static void clean data embedded cassandra ( string keyspace , string ... excluded tables ) { if ( session != null ) { clean data with native driver ( keyspace , excluded tables ) ; } }	truncate data in keyspace, except specified tables.
private static path copy ( string resource , string directory ) throws io { mkdir ( directory ) ; string file name = resource . substring ( resource . last index of ( str ) + num ) ; input stream from = embedded cassandra server helper . class . get resource as stream ( resource ) ; path copy name = paths . get ( directory , file name ) ; files . copy ( from , copy name ) ; return copy name ; }	Copies a resource from within the jar to a directory.
public static boolean remote port taken ( string node , int port , int timeout ) { socket s = null ; try { s = new socket ( ) ; s . set reuse address ( bool ) ; socket address sa = new inet socket address ( node , port ) ; s . connect ( sa , timeout * num ) ; } catch ( io e ) { if ( e . get message ( ) . equals ( str ) ) { return bool ; } if ( e instanceof socket timeout exception || e instanceof unknown host exception ) { throw e ; } } finally { if ( s != null ) { if ( s . is connected ( ) ) { return bool ; } else { } try { s . close ( ) ; } catch ( io e ) { } } return bool ; } }	Check if a remote port is taken.
public static subscriber state empty ( ) { return subscriber state . builder ( ) . server state ( str ) . stream id ( - num ) . parameter updater status ( collections . empty map ( ) ) . total updates ( - num ) . is master ( bool ) . build ( ) ; }	Returns an empty subscriber statewith -1 as total updates, master as falseand server state as empty.
public static map < string , op descriptor > onnx op descriptors ( ) throws exception { try ( input stream is = new class path resource ( str ) . get input stream ( ) ) { object mapper object mapper = new object mapper ( ) ; onnx descriptor op descriptor = object mapper . read value ( is , onnx descriptor . class ) ; map < string , op descriptor > descriptor map = new hash map < > ( ) ; for ( op descriptor descriptor : op descriptor . get descriptors ( ) ) { descriptor map . put ( descriptor . get name ( ) , descriptor ) ; } return descriptor map ; } }	Get the onnx op descriptors by name.
public list < long [ ] > calculate output shape ( ) { list < long [ ] > ret = new array list < > ( ) ; if ( larg ( ) . get shape ( ) != null && rarg ( ) . get shape ( ) != null ) ret . add ( shape . broadcast output shape ( larg ( ) . get shape ( ) , rarg ( ) . get shape ( ) ) ) ; else if ( larg ( ) . get shape ( ) != null ) ret . add ( larg ( ) . get shape ( ) ) ; return ret ; }	Calculate the output shape for this op.
public static boolean or ( i nd n , condition cond ) { boolean ret = bool ; i nd linear = n . linear view ( ) ; for ( int i = num ; i < linear . length ( ) ; i ++ ) { ret = ret || cond . apply ( linear . get complex ( i ) ) ; } return ret ; }	Or over the whole ndarray given some condition.
public static boolean and ( final ind n , final condition cond ) { if ( cond instanceof base condition ) { long val = ( long ) nd4j . get executioner ( ) . exec ( new match condition ( n , cond ) , integer . max value ) . get double ( num ) ; if ( val == n . length long ( ) ) return bool ; else return bool ; } else { boolean ret = bool ; final atomic boolean a = new atomic boolean ( ret ) ; shape . iterate ( n , new coordinate function ( ) { @ override public void process ( long [ ] ... coord ) { if ( a . get ( ) ) a . compare and set ( bool , a . get ( ) && cond . apply ( n . get double ( coord [ num ] ) ) ) ; } } ) ; return a . get ( ) ; } }	And over the whole ndarray given some condition.
public static boolean [ ] and ( final ind n , final condition condition , int ... dimension ) { if ( ! ( condition instanceof base condition ) ) throw new unsupported operation exception ( str ) ; match condition op = new match condition ( n , condition ) ; ind arr = nd4j . get executioner ( ) . exec ( op , dimension ) ; boolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; long tad length = shape . get tad ( n . shape ( ) , dimension ) ; for ( int i = num ; i < arr . length ( ) ; i ++ ) { if ( arr . get double ( i ) == tad length ) result [ i ] = bool ; else result [ i ] = bool ; } return result ; }	And over the whole ndarray given some condition, with respect to dimensions.
public static boolean [ ] or ( final ind n , final condition condition , int ... dimension ) { if ( ! ( condition instanceof base condition ) ) throw new unsupported operation exception ( str ) ; match condition op = new match condition ( n , condition ) ; ind arr = nd4j . get executioner ( ) . exec ( op , dimension ) ;	Or over the whole ndarray given some condition, with respect to dimensions.
public static void apply where ( final ind to , final condition condition , final number number ) { if ( condition instanceof base condition ) {	This method sets provided number to all elements which match specified condition.
public static ind first index ( ind array , condition condition ) { if ( ! ( condition instanceof base condition ) ) throw new unsupported operation exception ( str ) ; first index idx = new first index ( array , condition ) ; nd4j . get executioner ( ) . exec ( idx ) ; return nd4j . scalar ( ( double ) idx . get final result ( ) ) ; }	This method returns first index matching given conditionPLEASE NOTE: This method will return -1 value if condition wasn't met.
public int as flat properties ( flat buffer builder buffer builder ) { int iname = buffer builder . create string ( name ) ; int ii = flat properties . create i ( buffer builder , ints . to array ( i ) ) ; int il = flat properties . create l ( buffer builder , longs . to array ( l ) ) ; int id = flat properties . create d ( buffer builder , doubles . to array ( d ) ) ; int arrays [ ] = new int [ a . size ( ) ] ; int cnt = num ; for ( val array : a ) { int off = array . to flat array ( buffer builder ) ; arrays [ cnt ++ ] = off ; } int ia = flat properties . create a ( buffer builder , arrays ) ; return flat properties . create flat properties ( buffer builder , iname , ii , il , id , ia ) ; }	This method converts this FunctionProperties instance to FlatBuffers representation.
public static function properties from flat properties ( flat properties properties ) { val props = new function properties ( ) ; for ( int e = num ; e < properties . i length ( ) ; e ++ ) props . get i ( ) . add ( properties . i ( e ) ) ; for ( int e = num ; e < properties . l length ( ) ; e ++ ) props . get l ( ) . add ( properties . l ( e ) ) ; for ( int e = num ; e < properties . d length ( ) ; e ++ ) props . get d ( ) . add ( properties . d ( e ) ) ; for ( int e = num ; e < properties . i length ( ) ; e ++ ) props . get a ( ) . add ( nd4j . create from flat array ( properties . a ( e ) ) ) ; return props ; }	This method creates new FunctionProperties instance from FlatBuffers representation.
public static int as flat properties ( flat buffer builder buffer builder , collection < function properties > properties ) { int props [ ] = new int [ properties . size ( ) ] ; int cnt = num ; for ( val p : properties ) props [ cnt ++ ] = p . as flat properties ( buffer builder ) ; return flat node . create properties vector ( buffer builder , props ) ; }	This method converts multiple FunctionProperties to FlatBuffers representation.
public void set ( throwable t ) { try { lock . write lock ( ) . lock ( ) ; this . t = t ; } finally { lock . write lock ( ) . unlock ( ) ; } }	This method updates state with given Throwable.
public void set if first ( throwable t ) { try { lock . write lock ( ) . lock ( ) ; if ( this . t == null ) this . t = t ; } finally { lock . write lock ( ) . unlock ( ) ; } }	This method updates state only if it wasn't set before.
public static list < double > merge coords ( list < double > x , list < double > y ) { if ( x . size ( ) != y . size ( ) ) throw new illegal argument exception ( str ) ; list < double > ret = new array list < double > ( ) ; for ( int i = num ; i < x . size ( ) ; i ++ ) { ret . add ( x . get ( i ) ) ; ret . add ( y . get ( i ) ) ; } return ret ; }	This will merge the coordinates of the given coordinate system.
public static list < list < double > > partition variable ( list < double > arr , int chunk ) { int count = num ; list < list < double > > ret = new array list < list < double > > ( ) ; while ( count < arr . size ( ) ) { list < double > sublist = arr . sub list ( count , count + chunk ) ; count += chunk ; ret . add ( sublist ) ; }	This will partition the given whole variable data applyTransformToDestination in to the specified chunk number.
public data buffer . type nd4j type from onnx type ( onnx proto3 . tensor proto . data type data type ) { switch ( data type ) { case double : return data buffer . type . double ; case float : return data buffer . type . float ; case floa : return data buffer . type . half ; case in : case in : return data buffer . type . int ; default : return data buffer . type . unknown ; } }	Convert an onnx type to the proper nd4j type.
public void shutdown ( ) { if ( init locker . get ( ) && shutdown locker . compare and set ( bool , bool ) ) {	This method initiates shutdown sequence for this instance.PLEASE NOTE: This method is blocking for first caller only.
public int get current device architecture ( ) { int device id = nd4j . get affinity manager ( ) . get device for current thread ( ) ; if ( ! arch . contains key ( device id ) ) { int major = native ops holder . get instance ( ) . get device native ops ( ) . get device major ( new cuda pointer ( device id ) ) ; int minor = native ops holder . get instance ( ) . get device native ops ( ) . get device minor ( new cuda pointer ( device id ) ) ; integer cc = integer . parse int ( new string ( str + major + minor ) ) ; arch . put ( device id , cc ) ; return cc ; } return arch . get ( device id ) ; }	Get the current device architecture.
public static ind col2im ( ind col , int sy , int sx , int ph , int pw , int h , int w ) { if ( col . rank ( ) != num ) throw new illegal argument exception ( str ) ; ind output = nd4j . create ( new long [ ] { col . size ( num ) , col . size ( num ) , h , w } ) ; col2 im col2 im = col2 im . builder ( ) . input arrays ( new ind [ ] { col } ) . outputs ( new ind [ ] { output } ) . conv2 d ( d . builder ( ) . sy ( sy ) . sx ( sx ) . dw ( num ) . dh ( num ) . kh ( h ) . kw ( w ) . ph ( ph ) . pw ( pw ) . build ( ) ) . build ( ) ; nd4j . get executioner ( ) . exec ( col2 im ) ; return col2 im . output arguments ( ) [ num ] ; }	Rearrange matrixcolumns into blocks.
public static ind pooling2 d ( ind img , int kh , int kw , int sy , int sx , int ph , int pw , int dh , int dw , boolean is same mode , d . d type , d . divisor divisor , double extra , int virtual height , int virtual width , ind out ) { d pooling = d . builder ( ) . array inputs ( new ind [ ] { img } ) . array outputs ( new ind [ ] { out } ) . config ( d . builder ( ) . dh ( dh ) . dw ( dw ) . extra ( extra ) . kh ( kh ) . kw ( kw ) . ph ( ph ) . pw ( pw ) . is same mode ( is same mode ) . sx ( sx ) . sy ( sy ) . virtual height ( virtual height ) . virtual width ( virtual width ) . type ( type ) . divisor ( divisor ) . build ( ) ) . build ( ) ; nd4j . get executioner ( ) . exec ( pooling ) ; return out ; }	Pooling 2d implementation.
public static compression descriptor from byte buffer ( byte buffer byte buffer ) { compression descriptor compression descriptor = new compression descriptor ( ) ;	Instantiate a compression descriptor fromthe given bytebuffer.
public static < u extends aggregate > list < batch < u > > get batches ( list < u > list , int partition size ) { list < list < u > > partitions = lists . partition ( list , partition size ) ; list < batch < u > > split = new array list < > ( ) ; for ( list < u > partition : partitions ) { split . add ( new batch < u > ( partition ) ) ; } return split ; }	Helper method to create batch from list of aggregates, for cases when list of aggregates is higher then batchLimit.
protected static void validate concat ( int dimension , ind ... arrs ) { if ( arrs [ num ] . is scalar ( ) ) { for ( int i = num ; i < arrs . length ; i ++ ) if ( ! arrs [ i ] . is scalar ( ) ) throw new illegal argument exception ( str ) ; } else { int dims = arrs [ num ] . shape ( ) . length ; long [ ] shape = array util . remove index ( arrs [ num ] . shape ( ) , dimension ) ; for ( int i = num ; i < arrs . length ; i ++ ) { assert arrays . equals ( shape , array util . remove index ( arrs [ i ] . shape ( ) , dimension ) ) ; assert arrs [ i ] . shape ( ) . length == dims ; } } }	input arrays must have same number of dimensions.
@ override public void set d ( data buffer . type dtype ) { assert dtype == data buffer . type . double || dtype == data buffer . type . float || dtype == data buffer . type . int : str ;	Sets the data opType.
@ override public ind linspace ( int lower , int upper , int num ) { double [ ] data = new double [ num ] ; for ( int i = num ; i < num ; i ++ ) { double t = ( double ) i / ( num - num ) ; data [ i ] = lower * ( num - t ) + t * upper ; }	Generate a linearly spaced vector.
@ override public ind to flattened ( collection < ind > matrices ) { int length = num ; for ( ind m : matrices ) length += m . length ( ) ; ind ret = nd4j . create ( num , length ) ; int linear index = num ; for ( ind d : matrices ) { ret . put ( new ind [ ] { nd . interval ( linear index , linear index + d . length ( ) ) } , d ) ; linear index += d . length ( ) ; } return ret ; }	Returns a vector with all of the elements in every nd arrayequal to the sum of the lengths of the ndarrays.
@ override public ind bilinear products ( ind curr , ind in ) { assert curr . shape ( ) . length == num ; if ( in . columns ( ) != num ) { throw new assertion error ( str ) ; } if ( in . rows ( ) != curr . size ( curr . shape ( ) . length - num ) ) { throw new assertion error ( str ) ; } if ( curr . size ( curr . shape ( ) . length - num ) != curr . size ( curr . shape ( ) . length - num ) ) { throw new assertion error ( str ) ; } ind ret = nd4j . create ( curr . slices ( ) , num ) ; ind in t = in . transpose ( ) ; for ( int i = num ; i < curr . slices ( ) ; i ++ ) { ind slice = curr . slice ( i ) ; ind in t = in t . mmul ( slice ) ; ret . put scalar ( i , nd4j . get blas wrapper ( ) . dot ( in t , in ) ) ; } return ret ; }	Returns a column vector where each entry is the nth bilinearproduct of the nth slices of the two tensors.
@ override public i nd create complex ( double [ ] data ) { assert data . length % num == num : str ; return create complex ( data , new int [ ] { num , data . length / num } ) ; }	Creates an ndarray with the specified data.
@ override public i nd complex value of ( int num , double value ) { i nd ones = complex ones ( num ) ; ones . assign ( nd4j . create double ( value , num ) ) ; return ones ; }	Creates an 1 x num ndarray with the specified value.
@ override public i nd complex value of ( int [ ] shape , double value ) { i nd ones = complex ones ( shape ) ; ones . assign ( nd4j . scalar ( value ) ) ; return ones ; }	Creates an shape ndarray with the specified value.
@ override public boolean should replicate ( ) { long now = system . current time millis ( ) ; long diff = math . abs ( now - last synced ) ; return diff > sync time ; }	Returns true ifthe updater has accumulated enough ndarrays toreplicate to the workers.
@ override public i subi ( i c , i result ) { return result . set ( real component ( ) . double value ( ) - c . real component ( ) . double value ( ) , imaginary component ( ) . double value ( ) - c . imaginary component ( ) . double value ( ) ) ; }	Subtract two complex numbers, in-place.
public static i atan ( i num ) { complex c = new complex ( num . real component ( ) . double value ( ) , num . imaginary component ( ) . double value ( ) ) . atan ( ) ; return nd4j . create double ( c . get real ( ) , c . get imaginary ( ) ) ; }	Return the sin value of the given complex number.
public static i ceil ( i num ) { complex c = new complex ( fast math . ceil ( num . real component ( ) . double value ( ) ) , fast math . ceil ( num . imaginary component ( ) . double value ( ) ) ) ; return nd4j . create double ( c . get real ( ) , c . get imaginary ( ) ) ; }	Return the ceiling value of the given complex number.
public static i neg ( i num ) { complex c = new complex ( num . real component ( ) . double value ( ) , num . imaginary component ( ) . double value ( ) ) . negate ( ) ; return nd4j . create double ( c . get real ( ) , c . get imaginary ( ) ) ; }	Return the log value of the given complex number.
public static i abs ( i num ) { double c = new complex ( num . real component ( ) . double value ( ) , num . imaginary component ( ) . double value ( ) ) . abs ( ) ; return nd4j . create double ( c , num ) ; }	Return the absolute value of the given complex number.
public static i pow ( i num , i power ) { complex c = new complex ( num . real component ( ) . double value ( ) , num . imaginary component ( ) . double value ( ) ) . pow ( new complex ( power . real component ( ) . double value ( ) , power . imaginary component ( ) . double value ( ) ) ) ; if ( c . is na n ( ) ) c = new complex ( nd4j . eps threshold , num ) ; return nd4j . create double ( c . get real ( ) , c . get imaginary ( ) ) ; }	Raise a complex number to a power.
@ override public void binarize ( double cutoff ) { ind linear = get feature matrix ( ) . linear view ( ) ; for ( int i = num ; i < get features ( ) . length ( ) ; i ++ ) { double curr = linear . get double ( i ) ; if ( curr > cutoff ) get features ( ) . put scalar ( i , num ) ; else get features ( ) . put scalar ( i , num ) ; } }	Binarizes the dataset such that any number greater than cutoff is 1 otherwise zero.
@ override public data set sample ( int num samples , org . nd4j . linalg . api . rng . random rng , boolean with replacement ) { ind examples = nd4j . create ( num samples , get features ( ) . columns ( ) ) ; ind outcomes = nd4j . create ( num samples , num outcomes ( ) ) ; set < integer > added = new hash set < > ( ) ; for ( int i = num ; i < num samples ; i ++ ) { int picked = rng . next int ( num examples ( ) ) ; if ( ! with replacement ) while ( added . contains ( picked ) ) picked = rng . next int ( num examples ( ) ) ; examples . put row ( i , get ( picked ) . get features ( ) ) ; outcomes . put row ( i , get ( picked ) . get labels ( ) ) ; } return new data set ( examples , outcomes ) ; }	Sample a dataset.
@ override public long get memory footprint ( ) { long req mem = features . length long ( ) * nd4j . size of data type ( ) ; req mem += labels == null ? num : labels . length long ( ) * nd4j . size of data type ( ) ; req mem += features mask == null ? num : features mask . length long ( ) * nd4j . size of data type ( ) ; req mem += labels mask == null ? num : labels mask . length long ( ) * nd4j . size of data type ( ) ; return req mem ; }	This method returns memory used by this DataSet.
public static string stringify exception ( throwable e ) { string writer stm = new string writer ( ) ; print writer wrt = new print writer ( stm ) ; e . print stack trace ( wrt ) ; wrt . close ( ) ; return stm . to string ( ) ; }	Make a string representation of the exception.
public static string simple hostname ( string full hostname ) { if ( inet addresses . is inet address ( full hostname ) ) { return full hostname ; } int offset = full hostname . index of ( str ) ; if ( offset != - num ) { return full hostname . substring ( num , offset ) ; } return full hostname ; }	Given a full hostname, return the word upto the first dot.
public static string array to string ( string [ ] strs ) { if ( strs . length == num ) { return str ; } string builder sbuf = new string builder ( ) ; sbuf . append ( strs [ num ] ) ; for ( int idx = num ; idx < strs . length ; idx ++ ) { sbuf . append ( str ) ; sbuf . append ( strs [ idx ] ) ; } return sbuf . to string ( ) ; }	Given an array of strings, return a comma-separated list of its elements.
public static string byte to hex string ( byte [ ] bytes , int start , int end ) { if ( bytes == null ) { throw new illegal argument exception ( str ) ; } string builder s = new string builder ( ) ; for ( int i = start ; i < end ; i ++ ) { s . append ( format ( str , bytes [ i ] ) ) ; } return s . to string ( ) ; }	Given an array of bytes it will convert the bytes to a hex stringrepresentation of the bytes.
public static string [ ] get strings ( string str , string delim ) { collection < string > values = get string collection ( str , delim ) ; if ( values . size ( ) == num ) { return null ; } return values . to array ( new string [ values . size ( ) ] ) ; }	Returns an arraylist of strings.
public static string [ ] split ( string str , char escape char , char separator ) { if ( str == null ) { return null ; } array list < string > str list = new array list < string > ( ) ; string builder split = new string builder ( ) ; int index = num ; while ( ( index = find next ( str , separator , escape char , index , split ) ) >= num ) { ++ index ;	Split a string using the given separator.
public static string [ ] split ( string str , char separator ) {	Split a string using the given separator, with no escaping performed.
public static int find next ( string str , char separator , char escape char , int start , string builder split ) { int num pre escapes = num ; for ( int i = start ; i < str . length ( ) ; i ++ ) { char cur char = str . char at ( i ) ; if ( num pre escapes == num && cur char == separator ) {	Finds the first occurrence of the separator character ignoring the escapedseparators starting from the index.
public static string escape html ( string string ) { if ( string == null ) { return null ; } string builder sb = new string builder ( ) ; boolean last character was space = bool ; char [ ] chars = string . to char array ( ) ; for ( char c : chars ) { if ( c == str ) { if ( last character was space ) { last character was space = bool ; sb . append ( str ) ; } else { last character was space = bool ; sb . append ( str ) ; } } else { last character was space = bool ; switch ( c ) { case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; default : sb . append ( c ) ; break ; } } } return sb . to string ( ) ; }	Escapes HTML Special characters present in the string.
public static string join ( char sequence separator , iterable < ? > strings ) { iterator < ? > i = strings . iterator ( ) ; if ( ! i . has next ( ) ) { return str ; } string builder sb = new string builder ( i . next ( ) . to string ( ) ) ; while ( i . has next ( ) ) { sb . append ( separator ) ; sb . append ( i . next ( ) . to string ( ) ) ; } return sb . to string ( ) ; }	Concatenates strings, using a separator.
public static string camelize ( string s ) { string builder sb = new string builder ( ) ; string [ ] words = split ( string utils . to lower case ( s ) , escape char , str ) ; for ( string word : words ) sb . append ( org . apache . commons . lang3 . string utils . capitalize ( word ) ) ; return sb . to string ( ) ; }	Convert SOME_STUFF to SomeStuff.
public static string get stack trace ( thread t ) { final stack trace element [ ] stack trace = t . get stack trace ( ) ; string builder str = new string builder ( ) ; for ( stack trace element e : stack trace ) { str . append ( e . to string ( ) + str ) ; } return str . to string ( ) ; }	Get stack trace for a given thread.
public static ind invert ( ind arr , boolean in place ) { if ( ! arr . is square ( ) ) { throw new illegal argument exception ( str ) ; }	Inverts a matrix.
public big integer at ( int n ) { while ( a . size ( ) <= n ) { final int lastn = a . size ( ) - num ; final big integer nextn = big integer . value of ( lastn + num ) ; a . add ( a . get ( lastn ) . multiply ( nextn ) ) ; } return a . get ( n ) ; }	Compute the factorial of the non-negative integer.
public boolean is actual on host side ( ) {	This method returns, if host side has actual copy of data.
public boolean is actual on device side ( ) {	This method returns, if device side has actual copy of data.
@ override public pair < data buffer , long [ ] > create shape information ( int [ ] shape ) { char order = nd4j . order ( ) ; return create shape information ( shape , order ) ; }	This method creates shapeInformation buffer, based on shape being passed in.
@ override public pair < data buffer , long [ ] > create shape information ( long [ ] shape , char order ) { long [ ] stride = nd4j . get strides ( shape , order ) ;	This method creates shapeInformation buffer, based on shape & order being passed in.
public static boolean is vector ( data buffer shape info ) { int rank = shape . rank ( shape info ) ; if ( rank > num || rank < num ) return bool ; else { int len = shape . length ( shape info ) ; data buffer shape = shape . shape of ( shape info ) ; return shape . get int ( num ) == len || shape . get int ( num ) == len ; } }	Returns whether the given shape is a vector.
public static char get order ( ind arr ) { return get order ( arr . shape ( ) , arr . stride ( ) , arr . element stride ( ) ) ; }	Infer the order for the ndarray based on thearray's strides.
public static long offset for ( ind arr , int [ ] indexes ) { shape offset resolution resolution = new shape offset resolution ( arr ) ; resolution . exec ( shape . to indexes ( indexes ) ) ; return resolution . get offset ( ) ; }	Compute the offset for the given arraygiven the indices.
public static ind [ ] to indexes ( int [ ] indices ) { ind [ ] ret = new ind [ indices . length ] ; for ( int i = num ; i < ret . length ; i ++ ) ret [ i ] = new nd ( indices [ i ] ) ; return ret ; }	Convert the given int indexesto nd array indexes.
protected short get short ( long i ) { if ( data type ( ) != type . half ) throw new unsupported operation exception ( str ) ; return from float ( ( ( half indexer ) indexer ) . get ( offset ( ) + i ) ) ; }	Special method for.
@ override public data buffer reallocate ( long length ) { pointer old pointer = pointer ; if ( is attached ( ) ) { long capacity = length * get element size ( ) ; switch ( data type ( ) ) { case double : pointer = get parent workspace ( ) . alloc ( capacity , type . double , bool ) . as double pointer ( ) ; indexer = double indexer . create ( ( double pointer ) pointer ) ; break ; case float : pointer = get parent workspace ( ) . alloc ( capacity , type . float , bool ) . as float pointer ( ) ; indexer = float indexer . create ( ( float pointer ) pointer ) ; break ; case int : pointer = get parent workspace ( ) . alloc ( capacity , type . int , bool ) . as int pointer ( ) ; indexer = int indexer . create ( ( int pointer ) pointer ) ; break ; } workspace generation id = get parent workspace ( ) . get generation id ( ) ; } else { switch ( data type ( ) ) { case int : pointer = new int pointer ( length ) ; indexer = int indexer . create ( ( int pointer ) pointer ) ; break ; case double : pointer = new double pointer ( length ) ; indexer = double indexer . create ( ( double pointer ) pointer ) ; break ; case float : pointer = new float pointer ( length ) ; indexer = float indexer . create ( ( float pointer ) pointer ) ; break ; } } pointer . memcpy ( pointer , old pointer , this . length ( ) * get element size ( ) ) ;	Reallocate the native memory of the buffer.
public static void copy at stride ( int n , buffer type buffer type , byte buffer from , int from offset , int from stride , byte buffer to , int to offset , int to stride ) {	Copy from the given from bufferto the to buffer at the specifiedoffsets and strides.
@ override public data buffer get constant buffer ( float [ ] array ) {	This method returns DataBuffer with contant equal to input array.PLEASE NOTE: This method assumes that you'll never ever change values within result DataBuffer.
public string kafka uri ( ) { return string . format ( str , kafka broker list , topic name , group id , zookeeper host , zookeeper port , string encoder . class . get name ( ) , string encoder . class . get name ( ) ) ; }	Returns a kafka connection uri.
public static ind pow ( ind nd array , ind power , boolean dup ) { ind result = ( dup ? nd4j . create ( nd array . shape ( ) , nd array . ordering ( ) ) : nd array ) ; return exec ( new pow ( nd array , power , result , nd array . length ( ) , num ) ) ; }	Element-wise power function - x^y, performed element-wise.
public static ind log ( ind nd array , double base , boolean duplicate ) { return nd4j . get executioner ( ) . exec ( new x ( duplicate ? nd array . dup ( nd array . ordering ( ) ) : nd array , base ) ) . z ( ) ; }	Log on arbitrary base.
public static ind max ( ind nd array , double k , boolean dup ) { return exec ( dup ? new scalar max ( nd array . dup ( ) , k ) : new scalar max ( nd array , k ) ) ; }	Maximum function with a scalar.
public static ind max ( ind first , ind second , boolean dup ) { if ( dup ) { first = first . dup ( ) ; } return exec ( new old max ( second , first , first , first . length ( ) ) ) ; }	Element wise maximum function between 2 INDArrays.
public static ind min ( ind nd array , double k , boolean dup ) { return exec ( dup ? new scalar min ( nd array . dup ( ) , k ) : new scalar min ( nd array , k ) ) ; }	Minimum function with a scalar.
public static ind min ( ind first , ind second , boolean dup ) { if ( dup ) { first = first . dup ( ) ; } return exec ( new old min ( second , first , first , first . length ( ) ) ) ; }	Element wise minimum function between 2 INDArrays.
public static ind stabilize ( ind nd array , double k , boolean dup ) { return exec ( dup ? new stabilize ( nd array , nd array . dup ( ) , k ) : new stabilize ( nd array , k ) ) ; }	Stabilize to be within a range of k.
public static ind expm1 ( ind nd array , boolean dup ) { return exec ( dup ? new expm1 ( nd array , nd array . dup ( ) ) : new expm1 ( nd array ) ) ; }	Elementwise exponential - 1 function.
public static ind log1p ( ind nd array , boolean dup ) { return exec ( dup ? new log1p ( nd array , nd array . dup ( ) ) : new log1p ( nd array ) ) ; }	Log of x + 1 function.
public static ind [ ] prepare bounds ( ind bounds , ind x ) { return new ind [ ] { nd4j . value array of ( x . shape ( ) , bounds . get double ( num ) ) , nd4j . value array of ( x . shape ( ) , bounds . get double ( num ) ) } ; }	Prepare the boundaries for processing.
@ override public data set next ( ) { if ( ! iter . has next ( ) && passes < num passes ) { passes ++ ; batch = num ; log . info ( str + passes + str + batch ) ; iter . reset ( ) ; } batch ++ ; data set next = iter . next ( ) ; if ( pre processor != null ) pre processor . pre process ( next ) ; return next ; }	Returns the next element in the iteration.
public static allocation shape build allocation shape ( data buffer buffer ) { allocation shape shape = new allocation shape ( ) ; shape . set stride ( num ) ; shape . set offset ( buffer . original offset ( ) ) ; shape . set data type ( buffer . data type ( ) ) ; shape . set length ( buffer . length ( ) ) ; return shape ; }	This method returns AllocationShape for the whole DataBuffer.
public static boolean name exists in path ( string name ) { string path = system . getenv ( path env variable ) ; string [ ] dirs = path . split ( file . path separator ) ; for ( string dir : dirs ) { file dir file = new file ( dir ) ; if ( ! dir file . exists ( ) ) continue ; if ( dir file . is file ( ) && dir file . get name ( ) . equals ( name ) ) return bool ; else { iterator < file > files = file utils . iterate files ( dir file , null , bool ) ; while ( files . has next ( ) ) { file curr = files . next ( ) ; if ( curr . get name ( ) . equals ( name ) ) return bool ; } } } return bool ; }	Check if a file exists in the path.
protected void read ( object input stream s ) throws io , class not found exception { data = nd4j . create buffer ( length , bool ) ; data . read ( s ) ; }	Custom deserialization for Java serialization.
protected void sweep tail ( ) { integer device id = allocator . get device id ( ) ; int cnt = num ;	This method ensures the events in the beginning of FIFO queues are finished.
@ override public ind create from npy pointer ( pointer pointer ) { pointer data pointer = native ops . data point for numpy ( pointer ) ; int data buffer element size = native ops . element size for npy array ( pointer ) ; data buffer data = null ; pointer shape buffer pointer = native ops . shape buffer for numpy ( pointer ) ; int length = native ops . length for shape buffer pointer ( shape buffer pointer ) ; shape buffer pointer . capacity ( num * length ) ; shape buffer pointer . limit ( num * length ) ; shape buffer pointer . position ( num ) ; val int pointer = new long pointer ( shape buffer pointer ) ; data buffer shape buffer = nd4j . create buffer ( shape buffer pointer , data buffer . type . long , length , long raw indexer . create ( int pointer ) ) ; data pointer . position ( num ) ; data pointer . limit ( data buffer element size * shape . length ( shape buffer ) ) ; data pointer . capacity ( data buffer element size * shape . length ( shape buffer ) ) ;	Create from an in memory numpy pointer.
@ override public ind create from npy file ( file file ) { byte [ ] path bytes = file . get absolute path ( ) . get bytes ( charset . for name ( str ) ) ; string other bytes = new string ( path bytes ) ; system . out . println ( other bytes ) ; byte buffer direct buffer = byte buffer . allocate direct ( path bytes . length ) . order ( byte order . native order ( ) ) ; direct buffer . put ( path bytes ) ; direct buffer . rewind ( ) ; direct buffer . position ( num ) ; pointer pointer = native ops . numpy from file ( new byte pointer ( direct buffer ) ) ; ind result = create from npy pointer ( pointer ) ;	Create from a given numpy file.
@ override public paged pointer alloc ( long required memory , memory kind kind , data buffer . type data type , boolean initialize ) { throw new unsupported operation exception ( str ) ; }	This method does allocation from a given Workspace.
@ override public void attach object ( object object ) { if ( ! object locks . contains key ( object ) ) object locks . put ( object , new reentrant read write lock ( ) ) ; }	This method notifies locker, that specific object was added to tracking list.
public boolean started ( ) { return master . equals ( server state . started . name ( ) . to lower case ( ) ) && responder . equals ( server state . started . name ( ) . to lower case ( ) ) ; }	Returns true if bththe master and responder are started.
@ override public op exec ( op op ) { check for compression ( op ) ; invoke watchdog ( op ) ; if ( op instanceof accumulation ) { exec ( ( accumulation ) op , new int [ ] { integer . max value } ) ; } else if ( op instanceof index accumulation ) { exec ( ( index accumulation ) op , new int [ ] { integer . max value } ) ; } else if ( op instanceof scalar op || op instanceof transform op ) {	This is one of the main entry points for ops that are executed without respect to dimension.Developers note: For CudaGridExecutioner that's also the MetaOp/GridOp creation point.
@ override public void flush queue blocking ( ) { flush queue ( ) ;	This method forces all currently enqueued ops to be executed immediatelyPLEASE NOTE: This call is always blocking, until all queued operations are finished.
public input stream get input stream ( ) throws file not found exception { url url = this . get url ( ) ; if ( is jar url ( url ) ) { try { url = extract actual url ( url ) ; zip file zip file = new zip file ( url . get file ( ) ) ; zip entry entry = zip file . get entry ( this . resource name ) ; input stream stream = zip file . get input stream ( entry ) ; return stream ; } catch ( exception e ) { throw new runtime exception ( e ) ; } } else { file src file = this . get file ( ) ; return new file input stream ( src file ) ; } }	Returns requested ClassPathResource as InputStream object.
@ override public integer get device for thread ( long thread id ) { if ( get number of devices ( ) == num ) return num ; integer aff = affinity map . get ( thread id ) ; if ( aff == null ) { integer device id = get next device ( thread id ) ; affinity map . put ( thread id , device id ) ; affiliated . set ( new atomic boolean ( bool ) ) ; if ( thread id == thread . current thread ( ) . get id ( ) ) { native ops holder . get instance ( ) . get device native ops ( ) . set device ( new cuda pointer ( device id ) ) ;	This method returns deviceId for given thread, identified by threadIdIf no device was assigned to this thread before this call, it'll be assinged here.
@ override public void attach thread to device ( long thread id , integer device id ) { list < integer > devices = new array list < > ( cuda environment . get instance ( ) . get configuration ( ) . get available devices ( ) ) ; logger . debug ( str , thread id , device id , devices . size ( ) ) ; affinity map . put ( thread id , device id ) ; }	This method pairs specified thread & device.
protected integer get next device ( long thread id ) { integer device = null ; if ( ! cuda environment . get instance ( ) . get configuration ( ) . is forced single gpu ( ) && get number of devices ( ) > num ) {	This method returns device id available.
public static string get os name ( ) { os os type = calculate os ( ) ; switch ( os type ) { case apple : return str ; case linux : return str ; case sun : return str ; case windows : return str ; } return str ; }	Get the name of the osfor libary discovery on the classpath.
public static arch calculate arch ( ) { string os arch = system . get property ( str ) ; os arch = os arch . to lower case ( locale . english ) ; if ( os arch . equals ( str ) || os arch . equals ( str ) || os arch . equals ( str ) ) { return arch . x86 ; } if ( os arch . starts with ( str ) || os arch . starts with ( str ) ) { return arch . 64 ; } if ( os arch . equals ( str ) || os arch . equals ( str ) ) { return arch . ppc ; } if ( os arch . starts with ( str ) ) { return arch . ppc 64 ; } if ( os arch . starts with ( str ) ) { return arch . sparc ; } if ( os arch . starts with ( str ) ) { return arch . arm ; } if ( os arch . starts with ( str ) ) { return arch . mips ; } if ( os arch . contains ( str ) ) { return arch . risc ; } return arch . unknown ; }	Calculates the current ARCHType.
public void publish ( ind arr ) { if ( producer template == null ) producer template = camel context . create producer template ( ) ; producer template . send body ( str , arr ) ; }	Publish to a kafka topicbased on the connection information.
@ override public data buffer create ( pointer pointer , data buffer . type type , long length , indexer indexer ) { switch ( type ) { case int : return new int buffer ( pointer , indexer , length ) ; case double : return new double buffer ( pointer , indexer , length ) ; case float : return new float buffer ( pointer , indexer , length ) ; case long : return new long buffer ( pointer , indexer , length ) ; } throw new illegal argument exception ( str + type ) ; }	Create a data buffer based on thegiven pointer, data buffer opType,and length of the buffer.
protected void intercept int data type ( op op ) {	This method checks if any Op operand has data opType of INT, and throws exception if any.
@ override public i addi ( i c , i result ) { return result . set ( result . real component ( ) . float value ( ) + c . real component ( ) . float value ( ) , result . imaginary component ( ) . float value ( ) + c . imaginary component ( ) . float value ( ) ) ; }	Add two complex numbers in-place.
@ override public void process message ( ) { if ( payload != null ) {	This method assigns specific value to either specific row, or whole array.Array is identified by key.
public sd avg pooling3d ( sd [ ] inputs , d pooling3 d ) { d max pooling3 d = d . builder ( ) . inputs ( inputs ) . same diff ( same diff ( ) ) . pooling3 d ( pooling3 d ) . type ( d . d . avg ) . build ( ) ; return max pooling3 d . output variables ( ) [ num ] ; }	Avg pooling 3d operation.
public sd depth wise conv2d ( sd [ ] inputs , d depth conv2 d ) { s d depth wise conv2 d = s d . s builder ( ) . input functions ( inputs ) . same diff ( same diff ( ) ) . conv2 d ( depth conv2 d ) . build ( ) ; return depth wise conv2 d . output variables ( ) [ num ] ; }	Depthwise Conv2d operation. This is just separable convolution withonly the depth-wise weights specified.
public void reset ( ) { invocations count . set ( num ) ; class aggergator . reset ( ) ; long aggergator . reset ( ) ; class counter . reset ( ) ; op counter . reset ( ) ; class pairs counter . reset ( ) ; op pairs counter . reset ( ) ; matching counter . reset ( ) ; matching counter detailed . reset ( ) ; matching counter inverted . reset ( ) ; methods aggregator . reset ( ) ; scalar aggregator . reset ( ) ; non ews aggregator . reset ( ) ; strided aggregator . reset ( ) ; tad non ews aggregator . reset ( ) ; tad strided aggregator . reset ( ) ; mixed order aggregator . reset ( ) ; blas aggregator . reset ( ) ; blas order counter . reset ( ) ; order counter . reset ( ) ; listeners . clear ( ) ; }	This method resets all counters.
protected string get op class ( op op ) { if ( op instanceof scalar op ) { return str ; } else if ( op instanceof meta op ) { return str ; } else if ( op instanceof grid op ) { return str ; } else if ( op instanceof broadcast op ) { return str ; } else if ( op instanceof random op ) { return str ; } else if ( op instanceof accumulation ) { return str ; } else if ( op instanceof transform op ) { if ( op . y ( ) == null ) { return str ; } else return str ; } else if ( op instanceof index accumulation ) { return str ; } else if ( op instanceof custom op ) { return str ; } else return str ; }	This method returns op class opName.
public ind store and allocate new array ( ) { val shape = same diff . get shape for var name ( get var name ( ) ) ; if ( get arr ( ) != null && arrays . equals ( get arr ( ) . shape ( ) , shape ) ) return get arr ( ) ; if ( var name == null ) throw new n j ( str ) ; if ( shape == null ) { throw new n j ( str + var name ) ; } val arr = get weight init scheme ( ) . create ( shape ) ; same diff . put array for var name ( get var name ( ) , arr ) ; return arr ; }	Allocate and return a new arraybased on the vertex id and weight initialization.
public long [ ] get shape ( ) { long [ ] initial shape = same diff . get shape for var name ( get var name ( ) ) ; if ( initial shape == null ) { val arr = get arr ( ) ; if ( arr != null ) return arr . shape ( ) ; } return initial shape ; }	Returns the shape of this variable.
public ind eval ( ) { same diff exec = same diff . dup ( ) ; exec . define function ( str , new same diff . same diff function definition ( ) { @ override public sd [ ] define ( same diff same diff , map < string , ind > inputs , sd [ ] variable inputs ) { return new sd [ ] { sd . this } ; } } ) ; sd output = exec . invoke function on ( str , exec ) ; return output . get same diff ( ) . exec and end result ( ) ; }	Evaluate the result of this variable.
@ override public ind compress ( double [ ] data , int [ ] shape , char order ) { double pointer pointer = new double pointer ( data ) ; data buffer shape info = nd4j . get shape info provider ( ) . create shape information ( shape , order ) . get first ( ) ; data buffer buffer = compress pointer ( data buffer . type ex . double , pointer , data . length , num ) ; return nd4j . create array from shape buffer ( buffer , shape info ) ; }	This method creates compressed INDArray from Java double array, skipping usual INDArray instantiation routines.
public static i nd expi ( i nd to exp ) { i nd flattened = to exp . ravel ( ) ; for ( int i = num ; i < flattened . length ( ) ; i ++ ) { i n = flattened . get complex ( i ) ; flattened . put ( i , nd4j . scalar ( complex util . exp ( n ) ) ) ; } return flattened . reshape ( to exp . shape ( ) ) ; }	Returns the exponential of a complex ndarray.
public static i nd center ( i nd arr , long [ ] shape ) { if ( arr . length ( ) < array util . prod ( shape ) ) return arr ; for ( int i = num ; i < shape . length ; i ++ ) if ( shape [ i ] < num ) shape [ i ] = num ; ind shape matrix = nd . to nd ( shape ) ; ind curr shape = nd . to nd ( arr . shape ( ) ) ; ind start index = transforms . floor ( curr shape . sub ( shape matrix ) . divi ( nd4j . scalar ( num ) ) ) ; ind end index = start index . add ( shape matrix ) ; ind [ ] indexes = indices . create from start and end ( start index , end index ) ; if ( shape matrix . length ( ) > num ) return arr . get ( indexes ) ; else { i nd ret = nd4j . create complex ( new int [ ] { ( int ) shape matrix . get double ( num ) } ) ; int start = ( int ) start index . get double ( num ) ; int end = ( int ) end index . get double ( num ) ; int count = num ; for ( int i = start ; i < end ; i ++ ) { ret . put scalar ( count ++ , arr . get complex ( i ) ) ; } return ret ; } }	Center an array.
public static i nd truncate ( i nd nd , int n , int dimension ) { if ( nd . is vector ( ) ) { i nd truncated = nd4j . create complex ( new int [ ] { num , n } ) ; for ( int i = num ; i < n ; i ++ ) truncated . put scalar ( i , nd . get complex ( i ) ) ; return truncated ; } if ( nd . size ( dimension ) > n ) { long [ ] shape = array util . copy ( nd . shape ( ) ) ; shape [ dimension ] = n ; i nd ret = nd4j . create complex ( shape ) ; i nd nd linear = nd . linear view ( ) ; i nd ret linear = ret . linear view ( ) ; for ( int i = num ; i < ret . length ( ) ; i ++ ) ret linear . put scalar ( i , nd linear . get complex ( i ) ) ; return ret ; } return nd ; }	Truncates an ndarray to the specified shape.If the shape is the same or greater, it just returnsthe original array.
public static i nd pad with zeros ( i nd nd , long [ ] target shape ) { if ( arrays . equals ( nd . shape ( ) , target shape ) ) return nd ;	Pads an ndarray with zeros.
@ override public int iamax ( ind arr ) { switch ( arr . data ( ) . data type ( ) ) { case double : default op executioner . validate data type ( data buffer . type . double , arr ) ; return idamax ( arr . length ( ) , arr , num ) ; case float : default op executioner . validate data type ( data buffer . type . float , arr ) ; return isamax ( arr . length ( ) , arr , num ) ; case half : default op executioner . validate data type ( data buffer . type . half , arr ) ; return ihamax ( arr . length ( ) , arr , num ) ; default : } throw new unsupported operation exception ( ) ; }	Find the index of the element with maximum absolute value.
public void broadcast ( ind array ) { if ( array == null ) return ; nd4j . get executioner ( ) . commit ( ) ; int num devices = nd4j . get affinity manager ( ) . get number of devices ( ) ; for ( int i = num ; i < num devices ; i ++ ) {	This method duplicates array, and stores it to all devices.
@ override public void process message ( ) { vector aggregation aggregation = new vector aggregation ( row index , ( short ) void configuration . get number of shards ( ) , shard index , storage . get array ( key ) . get row ( row index ) . dup ( ) ) ; aggregation . set originator id ( this . get originator id ( ) ) ; transport . send message ( aggregation ) ; }	This method will be started in context of executor, either Shard, Client or Backup node.
static public big decimal gamma ( math context mc ) { if ( mc . get precision ( ) < gamma . precision ( ) ) { return gamma . round ( mc ) ; } else { double eps = prec2err ( num , mc . get precision ( ) ) ; math context mcloc = new math context ( num + mc . get precision ( ) ) ; big decimal resul = big decimal . one ; resul = resul . add ( log ( num , mcloc ) ) ; resul = resul . subtract ( log ( num , mcloc ) ) ; int kmax = ( int ) ( ( math . log ( eps / num ) - num ) / num ) ; mcloc = new math context ( num + err2prec ( num , eps / kmax ) ) ; for ( int n = num ; ; n ++ ) { big decimal c = zeta ( num * n + num , mcloc ) . subtract ( big decimal . one ) ; big integer fourn = big integer . value of ( num * n + num ) ; fourn = fourn . shift left ( num * n ) ; c = divide round ( c , fourn ) ; resul = resul . subtract ( c ) ; if ( c . double value ( ) < num * eps ) { break ; } } return resul . round ( mc ) ; } }	Euler-Mascheroni constant.
static public big decimal sqrt ( final big decimal x ) { if ( x . compare to ( big decimal . zero ) < num ) { throw new arithmetic exception ( str + x . to string ( ) + str ) ; } return root ( num , x ) ; }	The square root.
static public big decimal cbrt ( final big decimal x ) { if ( x . compare to ( big decimal . zero ) < num ) { return root ( num , x . negate ( ) ) . negate ( ) ; } else { return root ( num , x ) ; } }	The cube root.
static public big decimal exp ( final math context mc ) { if ( mc . get precision ( ) < e . precision ( ) ) { return e . round ( mc ) ; } else { big decimal uni = scale prec ( big decimal . one , mc . get precision ( ) ) ; return exp ( uni ) ; } }	The base of the natural logarithm.
static public big decimal pow ( final big decimal x , final big decimal y ) { if ( x . compare to ( big decimal . zero ) < num ) { throw new arithmetic exception ( str + x . to string ( ) ) ; } else if ( x . compare to ( big decimal . zero ) == num ) { return big decimal . zero ; } else { big decimal logx = log ( x ) ; big decimal ylogx = y . multiply ( logx ) ; big decimal resul = exp ( ylogx ) ; double err r = math . abs ( logx . double value ( ) * y . ulp ( ) . double value ( ) / num ) + math . abs ( y . double value ( ) * x . ulp ( ) . double value ( ) / num / x . double value ( ) ) ; math context mc r = new math context ( err2prec ( num , err r ) ) ; return resul . round ( mc r ) ; } }	Power function.
static public big decimal pow round ( final big decimal x , final int n ) { math context mc = new math context ( x . precision ( ) - ( int ) math . log10 ( ( double ) ( math . abs ( n ) ) ) ) ; return x . pow ( n , mc ) ; }	Raise to an integer power and round.
static public big decimal tanh ( final big decimal x ) { if ( x . compare to ( big decimal . zero ) < num ) { return tanh ( x . negate ( ) ) . negate ( ) ; } else if ( x . compare to ( big decimal . zero ) == num ) { return big decimal . zero ; } else { big decimal xhighpr = scale prec ( x , num ) ; big decimal exp2x = exp ( xhighpr . multiply ( new big decimal ( - num ) ) ) ; double eps = num * x . ulp ( ) . double value ( ) / math . pow ( math . cosh ( x . double value ( ) ) , num ) ; math context mc = new math context ( err2prec ( math . tanh ( x . double value ( ) ) , eps ) ) ; return big decimal . one . subtract ( exp2x ) . divide ( big decimal . one . add ( exp2x ) , mc ) ; } }	The hyperbolic tangent.
static public big decimal asinh ( final big decimal x ) { if ( x . compare to ( big decimal . zero ) == num ) { return big decimal . zero ; } else { big decimal xhighpr = scale prec ( x , num ) ; big decimal logx = log ( hypot ( num , xhighpr ) . add ( xhighpr ) ) ; double x dbl = x . double value ( ) ; double eps = num * x . ulp ( ) . double value ( ) / math . hypot ( num , x dbl ) ; math context mc = new math context ( err2prec ( logx . double value ( ) , eps ) ) ; return logx . round ( mc ) ; } }	The inverse hyperbolic sine.
static public big decimal acosh ( final big decimal x ) { if ( x . compare to ( big decimal . one ) < num ) { throw new arithmetic exception ( str + x . to string ( ) ) ; } else if ( x . compare to ( big decimal . one ) == num ) { return big decimal . zero ; } else { big decimal xhighpr = scale prec ( x , num ) ; big decimal logx = log ( sqrt ( xhighpr . pow ( num ) . subtract ( big decimal . one ) ) . add ( xhighpr ) ) ; double x dbl = x . double value ( ) ; double eps = num * x . ulp ( ) . double value ( ) / math . sqrt ( x dbl * x dbl - num ) ; math context mc = new math context ( err2prec ( logx . double value ( ) , eps ) ) ; return logx . round ( mc ) ; } }	The inverse hyperbolic cosine.
static public big decimal scale prec ( final big decimal x , int d ) { return x . set scale ( d + x . scale ( ) ) ; }	Append decimal zeros to the value.
static public big decimal scale prec ( final big decimal x , final math context mc ) { final int diff pr = mc . get precision ( ) - x . precision ( ) ; if ( diff pr > num ) { return scale prec ( x , diff pr ) ; } else { return x ; } }	Boost the precision by appending decimal zeros to the value.
static public int err2prec ( big decimal x , big decimal xerr ) { return err2prec ( xerr . divide ( x , math context . decima ) . double value ( ) ) ; }	Convert an absolute error to a precision.
public void put function for id ( string id , differential function function ) { if ( function instances by id . contains key ( id ) ) { throw new n j ( str ) ; } else if ( function instanceof sd ) { throw new n j ( str ) ; } function instances by id . put ( id , function ) ; }	Put the function for id.
public string [ ] get inputs for function ( differential function function ) { if ( ! incoming args reverse . contains key ( function . get own name ( ) ) ) throw new n j ( str + function . get own name ( ) ) ; return incoming args reverse . get ( function . get own name ( ) ) ; }	Returns the inputs for the given function.
public void update array for var name ( string var name , ind arr ) { if ( ! variable name to arr . contains key ( var name ) ) { throw new n j ( str + var name + str ) ; } variable name to arr . put ( var name , arr ) ; reverse array lookup . put ( arr , get variable ( var name ) ) ; }	Update the ndarray for the given vertex id.
public void put shape for var name ( string var name , long [ ] shape ) { if ( shape == null ) { throw new n j ( str ) ; } if ( variable name to shape . contains key ( var name ) ) { throw new n j ( str + var name + str ) ; } for ( int i = num ; i < shape . length ; i ++ ) { if ( shape [ i ] < num ) { add as place holder ( var name ) ; place holder original shapes . put ( var name , shape ) ; return ; } } variable name to shape . put ( var name , shape ) ; }	Associate a vertex id with the given shape.
public void associate array with variable ( ind arr , sd variable ) { if ( variable == null ) { throw new n j ( str ) ; } if ( arr == null ) { throw new n j ( str ) ; } reverse array lookup . put ( arr , variable ) ; variable name to arr . put ( variable . get var name ( ) , arr ) ; if ( ! shape already exists for var name ( variable . get var name ( ) ) ) put shape for var name ( variable . get var name ( ) , arr . shape ( ) ) ; else { update shape for var name ( variable . get var name ( ) , arr . shape ( ) ) ; } }	Associate the array with the given variable.
public < t > t get property for function ( differential function function instance , string property name ) { if ( ! properties for function . contains key ( function instance . get own name ( ) ) ) { return null ; } else { val map = properties for function . get ( function instance . get own name ( ) ) ; return ( t ) map . get ( property name ) ; } }	Get the property for a given function.
public void add property for function ( differential function function for , string property name , ind property ) { add property for function ( function for , property name , ( object ) property ) ; }	Add a property for the given function.
public void add outgoing for ( string [ ] var names , differential function function ) { if ( function . get own name ( ) == null ) throw new n j ( str ) ; if ( outgoing args reverse . contains key ( function . get own name ( ) ) ) { throw new n j ( str + function ) ; } if ( var names == null ) throw new n j ( str ) ; for ( int i = num ; i < var names . length ; i ++ ) { if ( var names [ i ] == null ) throw new n j ( str ) ; } outgoing args reverse . put ( function . get own name ( ) , var names ) ; outgoing args . put ( var names , function ) ; for ( val result name : var names ) { list < differential function > funcs = function output for . get ( result name ) ; if ( funcs == null ) { funcs = new array list < > ( ) ; function output for . put ( result name , funcs ) ; } funcs . add ( function ) ; } }	Adds outgoing arguments to the graph.Also checks for input argumentsand updates the graph adding an appropriate edgewhen the full graph is declared.
public void add args for ( string [ ] variables , differential function function ) { if ( function . get own name ( ) == null ) throw new n j ( str ) ;	Adds incoming args to the graph.
public boolean has args ( differential function function ) { val vertex id args = incoming args reverse . get ( function . get own name ( ) ) ; if ( vertex id args != null ) { val args = incoming args . get ( vertex id args ) ; if ( args != null ) return bool ; } return bool ; }	Returns true if this function alreadyhas defined arguments.
public ind [ ] eval ( map < string , ind > inputs ) { same diff exec pipeline = dup ( ) ; list < differential function > op exec action = exec pipeline . exec ( ) . get right ( ) ; if ( op exec action . is empty ( ) ) throw new illegal state exception ( str ) ; ind [ ] ret = new ind [ op exec action . size ( ) ] ; for ( int i = num ; i < ret . length ; i ++ ) { val var name = op exec action . get ( i ) . output variables ( ) [ num ] . get var name ( ) ; ret [ i ] = exec pipeline . get arr for var name ( var name ) ; } return ret ; }	Evaluate the given inputsbased on the current graph.
public sd one ( string name , int [ ] shape ) { return var ( name , array util . to long array ( shape ) , new constant init scheme ( str , num ) ) ; }	Variable initializationwith 1.0.
public sd ones like ( string name , sd input ) { return f ( ) . ones like ( name , input ) ; }	Return a variable of all 1s, with the same shape as the input.
public sd zeros like ( string name , sd input ) { return f ( ) . zeros like ( name , input ) ; }	Return a variable of all 0s, with the same shape as the input.
public void remove arg from function ( string var name , differential function function ) { val args = function . args ( ) ; for ( int i = num ; i < args . length ; i ++ ) { if ( args [ i ] . get var name ( ) . equals ( var name ) ) { val reverse args = incoming args reverse . get ( function . get own name ( ) ) ; incoming args . remove ( reverse args ) ; incoming args reverse . remove ( function . get own name ( ) ) ; val new args = new array list < string > ( args . length - num ) ; for ( int arg = num ; arg < args . length ; arg ++ ) { if ( ! reverse args [ arg ] . equals ( var name ) ) { new args . add ( reverse args [ arg ] ) ; } } val new args arr = new args . to array ( new string [ new args . size ( ) ] ) ; incoming args . put ( new args arr , function ) ; incoming args reverse . put ( function . get own name ( ) , new args arr ) ;	Remove an argument for a function.
public void set gradient for variable name ( string variable name , sd variable ) { if ( variable == null ) { throw new n j ( str + variable name ) ; } gradients . put ( variable name , variable ) ; }	Assign a vertex idto a gradient.
public sd avg pooling3d ( sd [ ] inputs , d pooling3 d ) { return avg pooling3d ( null , inputs , pooling3 d ) ; }	Average pooling 3d operation.
public sd gru ( string base name , gru configuration ) { return new gru ( this , configuration ) . output variables ( base name ) [ num ] ; }	The gru cell.
public list < differential function > exec ( list < differential function > ops ) { for ( int i = num ; i < ops . size ( ) ; i ++ ) { op op = ( op ) ops . get ( i ) ; nd4j . get executioner ( ) . exec ( op ) ; } return ops ; }	Executes the list of operations.This exec method is foronly invoking operationsrather than creating them.
public while while statement ( same diff conditional same diff conditional , same diff function definition condition body , same diff . same diff function definition loop body , sd [ ] input vars ) { return while . builder ( ) . input vars ( input vars ) . condition ( condition body ) . predicate ( same diff conditional ) . true body ( loop body ) . parent ( this ) . block name ( str + uuid . random uuid ( ) . to string ( ) ) . build ( ) ; }	Creates a while statement.
public pair < map < sd , differential function > , list < differential function > > exec ( string function name ) { if ( debug mode ) { return same diff function instances . get ( function name ) . enable debug mode ( ) . exec ( ) ; } else return same diff function instances . get ( function name ) . exec ( ) ; }	Exec a given function.
public list < differential function > exec ( string function name , list < differential function > cached ops ) { return same diff function instances . get ( function name ) . exec ( cached ops ) ; }	Exec the given functiongiven the ops.
public ind exec backward and end result ( ) { list < differential function > backwards = exec backwards ( ) . get right ( ) ; differential function df = backwards . get ( backwards . size ( ) - num ) ; if ( df instanceof op ) { return ( ( op ) df ) . z ( ) ; } else if ( df instanceof dynamic custom op ) { return ( ( dynamic custom op ) df ) . get output argument ( num ) ; } else { return null ; } }	Exec a backwards operationand return the end result.
public void add as place holder ( string var name ) { place holder var names . add ( var name ) ; if ( get variable ( var name ) != null && get variable ( var name ) . get shape ( ) != null ) { place holder original shapes . put ( var name , get variable ( var name ) . get shape ( ) ) ; } }	Add this vertex id as a place holder.
@ override public pointer allocate ( long bytes , memory kind kind , boolean initialize ) { atomic allocator allocator = atomic allocator . get instance ( ) ;	This method returns Pointer to allocated memory chunkPLEASE NOTE: Cache options depend on specific implementations.
public static int length for dtype ( data buffer . type type ) { switch ( type ) { case double : return num ; case float : return num ; case int : return num ; case half : return num ; case long : return num ; case compressed : default : throw new illegal argument exception ( str ) ; } }	Returns the length for the given data opType.
public static string get d ( data buffer . type allocation mode ) { switch ( allocation mode ) { case double : return str ; case float : return str ; case int : return str ; case half : return str ; default : return str ; } }	Gets the name of the alocation mode.
public static data buffer . type get dtype from context ( ) { try { lock . read lock ( ) . lock ( ) ; if ( dtype == null ) { lock . read lock ( ) . unlock ( ) ; lock . write lock ( ) . lock ( ) ; if ( dtype == null ) dtype = get dtype from context ( nd4j context . get instance ( ) . get conf ( ) . get property ( str ) ) ; lock . write lock ( ) . unlock ( ) ; lock . read lock ( ) . lock ( ) ; } return dtype ; } finally { lock . read lock ( ) . unlock ( ) ; } }	get the allocation mode from the context.
@ override public int get op num by name ( string op name ) { try { differential function op = differential function class holder . get instance ( ) . get instance ( op name ) ; return op . op num ( ) ; } catch ( exception e ) { throw new runtime exception ( str + op name + str , e ) ; } }	This method returns op id number for given opName.
@ override public void destroy all workspaces for current thread ( ) { ensure thread existense ( ) ; list < memory workspace > workspaces = new array list < > ( ) ; workspaces . add all ( backing map . get ( ) . values ( ) ) ; for ( memory workspace workspace : workspaces ) { destroy workspace ( workspace ) ; } system . gc ( ) ; }	This method destroys all workspaces allocated in current thread.
public synchronized void print allocation statistics for current thread ( ) { ensure thread existense ( ) ; map < string , memory workspace > map = backing map . get ( ) ; log . info ( str ) ; log . info ( str , map . size ( ) ) ; log . info ( str ) ; for ( string key : map . key set ( ) ) { long current = ( ( nd4j workspace ) map . get ( key ) ) . get current size ( ) ; long spilled = ( ( nd4j workspace ) map . get ( key ) ) . get spilled size ( ) ; long pinned = ( ( nd4j workspace ) map . get ( key ) ) . get pinned size ( ) ; log . info ( string . format ( str , ( key + str ) , string utils . traditional binary prefix . long2 string ( current , str , num ) , string utils . traditional binary prefix . long2 string ( spilled , str , num ) , string utils . traditional binary prefix . long2 string ( pinned , str , num ) , current , spilled , pinned ) ) ; } }	This method prints out basic statistics for workspaces allocated in current thread.
@ override public void trmv ( char order , char uplo , char a , char diag , ind a , ind x ) { if ( nd4j . get executioner ( ) . get profiling mode ( ) == op executioner . profiling mode . all ) op profiler . get instance ( ) . process blas call ( bool , a , x ) ;	trmv computes a matrix-vector product using a triangular matrix.
@ override public ind exec ( variance accumulation , boolean bias corrected , int ... dimension ) { return process op ( accumulation ) . z ( ) ; }	Execute an accumulation along one or more dimensions.
@ override public ind threshold decode ( ind encoded , ind target ) { return backend executioner . threshold decode ( encoded , target ) ; }	This method decodes thresholds array, and puts it into target array.
public string get node name ( string name ) {	Map a tensorflow node nameto the samediff equivalentfor import.
private void invoke ( scalar op op , int [ ] dimension ) { dimension = shape . normalize axis ( op . x ( ) . rank ( ) , dimension ) ;	ScalarOp along dimension.
public static void assert no workspaces open ( string msg ) throws n j { if ( nd4j . get workspace manager ( ) . any workspace active for current thread ( ) ) { list < memory workspace > l = nd4j . get workspace manager ( ) . get all workspaces for current thread ( ) ; list < string > workspaces = new array list < > ( l . size ( ) ) ; for ( memory workspace ws : l ) { if ( ws . is scope active ( ) ) { workspaces . add ( ws . get id ( ) ) ; } } throw new n j ( msg + str + workspaces ) ; } }	Assert that no workspaces are currently open.
private ind negative log likelihood ( ind labels , ind alpha , ind mu , ind sigma ) { ind labels minus mu = labels minus mu ( labels , mu ) ; ind diffsquared = labels minus mu . mul ( labels minus mu ) . sum ( num ) ; ind phitimesalphasum = phi ( diffsquared , sigma ) . muli ( alpha ) . sum ( num ) ;	This method returns an array consisting of each of the training samples,for each label in each sample, the negative log likelihood of thatvalue falling within the given gaussian mixtures.
public void request tick ( long time , time unit time unit ) { long timeframe ms = time unit . milliseconds . convert ( time , time unit ) ; long current time = system . current time millis ( ) ; boolean is waiting = bool ;	This method requests to change state to Tick.PLEASE NOTE: this method is blocking, if memory is in Toe state.PLEASE NOTE: if Tick can't be acquired within specified timeframe, exception will be thrown.
public boolean try request toe ( ) { schedule toe ( ) ; if ( is toe waiting . get ( ) || get current state ( ) == access state . toe ) {	This method requests to change state to ToePLEASE NOTE: this method is non-blocking, if Toe request is impossible atm, it will return false.
public void release toe ( ) { if ( get current state ( ) == access state . toe ) { if ( num > num ) {	This method requests release Toe status back to Tack.PLEASE NOTE: only the thread originally entered Toe state is able to release it.
public access state get current state ( ) { if ( access state . values ( ) [ current state . get ( ) ] == access state . toe ) { return access state . toe ; } else { if ( tick requests . get ( ) <= tack requests . get ( ) ) {	This method returns the current memory state.
@ override public void process message ( ) { if ( clipboard . is tracking ( this . originator id , this . get task id ( ) ) ) { clipboard . pin ( this ) ; if ( clipboard . is ready ( this . originator id , task id ) ) { void aggregation aggregation = clipboard . unpin ( this . originator id , task id ) ;	Vector aggregations are saved only by Shards started aggregation process. All other Shards are ignoring this meesage.
protected void initialize curr from list ( list < data set > examples ) { if ( examples . is empty ( ) ) log . warn ( str ) ; ind inputs = create input matrix ( examples . size ( ) ) ; ind labels = create output matrix ( examples . size ( ) ) ; for ( int i = num ; i < examples . size ( ) ; i ++ ) { inputs . put row ( i , examples . get ( i ) . get feature matrix ( ) ) ; labels . put row ( i , examples . get ( i ) . get labels ( ) ) ; } curr = new data set ( inputs , labels ) ; }	Initializes this data transform fetcher from the passed in datasets.
protected void init host collectors ( ) { for ( int i = num ; i < configuration . get number of gc threads ( ) ; i ++ ) { reference queue < base data buffer > queue = new reference queue < > ( ) ; unified garbage collector thread u thread = new unified garbage collector thread ( i , queue ) ;	This method executes preconfigured number of host memory garbage collectors.
@ override public pointer get pointer ( data buffer buffer , cuda context context ) { return memory handler . get device pointer ( buffer , context ) ; }	This method returns actual device pointer valid for current object.
@ override public void synchronize host data ( data buffer buffer ) {	This method should be called to make sure that data on host side is actualized.
@ override public void apply updater ( ind gradient , int iteration , int epoch ) { if ( historical gradient == null ) throw new illegal state exception ( str ) ; double learning rate = config . get learning rate ( iteration , epoch ) ; double epsilon = config . get epsilon ( ) ; historical gradient . addi ( gradient . mul ( gradient ) ) ; ind sqrt history = sqrt ( historical gradient . dup ( gradient reshape order ) , bool ) . addi ( epsilon ) ;	Gets feature specific learning ratesAdagrad keeps a history of gradients being passed in.Note that each gradient passed in becomes adapted over time, hence the opName adagrad.
@ override public void synchronize to host ( allocation point point ) { if ( ! point . is constant ( ) && point . is enqueued ( ) ) { wait till finished ( point ) ; } super . synchronize to host ( point ) ; }	This method makes sure HOST memory contains latest data from GPUAdditionally, this method checks, that there's no ops pending execution for this array.
public static ind [ ] create ( ind index ) { if ( index . is matrix ( ) ) { if ( index . rows ( ) > integer . max value ) throw new n j ( ) ; nd [ ] ret = new nd [ ( int ) index . rows ( ) ] ; for ( int i = num ; i < index . rows ( ) ; i ++ ) { ind row = index . get row ( i ) ; val nums = new long [ ( int ) index . get row ( i ) . columns ( ) ] ; for ( int j = num ; j < row . columns ( ) ; j ++ ) { nums [ j ] = ( int ) row . get float ( j ) ; } nd idx = new nd ( nums ) ; ret [ i ] = idx ; } return ret ; } else if ( index . is vector ( ) ) { long [ ] indices = nd . to longs ( index ) ; return new nd [ ] { new nd ( indices ) } ; } throw new illegal argument exception ( str ) ; }	Create from a matrix. The rows are the indicesThe columns are the individual element in each ndarrayindex.
public map < string , object > properties for function ( ) { val fields = differential function class holder . get instance ( ) . get fields for function ( this ) ; map < string , object > ret = new linked hash map < > ( ) ; for ( val entry : fields . entry set ( ) ) { try { ret . put ( entry . get key ( ) , fields . get ( entry . get key ( ) ) . get ( this ) ) ; } catch ( illegal access exception e ) { e . print stack trace ( ) ; } } return ret ; }	Returns the properties for a given function.
public boolean has place holder inputs ( ) { val args = args ( ) ; for ( val arg : args ) if ( same diff . has place holder variables ( arg ( ) . get var name ( ) ) ) return bool ; return bool ; }	Returns true if thisfunction has place holder inputs.
public list < sd > diff ( list < sd > i v1 ) { list < sd > vals = do diff ( i v1 ) ; if ( vals == null ) { throw new illegal state exception ( str + this . op name ( ) ) ; } val output vars = args ( ) ; for ( int i = num ; i < vals . size ( ) ; i ++ ) { sd var = output vars [ i ] ; sd grad = var . get gradient ( ) ; if ( grad != null ) { sd grad var = f ( ) . add ( grad , vals . get ( i ) ) ; try { vals . set ( i , grad var ) ; } catch ( unsupported operation exception e ) { throw new unsupported operation exception ( str + this . get class ( ) . get simple name ( ) + str , e ) ; } same diff . set gradient for variable name ( var . get var name ( ) , grad var ) ; } else { sd grad var = vals . get ( i ) ; same diff . update variable name and reference ( grad var , var . get var name ( ) + str ) ; same diff . set gradient for variable name ( var . get var name ( ) , grad var ) ; same diff . set forward variable for var name ( grad var . get var name ( ) , var ) ; } } return vals ; }	Perform automatic differentiationwrt the input variables.
public string format ( ind arr , boolean summarize ) { this . scientific format = str ; int add precision = this . precision ; while ( add precision > num ) { this . scientific format += str ; add precision -= num ; } this . scientific format = this . scientific format + str ; if ( this . scientific format . length ( ) + num > this . padding ) this . padding = this . scientific format . length ( ) + num ; this . max to print without switching = math . pow ( num , this . precision ) ; this . min to print without switching = num / ( this . max to print without switching ) ; if ( summarize && arr . length ( ) > num ) return format ( arr , num , bool ) ; return format ( arr , num , bool ) ; }	Format the given ndarray as a string.
@ override public same diff import graph ( graph type tf graph ) { same diff diff = same diff . create ( ) ; import state < graph type , tensor type > import state = new import state < > ( ) ; import state . set same diff ( diff ) ; import state . set graph ( tf graph ) ; val variables for graph = variables for graph ( tf graph ) ; import state . set variables ( variables for graph ) ;	This method converts given TF.
@ override public blob convert ( i nd to convert ) throws io , sql { byte array output stream bos = new byte array output stream ( ) ; data output stream dos = new data output stream ( bos ) ; nd4j . write complex ( to convert , dos ) ; byte [ ] bytes = bos . to byte array ( ) ; connection c = data source . get connection ( ) ; blob b = c . create blob ( ) ; b . set bytes ( num , bytes ) ; return b ; }	Convert an ndarray to a blob.
@ override public i nd load complex ( blob blob ) throws sql , io { data input stream dis = new data input stream ( blob . get binary stream ( ) ) ; return nd4j . read complex ( dis ) ; }	Load a complex ndarray from a blob.
@ override public void save ( i nd save , string id ) throws io , sql { do save ( save , id ) ; }	Save the ndarray.
protected void copy real to ( ind arr ) { ind linear = arr . linear view ( ) ; i nd this linear = linear view ( ) ; if ( arr . is scalar ( ) ) arr . put scalar ( num , get real ( num ) ) ; else for ( int i = num ; i < linear . length ( ) ; i ++ ) { arr . put scalar ( i , this linear . get real ( i ) ) ; } }	Copy real numbers to arr.
protected void copy imag to ( ind arr ) { ind linear = arr . linear view ( ) ; i nd this linear = linear view ( ) ; if ( arr . is scalar ( ) ) arr . put scalar ( num , get real ( num ) ) ; else for ( int i = num ; i < linear . length ( ) ; i ++ ) { arr . put scalar ( i , this linear . get imag ( i ) ) ; } }	Copy imaginary numbers to the givenndarray.
@ override public i nd epsi ( number other ) { i nd linear = linear view ( ) ; double other val = other . double value ( ) ; for ( int i = num ; i < linear view ( ) . length ( ) ; i ++ ) { i n = linear . get complex ( i ) ; double real = n . real component ( ) . double value ( ) ; double diff = math . abs ( real - other val ) ; if ( diff <= nd4j . eps threshold ) linear . put scalar ( i , nd4j . create double ( num , num ) ) ; else linear . put scalar ( i , nd4j . create double ( num , num ) ) ; } return this ; }	Returns an ndarray with 1 if the element is epsilon equals.
@ override public i nd assign ( i nd arr ) { if ( ! arr . is scalar ( ) ) lin alg exceptions . assert same length ( this , arr ) ; i nd linear = linear view ( ) ; i nd other linear = arr . linear view ( ) ; for ( int i = num ; i < linear . length ( ) ; i ++ ) { linear . put scalar ( i , other linear . get complex ( i ) ) ; } return this ; }	Assign all of the elements in the givenndarray to this ndarray.
@ override public i nd get rows ( int [ ] rindices ) { ind rows = nd4j . create ( rindices . length , columns ( ) ) ; for ( int i = num ; i < rindices . length ; i ++ ) { rows . put row ( i , get row ( rindices [ i ] ) ) ; } return ( i nd ) rows ; }	Get whole rows from the passed indices.
@ override public i nd put row ( long row , ind to put ) { return ( i nd ) super . put row ( row , to put ) ; }	Insert a row in to this arrayWill throw an exception if thisndarray is not a matrix.
@ override public i nd put column ( int column , ind to put ) { assert to put . is vector ( ) && to put . length ( ) == rows ( ) : str + to put . length ( ) + str + columns ( ) ; i nd r = get column ( column ) ; if ( to put instanceof i nd ) { i nd put complex = ( i nd ) to put ; for ( int i = num ; i < r . length ( ) ; i ++ ) { i n = put complex . get complex ( i ) ; r . put scalar ( i , n ) ; } } else { for ( int i = num ; i < r . length ( ) ; i ++ ) r . put scalar ( i , nd4j . create double ( to put . get double ( i ) , num ) ) ; } return this ; }	Insert a column in to this arrayWill throw an exception if thisndarray is not a matrix.
@ override public i nd sub ( ind other , ind result ) { return dup ( ) . subi ( other , result ) ; }	copy subtraction of two matrices.
@ override public i nd add ( ind other , ind result ) { return dup ( ) . addi ( other , result ) ; }	copy addition of two matrices.
@ override public i nd subi ( ind other , ind result ) { i nd c other = ( i nd ) other ; i nd c result = ( i nd ) result ; if ( other . is scalar ( ) ) return subi ( c other . get complex ( num ) , result ) ; if ( result == this ) nd4j . get blas wrapper ( ) . axpy ( nd4j . neg unit , c other , c result ) ; else if ( result == other ) { if ( data . data type ( ) == ( data buffer . type . double ) ) { nd4j . get blas wrapper ( ) . scal ( nd4j . neg unit . as double ( ) , c result ) ; nd4j . get blas wrapper ( ) . axpy ( nd4j . unit , this , c result ) ; } else { nd4j . get blas wrapper ( ) . scal ( nd4j . neg unit . as float ( ) , c result ) ; nd4j . get blas wrapper ( ) . axpy ( nd4j . unit , this , c result ) ; } } else { nd4j . get blas wrapper ( ) . copy ( this , result ) ; nd4j . get blas wrapper ( ) . axpy ( nd4j . neg unit , c other , c result ) ; } return c result ; }	in place subtraction of two matrices.
@ override public i nd addi ( ind other , ind result ) { i nd c other = ( i nd ) other ; i nd c result = ( i nd ) result ; if ( c other . is scalar ( ) ) { return c result . addi ( c other . get complex ( num ) , result ) ; } if ( is scalar ( ) ) { return c other . addi ( get complex ( num ) , result ) ; } if ( result == this ) { nd4j . get blas wrapper ( ) . axpy ( nd4j . unit , c other , c result ) ; } else if ( result == other ) { nd4j . get blas wrapper ( ) . axpy ( nd4j . unit , this , c result ) ; } else { ind result linear = result . linear view ( ) ; ind other linear = other . linear view ( ) ; ind linear = linear view ( ) ; for ( int i = num ; i < result linear . length ( ) ; i ++ ) { result linear . put scalar ( i , other linear . get double ( i ) + linear . get double ( i ) ) ; } } return ( i nd ) result ; }	in place addition of two matrices.
@ override public i nd assign ( number value ) { i nd one = linear view ( ) ; for ( int i = num ; i < one . length ( ) ; i ++ ) one . put scalar ( i , nd4j . create double ( value . double value ( ) , num ) ) ; return this ; }	Set the value of the ndarray to the specified value.
@ override public i nd ravel ( ) { if ( length ( ) >= integer . max value ) throw new illegal argument exception ( str ) ; i nd ret = nd4j . create complex ( ( int ) length ( ) , ordering ( ) ) ; i nd linear = linear view ( ) ; for ( int i = num ; i < length ( ) ; i ++ ) { ret . put scalar ( i , linear . get complex ( i ) ) ; } return ret ; }	Flattens the array for linear indexing.
public static i nd eigenvalues ( ind a ) { assert a . rows ( ) == a . columns ( ) ; ind wr = nd4j . create ( a . rows ( ) , a . rows ( ) ) ; ind wi = wr . dup ( ) ; nd4j . get blas wrapper ( ) . geev ( str , str , a . dup ( ) , wr , wi , dummy , dummy ) ; return nd4j . create complex ( wr , wi ) ; }	Computes the eigenvalues of a general matrix.
public static ind symmetric generalized eigenvalues ( ind a , ind b ) { assert a . rows ( ) == a . columns ( ) ; assert b . rows ( ) == b . columns ( ) ; ind w = nd4j . create ( a . rows ( ) ) ; a = invert matrix . invert ( b , bool ) . mmuli ( a ) ; nd4j . get blas wrapper ( ) . syev ( str , str , a , w ) ; return w ; }	Compute generalized eigenvalues of the problem A x = L B x.The data will be unchanged, no eigenvectors returned.
@ override public int iamax ( i nd arr ) { if ( arr . data ( ) . data type ( ) == data buffer . type . double ) return izamax ( arr . length ( ) , arr , blas buffer util . get blas stride ( arr ) ) ; return icamax ( arr . length ( ) , arr , blas buffer util . get blas stride ( arr ) ) ; }	finds the element of a vector that has the largest absolute value.
@ override public void copy ( i nd x , i nd y ) { if ( x . data ( ) . data type ( ) == data buffer . type . double ) zcopy ( x . length ( ) , x , blas buffer util . get blas stride ( x ) , y , blas buffer util . get blas stride ( y ) ) ; else ccopy ( x . length ( ) , x , blas buffer util . get blas stride ( x ) , y , blas buffer util . get blas stride ( y ) ) ; }	copy a vector to another vector.
@ override public void scal ( long n , i alpha , i nd x ) { if ( x . data ( ) . data type ( ) == data buffer . type . double ) zscal ( n , alpha . as double ( ) , x , blas buffer util . get blas stride ( x ) ) ; else cscal ( n , alpha . as float ( ) , x , blas buffer util . get blas stride ( x ) ) ; }	computes a vector by a scalar product.
@ override public void process message ( ) {	This method calculates dot of gives rows.
private static sd non zero count ( sd weights , sd labels ) { same diff sd = weights . get same diff ( ) ; sd present = sd . neq ( weights , num ) ; sd present broadcast = sd . zeros like ( labels ) . add ( present ) ; return sd . sum ( present broadcast ) ; }	Determine the number of weight entries that are non-zero, after broadcasting.
private static loss info do reduce ( same diff sd , string output name , boolean is mean , loss info . builder b , reduction reduction , sd pre reduce loss , sd label , sd weights , int [ ] dimensions ) { switch ( reduction ) { case none :	Perform the final reduction on the loss function.
public static < t > constructor < t > get no arg constructor ( class < t > clazz ) { try { constructor < t > ctor = clazz . get declared constructor ( new class [ num ] ) ; ctor . set accessible ( bool ) ; return ctor ; } catch ( no such method exception e ) {	Throw an IllegalStateException if the class does not have a no-arg constructor.
public static method handle get constructor ( class < ? > clazz , class < ? > ... args ) { try {	Gets a constructor that has the specified types of arguments.Throw an IllegalStateException if the class does not have such a constructor.
public static < t > t invoke ( method handle method handle , object ... params ) { try { return ( t ) method handle . invoke with arguments ( params ) ; } catch ( runtime exception e ) { throw e ; } catch ( throwable throwable ) { throw new runtime exception ( throwable ) ; } }	Wraps any non-runtime exceptions with a runtime exception.
@ suppress warnings ( str ) public static < a extends annotation > a get annotation ( annotation [ ] annotations , class < a > annotation type ) { for ( annotation anno : annotations ) if ( annotation type . is assignable from ( anno . get class ( ) ) ) return ( a ) anno ; return null ; }	Gets the annotation that has the specified type, or null if there isn't one.
public static < a extends annotation > a get declared annotation ( class < ? > on class , class < a > annotation type ) { return get annotation ( on class . get declared annotations ( ) , annotation type ) ; }	Get the declared annotation, ignoring any inherited annotations.
public static < a extends annotation > boolean is declared annotation present ( class < ? > on class , class < a > annotation type ) { return get declared annotation ( on class , annotation type ) != null ; }	Is the declared annotation present, ignoring any inherited annotations.
@ suppress warnings ( str ) public static < s > s create ( class < ? super s > interf , result < s > result ) { return ( s ) proxy . new proxy instance ( result . get class ( ) . get class loader ( ) , new class [ ] { interf } , new result proxy < > ( result ) ) ; }	Create a ResultProxy for the given interface.
public p load ( final base entity < ? > ent , final load context ctx ) { try {	Converts an entity to an object of the appropriate type for this metadata structure.Does not check that the entity is appropriate; that should be done when choosingwhich EntityMetadata to call.
public full entity < ? > save ( final p pojo , final save context ctx ) { try { return translator . save ( pojo , bool , ctx , path . root ( ) ) . get ( ) ; } catch ( save exception ex ) { throw ex ; } catch ( exception ex ) { throw new save exception ( pojo , ex ) ; } }	Converts an object to a datastore Entity with the appropriate Key type.
public static memcache service create proxy ( final memcache service raw , final int retry count ) { return ( memcache service ) java . lang . reflect . proxy . new proxy instance ( raw . get class ( ) . get class loader ( ) , raw . get class ( ) . get interfaces ( ) , new memcache service retry proxy ( raw , retry count ) ) ; }	Create the proxy that does retries.
public < t > entity metadata < t > get metadata safe ( string kind ) throws illegal argument exception { entity metadata < t > metadata = this . get metadata ( kind ) ; if ( metadata == null ) throw new illegal argument exception ( str + kind + str ) ; else return metadata ; }	Gets metadata for the specified kind.
public < t > query results < key < t > > query keys only ( final key query query ) { log . trace ( str ) ; return new key query results < > ( ds . run ( query ) ) ; }	Perform a keys-only query.
public < t > query results < t > query hybrid ( final key query query , final int chunk size ) { log . trace ( str ) ; final query results < key < t > > results = new key query results < > ( ds . run ( query ) ) ; return new hybrid query results < > ( loader . create load engine ( ) , results , chunk size ) ; }	Perform a keys-only plus batch gets.
public < t > query results < t > query normal ( final entity query query , final int chunk size ) { log . trace ( str ) ;	A normal, non-hybrid query.
public < t > query results < t > query projection ( final projection entity query query ) { log . trace ( str ) ; final load engine load engine = loader . create load engine ( ) ; return new projection query results < > ( ds . run ( query ) , load engine ) ; }	A projection query. Bypasses the session entirely.
public int query count ( final key query query ) { log . trace ( str ) ; final query results < com . google . cloud . datastore . key > results = ds . run ( query ) ; return iterators . size ( results ) ; }	The fundamental query count operation.
private < t > iterator < iterator < t > > safe partition ( final iterator < t > input , int chunk size ) {	Detects Integer.MAX_VALUE and prevents OOM exceptions.
private iterator < result with cursor < t > > load ( final iterator < result with cursor < key < t > > > keys ) { final list < entry < result with cursor < key < t > > , result < t > > > results = lists . new array list ( ) ; while ( keys . has next ( ) ) { final result with cursor < key < t > > next = keys . next ( ) ; results . add ( maps . immutable entry ( next , load engine . load ( next . get result ( ) ) ) ) ; } load engine . execute ( ) ; return iterators . transform ( results . iterator ( ) , entry -> new result with cursor < > ( entry . get value ( ) . now ( ) , entry . get key ( ) . get cursor after ( ) ) ) ; }	Loads them; note that it's possible for some loaded results to be null.
public static string msg ( path path , string msg ) { string builder bld = new string builder ( ) ; bld . append ( str ) ; bld . append ( path . to path string ( ) ) ; if ( bld . length ( ) < path padding ) while ( bld . length ( ) < path padding ) bld . append ( str ) ; else bld . append ( str ) ; bld . append ( msg ) ; return bld . to string ( ) ; }	Create a log a message for a given path.
public static < t > key < t > create ( final t pojo ) { return objectify service . factory ( ) . keys ( ) . key of ( pojo ) ; }	Create a key from a registered POJO entity.
private int compare to with identity hash ( final object k1 , final object k2 ) { return integer . compare ( system . identity hash code ( k1 ) , system . identity hash code ( k2 ) ) ; }	I have no idea what this is about, it was in the old logic.
public static < v > key < v > key ( final com . google . cloud . datastore . key raw ) { if ( raw == null ) return null ; else return new key < > ( raw ) ; }	Easy null-safe conversion of the raw key.
public static com . google . cloud . datastore . key key ( final key < ? > typed ) { if ( typed == null ) return null ; else return typed . get raw ( ) ; }	Easy null-safe conversion of the typed key.
private static string get kind here ( final class < ? > clazz ) {	Get the kind from the class if the class has an .
static boolean is missing type parameters ( type type ) { if ( type instanceof class ) { for ( class < ? > clazz = ( class < ? > ) type ; clazz != null ; clazz = clazz . get enclosing class ( ) ) { if ( clazz . get type parameters ( ) . length != num ) return bool ; } return bool ; } else if ( type instanceof parameterized type ) { return bool ; } else { throw new assertion error ( str + type . get class ( ) ) ; } }	Checks if the given type is a class that is supposed to have type parameters, but doesn't.In other words, if it's a really raw type.
public static boolean is super type ( type super type , type sub type ) { if ( super type instanceof parameterized type || super type instanceof class || super type instanceof generic array type ) { class < ? > super class = erase ( super type ) ; type mapped sub type = get exact super type ( capture ( sub type ) , super class ) ; if ( mapped sub type == null ) { return bool ; } else if ( super type instanceof class < ? > ) { return bool ; } else if ( mapped sub type instanceof class < ? > ) {	Checks if the capture of subType is a subtype of superType.
private static type [ ] get exact direct super types ( type type ) { if ( type instanceof parameterized type || type instanceof class ) { class < ? > clazz ; if ( type instanceof parameterized type ) { clazz = ( class < ? > ) ( ( parameterized type ) type ) . get raw type ( ) ; } else {	Returns the direct supertypes of the given type.
public static type capture ( type type ) { if ( type instanceof parameterized type ) { return capture ( ( parameterized type ) type ) ; } else { return type ; } }	Applies capture conversion to the given type.
public < p , d > translator < p , d > get translator ( final type key < p > tk , final create context ctx , final path path ) { return factory . get translators ( ) . get ( tk , ctx , path ) ; }	Get the relevant translator, creating it if necessary.
@ suppress warnings ( str ) public < p > populator < p > get populator ( final class < p > clazz , final path path ) { if ( clazz == null || clazz . equals ( object . class ) ) { return ( populator < p > ) null populator . instance ; } else { final class translator < p > class translator = ( class translator < p > ) this . < p , full entity < ? > > get translator ( new type key < > ( clazz ) , this , path ) ; return class translator . get populator ( ) ; } }	Get the populator for the specified class.
private boolean get index instruction ( class < p > clazz ) { index ind = clazz . get annotation ( index . class ) ; unindex unind = clazz . get annotation ( unindex . class ) ; if ( ind != null && unind != null ) throw new illegal state exception ( str + clazz ) ; if ( ind != null ) return bool ; else if ( unind != null ) return bool ; else return null ; }	Figure out if there is an index instruction for the whole class.
private boolean is of interest ( method method ) { for ( annotation [ ] annos : method . get parameter annotations ( ) ) if ( type utils . get annotation ( annos , also load . class ) != null ) return bool ; return bool ; }	Determine if we should create a Property for the method (ie, .
private list < property > get declared properties ( objectify factory fact , class < ? > clazz ) { list < property > good = new array list < > ( ) ; for ( field field : clazz . get declared fields ( ) ) if ( is of interest ( field ) ) good . add ( new field property ( fact , clazz , field ) ) ; for ( method method : clazz . get declared methods ( ) ) if ( is of interest ( method ) ) good . add ( new method property ( method ) ) ; return good ; }	Get all the persistable fields and methods declared on a class.
public key metadata < p > get key metadata ( ) { final populator < object > populator = props . get ( num ) ; preconditions . check state ( populator instanceof key populator , str + this . clazz ) ; return ( ( key populator < p > ) populator ) . get key metadata ( ) ; }	Gets the key metadata but only if this was an .
public < t > result < t > get ( final key < t > key ) { assert ! is executed ( ) ; session value < t > sv = get session ( ) . get ( key ) ; if ( sv == null ) { log . trace ( str , key ) ; this . pending . add ( key . get raw ( ) ) ; result < t > result = new result cache < t > ( ) { @ override @ suppress warnings ( str ) public t now uncached ( ) {	Gets a result, using the session cache if possible.
public void execute ( ) { if ( needs execution ( ) ) { log . trace ( str , pending ) ; result < map < com . google . cloud . datastore . key , entity > > fetched = fetch pending ( ) ; translated = load engine . translate ( fetched ) ;	Turn this into a result set.
private result < map < com . google . cloud . datastore . key , entity > > fetch pending ( ) {	Possibly pulls some values from the stuffed collection.
private void add indexed discriminators ( final class < ? > clazz ) { if ( clazz == object . class ) return ; this . add indexed discriminators ( clazz . get superclass ( ) ) ; final subclass sub = clazz . get annotation ( subclass . class ) ; if ( sub != null && sub . index ( ) ) { final string disc = ( sub . name ( ) . length ( ) > num ) ? sub . name ( ) : clazz . get simple name ( ) ; this . indexed discriminators . add ( string value . of ( disc ) ) ; } }	Recursively go through the class hierarchy adding any discriminators that are indexed.
public void register subclass ( class translator < ? extends p > translator ) { by discriminator . put ( translator . get discriminator ( ) , translator ) ; subclass sub = translator . get declared class ( ) . get annotation ( subclass . class ) ; for ( string also load : sub . also load ( ) ) by discriminator . put ( also load , translator ) ; by class . put ( translator . get declared class ( ) , translator ) ; }	Register a subclass translator with this class translator.
public static type get collection component type ( type collection type ) { type component type = generic type reflector . get type parameter ( collection type , collection . class . get type parameters ( ) [ num ] ) ; if ( component type == null )	Get the component type of a Collection.
public static type get map key type ( type map type ) { type component type = generic type reflector . get type parameter ( map type , map . class . get type parameters ( ) [ num ] ) ; if ( component type == null )	Get the key type of a Map.
public static forward path of ( path path ) { forward path next = new forward path ( path ) ; if ( path . get previous ( ) == path . root ( ) ) return next ; forward path previous = of ( path . get previous ( ) ) ; previous . next = next ; return previous ; }	Recursive method which reverses the path into a ForwardPath.
public path get final path ( ) { forward path here = this ; while ( here . next != null ) here = here . next ; return here . get path ( ) ; }	Get the complete path in this chain, typically for error messages or debugging.
public string to path string ( ) { if ( this == root ) { return str ; } else { string builder builder = new string builder ( ) ; to path string ( builder ) ; return builder . to string ( ) ; } }	Create the full x.y.z string.
public int depth ( ) { int depth = num ; path here = this ; while ( here != root ) { depth ++ ; here = here . previous ; } return depth ; }	ROOT is 0, top level Entity properties are 1, embedded things are higher.
public void put all ( final collection < bucket > updates ) { final set < key > good = this . cache put if untouched ( updates ) ; if ( good . size ( ) == updates . size ( ) ) return ;	Update a set of buckets with new values.
public void empty ( final iterable < key > keys ) { final map < key , object > updates = new hash map < > ( ) ; for ( final key key : keys ) if ( cache control . is cacheable ( key ) ) updates . put ( key , null ) ; this . memcache with retry . put all ( updates ) ; }	Revert a set of keys to the empty state.
private set < key > cache put if untouched ( final iterable < bucket > buckets ) { final map < key , cas put > payload = new hash map < > ( ) ; final set < key > successes = new hash set < > ( ) ; for ( final bucket buck : buckets ) { if ( ! buck . is cacheable ( ) ) { successes . add ( buck . get key ( ) ) ; continue ; } final integer expiry seconds = cache control . get expiry seconds ( buck . get key ( ) ) ; if ( expiry seconds == null ) { successes . add ( buck . get key ( ) ) ; continue ; } payload . put ( buck . get key ( ) , new cas put ( buck . identifiable value , buck . get next to store ( ) , expiry seconds ) ) ; } successes . add all ( this . memcache . put if untouched ( payload ) ) ; return successes ; }	Put buckets in the cache, checking for cacheability and collisions.
private map < key , object > cache get all ( final collection < key > keys ) { try { return this . memcache . get all ( keys ) ; } catch ( exception ex ) {	Bulk get on keys, getting the raw objects.
public static set < key > keys of ( final collection < bucket > buckets ) { return buckets . stream ( ) . map ( bucket :: get key ) . collect ( collectors . to set ( ) ) ; }	Basically a list comprehension of the keys for convenience.
@ suppress warnings ( str ) public < k extends incomplete key > void set key ( final full entity . builder < k > container , final p pojo ) { final incomplete key raw key = get incomplete key ( pojo ) ; if ( ! ( raw key instanceof com . google . cloud . datastore . key ) ) {	Sets the key on a container from the POJO.
public void set long id ( p pojo , long id ) { if ( ! clazz . is assignable from ( pojo . get class ( ) ) ) throw new illegal argument exception ( str + clazz . get name ( ) + str + pojo . get class ( ) . get name ( ) ) ; this . id meta . get property ( ) . set ( pojo , id ) ; }	Sets the numeric id field.
private com . google . cloud . datastore . key get parent raw ( p pojo ) { if ( parent meta == null ) return null ; final value < object > value = parent meta . get value ( pojo , new save context ( ) , path . root ( ) ) ; return ( value == null || value . get type ( ) == value type . null ) ? null : ( com . google . cloud . datastore . key ) value . get ( ) ; }	Get the contents of the .
private void register subclass ( final class translator < p > translator , final type key < ? super p > superclass type key , final create context ctx , final path path ) { if ( superclass type key . get type as class ( ) == object . class ) return ; @ suppress warnings ( str ) final class translator < ? super p > super translator = create ( ( type key ) superclass type key , ctx , path ) ; super translator . register subclass ( translator ) ; register subclass ( translator , new type key < > ( superclass type key . get type as class ( ) . get superclass ( ) ) , ctx , path ) ; }	Recursively register this subclass with all the superclass translators.
private static boolean could have common subtype ( type type1 , type type2 ) {	Checks if the intersection of two types is not empty.
private static type transform owner ( type given owner , class < ? > clazz ) { if ( given owner == null ) {	Transforms the given owner type into an appropriate one when constructing a parameterized type.
public < a extends annotation > a get annotation anywhere ( class < a > annotation type ) { a anno = get annotation ( annotation type ) ; if ( anno == null ) { class < ? > clazz = ( class < ? > ) generic type reflector . erase ( type ) ; return clazz . get annotation ( annotation type ) ; } else { return anno ; } }	Checks not only the listed annotations but also annotations on the class.
public void add all ( final session other ) { if ( log . is trace enabled ( ) ) log . trace ( str , other . map . key set ( ) ) ; map . put all ( other . map ) ; }	Add all entries in the other session to this one.
public < t > result < t > load ( final key < t > key ) { if ( key == null ) throw new null pointer exception ( str ) ; final result < t > result = round . get ( key ) ;	Gets the result, possibly from the session, putting it in the session if necessary.Also will recursively prepare the session with .
public void execute ( ) { if ( round . needs execution ( ) ) { round old = round ; round = old . next ( ) ; old . execute ( ) ; } }	Starts asychronous fetching of the batch.
public result < map < key < ? > , object > > translate ( final result < map < com . google . cloud . datastore . key , entity > > raw ) { return new result cache < map < key < ? > , object > > ( ) { private load context ctx ; @ override public map < key < ? > , object > now uncached ( ) { final map < key < ? > , object > result = new hash map < > ( raw . now ( ) . size ( ) * num ) ; ctx = new load context ( load engine . this ) ; for ( final entity ent : raw . now ( ) . values ( ) ) { final key < ? > key = key . create ( ent . get key ( ) ) ; final object entity = load ( ent , ctx ) ; result . put ( key , entity ) ; } return result ; } @ override protected void post execute hook ( ) { ctx . done ( ) ; ctx = null ; } } ; }	Asynchronously translate raw to processed; might produce successive load operations as refs are filled in.
public result < map < com . google . cloud . datastore . key , entity > > fetch ( set < com . google . cloud . datastore . key > keys ) { log . debug ( str , keys . size ( ) , keys ) ; final future < map < com . google . cloud . datastore . key , entity > > fut = datastore . get ( keys , read options . to array ( new read option [ read options . size ( ) ] ) ) ; return result adapter . create ( fut ) ; }	Fetch the keys from the async datastore using the current transaction context.
@ suppress warnings ( str ) public < t > t load ( final base entity < com . google . cloud . datastore . key > ent , final load context ctx ) { if ( ent == null ) return null ; final entity metadata < t > meta = ofy . factory ( ) . get metadata ( ent . get key ( ) . get kind ( ) ) ; if ( meta == null ) return ( t ) ent ; else return meta . load ( ent , ctx ) ; }	Converts a datastore entity into a typed pojo object.
public com . google . cloud . datastore . key create raw any ( final com . google . cloud . datastore . key parent , final string kind , final object id ) { if ( id instanceof string ) return create raw ( parent , kind , ( string ) id ) ; else if ( id instanceof long ) return create raw ( parent , kind , ( long ) id ) ; else throw new illegal argument exception ( str + id + str ) ; }	Construct a Key from a Long or String id.
public static com . google . cloud . datastore . key raw ( final key < ? > key ) { return key == null ? null : key . get raw ( ) ; }	Null-safe extraction of the raw key.
@ suppress warnings ( str ) public static < s > value < s > get id value ( final incomplete key key ) { if ( key instanceof com . google . cloud . datastore . key ) { final com . google . cloud . datastore . key complete key = ( com . google . cloud . datastore . key ) key ; if ( complete key . has id ( ) ) return ( value < s > ) long value . of ( complete key . get id ( ) ) ; else return ( value < s > ) string value . of ( complete key . get name ( ) ) ; } else { return null ; } }	Gets the String or Long id from the key as a Value, or null if incomplete.
@ sneaky throws public static com . google . cloud . datastore . key from url safe ( final string url safe key ) { if ( url safe key . starts with ( str ) ) { return key format . instance . parse old style app engine key ( url safe key ) ; } else { return com . google . cloud . datastore . key . from url safe ( url safe key ) ; } }	Understands both the legacy format "ag1zfnZvb2Rvb2R5bmUwcgcLEgFCGAEM" and new format,providing the key either way.
@ override public objectify impl transactionless ( final objectify impl parent ) { return parent . make new ( next -> new transactor no ( next , parent transactor . get session ( ) ) ) ; }	This version goes back to life without a transaction, but preserves current options.We use the session from the parent, ie life before transactions.
@ override public < r > r transact new ( final objectify impl parent , final int limit tries , final work < r > work ) { return transactionless ( parent ) . transact new ( limit tries , work ) ; }	We need to make sure the parentSession is the transactionless session, not the sessionfor our transaction.
private < r > r transact once ( final objectify impl parent , final work < r > work ) { final objectify impl txn ofy = factory . open ( parent . get options ( ) , next -> new transactor yes ( next , this ) ) ; boolean committed successfully = bool ; try { final r result = work . run ( ) ; txn ofy . flush ( ) ; txn ofy . get transaction ( ) . commit ( ) ; committed successfully = bool ; return result ; } finally { if ( txn ofy . get transaction ( ) . is active ( ) ) { try { txn ofy . get transaction ( ) . rollback ( ) ; } catch ( runtime exception ex ) { log . error ( str , ex ) ; } } txn ofy . close ( ) ; if ( committed successfully ) { ( ( private async transaction ) txn ofy . get transaction ( ) ) . run commit listeners ( ) ; } } }	One attempt at executing a transaction.
private boolean matches ( object on pojo , if < ? , ? > [ ] conditions ) { if ( conditions == null ) return bool ; object value = this . get ( on pojo ) ; for ( if < ? , ? > condition : conditions ) { @ suppress warnings ( str ) if < object , object > cond = ( if < object , object > ) condition ; if ( cond . matches value ( value ) ) return bool ; if ( cond . matches pojo ( on pojo ) ) return bool ; } return bool ; }	Tests whether a set of conditions match.
private objectify ofy ( ) {	Get the current objectify instance associated with this ref.
public async datastore async datastore ( final boolean enable global cache ) { if ( this . entity memcache != null && enable global cache && this . registrar . is cache enabled ( ) ) return new caching async datastore ( async datastore ( ) , this . entity memcache ) ; else return async datastore ( ) ; }	Might produce a caching version if caching is enabled.
@ suppress warnings ( str ) public < t > entity metadata < t > get metadata for entity ( final t obj ) throws illegal argument exception {	Named differently so you don't accidentally use the Object form.
private < t > key range < t > allocate ( final incomplete key incomplete key , final int num ) { final incomplete key [ ] allocations = new incomplete key [ num ] ; arrays . fill ( allocations , incomplete key ) ; final list < key < t > > typed keys = datastore ( ) . allocate id ( allocations ) . stream ( ) . map ( key :: < t > create ) . collect ( collectors . to list ( ) ) ; return new key range < > ( typed keys ) ; }	Allocate num copies of the incompleteKey.
public objectify impl open ( final objectify options opts , final transactor supplier transactor supplier ) { final objectify impl objectify = new objectify impl ( this , opts , transactor supplier ) ; stacks . get ( ) . add ( objectify ) ; return objectify ; }	This is only public because it is used from the impl package; don't use this as a public API.
public void close ( final objectify ofy ) { final deque < objectify > stack = stacks . get ( ) ; if ( stack . is empty ( ) ) throw new illegal state exception ( str ) ; final objectify popped = stack . remove last ( ) ; assert popped == ofy : str ; }	Pops context off of stack after a transaction completes.
public static void homogenize indexes ( final list < value < ? > > list ) { if ( is index homogeneous ( list ) ) return ; for ( int i = num ; i < list . size ( ) ; i ++ ) { final value < ? > value = list . get ( i ) ; if ( value . exclude from indexes ( ) ) list . set ( i , index ( value , bool ) ) ; } }	The datastore has a weird behavior of reordering values in a list so that indexed ones come before nonindexedones.
public static < t > ref < t > create ( t value ) { key < t > key = key . create ( value ) ; return create ( key ) ; }	Creates a Ref from a registered pojo entity.
final public t safe ( ) throws not found exception { t t = this . get ( ) ; if ( t == null ) throw new not found exception ( key ( ) ) ; else return t ; }	Obtain the entity value, throwing an exception if the entity was not found.
public boolean add ( k key , v value ) { list < v > list = this . get ( key ) ; if ( list == null ) { list = new array list < > ( ) ; this . put ( key , list ) ; } return list . add ( value ) ; }	Adds a value to the set associated with the key.
@ override public boolean is done ( ) { boolean done = this . raw . is done ( ) ; if ( ! triggered && done ) { this . triggered = bool ; pending futures . remove pending ( this ) ; this . trigger ( ) ; } return done ; }	This version also checks to see if we are done and we still need to call the trigger.If so, it calls it.
public if < ? , ? > [ ] generate if conditions ( class < ? extends if < ? , ? > > [ ] if classes , field field ) { if ( if classes . length == num ) return always ; if < ? , ? > [ ] result = new if < ? , ? > [ if classes . length ] ; for ( int i = num ; i < if classes . length ; i ++ ) { class < ? extends if < ? , ? > > if class = if classes [ i ] ; result [ i ] = this . create if ( if class , field ) ;	Clever enough to recognize that an empty set of conditions means Always.
public void done ( ) { engine . execute ( ) ; while ( deferred != null ) { final list < runnable > runme = deferred ; deferred = null ;	Call this when a load process completes.
public object get container ( type container type , path path ) { class < ? > container class = generic type reflector . erase ( container type ) ; iterator < object > containers it = containers . descending iterator ( ) ;	Get the container object which is appropriate for the specified property.
private stat get stat ( string kind ) { stat stat = this . stats . get ( kind ) ; if ( stat == null ) { stat = new stat ( ) ; this . stats . put ( kind , stat ) ; } return stat ; }	We're just tracking statistics so we don't really need to worry about these stepping on each other;if there's a hit or miss lost no big deal.
public static void unwrap and throw ( throwable ex ) { if ( ex instanceof runtime exception ) throw ( runtime exception ) ex ; else if ( ex instanceof error ) throw ( error ) ex ; else if ( ex instanceof execution exception ) unwrap and throw ( ex . get cause ( ) ) ; else throw new undeclared throwable exception ( ex ) ; }	Properly unwraps ExecutionException, throwing the relevant original cause.
public < p , d > translator < p , d > get ( final type key tk , final create context ctx , final path path ) { translator < ? , ? > translator = translators . get ( tk ) ; if ( translator == null ) { translator = create ( tk , ctx , path ) ; translators . put ( tk , translator ) ; }	Obtains the Translator appropriate for this type and annotations.
public < p > translator < p , full entity < ? > > get root ( final class < p > clazz ) { return get ( new type key ( clazz ) , new create context ( fact ) , path . root ( ) ) ; }	Get the translator for a root entity class.
private translator < ? , ? > create ( final type key tk , final create context ctx , final path path ) { for ( final translator factory < ? , ? > trans : this . translator factories ) { @ suppress warnings ( str ) final translator < ? , ? > so far = trans . create ( tk , ctx , path ) ; if ( so far != null ) return so far ; } throw new illegal argument exception ( str + tk . get type ( ) + str + arrays . to string ( tk . get annotations ( ) ) ) ; }	Create a translator from scratch by going through the discovery process.
@ override public void load ( final full entity < ? > container , final load context ctx , final path container path , final p into pojo ) { try { if ( translator instanceof recycles ) ctx . recycle ( property . get ( into pojo ) ) ; final value < d > value = ( translator instanceof synthetic ) ? null : get property from container ( container , container path ) ;	Gets the appropriate value from the container and sets it on the appropriate field of the pojo.
private value < d > get property from container ( final full entity < ? > container , final path container path ) { string found name = null ; value < d > value = null ; for ( string name : property . get load names ( ) ) { if ( container . contains ( name ) ) { if ( found name != null ) throw new illegal state exception ( str + property . get name ( ) + str + container path . extend ( found name ) + str + container path . extend ( name ) + str ) ;	Gets the relevant property from the container, detecting alsoload collisions.
public void set value ( final object pojo , final value < d > value , final load context ctx , final path container path ) throws skip exception { final path property path = container path . extend ( property . get name ( ) ) ; final p loaded = translator . load ( value , ctx , property path ) ; set on pojo ( pojo , loaded , ctx , property path ) ; }	Set this raw datastore value on the relevant property of the pojo, doing whatever translations are necessary.
@ override public void save ( final p on pojo , boolean index , final save context ctx , final path container path , final full entity . builder < ? > into ) { if ( property . is saved ( on pojo ) ) {	Gets the appropriate field value from the pojo and puts it in the container at the appropriate prop nameand with the appropriate indexing.
public value < d > get value ( final object pojo , final save context ctx , final path container path ) { @ suppress warnings ( str ) final p value = ( p ) property . get ( pojo ) ; return translator . save ( value , bool , ctx , container path . extend ( property . get name ( ) ) ) ; }	Get the value for the property and translate it into datastore format.
@ suppress warnings ( str ) protected final < em extends extendable message < em > > void write extensions ( em msg , json generator gen ) throws io { boolean open ext = bool ; for ( map . entry < field descriptor , object > field : msg . get all fields ( ) . entry set ( ) ) { field descriptor fd = field . get key ( ) ; if ( fd . is extension ( ) ) { if ( fd . is repeated ( ) ) { list < object > ext value = ( list < object > ) field . get value ( ) ; if ( ! ext value . is empty ( ) ) { open rtb json ext writer < object > ext writer = factory . get writer ( msg . get class ( ) , ext value . get ( num ) . get class ( ) , fd . get name ( ) ) ; if ( ext writer != null ) { open ext = open ext ( gen , open ext ) ; ext writer . write repeated ( ext value , gen ) ; } } } else { object ext value = field . get value ( ) ; open rtb json ext writer < object > ext writer = factory . get writer ( msg . get class ( ) , ext value . get class ( ) , fd . get name ( ) ) ; if ( ext writer != null ) { open ext = open ext ( gen , open ext ) ; ext writer . write single ( ext value , gen ) ; } } } } if ( open ext ) { gen . write end object ( ) ; } }	Write any extensions that may exist in a message.
protected final boolean write content category ( string cat , json generator gen ) throws io { if ( ! factory . is strict ( ) || open rtb utils . category from name ( cat ) != null ) { gen . write string ( cat ) ; return bool ; } else { return bool ; } }	Writes a string that represents a ContentCategory's JSON name, returning success status.If the factory is in strict mode, the category name is validated.
protected final void write content categories ( string field name , list < string > cats , json generator gen ) throws io { if ( ! cats . is empty ( ) ) { gen . write array field start ( field name ) ; for ( string cat : cats ) { write content category ( cat , gen ) ; } gen . write end array ( ) ; } }	Writes an array of ContentCategory if not empty.
public string process ( snippet processor context ctx , string snippet ) { check not null ( ctx ) ; string builder sb = ctx . builder ( ) ; sb . set length ( num ) ; string curr snippet = snippet ; boolean processed macros = bool ; int snippet pos = num ; int macro pos = curr snippet . index of ( str ) ; while ( macro pos != - num ) { sb . append ( curr snippet . substring ( snippet pos , macro pos ) ) ; int macro end = process macro at ( ctx , curr snippet , macro pos ) ; if ( macro end == - num ) { sb . append ( str ) ; snippet pos = macro pos + num ; } else { snippet pos = macro end ; processed macros = bool ; } macro pos = curr snippet . index of ( str , snippet pos ) ; } if ( processed macros ) { sb . append ( curr snippet , snippet pos , curr snippet . length ( ) ) ; curr snippet = sb . to string ( ) ; } sb . set length ( num ) ; string ret = url encode ( ctx , curr snippet ) ; sb . set length ( num ) ; return ret ; }	Processes the raw snippet that was set by the bid, making any transformations necessary.
public static iterable < bid . builder > bids ( bid response . builder response ) { return new response bids iterator ( response , seat any , null ) ; }	Iterates all bids.
@ nullable public static bid . builder bid with id ( bid response . builder response , string id ) { check not null ( id ) ; for ( seat bid . builder seatbid : response . get seatbid builder list ( ) ) { for ( bid . builder bid : seatbid . get bid builder list ( ) ) { if ( id . equals ( bid . get id ( ) ) ) { return bid ; } } } return null ; }	Finds a bid by ID.
public static boolean update bids ( bid response . builder response , function < bid . builder , boolean > updater ) { check not null ( updater ) ; boolean updated = bool ; for ( seat bid . builder seatbid : response . get seatbid builder list ( ) ) { updated |= proto utils . update ( seatbid . get bid builder list ( ) , updater ) ; } return updated ; }	Updates bids, from all seats.
public static boolean remove bids ( bid response . builder response , predicate < bid . builder > filter ) { check not null ( filter ) ; boolean updated = bool ; for ( seat bid . builder seatbid : response . get seatbid builder list ( ) ) { updated |= remove bids ( seatbid , filter ) ; } return updated ; }	Remove bids by bid.
protected final < eb extends extendable builder < ? , eb > > void read extensions ( eb msg , json parser par ) throws io { @ suppress warnings ( str ) set < open rtb json ext reader < eb > > ext readers = factory . get readers ( ( class < eb > ) msg . get class ( ) ) ; if ( ext readers . is empty ( ) ) { par . skip children ( ) ; return ; } start object ( par ) ; json token tok last = par . get current token ( ) ; json location loc last = par . get current location ( ) ; while ( bool ) { boolean ext read = bool ; for ( open rtb json ext reader < eb > ext reader : ext readers ) { if ( ext reader . filter ( par ) ) { ext reader . read ( msg , par ) ; json token tok new = par . get current token ( ) ; json location loc new = par . get current location ( ) ; boolean advanced = tok new != tok last || ! loc new . equals ( loc last ) ; ext read |= advanced ; if ( ! end object ( par ) ) { return ; } else if ( advanced && par . get current token ( ) != json token . field name ) { tok last = par . next token ( ) ; loc last = par . get current location ( ) ; } else { tok last = tok new ; loc last = loc new ; } } } if ( ! end object ( par ) ) {	Read any extensions that may exist in a message.
protected final boolean empty to null ( json parser par ) throws io { json token token = par . get current token ( ) ; if ( token == null ) { token = par . next token ( ) ; } return ! factory ( ) . is strict ( ) && token == null ; }	Special case for empty-string input. Returning null in non-.
public final < eb extends extendable builder < ? , eb > > open rtb json factory register ( open rtb json ext reader < eb > ext reader , class < eb > msg klass ) { ext readers . put ( msg klass . get name ( ) , ext reader ) ; return this ; }	Register an extension reader.
public final < t > open rtb json factory register ( open rtb json ext writer < t > ext writer , class < t > ext klass , class < ? extends message > msg klass , string field name ) { map < string , map < string , open rtb json ext writer < ? > > > map msg = ext writers . get ( msg klass . get name ( ) ) ; if ( map msg == null ) { ext writers . put ( msg klass . get name ( ) , map msg = new linked hash map < > ( ) ) ; } map < string , open rtb json ext writer < ? > > map klass = map msg . get ( ext klass . get name ( ) ) ; if ( map klass == null ) { map msg . put ( ext klass . get name ( ) , map klass = new linked hash map < > ( ) ) ; } map klass . put ( field name == null ? fieldname all : field name , ext writer ) ; return this ; }	Register an extension writer, bound to a specific field name.
public void process ( snippet processor context bid ctx ) { for ( seat bid . builder seat : bid ctx . response ( ) . get seatbid builder list ( ) ) { for ( bid . builder bid : seat . get bid builder list ( ) ) { bid ctx . set bid ( bid ) ; process fields ( bid ctx ) ; } } }	Processes the context's response in-place, modifying properties that may contain macros.
protected void process fields ( snippet processor context bid ctx ) { bid . builder bid = bid ctx . get bid ( ) ;	Processes all fields of a bid that should support macro expansion.
public static < b extends message lite . builder > boolean update ( iterable < b > objs , function < b , boolean > updater ) { check not null ( updater ) ; boolean updated = bool ; for ( b obj : objs ) { updated |= updater . apply ( obj ) ; } return updated ; }	Updates every builder from a sequence.
public static < m extends message lite or builder > list < m > filter ( list < m > objs , predicate < m > filter ) { check not null ( filter ) ; for ( int i = num ; i < objs . size ( ) ; ++ i ) { if ( ! filter . test ( objs . get ( i ) ) ) {	Runs a filter through a sequence of objects.
public static string get current name ( json parser par ) throws io { string name = par . get current name ( ) ; return name == null ? str : name ; }	Returns the current field name, or empty string if none.
public static void start object ( json parser par ) throws io { json token token = par . get current token ( ) ; if ( token == null || token == json token . field name ) { token = par . next token ( ) ; } if ( token == json token . start object ) { par . next token ( ) ; } else { throw new json parse exception ( par , str ) ; } }	Starts an Object, skipping the '{' token, and if necessary a field name before it.
public static void start array ( json parser par ) throws io { json token token = par . get current token ( ) ; if ( token == null || token == json token . field name ) { token = par . next token ( ) ; } if ( token == json token . start array ) { par . next token ( ) ; } else { throw new json parse exception ( par , str ) ; } }	Starts an Array, skipping the '[' token, and if necessary a field name before it.
public static json token peek token ( json parser par ) throws io { json token token = par . get current token ( ) ; if ( token == null || token == json token . field name ) { token = par . next token ( ) ; } return token ; }	Skips a field name if necessary, returning the current token then.
public static void write int bool field ( string field name , boolean data , json generator gen ) throws io { gen . write number field ( field name , data ? num : num ) ; }	Writes a boolean as int, where false = 0 and true = 1.
public static void write strings ( string field name , list < string > data , json generator gen ) throws io { if ( ! data . is empty ( ) ) { gen . write array field start ( field name ) ; for ( string d : data ) { gen . write string ( d ) ; } gen . write end array ( ) ; } }	Writes a string array if not empty.
public static void write ints ( string field name , list < integer > data , json generator gen ) throws io { if ( ! data . is empty ( ) ) { gen . write array field start ( field name ) ; for ( integer d : data ) { gen . write number ( d ) ; } gen . write end array ( ) ; } }	Writes an int array if not empty.
public static void write longs ( string field name , list < long > data , json generator gen ) throws io { if ( ! data . is empty ( ) ) { gen . write array field start ( field name ) ; for ( long d : data ) { write long ( d , gen ) ; } gen . write end array ( ) ; } }	Writes a long array if not empty, using quotes for values that are too big.
public static void write enums ( string field name , list < ? extends protocol message enum > enums , json generator gen ) throws io { if ( ! enums . is empty ( ) ) { gen . write array field start ( field name ) ; for ( protocol message enum e : enums ) { write enum ( e , gen ) ; } gen . write end array ( ) ; } }	Writes a enum array if not empty.
public static url resolve url ( url base , string target ) throws url { target = target . trim ( ) ; if ( target . starts with ( str ) ) { return fix pure query targets ( base , target ) ; } return new url ( base , target ) ; }	Resolve relative URL-s and fix a few java.net.URL errors in handling ofURLs with embedded params and pure query targets.
static url fix pure query targets ( url base , string target ) throws url { if ( ! target . starts with ( str ) ) return new url ( base , target ) ; string base path = base . get path ( ) ; string base right most = str ; int base right most idx = base path . last index of ( str ) ; if ( base right most idx != - num ) { base right most = base path . substring ( base right most idx + num ) ; } if ( target . starts with ( str ) ) target = base right most + target ; return new url ( base , target ) ; }	Handle the case in RFC3986 section 5.4.1 example 7, and similar.
public static string [ ] get host segments ( url url ) { string host = url . get host ( ) ;	Partitions of the hostname of the url by ".".
public static string get host ( string url ) { try { return new url ( url ) . get host ( ) . to lower case ( locale . root ) ; } catch ( url e ) { return null ; } }	Returns the lowercased hostname for the url or null if the url is notwell formed.
public static string get page ( string url ) { try {	Returns the page for the url.
public static list < string > load list from conf ( string param key , map storm conf ) { object obj = storm conf . get ( param key ) ; list < string > list = new linked list < > ( ) ; if ( obj == null ) return list ; if ( obj instanceof persistent vector ) { list . add all ( ( persistent vector ) obj ) ; } else {	Return one or more Strings regardless of whether they are represented asa single String or a list in the config or an empty List if no valuecould be found for that key.
public static map extract config element ( map conf ) { if ( conf . size ( ) == num ) { object conf node = conf . get ( str ) ; if ( conf node != null && conf node instanceof map ) { conf = ( map ) conf node ; } } return conf ; }	If the config consists of a single key 'config', its values are usedinstead.
public synchronized protocol get protocol ( url url ) {	Returns an instance of the protocol to use for a given URL.
public static byte [ ] generate warc ( map < string , string > fields ) { string buffer buffer = new string buffer ( ) ; buffer . append ( warc version ) ; buffer . append ( crlf ) ; buffer . append ( str ) . append ( crlf ) ; string main id = uuid . random uuid ( ) . to string ( ) ;	Generates a WARC info entry which can be stored at the beginning of eachWARC file.
public static string extract refresh url ( string value ) { if ( string utils . is blank ( value ) ) return null ;	Returns a normalised value of the content attribute for the refresh tag.
public metadata get meta for outlink ( string target url , string source url , metadata parent md ) { metadata md = filter ( parent md , md to transfer ) ;	Determine which metadata should be transfered to an outlink.
public metadata filter ( metadata metadata ) { metadata filtered md = filter ( metadata , md to transfer ) ;	Determine which metadata should be persisted for a given documentincluding those which are not necessarily transferred to the outlinks.
public static void add ( string url , metadata md , date next fetch ) { log . debug ( str , url , md , next fetch ) ; url tuple = new url ( url , md , next fetch ) ; synchronized ( queue ) { queue . add ( tuple ) ; } }	Add a new URL.
public static string clean field name ( string name ) { string lowercase = name . to lower case ( ) ; lowercase = lowercase . replace all ( str , str ) ; if ( lowercase . length ( ) < num || lowercase . length ( ) > num ) throw new runtime exception ( str + lowercase ) ; if ( lowercase . equals ( str ) ) throw new runtime exception ( str ) ; return lowercase ; }	Remove the non-cloudSearch-legal characters.
private static string get charset from bom ( final byte [ ] byte data ) { bom bom in = new bom ( new byte array input stream ( byte data ) ) ; try { byte order mark bom = bom in . get bom ( ) ; if ( bom != null ) { return bom . get charset name ( ) ; } } catch ( io e ) { return null ; } return null ; }	Detects any BOMs and returns the corresponding charset.
private static string get charset from text ( byte [ ] content , string declared charset , int max length charset detection ) { string charset = null ;	Use a third party library as last resort to guess the charset from thebytes.
private static string get charset from meta ( byte buffer [ ] , int maxlength ) {	Attempt to find a META tag in the HTML that hints at the character setused to write the document.
private final boolean sniff ( byte [ ] content ) { byte [ ] beginning = content ; if ( content . length > max offset guess && max offset guess > num ) { beginning = arrays . copy of range ( content , num , max offset guess ) ; } int position = bytes . index of ( beginning , clue ) ; if ( position != - num ) { return bool ; } return bool ; }	Examines the first bytes of the content for a clue of whether thisdocument is a sitemap, based on namespaces.
public void set value ( string key , string value ) { md . put ( key , new string [ ] { value } ) ; }	Set the value for a given key.
public static string get first value ( metadata md , string ... keys ) { for ( string key : keys ) { string val = md . get first value ( key ) ; if ( string utils . is blank ( val ) ) continue ; return val ; } return null ; }	Returns the first non empty value found for the keys or null if nonefound.
public static list < cookie > get cookies ( string [ ] cookies strings , url target url ) { array list < cookie > list = new array list < cookie > ( ) ; for ( string cs : cookies strings ) { string name = null ; string value = null ; string expires = null ; string domain = null ; string path = null ; boolean secure = bool ; string [ ] tokens = cs . split ( str ) ; int equals = tokens [ num ] . index of ( str ) ; name = tokens [ num ] . substring ( num , equals ) ; value = tokens [ num ] . substring ( equals + num ) ; for ( int i = num ; i < tokens . length ; i ++ ) { string ti = tokens [ i ] . trim ( ) ; if ( ti . equals ignore case ( str ) ) secure = bool ; if ( ti . to lower case ( ) . starts with ( str ) ) { path = ti . substring ( num ) ; } if ( ti . to lower case ( ) . starts with ( str ) ) { domain = ti . substring ( num ) ; } if ( ti . to lower case ( ) . starts with ( str ) ) { expires = ti . substring ( num ) ; } } basic client cookie cookie = new basic client cookie ( name , value ) ;	Get a list of cookies based on the cookies string taken from responseheader and the target url.
public static boolean check domain match to url ( string cookie domain , string url host name ) { try { if ( cookie domain . starts with ( str ) ) { cookie domain = cookie domain . substring ( num ) ; } string [ ] domain tokens = cookie domain . split ( str ) ; string [ ] host tokens = url host name . split ( str ) ; int token dif = host tokens . length - domain tokens . length ; if ( token dif < num ) { return bool ; } for ( int i = domain tokens . length - num ; i >= num ; i -- ) { if ( ! domain tokens [ i ] . equals ignore case ( host tokens [ i + token dif ] ) ) { return bool ; } } return bool ; } catch ( exception e ) { return bool ; } }	Helper method to check if url matches a cookie domain.
protected static string get cache key ( url url ) { string protocol = url . get protocol ( ) . to lower case ( locale . root ) ; string host = url . get host ( ) . to lower case ( locale . root ) ; int port = url . get port ( ) ; if ( port == - num ) { port = url . get default port ( ) ; } return protocol + str + host + str + port ; }	Compose unique key to store and access robot rules in cache for given URL.
public base robot rules get robot rules set from cache ( url url ) { string cache key = get cache key ( url ) ; base robot rules robot rules = cache . get if present ( cache key ) ; if ( robot rules != null ) { return robot rules ; } return empty rules ; }	Returns the robots rules from the cache or empty rules if not found.
public void extract meta tags ( document fragment doc ) throws x { node list nodes = ( node list ) expression . evaluate ( doc , x . nodeset ) ; if ( nodes == null ) return ; int num nodes = nodes . get length ( ) ; for ( int i = num ; i < num nodes ; i ++ ) { node n = ( node ) nodes . item ( i ) ;	called by the parser bolts.
protected final void ack ( tuple t , string url ) {	Must be called by extending classes to store and collect in one go.
public boolean filter ( string url , metadata metadata ) throws url { url u = new url ( url ) ;	Try the rules from the hostname, domain name, metadata and global scopesin this order.
@ override public string filter ( url source url , metadata source metadata , string url string ) { iterator < rule > i = rules . iterator ( ) ; while ( i . has next ( ) ) { rule r = i . next ( ) ; matcher matcher = r . pattern . matcher ( url string ) ; url string = matcher . replace all ( r . substitution ) ; } if ( url string . equals ( str ) ) { url string = null ; } return url string ; }	This function does the replacements by iterating through all the regexpatterns.
private list < rule > read rules ( string rules file ) { try { input stream regex stream = get class ( ) . get class loader ( ) . get resource as stream ( rules file ) ; reader reader = new input stream reader ( regex stream , standard charsets . utf 8 ) ; return read configuration ( reader ) ; } catch ( exception e ) { log . error ( str , e ) ; return empty rules ; } }	Reads the configuration file and populates a List of Rules.
private string process query elements ( string url to filter ) { try {	Basic filter to remove query parameters from urls so parameters thatdon't change the content of the page can be removed.
@ suppress warnings ( str ) public static navigation filters from conf ( map storm conf ) { string configfile = conf utils . get string ( storm conf , str ) ; if ( string utils . is not blank ( configfile ) ) { try { return new navigation filters ( storm conf , configfile ) ; } catch ( io e ) { string message = str + configfile ; log . error ( message ) ; throw new runtime exception ( message , e ) ; } } return navigation filters . empty navigation filters ; }	Loads and configure the NavigationFilters based on the storm config ifthere is one otherwise returns an emptyNavigationFilters.
public gzip hdfs bolt add record format ( record format format , int position ) { multiple record format formats ; if ( this . format == null ) { formats = new multiple record format ( format ) ; this . format = formats ; } else { if ( this . format instanceof multiple record format ) { formats = ( multiple record format ) this . format ; } else { formats = new multiple record format ( this . format ) ; this . format = formats ; } formats . add format ( new gzipped record format ( format ) , position ) ; } return this ; }	Add an additional record format at given position.
private long throttle queries ( ) { if ( time last query sent != num ) {	Returns the amount of time to wait if the backend was queried toorecently and needs throttling or -1 if the backend can be queriedstraight away.
private boolean trigger queries ( ) { if ( time last query received != num && max delay between queries > num ) {	Indicates whether enough time has elapsed since receiving the results ofthe previous query so that a new one can be sent even if the buffer isnot empty.
@ suppress warnings ( str ) public static parse filters from conf ( map storm conf ) { string parseconfigfile = conf utils . get string ( storm conf , str ) ; if ( string utils . is not blank ( parseconfigfile ) ) { try { return new parse filters ( storm conf , parseconfigfile ) ; } catch ( io e ) { string message = str + parseconfigfile ; log . error ( message ) ; throw new runtime exception ( message , e ) ; } } return parse filters . empty parse filter ; }	Loads and configure the ParseFilters based on the storm config if thereis one otherwise returns an emptyParseFilter.
protected void append ( node new node ) throws org . xml . sax . sax { node current node = m current node ; if ( null != current node ) { current node . append child ( new node ) ;	Append a node to the current container.
@ override public void processing instruction ( string target , string data ) throws org . xml . sax . sax { append ( m doc . create processing instruction ( target , data ) ) ; }	Receive notification of a processing instruction.
@ override public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . sax {	Report an XML comment anywhere in the document.This callback will be used for comments inside or outside the documentelement, including comments in the external DTD subset (if read).
@ override public void start dtd ( string name , string public id , string system id ) throws org . xml . sax . sax {	Report the start of DTD declarations, if any.Any declarations are assumed to be in the internal subset unlessotherwise indicated.
protected string value for url ( tuple tuple ) { string url = tuple . get string by field ( str ) ; metadata metadata = ( metadata ) tuple . get value by field ( str ) ;	Returns the value to be used as the URL for indexing purposes, if presentthe canonical value is used instead.
protected string trim text ( string text ) { if ( max length text == - num ) return text ; if ( text == null ) return text ; if ( text . length ( ) <= max length text ) return text ; return text . substring ( num , max length text ) ; }	Returns a trimmed string or the original one if it is below the thresholdset in the configuration.
protected final optional < integer > check custom interval ( metadata metadata , status s ) { if ( custom intervals == null ) return optional . empty ( ) ; for ( custom interval custom interval : custom intervals ) { string [ ] values = metadata . get values ( custom interval . key ) ; if ( values == null ) { continue ; } for ( string v : values ) { if ( v . equals ( custom interval . value ) ) { return custom interval . get duration for status ( s ) ; } } } return optional . empty ( ) ; }	Returns the first matching custom interval.
public static url from conf ( map storm conf ) { string config file = conf utils . get string ( storm conf , str ) ; if ( string utils . is not blank ( config file ) ) { try { return new url ( storm conf , config file ) ; } catch ( io e ) { string message = str + config file ; log . error ( message ) ; throw new runtime exception ( message , e ) ; } } return url . empty url ; }	Loads and configure the URLFilters based on the storm config if there isone otherwise returns an empty URLFilter.
public void set wheel item count ( int count ) { m item count = count ; m item angle = calculate item angle ( count ) ; if ( m wheel bounds != null ) { invalidate ( ) ;	Sets the number of items to be displayed on the wheel.
public static int resolve size and state ( int size , int measure spec ) { int result = size ; int spec mode = measure spec . get mode ( measure spec ) ; int spec size = measure spec . get size ( measure spec ) ; switch ( spec mode ) { case measure spec . unspecified : result = size ; break ; case measure spec . at most : if ( spec size < size ) { result = spec size ; } else { result = size ; } break ; case measure spec . exactly : result = spec size ; break ; } return result ; }	Taken and modified from Android Source for API < 11.
public void set empty item drawable ( drawable drawable ) { m empty item drawable = drawable ; empty cache item . m drawable = drawable ; if ( m wheel bounds != null ) { invalidate ( ) ; } }	Sets the empty item drawable that is drawn when outside of the adapter range.
public void set angle ( float angle ) { m angle = angle ; update selected position ( ) ; if ( m on angle change listener != null ) { m on angle change listener . on wheel angle change ( m angle ) ; } invalidate ( ) ; }	Set the angle of the wheel instantaneously.Note this does not animate to the provided angle.
private void update selected position ( ) { int position = ( int ) ( ( - m angle + - num * math . signum ( m angle ) * m item angle ) / m item angle ) ; set selected position ( position ) ; }	Checks to see if the selectedPosition has changed.
public void invalidate wheel item drawable ( int position ) { int adapter pos = raw position to adapter position ( position ) ; if ( is empty item position ( adapter pos ) ) return ; cache item cache item = m item cache array [ adapter pos ] ; if ( cache item != null ) cache item . m dirty = bool ; invalidate ( ) ; }	Invalidate the drawable at the specific position so that the next Draw callwill refresh the Drawable at this given position in the adapter.
public int raw position to wheel position ( int position , int adapter position ) { int circular offset = m is repeatable ? ( ( int ) math . floor ( ( position / ( float ) m adapter item count ) ) * ( m adapter item count - m item count ) ) : num ; return circle . clamp ( adapter position + circular offset , m item count ) ; }	Converts the raw position to a position within the wheel item bounds.
private void update ( float delta time ) { float vel = m angular velocity ; float vel sqr = vel * vel ; if ( vel > num ) {	Estimates the wheel's new angle and angular velocity.
private int get contrast color ( map . entry < string , integer > entry ) { string color name = material color . get color name ( entry ) ; return material color . get contrast color ( color name ) ; }	get the materials darker contrast.
static int clamp ( int value , int upper limit ) { if ( value < num ) { return value + ( - num * ( int ) math . floor ( value / ( float ) upper limit ) ) * upper limit ; } else { return value % upper limit ; } }	Clamps the value to a number between 0 and the upperLimit.
protected void write coveralls ( final json writer writer , final source callback source callback , final list < coverage parser > parsers ) throws processing exception , io { try { get log ( ) . info ( str + writer . get coveralls file ( ) . get absolute path ( ) + str ) ; long now = system . current time millis ( ) ; source callback . on begin ( ) ; for ( coverage parser parser : parsers ) { get log ( ) . info ( str + parser . get coverage file ( ) . get absolute path ( ) ) ; parser . parse ( source callback ) ; } source callback . on complete ( ) ; long duration = system . current time millis ( ) - now ; get log ( ) . info ( str + duration + str ) ; } finally { writer . close ( ) ; } }	Writes coverage data to JSON file.
@ override public byte buffer get data as byte buffer ( ) { byte buffer bb = byte buffer . allocate ( ( int ) get size ( ) ) ; reset local iterator ( ) ; while ( has next ( ) ) bb . put ( next byte ( ) ) ; return bb ; }	Trasfer data to a ByteBuffer.Note we cast char to byte, discarding top byte, if any.This is because CDM char is really a byte, not a java char.
public void set string ( string val ) { int rank = get rank ( ) ; if ( rank != num ) throw new illegal argument exception ( str ) ; int array len = index calc . get shape ( num ) ; int str len = math . min ( val . length ( ) , array len ) ; for ( int k = num ; k < str len ; k ++ ) storage [ k ] = val . char at ( k ) ; char c = num ; for ( int k = str len ; k < array len ; k ++ ) storage [ k ] = c ; }	Set the ArrayChar values from the characters in the String.
public array object make1 d ( ) { int nelems = ( get rank ( ) == num ) ? num : ( int ) get size ( ) / index calc . get shape ( get rank ( ) - num ) ; array sarr = array . factory ( data type . string , new int [ ] { nelems } ) ; index iterator newsiter = sarr . get index iterator ( ) ; array char . string iterator siter = get string iterator ( ) ; while ( siter . has next ( ) ) { newsiter . set object next ( siter . next ( ) ) ; } return ( array object ) sarr ; }	Make this into the equivilent 1D ArrayObject of Strings.
public static array char make from string ( string s , int max ) { array char result = new array char . d1 ( max ) ; for ( int i = num ; i < max && i < s . length ( ) ; i ++ ) result . set char ( i , s . char at ( i ) ) ; return result ; }	Create an ArrayChar from a String.
public static array char make from string array ( array object values ) {	Create an ArrayChar from an ArrayObject of Strings.
public static array char make from string array ( array object values , int strlen ) {	Create an ArrayChar from an ArrayObject of Strings.Inverse of make1DStringArray.
@ override public int [ ] get forecast time interval offset ( grib2 record gr ) { grib2 pds pds = gr . get pds ( ) ; if ( ! pds . is time interval ( ) ) { return null ; }	Reference time is the start time of the first forecast, other forecasts at 6-hour intervals. Number in Ave = number of forecast used.
public void show ( ) { set state ( frame . normal ) ;	show the window.
public void show if not iconified ( ) { if ( get state ( ) == frame . iconified ) return ;	show if not iconified.
static public long make size estimate ( ucar . nc2 . dt . grid dataset gds , list < string > grid list , lat lon rect llbb , projection rect proj rect , int horiz stride , range z range , calendar date range date range , int stride time , boolean add lat lon ) throws io , invalid range exception { cf writer2 = new cf ( ) ; return writer2 . write or test size ( gds , grid list , llbb , proj rect , horiz stride , z range , date range , stride time , add lat lon , bool , null ) ; }	Compute the size of the file without writing.
public static void main ( string [ ] args ) throws io { int count = num ; string file = ( args . length > num ) ? args [ num ] : str ; random access file raf = new random access file ( file , str ) ; system . out . printf ( str , raf . get location ( ) ) ; grib1 record scanner scan = new grib1 record scanner ( raf ) ; while ( scan . has next ( ) ) { scan . next ( ) ; count ++ ; } raf . close ( ) ; system . out . printf ( str , count ) ; }	Count the number of records in a grib1 file.
public static unit name new unit name ( final string name , final string plural ) throws name exception { return new unit name ( name , plural , null ) ; }	Factory method for constructing a UnitName from a name and a plural formof the name.
public static unit name new unit name ( final string name , final string plural , final string symbol ) throws name exception { return new unit name ( name , plural , symbol ) ; }	Factory method for constructing a UnitName from a name, a plural form ofthe name, and a symbol.
protected string make plural ( final string name ) { string plural ; final int length = name . length ( ) ; final char last char = name . char at ( length - num ) ; if ( last char != str ) { plural = name + ( last char == str || last char == str || last char == str || name . ends with ( str ) ? str : str ) ; } else { if ( length == num ) { plural = name + str ; } else { final char penultimate char = name . char at ( length - num ) ; plural = ( penultimate char == str || penultimate char == str || penultimate char == str || penultimate char == str || penultimate char == str ) ? name + str : name . substring ( num , length - num ) + str ; } } return plural ; }	Returns the plural form of a name.
public boolean included ( date d ) { if ( is empty ) return bool ; if ( get start ( ) . after ( d ) ) return bool ; if ( get end ( ) . before ( d ) ) return bool ; return bool ; }	Determine if the given date is included in this date range.The date range includes the start and end dates.
public date range intersect ( date range clip ) { if ( is empty ) return this ; if ( clip . is empty ) return clip ; date type ss = get start ( ) ; date type s = ss . before ( clip . get start ( ) ) ? clip . get start ( ) : ss ; date type ee = get end ( ) ; date type e = ee . before ( clip . get end ( ) ) ? ee : clip . get end ( ) ; return new date range ( s , e , null , resolution ) ; }	Intersect with another date range.
public void extend ( date range dr ) { boolean local empty = is empty ; if ( local empty || dr . get start ( ) . before ( get start ( ) ) ) set start ( dr . get start ( ) ) ; if ( local empty || get end ( ) . before ( dr . get end ( ) ) ) set end ( dr . get end ( ) ) ; }	Extend this date range by the given one.
public void extend ( date d ) { if ( d . before ( get start ( ) . get date ( ) ) ) set start ( new date type ( bool , d ) ) ; if ( get end ( ) . before ( d ) ) set end ( new date type ( bool , d ) ) ; }	Extend this date range by the given Date.
public void set start ( date type start ) { this . start = start ; use start = bool ; if ( use end ) { this . is moving = this . start . is present ( ) || this . end . is present ( ) ; use duration = bool ; recalc duration ( ) ; } else { this . is moving = this . start . is present ( ) ; this . end = this . start . add ( duration ) ; } check if empty ( ) ; }	Set the starting Date.
public void set end ( date type end ) { this . end = end ; use end = bool ; if ( use start ) { this . is moving = this . start . is present ( ) || this . end . is present ( ) ; use duration = bool ; recalc duration ( ) ; } else { this . is moving = this . end . is present ( ) ; this . start = this . end . subtract ( duration ) ; } check if empty ( ) ; }	Set the ending Date.
public void set duration ( time duration duration ) { this . duration = duration ; use duration = bool ; if ( use start ) { this . is moving = this . start . is present ( ) ; this . end = this . start . add ( duration ) ; use end = bool ; } else { this . is moving = this . end . is present ( ) ; this . start = this . end . subtract ( duration ) ; } check if empty ( ) ; }	Set the duration of the interval.
public void add map bean ( map bean mb ) { map bean menu . add action ( mb . get action desc ( ) , mb . get icon ( ) , mb . get action ( ) ) ;	add a MapBean to the User Interface.
public void yyerror ( string s ) { system . err . println ( str + s + str + charno + str ) ; string context = get input ( ) ; int show = ( context . length ( ) < contextlen ? context . length ( ) : contextlen ) ; system . err . println ( context . substring ( context . length ( ) - show ) + str ) ; new exception ( ) . print stack trace ( system . err ) ; }	Entry point for error reporting.
public string get name ( ) { string loc = ncd . get location ( ) ; int pos = loc . last index of ( str ) ; if ( pos < num ) pos = loc . last index of ( str ) ; return ( pos < num ) ? loc : loc . substring ( pos + num ) ; }	the name of the dataset is the last part of the location.
public string params to string ( ) { formatter f = new formatter ( ) ; f . format ( str , lat0deg , lon0deg , par1deg , par2deg , earth ) ; return f . to string ( ) ; }	Create a String of the parameters.
public dsp open ( byte [ ] rawdata ) throws dap exception { try { this . raw = rawdata ; byte array input stream stream = new byte array input stream ( this . raw ) ; chunk input stream rdr = new chunk input stream ( stream , request mode . dap ) ; string document = rdr . read dmr ( ) ; byte [ ] serialdata = dap util . readbinaryfile ( rdr ) ; super . build ( document , serialdata , rdr . get remote byte order ( ) ) ; return this ; } catch ( io ioe ) { throw new dap exception ( ioe ) . set code ( dap codes . sc internal server error ) ; } }	Extension to access a raw byte stream.
private optional < list < range iterator > > compute bounds ( lat lon rect llbb , int horiz stride ) { synchronized ( this ) { if ( edges == null ) edges = new edges ( ) ; } return edges . compute bounds exhaustive ( llbb , horiz stride ) ; }	return y, x ranges.
private void synch ui ( boolean sliders ok ) { event ok = bool ; if ( sliders ok ) min slider . set value ( scale . world2slider ( date range . get start ( ) ) ) ; min field . set value ( date range . get start ( ) ) ; if ( max field != null ) { if ( sliders ok ) max slider . set value ( scale . world2slider ( date range . get end ( ) ) ) ; max field . set value ( date range . get end ( ) ) ; } if ( duration field != null ) duration field . set value ( date range . get duration ( ) ) ; event ok = bool ; }	set values on the UI.
public int [ ] compute unlimited chunking ( list < dimension > dims , int elem size ) { int max elements = default chunk size / elem size ; int [ ] result = fill rightmost ( convert unlimited shape ( dims ) , max elements ) ; long result size = new section ( result ) . compute size ( ) ; if ( result size < min chunksize ) { max elements = min chunksize / elem size ; result = incr unlimited shape ( dims , result , max elements ) ; } return result ; }	make it easy to test by using dimension list.
public void register ( path dir ) throws io { if ( ! enable ) return ; watch key key = dir . register ( watcher , entry create , entry delete , entry modify ) ; if ( trace ) { path prev = keys . get ( key ) ; if ( prev == null ) { system . out . format ( str , dir ) ; } else { if ( ! dir . equals ( prev ) ) { system . out . format ( str , prev , dir ) ; } } } keys . put ( key , dir ) ; }	Register the given directory with the WatchService.
public void process events ( ) { if ( ! enable ) return ; for ( ; ; ) {	Process all events for keys queued to the watcher.
static public feature dataset wrap ( feature type want feature type , netcdf dataset ncd , ucar . nc2 . util . cancel task task , formatter errlog ) throws io { if ( debug ) system . out . println ( str + ncd . get location ( ) + str + want feature type ) ;	Wrap a NetcdfDataset as a FeatureDataset.
static public boolean feature type ok ( feature type want , feature type fac type ) { if ( want == null ) return bool ; if ( want == fac type ) return bool ; if ( want == feature type . any point ) { return fac type . is point feature type ( ) ; } if ( fac type == feature type . any point ) { return want . is point feature type ( ) ; } if ( want == feature type . coverage ) { return fac type . is coverage feature type ( ) ; } if ( want == feature type . grid ) {	Determine if factory type matches wanted feature type.
static public feature type find feature type ( netcdf file ncd ) {	Try to determine the feature type of the dataset, by examining its metadata.
public int write catalog ( http servlet request req , http servlet response res , catalog cat , boolean is local catalog ) throws io { string cat html as string = convert catalog to html ( cat , is local catalog ) ;	Write an Catalog to the HttpServletResponse, return the size in bytes of the catalog written to the response.
string convert catalog to html ( catalog cat , boolean is local catalog ) { string builder sb = new string builder ( num ) ; string uri = cat . get uri string ( ) ; if ( uri == null ) uri = cat . get name ( ) ; if ( uri == null ) uri = str ; string catname = escape . html ( uri ) ;	Write a catalog in HTML, make it look like a file directory.
public string get user css ( ) { return new string builder ( ) . append ( str ) . append ( this . html config . prepare url string for html ( this . html config . get page css url ( ) ) ) . append ( str ) . to string ( ) ; }	public static final String UNIDATA_CSS.
public string get user head ( ) { return new string builder ( ) . append ( str ) . append ( str ) . append ( this . html config . prepare url string for html ( this . html config . get host inst logo url ( ) ) ) . append ( str ) . append ( str ) . append ( this . html config . get host inst logo alt ( ) ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( this . tds context . get webapp display name ( ) ) . append ( str ) . append ( str ) . to string ( ) ; }	public static final String UNIDATA_HEAD.
private object make dynamic catalog ( string path , uri base uri ) throws io { boolean is latest = path . ends with ( str ) ;	barfola on the return type.
private void add global services ( catalog builder cat ) {	rigamorole to modify invariant catalogs; we may need to add global services.
static public void init ( credentials provider provider , string user agent ) { if ( provider != null ) try { http . set global credentials provider ( provider ) ; } catch ( http e ) { throw new illegal argument exception ( e ) ; } if ( user agent != null ) http . set global user agent ( user agent + str ) ; else http . set global user agent ( str ) ; }	initialize the HttpClient layer.
@ urlencoded @ deprecated public static string get content as string ( http session , string urlencoded ) throws io { http use session = session ; try { if ( use session == null ) use session = http . new session ( urlencoded ) ; try ( http m = http . get ( use session , urlencoded ) ) { m . execute ( ) ; return m . get response as string ( ) ; } } finally { if ( ( session == null ) && ( use session != null ) ) use session . close ( ) ; } }	Get the content from a url.
public static int put content ( string urlencoded , string content ) throws io { try ( http m = http . put ( urlencoded ) ) { m . set request content ( new string entity ( content , str , str ) ) ; m . execute ( ) ; int result code = m . get status code ( ) ;	Put content to a url, using HTTP PUT.
protected front page get front page ( dap request drq , dap context cxt ) throws dap exception { if ( this . defaultroots == null ) {	Isolate front page builder so we can override if desired for testing.
@ override public catalog builder make catalog ( string match , string req path , uri cat uri ) throws io { state grib local state = ( state grib ) check state ( ) ; if ( local state == null ) return null ;	see top javadoc for possible URLs.
private thredds metadata . geospatial coverage extract geospatial ( grib collection immutable . gc group ) { gds horiz coord sys gds coord sys = group . get gds horiz coord sys ( ) ; lat lon rect llbb = grid coord sys . get lat lon bounding box ( gds coord sys . proj , gds coord sys . get start x ( ) , gds coord sys . get start y ( ) , gds coord sys . get end x ( ) , gds coord sys . get end y ( ) ) ; double dx = num , dy = num ; if ( gds coord sys . is lat lon ( ) ) { dx = math . abs ( gds coord sys . dx ) ; dy = math . abs ( gds coord sys . dy ) ; } return new thredds metadata . geospatial coverage ( llbb , null , dx , dy ) ; }	LOOK how come we arent using MetadataExtractor ??.
public grib collection immutable . dataset get single dataset or by type name ( grib collection immutable gc , string type name ) { if ( gc . get datasets ( ) . size ( ) == num ) return gc . get dataset ( num ) ; for ( grib collection immutable . dataset ds : gc . get datasets ( ) ) if ( ds . get type ( ) . to string ( ) . equals ignore case ( type name ) ) return ds ; return null ; }	kinda kludgey, but trying not keep URLs stable.
public boolean nearly equals ( vert coord value other ) { return misc . nearly equals ( value1 , other . value1 ) && misc . nearly equals ( value2 , other . value2 ) ; }	cannot do approx equals and be consistent with hashCode, so make seperate call.
public static id new unit id ( final string name , final string plural , final string symbol ) { id id ; try { id = name == null ? new unit symbol ( symbol ) : unit name . new unit name ( name , plural , symbol ) ; } catch ( final name exception e ) { id = null ;	Factory method for constructing an identifier from a name, plural, andsymbol.
public static grads attribute parse attribute ( string attr spec ) { string [ ] toks = attr spec . split ( str ) ; string buffer buf = new string buffer ( ) ; for ( int i = num ; i < toks . length ; i ++ ) { buf . append ( toks [ i ] ) ; buf . append ( str ) ; }	Parse an attribute spec.
int read top ( ucar . unidata . io . random access file raf ) throws io { int pos = num ;	read the header of input file and parsing the NOWRAD part.
public static int shorts to int ( short s1 , short s2 , boolean swap bytes ) { byte [ ] b = new byte [ num ] ; b [ num ] = ( byte ) ( s1 > > > num ) ; b [ num ] = ( byte ) ( s1 > > > num ) ; b [ num ] = ( byte ) ( s2 > > > num ) ; b [ num ] = ( byte ) ( s2 > > > num ) ; return bytes to int ( b , bool ) ; }	convert two short into a integer.
public static int bytes to int ( byte [ ] bytes , boolean swap bytes ) { byte a = bytes [ num ] ; byte b = bytes [ num ] ; byte c = bytes [ num ] ; byte d = bytes [ num ] ; if ( swap bytes ) { return ( ( a & num ) ) + ( ( b & num ) << num ) + ( ( c & num ) << num ) + ( ( d & num ) << num ) ; } else { return ( ( a & num ) << num ) + ( ( b & num ) << num ) + ( ( c & num ) << num ) + ( ( d & num ) ) ; } }	convert bytes into integer.
static public java . util . date get date ( int julian days , int msecs ) { long total = ( ( long ) ( julian days - num ) ) * num * num * num + msecs ; return new date ( total ) ; }	get jave date.
public static string make valid netcdf object name ( string name ) { string builder sb = new string builder ( name ) ; while ( sb . length ( ) > num ) { int cp = sb . code point at ( num ) ;	Convert a name to a legal netcdf-3 name.
static public boolean is valid netcdf3 object name ( string name ) { matcher m = object name pattern old . matcher ( name ) ; return m . matches ( ) ; }	Determine if the given name can be used for a Dimension, Attribute, or Variable name.Should match makeValidNetcdf3ObjectName.
private ucar . ma2 . array read record data ( ucar . nc2 . structure s , section section ) throws java . io . io {	Read data from record structure.
private ucar . ma2 . array read record data subset ( ucar . nc2 . structure s , section section ) throws java . io . io { range record range = section . get range ( num ) ; int nrecords = record range . length ( ) ;	Read data from record structure, that has been subsetted.Read one record at at time, put requested variable into ArrayStructureMA.
protected void fill non record variables ( ) throws io {	fill buffer with fill value.
public grads time struct make time struct ( int time index ) { double t val = get values ( ) [ time index ] ; date d = date unit . get standard date ( t val + str + get unit ( ) ) ; calendar calendar = calendar . get instance ( ) ; calendar . set time zone ( java . util . time zone . get time zone ( str ) ) ; calendar . set time ( d ) ; return make time struct ( calendar ) ; }	Make a time struct from the index.
private grads time struct make time struct ( calendar calendar ) { grads time struct ts = new grads time struct ( ) ; ts . year = calendar . get ( calendar . year ) ; ts . month = calendar . get ( calendar . month ) + num ;	Make a GradsTimeStruct from the calendar state.
public static boolean has time template ( string template ) { for ( int i = num ; i < time templates . length ; i ++ ) { if ( template . index of ( time templates [ i ] ) >= num ) { return bool ; } } return bool ; }	Does this file definition have a time template in it?.
public void add ( server side function function ) { if ( function instanceof bool function ) { bool functions . put ( function . get name ( ) , function ) ; } if ( function instanceof bt ) { bt functions . put ( function . get name ( ) , function ) ; } }	Adds a function to the library.
public bool function get bool function ( string name ) throws no such function exception { if ( ! bool functions . contains key ( name ) ) { load new function ( name ) ; } return ( bool function ) bool functions . get ( name ) ; }	Retrieves a boolean function from the library.
public bt get bt ( string name ) throws no such function exception { if ( ! bt functions . contains key ( name ) ) { load new function ( name ) ; } return ( bt ) bt functions . get ( name ) ; }	Retrieves a BaseType function from the library.
protected void load new function ( string name ) { try { string full name = prefix + name ; class value = class . for name ( full name ) ; if ( ( server side function . class ) . is assignable from ( value ) ) { add ( ( server side function ) value . new instance ( ) ) ; return ; } } catch ( class not found exception e ) { } catch ( illegal access exception e ) { } catch ( instantiation exception e ) { } }	Tries to load a function with the given name.
public final string get level name ( grid record gr ) { if ( cust != null ) { string result = cust . get level name short ( gr . get level type1 ( ) ) ; if ( result != null ) return result ; } string level unit = get level unit ( gr ) ; if ( level unit != null ) { int level1 = ( int ) gr . get level1 ( ) ; int level2 = ( int ) gr . get level2 ( ) ; if ( level unit . equals ignore case ( str ) ) { return str ; } else if ( level1 == num ) { return str ; } else if ( level1 == num ) { return str ; } else if ( level1 == num ) { return str ; } else if ( level2 != num ) { return str ; } } return str ; }	gets the LevelName.
public final string get level description ( grid record gr ) { if ( cust != null ) { string result = cust . get level description ( gr . get level type1 ( ) ) ; if ( result != null ) return result ; }	gets the LevelDescription.
public final string get level unit ( grid record gr ) { if ( cust != null ) { string result = cust . get level units ( gr . get level type1 ( ) ) ; if ( result != null ) return result ; } return visad . jmet . met units . make symbol ( ( ( idas ) gr ) . get level unit name ( ) ) ; }	gets the LevelUnit.
public final int get projection type ( grid def record gds ) { string name = get projection name ( gds ) . trim ( ) ; switch ( name ) { case str : return mercator ; case str : return lambert conformal ; case str : return polar stereographic ; default : return - num ; } }	gets the ProjectionType.
public final boolean is vertical coordinate ( grid record gr ) { if ( cust != null ) { return cust . is vertical coordinate ( gr . get level type1 ( ) ) ; } int type = gr . get level type1 ( ) ; if ( ( ( idas ) gr ) . has grib info ( ) ) { if ( type == num ) { return bool ; } if ( type == num ) { return bool ; } if ( type == num ) { return bool ; } if ( ( type >= num ) && ( type <= num ) ) { return bool ; } if ( type == num ) { return bool ; } if ( type == num ) { return bool ; } } else if ( get level unit ( gr ) . equals ( str ) ) { return bool ; } return bool ; }	is this a VerticalCoordinate.
public boolean is layer ( grid record gr ) { if ( cust != null ) { return cust . is layer ( gr . get level type1 ( ) ) ; } if ( gr . get level2 ( ) == num ) { return bool ; } return bool ; }	Is this a layer?.
static public coordinate transform make coordinate transform ( netcdf dataset ds , attribute container ctv , formatter parse info , formatter err info ) {	Make a CoordinateTransform object from the parameters in a Coordinate Transform Variable, using an intrinsic or registered CoordTransBuilder.
static public ds make dummy transform variable ( netcdf dataset ds , coordinate transform ct ) { ds v = new ds ( ds , null , null , ct . get name ( ) , data type . char , str , null , null ) ; list < parameter > params = ct . get parameters ( ) ; for ( parameter p : params ) { if ( p . is string ( ) ) v . add attribute ( new attribute ( p . get name ( ) , p . get string value ( ) ) ) ; else { double [ ] data = p . get numeric values ( ) ; array data a = array . factory ( data type . double , new int [ ] { data . length } , data ) ; v . add attribute ( new attribute ( p . get name ( ) , data a ) ) ; } } v . add attribute ( new attribute ( coordinate . transform type , ct . get transform type ( ) . to string ( ) ) ) ;	Create a "dummy" Coordinate Transform Variable based on the given CoordinateTransform.This creates a scalar Variable with dummy data, and adds the Parameters of the CoordinateTransformas attributes.
static public projection impl make projection ( coverage transform gct , formatter err info ) {	Make a CoordinateTransform object from the parameters in a GridCoordTransform, using an intrinsic orregistered CoordTransBuilder.
public static void main ( string args [ ] ) { boolean use popup = bool ; for ( int i = num ; i < args . length ; i ++ ) { if ( args [ i ] . equals ( str ) ) use popup = bool ; } try { store = xml . create from file ( str , null ) ; p = store . get preferences ( ) ; } catch ( io e ) { system . out . println ( str + e ) ; }	Standalone application.
public void save ( ) { collection name table . save state ( bool ) ; data table . save state ( bool ) ; prefs . put bean object ( str , info window . get bounds ( ) ) ; prefs . put int ( str , split . get divider location ( ) ) ; }	private MetadataManager mm;.
@ override public final chronology with zone ( date time zone zone ) { if ( zone . equals ( date time zone . utc ) ) return this . with utc ( ) ; throw new unsupported operation exception ( str ) ; }	Throws UnsupportedOperationException unless the time zone is UTC.
public void write count ( long count ) throws io { countbuffer . clear ( ) ; countbuffer . put long ( count ) ; byte [ ] countbuf = countbuffer . array ( ) ; int len = countbuffer . position ( ) ; write bytes ( countbuf , len ) ; if ( debug ) { system . err . printf ( str , count ) ; } }	Write out a prefix count.
public void write atomic array ( dap type daptype , object values ) throws io { assert values != null && values . get class ( ) . is array ( ) ; byte buffer buf = serial writer . encode array ( daptype , values , this . order ) ; byte [ ] bytes = buf . array ( ) ; int len = buf . position ( ) ; write bytes ( bytes , len ) ; if ( debug ) { system . err . printf ( str , daptype . get short name ( ) ) ; for ( int i = num ; i < len ; i ++ ) { int x = ( int ) ( order == byte order . big endian ? bytes [ i ] : bytes [ ( len - num ) - i ] ) ; system . err . printf ( str , ( int ) ( x & num ) ) ; } system . err . println ( ) ; } }	Write out an array of atomic values.
public void write bytes ( byte [ ] bytes , int len ) throws io { output bytes ( bytes , num , len ) ; if ( this . checksummode . enabled ( checksum mode . dap ) ) { this . checksum . update ( bytes , num , len ) ; if ( dumpcsum ) { system . err . print ( str ) ; for ( int i = num ; i < len ; i ++ ) { system . err . printf ( str , bytes [ i ] ) ; } system . err . println ( ) ; } } }	Write out a set of bytes.
public void output bytes ( byte [ ] bytes , int start , int count ) throws io { if ( dumpdata ) { system . err . printf ( str , start , count ) ; for ( int i = num ; i < count ; i ++ ) { system . err . printf ( str , bytes [ i ] ) ; } system . err . println ( str ) ; system . err . flush ( ) ; } output . write ( bytes , start , count ) ; }	Deliberate choke point for debugging.
void finish init ( ) {	stuff to do after UI is complete.
static public calendar date range of ( date range dr ) { if ( dr == null ) return null ; return calendar date range . of ( dr . get start ( ) . get date ( ) , dr . get end ( ) . get date ( ) ) ; }	Does not handle non-standard calendars.
public static grib2 gds factory ( int template , byte [ ] data ) { grib2 gds result ; switch ( template ) { case num : result = new lat lon ( data ) ; break ; case num : result = new rotated lat lon ( data ) ; break ; case num : result = new mercator ( data ) ; break ; case num : result = new polar stereographic ( data ) ; break ; case num : result = new lambert conformal ( data , num ) ; break ; case num : result = new albers equal area ( data ) ; break ; case num : result = new gauss lat lon ( data ) ; break ; case num :	reletive error in position - GRIB numbers sometimes miscoded.
public int ddsparse ( string text , dds dds ) throws parse exception { return dapparse ( text , dds , null , null ) ; }	Call this to parse a DDS.
public int dasparse ( string text , das das ) throws parse exception { return dapparse ( text , null , das , null ) ; }	Call this to parse a DAS.
private void swap grid header ( int [ ] gh ) { idas . flip ( gh , num , num ) ; idas . flip ( gh , num , num ) ; idas . flip ( gh , num , num ) ; idas . flip ( gh , num , num ) ; idas . flip ( gh , num , num ) ; }	Swap the grid header, avoiding strings.
public float [ ] read grid ( idas gr ) throws io { float [ ] data ;	Read the grid.
public static void main ( string [ ] args ) throws io { string file = str ; if ( args . length > num ) { file = args [ num ] ; } idas mg = new idas ( file ) ; grid index grid index = mg . get grid index ( ) ; list grids = grid index . get grid records ( ) ; system . out . println ( str + grids . size ( ) + str ) ; int num = math . min ( grids . size ( ) , num ) ; for ( int i = num ; i < num ; i ++ ) { system . out . println ( grids . get ( i ) ) ; } }	for testing purposes.
private void write a ( string name , boolean is implemented ) { string def value ; if ( is implemented ) def value = str ; else def value = str ; file output += str + name + str + str + str + def value + str + str ; }	Writes a constraint OWS element out.
private void write headers and ss ( ) { file output += str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str ; write service info ( ) ; }	Writes headers and service sections.
public void write operations ( ) { file output += str ; for ( wfs rt : operation list ) { write a ( rt ) ; }	Takes all added operations and writes an operations metadata section.
public void read all ( file dir , file filter ff , closure closure , log filter logf , stats stat ) throws io { file [ ] files = dir . list files ( ) ; if ( files == null ) { system . out . printf ( str , dir ) ; return ; } list < file > list = arrays . as list ( files ) ; collections . sort ( list ) ; for ( file f : list ) { if ( ( ff != null ) && ! ff . accept ( f ) ) continue ; if ( f . is directory ( ) ) read all ( f , ff , closure , logf , stat ) ; else scan log file ( f , closure , logf , stat ) ; } }	Read all the files in a directory and process them.
public void scan log file ( file file , closure closure , log filter logf , stats stat ) throws io { try ( input stream ios = new file input stream ( file ) ) { system . out . printf ( str , file . get path ( ) ) ; buffered reader data is = new buffered reader ( new input stream reader ( ios , cdm . utf8 charset ) , num * num ) ; int total = num ; int count = num ; while ( ( max lines < num ) || ( count < max lines ) ) { log log = parser . next log ( data is ) ; if ( log == null ) break ; total ++ ; if ( ( logf != null ) && ! logf . pass ( log ) ) continue ; closure . process ( log ) ; count ++ ; } if ( stat != null ) { stat . total += total ; stat . passed += count ; } system . out . printf ( str , file . get path ( ) , total , count ) ; } }	Read a log file.
public int get grid packing type ( int grid number ) throws io {	Get the grid packing type.
public gempak grid record find grid ( string parm ) { list < grid record > grid list = grid index . get grid records ( ) ; if ( grid list == null ) { return null ; } for ( grid record grid : grid list ) { gempak grid record gh = ( gempak grid record ) grid ; if ( gh . param . trim ( ) . equals ( parm ) ) { return gh ; } } return null ; }	Find the first grid with this name.
public float [ ] dm rpkg ( int isword , int nword , int decimal scale ) throws io {	Unpack a packed grid.
private synchronized float [ ] unpack data ( int iiword , int nword , int ipktyp , int kxky , int nbits , float ref , float scale , boolean miss , float difmin , int kx , int decimal scale ) throws io { if ( ipktyp == mdggrb ) { if ( ! use dp ) { return unpack grib1 data ( iiword , nword , kxky , nbits , ref , scale , miss , decimal scale ) ; } else { if ( nword * num < kxky * nbits ) {	Read packed data.
private synchronized float [ ] dp ugrb ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimal scale ) throws io { float scale factor = ( decimal scale == num ) ? num : ( float ) math . pow ( num , - decimal scale ) ;	Unpack grib data packed into ints.
private float [ ] unpack grib1 data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimal scale ) throws io {	Read packed Grib1 data using ucar.grib code.
private float [ ] unpack grib2 data ( int iiword , int lendat , int [ ] iarray , float [ ] rarray ) throws io { long start = get offset ( iiword ) ; rf . seek ( start ) ; grib2 record gr = make grib record ( rf , start ) ; float [ ] data = gr . read data ( rf ) ; if ( ( ( iarray [ num ] > > num ) & num ) == num ) {	Read packed Grib2 data.
public void print grids ( ) { list < grid record > grid list = grid index . get grid records ( ) ; if ( grid list == null ) return ; system . out . println ( str ) ; for ( grid record a grid list : grid list ) { system . out . println ( a grid list ) ; } }	Print out the grids.
private void get next byte ( ) throws io { if ( ! need to swap ) {	Get the next byte.
public static calendar date of ( calendar cal , int year , int month of year , int day of month , int hour of day , int minute of hour , int second of minute ) { chronology base = calendar . get chronology ( cal ) ; date time dt = new date time ( year , month of year , day of month , hour of day , minute of hour , second of minute , base ) ; if ( ! calendar . is default chronology ( cal ) ) dt = dt . with chronology ( calendar . get chronology ( cal ) ) ; dt = dt . with zone ( date time zone . utc ) ; return new calendar date ( cal , dt ) ; }	Get Calendar date from fields. Uses UTZ time zone.
public static calendar date of ( java . util . date date ) { date time dt = new date time ( date , date time zone . utc ) ; return new calendar date ( null , dt ) ; }	Create CalendarDate from a java.util.Date.Uses standard Calendar.
public static calendar date of ( long msecs ) {	Create CalendarDate from msecs since epochUses standard Calendar.
public static calendar date of ( calendar cal , long msecs ) { chronology base = calendar . get chronology ( cal ) ; date time dt = new date time ( msecs , base ) ; return new calendar date ( cal , dt ) ; }	Create CalendarDate from msecs since epochUses the given Calendar.
public static calendar date parse udunits ( string calendar name , string udunits ) { int pos = udunits . index of ( str ) ; if ( pos < num ) return null ; string val string = udunits . substring ( num , pos ) . trim ( ) ; string unit string = udunits . substring ( pos + num ) . trim ( ) ; calendar date unit cdu = calendar date unit . of ( calendar name , unit string ) ; double val = double . parse double ( val string ) ; return cdu . make calendar date ( val ) ; }	Get CalendarDate from udunit date string.
public long get difference ( calendar date o , calendar period . field fld ) { switch ( fld ) { case millisec : return get difference in msecs ( o ) ; case second : return ( long ) ( get difference in msecs ( o ) / millisecs in second ) ; case minute : return ( long ) ( get difference in msecs ( o ) / millisecs in minute ) ; case hour : return ( long ) ( get difference in msecs ( o ) / millisecs in hour ) ; case day : return ( long ) ( get difference in msecs ( o ) / millisecs in day ) ; case month : int tmonth = get field value ( calendar period . field . month ) ; int omonth = o . get field value ( calendar period . field . month ) ; int years = ( int ) this . get difference ( o , calendar period . field . year ) ; return tmonth - omonth + num * years ; case year : int tyear = get field value ( calendar period . field . year ) ; int oyear = o . get field value ( calendar period . field . year ) ; return tyear - oyear ; } return date time . get millis ( ) - o . date time . get millis ( ) ; }	Get difference between two calendar dates in given Field units.
protected cdm create atomic var ( data cursor data ) throws dap exception { cdm array = new cdm ( data ) ; return array ; }	Create an Atomic Valued variable.
public void setup ( http servlet request req , http servlet response resp ) throws send error { this . req = req ; this . res = resp ; if ( ! once ) doonce ( req ) ;	Setup for each request.
static protected string escape string ( string s ) { string builder buf = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { int c = s . char at ( i ) ; switch ( c ) { case str : buf . append ( str ) ; break ; case str : buf . append ( str ) ; break ; case str : buf . append ( str ) ; break ; case str : buf . append ( str ) ; break ; case str : buf . append ( str ) ; break ; case str : buf . append ( str ) ; break ; default : if ( c < str ) buf . append ( string . format ( str , ( c & num ) ) ) ; else buf . append ( ( char ) c ) ; break ; } } return buf . to string ( ) ; }	Given a typical string, insert backslashesbefore '"' and '\\' characters and control characters.
static public list < slice > create slices ( list < range > rangelist ) throws dap4 . core . util . dap exception { list < slice > slices = new array list < slice > ( rangelist . size ( ) ) ; for ( int i = num ; i < rangelist . size ( ) ; i ++ ) { range r = rangelist . get ( i ) ;	Convert a list of ucar.ma2.Range to a list of SliceMore or less the inverst of create CDMRanges.
static public netcdf file unwrapfile ( netcdf file file ) { for ( ; ; ) { if ( file instanceof netcdf dataset ) { netcdf dataset ds = ( netcdf dataset ) file ; file = ds . get referenced file ( ) ; if ( file == null ) break ; } else break ; } return file ; }	NetcdfDataset can wrap a NetcdfFile.Goal of this procedure is to get down to thelowest level NetcdfFile instance.
static public boolean contains vlen ( list < dimension > dimset ) { if ( dimset == null ) return bool ; for ( dimension dim : dimset ) { if ( dim . is variable length ( ) ) return bool ; } return bool ; }	Test if any dimension is variable length.
static public int [ ] compute effective shape ( list < dap dimension > dimset ) { if ( dimset == null || dimset . size ( ) == num ) return new int [ num ] ; int effectiverank = dimset . size ( ) ; int [ ] shape = new int [ effectiverank ] ; for ( int i = num ; i < effectiverank ; i ++ ) { shape [ i ] = ( int ) dimset . get ( i ) . get size ( ) ; } return shape ; }	Compute the shape inferred from a set of slices.'Effective' means that any trailing vlen will beignored.
public date add ( date d ) { calendar cal = calendar . get instance ( ) ; cal . set time ( d ) ; cal . add ( calendar . second , ( int ) get value in seconds ( ) ) ; return cal . get time ( ) ; }	Add the time amount to the given Date, return a new Date.
@ override protected unit my multiply by ( final unit that ) throws multiply exception { return that instanceof scaled unit ? new scaled unit ( get scale ( ) * ( ( scaled unit ) that ) . get scale ( ) , get unit ( ) . multiply by ( ( ( scaled unit ) that ) . get unit ( ) ) ) : new scaled unit ( get scale ( ) , get unit ( ) . multiply by ( that ) ) ; }	Multiplies this unit by another unit.
@ override protected unit my divide by ( final unit that ) throws operation exception { return that instanceof scaled unit ? new scaled unit ( get scale ( ) / ( ( scaled unit ) that ) . get scale ( ) , get unit ( ) . divide by ( ( ( scaled unit ) that ) . get unit ( ) ) ) : new scaled unit ( get scale ( ) , get unit ( ) . divide by ( that ) ) ; }	Divides this unit by another unit.
@ override protected unit my divide into ( final unit that ) throws operation exception { return that instanceof scaled unit ? new scaled unit ( ( ( scaled unit ) that ) . get scale ( ) / get scale ( ) , get unit ( ) . divide into ( ( ( scaled unit ) that ) . get unit ( ) ) ) : new scaled unit ( num / get scale ( ) , get unit ( ) . divide into ( that ) ) ; }	Divides this unit into another unit.
@ override protected unit my raise to ( final int power ) throws raise exception { return new scaled unit ( math . pow ( get scale ( ) , power ) , get unit ( ) . raise to ( power ) ) ; }	Raises this unit to a power.
public double to derived unit ( final double amount ) throws conversion exception { if ( ! ( unit instanceof derivable unit ) ) { throw new conversion exception ( this , get derived unit ( ) ) ; } return ( ( derivable unit ) unit ) . to derived unit ( amount * get scale ( ) ) ; }	Converts a numeric value from this unit to the underlying derived unit.
public float [ ] to derived unit ( final float [ ] input , final float [ ] output ) throws conversion exception { final float scale = ( float ) get scale ( ) ; for ( int i = input . length ; -- i >= num ; ) { output [ i ] = input [ i ] * scale ; } if ( ! ( unit instanceof derivable unit ) ) { throw new conversion exception ( this , get derived unit ( ) ) ; } return ( ( derivable unit ) get unit ( ) ) . to derived unit ( output , output ) ; }	Converts numeric values from this unit to the underlying derived unit.
public double from derived unit ( final double amount ) throws conversion exception { if ( ! ( unit instanceof derivable unit ) ) { throw new conversion exception ( get derived unit ( ) , this ) ; } return ( ( derivable unit ) get unit ( ) ) . from derived unit ( amount ) / get scale ( ) ; }	Converts a numeric value from the underlying derived unit to this unit.
public string get canonical string ( ) { return derived unit impl . dimensionless . equals ( unit ) ? double . to string ( get scale ( ) ) : double . to string ( get scale ( ) ) + str + unit . to string ( ) ; }	Returns the canonical string representation of the unit.
public array read data ( section iterable want ) throws io , invalid range exception { if ( vindex instanceof partition collection immutable . variable index partitioned ) return read data from partition ( ( partition collection immutable . variable index partitioned ) vindex , want ) ; else return read data from collection ( vindex , want ) ; }	Read the section of data described by want.
public array read data2 ( coords set want , range iterator y range , range iterator x range ) throws io { if ( vindex instanceof partition collection immutable . variable index partitioned ) return read data from partition2 ( ( partition collection immutable . variable index partitioned ) vindex , want , y range , x range ) ; else return read data from collection2 ( vindex , want , y range , x range ) ; }	Coordinate based subsetting for Coverage.
@ override public point feature collection flatten ( list < string > station names , calendar date range date range , list < if > var list ) throws io { if ( ( station names == null ) || ( station names . size ( ) == num ) ) return new station time series collection flattened ( this , date range ) ; list < station feature > subset stations = get station helper ( ) . get station features from names ( station names ) ; return new station time series collection flattened ( new station subset ( this , subset stations ) , date range ) ; }	might need to override for efficiency.
public inv service find service ( string name ) { if ( name == null ) return null ; for ( inv service s : services ) { if ( name . equals ( s . get name ( ) ) ) return s ;	Find the named service declared in the top level of this catalog.
public int get gate size ( int datatype ) { switch ( datatype ) { case reflectivity : return ( ( int ) reflect gate size ) ; case velocity hi : case velocity low : case spectrum width : return ( ( int ) doppler gate size ) ;	This method returns the gate size in meters.
public int get gate start ( int datatype ) { switch ( datatype ) { case reflectivity : return ( ( int ) reflect first gate ) ; case velocity hi : case velocity low : case spectrum width : return ( ( int ) doppler first gate ) ;	This method returns the starting gate in meters.
public int get gate count ( int datatype ) { switch ( datatype ) { case reflectivity : return ( ( int ) reflect gate count ) ; case velocity hi : case velocity low : case spectrum width : return ( ( int ) doppler gate count ) ;	This method returns the number of gates.
public void write xml ( netcdf dataset ncd , output stream os , boolean show coords , string uri ) throws io {	Write a NetcdfDataset as an NcML-G document to the specified stream.
public dimension preferred layout size ( container target ) { synchronized ( target . get tree lock ( ) ) { dimension dim = new dimension ( num , num ) ; for ( int i = num ; i < target . get component count ( ) ; i ++ ) { component m = target . get component ( i ) ; if ( m . is visible ( ) ) { dimension d = m . get preferred size ( ) ;	deal with having components on more than one line.
static crawlable dataset verify descendant dataset ( crawlable dataset ancestor cr ds , string path , crawlable dataset filter filter ) {	Return the requested dataset if it is the ancestor dataset or an alloweddescendant of the ancestor dataset, otherwise return null.
public inv catalog impl generate proxy ds resolver catalog ( crawlable dataset catalog cr ds , proxy dataset handler pdh ) throws io { throw new java . lang . unsupported operation exception ( str ) ; }	Not supported by SimpleCatalogBuilder.
static public calendar date unit of ( string calendar name , string udunit string ) { calendar calt = calendar . get ( calendar name ) ; if ( calt == null ) calt = calendar . get default ( ) ; return new calendar date unit ( calt , udunit string ) ; }	Create a CalendarDateUnit from a calendar name and a udunit string = "unit since calendarDate".
static public calendar date unit with calendar ( calendar calt , string udunit string ) { if ( calt == null ) calt = calendar . get default ( ) ; return new calendar date unit ( calt , udunit string ) ; }	Create a CalendarDateUnit from a calendar and a udunit string = "unit since calendarDate".
static public calendar date unit of ( calendar calt , calendar period . field period field , calendar date base date ) { if ( calt == null ) calt = calendar . get default ( ) ; return new calendar date unit ( calt , period field , base date ) ; }	Create a CalendarDateUnit from a calendar, a CalendarPeriod.Field, and a base date.
public quantity dimension get quantity dimension ( ) { factor [ ] factors = get factors ( ) ; for ( int i = factors . length ; -- i >= num ; ) { factor factor = factors [ i ] ; factors [ i ] = new factor ( ( ( base unit ) factor . get base ( ) ) . get base quantity ( ) , factor . get exponent ( ) ) ; } return new quantity dimension ( factors ) ; }	Returns the corresponding quantity dimension.
public boolean is valid file ( ucar . unidata . io . random access file raf ) { try { raf . order ( random access file . little endian ) ;	Check if this is a valid SIGMET-IRIS file for this IOServiceProvider.
public array read data1 ( ucar . nc2 . variable v2 , section section ) throws io , invalid range exception {	Read data from a top level Variable and return a memory resident Array.
public array read int data ( layout regular index , variable v2 ) throws io { int [ ] var = ( int [ ] ) ( v2 . read ( ) . get1 d ( v2 . get data type ( ) ) ) ; int [ ] data = new int [ ( int ) index . get total nelems ( ) ] ; while ( index . has next ( ) ) { layout . chunk chunk = index . next ( ) ; system . arraycopy ( var , ( int ) chunk . get src pos ( ) / num , data , ( int ) chunk . get dest elem ( ) , chunk . get nelems ( ) ) ; } return array . factory ( v2 . get data type ( ) , new int [ ] { ( int ) index . get total nelems ( ) } , data ) ; }	Read data from a top level Variable of INTEGER data type and return a memory resident Array.
public long read to byte channel11 ( ucar . nc2 . variable v2 , section section , writable byte channel channel ) throws java . io . io , ucar . ma2 . invalid range exception { array data = read data ( v2 , section ) ; float [ ] ftdata = new float [ ( int ) data . get size ( ) ] ; byte [ ] bytedata = new byte [ ( int ) data . get size ( ) * num ] ; index iterator iter = data . get index iterator ( ) ; int i = num ; byte buffer buffer = byte buffer . allocate direct ( bytedata . length ) ; while ( iter . has next ( ) ) { ftdata [ i ] = iter . get float next ( ) ; bytedata [ i ] = new float ( ftdata [ i ] ) . byte value ( ) ; buffer . put ( bytedata [ i ] ) ; i ++ ; } buffer = byte buffer . wrap ( bytedata ) ;	Read data from a top level Variable and send data to a WritableByteChannel.
static float calc elev ( short angle ) { final double maxval = num ; double ang = ( double ) angle ; if ( angle < num ) ang = ( ~ angle ) + num ; double temp = ( ang / maxval ) * num ; big decimal bd = new big decimal ( temp ) ; big decimal result = bd . set scale ( num , rounding mode . half down ) ; return result . float value ( ) ; }	Calculate radial elevation of each ray.
static float calc step ( float range first , float range last , short num bins ) { float step = ( range last - range first ) / ( num bins - num ) ; big decimal bd = new big decimal ( step ) ; big decimal result = bd . set scale ( num , rounding mode . half down ) ; return result . float value ( ) ; }	Calculate distance between sequential bins in a ray.
static float calc az ( short az0 , short az1 ) {	Calculate azimuth of a ray.
static float calc data ( map < string , number > rec hdr , short dty , byte data ) { short [ ] coef = { num , num , num , num } ;	Calculate data values from raw ingest data.
static float calc nyquist ( int prf , int wave ) { double tmp = ( prf * wave * num ) * num ; tmp = tmp * num ;	Calculate of Nyquist velocity.
public vertical transform make vertical transform ( netcdf dataset ds , dimension time dim ) { return builder . make math transform ( ds , time dim , this ) ; }	Use the builder to make the Vertical Transform function.
static public void set debug flags ( ucar . nc2 . util . debug flags debug flag ) { debug open = debug flag . is set ( str ) ; debug missing = debug flag . is set ( str ) ; debug missing details = debug flag . is set ( str ) ; debug proj = debug flag . is set ( str ) ; debug vert = debug flag . is set ( str ) ; debug timing = debug flag . is set ( str ) ; }	Set the debug flags.
static public void set extend index ( boolean b ) { index file mode on open = b ? index extend mode . extendwrite : index extend mode . readonly ; index file mode on sync = b ? index extend mode . extendwrite : index extend mode . readonly ; }	Set how indexes are used for both open and sync.
private void read xy ( variable v2 , int ens idx , int time idx , int lev idx , range y range , range x range , index iterator ii ) throws io , invalid range exception { grid variable pv = ( grid variable ) v2 . get s ( ) ; grid horiz coord sys hsys = pv . get horiz coord sys ( ) ; int nx = hsys . get nx ( ) ; grid record record = pv . find record ( ens idx , time idx , lev idx ) ; if ( record == null ) { attribute att = v2 . find attribute ( str ) ; float missing value = ( att == null ) ? - num : att . get numeric value ( ) . float value ( ) ; int xy count = y range . length ( ) * x range . length ( ) ; for ( int j = num ; j < xy count ; j ++ ) { ii . set float next ( missing value ) ; } return ; }	read one YX array.
public boolean is missing xy ( variable v2 , int time idx , int ens idx , int lev idx ) throws invalid range exception { grid variable pv = ( grid variable ) v2 . get s ( ) ; if ( ( time idx < num ) || ( time idx >= pv . get n ( ) ) ) { throw new invalid range exception ( str + time idx ) ; } if ( ( lev idx < num ) || ( lev idx >= pv . get vert nlevels ( ) ) ) { throw new invalid range exception ( str + lev idx ) ; } if ( ( ens idx < num ) || ( ens idx >= pv . get n ( ) ) ) { throw new invalid range exception ( str + ens idx ) ; } return ( null == pv . find record ( ens idx , time idx , lev idx ) ) ; }	Is this XY level missing?.
public lat lon rect get lat lon bounding box ( ) { if ( llbb == null ) { if ( ( get x ( ) instanceof d ) && ( get y ( ) instanceof d ) ) { return null ; } coordinate axis horiz xaxis = get x ( ) ; coordinate axis horiz yaxis = get y ( ) ; if ( is lat lon ( ) ) { double start lat = horiz yaxis . get min value ( ) ; double start lon = horiz xaxis . get min value ( ) ; double delta lat = horiz yaxis . get max value ( ) - start lat ; double delta lon = horiz xaxis . get max value ( ) - start lon ; lat lon point llpt = new lat lon point impl ( start lat , start lon ) ; llbb = new lat lon rect ( llpt , delta lat , delta lon ) ; } else { projection impl data projection = get projection ( ) ; projection rect bb = get bounding box ( ) ; if ( bb != null ) llbb = data projection . proj to lat lon bb ( bb ) ; } } return llbb ; }	Get horizontal bounding box in lat, lon coordinates.
public void finish ( ) { sequence offset = new int [ nelems ] ; total = num ; for ( int i = num ; i < nelems ; i ++ ) { sequence offset [ i ] = total ; total += sequence len [ i ] ; } sdata = new structure data [ nelems ] ; for ( int i = num ; i < nelems ; i ++ ) sdata [ i ] = new a ( this , sequence offset [ i ] ) ;	Call this when you have set all the sequence lengths.
public static void tab ( string buffer sbuff , int tab stop , boolean always one ) { int len = sbuff . length ( ) ; if ( tab stop > len ) { sbuff . set length ( tab stop ) ; for ( int i = len ; i < tab stop ; i ++ ) { sbuff . set char at ( i , str ) ; } } else if ( always one ) { sbuff . set length ( len + num ) ; sbuff . set char at ( len , str ) ; } }	Blank fill sbuff with blanks, until position tabStop.
public static string pad ( string s , int width , boolean right justify ) { if ( s . length ( ) >= width ) { return s ; } string builder sbuff = new string builder ( width ) ; int need = width - s . length ( ) ; sbuff . set length ( need ) ; for ( int i = num ; i < need ; i ++ ) { sbuff . set char at ( i , str ) ; } if ( right justify ) { sbuff . append ( s ) ; } else { sbuff . insert ( num , s ) ; } return sbuff . to string ( ) ; }	Create a new string by padding the existing one with blanks to specified width.Do nothing if length is already greater or equal to width.
public static string i ( int v , int width ) { return pad ( integer . to string ( v ) , width , bool ) ; }	Format an integer value.
public static string l ( long v , int width ) { return pad ( long . to string ( v ) , width , bool ) ; }	Format a long value.
public static string format byte size ( double size ) { string unit = null ; if ( size > num ) { unit = str ; size *= num ; } else if ( size > num ) { unit = str ; size *= num ; } else if ( size > num ) { unit = str ; size *= num ; } else if ( size > num ) { unit = str ; size *= num ; } else if ( size > num ) { unit = str ; size *= num ; } else { unit = str ; } return format . d ( size , num ) + str + unit ; }	Nicely formatted representation of bytes, eg turn 5.636E7 into.
private static void show ( double d , int sigfig ) { system . out . println ( str + d + str + sigfig + str + format . d ( d , sigfig ) ) ; }	Show the value of a double to the significant figures.
private static void show2 ( double d , int dec places ) { system . out . println ( str + d + str + dec places + str + format . dfrac ( d , dec places ) ) ; }	Show the value of a double with specified number of decimal places.
private string get shape string ( int [ ] shape ) { string builder buf = new string builder ( ) ; for ( int i = num ; i < shape . length ; i ++ ) { if ( i != num ) buf . append ( str ) ; buf . append ( shape [ i ] ) ; } return buf . to string ( ) ; }	display name plus the dimensions.
public slice finish ( ) throws dap exception {	Perform sanity checks on a slice and repair where possible.
public string to constraint string ( ) throws dap exception { assert this . first != undefined && this . stride != undefined && this . stop != undefined ; if ( ( this . stop - this . first ) == num ) { return string . format ( str ) ; } else if ( this . stride == num ) { if ( ( this . stop - this . first ) == num ) return string . format ( str , this . first ) ; else return string . format ( str , this . first , this . stop - num ) ; } else return string . format ( str , this . first , this . stride , this . stop - num ) ; }	Convert this slice to a stringsuitable for use in a constraint.
static public slice compose ( slice target , slice src ) throws dap exception { long sr stride = target . get stride ( ) * src . get stride ( ) ; long sr first = map ( target , src . get first ( ) ) ; long lastx = map ( target , src . get last ( ) ) ; long sr last = ( target . get last ( ) < lastx ? target . get last ( ) : lastx ) ;	Take two slices and compose src wrt targetAssume neither argument is null.
static long map ( slice target , long i ) throws dap exception { if ( i < num ) throw new dap exception ( str ) ; if ( i > target . get stop ( ) ) throw new dap exception ( str ) ; return target . get first ( ) + i * target . get stride ( ) ; }	Map ith element of one range wrt a target range.
static public void dumpbytes ( byte buffer buf0 , boolean skipdmr ) { int savepos = buf0 . position ( ) ; int limit0 = buf0 . limit ( ) ; int skipcount = num ; if ( limit0 > maxlimit ) limit0 = maxlimit ; if ( limit0 >= buf0 . limit ( ) ) limit0 = buf0 . limit ( ) ; if ( skipdmr ) { byte order saveorder = buf0 . order ( ) ; buf0 . order ( byte order . big endian ) ;	Provide a simple dump of binary data.
public static earth ellipsoid get type ( string name ) { if ( name == null ) return null ; return hash . get ( name ) ; }	Find the EarthEllipsoid that matches this name.
public static earth ellipsoid get type ( int epsg id ) { collection < earth ellipsoid > all = get all ( ) ; for ( earth ellipsoid ellipsoid : all ) { if ( ellipsoid . epsg id == epsg id ) { return ellipsoid ; } } return null ; }	Find the EarthEllipsoid that matches this EPSG Id.
private array decode vlen data ( nc stream proto . data col dproto , section parent section ) throws io { data type data type = nc stream . convert data type ( dproto . get data type ( ) ) ; byte buffer bb = dproto . get primdata ( ) . as read only byte buffer ( ) ; byte order bo = dproto . get bigend ( ) ? byte order . big endian : byte order . little endian ; bb . order ( bo ) ; array alldata = array . factory ( data type , new int [ ] { dproto . get nelems ( ) } , bb ) ;	vlen inside a Structure.
public array list extract ( string url ) throws io { if ( debug ) system . out . println ( str + url ) ; base url = new url ( url ) ; input stream in = base url . open stream ( ) ; input stream reader r = new input stream reader ( filter tag ( in ) , cdm . ut ) ; html . parser callback callback = new caller backer ( ) ; url list = new array list ( ) ; want urls = bool ; want text = bool ; parser . parse ( r , callback , bool ) ; return url list ; }	Extract all A-HREF contained URLS from the given URL and return in List.
public string get text content ( string url ) throws io { if ( debug ) system . out . println ( str + url ) ; base url = new url ( url ) ; input stream in = base url . open stream ( ) ; input stream reader r = new input stream reader ( filter tag ( in ) , cdm . ut ) ; html . parser callback callback = new caller backer ( ) ; text buffer = new string buffer ( num ) ; want urls = bool ; want text = bool ; parser . parse ( r , callback , bool ) ; return text buffer . to string ( ) ; }	Extract text content from the given URL and return in String.
private input stream filter tag ( input stream in ) throws io { buffered reader buff in = new buffered reader ( new input stream reader ( in , cdm . ut ) ) ; byte array output stream bos = new byte array output stream ( num ) ; string line = buff in . read line ( ) ; while ( line != null ) { string lline = line . to lower case ( ) ; if ( lline . contains ( str ) )	workaround for HTMLEditorKit.Parser, cant deal with "content-encoding".
@ override public long read to byte channel ( ucar . nc2 . variable v2 , section section , writable byte channel channel ) throws java . io . io , ucar . ma2 . invalid range exception { array data = read data ( v2 , section ) ; return iosp helper . copy to byte channel ( data , channel ) ; }	LOOK DataOutputStream uses big-endian.
@ override public void add all ( iterable < attribute > atts ) { for ( attribute att : atts ) add attribute ( att ) ; }	Add all; replace old if has same name.
@ override public boolean remove attribute ( string att name ) { attribute att = find attribute ( att name ) ; return att != null && atts . remove ( att ) ; }	Remove an Attribute by name.
@ override public boolean remove attribute ignore case ( string att name ) { attribute att = find attribute ignore case ( att name ) ; return att != null && atts . remove ( att ) ; }	Remove an Attribute by name, ignoring case.
public list < double > get offsets in time units ( ) { double start = first date . get millis ( ) ; list < double > result = new array list < > ( runtimes . length ) ; for ( int idx = num ; idx < runtimes . length ; idx ++ ) { double runtime = ( double ) get runtime ( idx ) ; double msecs = ( runtime - start ) ; result . add ( msecs / time unit . get value in millisecs ( ) ) ; } return result ; }	Get offsets from firstDate, in units of timeUnit.
public void add action source listener ( action source listener l ) { if ( ! event type . equals ( l . get event type name ( ) ) ) throw new illegal argument exception ( str + event type + str + l . get event type name ( ) ) ; lm . add listener ( l ) ; l . add action value listener ( this ) ; }	add an ActionSource listener.
static public date get standard date ( string text ) { double value ; string udunit string ; text = text . trim ( ) ; string tokenizer stoker = new string tokenizer ( text ) ; string first toke = stoker . next token ( ) ; try { value = double . parse double ( first toke ) ; udunit string = text . substring ( first toke . length ( ) ) ; } catch ( number format exception e ) {	Create a java.util.Date from this udunits String.
static public date get standard or iso ( string text ) { date result = get standard date ( text ) ; if ( result == null ) { date formatter formatter = new date formatter ( ) ; result = formatter . get iso ( text ) ; } return result ; }	Create a java.util.Date from a udunit or ISO String.
public date get date origin ( ) { if ( ! ( uu instanceof time scale unit ) ) return null ; time scale unit tu = ( time scale unit ) uu ; return tu . get origin ( ) ; }	Get the origin Date.
public date get date ( ) { double secs = time unit . get value in seconds ( value ) ; return new date ( get date origin ( ) . get time ( ) + ( long ) ( num * secs ) ) ; }	Get the equivalent java.util.Date.
public date make date ( double val ) { if ( double . is na n ( val ) ) return null ; double secs = time unit . get value in seconds ( val ) ;	Create a Date from this base unit and the given value.
public double make value ( date date ) { double secs = date . get time ( ) / num ; double origin secs = get date origin ( ) . get time ( ) / num ; double diff = secs - origin secs ; try { time unit . set value in seconds ( diff ) ; } catch ( exception e ) { throw new runtime exception ( e . get message ( ) ) ; } return time unit . get value ( ) ; }	Create the equivalent value from this base unit and the given Date.Inverse of makeDate.
public string make standard date string ( double value ) { date date = make date ( value ) ; if ( date == null ) return null ; date formatter formatter = new date formatter ( ) ; return formatter . to date time string iso ( date ) ; }	Make a standard GMT string representation from this unit and given value.
private double get grid spacing in km ( string type ) { double value = gds . get double ( type ) ; if ( double . is na n ( value ) ) return value ; string grid unit = gds . get param ( grid def record . grid units ) ; simple unit unit ; if ( grid unit == null || grid unit . length ( ) == num ) { unit = simple unit . meter unit ; } else { unit = simple unit . factory ( grid unit ) ; } if ( unit != null && simple unit . is compatible ( unit . get unit string ( ) , str ) ) { value = unit . convert to ( value , simple unit . km unit ) ; } return value ; }	Get the grid spacing in kilometers.
void add dimensions to netcdf file ( netcdf file ncfile ) { if ( is lat lon ) { ncfile . add dimension ( g , new dimension ( str , gds . get int ( grid def record . ny ) , bool ) ) ; ncfile . add dimension ( g , new dimension ( str , gds . get int ( grid def record . nx ) , bool ) ) ; } else { ncfile . add dimension ( g , new dimension ( str , gds . get int ( grid def record . ny ) , bool ) ) ; ncfile . add dimension ( g , new dimension ( str , gds . get int ( grid def record . nx ) , bool ) ) ; } }	Add the dimensions associated with this coord sys to the netCDF file.
private double [ ] add coord axis ( netcdf file ncfile , string name , int n , double start , double incr , string units , string desc , string standard name , axis type axis ) {	Add a coordinate axis.
private boolean make projection ( netcdf file ncfile , int proj type ) { switch ( proj type ) { case grid table lookup . rotated lat lon : make rotated lat lon ( ncfile ) ; break ; case grid table lookup . polar stereographic : make ps ( ) ; break ; case grid table lookup . lambert conformal : make lc ( ) ; break ; case grid table lookup . mercator : make mercator ( ) ; break ; case grid table lookup . orthographic :	Make a projection and add it to the netCDF file.
private void add gd ( variable v ) {	Add the GDS params to the variable as attributes.
private void add coord system variable ( netcdf file ncfile , string name , string dims ) { variable v = new variable ( ncfile , g , null , name ) ; v . set data type ( data type . char ) ; v . set dimensions ( str ) ;	Add coordinate system variable.
private void make lc ( ) {	Make a LambertConformalConic projection.
private void make ps ( ) { string nproj = gds . get param ( grid def record . npproj ) ; double lat origin = ( nproj == null || nproj . equals ignore case ( str ) ) ? num : - num ;	Make a PolarStereographic projection.
private void make mercator ( ) { double latin = gds . get double ( grid def record . lad ) ;	Make a Mercator projection.
private void set dx dy ( double startx , double starty , projection impl proj ) { double lo2 = gds . get double ( grid def record . l ) ; double la2 = gds . get double ( grid def record . l ) ; if ( double . is na n ( lo2 ) || double . is na n ( la2 ) ) { return ; } lat lon point impl end ll = new lat lon point impl ( la2 , lo2 ) ; projection point impl end = ( projection point impl ) proj . lat lon to proj ( end ll ) ; double dx = math . abs ( end . get x ( ) - startx ) / ( gds . get int ( grid def record . nx ) - num ) ; double dy = math . abs ( end . get y ( ) - starty ) / ( gds . get int ( grid def record . ny ) - num ) ; gds . add param ( grid def record . dx , string . value of ( dx ) ) ; gds . add param ( grid def record . dy , string . value of ( dy ) ) ; gds . add param ( grid def record . grid units , str ) ; }	Calculate the dx and dy from startx, starty and projection.
protected inv dataset impl read dataset ( inv catalog impl catalog , inv dataset impl parent , element ds elem , uri base ) {	read a dataset element.
public object read metadata content from url ( inv dataset dataset , java . net . uri uri ) throws java . io . io { element elem = read content from url ( uri ) ; object content object = read metadata content ( dataset , elem ) ; if ( debug metadata read ) system . out . println ( str + content object . get class ( ) . get name ( ) ) ; return content object ; }	this is only called for ThredddsMetadata.
public int get level type1 ( ) {	Get the type for the first level of this GridRecord.
public boolean is valid file ( random access file raf ) throws io { raf . seek ( num ) ; string test = raf . read string ( magic . length ( ) ) ; return test . equals ( magic ) ; }	Check if this is a valid file for this IOServiceProvider.You must make this method thread safe, ie dont keep any state.
public void write ( byte [ ] b , int off , int len ) throws io { count += len ; super . write ( b , off , len ) ; }	Writes an array of bytes to the compressed output stream.
@ override public void set clear name ( string clearname ) { super . set clear name ( clearname ) ; if ( attr != null ) attr . set clear name ( clearname ) ; if ( attr tbl != null ) attr tbl . set clear name ( clearname ) ; }	Sets the unencoded name of the class instance.
static public string get coordinate name ( netcdf dataset ds , axis type a ) { list < variable > var list = ds . get variables ( ) ; for ( variable v : var list ) { if ( v instanceof structure ) { list < variable > vars = ( ( structure ) v ) . get variables ( ) ; for ( variable vs : vars ) { string axis type = ds . find att value ignore case ( vs , coordinate . axis type , null ) ; if ( ( axis type != null ) && axis type . equals ( a . to string ( ) ) ) return vs . get short name ( ) ; } } else { string axis type = ds . find att value ignore case ( v , coordinate . axis type , null ) ; if ( ( axis type != null ) && axis type . equals ( a . to string ( ) ) ) return v . get short name ( ) ; } } if ( a == axis type . lat ) return find variable name ( ds , str ) ; if ( a == axis type . lon ) return find variable name ( ds , str ) ; if ( a == axis type . time ) return find variable name ( ds , str ) ; if ( a == axis type . height ) { variable v = find variable ( ds , str ) ; if ( null == v ) v = find variable ( ds , str ) ; if ( v != null ) return v . get short name ( ) ; }	Tries to find the coordinate variable of the specified type.
static public string get coordinate name ( netcdf dataset ds , axis type a , dimension dim ) { string name = get coordinate name ( ds , a ) ; if ( name == null ) return null ; variable v = ds . find variable ( name ) ; if ( v == null ) return null ; if ( v . is scalar ( ) ) return null ; if ( ! v . get dimension ( num ) . equals ( dim ) ) return null ; return name ; }	Tries to find the coordinate variable of the specified type, which has the specified dimension as its firsst dimension.
public string build xml ( ) { string builder response = new string builder ( ) ; response . append ( str ) ; if ( code > num ) response . append ( string . format ( str , code ) ) ; response . append ( str ) ; if ( message != null ) response . append ( str + get message ( ) + str ) ; if ( context != null ) response . append ( str + get context ( ) + str ) ; if ( otherinfo != null ) response . append ( str + get other info ( ) + str ) ; return response . to string ( ) ; }	Convert an ErrorResponse to the equivalent XML.
public dap exception build exception ( ) { string xml = build xml ( ) ; dap exception dapex = new dap exception ( xml ) . set code ( code ) ; return dapex ; }	Convert an ErrorResponse to the equivalent DapException.
private list < dimension > breakup levels ( netcdf dataset ds , variable level var ) throws io { if ( debug breakup ) parse info . format ( str , level var . get short name ( ) ) ; list < dimension > dim list = new array list < > ( ) ; array char level var data ; try { level var data = ( array char ) level var . read ( ) ; } catch ( io ioe ) { return dim list ; } list < string > values = null ; string current units = null ; array char . string iterator iter = level var data . get string iterator ( ) ; while ( iter . has next ( ) ) { string s = iter . next ( ) ; if ( debug breakup ) parse info . format ( str , s ) ; string tokenizer stoke = new string tokenizer ( s ) ; if ( ! stoke . has more tokens ( ) ) continue ;	return the list of Dimensions that were created.
private dimension make z ( netcdf dataset ds , list < string > values , string units ) throws io { int len = values . size ( ) ; string name = make z ( units ) ; if ( len > num ) name = name + integer . to string ( len ) ; else name = name + values . get ( num ) ; string util2 . replace ( name , str , str ) ; dimension dim ; if ( null != ( dim = ds . get root group ( ) . find dimension ( name ) ) ) { if ( dim . get length ( ) == len ) {	make a new variable out of the list in "values".
private void create new variables ( netcdf dataset ds , variable nc var , list < dimension > new dims , dimension level dim ) throws invalid range exception { list < dimension > dims = nc var . get dimensions ( ) ; int new dim index = dims . index of ( level dim ) ;	create new variables as sections of ncVar.
private coordinate axis make time coord axis from reference ( netcdf dataset ds , variable time var , array vals ) { variable ref var = ds . find variable ( str ) ; if ( ref var == null ) return null ; double ref value ; try { array ref array = ref var . read ( ) ; ref value = ref array . get double ( ref array . get index ( ) ) ;	construct time coordinate from reftime variable.
public static float bit shave ( float value , int bit mask ) { if ( float . is na n ( value ) ) return value ;	Shave n bits off the float.
public static void main ( string [ ] args ) { string file in = ( args . length > num ) ? args [ num ] : str ; string file out = ( args . length > num ) ? args [ num ] : str ; try ( grib to netcdf writer writer = new grib to netcdf writer ( file in , file out ) ) { writer . write ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	Write Grib file to a netcdf4 file.
static public netcdf dataset wrap ( netcdf file ncfile , set < enhance > mode ) throws io { if ( ncfile instanceof netcdf dataset ) { netcdf dataset ncd = ( netcdf dataset ) ncfile ; if ( ! ncd . enhance needed ( mode ) ) return ( netcdf dataset ) ncfile ; }	Make NetcdfFile into NetcdfDataset with given enhance mode.
public static netcdf file open file ( string location , ucar . nc2 . util . cancel task cancel task ) throws io { dataset url durl = dataset url . find dataset url ( location ) ; return open or acquire file ( null , null , null , durl , - num , cancel task , null ) ; }	Factory method for opening a NetcdfFile through the netCDF API.
public void clear coordinate systems ( ) { coord sys = new array list < > ( ) ; coord axes = new array list < > ( ) ; coord transforms = new array list < > ( ) ; for ( variable v : get variables ( ) ) { variable enhanced ve = ( variable enhanced ) v ; ve . clear coordinate systems ( ) ;	Clear Coordinate System metadata, to allow them to be redone.
public coordinate axis find coordinate axis ( axis type type ) { if ( type == null ) return null ; for ( coordinate axis v : coord axes ) { if ( type == v . get axis type ( ) ) return v ; } return null ; }	Retrieve the CoordinateAxis with the specified Axis Type.
public coordinate axis find coordinate axis ( string full name ) { if ( full name == null ) return null ; for ( coordinate axis v : coord axes ) { if ( full name . equals ( v . get full name ( ) ) ) return v ; } return null ; }	Retrieve the CoordinateAxis with the specified type.
public coordinate system find coordinate system ( string name ) { if ( name == null ) return null ; for ( coordinate system v : coord sys ) { if ( name . equals ( v . get name ( ) ) ) return v ; } return null ; }	Retrieve the CoordinateSystem with the specified name.
public coordinate transform find coordinate transform ( string name ) { if ( name == null ) return null ; for ( coordinate transform v : coord transforms ) { if ( name . equals ( v . get name ( ) ) ) return v ; } return null ; }	Retrieve the CoordinateTransform with the specified name.
public boolean enhance needed ( set < enhance > want ) throws io { if ( want == null ) return bool ; for ( enhance mode : want ) { if ( ! this . enhance mode . contains ( mode ) ) return bool ; } return bool ; }	is this enhancement already done ?.
public void set values ( variable v , int npts , double start , double incr ) { if ( npts != v . get size ( ) ) throw new illegal argument exception ( str + npts + str + v . get size ( ) ) ; array data = array . make array ( v . get data type ( ) , npts , start , incr ) ; if ( v . get rank ( ) != num ) data = data . reshape ( v . get shape ( ) ) ; v . set cached data ( data , bool ) ; }	Generate the list of values from a starting value and an increment.Will reshape to variable if needed.
public void set values ( variable v , list < string > values ) throws illegal argument exception { array data = array . make array ( v . get data type ( ) , values ) ; if ( data . get size ( ) != v . get size ( ) ) throw new illegal argument exception ( str + v . get full name ( ) + str + v . get size ( ) + str + data . get size ( ) ) ; if ( v . get rank ( ) != num )	Set the data values from a list of Strings.
static public array make array ( data type dtype , list < string > string values ) throws number format exception { return array . make array ( dtype , string values ) ; }	Make a 1D array from a list of strings.
public long index ( ) { long offset = num ; for ( int i = num ; i < this . indices . length ; i ++ ) { offset *= this . dimsizes [ i ] ; offset += this . indices [ i ] ; } return offset ; }	Compute the linear indexfrom the current odometer indices.
static public m o get existing file ( string filename ) throws io { if ( filename == null ) return null ; path path = paths . get ( filename ) ; if ( files . exists ( path ) ) return new m o ( path ) ; return null ; }	Make MFileOS7 if file exists, otherwise return null.
public list < esri feature > get features ( d b box ) { if ( b box == null ) return features ; list < esri feature > list = new array list < > ( ) ; for ( esri feature gf : features ) { if ( gf . get bounds2 d ( ) . intersects ( b box ) ) list . add ( gf ) ; } return list ; }	Get a List of all the features in the shapefile that intersectthe specified bounding box.
private void discretize ( double [ ] d , int n ) { if ( coarseness == num ) return ; for ( int i = num ; i < n ; i ++ ) { d [ i ] = ( math . rint ( resolution * d [ i ] ) / resolution ) ; } }	Discretize elements of array to a lower resolution.
public void add ( thredds metadata tmd , boolean include inherited ) { creators . add all ( tmd . get creators ( ) ) ; contributors . add all ( tmd . get contributors ( ) ) ; dates . add all ( tmd . get dates ( ) ) ; docs . add all ( tmd . get documentation ( ) ) ; keywords . add all ( tmd . get keywords ( ) ) ; projects . add all ( tmd . get projects ( ) ) ; properties . add all ( tmd . get properties ( ) ) ; publishers . add all ( tmd . get publishers ( ) ) ; variables . add all ( tmd . get variables ( ) ) ; if ( include inherited ) metadata . add all ( tmd . get metadata ( ) ) ; else { for ( inv metadata mdata : tmd . get metadata ( ) ) { if ( ! mdata . is inherited ( ) ) metadata . add ( mdata ) ; } }	Add all the content from another ThreddsMetadata.
public void add documentation ( string type , string content ) { if ( content == null ) { remove documentation ( type ) ; return ; } content = content . trim ( ) ; for ( inv documentation doc : get documentation ( ) ) { string dtype = doc . get type ( ) ; if ( ( dtype != null ) && dtype . equals ignore case ( type ) ) { doc . set inline content ( content ) ; return ; } } if ( content . length ( ) > num ) add documentation ( new inv documentation ( null , null , null , type , content ) ) ; }	set specified type of documentation.
public void remove documentation ( string type ) { iterator iter = docs . iterator ( ) ; while ( iter . has next ( ) ) { inv documentation doc = ( inv documentation ) iter . next ( ) ; string dtype = doc . get type ( ) ; if ( ( dtype != null ) && dtype . equals ignore case ( type ) ) iter . remove ( ) ; } }	remove all instances of specified type of documentation.
private int get max bytes ( long start ) { int segno = num ; while ( start >= seg max [ segno ] ) segno ++ ; return ( int ) ( seg max [ segno ] - start ) ; }	how many more bytes are in this segment ?.
public static boolean is mine ( netcdf file ncfile ) { string cs = ncfile . find att value ignore case ( null , cdm . conventions , null ) ; if ( cs != null ) return bool ; string s = ncfile . find att value ignore case ( null , str , null ) ; if ( ( s == null ) || ! ( s . equals ignore case ( str ) || s . equals ignore case ( str ) ) ) return bool ; if ( ( null == ncfile . find global attribute ( str ) ) || ( null == ncfile . find global attribute ( str ) ) || ( null == ncfile . find global attribute ( str ) ) || ( null == ncfile . find global attribute ( str ) ) || ( null == ncfile . find global attribute ( str ) ) ) return bool ; return ! ( null == ncfile . find dimension ( str ) || null == ncfile . find dimension ( str ) ) ; }	Is this my file?.
static public list < string > breakup convention names ( string conv att value ) { list < string > names = new array list < > ( ) ; if ( ( conv att value . index of ( str ) > num ) || ( conv att value . index of ( str ) > num ) ) { string tokenizer stoke = new string tokenizer ( conv att value , str ) ; while ( stoke . has more tokens ( ) ) { string name = stoke . next token ( ) ; names . add ( name . trim ( ) ) ; } } else if ( ( conv att value . index of ( str ) > num ) ) { string tokenizer stoke = new string tokenizer ( conv att value , str ) ; while ( stoke . has more tokens ( ) ) { string name = stoke . next token ( ) ; names . add ( name . trim ( ) ) ; } } else { string tokenizer stoke = new string tokenizer ( conv att value , str ) ; while ( stoke . has more tokens ( ) ) { string name = stoke . next token ( ) ; names . add ( name . trim ( ) ) ; } } return names ; }	Breakup list of Convention names in the Convention attribute in CF compliant way.
static public string build convention attribute ( string main conv , string ... conv atts ) { list < string > result = new array list < > ( ) ; result . add ( main conv ) ; for ( string convs : conv atts ) { if ( convs == null ) continue ; list < string > ss = breakup convention names ( convs ) ;	Build a list of Conventions.
@ override public void build coordinate systems ( netcdf dataset nc dataset ) {	Heres where the work is to identify coordinate axes and coordinate systems.
protected void find coordinate axes ( netcdf dataset nc dataset ) { for ( var process vp : var list ) { if ( vp . coord axes != null ) find coordinate axes ( vp , vp . coord axes ) ; if ( vp . coordinates != null ) find coordinate axes ( vp , vp . coordinates ) ; } }	Identify coordinate axes, set VarProcess.isCoordinateAxis = true.Default is to look for those referenced by _CoordinateAxes attribute.Note coordinate variables are already identified.
protected void find coordinate systems ( netcdf dataset nc dataset ) { for ( var process vp : var list ) { if ( vp . coord sys != null ) { string tokenizer stoker = new string tokenizer ( vp . coord sys ) ; while ( stoker . has more tokens ( ) ) { string vname = stoker . next token ( ) ; var process ap = find var process ( vname , vp ) ; if ( ap != null ) { if ( ! ap . is coordinate system ) parse info . format ( str , vname , vp . v . get full name ( ) ) ; ap . is coordinate system = bool ; } else { parse info . format ( str , vname , vp . v . get full name ( ) ) ; user advice . format ( str , vname , vp . v . get full name ( ) ) ; } } } } }	Identify coordinate systems, set VarProcess.isCoordinateSystem = true.Default is to look for those referenced by _CoordinateSystems attribute.
protected void make coordinate systems ( netcdf dataset nc dataset ) { for ( var process vp : var list ) { if ( vp . is coordinate system ) { vp . make coordinate system ( ) ; } } }	Take all previously identified Coordinate Systems and create aCoordinateSystem object.
protected void make coordinate systems maximal ( netcdf dataset nc dataset ) { boolean require complete coord sys = ! nc dataset . get enhance mode ( ) . contains ( netcdf dataset . enhance . incomplete coord systems ) ; for ( var process vp : var list ) { variable enhanced ve = ( variable enhanced ) vp . v ; if ( vp . has coordinate system ( ) || ! vp . is data ( ) ) continue ;	If a variable still doesnt have a coordinate system, use hueristics to try to find one that was probably forgotten.Examine existing CS.
protected boolean is coordinate axis for variable ( variable axis , variable enhanced v ) { list < dimension > var dims = v . get dimensions all ( ) ; list < dimension > axis dims = axis . get dimensions all ( ) ;	Does this axis "fit" this variable.True if all of the dimensions in the axis also appear in the variable.If char variable, last dimension is left out.
public void subset ( inv dataset ds ) { inv dataset impl dataset = ( inv dataset impl ) ds ;	Munge this catalog so the given dataset is the top catalog.
public void filter ( dataset filter filter ) { mark ( filter , top dataset ) ; delete ( top dataset ) ; this . filter = filter ; }	Munge this catalog to remove any dataset that doesnt pass through the filter.
private boolean mark ( dataset filter filter , inv dataset impl ds ) { if ( ds instanceof inv catalog ref ) { inv catalog ref cat ref = ( inv catalog ref ) ds ; if ( ! cat ref . is read ( ) ) return bool ; }	unread CatalogRefs are always kept.
public void init once ( http servlet request req ) throws send error { if ( once ) return ; once = bool ; log . info ( get class ( ) . get name ( ) + str ) ; if ( this . tds context == null ) throw new send error ( http servlet response . sc internal server error , str ) ;	Invoked on first get so that everything is available,especially Spring stuff.
public boolean count ( string name , comparable value ) { counter counter = map . get ( name ) ; if ( counter == null ) { counter = add ( name ) ; } return counter . count ( value ) ; }	Add value to the named counter.Add counter if it doesnt already exist.
private void add ( final string name , final string symbol , final double definition ) throws prefix exists exception { add name ( name , definition ) ; add symbol ( symbol , definition ) ; }	Adds a prefix to the database.
public int compare ( table row other , int col ) { string s1 = get value at ( col ) . to string ( ) ; string s2 = other . get value at ( col ) . to string ( ) ; int ret = s1 . compare to ignore case ( s2 ) ;	for other behavior, override this; use compareXXX routines.
protected int compare boolean ( table row other , int col , boolean b1 , boolean b2 ) {	for use by the subclass.
void pass reserved ( xml map , dap node node ) throws parse exception { try { dap attribute attr = null ; for ( map . entry < string , sax event > entry : map . entry set ( ) ) { sax event event = entry . get value ( ) ; string key = entry . get key ( ) ; string value = event . value ; if ( is reserved ( key ) ) node . add xml ( key , value ) ; } } catch ( dap exception de ) { throw new parse exception ( de ) ; } }	add any reserved xml attributes to a node unchanged.
private boolean has valid date range ( string time start , string time end , string time duration ) {	Determine if a valid date range was specified.
synchronized public void register ( string class name , boolean last ) throws dap exception { try { class < ? extends dsp > klass = ( class < ? extends dsp > ) loader . load class ( class name ) ; register ( klass , last ) ; } catch ( class not found exception e ) { throw new dap exception ( e ) ; } }	Register a DSP, using its class string name.
synchronized public void register ( class < ? extends dsp > klass , boolean last ) {	Register a DSP class.
synchronized public boolean registered ( class < ? extends dsp > klass ) { for ( registration r : registry ) { if ( r . dspclass == klass ) return bool ; } return bool ; }	See if a specific DSP is registered.
synchronized public void unregister ( class < ? extends dsp > klass ) { for ( int i = num ; i < registry . size ( ) ; i ++ ) { if ( registry . get ( i ) . dspclass == klass ) { registry . remove ( i ) ; break ; } } }	Unregister dsp.
public double get forecast time interval size in hours ( grib2 pds pds ) { grib2 pds . pds interval pds intv = ( grib2 pds . pds interval ) pds ; int time unit org = pds . get time unit ( ) ;	Get interval size in units of hours.Only use in GribVariable to decide on variable identity when intvMerge = false.
@ nullable public int [ ] get forecast time interval offset ( grib2 record gr ) { time coord intv date value tinvd = get forecast time interval ( gr ) ; if ( tinvd == null ) return null ; grib2 pds pds = gr . get pds ( ) ; int unit = convert time unit ( pds . get time unit ( ) ) ; time coord intv value tinv = tinvd . convert reference date ( gr . get reference date ( ) , grib2 utils . get calendar period ( unit ) ) ; if ( tinv == null ) return null ; int [ ] result = new int [ num ] ; result [ num ] = tinv . get bounds1 ( ) ; result [ num ] = tinv . get bounds2 ( ) ; return result ; }	If this has a time interval coordinate, get time interval.
@ override public vert coord type get vert unit ( int code ) {	Unit of vertical coordinate.from Grib2 code table 4.5.Only levels with units get a dimension added.
public void sort ( ) { list < dap node > sorted = new array list < dap node > ( ) ; sort r ( this , sorted ) ;	Sort the nodelist into prefix left to right order.
static public var att find variable with attribute ( netcdf dataset ds , string att name ) { for ( variable v : ds . get variables ( ) ) { attribute att = v . find attribute ignore case ( att name ) ; if ( att != null ) return new var att ( v , att ) ; }	Find first variable with given attribute name.
static public variable find variable with attribute value ( netcdf dataset ds , string att name , string att value ) { for ( variable v : ds . get variables ( ) ) { string have value = ds . find att value ignore case ( v , att name , null ) ; if ( ( have value != null ) && have value . equals ( att value ) ) return v ; }	Find first variable with given attribute name and value.If not found, search one level into structures.
static public string find name of variable with attribute value ( netcdf dataset ds , string att name , string att value ) { variable v = find variable with attribute value ( ds , att name , att value ) ; return ( v == null ) ? null : v . get short name ( ) ; }	Find first variable with given attribute name and value.
static public variable find variable with attribute value ( structure struct , string att name , string att value ) { for ( variable v : struct . get variables ( ) ) { attribute att = v . find attribute ignore case ( att name ) ; if ( ( att != null ) && att . get string value ( ) . equals ( att value ) ) return v ; } return null ; }	Find first member variable in this struct with given attribute name and value.
static public structure find nested structure ( structure s ) { for ( variable v : s . get variables ( ) ) { if ( ( v instanceof structure ) ) return ( structure ) v ; } return null ; }	Find first nested structure.
static public boolean has netcdf3 record structure ( netcdf dataset ds ) { variable v = ds . find variable ( str ) ; return ( v != null ) && ( v . get data type ( ) == data type . structure ) ; }	Does this dataset have a record structure? netcdf-3 specific.
static public string get literal ( netcdf dataset ds , string key , formatter errlog ) { if ( key . starts with ( str ) ) { string val = ds . find att value ignore case ( null , key . substring ( num ) , null ) ; if ( ( val == null ) && ( errlog != null ) ) errlog . format ( str , key ) ; return val ; } return key ; }	Translate key to value.
static public feature type get feature type ( netcdf dataset ds , string key , formatter errlog ) { feature type ft = null ; string fts = get literal ( ds , key , errlog ) ; if ( fts != null ) { ft = feature type . value of ( fts . to upper case ( ) ) ; if ( ( ft == null ) && ( errlog != null ) ) errlog . format ( str , fts , key ) ; } return ft ; }	Turn the key into a String and return the corresponding featureType, if any.
static public string get variable name ( netcdf dataset ds , string key , formatter errlog ) { variable v = null ; string vs = get literal ( ds , key , errlog ) ; if ( vs != null ) { v = ds . find variable ( vs ) ; if ( ( v == null ) && ( errlog != null ) ) errlog . format ( str , vs , key ) ; } return v == null ? null : v . get short name ( ) ; }	Find the variable pointed to by key.
public double get coord value ( int j , int i ) { if ( coords == null ) do read ( ) ; return coords . get ( j , i ) ; }	Get the coordinate value at the i, j index.
static private double connect lon ( double connect , double val ) { if ( double . is na n ( connect ) ) return val ; if ( double . is na n ( val ) ) return val ; double diff = val - connect ; if ( math . abs ( diff ) < max jump ) return val ;	larger than you would ever expect.
public double [ ] get coord values ( ) { if ( coords == null ) do read ( ) ; if ( ! is numeric ( ) ) throw new unsupported operation exception ( str ) ; return ( double [ ] ) coords . get1 d ( data type . double ) ; }	Get the coordinate values as a 1D double array, in canonical order.
public d section ( range r1 , range r2 ) throws invalid range exception { list < range > section = new array list < > ( ) ; section . add ( r1 ) ; section . add ( r2 ) ; return ( d ) section ( section ) ; }	Create a new CoordinateAxis2D as a section of this CoordinateAxis2D.
private int find closest ( array double . d2 bounds for run , double target ) { double min diff = double . max value ; int idx found = - num ; int n = bounds for run . get shape ( ) [ num ] ; for ( int i = num ; i < n ; i ++ ) { double midpoint = ( bounds for run . get ( i , num ) + bounds for run . get ( i , num ) ) / num ; double diff = math . abs ( midpoint - target ) ; if ( diff < min diff ) { min diff = diff ; idx found = i ; } } return idx found ; }	return index of closest value to target.
@ deprecated public string get name ( ) { switch ( sort ) { case attribute : case dimension : case enumeration :	getName is deprecated because, as the code below shows,it has no consistent meaning.
public void add action ( string menu name , action act ) { act . put value ( action . name , menu name ) ; super . add ( act ) ; }	Add an action to the popup menu.Note that the menuName is made the NAME value of the action.
public match match ( string path ) { sorted map < string , match > tail = tree map . tail map ( path ) ; if ( tail . is empty ( ) ) return null ; string after = tail . first key ( ) ;	Find the longest match.
public static void main ( string [ ] args ) { projection manager d = new projection manager ( null , null ) ; d . set visible ( ) ; }	testing 1-2-3.
public int index of ( byte [ ] data , int start , int max ) { int j = num ; if ( data . length == num ) return - num ; if ( start + max > data . length ) system . out . println ( str ) ; for ( int i = start ; i < start + max ; i ++ ) { while ( j > num && match [ j ] != data [ i ] ) j = failure [ j - num ] ; if ( match [ j ] == data [ i ] ) j ++ ; if ( j == match . length ) return i - match . length + num ; } return - num ; }	Finds the first occurrence of match in data.
public static synchronized void add ( url url , source picture sp ) { tools . log ( str + url . to string ( ) ) ; if ( sp . get source buffered image ( ) == null ) { tools . log ( str ) ; return ; } if ( ( max cache < num ) ) { tools . log ( str ) ; return ; } if ( is in cache ( url ) ) { tools . log ( str + url . to string ( ) + str ) ; return ; } if ( picture cache . size ( ) >= max cache ) remove least popular ( ) ; if ( picture cache . size ( ) < max cache ) picture cache . put ( url . to string ( ) , sp ) ;	store an image in the cache.
public static synchronized void report cache ( ) { tools . log ( str + integer . to string ( picture cache . size ( ) ) + str + integer . to string ( max cache ) ) ;	method to inspect the cache.
public static void stop background loading ( ) { enumeration e = cache loads in progress . elements ( ) ; while ( e . has more elements ( ) ) { ( ( source picture ) e . next element ( ) ) . stop loading ( ) ; } }	method to stop all background loading.
public static boolean stop background loading except ( url exemption url ) { source picture sp ; string exemption url = exemption url . to string ( ) ; enumeration e = cache loads in progress . elements ( ) ; boolean in progress = bool ; while ( e . has more elements ( ) ) { sp = ( ( source picture ) e . next element ( ) ) ; if ( ! sp . get url string ( ) . equals ( exemption url ) ) sp . stop loading ( ) ; else { tools . log ( str ) ; in progress = bool ; } } return in progress ; }	method to stop all background loading except the indicated file.
static public http get ( http session , string legalurl ) throws http { return makemethod ( http . methods . get , session , legalurl ) ; }	Static factory methods for creating HTTPMethod instances.
static protected http makemethod ( http . methods m , http session , string url ) throws http { http meth = null ; if ( mockmethodclass == null ) {	Common method creation code so we can isolate mocking.
public object next float ( dap type basetype ) throws dap exception { type sort atomtype = basetype . get type sort ( ) ; switch ( atomtype ) { case float32 : return new float [ ] { random . next float ( ) } ; case float64 : return new double [ ] { random . next double ( ) } ; default : break ; } throw new dap exception ( str + basetype ) ; }	return a float type value.
public int next count ( int max ) throws dap exception { int min = num ; if ( max < min || min < num ) throw new dap exception ( str ) ; int range = ( max + num ) - min ;	Return an integer in range 1..max inclusive.
@ override protected array read data ( variable cdmvar , section section ) throws io , invalid range exception {	Primary read entry point.This is the primary implementor of Variable.read.
private static file system provider get provider ( uri uri ) throws io { if ( fsproviders . contains key ( uri . get scheme ( ) ) ) { return fsproviders . get ( uri . get scheme ( ) ) ; } else { file system fs ; try { fs = file systems . new file system ( uri , new hash map < string , object > ( ) , thread . current thread ( ) . get context class loader ( ) ) ; } catch ( file system already exists exception e ) { fs = file systems . get file system ( uri ) ; } fsproviders . put ( uri . get scheme ( ) , fs . provider ( ) ) ; return fs . provider ( ) ; } }	filesystem can't be re-created either.
private static void read station table ( ) throws io { station table hash = new hash map < string , station > ( ) ; class loader cl = level2 volume scan . class . get class loader ( ) ; input stream is = cl . get resource as stream ( str ) ; list < table parser . record > recs = table parser . read table ( is , str , num ) ; for ( table parser . record record : recs ) { station s = new station ( ) ; s . id = str + record . get ( num ) ; s . name = record . get ( num ) + str + record . get ( num ) ; s . lat = ( double ) record . get ( num ) * num ; s . lon = ( double ) record . get ( num ) * num ; s . elev = ( double ) record . get ( num ) ; station table hash . put ( s . id , s ) ; if ( show stations ) system . out . println ( str + s ) ; } }	this is the old Gempak table, not as precise.
@ override public int get index ( t gr ) { integer result = val map . get ( extract ( gr ) ) ; return ( result == null ) ? num : result ; }	Used by CoordinateND.makeSparseArray; not used by CoordinateTime2D.
protected void remove data variable ( string var name ) { iterator iter = data variables . iterator ( ) ; while ( iter . has next ( ) ) { if v = ( if ) iter . next ( ) ; if ( v . get short name ( ) . equals ( var name ) ) iter . remove ( ) ; } }	reminder for subclasses to set this.
private string cloud hgt2 meters ( string height ) { if ( height . equals ( str ) ) { return str ; } else {	convert cloud height to meters.
@ override public array really read ( variable mainv , section section , cancel task cancel task ) throws io , invalid range exception { fmrc inv lite . gridset . grid grid lite = ( fmrc inv lite . gridset . grid ) mainv . get s ( ) ;	here is where agg variables get read.
public void set num colors ( int n ) { if ( n != ncolors ) { colors = new color [ n ] ; int prevn = math . min ( ncolors , n ) ; system . arraycopy ( use colors , num , colors , num , prevn ) ; for ( int i = ncolors ; i < n ; i ++ ) colors [ i ] = color . white ; use colors = colors ; ncolors = n ; edge = new double [ ncolors ] ; hist = new int [ ncolors + num ] ; } }	Set the number of colors in the colorscale.
private affine transform calc transform ( d screen , bounds world ) {	map world coords to screen coords.
static auth scope uri to auth scope ( uri uri ) { assert ( uri != null ) ; return new auth scope ( uri . get host ( ) , uri . get port ( ) , auth scope . any realm , uri . get scheme ( ) ) ; }	Create an AuthScope from a URI; remove any principal.
public void finish ( ) { if ( gcs . size ( ) == num ) return ; if ( gcs . size ( ) == num ) { list hcs = get horiz coord sys ( ) ; grid def record . compare ( ( grid def record ) hcs . get ( num ) , ( grid def record ) hcs . get ( num ) ) ; } }	compares GDS for duplicates.
public boolean is reciprocal of ( final factor that ) { return get base ( ) . equals ( that . get base ( ) ) && get exponent ( ) == - that . get exponent ( ) ; }	Indicates if this Factor is the reciprocal of another Factor.
public inv catalog get dir catalog ( file directory , string filter pattern , boolean sort in increasing order , boolean add dataset size ) { return ( this . get dir catalog ( directory , filter pattern , sort in increasing order , null , add dataset size , null , null , null ) ) ; }	Return a catalog for the given directory.
public int find idx ( int want ) { if ( is constant ) return ( want == start ) ? num : - num ; if ( is sequential ) return want - start ; if ( is sorted ) { return arrays . binary search ( raw , want ) ; }	Find which index holds the value want.
private object read metadata content from url ( inv dataset dataset , string url string ) throws java . net . url , java . io . io {	Create an InvMetadata content object from an XML document at a named URL.The content object is an ArrayList of CatalogGenConfig instances.
public object read metadata content ( inv dataset dataset , org . jdom2 . element mdata element ) { log . debug ( str ) ;	Create an InvMetadata content object from an org.w3c.dom.Element.The content object is an ArrayList of CatalogGenConfig instances.
public void add metadata content ( org . jdom2 . element mdata jdom element , object content object ) {	Serialize the InvMetadata content object to a org.w3c.dom.Element.
public boolean validate metadata content ( object content object , string builder out ) { boolean ok = bool ; array list cat gen config list = ( array list ) content object ; iterator iter = cat gen config list . iterator ( ) ; while ( iter . has next ( ) ) { catalog gen config cat gen conf = ( catalog gen config ) iter . next ( ) ; ok &= cat gen conf . validate ( out ) ; } return ok ; }	Validate the content object.
private catalog gen config read cat gen config element ( inv dataset parent dataset , element cat gen conf element ) { string type = cat gen conf element . get attribute value ( str ) ; catalog gen config cat gen conf = new catalog gen config ( parent dataset , type ) ;	Return a CatalogGenConfig when given a 'catalogGenConfig' JDOM element.
private dataset source read dataset source element ( inv dataset parent dataset , element ds source element ) { string name = ds source element . get attribute value ( str ) ; string type = ds source element . get attribute value ( str ) ; string structure = ds source element . get attribute value ( str ) ; string access point = ds source element . get attribute value ( str ) ; string create catalog refs = ds source element . get attribute value ( str ) ;	Return a DatasetSource when given a 'datasetSource' JDOM element.
private dataset namer read dataset namer element ( inv dataset parent dataset , element ds namer element ) { string name = ds namer element . get attribute value ( str ) ; string add level = ds namer element . get attribute value ( str ) ; string type = ds namer element . get attribute value ( str ) ; string match pattern = ds namer element . get attribute value ( str ) ; string substitute pattern = ds namer element . get attribute value ( str ) ; string attrib container = ds namer element . get attribute value ( str ) ; string attrib name = ds namer element . get attribute value ( str ) ; dataset namer ds namer = new dataset namer ( parent dataset , name , add level , type , match pattern , substitute pattern , attrib container , attrib name ) ; return ( ds namer ) ; }	Return a DatasetNamer when given a 'datasetNamer' JDOM element.
private dataset filter read dataset filter element ( dataset source parent dataset source , element ds filter element ) { string name = ds filter element . get attribute value ( str ) ; string type = ds filter element . get attribute value ( str ) ; string match pattern = ds filter element . get attribute value ( str ) ; dataset filter ds filter = new dataset filter ( parent dataset source , name , dataset filter . type . get type ( type ) , match pattern ) ; string match pattern target = ds filter element . get attribute value ( str ) ; ds filter . set match pattern target ( match pattern target ) ; if ( ds filter element . get attribute value ( str ) != null ) { boolean apply to collection datasets = boolean . value of ( ds filter element . get attribute value ( str ) ) . boolean value ( ) ; ds filter . set apply to collection datasets ( apply to collection datasets ) ; } if ( ds filter element . get attribute value ( str ) != null ) { boolean apply to atomic datasets = boolean . value of ( ds filter element . get attribute value ( str ) ) . boolean value ( ) ; ds filter . set apply to atomic datasets ( apply to atomic datasets ) ; } if ( ds filter element . get attribute value ( str ) != null ) { boolean reject matching datasets = boolean . value of ( ds filter element . get attribute value ( str ) ) . boolean value ( ) ; ds filter . set reject matching datasets ( reject matching datasets ) ; } return ( ds filter ) ; }	Return a DatasetFilter when given a 'datasetFilter' JDOM element.
private result service read result service element ( inv dataset parent dataset , element result service element ) { string name = result service element . get attribute value ( str ) ; string service type = result service element . get attribute value ( str ) ; string base = result service element . get attribute value ( str ) ; string suffix = result service element . get attribute value ( str ) ; string access point header = result service element . get attribute value ( str ) ; return ( new result service ( name , service type . get type ( service type ) , base , suffix , access point header ) ) ; }	Return a ResultService when given a 'resultService' JDOM element.
private org . jdom2 . element create cat gen config element ( catalog gen config cgc ) {	Create a 'catalogGenConfig' JDOM element.
private org . jdom2 . element create dataset source element ( dataset source ds source ) { element dss elem = new element ( str , catalog gen config namespace 0 5 ) ; if ( ds source != null ) {	Create a 'DatasetSource' JDOM element.
private org . jdom2 . element create dataset namer element ( dataset namer ds namer ) { element dsn elem = new element ( str , catalog gen config namespace 0 5 ) ; if ( ds namer != null ) {	Create a 'DatasetNamer' JDOM element.
private org . jdom2 . element create dataset filter element ( dataset filter ds filter ) { element dsf elem = new element ( str , catalog gen config namespace 0 5 ) ; if ( ds filter != null ) {	Create a 'DatasetFilter' JDOM element.
private org . jdom2 . element create result service element ( result service result service ) { element rs elem = new element ( str , catalog gen config namespace 0 5 ) ; if ( result service != null ) {	Create a 'ResultService' JDOM element.
static public boolean is set ( string flag name ) { if ( store == null ) return bool ; name part np = partit ( flag name ) ; if ( debug ) { try { if ( ( np . store name . length ( ) > num ) && ! store . node exists ( np . store name ) ) system . out . println ( str + flag name + str + np ) ; else if ( null == store . node ( np . store name ) . get ( np . key name , null ) ) system . out . println ( str + flag name + str + np ) ; } catch ( backing store exception e ) { } }	Return the value of the named flag.
static public void construct menu ( j top menu ) { if ( debug ) system . out . println ( str ) ; if ( top menu . get item count ( ) > num ) top menu . remove all ( ) ; try { add to menu ( top menu , store ) ;	Construct cascading pull-aside menus using the values of the debug flagsin the Preferences object.
public void add parameters ( string tbl ) throws io { try ( input stream is = get input stream ( tbl ) ) { if ( is == null ) { throw new io ( str + tbl ) ; } string content = read contents ( is ) ;	Add parameters from the table.
private gempak parameter make parameter ( string [ ] words ) { int num = num ; string description ; if ( words [ num ] != null ) { num = ( int ) double . parse double ( words [ num ] ) ; } if ( ( words [ num ] == null ) || words [ num ] . equals ( str ) ) {	Make a parameter from the tokens.
public gempak parameter get parameter ( string name ) { gempak parameter param = param map . get ( name ) ; if ( param == null ) {	Get the parameter for the given name.
private string read contents ( input stream is ) throws io { return new string ( read bytes ( is ) , cdm . utf8 charset ) ; }	Read in the bytes from the given InputStreamand construct and return a String.Closes the InputStream argument.
private byte [ ] read bytes ( input stream is ) throws io { int total read = num ; byte [ ] content = new byte [ num ] ; while ( bool ) { int how many = is . read ( content , total read , content . length - total read ) ; if ( how many < num ) { break ; } if ( how many == num ) { continue ; } total read += how many ; if ( total read >= content . length ) { byte [ ] tmp = content ; int new length = ( ( content . length < num ) ? content . length * num : content . length + num ) ; content = new byte [ new length ] ; system . arraycopy ( tmp , num , content , num , total read ) ; } } is . close ( ) ; byte [ ] results = new byte [ total read ] ; system . arraycopy ( content , num , results , num , total read ) ; return results ; }	Read the bytes in the given input stream.
public string replace file template ( string filespec , int ens index ) { return filespec . replace all ( ens template id , get ensemble names ( ) . get ( ens index ) ) ; }	Replace the ensemble template parameter in a filename.
public void set station info ( string stn id v , string stn desc v ) { this . stn id v = stn id v ; this . stn desc v = stn desc v ; variable station var = ncfile . find variable ( stn id v ) ; station id type = station var . get data type ( ) ; }	Set extra information used by station obs datasets.
protected boolean accept ( string buffer buff ) { if ( ! validate ( buff ) ) { validate ( buff ) ; return bool ; } if ( accept if different ( get edit value ( ) ) ) { set store value ( valid value ) ; send event ( ) ; } return bool ; }	Get current value from editComponent, save to store.If different from old value, fire PropertyChangeEvent.Return false if invalid format, add error message to buff if not null.
@ nullable public byte [ ] get bitmap ( random access file raf ) throws io {	Read the bit map array.
public void set netcdf file ( netcdf file ncf ) { this . ncfile = ncf ; this . filename = ncf . get location ( ) ; final get data runnable runner = new get data runnable ( ) { public void run ( object o ) throws io { final string writer sw = new string writer ( num ) ; n w . print ( ncfile , command , sw , task ) ; result = sw . to string ( ) ; } } ; task = new get data task ( runner , filename , null ) ; stop button . start progress monitor task ( task ) ; }	allow calling from outside.
static public void set debug flags ( ucar . nc2 . util . debug flags debug flag ) { debug ce = debug flag . is set ( str ) ; debug server call = debug flag . is set ( str ) ; debug open result = debug flag . is set ( str ) ; debug data result = debug flag . is set ( str ) ; debug char array = debug flag . is set ( str ) ; debug construct = debug flag . is set ( str ) ; debug preload = debug flag . is set ( str ) ; debug time = debug flag . is set ( str ) ; show n = debug flag . is set ( str ) ; debug attributes = debug flag . is set ( str ) ; debug cached = debug flag . is set ( str ) ; }	Debugging flags. This is a way to decouple setting flags from particular implementations.
name pieces parse name ( string name ) { name pieces pieces = new name pieces ( ) ; int dotpos = name . last index of ( str ) ; int slashpos = name . last index of ( str ) ; if ( slashpos < num && dotpos < num ) { pieces . name = name ; } else if ( slashpos >= num && dotpos < num ) { pieces . prefix = name . substring ( num , slashpos ) ; pieces . name = name . substring ( slashpos + num , name . length ( ) ) ; } else if ( slashpos < num && dotpos >= num ) { pieces . var = name . substring ( num , dotpos ) ; pieces . name = name . substring ( dotpos + num , name . length ( ) ) ; } else {	Utility to decompose a name.
private boolean is group ( d dstruct ) { base type parent = ( base type ) dstruct . get parent ( ) ; if ( parent == null ) return bool ; if ( parent instanceof d ) return is group ( ( d ) parent ) ; return bool ; }	make a structure into a group if its scalar and all parents are groups.
dimension get netcdf strlen dim ( dods v ) { attribute table table = das . get attribute table n ( v . get full name ( ) ) ;	Checks to see if this is netcdf char array.
dimension get shared dimension ( group group , dimension d ) { if ( d . get short name ( ) == null ) return d ; if ( group == null ) group = root group ; for ( dimension sd : group . get dimensions ( ) ) { if ( sd . get short name ( ) . equals ( d . get short name ( ) ) && sd . get length ( ) == d . get length ( ) ) return sd ; } d . set shared ( bool ) ; group . add dimension ( d ) ; return d ; }	If an equivilent shared dimension already exists, use it, else add d to shared dimensions.Equivilent is same name and length.
list < dimension > construct dimensions ( group group , opendap . dap . d dods array ) { if ( group == null ) group = root group ; list < dimension > dims = new array list < dimension > ( ) ; enumeration enumerate = dods array . get dimensions ( ) ; while ( enumerate . has more elements ( ) ) { opendap . dap . d dad = ( opendap . dap . d ) enumerate . next element ( ) ; string name = dad . get encoded name ( ) ; if ( name != null ) name = string util2 . unescape ( name ) ; dimension myd ; if ( name == null ) {	construct list of dimensions to use.
static public boolean is unsigned ( opendap . dap . base type dtype ) { return ( dtype instanceof d ) || ( dtype instanceof du ) || ( dtype instanceof du ) ; }	Get whether this is an unsigned type.
dds read data dd ( string ce ) throws io , opendap . dap . da { if ( debug server call ) system . out . println ( str + ce + str ) ; long start = num ; if ( debug time ) start = system . current time millis ( ) ; if ( ! ce . starts with ( str ) ) ce = str + ce ; dds data ; synchronized ( this ) { data = dods connection . get data ( ce , null ) ; } if ( debug time ) system . out . println ( str + ( system . current time millis ( ) - start ) / num ) ; if ( debug data result ) { system . out . println ( str ) ; data . print ( system . out ) ; } return data ; }	This does the actual connection to the opendap server and reading of the data.All data calls go through here so we can add debugging.
public static image icon get icon ( string full icon name , boolean err msg ) { image icon icon = null ; java . net . url icon r = cl . get resource ( full icon name ) ; if ( debug icon ) { system . out . println ( str + cl . get class loader ( ) ) ; system . out . println ( str + full icon name + str + icon r ) ; } if ( icon r != null ) icon = new image icon ( icon r ) ; if ( ( icon == null ) && err msg ) system . out . println ( str + full icon name ) ; else if ( debug icon ) system . out . println ( str + full icon name ) ; return icon ; }	Get a gif file, make it into an ImageIcon.
public static image get image ( string full image name ) { image image = null ; java . net . url url = cl . get resource ( full image name ) ; if ( url != null ) image = toolkit . get default toolkit ( ) . create image ( url ) ; if ( image == null ) system . out . println ( str + full image name ) ; return image ; }	Get a gif file, make it into an Image.
public static cursor make cursor ( string name ) { image image = get image ( name ) ; if ( null == image ) return null ; cursor cursor ; try { toolkit tk = toolkit . get default toolkit ( ) ; if ( debug ) { image observer obs = new image observer ( ) { public boolean image update ( image image , int flags , int x , int y , int width , int height ) { return bool ; } } ; system . out . println ( str + tk . get best cursor size ( image . get width ( obs ) , image . get height ( obs ) ) ) ; system . out . println ( str + tk . get maximum cursor colors ( ) ) ; } cursor = tk . create custom cursor ( image , new point ( num , num ) , name ) ; } catch ( index out of bounds exception e ) { system . out . println ( str + e ) ; return null ; } return cursor ; }	Get a gif file, make it into a Cursor.
static public object read data fill ( random access file raf , layout index , data type data type , object fill value , int byte order ) throws java . io . io { object arr = ( fill value == null ) ? make primitive array ( ( int ) index . get total nelems ( ) , data type ) : make primitive array ( ( int ) index . get total nelems ( ) , data type , fill value ) ; return read data ( raf , index , data type , arr , byte order , bool ) ; }	Read data subset from RandomAccessFile, create primitive array of size Layout.getTotalNelems.Reading is controlled by the Layout object.
static public object read data fill ( positioning data input stream is , layout index , data type data type , object fill value ) throws java . io . io { object arr = ( fill value == null ) ? make primitive array ( ( int ) index . get total nelems ( ) , data type ) : make primitive array ( ( int ) index . get total nelems ( ) , data type , fill value ) ; return read data ( is , index , data type , arr ) ; }	Read data subset from PositioningDataInputStream, create primitive array of size Layout.getTotalNelems.Reading is controlled by the Layout object.
static public object read data fill ( bb layout , data type data type , object fill value ) throws java . io . io { long size = layout . get total nelems ( ) ; if ( data type == data type . structure ) size *= layout . get elem size ( ) ; object arr = ( fill value == null ) ? make primitive array ( ( int ) size , data type ) : make primitive array ( ( int ) size , data type , fill value ) ; return read data ( layout , data type , arr ) ; }	Read data subset from ByteBuffer, create primitive array of size Layout.getTotalNelems.Reading is controlled by the Layout object.
static public object make primitive array ( int size , data type data type ) { object arr = null ; if ( ( data type . get primitive class type ( ) == byte . class ) || ( data type == data type . char ) || ( data type == data type . opaque ) || ( data type == data type . structure ) ) { arr = new byte [ size ] ; } else if ( data type . get primitive class type ( ) == short . class ) { arr = new short [ size ] ; } else if ( data type . get primitive class type ( ) == int . class ) { arr = new int [ size ] ; } else if ( data type . get primitive class type ( ) == long . class ) { arr = new long [ size ] ; } else if ( data type == data type . float ) { arr = new float [ size ] ; } else if ( data type == data type . double ) { arr = new double [ size ] ; } else if ( data type == data type . string ) { arr = new string [ size ] ; } return arr ; }	Create 1D primitive array of the given size and type.
static public char [ ] convert byte to char utf ( byte [ ] byte array ) { charset c = cdm . utf8 charset ; char buffer output = c . decode ( byte buffer . wrap ( byte array ) ) ; return output . array ( ) ; }	convert byte array to char array, assuming UTF-8 encoding.
static public byte [ ] convert char to byte utf ( char [ ] from ) { charset c = cdm . utf8 charset ; byte buffer output = c . encode ( char buffer . wrap ( from ) ) ; return output . array ( ) ; }	convert char array to byte array, assuming UTF-8 encoding.
static public char [ ] convert byte to char ( byte [ ] byte array ) { int size = byte array . length ; char [ ] cbuff = new char [ size ] ; for ( int i = num ; i < size ; i ++ ) cbuff [ i ] = ( char ) data type . unsigned byte to short ( byte array [ i ] ) ;	convert byte array to char array.
static public ucar . ma2 . array read section ( parsed section spec cer ) throws io , invalid range exception { variable inner = null ; list < range > total ranges = new array list < > ( ) ; parsed section spec current = cer ; while ( current != null ) { total ranges . add all ( current . section . get ranges ( ) ) ; inner = current . v ; current = current . child ; } assert inner != null ; section total = new section ( total ranges ) ; array result = array . factory ( inner . get data type ( ) , total . get shape ( ) ) ;	section reading for member data.
static private array structure section array structure ( parsed section spec child , array structure inner data , structure members . member m ) throws io , invalid range exception { structure members membersw = new structure members ( m . get structure members ( ) ) ;	LOOK could be used in createView ??.
public string get scalar string ( int recnum , structure members . member m ) { array data = m . get data array ( ) ; return ( string ) data . get object ( recnum ) . to string ( ) ; }	Get member databuffer of type String or char.
public structure data get scalar structure ( int index , structure members . member m ) { if ( m . get data type ( ) != data type . structure ) throw new forbidden conversion exception ( str ) ; array ca = member array ( index , member index ( m ) ) ; if ( ca . get data type ( ) != data type . structure && ca . get data type ( ) != data type . sequence ) throw new forbidden conversion exception ( str ) ; cdm as = ( cdm ) ca ; return as . get structure data ( num ) ; }	Non-atomic cases.
@ override public ucar . ma2 . array get array ( int recno , structure members . member m ) { return ( ucar . ma2 . array ) member array ( recno , member index ( m ) ) ; }	Key interface method coming in from StructureDataA.
static structure members computemembers ( dap variable var ) { dap structure ds = ( dap structure ) var . get base type ( ) ; structure members sm = new structure members ( ds . get short name ( ) ) ; list < dap variable > fields = ds . get fields ( ) ; for ( int i = num ; i < fields . size ( ) ; i ++ ) { dap variable field = fields . get ( i ) ; dap type dt = field . get base type ( ) ; data type cdmtype = cdm . daptype2cdmtype ( dt ) ; structure members . member m = sm . add member ( field . get short name ( ) , str , null , cdmtype , cdm . compute effective shape ( field . get dimensions ( ) ) ) ; m . set data param ( i ) ;	Compute the StructureMembers objectfrom a DapStructure. May need to recurseif a field is itself a Structure.
public void add dimensions to netcdf file ( netcdf file ncfile , group g ) { ncfile . add dimension ( g , new dimension ( get name ( ) , get n ( ) , bool ) ) ; }	Add this as a dimension to a netCDF file.
public static string normalize path ( string path ) {	Normalize the given path so that it can be used in the creation of a CrawlableDataset.This method can be used on absolute or relative paths.Normal uses slashes ("/") as path seperator, not backslashes ("\"), and doesnot use trailing slashes.
public void add explicit dataset ( string cache name , string location , string id , string ncoord s , string coord value s , string section spec , ucar . nc2 . util . cache . file factory reader ) { dataset nested = make dataset ( cache name , location , id , ncoord s , coord value s , section spec , null , reader ) ; explicit datasets . add ( nested ) ; }	Add a nested dataset, specified by an explicit netcdf element.enhance is handled by the reader, so its always false here.
public void add dataset scan ( element crawlable dataset element , string dir name , string suffix , string regexp pattern string , string date format mark , set < netcdf dataset . enhance > enhance mode , string subdirs , string older than ) { dataset manager . add directory scan ( dir name , suffix , regexp pattern string , subdirs , older than , enhance mode ) ; this . date format mark = date format mark ; if ( date format mark != null ) { is date = bool ; if ( type == type . join existing ) type = type . join existing one ;	Add a dataset scan.
public void finish ( cancel task cancel task ) throws io { dataset manager . scan ( bool ) ;	all elements are processed, finish construction.
protected void make datasets ( cancel task cancel task ) throws io {	Make the list of Datasets, from explicit and scans.
protected dataset get typical dataset ( ) throws io { list < dataset > nested datasets = get datasets ( ) ; int n = nested datasets . size ( ) ; if ( n == num ) throw new file not found exception ( str ) ; int select ; if ( typical dataset mode == typical dataset . latest ) select = n - num ; else if ( typical dataset mode == typical dataset . penultimate ) select = ( n < num ) ? num : n - num ; else if ( typical dataset mode == typical dataset . first ) select = num ; else {	Open one of the nested datasets as a template for the aggregation dataset.
protected dataset make dataset ( string cache name , string location , string id , string ncoord s , string coord value s , string section spec , enum set < netcdf dataset . enhance > enhance , ucar . nc2 . util . cache . file factory reader ) { return new dataset ( cache name , location , id , enhance , reader ) ;	Dataset factory, so subclasses can override.
void put resource control ( dataset ds ) { if ( logger . is debug enabled ( ) ) logger . debug ( str + ds . get restrict access ( ) + str + ds . get name ( ) ) ; resource control hash . put ( ds . get url path ( ) , ds . get restrict access ( ) ) ;	This tracks Dataset elements that have resource control attributes.
public void add point ( double x , double y ) { point pt prev = null ; if ( points . size ( ) > num ) { pt prev = points . get ( points . size ( ) - num ) ; } this . points . add ( new cf ( x , y , pt prev , null , null ) ) ; }	Add a point to the end of the line.
public double [ ] get bb ( ) { double [ ] bb upper = new double [ num ] ; list < point > pt list = this . get points ( ) ; if ( pt list . is empty ( ) ) return null ; bb upper [ num ] = pt list . get ( num ) . get y ( ) ; bb upper [ num ] = pt list . get ( num ) . get y ( ) ; for ( point pt : this . get points ( ) ) { if ( bb upper [ num ] < pt . get x ( ) ) { bb upper [ num ] = pt . get x ( ) ; } if ( bb upper [ num ] < pt . get y ( ) ) { bb upper [ num ] = pt . get y ( ) ; } }	Gets the upper bounding box coordinate on the line.
public double [ ] get bb ( ) { double [ ] bb lower = new double [ num ] ; list < point > pt list = this . get points ( ) ; if ( pt list . is empty ( ) ) return null ; bb lower [ num ] = pt list . get ( num ) . get y ( ) ; bb lower [ num ] = pt list . get ( num ) . get y ( ) ; for ( point pt : this . get points ( ) ) { if ( bb lower [ num ] > pt . get x ( ) ) { bb lower [ num ] = pt . get x ( ) ; } if ( bb lower [ num ] > pt . get y ( ) ) { bb lower [ num ] = pt . get y ( ) ; } }	Gets the lower bounding box coordinate on the line.
boolean validate ( string builder out ) { this . is valid = bool ;	Validate this DatasetFilter object.
private boolean match ( inv dataset dataset ) {	Test whether the given dataset matches the filter criteria.
public void add all ( feature dataset point fd point ) throws io { try ( point feature iterator point feat iter = new flattened dataset point collection ( fd point ) . get point feature iterator ( ) ) { while ( point feat iter . has next ( ) ) { station point feature point feat = ( station point feature ) point feat iter . next ( ) ; add ( point feat ) ; } } }	fdPoint remains open.
public void parse constraint ( req state rs ) throws parse exception , opendap . dap . da , no such variable exception , no such function exception , invalid operator exception , invalid parameter exception , sbh , wrong type exception { parse constraint ( rs . get constraint expression ( ) , rs . get request url ( ) . to string ( ) ) ; }	Convenience wrapper for parseConstraint.
public boolean eval clauses ( object special o ) throws no such variable exception , da , io { boolean result = bool ; enumeration ec = get clauses ( ) ; while ( ec . has more elements ( ) && result == bool ) { object o = ec . next element ( ) ; if ( debug ) { system . out . println ( str + ec . next element ( ) ) ; } result = ( ( top level clause ) o ) . evaluate ( ) ; }	Evaluate all of the Clauses in the Clause vector.
public void print constraint ( print writer pw ) { enumeration ec = get clauses ( ) ; boolean first = bool ; while ( ec . has more elements ( ) ) { clause cl = ( clause ) ec . next element ( ) ; if ( ! first ) pw . print ( str ) ; cl . print constraint ( pw ) ; first = bool ; } pw . flush ( ) ; }	Print all of the Clauses in the Clause vector.
static public boolean amend from odl ( netcdf file ncfile , group eos group ) throws io { string smeta = get struct metadata ( eos group ) ; if ( smeta == null ) { return bool ; } hdf eos fixer = new hdf eos ( ) ; fixer . fix attributes ( ncfile . get root group ( ) ) ; fixer . amend from odl ( ncfile , smeta ) ; return bool ; }	Amend the given NetcdfFile with metadata from HDF-EOS structMetadata.All Variables named StructMetadata.n, where n= 1, 2, 3 ..
private void set shared dimensions ( variable v , list < element > values , list < dimension > unknown dims , string location ) { if ( values . size ( ) == num ) { return ; }	convert to shared dimensions.
private dimension check unknown dims ( string want dim , list < dimension > unknown dims , dimension old dim , string location ) { for ( dimension dim : unknown dims ) { if ( dim . get short name ( ) . equals ( want dim ) ) { int len = old dim . get length ( ) ; if ( len == num ) { dim . set unlimited ( bool ) ;	look if the wanted dimension is in the unknownDims list.
private group find group nested ( group parent , string name ) { for ( group g : parent . get groups ( ) ) { if ( g . get short name ( ) . equals ( name ) ) { return g ; } } for ( group g : parent . get groups ( ) ) { group result = find group nested ( g , name ) ; if ( result != null ) { return result ; } } return null ; }	look for a group with the given name.
public string read xlink content ( ) throws java . io . io { if ( uri == null ) return str ; url url = uri . to url ( ) ; input stream is = url . open stream ( ) ; byte array output stream os = new byte array output stream ( is . available ( ) ) ;	Get inline content as a string, else null if there is none.
public uri get standard uri ( ) { try { inv catalog cat = dataset . get parent catalog ( ) ; if ( cat == null ) return new uri ( get unresolved url name ( ) ) ; return cat . resolve uri ( get unresolved url name ( ) ) ; } catch ( java . net . uri e ) { logger . warn ( str + get unresolved url name ( ) ) ; return null ; } }	Construct the standard THREDDS access URI for this dataset access method,resolve if the URI is relative.
public void set projection ( projection manager . projection class pc ) {	construct input fields based on Projection Class.
public void add layout component ( component comp , object constraint ) { if ( debug ) system . out . println ( name + str + comp . get class ( ) . get name ( ) + str + comp . hash code ( ) + str + constraint ) ; if ( ! ( constraint instanceof constraint ) ) throw new illegal argument exception ( str ) ; constraint map . put ( comp , constraint ) ; global bounds = null ; }	Adds the specified component to the layout, using the specifiedconstraint object.
public void invalidate layout ( container target ) { if ( debug ) system . out . println ( name + str ) ; global bounds = null ;	Invalidates the layout, indicating that if the layout managerhas cached information it should be discarded.
public void remove layout component ( component comp ) { if ( debug ) system . out . println ( str ) ; constraint map . remove ( comp ) ; global bounds = null ; }	Removes the specified component from the layout.
public dimension minimum layout size ( container parent ) { if ( debug ) system . out . println ( str ) ; if ( global bounds == null ) layout container ( parent ) ; return global bounds . get size ( ) ; }	Calculates the minimum size dimensions for the specifiedcontainer, given the components it contains.
public void layout container ( container target ) { synchronized ( target . get tree lock ( ) ) { if ( debug ) system . out . println ( name + str ) ;	Lays out the specified container.
public static boolean is radial coord sys ( formatter parse info , coordinate system cs ) { return ( cs . get azimuth axis ( ) != null ) && ( cs . get radial axis ( ) != null ) && ( cs . get elevation axis ( ) != null ) ; }	Determine if this CoordinateSystem can be made into a RadialCoordSys.
public double get maximum radial ( ) { if ( max radial == num ) { try { array radial data = get radial axis data cached ( ) ; max radial = ma . get maximum ( radial data ) ; string units = get radial axis ( ) . get units string ( ) ; simple unit radial unit = simple unit . factory ( units ) ; max radial = radial unit . convert to ( max radial , simple unit . km unit ) ;	Get the maximum radial distance, in km.
public double [ ] earth to sat ( double geographic lon , double geographic lat ) { geographic lat = geographic lat * deg to rad ; geographic lon = geographic lon * deg to rad ; double geocentric lat = math . atan ( ( ( r pol * r pol ) / ( r eq * r eq ) ) * math . tan ( geographic lat ) ) ; double r earth = r pol / math . sqrt ( num - ( ( r eq * r eq - r pol * r pol ) / ( r eq * r eq ) ) * math . cos ( geocentric lat ) * math . cos ( geocentric lat ) ) ; double r 1 = h - r earth * math . cos ( geocentric lat ) * math . cos ( geographic lon - sub lon ) ; double r 2 = - r earth * math . cos ( geocentric lat ) * math . sin ( geographic lon - sub lon ) ; double r 3 = r earth * math . sin ( geocentric lat ) ; if ( r 1 > h ) {	Transform geographic Earth coordinates to satellite view angle coordinate systemalso known as the "intermediate" coordinate system in CGMS Normalized Geostationary Projection.
public double [ ] sat to earth ( double x , double y ) { if ( scan geom . equals ( goes ) ) {	Transform satellite view angle coordinates, known as the "intermeidate" coordinates in theCGMS Normalized Geostationary Projection, to geographic Earth coordinates.
public double [ ] goes to geos ( double lamda goes , double theta goes ) { double theta geos = math . asin ( math . sin ( theta goes ) * math . cos ( lamda goes ) ) ; double lamda geos = math . atan ( math . tan ( lamda goes ) / math . cos ( theta goes ) ) ; return new double [ ] { lamda geos , theta geos } ; }	Transform view angle coordinates in the GOES scan geometry frame to view angle coordinatesin the GEOS scan geometry frame.
public static string scan geom to sweep angle axis ( string scan geometry ) { string sweep angle axis = str ; if ( scan geometry . equals ( goes ) ) { sweep angle axis = str ; } return sweep angle axis ; }	Find sweep_angle_axis associated with a scan geometry.
public static string sweep angle axis to scan geom ( string sweep angle axis ) { string scan geom = goes ; if ( sweep angle axis . equals ( str ) ) { scan geom = geos ; } return scan geom ; }	Find scan geometry associated with sweep_angle_axis.
void set runtime coords ( coordinate runtime runtimes ) { for ( int idx = num ; idx < runtimes . get size ( ) ; idx ++ ) { calendar date cd = runtimes . get runtime date ( idx ) ; long runtime = runtimes . get runtime ( idx ) ; coordinate time abstract time = time map . get ( runtime ) ; if ( time == null ) { time = is time interval ? new coordinate time intv ( this . code , this . time unit , cd , new array list < > ( num ) , null ) : new coordinate time ( this . code , this . time unit , cd , new array list < > ( num ) , null ) ; time map . put ( runtime , time ) ; } } }	set the list of runtime coordinates; add any that are not already present, and make an empty CoordinateTimeAbstract for it.
public static void write point obs dataset ( point obs dataset pobs dataset , string file out ) throws io {	write data from a ucar.nc2.dt.PointObsDataset into CF point format.
public static boolean rewrite point feature dataset ( string file in , string file out , boolean in memory ) throws io { system . out . println ( str + file in + str + file out + str + in memory ) ; long start = system . current time millis ( ) ;	Open a ucar.nc2.ft.PointFeatureCollection, write out in CF point format.
public array sequence get array sequence ( string member name ) { structure members . member m = members . find member ( member name ) ; if ( m == null ) throw new illegal argument exception ( str + member name ) ; return get array sequence ( m ) ; }	Get ArraySequence for a member of type Sequence.
public string get full name ( ) { return ( parent == null ) ? name : ( parent . get full name ( ) == null || parent . get full name ( ) . length ( ) == num ) ? name : parent . get full name ( ) + str + name ; }	Get the full, heirarchical name of the dataset, which has all parent collection names.
public string get unique id ( ) { string authority = get authority ( ) ; if ( ( authority != null ) && ( get id ( ) != null ) ) return authority + str + get id ( ) ; else if ( get id ( ) != null ) return get id ( ) ; else return null ; }	If this dataset has an authority and an ID, then the concatenation of them is theglobally unique ID.
public inv access get access ( thredds . catalog . service type type ) { for ( inv access a : get access ( ) ) { inv service s = a . get service ( ) ; if ( s . get service type ( ) == type ) return a ; } return null ; }	Get access element of the specified service type for this dataset.If more than one, get the first one.
public inv dataset impl find dataset by name ( string name ) { for ( inv dataset ds : get datasets ( ) ) { if ( ds . get name ( ) . equals ( name ) ) return ( inv dataset impl ) ds ; } return null ; }	Find an immediate child dataset by its name.
public inv catalog get parent catalog ( ) { if ( catalog != null ) return catalog ; return ( parent != null ) ? parent . get parent catalog ( ) : null ; }	Get containing catalog.
public java . util . list < inv metadata > get metadata ( thredds . catalog . metadata type want ) { list < inv metadata > result = new array list < inv metadata > ( ) ; for ( inv metadata m : get metadata ( ) ) { metadata type mtype = metadata type . get type ( m . get metadata type ( ) ) ; if ( mtype == want ) result . add ( m ) ; } return result ; }	Get the metadata elements of the specified type.
public inv service find service ( string name ) { if ( name == null ) return null ;	Find the named service declared in this dataset or one of its parents.
public thredds metadata . variables get variables ( string vocab ) { thredds metadata . variables result = new thredds metadata . variables ( vocab , null , null , null , null ) ; if ( variables == null ) return result ; for ( thredds metadata . variables vs : variables ) { if ( vs . get vocabulary ( ) . equals ( vocab ) ) result . get variable list ( ) . add all ( vs . get variable list ( ) ) ; } return result ; }	get Variables from the specified vocabulary.
public static list < inv catalog ref > find all cat refs in dataset tree ( list < inv dataset > datasets , string builder log , boolean only relative urls ) { list < inv catalog ref > cat ref list = new array list < inv catalog ref > ( ) ; for ( inv dataset invds : datasets ) { inv dataset impl cur ds = ( inv dataset impl ) invds ; if ( cur ds instanceof inv dataset scan ) continue ; if ( cur ds instanceof inv catalog ref ) { inv catalog ref cat ref = ( inv catalog ref ) cur ds ; string name = cat ref . get name ( ) ; string href = cat ref . get xlink href ( ) ; uri uri ; try { uri = new uri ( href ) ; } catch ( uri e ) { log . append ( log . length ( ) > num ? str : str ) . append ( str ) . append ( name ) . append ( str ) . append ( href ) . append ( str ) ; continue ; } if ( only relative urls && uri . is absolute ( ) ) continue ; cat ref list . add ( cat ref ) ; continue ; } if ( cur ds . has nested datasets ( ) ) cat ref list . add all ( find all cat refs in dataset tree ( cur ds . get datasets ( ) , log , only relative urls ) ) ; } return cat ref list ; }	Find all catalogRef elements in the dataset tree formed by the given dataset list.
static public string escape path for url ( string path ) { try { return new uri ( null , null , path , null ) . to string ( ) ; } catch ( uri e ) { return path ; } }	Escape the characters necessary for a path to be valid for a URL.
private array double . d3 add stagger ( array double . d3 array , int dim index ) {	Add 1 to the size of the array for the given dimension.Use linear average and interpolation to fill in the values.
private double [ ] extrapinterpolate ( double [ ] array ) { int n = array . length ; double [ ] d = new double [ n + num ] ;	Add one element to the array by linear interpolationand extrapolation at the ends.
private double compute rho ( double lat ) { return earth radius * math . sqrt ( c - num * n * math . sin ( lat ) ) / n ; }	Compute the RHO parameter.
public string get detail info ( ) { formatter ff = new formatter ( ) ; ff . format ( str , super . get detail info ( ) ) ; ff . format ( str , parse info ) ; return ff . to string ( ) ; }	Get the detail information.
protected structure make structure ( string part name , list < dimension > dimensions , boolean include missing ) { list < gempak parameter > params = gemreader . get parameters ( part name ) ; if ( params == null ) { return null ; } structure s var = new structure ( ncfile , null , null , part name ) ; s var . set dimensions ( dimensions ) ; for ( gempak parameter param : params ) { s var . add member variable ( make param variable ( param , null ) ) ; } if ( include missing ) { s var . add member variable ( make missing variable ( ) ) ; } return s var ; }	Make a structure for the part.
protected variable make missing variable ( ) { variable var = new variable ( ncfile , null , null , missing var ) ; var . set data type ( data type . byte ) ; var . set dimensions ( ( list < dimension > ) null ) ; var . add attribute ( new attribute ( str , str ) ) ; var . add attribute ( new attribute ( cdm . missing value , ( byte ) num ) ) ; return var ; }	Make the missing variable.
protected variable make param variable ( gempak parameter param , list < dimension > dims ) { variable var = new variable ( ncfile , null , null , param . get name ( ) ) ; var . set data type ( data type . float ) ; var . set dimensions ( dims ) ; var . add attribute ( new attribute ( cdm . long name , param . get description ( ) ) ) ; string units = param . get unit ( ) ; if ( ( units != null ) && ! units . equals ( str ) ) { var . add attribute ( new attribute ( cdm . units , units ) ) ; } var . add attribute ( new attribute ( cdm . missing value , rmiss ) ) ; return var ; }	Make a variable from a GempakParmaeter.
protected void add global attributes ( ) {	Add on global attributes for all types.
protected int get stn var size ( string name ) { int size = - num ; for ( int i = num ; i < stn var names . length ; i ++ ) { if ( name . equals ( stn var names [ i ] ) ) { size = stn var sizes [ i ] ; break ; } } return size ; }	Get the size of a particular station variable.
private array get1 d ( data type type , int len ) { array var array = null ; if ( type . equals ( data type . float ) ) { var array = new array float . d1 ( len ) ; } else if ( type . equals ( data type . double ) ) { var array = new array double . d1 ( len ) ; } else if ( type . equals ( data type . int ) ) { var array = new array int . d1 ( len , bool ) ; } return var array ; }	Get a 1DArray for the type and length.
private int yy lr goto state ( int yystate , int yysym ) { int yyr = yypgoto [ yysym - yyntokens ] + yystate ; if ( num <= yyr && yyr <= yylast && yycheck [ yyr ] == yystate ) return yytable [ yyr ] ; else return yydefgoto [ yysym - yyntokens ] ; }	Compute post-reduction state.
private string yysyntax error ( int yystate , int tok ) { if ( yy error verbose ) { if ( tok != yyempty ) { string buffer res = new string buffer ( str ) ; res . append ( yytnamerr ( yytname [ tok ] ) ) ; int yyn = yypact [ yystate ] ; if ( ! yy pact value is default ( yyn ) ) { int yyxbegin = yyn < num ? - yyn : num ; int yychecklim = yylast - yyn + num ; int yyxend = yychecklim < yyntokens ? yychecklim : yyntokens ; int count = num ; for ( int x = yyxbegin ; x < yyxend ; ++ x ) if ( yycheck [ x + yyn ] == x && x != yyterror && ! yy table value is error ( yytable [ x + yyn ] ) ) ++ count ; if ( count < num ) { count = num ; for ( int x = yyxbegin ; x < yyxend ; ++ x ) if ( yycheck [ x + yyn ] == x && x != yyterror && ! yy table value is error ( yytable [ x + yyn ] ) ) { res . append ( count ++ == num ? str : str ) ; res . append ( yytnamerr ( yytname [ x ] ) ) ; } } } return res . to string ( ) ; } } return str ; }	Generate an error message.
private void yy reduce print ( int yyrule , yy yystack ) { if ( yydebug == num ) return ; int yylno = yyrline [ yyrule ] ; int yynrhs = yyr2 [ yyrule ] ; yycdebug ( str + ( yyrule - num ) + str + yylno + str ) ; for ( int yyi = num ; yyi < yynrhs ; yyi ++ ) yy symbol print ( str + ( yyi + num ) + str , yystos [ yystack . state at ( yynrhs - ( yyi + num ) ) ] , ( ( yystack . value at ( yynrhs - ( yyi + num ) ) ) ) ) ; }	Report on the debug stream that the rule yyrule is going to be reduced.
public string read dmr ( ) throws dap exception { try { if ( state != state . initial ) throw new dap exception ( str ) ; byte [ ] dmr8 = null ; if ( requestmode == request mode . dmr ) {	Read the DMR, trimmed.
public string read error ( ) throws io { state = state . error ;	Read an error chunk.
public int read ( byte [ ] buf , int off , int len ) throws io {	Reads up to len databuffer of databuffer from the input stream into anarray of databuffer.
boolean read header ( input stream input ) throws io { byte [ ] bytehdr = new byte [ num ] ; int red = input . read ( bytehdr ) ; if ( red == - num ) return bool ; if ( red < num ) throw new io ( str ) ; this . flags = ( ( int ) bytehdr [ num ] ) & num ;	Read the size+flags header from the input stream and use it toinitialize the chunk state.
static public date iso string to date ( string iso ) throws illegal argument exception { calendar date dt = iso string to calendar date ( null , iso ) ; return dt . to date ( ) ; }	Does not handle non-standard Calendars.
static public list < record > read table ( string url string , string format , int max lines ) throws io , number format exception { input stream ios ; if ( url string . starts with ( str ) ) { url url = new url ( url string ) ; ios = url . open stream ( ) ; } else { ios = new file input stream ( url string ) ; } return read table ( ios , format , max lines ) ; }	Reads a URL or file in as a table.
static private void transfer group ( netcdf file ds , netcdf dataset target ds , group src , group target group , replace variable check replace check ) { boolean unlimited ok = bool ;	transfer the objects in src group to the target group.
private file get stn file ( string location ) { file file = new file ( location ) ; file stn file = new file ( file . get parent file ( ) , stn file ) ; if ( ! stn file . exists ( ) ) { if ( file . get parent file ( ) == null ) return null ; stn file = new file ( file . get parent file ( ) . get parent file ( ) , stn file ) ; if ( ! stn file . exists ( ) ) return null ; } return stn file ; }	stn file must be in the same directory or one up.
@ override public void open ( random access file raff , netcdf file ncfile , cancel task cancel task ) throws io { super . open ( raff , ncfile , cancel task ) ; int pos = location . last index of ( str ) ; string ext = location . substring ( pos ) ; file file = new file ( location ) ; file stn file = get stn file ( location ) ; if ( stn file == null ) throw new file not found exception ( str + location ) ; if ( ext . equals ( idx ext ) ) { stn raf = random access file . acquire ( stn file . get path ( ) ) ; } else if ( ext . equals ( dat ext ) ) { stn raf = random access file . acquire ( stn file . get path ( ) ) ; data raf = raff ;	if a DAT file.
public int get beginning ( int index ) {	Gets the beginning index of a geometry's points given the index of the geometry within the array.
public int get end ( int index ) {	Gets the ending index of a geometry's points given the index of the geometry within the array.
private boolean create all runtime collections ( formatter errlog ) throws io { long start = system . current time millis ( ) ; this . type = grib collection immutable . type . src ; boolean ok = bool ; list < m > files = new array list < > ( ) ; list < ? extends group > groups = make groups ( files , bool , errlog ) ; list < m > all files = collections . unmodifiable list ( files ) ;	creates seperate collection and index for each runtime.
protected void set edit value ( object value ) { if ( value == null ) tf . set text ( str ) ; else tf . set text ( value . to string ( ) ) ;	set current value of editComponent.
data type get data type ( int format ) { data type p ; switch ( format ) { case num :	Return the string of entity ID for the Dorade image file.
public static double [ ] ec lla ( double x , double y , double z , double a , double b ) { double longitude = math . atan2 ( y , x ) ; double e prime squared = ( a * a - b * b ) / ( b * b ) ; double p = math . sqrt ( x * x + y * y ) ; double theta = math . atan ( ( z * a ) / ( p * b ) ) ; double sine theta = math . sin ( theta ) ; double cos theta = math . cos ( theta ) ; double f = num / num ; double e2 = num * f - f * f ; double top = z + e prime squared * b * sine theta * sine theta * sine theta ; double bottom = p - e2 * a * cos theta * cos theta * cos theta ; double geodetic lat = math . atan ( top / bottom ) ; double sine lat = math . sin ( geodetic lat ) ; double n = a / math . sqrt ( num - e2 * sine lat * sine lat ) ; double altitude = ( p / math . cos ( geodetic lat ) ) - n ;	comparing api to others.
public static string clean unit ( string unit ) { if ( unit == null ) return null ;	Clean up strings to be used for unit string.
public static string clean name ( string name ) { if ( name == null ) return null ; int pos = name . index of ( str ) ; if ( pos < num ) pos = name . index of ( str ) ; if ( pos > num ) name = name . substring ( num , pos ) ; name = string util2 . replace ( name , str , str ) ; string builder sb = new string builder ( name ) ; string util2 . replace ( sb , str , str ) ; string util2 . remove ( sb , str ) ; return string util2 . collapse whitespace ( sb . to string ( ) . trim ( ) ) ; }	Clean up strings to be used in Netcdf Object names.
public static boolean is unitless ( string unit ) { if ( unit == null ) return bool ; string munge = unit . to lower case ( ) . trim ( ) ; munge = string util2 . remove ( munge , str ) ; return munge . length ( ) == num || munge . starts with ( str ) || munge . starts with ( str ) || munge . starts with ( str ) || munge . starts with ( str ) || munge . starts with ( str ) || munge . starts with ( str ) || munge . equals ( str ) ; }	The given unit is "unitless".
static notes factory ( note sort ns , int g , int id , dsp dsp ) { notes note = null ; switch ( ns ) { case type : note = new type notes ( g , id , dsp ) ; break ; case var : note = new var notes ( g , id , dsp ) ; break ; case dim : note = new dim notes ( g , id , dsp ) ; break ; case group : note = new group notes ( g , id , dsp ) ; break ; } return note ; }	Use a factory so we can debug constructor calls.
static public long get var id ( var notes note ) { return get var id ( note . gid , note . id , note . get field index ( ) ) ; }	Manage the compound id for variables.
void parse das ( das das ) throws io { enumeration table names = das . get names ( ) ; while ( table names . has more elements ( ) ) { string table name = ( string ) table names . next element ( ) ; attribute table att table = das . get attribute table n ( table name ) ; if ( table name . equals ( str ) || table name . equals ( str ) ) { add attribute table ( this , att table , table name , bool ) ; } else if ( table name . equals ( str ) || table name . equals ( str ) ) {	Parse the DAS, assign attribute tables to the DodsV objects.Nested attribute tables are supposed to follow the tree we construct with dodsV, so its easy to assign to correct dodsV.
v find dods v ( string name , boolean use done ) { for ( v dods v : children ) { if ( use done && dods v . is done ) continue ;	Search the immediate children for a BaseType with given name.
v find data v ( v dds v ) { if ( dds v . parent . bt != null ) { v parent v = find data v ( dds v . parent ) ; if ( parent v == null )	find the DodsV object in the dataVlist corresponding to the ddsV.
v find by index ( int index ) { if ( children . size ( ) <= index ) return null ; return children . get ( index ) ; }	Return a child by index.
public group get parent group ( ) { group g = super . get parent group ( ) ; if ( g == null ) { g = ncfile . get root group ( ) ; super . set parent group ( g ) ; } assert g != null ; return g ; }	Get the parent group.
public dimension get dimension ( int i ) { if ( ( i < num ) || ( i >= get rank ( ) ) ) return null ; return dimensions . get ( i ) ; }	Get the ith dimension.
public int find dimension index ( string name ) { for ( int i = num ; i < dimensions . size ( ) ; i ++ ) { dimension d = dimensions . get ( i ) ; if ( name . equals ( d . get short name ( ) ) ) return i ; } return - num ; }	Find the index of the named Dimension in this Variable.
public string get units string ( ) { string units = null ; attribute att = find attribute ( cdm . units ) ; if ( att == null ) att = find attribute ignore case ( cdm . units ) ; if ( ( att != null ) && att . is string ( ) ) { units = att . get string value ( ) ; if ( units != null ) units = units . trim ( ) ; } return units ; }	Get the Unit String for the Variable.Looks for the CDM.UNITS attribute value.
public section get shape as section ( ) { if ( shape as section == null ) { try { list < range > list = new array list < > ( ) ; for ( dimension d : dimensions ) { int len = d . get length ( ) ; if ( len > num ) list . add ( new range ( d . get short name ( ) , num , len - num ) ) ; else if ( len == num ) list . add ( range . empty ) ;	Get shape as a Section object.
public variable slice ( int dim , int value ) throws invalid range exception { if ( ( dim < num ) || ( dim >= shape . length ) ) throw new invalid range exception ( str + dim ) ;	Create a new Variable that is a logical slice of this Variable, byfixing the specified dimension at the specified index value.
public void set enum typedef ( enum typedef enum typedef ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( ! data type . is enum ( ) ) throw new unsupported operation exception ( str ) ; this . enum typedef = enum typedef ; }	Public by accident.
public array read ( list < range > ranges ) throws io , invalid range exception { if ( null == ranges ) return read ( ) ; return read ( new section ( ranges ) ) ; }	Read a section of the data for this Variable from the netcdf file and return a memory resident Array.
public string read scalar string ( ) throws io { array data = get scalar data ( ) ; if ( data type == data type . string ) return ( string ) data . get object ( index . scalar index immutable ) ; else if ( data type == data type . char ) { array char data c = ( array char ) data ; return data c . get string ( ) ; } else throw new illegal argument exception ( str + get full name ( ) ) ; }	Get the value as a String for a scalar Variable.
protected array read ( ) throws io {	non-structure-member Variables.
protected array read ( section section ) throws io , invalid range exception {	assume filled, validated Section.
public string write cdl ( boolean use full name , boolean strict ) { formatter buf = new formatter ( ) ; write cdl ( buf , new indent ( num ) , use full name , strict ) ; return buf . to string ( ) ; }	CDL representation of a Variable.
public string to string debug ( ) { formatter f = new formatter ( ) ; f . format ( str , get full name ( ) ) ; if ( ncfile != null ) { f . format ( str , get dataset location ( ) ) ; string extra = ncfile . to string debug ( this ) ; if ( extra != null ) f . format ( str , extra ) ; } return f . to string ( ) ; }	String representation of Variable and its attributes.
public void set data type ( data type data type ) { if ( immutable ) throw new illegal state exception ( str ) ; this . data type = data type ; this . element size = get data type ( ) . get size ( ) ; }	Set the data type.
public void set dimensions ( list < dimension > dims ) { if ( immutable ) throw new illegal state exception ( str ) ; this . dimensions = ( dims == null ) ? new array list < > ( ) : new array list < > ( dims ) ; reset shape ( ) ; }	Set the shape with a list of Dimensions.
public void reset shape ( ) {	Use when dimensions have changed, to recalculate the shape.
public void set dimensions ( string dim string ) { if ( immutable ) throw new illegal state exception ( str ) ; try { set dimensions ( dimension . make dimensions list ( get parent group ( ) , dim string ) ) ;	Set the dimensions using the dimensions names.
public void reset dimensions ( ) { if ( immutable ) throw new illegal state exception ( str ) ; array list < dimension > new dimensions = new array list < > ( ) ; for ( dimension dim : dimensions ) { if ( dim . is shared ( ) ) { dimension new d = get parent group ( ) . find dimension ( dim . get short name ( ) ) ; if ( new d == null ) throw new illegal argument exception ( str + get full name ( ) + str + dim ) ; new dimensions . add ( new d ) ; } else { new dimensions . add ( dim ) ; } } this . dimensions = new dimensions ; reset shape ( ) ; }	Reset the dimension array.
public void set dimension ( int idx , dimension dim ) { if ( immutable ) throw new illegal state exception ( str ) ; dimensions . set ( idx , dim ) ; reset shape ( ) ; }	Replace a dimension with an equivalent one.
public void set cached data ( array cache data , boolean is metadata ) { if ( ( cache data != null ) && ( cache data . get element type ( ) != get data type ( ) . get primitive class type ( ) ) ) throw new illegal argument exception ( str + cache data . get element type ( ) + str + get data type ( ) ) ; this . cache . data = cache data ; this . is metadata = is metadata ; this . cache . caching set = bool ; this . cache . is caching = bool ; }	Set the data cache.
public list < dimension > get dimensions all ( ) { list < dimension > dims all = new array list < > ( ) ; add dimensions all ( dims all , this ) ; return dims all ; }	Get list of Dimensions, including parents if any.
protected void set bounding box ( ) { lat lon rect largest bb = null ;	you must set EarthLocation before you call this.
void finish ( ) { grid list = new array list < > ( uv hash . values ( ) ) ; collections . sort ( grid list ) ;	call after adding all runs.
public iterable < dataset > get all datasets ( ) { list < dataset > all = new array list < > ( ) ; add all ( this , all ) ; return all ; }	get all datasets contained directly in this catalog.
public boolean dsp match ( string path , dap context context ) { for ( string ext : synextensions ) { if ( path . ends with ( ext ) ) return bool ; } return bool ; }	A path is a Synthetic path if it ends in .dmr or .syn.
public cdmdsp open ( netcdf dataset ncd ) throws dap exception { assert this . context != null ; this . dmrfactory = new dmr ( ) ; this . ncdfile = ncd ; set location ( this . ncdfile . get location ( ) ) ; build dmr ( ) ; return this ; }	Provide an extra API for use in testing.
public void build dmr ( ) throws dap exception { if ( get dmr ( ) != null ) return ; try { if ( dumpcdl ) { system . out . println ( str ) ; this . ncdfile . write cdl ( system . out , bool ) ; system . out . flush ( ) ; }	Extract the metadata from the NetcdfDatasetand build the DMR.
protected void buildseqtypes ( variable cdmvar ) throws dap exception { if ( cdm . has vlen ( cdmvar ) ) { buildseqtype ( cdmvar ) ; } if ( cdmvar . get data type ( ) == data type . structure || cdmvar . get data type ( ) == data type . sequence ) { structure struct = ( structure ) cdmvar ; list < variable > fields = struct . get variables ( ) ; for ( int i = num ; i < fields . size ( ) ; i ++ ) { variable field = fields . get ( i ) ; buildseqtypes ( field ) ;	Walk this variable, including fields, to construct sequence typesfor any contained vlen dimensions.
protected void builddimrefs ( dap variable dapvar , list < dimension > cdmdims ) throws dap exception { if ( cdmdims == null || cdmdims . size ( ) == num ) return ;	Assign dimensions to a variable.
protected enum typedef find matching enum ( enum typedef varenum ) throws dap exception { list < enum typedef > candidates = new array list < > ( ) ; for ( map . entry < dap node , cdm > entry : this . nodemap . get cdm ( ) . entry set ( ) ) { cdm cdmnode = entry . get value ( ) ; if ( cdmnode . get sort ( ) != cdm . enumeration ) continue ;	Unfortunately, the CDM Iosp does notactually use the declared enums.
static list < dimension > get core dimset ( list < dimension > dimset ) throws dap exception { if ( dimset == null ) return null ; list < dimension > core = new array list < > ( ) ; int pos = - num ; int count = num ; for ( int i = num ; i < dimset . size ( ) ; i ++ ) { if ( dimset . get ( i ) . is variable length ( ) ) { pos = i ; count ++ ; } else core . add ( dimset . get ( i ) ) ; } if ( ( pos != dimset . size ( ) - num ) || count > num ) throw new dap exception ( str ) ; return core ; }	Strip vlen dimensions from a set of dimensions.
public int scan bufr file ( string filename , counter total ) throws exception { int count = num ; try ( random access file raf = new random access file ( filename , str ) ) { message scanner scan = new message scanner ( raf ) ; while ( scan . has next ( ) ) { message m = scan . next ( ) ; if ( m == null ) continue ; try { if ( show mess ) out . format ( str , indent , count , m . get header ( ) ) ; count ++ ; counter counter = new counter ( ) ; process bufr message as dataset ( scan , m , counter ) ; if ( show mess ) out . format ( str , indent , counter . nvals , counter . nmiss ) ; total . add ( counter ) ; } catch ( exception e ) { system . out . printf ( str , e . get message ( ) , m . get header ( ) ) ; indent . set indent level ( num ) ; } } } return count ; }	open the file and extract BUFR messages.
private void process bufr message as dataset ( message scanner scan , message m , counter counter ) throws exception { byte [ ] mbytes = scan . get message bytes ( m ) ; netcdf file ncfile = netcdf file . open in memory ( str , mbytes , str ) ; sequence obs = ( sequence ) ncfile . find variable ( bufr iosp2 . obs record ) ; structure data iterator sdata iter = obs . get structure iterator ( - num ) ; process sequence ( obs , sdata iter , counter ) ; }	convert one message ino a NetcdfDataset and print data.
public void do post ( http servlet request req , http servlet response res ) throws servlet exception , io { log . info ( str + usage log . setup request context ( req ) ) ;	POST handles uploaded files.
public affine transform get transform ( ) { at . set transform ( pix per world , num , num , - pix per world , pix x0 , pix y0 ) ; if ( debug ) { system . out . println ( str + pix per world + str + pix x0 + str + pix y0 ) ; system . out . println ( str + at ) ; } return at ; }	Get the affine transform based on screen size and world bounding box.
public boolean want rotate ( double display width , double display height ) { get map area ( bb ) ;	calculate if we want to rotate based on aspect ratio.
public projection rect get map area ( projection rect rect ) { if ( rect == null ) rect = new projection rect ( ) ; double width = pwidth / pix per world ; double height = pheight / pix per world ;	Get current MapArea .
public d world to screen ( projection point impl w , d p ) { p . set location ( pix per world * w . get x ( ) + pix x0 , - pix per world * w . get y ( ) + pix y0 ) ; return p ; }	convert a world coordinate to a display point.
public void pan ( double deltax , double deltay ) { zoom . push ( ) ; pix x0 -= deltax ; pix y0 -= deltay ; fire map area event ( ) ; }	call this to change the center of the screen's world coordinates.deltax, deltay in display coordinates.
public void zoom ( double startx , double starty , double width , double height ) { if ( debug zoom ) system . out . println ( str + startx + str + starty + str + width + str + height + str ) ; if ( ( width < num ) || ( height < num ) ) return ; zoom . push ( ) ; pix x0 -= startx + width / num - pwidth / num ; pix y0 -= starty + height / num - pheight / num ; zoom ( pwidth / width ) ; }	call this to zoom into a subset of the screen.startx, starty are the upper left corner of the box in display coordswidth, height the size of the box in display coords.
private void recalc from bounding box ( ) { if ( debug recalc ) { system . out . println ( str + bb ) ; system . out . println ( str + pwidth + str + pheight ) ; }	adjust bounding box to fit inside the screen size.
public synchronized void add listener ( object l ) { if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; has listeners = bool ; } else logger . warn ( str + l ) ; }	Add a listener.
public synchronized void remove listener ( object l ) { if ( listeners . contains ( l ) ) { listeners . remove ( l ) ; has listeners = ( listeners . size ( ) > num ) ; } else logger . warn ( str + l ) ; }	Remove a listener.
public synchronized void send event ( java . util . event object event ) { if ( ! has listeners || ! enabled ) return ; object [ ] args = new object [ num ] ; args [ num ] = event ;	Send an event to all registered listeners. If an exception is thrown, removethe Listener from the list.
public synchronized void send event exclude source ( java . util . event object event ) { if ( ! has listeners || ! enabled ) return ; object source = event . get source ( ) ; object [ ] args = new object [ num ] ; args [ num ] = event ;	Send an event to all registered listeners, except the named one.
public static boolean print ( string command , writer out , ucar . nc2 . util . cancel task ct ) throws io {	ncdump that parses a command string.
static public string print variable data ( if v , ucar . nc2 . util . cancel task ct ) throws io { array data = v . read ( ) ; string writer writer = new string writer ( num ) ; print array ( data , v . get full name ( ) , new print writer ( writer ) , new indent ( num ) , ct ) ; return writer . to string ( ) ; }	Print all the data of the given Variable.
static public string print variable data section ( variable v , string section spec , ucar . nc2 . util . cancel task ct ) throws io , invalid range exception { array data = v . read ( section spec ) ; string writer writer = new string writer ( num ) ; print array ( data , v . get full name ( ) , new print writer ( writer ) , new indent ( num ) , ct ) ; return writer . to string ( ) ; }	Print a section of the data of the given Variable.
static public void print structure data ( print writer out , structure data sdata ) throws io { print structure data ( out , sdata , new indent ( num ) , null ) ; out . flush ( ) ; }	Print contents of a StructureData.
static public void print array plain ( array ma , print writer out ) { ma . reset local iterator ( ) ; while ( ma . has next ( ) ) { out . print ( ma . next ( ) ) ; out . print ( str ) ; } }	Print array as undifferentiated sequence of values.
static public void print array ( array array , print writer pw ) { print array ( array , null , null , pw , new indent ( num ) , null , bool ) ; }	Print array to PrintWriter.
static public void write nc ml ( netcdf file ncfile , writer writer , want values show values , string url ) throws io { preconditions . check not null ( ncfile ) ; preconditions . check not null ( writer ) ; preconditions . check not null ( show values ) ; predicate < variable > write vars pred ; switch ( show values ) { case none : write vars pred = ml . write no variables predicate ; break ; case coords only : write vars pred = ml . write coordinate variables predicate ; break ; case all : write vars pred = ml . write all variables predicate ; break ; default : string message = string . format ( str , show values ) ; throw new assertion error ( message ) ; } ml ncml writer = new ml ( ) ; ncml writer . set write variables predicate ( write vars pred ) ; element netcdf element = ncml writer . make netcdf element ( ncfile , url ) ; ncml writer . write to writer ( netcdf element , writer ) ; }	Write the NcML representation for a file.Note that ucar.nc2.dataset.NcMLWriter has a JDOM implementation, for complete NcML.This method implements only the "core" NcML for plain ole netcdf files.
protected double read attribute double ( attribute container v , string attname , double def value ) { attribute att = v . find attribute ignore case ( attname ) ; if ( att == null ) return def value ; if ( att . is string ( ) ) return double . parse double ( att . get string value ( ) ) ; else return att . get numeric value ( ) . double value ( ) ; }	Read a variable attribute as a double.
protected boolean add parameter ( coordinate transform rs , string param name , netcdf file ds , string var name escaped ) { if ( null == ( ds . find variable ( var name escaped ) ) ) { if ( null != err buffer ) err buffer . format ( str , get transform name ( ) , var name escaped ) ; return bool ; } rs . add parameter ( new parameter ( param name , var name escaped ) ) ; return bool ; }	Add a Parameter to a CoordinateTransform.Make sure that the variable exists.
protected object read as ( dap variable atomvar , dap type basetype , list < slice > slices ) throws dap exception { if ( basetype . get type sort ( ) == type sort . enum ) {	Allow specification of basetype to use; used for enumerations.
public final boolean is positive up ( grid record gr ) { int type = gr . get level type1 ( ) ; if ( ( type == num ) || ( type == num ) ) { return bool ; } return bool ; }	is this a PositiveUp VerticalCoordinate.
public boolean is compatible ( final unit that ) {	Indicates if numeric values in this unit are convertible with anotherunit.
public string make label ( final string quantity id ) { final string builder buf = new string builder ( quantity id ) ; if ( quantity id . contains ( str ) ) { buf . insert ( num , str ) . append ( str ) ; } buf . append ( str ) ; final int start = buf . length ( ) ; buf . append ( to string ( ) ) ; if ( buf . substring ( start ) . index of ( str ) != - num ) { buf . insert ( start , str ) . append ( str ) ; } return buf . to string ( ) ; }	Returns a label for a quantity in this unit.
public void set bit offset ( int bit offset ) throws io { if ( bit offset % num == num ) { raf . seek ( start pos + bit offset / num ) ; bit pos = num ; bit buf = num ; } else { raf . seek ( start pos + bit offset / num ) ; bit pos = num - ( bit offset % num ) ; bit buf = ( byte ) raf . read ( ) ; bit buf &= num > > ( num - bit pos ) ;	Position file at bitOffset from startPos.
public long bits2 u ( int nb ) throws io { assert nb <= num ; assert nb >= num ; long result = num ; int bits left = nb ; while ( bits left > num ) {	Read the next nb bits and return an Unsigned Long .
public long bits2 s ( int nb ) throws io { long result = bits2 u ( nb ) ;	Read the next nb bits and return an Signed Long .
private void open connection ( string url string , command command ) throws io , da { input stream is = null ; try { try ( http method = http . get ( session , url string ) ) { if ( accept compress ) method . set compression ( str ) ;	Open a connection to the DODS server.
public das get das ( ) throws io , da { das command = new das ( ) ; if ( file path != null ) {	Returns the DAS object from the dataset referenced by this object's URL.The DAS object is referred to by appending `.das' to the end of a DODSURL.
private string get complete ce ( string ce ) { string local proj string = null ; string local sel string = null ; if ( ce == null ) return str ;	Use some sense when assembling the CE.
@ override public lat lon point proj to lat lon ( projection point world , lat lon point impl result ) { double from x = world . get x ( ) - false easting ; double from y = world . get y ( ) - false northing ; double to lat r = from y / earth radius ; double to lon r ; if ( misc . nearly equals ( math . abs ( to lat r ) , pi over 2 , num ) ) { to lat r = to lat r < num ? - pi over 2 : + pi over 2 ; to lon r = math . to radians ( cent meridian ) ;	Convert projection coordinates to a LatLonPoint.
private string idv dataset catalog ( string xml ) { string ret = xml . replace ( str , str ) ; ret = ret . replace ( str , str ) ; string builder sub = new string builder ( ret . substring ( num , ret . index of ( str ) ) ) ; sub . append ( str ) ; sub . append ( str ) ; string end coverage = str ; sub . append ( ret . substring ( ret . index of ( end coverage ) + end coverage . length ( ) ) ) ; return sub . to string ( ) ; }	This code tweaks our catalog output to match.
private date range idv compatible range ( date range range ) { calendar date start = range . get start ( ) . get calendar date ( ) ; calendar date end = range . get end ( ) . get calendar date ( ) ; return new date range ( start . to date ( ) , end . to date ( ) ) ; }	present and 14 days.
boolean is valid file ( ucar . unidata . io . random access file ra file ) {	Check basic DMSP file validity of given random access file.
private void handle satellite information ( ) { spacecraft id att = new attribute ( this . spacecraft id att name , header info . get ( header info title . spacecraft id . to string ( ) ) ) ; norad id att = new attribute ( this . norad id att name , header info . get ( header info title . norad id . to string ( ) ) ) ; }	Parse the satellite information from the header.
private void handle sensor information ( ) { num samples per band = integer . parse int ( header info . get ( header info title . samples per band . to string ( ) ) ) ; num samples per band dim = new dimension ( this . num samples per band dim name , num samples per band ) ;	Parse the sensor information from the header.
static public element read root element ( string location ) throws io { org . jdom2 . document doc ; try { sax builder = new sax ( ) ; doc = builder . build ( location ) ; } catch ( jdom e ) { throw new io ( e . get message ( ) ) ; } return doc . get root element ( ) ; }	Read an XML Document from a URL and return the root element.
static public string clean character data ( string text ) { if ( text == null ) return null ; boolean bad = bool ; for ( int i = num , len = text . length ( ) ; i < len ; i ++ ) { int ch = text . char at ( i ) ; if ( ! org . jdom2 . verifier . is xml ( ch ) ) { bad = bool ; break ; } } if ( ! bad ) return text ; string builder sbuff = new string builder ( text . length ( ) ) ; for ( int i = num , len = text . length ( ) ; i < len ; i ++ ) { int ch = text . char at ( i ) ; if ( org . jdom2 . verifier . is xml ( ch ) ) sbuff . append ( ( char ) ch ) ; } return sbuff . to string ( ) ; }	Make sure that text is XML safe.
private static string xunescape string ( string in , char escape , boolean spaceplus ) { try { if ( in == null ) return null ; byte [ ] utf8 = in . get bytes ( utf8 charset ) ; byte escape8 = ( byte ) escape ; byte [ ] out = new byte [ utf8 . length ] ;	Given a string that contains WWW escape sequences, translate those escapesequences back into ASCII characters.
public static string escape url ( string ce ) { try { ce = escape string ( ce , allowable in url query ) ; } catch ( exception e ) { ce = null ; } return ce ; }	Define the DEFINITIVE URL constraint expression escape function.
public static string unescape url ( string ce ) { try { ce = unescape string ( ce ) ; } catch ( exception e ) { ce = null ; } return ce ; }	Define the DEFINITIVE URL constraint expression unescape function.
public static string backslash decode ( string s ) { string builder buf = new string builder ( s ) ; int i = num ; while ( i < buf . length ( ) ) { if ( buf . char at ( i ) == str ) { buf . delete char at ( i ) ; } i ++ ; } return buf . to string ( ) ; }	Define the DEFINITIVE URL BACKSLASH unescape function.
public static string backslash encode ( string s ) { string builder buf = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { int c = buf . char at ( i ) ; if ( must backslash escape . index of ( c ) >= num ) buf . append ( backslash ) ; buf . append ( ( char ) c ) ; } return buf . to string ( ) ; }	Define the DEFINITIVE URL BACKSLASH escape function.
protected void add lightning global attributes ( netcdf file ncfile ) { ncfile . add attribute ( null , new attribute ( cf . feature type , cf . feature type . point . to string ( ) ) ) ; ncfile . add attribute ( null , new attribute ( cdm . history , str ) ) ; }	Add the global attributes.
static public short swap short ( byte [ ] b , int offset ) {	Returns the short resulting from swapping 2 bytes at a specifiedoffset in a byte array.
static public int swap int ( byte [ ] b , int offset ) {	Returns the int resulting from reversing 4 bytes at a specifiedoffset in a byte array.
static public double swap double ( byte [ ] b , int offset ) { long accum = num ; long shiftedval ; for ( int shift by = num , i = offset ; shift by < num ; shift by += num , i ++ ) { shiftedval = ( ( long ) ( b [ i ] & num ) ) << shift by ; accum |= shiftedval ; } return double . long bits to double ( accum ) ; }	Returns the double resulting from reversing 8 bytes at a specifiedoffset in a byte array.
static public float swap float ( float v ) { int l = swap int ( float . float to int bits ( v ) ) ; return ( float . int bits to float ( l ) ) ; }	Returns the float resulting from reversing 4 bytes of a specifiedfloat.
static public double swap double ( double v ) { long l = swap long ( double . double to long bits ( v ) ) ; return ( double . long bits to double ( l ) ) ; }	Returns the double resulting from reversing 8 bytes of a specifieddouble.
static public byte [ ] short to bytes ( short v ) { byte [ ] b = new byte [ num ] ; int allbits = num ; for ( int i = num ; i < num ; i ++ ) { b [ num - i ] = ( byte ) ( ( v & ( allbits << i * num ) ) > > i * num ) ; } return b ; }	Convert a short to an array of 2 bytes.
static public byte [ ] int to bytes ( int v ) { byte [ ] b = new byte [ num ] ; int allbits = num ; for ( int i = num ; i < num ; i ++ ) { b [ num - i ] = ( byte ) ( ( v & ( allbits << i * num ) ) > > i * num ) ; } return b ; }	Convert an int to an array of 4 bytes.
static public byte [ ] long to bytes ( long v ) { byte [ ] b = new byte [ num ] ; long allbits = num ; for ( int i = num ; i < num ; i ++ ) { b [ num - i ] = ( byte ) ( ( v & ( allbits << i * num ) ) > > i * num ) ; } return b ; }	Convert a long to an array of 8 bytes.
public vertical transform subset ( range t range , range z range , range y range , range x range ) throws ucar . ma2 . invalid range exception { return new vertical transform subset ( this , t range , z range , y range , x range ) ; }	Create a subset of this VerticalTransform.
public string write xml ( date last modified ) { xml fmt = new xml ( format . get pretty format ( ) ) ; return fmt . output string ( write document ( last modified ) ) ; }	Write the XML representation to a String.
private array make c ( array s , double a , double b ) { int nz = ( int ) s . get size ( ) ; index s index = s . get index ( ) ; if ( a == num ) return s ;	Make the C array.
public void start xml ( ) { file output += str ; file output += str + str + wfs . tdsnamespace + str + wfsxml . enc quotes ( namespace ) + str + str + str + str + server + str + str ; file output += str + str ; }	Initiate the response with an XML file with an XML header.
public void write features ( ) { for ( wfs feat : feature list ) { file output += str + feat . get title ( ) + str ; file output += str ; file output += str + feat . get type ( ) + str ; file output += str ; for ( wfs attribute : feat . get attributes ( ) ) { file output += str + attribute . get name ( ) + str + attribute . get type ( ) + str ; } file output += str ; file output += str ; file output += str ; file output += str ; file output += str + feat . get name ( ) + str + feat . get title ( ) + str ; } }	Write the features from the featureList. For each feature, write its attributes.
void add levels ( list < grid record > records ) { for ( grid record record : records ) { double d = new double ( record . get level1 ( ) ) ; if ( ! levels . contains ( d ) ) { levels . add ( d ) ; } if ( dont use vertical && ( levels . size ( ) > num ) ) { if ( grid service provider . debug vert ) { system . out . println ( str + vertical name + str + record . get level type1 ( ) + str + levels . size ( ) ) ; } } } collections . sort ( levels ) ; if ( positive . equals ( str ) ) { collections . reverse ( levels ) ;	Add levels from the GridRecords.
void add dimensions to netcdf file ( netcdf file ncfile , group g ) { if ( dont use vertical ) { return ; } int nlevs = levels . size ( ) ; ncfile . add dimension ( g , new dimension ( vertical name , nlevs , bool ) ) ; }	Add dimensions to the netcdf file.
void add to netcdf file ( netcdf file ncfile , group g ) { if ( dont use vertical ) { return ; } if ( g == null ) { g = ncfile . get root group ( ) ; } string dims = str ; if ( ! dont use vertical ) { dims = dims + str + vertical name ; } if ( hcs . is lat lon ( ) ) { dims = dims + str ; } else { dims = dims + str ; }	Add this coordinate system to the netCDF file.
void find coordinate transform ( group g , string name starts with , int level type ) {	Find the coordinate transform.
int get index ( grid record record ) { double d = new double ( record . get level1 ( ) ) ; return levels . index of ( d ) ; }	Get the index of a particular GridRecord.
static public void exit ( ) { if ( timer != null ) { timer . cancel ( ) ; system . out . printf ( str ) ; } timer = null ; }	Be sure to call this when your application exits, otherwise your process may not exit without being killed.
public file get file ( string file location ) { if ( ! always use cache ) { file f = new file ( file location ) ; if ( f . exists ( ) ) return f ; if ( can write ( f ) ) return f ; } if ( never use cache ) { throw new illegal state exception ( str + file location ) ; } file f = new file ( make cache path ( file location ) ) ; if ( cache path policy == cache path policy . nested directory ) { file dir = f . get parent file ( ) ; if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) cache log . warn ( str + dir . get path ( ) ) ; } return f ; }	Get the named File.If exists or isWritable, return it.Otherwise get corresponding file in the cache directory.If fileLocation has "/" in it, and cachePathPolicy == NestedDirectory, thenested directories will be created.
public file get existing file or cache ( string file location ) { file f = new file ( file location ) ; if ( f . exists ( ) ) return f ; if ( never use cache ) return null ; file fc = new file ( make cache path ( file location ) ) ; if ( fc . exists ( ) ) return fc ; return null ; }	Looking for an existing file, in cache or no.
public void show cache ( print stream pw ) { pw . println ( str ) ; pw . println ( str ) ; file dir = new file ( root ) ; file [ ] files = dir . list files ( ) ; if ( files != null ) for ( file file : files ) { string org = null ; try { org = url . decode ( file . get name ( ) , str ) ; } catch ( unsupported encoding exception e ) { e . print stack trace ( ) ; } pw . println ( str + file . length ( ) + str + new date ( file . last modified ( ) ) + str + org ) ; } }	Show cache contents, for debugging.
public void clean cache ( file dir , formatter sbuff , boolean is root ) { long now = system . current time millis ( ) ; file [ ] files = dir . list files ( ) ; if ( files == null ) { throw new illegal state exception ( str + dir . get absolute path ( ) ) ; }	Remove any files or directories whose last modified time greater than persistMinutes.
public static bearing calculate bearing ( earth e , lat lon point pt1 , lat lon point pt2 , bearing result ) { return calculate bearing ( e , pt1 . get latitude ( ) , pt1 . get longitude ( ) , pt2 . get latitude ( ) , pt2 . get longitude ( ) , result ) ; }	Calculate the bearing between the 2 points.See calculateBearing below.
public static bearing calculate bearing ( lat lon point pt1 , lat lon point pt2 , bearing result ) { return calculate bearing ( default earth , pt1 . get latitude ( ) , pt1 . get longitude ( ) , pt2 . get latitude ( ) , pt2 . get longitude ( ) , result ) ; }	Calculate the bearing between the 2 points.See calculateBearing below.
public static void main ( string [ ] args ) {	Test the calculations - forward and back.
public static lat lon point impl find point ( earth e , lat lon point pt1 , double az , double dist , lat lon point impl result ) { return find point ( e , pt1 . get latitude ( ) , pt1 . get longitude ( ) , az , dist , result ) ; }	Calculate a position given an azimuth and distance fromanother point.
public static lat lon point impl find point ( lat lon point pt1 , double az , double dist , lat lon point impl result ) { return find point ( default earth , pt1 . get latitude ( ) , pt1 . get longitude ( ) , az , dist , result ) ; }	Calculate a position given an azimuth and distance fromanother point.
public static lat lon point impl find point ( double lat1 , double lon1 , double az , double dist , lat lon point impl result ) { return find point ( default earth , lat1 , lon1 , az , dist , result ) ; }	Calculate a position given an azimuth and distance fromanother point.
public void load picture in thread ( url image url , int priority , double rotation ) { if ( picture status code == loading ) { stop loading except ( image url ) ; } this . image url = image url ; this . rotation = rotation ; load thread t = new load thread ( this ) ; t . set priority ( priority ) ; t . start ( ) ; }	method to invoke with a filename or URL of a picture that is to be loadeda new thread.
public void load picture ( url image url , double rotation ) { if ( picture status code == loading ) { stop loading except ( image url ) ; } this . image url = image url ; this . rotation = rotation ; load picture ( ) ; }	method to invoke with a filename or URL of a picture that is to be loaded inthe main thread.
public void load picture ( ) { tools . log ( str + image url . to string ( ) + str + integer . to string ( this . hash code ( ) ) ) ;	loads a picture from the URL in the imageUrl object into the sourcePictureBufferedImageobject and updates the status when done or failed.
public void stop loading ( ) { if ( image url == null ) return ;	this method can be invoked to stop the current reader.
public boolean stop loading except ( url exemption url ) { if ( image url == null ) return bool ;	this method can be invoked to stop the current reader except if itis reading the desired file.
public dimension get size ( ) { if ( source picture buffered image != null ) return new dimension ( source picture buffered image . get width ( ) , source picture buffered image . get height ( ) ) ; else return new dimension ( num , num ) ; }	return the size of the image or Zero if there is none.
public void set source buffered image ( buffered image img , string status message ) { source picture buffered image = img ; set status ( ready , status message ) ; }	sets the buffered image.
public uri get standard uri ( ) { try { catalog cat = dataset . get parent catalog ( ) ; if ( cat == null ) return new uri ( get unresolved url name ( ) ) ; return cat . resolve uri ( get unresolved url name ( ) ) ; } catch ( java . net . uri e ) { throw new runtime exception ( str + get unresolved url name ( ) ) ; } }	Construct the standard THREDDS access URI for this dataset access method,resolved agaisnt the parent catalog if the URI is relative.
static public void transfer info ( list < data descriptor > from list , list < data descriptor > to list ) {	Transfer info from the "proto message" to another message with the exact same structure.
int count bits ( ) { int total nbits = num ; total nbytes cdm = num ; for ( data descriptor dd : sub keys ) { if ( dd . sub keys != null ) { total nbits += dd . count bits ( ) ; total nbytes cdm += dd . total nbytes cdm ; } else if ( dd . f == num ) { total nbits += dd . bit width ; total nbytes cdm += dd . get byte width cdm ( ) ; } }	count the bits used by the data in this dd and its childrenonly accurate for not compressed, and not variable length.
public boolean equals2 ( object o ) { if ( this == o ) return bool ; if ( o == null || get class ( ) != o . get class ( ) ) return bool ; data descriptor that = ( data descriptor ) o ; if ( fxy != that . fxy ) return bool ; if ( replication != that . replication ) return bool ; if ( type != that . type ) return bool ; if ( sub keys != null ? ! sub keys . equals ( that . sub keys ) : that . sub keys != null ) return bool ; return bool ; }	LOOK need different hashCode, reader assumes using object id.
private int load header ( ) { if ( header loaded ) return num ; input stream s = stream ; if ( s == null ) return - num ; try { buffered input stream bs = new buffered input stream ( s ) ; ds = new data input stream ( bs ) ; header = new byte [ num ] ; ds . read fully ( header ) ;	Load the dbase file header.
private int load data ( ) { if ( ! header loaded ) return - num ; if ( data loaded ) return num ; input stream s = stream ; if ( s == null ) return - num ; try { for ( int i = num ; i < nrecords ; i ++ ) { byte recbyte = ds . read byte ( ) ; if ( recbyte == num ) { for ( int j = num ; j < nfields ; j ++ ) { data [ j ] . read row n ( ds , i ) ; } } else { nrecords -- ; i -- ; } } data loaded = bool ; } catch ( java . io . io e ) { close ( s ) ; return - num ; } finally { close ( s ) ; } return num ; }	Load the dbase file data.
public dbase data get field ( string name ) { for ( int i = num ; i < nfields ; i ++ ) { if ( field desc [ i ] . name . equals ( name ) ) return data [ i ] ; } return null ; }	Extract the data for a given field by name.
public double [ ] get doubles by name ( string name ) { dbase data d ; if ( ( d = get field ( name ) ) == null ) return null ; if ( d . get type ( ) == dbase data . type char ) { string [ ] s = d . get strings ( ) ; double [ ] dd = new double [ s . length ] ; for ( int i = num ; i < s . length ; i ++ ) { dd [ i ] = double . value of ( s [ i ] ) ; } return dd ; } if ( d . get type ( ) == dbase data . type boolean ) { boolean [ ] b = d . get booleans ( ) ; double [ ] dd = new double [ b . length ] ; for ( int i = num ; i < b . length ; i ++ ) { if ( b [ i ] ) { dd [ i ] = num ; } else { dd [ i ] = num ; } } return dd ; } return d . get doubles ( ) ; }	Extract the double array of data for a field by Name.
public string [ ] get strings by name ( string name ) { dbase data d ; if ( ( d = get field ( name ) ) == null ) return null ; if ( d . get type ( ) != dbase data . type char ) return null ; return d . get strings ( ) ; }	Extract the string array of data for a field by Name.
public boolean [ ] get booleans by name ( string name ) { dbase data d ; if ( ( d = get field ( name ) ) == null ) return null ; if ( d . get type ( ) != dbase data . type boolean ) return null ; return d . get booleans ( ) ; }	Extract the boolean array of data for a field by Name.
public string get field name ( int i ) { if ( i >= nfields || i < num ) { return null ; } return ( field desc [ i ] . name ) ; }	Get the name of a field by column number.
public string [ ] get field names ( ) { string [ ] s = new string [ nfields ] ; for ( int i = num ; i < nfields ; i ++ ) { s [ i ] = get field name ( i ) ; } return s ; }	Get a list of all the field names in the dbase file.
public static void main ( string [ ] args ) { if ( args . length < num ) { system . out . println ( str ) ; system . exit ( - num ) ; } for ( string s : args ) { system . out . println ( str + s + str ) ; try { dbase file dbf = new dbase file ( s ) ;	Test program, dumps a Dbase file to stdout.
public map < string , dap attribute > get attributes ( ) { if ( attributes == null ) attributes = new hash map < string , dap attribute > ( ) ; return attributes ; }	attributes are not allowed on some node types.
synchronized public dap attribute set attribute ( dap attribute attr ) throws dap exception { if ( attributes == null ) attributes = new hash map < string , dap attribute > ( ) ; dap attribute old = attributes . get ( attr . get short name ( ) ) ; attributes . put ( attr . get short name ( ) , attr ) ; attr . set parent ( this ) ; return old ; }	This may occur after initial construction.
public synchronized void remove attribute ( dap attribute attr ) throws dap exception { if ( this . attributes == null ) return ; string name = attr . get short name ( ) ; if ( this . attributes . contains key ( name ) ) this . attributes . remove ( name ) ; }	Used by AbstractDSP to suppress certain attributes.
public dap group get group ( ) { if ( this . sort == dap sort . dataset ) return null ;	Closest containing group.
public dap node get container ( ) { dap node parent = this . parent ; switch ( get sort ( ) ) { default : break ; case enumconst : parent = ( ( dap enum const ) this ) . get parent ( ) . get container ( ) ; break ; case attribute : case attributeset : case otherxml : parent = ( ( dap attribute ) this ) . get parent ( ) ; if ( parent instanceof dap variable ) parent = parent . get container ( ) ; break ; case map : parent = ( ( dap map ) this ) . get variable ( ) . get container ( ) ; break ; } return parent ; }	Closest containing group, structure, sequence.
public string get escaped short name ( ) { if ( this . escapedname == null ) this . escapedname = escape . backslash escape ( get short name ( ) , null ) ; return this . escapedname ; }	Here, escaped means backslash escaped short name.
public list < dap node > get container path ( ) { list < dap node > path = new array list < dap node > ( ) ; dap node current = this . get container ( ) ; for ( ; ; ) { path . add ( num , current ) ; if ( current . get container ( ) == null ) break ; current = current . get container ( ) ; } return path ; }	Get the transitive list of containersNot including this node.
public list < dap group > get group path ( ) { list < dap group > path = new array list < dap group > ( ) ; dap node current = this ; for ( ; ; ) { if ( current . get sort ( ) == dap sort . group || current . get sort ( ) == dap sort . dataset ) path . add ( num , ( dap group ) current ) ; if ( current . get container ( ) == null ) break ; current = current . get container ( ) ; } return path ; }	Get the transitive list of containing groupsPossibly including this node.
public string computefqn ( ) { list < dap node > path = get path ( ) ;	Compute the FQN of this node.
protected void build ( dap dataset dmr , byte [ ] serialdata , byte order order ) throws dap exception { set dmr ( dmr ) ;	Build the data from the incoming serial dataNote that some DSP's will not use.
public void put bean collection ( string key , collection new value ) {	Stores a Collection of beans.
public list get list ( string key , list def ) { try { object bean = get bean ( key , def ) ; return ( list ) bean ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } }	Get an arrayList. This returns a copy of the stored list.
private object get object ( string key name ) { object result = null ; try { result = key values . get ( key name ) ; if ( result == null ) {	assume key non-null, locked node.
public float [ ] read data ( random access file raf , long drs pos ) throws io { raf . seek ( drs pos ) ; grib2 section data representation drs = new grib2 section data representation ( raf ) ; grib2 section bit map bms = new grib2 section bit map ( raf ) ; grib2 section data data section = new grib2 section data ( raf ) ; grib2 gds gds = get gds ( ) ; grib2 data reader reader = new grib2 data reader ( drs . get data template ( ) , gdss . get number points ( ) , drs . get data points ( ) , get scan mode ( ) , gds . get nx raw ( ) , data section . get starting position ( ) , data section . get msg length ( ) ) ; grib2 drs gdrs = drs . get drs ( raf ) ; float [ ] data = reader . get data ( raf , bms , gdrs ) ; if ( gds . is thin ( ) ) data = quasi regular . convert quasi grid ( data , gds . get npts in line ( ) , gds . get nx raw ( ) , gds . get ny raw ( ) , grib data . get interpolation method ( ) ) ; last record read = this ; return data ; }	Read data array.
public dsp print ( ) throws dap exception { dap dataset dmr = this . dsp . get dmr ( ) ; if ( this . ce == null ) this . ce = ce . get universal ( dmr ) ; this . printer . set indent ( num ) ; list < dap variable > topvars = dmr . get top variables ( ) ; for ( int i = num ; i < topvars . size ( ) ; i ++ ) { dap variable top = topvars . get ( i ) ; list < slice > slices = this . ce . get constrained slices ( top ) ; if ( this . ce . references ( top ) ) { data cursor data = dsp . get variable data ( top ) ; print variable ( data , slices ) ; } } printer . eol ( ) ; return this ; }	Print data from a DSP- optionally constrained.
protected void print compound instance ( data cursor datav ) throws dap exception {	Print a single structure or sequence or record instance.
public string write to string ( element elem ) { try ( string writer writer = new string writer ( ) ) { write to writer ( elem , writer ) ; return writer . to string ( ) ; } catch ( io e ) { throw new assertion error ( str , e ) ; } }	Writes an NcML element to a string.
public void write to file ( element elem , file out file ) throws io { try ( output stream out stream = new buffered output stream ( new file output stream ( out file , bool ) ) ) { write to stream ( elem , out stream ) ; } }	Writes an NcML element to an output file.
public void write to stream ( element elem , output stream out stream ) throws io { try ( writer writer = new buffered writer ( new output stream writer ( new buffered output stream ( out stream ) , xml format . get encoding ( ) ) ) ) { write to writer ( elem , writer ) ; } }	Writes an NcML element to an output stream.
public void write to writer ( element elem , writer writer ) throws io { xml outputter . set format ( xml format ) ; elem . detach ( ) ;	Writes an NcML element to a Writer.
public element make dimension element ( dimension dim ) throws illegal argument exception { if ( ! dim . is shared ( ) ) { throw new illegal argument exception ( str + str ) ; } element dim elem = new element ( str , namespace ) ; dim elem . set attribute ( str , dim . get short name ( ) ) ; dim elem . set attribute ( str , integer . to string ( dim . get length ( ) ) ) ; if ( dim . is unlimited ( ) ) dim elem . set attribute ( str , str ) ; return dim elem ; }	Only for shared dimensions.
public ct make coordinate transform ( attribute container ctv , string units ) { int [ ] area = get int array ( ctv , idas . attr areadir ) ; int [ ] nav = get int array ( ctv , idas . attr navblock ) ; int [ ] aux = null ; if ( ctv . find attribute ignore case ( idas . attr auxblock ) != null ) { aux = get int array ( ctv , idas . attr auxblock ) ; }	Make the coordinate transform.
private int [ ] get int array ( attribute container ctv , string att name ) { attribute att = ctv . find attribute ( att name ) ; if ( att == null ) { throw new illegal argument exception ( str + ctv . get name ( ) + str + att name + str ) ; } array arr = att . get values ( ) ; return ( int [ ] ) arr . get1 d ( int . class ) ; }	get the int array from the variable attribute.
private static base unit bu ( final string name , final string symbol , final base quantity quantity ) throws name exception , unit exists exception { return base unit . get or create ( unit name . new unit name ( name , null , symbol ) , quantity ) ; }	Factory method for constructing a base unit.
private static unit du ( final string name , final string symbol , final unit definition ) throws name exception { return definition . clone ( unit name . new unit name ( name , null , symbol ) ) ; }	Factory method for constructing a derived unit.
private static db base unit db ( ) throws name exception , unit exists exception , no such unit exception { final db db = new db ( num , num ) ; db . add unit ( ampere ) ; db . add unit ( candela ) ; db . add unit ( kelvin ) ; db . add unit ( kilogram ) ; db . add unit ( meter ) ; db . add unit ( mole ) ; db . add unit ( second ) ; db . add unit ( radian ) ; db . add unit ( steradian ) ; db . add alias ( str , str ) ; return db ; }	Returns the base unit database of the SI.
public static synchronized si instance ( ) throws unit system exception { if ( si == null ) { try { si = new si ( ) ; } catch ( final unit exception e ) { throw new unit system exception ( str , e ) ; } } return si ; }	Returns an instance of the SI system of units.
int find coord element ( double [ ] target , boolean bounded ) { switch ( axis . get spacing ( ) ) { case regular interval :	Given a coordinate interval, find what grid element matches it.
private int find closest ( double target ) { double min diff = double . max value ; double use value = double . min value ; int idx found = - num ; for ( int i = num ; i < axis . get ncoords ( ) ; i ++ ) { double coord = axis . get coord midpoint ( i ) ; double diff = math . abs ( coord - target ) ; if ( diff < min diff || ( diff == min diff && coord > use value ) ) { min diff = diff ; idx found = i ; use value = coord ; } } return idx found ; }	if its a tie, use the larger one.
private optional < coverage coord axis builder > subset values ( double min value , double max value , int stride ) { if ( axis . get spacing ( ) == coverage coord axis . spacing . discontiguous interval ) return subset values discontinuous ( min value , max value , stride ) ; double lower = axis . is ascending ( ) ? math . min ( min value , max value ) : math . max ( min value , max value ) ; double upper = axis . is ascending ( ) ? math . max ( min value , max value ) : math . min ( min value , max value ) ; int min index = find coord element ( lower , bool ) ; int max index = find coord element ( upper , bool ) ; if ( min index >= axis . get ncoords ( ) ) return optional . empty ( string . format ( str , lower , axis . get end value ( ) ) ) ; if ( max index < num ) return optional . empty ( string . format ( str , upper , axis . get start value ( ) ) ) ; if ( min index < num ) min index = num ; if ( max index >= axis . get ncoords ( ) ) max index = axis . get ncoords ( ) - num ; int count = max index - min index + num ; if ( count <= num ) throw new illegal argument exception ( str ) ; try { return optional . of ( subset by index ( new range ( min index , max index , stride ) ) ) ; } catch ( invalid range exception e ) { return optional . empty ( e . get message ( ) ) ; } }	look must handle discon interval different.
@ nonnull public data factory . result open feature dataset ( dataset dataset , ucar . nc2 . util . cancel task task ) throws io { return open feature dataset ( null , dataset , task , new result ( ) ) ; }	Open a FeatureDataset from an Dataset object, deciding on which Access to use.
public data factory . result open feature dataset ( access access , ucar . nc2 . util . cancel task task ) throws io { dataset ds = access . get dataset ( ) ; data factory . result result = new result ( ) ; if ( ds . get feature type ( ) == null ) { result . err log . format ( str ) ; result . fatal error = bool ; return result ; } return open feature dataset ( ds . get feature type ( ) , access , task , result ) ; }	Open a FeatureDataset from an Access object.
public static void annotate ( dataset ds , netcdf dataset nc dataset ) { nc dataset . set title ( ds . get name ( ) ) ; nc dataset . set id ( ds . get id ( ) ) ;	Add information from the Dataset to the NetcdfDataset.
public static float [ ] read data ( random access file raf , long start pos ) throws io { raf . seek ( start pos ) ; grib1 record gr = new grib1 record ( raf ) ; return gr . read data ( raf ) ; }	Read data array by first reading in GribRecord.All sections are read in, so scanMode is from the datafile, not the index.
public string assemble ( enum set < parts > parts ) { string builder uri = new string builder ( ) ;	Reassemble the url using the specified parts.
static public string canonical ( string s ) { if ( s != null ) { s = s . trim ( ) ; if ( s . length ( ) == num ) s = null ; } return s ; }	Canonicalize a part of a URL.
private string normalize ( string units ) { switch ( units ) { case str : units = str ; break ; case str : units = str ; break ; case str : units = str ; break ; case str : units = str ; break ; default : units = string util2 . substitute ( units , str , str ) ; units = string util2 . remove ( units , str ) ; units = string util2 . remove ( units , str ) ; break ; } return units ; }	pretty much WRF specific.
public void finish ( ) { if ( init ) return ; init = bool ; if ( xlink href == null ) return ; xlink href = xlink href . trim ( ) ; try { this . xlink uri = dataset . get parent catalog ( ) . resolve uri ( xlink href ) ; } catch ( java . net . uri e ) { log . append ( str ) . append ( xlink href ) . append ( str ) ; return ; }	Finish getting the metadata if necessary.If this is an XLink, this will trigger a read of the href the first time called.
public synchronized object get ( object key ) { int index = keys . index of ( key ) ; if ( index != - num ) return elements . element at ( index ) ; else return null ; }	Returns the value to which the key is mapped in this table.
public synchronized object put ( object key , object value ) throws null pointer exception { if ( key == null || value == null ) throw new null pointer exception ( ) ; int index = keys . index of ( key ) ; if ( index != - num ) { object prev = elements . element at ( index ) ; elements . set element at ( value , index ) ; return prev ; } else { keys . add element ( key ) ; elements . add element ( value ) ; return null ; } }	Maps the specified key to the specified value in this table.
public date get date ( ) { calendar calendar = calendar . get instance ( time zone . get time zone ( str ) ) ; calendar . set ( calendar . year , year ) ; calendar . set ( calendar . month , month - num ) ;	Return this as a java Date object.
void print xml ( dap node node , ce ce , int flags ) throws io { if ( ( flags & perline ) != num ) printer . indent ( num ) ;	Print info from the node that needs to be in the form of xml attributes.
protected void print xml ( string name , string value , int flags ) throws dap exception { if ( name == null ) return ; if ( ( flags & nonnil ) == num && ( value == null || value . length ( ) == num ) ) return ; if ( ( flags & perline ) != num ) { printer . eol ( ) ; printer . margin ( ) ; } printer . print ( str + name + str ) ; printer . print ( str ) ; if ( value != null ) {	PrintXMLAttributes helper function.
static boolean is special ( dap attribute attr ) { if ( attr . get parent ( ) . get sort ( ) == dap sort . dataset ) { for ( string s : groupspecial ) { if ( s . equals ( attr . get short name ( ) ) ) return bool ; } } else if ( attr . get parent ( ) . get sort ( ) == dap sort . variable ) { for ( string s : varspecial ) { if ( s . equals ( attr . get short name ( ) ) ) return bool ; } } return bool ; }	Special here is not the same as reserved.
void print dimrefs ( dap variable var ) throws dap exception { if ( var . get rank ( ) == num ) return ; list < dap dimension > dimset = this . ce . get constrained dimensions ( var ) ; if ( dimset == null ) throw new dap exception ( str + var ) ; assert var . get rank ( ) == dimset . size ( ) ; for ( int i = num ; i < var . get rank ( ) ; i ++ ) { dap dimension dim = dimset . get ( i ) ; printer . margin print ( str ) ; if ( dim . is shared ( ) ) { string fqn = dim . get fqn ( ) ; assert ( fqn != null ) : str ; fqn = fqn xml ( fqn ) ; print xml ( str , fqn , xmlescaped ) ; } else { long size = dim . get size ( ) ;	Print the dimrefs for a variable's dimensions.If the variable has a non-whole projection, then use sizeelse use the dimension name.
public static boolean is valid file ( random access file raf ) { string file name = raf . get location ( ) ; area file af = null ; try { af = new area file ( file name ) ;	Check to see if this is a valid AREA file.
private void set area directory attributes ( variable v ) { if ( ( dir block == null ) || ( ad == null ) ) { return ; } for ( int i = num ; i < num ; i ++ ) { if ( i == num ) { continue ; } v . add attribute ( new attribute ( get ad ( i ) , dir block [ i ] ) ) ; } }	Set the area directory attributes on the variable.
private void set nav block attributes ( variable v ) { if ( ( nav block == null ) || ( ad == null ) ) { return ; } v . add attribute ( new attribute ( str , idas . int bits to string ( nav block [ num ] ) ) ) ; }	Set the navigation block attributes on the variable.
private int get cal type ( string cal name ) { int cal type out = calibrator . cal none ; if ( cal name . trim ( ) . equals ( str ) ) { cal type out = calibrator . cal alb ; } else if ( cal name . trim ( ) . equals ( str ) ) { cal type out = calibrator . cal brit ; } else if ( cal name . trim ( ) . equals ( str ) ) { cal type out = calibrator . cal rad ; } else if ( cal name . trim ( ) . equals ( str ) ) { cal type out = calibrator . cal raw ; } else if ( cal name . trim ( ) . equals ( str ) ) { cal type out = calibrator . cal temp ; } return cal type out ; }	Get the calibration type from the name.
private void set cal type attributes ( variable image , int cal type ) { string long name = str ;	Set the long name and units for the calibration type.
static public void find coords ( table config nt , netcdf dataset ds , predicate p ) { nt . lat = find coord short name by type ( ds , axis type . lat , p ) ; nt . lon = find coord short name by type ( ds , axis type . lon , p ) ; nt . time = find coord short name by type ( ds , axis type . time , p ) ; nt . elev = find coord short name by type ( ds , axis type . height , p ) ; if ( nt . elev == null ) nt . elev = find coord short name by type ( ds , axis type . pressure , p ) ; }	search for Axis by Type, assign to TableConfig if found.search for Lat, Lon, Time, Height.
static public string find coord name by type ( netcdf dataset ds , axis type atype ) { coordinate axis coord axis = find coord by type ( ds , atype ) ; return coord axis == null ? null : coord axis . get full name ( ) ; }	search for Axis by Type.
static public coordinate axis find coord by type ( netcdf dataset ds , axis type atype ) { return find coord by type ( ds , atype , null ) ; }	Search for Axis by Type.
static public coordinate axis find coord by type ( netcdf dataset ds , axis type atype , predicate p ) {	search for Axis by Type and test against a predicate.
static public dimension find dimension by type ( netcdf dataset ds , axis type atype ) { coordinate axis axis = find coord by type ( ds , atype ) ; if ( axis == null ) return null ; if ( axis . is scalar ( ) ) return null ; return axis . get dimension ( num ) ; }	search for Dimension used by axis of given by Type.
static private coordinate system find best coordinate system ( netcdf dataset ds ) {	Find the CoordinateSystem with the most number of CoordinateAxes.
private d find dependent ( coverage coord axis independent axis , axis type axis type ) { for ( coverage coord axis axis : axes ) { if ( axis . get dependence type ( ) == coverage coord axis . dependence type . dependent ) { for ( string axis name : axis . depends on ) { if ( axis name . equals ignore case ( independent axis . get name ( ) ) && axis . get axis type ( ) == axis type ) return ( d ) axis ; } } } return null ; }	find the dependent axis that depend on independentAxis.
public base type get variable ( int row , string name ) throws no such variable exception { int dot index = name . index of ( str ) ; if ( dot index != - num ) {	Returns the named variable in the given row of the sequence.
private byte read marker ( data input stream source ) throws io { byte marker = source . read byte ( ) ;	Reads a marker byte from the input stream.
protected void write marker ( data output stream sink , byte marker ) throws io {	Writes a marker byte to the output stream.
public static void main ( string [ ] args ) { time series dataset1 = create dataset ( str , num , new minute ( ) , num ) ; multiple axis chart demo = new multiple axis chart ( str , str , str , dataset1 ) ; time series dataset2 = create dataset ( str , num , new minute ( ) , num ) ; demo . add series ( str , dataset2 ) ; time series dataset3 = create dataset ( str , num , new minute ( ) , num ) ; demo . add series ( str , dataset3 ) ; time series dataset4 = create dataset ( str , num , new minute ( ) , num ) ; demo . add series ( str , dataset4 ) ; demo . finish ( new java . awt . dimension ( num , num ) ) ; j frame = new j ( str ) ; frame . get content pane ( ) . add ( demo , border layout . center ) ; frame . set size ( num , num ) ; frame . set visible ( bool ) ; frame . set default close operation ( j . exit on close ) ; }	Starting point for the demonstration application.
public string [ ] get java array string ( structure members . member m ) { if ( m . get data type ( ) == data type . string ) { array data = get array ( m ) ; int n = m . get size ( ) ; string [ ] result = new string [ n ] ; for ( int i = num ; i < result . length ; i ++ ) result [ i ] = ( string ) data . get object ( i ) ; return result ; } else if ( m . get data type ( ) == data type . char ) { array char data = ( array char ) get array ( m ) ; array char . string iterator iter = data . get string iterator ( ) ; string [ ] result = new string [ iter . get num elems ( ) ] ; int count = num ; while ( iter . has next ( ) ) result [ count ++ ] = iter . next ( ) ; return result ; } throw new illegal argument exception ( str + m . get data type ( ) ) ; }	LOOK can we optimize ??.
public parm [ ] get param list ( ) { int param count = num ; for ( int i = num ; i < n sensors ; i ++ ) param count += my rad [ i ] . get n ( ) ; parm [ ] list = new parm [ param count ] ; int next = num ; for ( int i = num ; i < n sensors ; i ++ ) { int n params = my rad [ i ] . get n ( ) ; system . arraycopy ( my rad [ i ] . get param list ( ) , num , list , next , n params ) ; next += n params ; } return list ; }	Get the array of available parameter names for this volume.
public void set stations ( java . util . list stns ) { stn render . set stations ( stns ) ; redraw ( bool ) ; }	Set the list of Stations.
public void set selected station ( string id ) { stn render . set selected station ( id ) ; selected station = stn render . get selected station ( ) ; assert selected station != null ; np . set lat lon center map area ( selected station . get latitude ( ) , selected station . get longitude ( ) ) ; redraw ( ) ; }	Looks for the station with given id.
protected void redraw ( ) { long tstart = system . current time millis ( ) ; java . awt . d g np = np . get buffered image graphics ( ) ; if ( g np == null )	Redraw the graphics on the screen.
private void read object ( object input stream s ) throws io , class not found exception { double x = s . read double ( ) ; double y = s . read double ( ) ; double w = s . read double ( ) ; double h = s . read double ( ) ; set rect ( x , y , w , h ) ; }	Read the object from the input stream of the serialized object.
private void write object ( object output stream s ) throws io { s . write double ( get x ( ) ) ; s . write double ( get y ( ) ) ; s . write double ( get width ( ) ) ; s . write double ( get height ( ) ) ; }	Wrtie the object to the output stream.
public void add ( final db that ) throws unit exists exception { unit set . add all ( that . unit set ) ; name map . put all ( that . name map ) ; symbol map . put all ( that . symbol map ) ; }	Adds all the entries in another UnitDBImpl to this database.
public void add unit ( final unit unit ) throws unit exists exception , name exception { if ( unit . get name ( ) == null ) { throw new name exception ( str ) ; } add by name ( unit . get name ( ) , unit ) ; add by name ( unit . get plural ( ) , unit ) ; add by symbol ( unit . get symbol ( ) , unit ) ; unit set . add ( unit ) ; }	Adds a unit to the database.
public final void add symbol ( final string symbol , final string name ) throws no such unit exception , unit exists exception { add alias ( null , name , symbol , null ) ; }	Adds a symbol for a unit already in the database.
public unit get ( final string id ) { unit unit = get by symbol ( id ) ; if ( unit == null ) { unit = get by name ( id ) ; } return unit ; }	Gets a unit by either name, plural, or symbol.
private final void add by name ( final string name , final unit new unit ) throws unit exists exception { if ( name != null ) { add unique ( name map , canonicalize ( name ) , new unit ) ; } }	Adds a unit to the database by name.
private final void add by symbol ( final string symbol , final unit new unit ) throws unit exists exception { if ( symbol != null ) { add unique ( symbol map , symbol , new unit ) ; } }	Adds a unit to the database by symbol.
private static final void add unique ( final map < string , unit > map , final string key , final unit new unit ) throws unit exists exception { final unit old unit = map . put ( key , new unit ) ; if ( old unit != null && ! old unit . equals ( new unit ) ) { throw new unit exists exception ( old unit , new unit ) ; } }	Adds a unique unit to a map..
public void add to menu ( final j menu ) { final ui . look and feel info [ ] plaf info = ui . get installed look and feels ( ) ; for ( ui . look and feel info a plaf info : plaf info ) { add to menu ( a plaf info . get name ( ) , a plaf info . get class name ( ) , menu ) ; } final look and feel current = ui . get look and feel ( ) ; system . out . printf ( str , current . get name ( ) ) ; }	Add a set of MenuItems to the given JMenu, one for each possible L&F.if this platform doesnt support the L&F, disable the MenuItem.
@ nullable public static grib2 record find record by drspos ( random access file raf , long drs pos ) throws io { long pos = math . max ( num , drs pos - ( num * num ) ) ;	tricky bit of business.
public boolean read ( string dataset name , object special o ) throws no such variable exception , io {	called if its scalar.
public void serialize ( string dataset , data output stream sink , ce ce , object special o ) throws no such variable exception , da , io { if ( org == null ) { super . serialize ( dataset , sink , ce , special o ) ; return ; }	overrride for array of Structures.
@ override public projection impl construct copy ( ) { projection impl result = new vertical perspective view ( get origin lat ( ) , get origin lon ( ) , r , get height ( ) , false east , false north ) ; result . set default map area ( default map area ) ; result . set name ( name ) ; return result ; }	"map limit" circle of this radius from the origin, p 173.
public thredds data factory . result open feature dataset ( inv dataset inv dataset , ucar . nc2 . util . cancel task task ) throws io { return open feature dataset ( null , inv dataset , task , new result ( ) ) ; }	Open a FeatureDataset from an InvDataset object, deciding on which InvAccess to use.
public thredds data factory . result open feature dataset ( inv access access , ucar . nc2 . util . cancel task task ) throws io { inv dataset inv dataset = access . get dataset ( ) ; thredds data factory . result result = new result ( ) ; if ( inv dataset . get data type ( ) == null ) { result . err log . format ( str ) ; result . fatal error = bool ; return result ; } return open feature dataset ( inv dataset . get data type ( ) , access , task , result ) ; }	Open a FeatureDataset from an InvAccess object.
public netcdf dataset open dataset ( inv dataset inv dataset , boolean acquire , ucar . nc2 . util . cancel task task , formatter log ) throws io { result result = new result ( ) ; netcdf dataset ncd = open dataset ( inv dataset , acquire , task , result ) ; if ( log != null ) log . format ( str , result . err log ) ; return ( result . fatal error ) ? null : ncd ; }	Try to open as a NetcdfDataset.
public static void annotate ( inv dataset ds , netcdf dataset nc dataset ) { nc dataset . set title ( ds . get name ( ) ) ; nc dataset . set id ( ds . get id ( ) ) ;	Add information from the InvDataset to the NetcdfDataset.
void add partition ( int partno , int groupno , int varno , int ndups , int nrecords , int nmissing , grib collection mutable . variable index vi ) { if ( part list == null ) part list = new array list < > ( nparts ) ; part list . add ( new d ( partno , groupno , varno ) ) ; this . ndups += ndups ; this . nrecords += nrecords ; this . nmissing += nmissing ; }	only used by PartitionBuilder, not PartitionBuilderFromIndex.
@ nullable public grib collection mutable make grib collection ( ) { grib collection mutable result = grib cdm index . open mutable gc ( dcm . get index filename ( grib cdm index . ncx suffix ) , config , bool , bool , logger ) ; if ( result == null ) { logger . error ( str , dcm . get index filename ( grib cdm index . ncx suffix ) ) ; return null ; } last modified = result . last modified ; file size = result . file size ; if ( result . master runtime != null ) partition date = result . master runtime . get first date ( ) ; return result ; }	the children must already exist.
public static reg exp and duration time coverage enhancer get instance to match on dataset name ( string match pattern , string substitution pattern , string duration ) { return new reg exp and duration time coverage enhancer ( match pattern , substitution pattern , duration , match target . dataset name ) ; }	Factory method that returns a RegExpAndDurationTimeCoverageEnhancer instancethat will apply the match pattern to the dataset name.
public static reg exp and duration time coverage enhancer get instance to match on dataset path ( string match pattern , string substitution pattern , string duration ) { return new reg exp and duration time coverage enhancer ( match pattern , substitution pattern , duration , match target . dataset path ) ; }	Factory method that returns a RegExpAndDurationTimeCoverageEnhancer instancethat will apply the match pattern to the dataset path.
public boolean write xml ( query capability dqc , string filename ) { try { buffered output stream os = new buffered output stream ( new file output stream ( filename ) ) ; write xml ( dqc , os ) ; os . close ( ) ; } catch ( io e ) { e . print stack trace ( ) ; return bool ; } return bool ; }	Write the catalog as an XML document to the specified filename.
private ucar . ma2 . array structure read structure data ( ucar . nc2 . structure s , section section ) throws java . io . io , invalid range exception { h4header . vinfo vinfo = ( h4header . vinfo ) s . get s ( ) ; vinfo . set layout info ( ) ;	Structures must be fixed sized.
public void set picture ( url filename url , string legend param , double rotation ) { legend = legend param ; center when scaled = bool ; scl pic . set scale size ( get size ( ) ) ; scl pic . stop loading except ( filename url ) ; scl pic . load and scale picture in thread ( filename url , thread . max priority , rotation ) ; }	brings up the indicated picture on the display.
public void set buffered image ( buffered image img , string status message ) { legend = status message ; center when scaled = bool ; dimension dim = get size ( ) ; scl pic . set scale size ( dim ) ; source picture source = new source picture ( ) ; source . set source buffered image ( img , status message ) ; scl pic . set source picture ( source ) ; if ( ! scale to fit ) scl pic . set scale factor ( num ) ; scl pic . scale picture ( ) ; repaint ( ) ; }	sets the buffered image directly.
public void zoom to fit ( ) {	this method sets the desired scaled size of the ScalablePictureto the size of the JPanel and fires off a createScaledPictureInThreadrequest if the ScalablePicture has been loaded or is ready.
public void paint component ( graphics g ) { int window width = get size ( ) . width ; int window height = get size ( ) . height ; tools . log ( str ) ; if ( dragging == bool ) {	we are overriding the default paintComponent method, grabbing the Graphicshandle and doing our own drawing here.
public static int [ ] tg ftoi ( int [ ] iftime , int start ) { int [ ] intdtf = new int [ num ] ;	This subroutine converts the two integers stored in a grid fileinto three integers containing the date, time and forecast time.
public static string tg itoc ( int [ ] intdtf ) { string gdattim = str ;	This subroutine converts an integer time array containing the date,time and forecast time into a GEMPAK grid time.
public static string ti itoc ( int [ ] idtarr ) { string dattim ; string date , time ;	This subroutine converts an integer time array into a standardGEMPAK time.
public static int ti daym ( int iyear , int imon ) { int iday = num ; if ( ( imon > num ) && ( imon < num ) ) {	This subroutine returns the number of days in the given month.The year must be a full four-digit year.
public static string lv ccrd ( int ivcord ) {	This subroutine translates a numeric value for IVCORD into itscharacter value in VCOORD.
public static int [ ] swp4 ( int [ ] values , int start index , int number ) { for ( int i = start index ; i < start index + number ; i ++ ) { values [ i ] = integer . reverse bytes ( values [ i ] ) ; } return values ; }	Swap the order of the integers in place.
public static string get grid packing name ( int pktyp ) { string packing type = str ; switch ( pktyp ) { case gempak constants . mdgnon : packing type = str ; break ; case gempak constants . mdggrb : packing type = str ; break ; case gempak constants . mdgnmc : packing type = str ; break ; case gempak constants . mdgdif : packing type = str ; break ; case gempak constants . mdgdec : packing type = str ; break ; case gempak constants . mdgr : packing type = str ; break ; default : break ; } return packing type ; }	Get a name for the grid packing type.
public static string get data type ( int typrt ) { string data type = str + typrt ; switch ( typrt ) { case gempak constants . mdreal : data type = str ; break ; case gempak constants . mdintg : data type = str ; break ; case gempak constants . mdchar : data type = str ; break ; case gempak constants . mdrpck : data type = str ; break ; case gempak constants . mdgrid : data type = str ; break ; default : break ; } return data type ; }	Get a name for the data packing type.
public void read data ( input stream is , ui status ui ) throws io , eof , da {	Read the data stream from the given InputStream.
public final void externalize ( output stream os , boolean compress , boolean headers ) throws io {	Dump the dataset using externalize methods.
public static tag enum get tag ( short code ) { tag enum te = hash . get ( code ) ; if ( te == null ) te = new tag enum ( str , str , code ) ; return te ; }	Find the Tag that matches the code.
public buffered image get next image ( boolean forward ) { if ( grid != null ) { if ( forward ) { this . time ++ ; if ( this . time >= this . ntimes ) this . time = num ; } else { this . time -- ; if ( this . time < num ) this . time = this . ntimes - num ; } array data ; try { data = grid . read data slice ( this . time , num , - num , - num ) ; return image array adapter . make grayscale image ( data , grid ) ; } catch ( io e ) { e . print stack trace ( ) ; return null ; } } if ( current file == null ) return null ; if ( current dir == null ) { current dir file no = num ; current dir = current file . get parent file ( ) ; current dir file list = new array list < > ( ) ; add to list ( current dir , current dir file list ) ;	This assumes you have opened a file.
static public int size ( dap type type ) { switch ( type . get type sort ( ) ) { case char :	Conmpute the size, in databuffer,of the daptype wrt to a serialization;0 if undefined.
private static int sum array ( int [ ] arr ) { if ( arr == null ) throw new null pointer exception ( str ) ; if ( arr . length == num ) throw new illegal argument exception ( str ) ; int sum = num ; for ( int i = num ; i < arr . length ; i ++ ) { if ( arr [ i ] <= num ) { throw new illegal argument exception ( str ) ; } sum += arr [ i ] ; } return sum ; }	Calculates the sum of the values in the given array.
public void set grid ( d bbox , double width , double height ) { offset x = bbox . get x ( ) ; offset y = bbox . get y ( ) ;	Set the grid scale.
public void set overlap ( int overlap ) {	Set how much the data may overlap.
public void clear ( ) { for ( int y = num ; y < count y ; y ++ ) for ( int x = num ; x < count x ; x ++ ) grid array [ y ] [ x ] . used = bool ; }	clear all the grid cells.
public boolean mark if clear ( d rect , object o ) { double center x = rect . get x ( ) + rect . get width ( ) / num ; double center y = rect . get y ( ) + rect . get height ( ) / num ; int index x = ( int ) ( ( center x - offset x ) / grid width ) ; int index y = ( int ) ( ( center y - offset y ) / grid height ) ; if ( debug mark ) system . out . println ( str + rect + str + index x + str + index y ) ; if ( ( index x < num ) || ( index x >= count x ) || ( index y < num ) || ( index y >= count y ) )	Check if the given rect intersects an already drawn one.If not, set the corresponding cell as marked, store object, return true,meaning "ok to draw".
public object find intersection ( d rect ) { double center x = rect . get x ( ) + rect . get width ( ) / num ; double center y = rect . get y ( ) + rect . get height ( ) / num ; int index x = ( int ) ( ( center x - offset x ) / grid width ) ; int index y = ( int ) ( ( center y - offset y ) / grid height ) ;	Check if the given rect intersects an already drawn object.
public object find intersection ( d p ) { int index x = ( int ) ( ( p . get x ( ) - offset x ) / grid width ) ; int index y = ( int ) ( ( p . get y ( ) - offset y ) / grid height ) ;	Check if the given point is contained in already drawn object.
public object find closest ( d pt ) { object o = null ; int index x = ( int ) ( ( pt . get x ( ) - offset x ) / grid width ) ; int index y = ( int ) ( ( pt . get y ( ) - offset y ) / grid height ) ; if ( debug closest ) system . out . println ( str + pt + str + index x + str + index y ) ; if ( ( index x < num ) || ( index x >= count x ) || ( index y < num ) || ( index y >= count y ) )	Find the closest marked cell to the given point.
private double distance sq ( d pt , int index x , int index y ) { if ( ( index x < num ) || ( index x >= count x ) || ( index y < num ) || ( index y >= count y ) )	if out of bbox or cell not marked, return MAX_DOUBLE.
public static synchronized base unit get or create ( final unit name id , final base quantity base quantity ) throws name exception , unit exists exception { base unit base unit ; final base unit name unit = name map . get ( id ) ; final base unit quantity unit = quantity map . get ( base quantity ) ; if ( name unit != null || quantity unit != null ) { base unit = name unit != null ? name unit : quantity unit ; if ( ( name unit != null && ! base quantity . equals ( name unit . get base quantity ( ) ) ) || ( quantity unit != null && ! id . equals ( quantity unit . get unit name ( ) ) ) ) { throw new unit exists exception ( str + base unit + str ) ; } } else { base unit = new base unit ( id , base quantity ) ; quantity map . put ( base quantity , base unit ) ; name map . put ( id , base unit ) ; } return base unit ; }	Factory method for creating a new BaseUnit or obtaining apreviously-created one.
static private service type search fragment ( string fragment ) { if ( fragment . length ( ) == num ) return null ; map < string , string > map = parse fragment ( fragment ) ; if ( map == null ) return null ; string protocol = map . get ( str ) ; if ( protocol == null ) { for ( string p : fragprotocols ) { if ( map . get ( p ) != null ) { protocol = p ; break ; } } } if ( protocol != null ) { if ( protocol . equals ignore case ( str ) || protocol . equals ignore case ( str ) ) return service type . opendap ; if ( protocol . equals ignore case ( str ) ) return service type . da ; if ( protocol . equals ignore case ( str ) ) return service type . cdm remote ; if ( protocol . equals ignore case ( str ) ) return service type . thredds ; if ( protocol . equals ignore case ( str ) ) return service type . ncml ; } return null ; }	Given a location, find markers indicated which protocol to useLOOK what use case is this handling ?.
static private service type search path ( string url ) { if ( bool ) {	Given a url, search the path to look for protocol indicators.
static private service type decode path extension ( string path ) {	Check path extension; assumes no query or fragment.
static private service type check if dods ( string location ) throws io { int len = location . length ( ) ;	not sure what other opendap servers do, so fall back on check for dds.
public long send data2 ( variable v , section section , output stream out , nc stream compression compress ) throws io , invalid range exception { if ( show ) system . out . printf ( str , v . get full name ( ) , section ) ; boolean is vlen = v . is variable length ( ) ;	LOOK compression not used.
static public string fqn suffix ( string fqn ) { int structindex = fqn . last index of ( str ) ; int groupindex = fqn . last index of ( str ) ; if ( structindex >= num ) return fqn . substring ( structindex + num , fqn . length ( ) ) ; else return fqn . substring ( groupindex + num , fqn . length ( ) ) ; }	return last name part of an fqn; result will be escaped.
static public string fqn prefix ( string fqn ) { int structindex = fqn . last index of ( str ) ; int groupindex = fqn . last index of ( str ) ; if ( structindex >= num ) return fqn . substring ( num , structindex ) ; else return fqn . substring ( num , groupindex ) ; }	return prefix name part of an fqn; result will be escaped.
static public string locate file ( string filename , string abspath , boolean wantdir ) { deque < string > q = new array deque < string > ( ) ;	Walk the specified subtree dir tree to try to locate file|dir named filename.Use breadth first search.
static public string locate relative ( string relpath , string abspath , boolean wantdir ) {	Walk the specified dir tree to locate file specified by relative path.Use breadth first search.
static public byte [ ] extract ( byte buffer buf ) { int len = buf . limit ( ) ; byte [ ] bytes = new byte [ len ] ; buf . rewind ( ) ; buf . get ( bytes ) ; return bytes ; }	Properly extract the byte contents of a ByteBuffer.
static public list < dap variable > get structure path ( dap variable var ) { list < dap node > path = var . get path ( ) ; list < dap variable > structpath = new array list < dap variable > ( ) ; for ( int i = num ; i < path . size ( ) ; i ++ ) { dap node node = path . get ( i ) ; switch ( node . get sort ( ) ) { case dataset : case group : break ; case variable : structpath . add ( ( dap variable ) node ) ; break ; default : assert bool : str ; } } return structpath ; }	Given a dap variable, get the path from thetop-level variable to and including the given variablesuch that all but the last element is a structure.
static public string nullify ( string path ) { return ( path != null && path . length ( ) == num ? null : path ) ; }	Convert "" paths to null.
static public string join ( string [ ] array , string sep , int from , int upto ) { if ( sep == null ) sep = str ; if ( from < num || upto > array . length ) throw new index out of bounds exception ( ) ; if ( upto <= from ) return str ; string builder result = new string builder ( ) ; boolean first = bool ; for ( int i = from ; i < upto ; i ++ , first = bool ) { if ( ! first ) result . append ( sep ) ; result . append ( array [ i ] ) ; } return result . to string ( ) ; }	Given an Array of Strings and a separator and a count,concat the first count elements of an array with separatorbetween them.
static public boolean has drive letter ( string path ) { boolean hasdr = bool ; if ( path != null && path . length ( ) >= num ) { hasdr = ( driveletters . index of ( path . char at ( num ) ) >= num && path . char at ( num ) == str ) ; } return hasdr ; }	return true if this path appears to start with a windows drive letter.
static public list < string > get protocols ( string url , int [ ] breakpoint ) {	Return the set of leading protocols for a url; may be more than one.
static public list < slice > index to slices ( index indices , dap variable template ) throws dap4 . core . util . dap exception { list < dap dimension > dims = template . get dimensions ( ) ; list < slice > slices = index to slices ( indices , dims ) ; return slices ; }	Provide a helper function to convert an Index object toa slice list.
static public list < slice > offset to slices ( long offset , dap variable template ) throws dap exception { list < dap dimension > dims = template . get dimensions ( ) ; long [ ] dimsizes = dap util . get dim sizes ( dims ) ; return index to slices ( offset to index ( offset , dimsizes ) , template ) ; }	Provide a helper function to convert an offset toa slice list.
static public boolean is contiguous ( list < slice > slices ) { for ( slice sl : slices ) { if ( sl . get stride ( ) != num ) return bool ; } return bool ; }	Test if a set of slices represent a contiguous regionThis is equivalent to saying all strides are one.
static public boolean is single point ( list < slice > slices ) { for ( slice sl : slices ) { if ( sl . get count ( ) != num ) return bool ; } return bool ; }	Test if a set of slices represent a single position.
static public index slices to index ( list < slice > slices ) throws dap exception { long [ ] positions = new long [ slices . size ( ) ] ; long [ ] dimsizes = new long [ slices . size ( ) ] ; for ( int i = num ; i < positions . length ; i ++ ) { slice s = slices . get ( i ) ; if ( s . get count ( ) != num ) throw new dap exception ( str ) ; positions [ i ] = s . get first ( ) ; dimsizes [ i ] = s . get max ( ) ; } return new index ( positions , dimsizes ) ; }	If a set of slices refers to a single position,then return the corresponding Index.
public data result read data ( input stream is , netcdf file ncfile , string location ) throws io { byte [ ] b = new byte [ num ] ; int bytes read = nc stream . read fully ( is , b ) ; if ( bytes read < b . length ) throw new eof ( location ) ; if ( nc stream . test ( b , nc stream . magic data ) ) return read data1 ( is , ncfile ) ; if ( nc stream . test ( b , nc stream . magic dat ) ) return read data2 ( is ) ; throw new io ( str + location ) ; }	Read the result of a data request.
public void set station info ( string stn id v , string stn desc v , string stn index v , station helper station helper ) { this . stn id v = stn id v ; this . stn desc v = stn desc v ; this . stn index v = stn index v ; this . station helper = station helper ; if ( stn id v != null ) { variable station var = ncfile . find variable ( stn id v ) ; station id type = station var . get data type ( ) ; } }	Set extra information used by station obs datasets.Use stnIdVName or stnIndexVName.
public feature collection config read config from catalog ( string catalog and path ) { string cat filename ; string fc name = null ; int pos = catalog and path . index of ( str ) ; if ( pos > num ) { cat filename = catalog and path . substring ( num , pos ) ; fc name = catalog and path . substring ( pos + num ) ; } else { cat filename = catalog and path ; } file cat = new file ( cat filename ) ; org . jdom2 . document doc ; try { sax builder = new sax ( ) ; doc = builder . build ( cat ) ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } try { list < element > fc elems = new array list < > ( ) ; find feature collection ( doc . get root element ( ) , fc name , fc elems ) ; if ( fc elems . size ( ) > num ) return read config ( fc elems . get ( num ) ) ; } catch ( illegal state exception e ) { e . print stack trace ( ) ; } return null ; }	Read a catalog and extract a FeatureCollectionConfig from it.
void update groups ( list < dap group > groups ) {	We will need to re-order the groups.
public dap variable find variable ( string name ) { dap node var = find in group ( name , dap sort . variable ) ; return ( dap variable ) var ; }	Locate a variable in this group.
protected axis type get axis type ( netcdf dataset nc dataset , variable enhanced v ) { string unit = v . get units string ( ) ; if ( unit == null ) return null ; unit = unit . trim ( ) ; if ( unit . equals ignore case ( str ) || unit . equals ignore case ( str ) || unit . equals ignore case ( str ) || unit . equals ignore case ( str ) || unit . equals ignore case ( str ) || unit . equals ignore case ( str ) ) return axis type . lon ; if ( unit . equals ignore case ( str ) || unit . equals ignore case ( str ) || unit . equals ignore case ( str ) || unit . equals ignore case ( str ) || unit . equals ignore case ( str ) || unit . equals ignore case ( str ) ) return axis type . lat ; if ( simple unit . is date unit ( unit ) ) { return axis type . time ; }	we assume that coordinate axes get identified by being coordinate variables.
@ nullable public static grib stat type get stat type ( int time range indicator ) { switch ( time range indicator ) { case num : case num : case num : case num : case num : case num : case num : case num : case num : return grib stat type . average ; case num : case num : case num : case num : return grib stat type . accumulation ; case num : return grib stat type . difference from end ; case num : return grib stat type . covariance ; case num : case num : return grib stat type . standard deviation ; default : return null ; } }	The time unit statistical type, derived from code table 5).
private optional < coverage coord axis > subset lon ( lat lon rect llbb , int stride ) throws invalid range exception { double want min = lat lon point impl . lon normal from ( llbb . get lon min ( ) , lon axis . get start value ( ) ) ; double want max = lat lon point impl . lon normal from ( llbb . get lon max ( ) , lon axis . get start value ( ) ) ; double start = lon axis . get start value ( ) ; double end = lon axis . get end value ( ) ;	here's where to deal with crossing seam.
public list < range iterator > get ranges ( ) { list < range iterator > result = new array list < > ( ) ; result . add ( get y ( ) . get range ( ) ) ; range iterator lon range = get x ( ) . get range iterator ( ) ; if ( lon range == null ) lon range = get x ( ) . get range ( ) ;	return y, x range.
static synchronized protected void set defaults ( map < prop , object > props ) { if ( bool ) {	Provide defaults for a settings map.
public string get session id ( ) { string sid = null ; string jsid = null ; list < cookie > cookies = this . sessioncontext . get cookie store ( ) . get cookies ( ) ; for ( cookie cookie : cookies ) { if ( cookie . get name ( ) . equals ignore case ( str ) ) sid = cookie . get value ( ) ; if ( cookie . get name ( ) . equals ignore case ( str ) ) jsid = cookie . get value ( ) ; } return ( sid == null ? jsid : sid ) ; }	Extract the sessionid cookie value.
public http set max redirects ( int n ) { if ( n < num )	Set the max number of redirects to follow.
public http set use sessions ( boolean tf ) { localsettings . put ( prop . usesessions , ( boolean ) tf ) ; this . cachevalid = bool ; return this ; }	Should we use sessionid's?.
synchronized public void close ( ) { if ( this . closed ) return ;	Close the session. This implies closingany open methods.
synchronized protected void set authentication and proxy ( http client builder cb ) throws http {	Handle authentication and Proxy'ing.
static protected synchronized void track ( http session ) { if ( ! testing ) throw new unsupported operation exception ( ) ; if ( session list == null ) session list = new concurrent skip list set < http > ( ) ; session list . add ( session ) ; }	If we are testing, then track the sessions for kill.
@ deprecated static public void set global credentials provider ( auth scope scope , credentials provider provider ) throws http { set global credentials provider ( provider , scope ) ; }	Deprecated, but here for back compatibility.
void validate ( string url string ) { if ( url string == null ) return ; uri uri ; try { uri = new uri ( url string ) ; } catch ( uri e ) { javax . swing . j . show message dialog ( null , str + url string + str + e . get message ( ) + str ) ; return ; } string contents = get text ( ) ;	private DqcFactory dqcFactory = null;.
static public index factory ( int [ ] shape ) { int rank = shape . length ; switch ( rank ) { case num : return new d ( ) ; case num : return new d ( shape ) ; case num : return new d ( shape ) ; case num : return new d ( shape ) ; case num : return new d ( shape ) ; case num : return new d ( shape ) ; case num : return new d ( shape ) ; case num : return new d ( shape ) ; default : return new index ( shape ) ; } }	Generate a subclass of Index optimized for this array's rank.
static private long compute strides ( int [ ] shape , int [ ] stride ) { long product = num ; for ( int ii = shape . length - num ; ii >= num ; ii -- ) { final int this dim = shape [ ii ] ; if ( this dim < num ) continue ;	Compute standard strides based on array's shape.Ignore vlen.
index section ( list < range > ranges ) throws invalid range exception {	create a new Index based on a subsection of this one, with rank reduction ifdimension length == 1.
index reduce ( ) { index c = this ; for ( int ii = num ; ii < rank ; ii ++ ) if ( shape [ ii ] == num ) {	Create a new Index based on current one byeliminating any dimensions with length one.
index reduce ( int dim ) { if ( ( dim < num ) || ( dim >= rank ) ) throw new illegal argument exception ( str + dim ) ; if ( shape [ dim ] != num ) throw new illegal argument exception ( str + dim + str ) ; index newindex = index . factory ( rank - num ) ; newindex . offset = offset ; int count = num ; for ( int ii = num ; ii < rank ; ii ++ ) { if ( ii != dim ) { newindex . shape [ count ] = shape [ ii ] ; newindex . stride [ count ] = stride [ ii ] ;	Create a new Index based on current one byeliminating the specified dimension;.
index transpose ( int index1 , int index2 ) { if ( ( index1 < num ) || ( index1 >= rank ) ) throw new illegal argument exception ( ) ; if ( ( index2 < num ) || ( index2 >= rank ) ) throw new illegal argument exception ( ) ; index new index = ( index ) this . clone ( ) ; new index . stride [ index1 ] = stride [ index2 ] ; new index . stride [ index2 ] = stride [ index1 ] ; new index . shape [ index1 ] = shape [ index2 ] ; new index . shape [ index2 ] = shape [ index1 ] ; new index . fast iterator = bool ; new index . precalc ( ) ;	create a new Index based on current one, excepttranspose two of the indices.
index permute ( int [ ] dims ) { if ( dims . length != shape . length ) throw new illegal argument exception ( ) ; for ( int dim : dims ) if ( ( dim < num ) || ( dim >= rank ) ) throw new illegal argument exception ( ) ; boolean is permuted = bool ; index new index = ( index ) this . clone ( ) ; for ( int i = num ; i < dims . length ; i ++ ) { new index . stride [ i ] = stride [ dims [ i ] ] ; new index . shape [ i ] = shape [ dims [ i ] ] ;	create a new Index based on a permutation of the current indices; vlen fails.
index iterator get index iterator ( array maa ) { if ( fast iterator ) return new iterator fast ( size , maa ) ; else return new iterator impl ( maa ) ; }	Get an index iterator for traversing the array in canonical order.
public int current element ( ) { int value = offset ;	Get the current element's index into the 1D backing array.VLEN stops processing.
public index set ( int [ ] index ) { if ( index . length != rank ) throw new array index out of bounds exception ( ) ; if ( rank == num ) return this ; int prefixrank = ( hasvlen ? rank : rank - num ) ; system . arraycopy ( index , num , current , num , prefixrank ) ; if ( hasvlen ) current [ prefixrank ] = - num ; return this ; }	Set the current element's index.
public void set dim ( int dim , int value ) { if ( value < num || value >= shape [ dim ] )	set current element at dimension dim to v.
public index set ( int v0 , int v1 , int v2 ) { set dim ( num , v0 ) ; set dim ( num , v1 ) ; set dim ( num , v2 ) ; return this ; }	set current element at dimension 0,1,2 to v0,v1,v2.
public string get time interval name ( ) {	Check if we all time intervals have the same length.
@ override public calendar date range make calendar date range ( ucar . nc2 . time . calendar cal ) { calendar date unit cdu = calendar date unit . of ( cal , time unit . get field ( ) , ref date ) ; calendar date start = cdu . make calendar date ( time unit . get value ( ) * time intervals . get ( num ) . get bounds2 ( ) ) ; calendar date end = cdu . make calendar date ( time unit . get value ( ) * time intervals . get ( get size ( ) - num ) . get bounds2 ( ) ) ; return calendar date range . of ( start , end ) ; }	Make calendar date range, using the first and last ending bounds.
protected list < string > make date list ( boolean unique ) { key date = date time keys . get ( num ) ; key time = date time keys . get ( num ) ; list < int [ ] > to check ; if ( date . type . equals ( row ) ) { to check = headers . row headers ; } else { to check = headers . col headers ; } list < string > file dates = new array list < > ( ) ; for ( int [ ] header : to check ) { if ( header [ num ] != imissd ) {	Get the list of dates.
private list < gempak parameter > make params ( dm part ) { list < gempak parameter > gemparms = new array list < > ( part . kparms ) ; for ( dm param : part . params ) { string name = param . kprmnm ; gempak parameter parm = gempak parameters . get parameter ( name ) ; if ( parm == null ) {	Make GempakParameters from the list of.
private list < gempak station > get station list ( ) { key slat = find key ( gempak station . slat ) ; if ( slat == null ) { return null ; } list < int [ ] > to check ; if ( slat . type . equals ( row ) ) { to check = headers . row headers ; } else { to check = headers . col headers ; } list < gempak station > file stations = new array list < > ( ) ; int i = num ; for ( int [ ] header : to check ) { if ( header [ num ] != imissd ) { gempak station station = make station ( header ) ; if ( station != null ) { station . set index ( i + num ) ; file stations . add ( station ) ; } } i ++ ; } return file stations ; }	Get the station list.
public list < string > get station key names ( ) { list < string > keys = new array list < > ( ) ; if ( ( station keys != null ) && ! station keys . is empty ( ) ) { for ( key key : station keys ) { keys . add ( key . name ) ; } } return keys ; }	Get the station key names.
public list < date > get dates ( ) { if ( ( dates == null || dates . is empty ( ) ) && ! date list . is empty ( ) ) { dates = new array list < > ( date list . size ( ) ) ; date fmt . set time zone ( time zone . get time zone ( str ) ) ; for ( string date string : date list ) { date d = date fmt . parse ( date string , new parse position ( num ) ) ;	Get the list of dates in this file.
public int find station index ( string id ) { for ( gempak station station : get stations ( ) ) { if ( station . get stid ( ) . equals ( id ) ) { return station . get index ( ) ; } } return - num ; }	Find the station index for the specified station id.
public string get file type ( ) { string type = str ; switch ( dm label . kftype ) { case mfsn : type = str ; break ; case mfsf : type = str ; break ; default : } if ( ! sub type . equals ( str ) ) { type = type + str + sub type + str ; } return type ; }	Get the type for this file.
public void indent ( int n ) { depth += n ; if ( depth < num ) depth = num ; else if ( depth > maxdepth ) depth = maxdepth ; }	Set depth += n.
public void set indent ( int n ) { depth = n ; if ( depth < num ) depth = num ; else if ( depth > maxdepth ) depth = maxdepth ; }	Set depth = n.
public static grib index read or create index from single file ( boolean is grib1 , m mfile , collection update type force , org . slf4j . logger logger ) throws io { grib index index = is grib1 ? new grib1 index ( ) : new grib2 index ( ) ; if ( ! index . read index ( mfile . get path ( ) , mfile . get last modified ( ) , force ) ) {	Create a gbx9 index from a single grib1 or grib2 file.Use the existing index if it already exists.
public void add directory scan ( string dir name , string suffix , string regexp pattern string , string subdirs s , string older s , object aux info ) { m filters = new m ( ) ; if ( null != regexp pattern string ) filters . add include filter ( new reg exp match on name ( regexp pattern string ) ) ; else if ( suffix != null ) filters . add include filter ( new wildcard match on path ( str + suffix + str ) ) ; if ( older s != null ) { try { time duration tu = new time duration ( older s ) ; filters . add and filter ( new last modified limit ( ( long ) ( num * tu . get value in seconds ( ) ) ) ) ; } catch ( exception e ) { logger . error ( collection name + str , older s ) ; } } boolean want subdirs = bool ; if ( ( subdirs s != null ) && subdirs s . equals ignore case ( str ) ) want subdirs = bool ; collection config mc = new collection config ( dir name , dir name , want subdirs , filters , aux info ) ;	Add a directory scan to the collection.
@ override public boolean is scan needed ( ) {	Compute if synchronous scan is needed.True if recheck is true and enough time has elapsed.
private boolean scan first time ( ) throws io { map < string , m > new map = new hash map < > ( ) ; if ( ! has scans ( ) ) { map = new map ; return bool ; } really scan ( new map ) ;	only called from synch methods.
public static void set debug flags ( ucar . nc2 . util . debug flags debug flags ) { debug = debug flags . is set ( str ) ; debug write = debug flags . is set ( str ) ; debug chunk = debug flags . is set ( str ) ; }	Set debugging flags.
public variable add variable ( variable old var ) { list < dimension > new dims = get new dimensions ( old var ) ; variable new var ; if ( ( old var . get data type ( ) . equals ( data type . string ) ) && ( ! version . is extended model ( ) ) ) { new var = writer . add string variable ( null , old var , new dims ) ; } else { new var = writer . add variable ( null , old var . get short name ( ) , old var . get data type ( ) , new dims ) ; } var map . put ( old var , new var ) ; var list . add ( old var ) ; for ( attribute org att : old var . get attributes ( ) ) writer . add variable attribute ( new var , convert attribute ( org att ) ) ; return new var ; }	Specify which variable will get written.
public netcdf file write ( cancel task cancel ) throws io { try { if ( version . is extended model ( ) ) add group extended ( null , file in . get root group ( ) ) ; else add group classic ( ) ; if ( cancel != null && cancel . is cancel ( ) ) return null ;	Write the input file to the output file.
public static void validate ( xml object doc , boolean strict ) throws xml exception {	Validates an xml doc.
@ override public string to constraint string ( ) throws dap exception { assert this . first != undefined && this . stride != undefined && this . stop != undefined ; string builder buf = new string builder ( ) ; buf . append ( str ) ; boolean first = bool ; for ( slice sub : this . subslices ) { if ( ! first ) buf . append ( str ) ; first = bool ; if ( ( sub . stop - sub . first ) == num ) { buf . append ( str ) ; } else if ( sub . stride == num ) { if ( ( sub . stop - sub . first ) == num ) buf . append ( sub . first ) ; else buf . append ( string . format ( str , sub . first , sub . stop - num ) ) ; } else buf . append ( string . format ( str , sub . first , sub . stride , sub . stop - num ) ) ; } buf . append ( str ) ; return buf . to string ( ) ; }	Convert this multislice to a stringsuitable for use in a constraint.
public void set original variable ( ucar . nc2 . variable org var ) { if ( ! ( org var instanceof structure ) ) throw new illegal argument exception ( str + org var . get full name ( ) ) ; this . org var = ( structure ) org var ; }	Set the Structure to wrap.
@ override public array really read ( variable client , section section , cancel task cancel task ) throws io , invalid range exception { if ( section . compute size ( ) == get size ( ) ) return read ( ) ; array result ; if ( has cached data ( ) ) result = super . really read ( client , section , cancel task ) ; else if ( org var != null ) result = org var . read ( section ) ; else { throw new illegal state exception ( str ) ;	section of regular Variable.
private boolean convert needed ( structure members sm data ) { for ( variable v : get variables ( ) ) { if ( v instanceof ds ) { ds vds = ( ds ) v ; if ( vds . need convert ( ) ) return bool ; } else if ( v instanceof ds ) { ds nested = ( ds ) v ; if ( nested . convert needed ( null ) ) return bool ; }	is conversion needed?.
protected array structure convert ( array data , section section ) throws io { array structure org as = ( array structure ) data ; if ( ! convert needed ( org as . get structure members ( ) ) ) {	3) variable with cached data added to StructureDS through NcML.
private void convert member info ( structure members wrapper sm ) { for ( structure members . member m : wrapper sm . get members ( ) ) { variable v = find variable ( m . get name ( ) ) ; if ( ( v == null ) && ( org var != null ) )	the wrapper StructureMembers must be converted to correspond to the wrapper Structure.
private variable enhanced find variable from org name ( string org name ) { for ( variable v top : get variables ( ) ) { variable v = v top ; while ( v instanceof variable enhanced ) { variable enhanced ve = ( variable enhanced ) v ; if ( ( ve . get original name ( ) != null ) && ( ve . get original name ( ) . equals ( org name ) ) ) return ( variable enhanced ) v top ; v = ve . get original variable ( ) ; } } return null ; }	look for the top variable that has an orgVar with the wanted orgName.
private boolean var has data ( variable v , structure members sm ) { if ( sm . find member ( v . get short name ( ) ) != null ) return bool ; while ( v instanceof variable enhanced ) { variable enhanced ve = ( variable enhanced ) v ; if ( sm . find member ( ve . get original name ( ) ) != null ) return bool ; v = ve . get original variable ( ) ; } return bool ; }	verify that the variable has data in the data array.
public void enhance ( set < netcdf dataset . enhance > mode ) { for ( variable v : get variables ( ) ) { variable enhanced ve = ( variable enhanced ) v ; ve . enhance ( mode ) ; } }	DO NOT USE DIRECTLY.
public boolean resource control ok ( http servlet request req , http servlet response res , string req path ) { if ( null == req path ) req path = tds path utils . extract path ( req , null ) ;	Check if this is making a request for a restricted dataset, and if so, if its allowed.
private array sequence make empty sequence ( sequence seq ) { structure members members = seq . make structure members ( ) ; return new array sequence ( members , new empty structure data iterator ( ) , - num ) ; }	Create an empty ArraySequence for missing data.
private array sequence make array sequence ( sequence seq , list < gempak parameter > params , float [ ] values ) { if ( values == null ) { return make empty sequence ( seq ) ; } int num levels = values . length / params . size ( ) ; structure members members = seq . make structure members ( ) ; int offset = bb . set offsets ( members ) ; int size = offset * num levels ; byte [ ] bytes = new byte [ size ] ; byte buffer buf = byte buffer . wrap ( bytes ) ; bb abb = new bb ( members , new int [ ] { num levels } , buf , num ) ; int var = num ; for ( int i = num ; i < num levels ; i ++ ) { for ( gempak parameter param : params ) { if ( members . find member ( param . get name ( ) ) != null ) { buf . put float ( values [ var ] ) ; } var ++ ; } } return new array sequence ( members , new sequence iterator ( num levels , abb ) , num levels ) ; }	Create an ArraySequence to hold the data.
protected sequence make sequence ( structure parent , string part name , boolean include missing ) { list < gempak parameter > params = gemreader . get parameters ( part name ) ; if ( params == null ) { return null ; } sequence s var = new sequence ( ncfile , null , parent , part name ) ; s var . set dimensions ( str ) ; for ( gempak parameter param : params ) { variable v = make param variable ( param , null ) ; add vertical coord attribute ( v ) ; s var . add member variable ( v ) ; } if ( include missing ) { s var . add member variable ( make missing variable ( ) ) ; } return s var ; }	Make a Sequence for the part.
private void add vertical coord attribute ( variable v ) { gempak sounding file reader gsfr = ( gempak sounding file reader ) gemreader ; int vert type = gsfr . get vertical coordinate ( ) ; string p name = v . get full name ( ) ; if ( gemreader . get file sub type ( ) . equals ( gempak sounding file reader . merged ) ) { if ( ( vert type == gempak sounding file reader . pres coord ) && p name . equals ( str ) ) { v . add attribute ( new attribute ( coordinate . axis type , axis type . pressure . name ( ) ) ) ; } else if ( ( vert type == gempak sounding file reader . hght coord ) && ( p name . equals ( str ) || p name . equals ( str ) || p name . equals ( str ) ) ) { v . add attribute ( new attribute ( coordinate . axis type , axis type . height . name ( ) ) ) ; } } else if ( p name . equals ( str ) ) { v . add attribute ( new attribute ( coordinate . axis type , axis type . pressure . name ( ) ) ) ; } }	Add the vertical coordinate variables if necessary.
public void read xm ( string uri string , catalog set callback callback ) { inv catalog impl cat = read xml ( uri string ) ; callback . set catalog ( cat ) ; }	This allows the possibility of reading a catalog in another thread.
public inv catalog impl read xml ( string cat as string , uri base uri ) { return read xml ( new string reader ( cat as string ) , base uri ) ; }	Create an InvCatalog by reading catalog XML from a String.Failures and exceptions are handled by causing validate() tofail.
public inv catalog impl read xml ( string reader cat as string reader , uri base uri ) { xml resolver = new xml ( bool ) ; sax builder = resolver . get sax ( ) ; document in doc ; try { in doc = builder . build ( cat as string reader ) ; } catch ( exception e ) { inv catalog impl cat = new inv catalog impl ( base uri . to string ( ) , null , null ) ; cat . append error message ( str + str + e . get class ( ) . get name ( ) + str + e . get message ( ) + str + fatal messages . to string ( ) + str + err messages . to string ( ) + str + warn messages . to string ( ) + str , bool ) ; return cat ; } return read xml ( in doc , base uri ) ; }	Create an InvCatalog by reading catalog XML from a StringReader.Failures and exceptions are handled by causing validate() tofail.
public void write xml ( inv catalog impl catalog , output stream os , boolean raw ) throws io { if converter = this . get catalog converter ( xml . catalog namespace 10 ) ; converter . write xml ( catalog , os , raw ) ; }	Write the InvCatalogImpl to the OutputStream as a InvCatalog 1.0 document.
public if get metadata converter ( string key ) { if ( key == null ) return null ; return metadata converters . get ( key ) ; }	Find the MetadataConverterIF registered for this key.
private static unit name dimensionless id ( ) { unit name id ; try { id = unit name . new unit name ( str , str , str ) ; } catch ( final name exception e ) { id = null ; } return id ; }	Returns the identifiers associated with the dimensionless, derived unit.
@ override protected unit my multiply by ( final unit that ) throws multiply exception { unit result ; if ( dimension . get rank ( ) == num ) { result = that ; } else { if ( ! ( that instanceof derived unit ) ) { result = that . multiply by ( this ) ; } else { final unit dimension that dimension = ( ( derived unit ) that ) . get dimension ( ) ; result = that dimension . get rank ( ) == num ? this : new derived unit impl ( dimension . multiply by ( that dimension ) ) ; } } return result ; }	Multiplies this derived unit by another.
@ override protected unit my divide by ( final unit that ) throws operation exception { unit result ; if ( dimension . get rank ( ) == num ) { result = that . raise to ( - num ) ; } else { if ( ! ( that instanceof derived unit ) ) { result = that . divide into ( this ) ; } else { final unit dimension that dimension = ( ( derived unit ) that ) . get dimension ( ) ; result = that dimension . get rank ( ) == num ? this : new derived unit impl ( dimension . divide by ( that dimension ) ) ; } } return result ; }	Divides this derived unit by another.
public final float [ ] to derived unit ( final float [ ] input , final float [ ] output ) { if ( input != output ) { system . arraycopy ( input , num , output , num , input . length ) ; } return output ; }	Converts numerical values from this unit to the derived unit.
@ override public final boolean is compatible ( final unit that ) { final derived unit unit = that . get derived unit ( ) ; return equals ( unit ) || is reciprocal of ( unit ) ; }	Indicates if values in this unit are convertible with another unit.
public string write feature ( simple geometry geom ) { if ( geom instanceof point ) return write point ( ( point ) geom ) ; else if ( geom instanceof line ) return write line ( ( line ) geom ) ; else if ( geom instanceof polygon ) return write polygon ( ( polygon ) geom ) ; else return null ; }	Checks the type of the Simple Geom and calls the appropriate method to build the xml.
private string write point ( point point ) { string xml = str ; xml += str + str + point . get x ( ) + str + point . get y ( ) + str + str ; return xml ; }	Takes in a point and writes its xml.
private string write line ( line line ) { string xml = str ; xml += str ; for ( point point : line . get points ( ) ) { xml += point . get x ( ) + str + point . get y ( ) + str ; } xml += str ; return xml ; }	Takes in a line and iterates through all its points, writing the posList to xml.
private string write polygon ( polygon poly ) { string xml = str ; xml += str ; polygon polygon = poly ;	Takes in a polygon, checks whether it is an interior or exterior ring, and writes the corresponding xml.Iterates through all linked polygons.
list < node > get subnodes ( node parent ) { list < node > subs = new array list < > ( ) ; node list nodes = parent . get child nodes ( ) ; for ( int i = num ; i < nodes . get length ( ) ; i ++ ) { node n = nodes . item ( i ) ; if ( n . get node type ( ) == node . element node ) subs . add ( n ) ; } return subs ; }	Return the subnodes of a node with non-element nodes suppressed.
protected void pass reserved ( node node , dap node dap ) throws parse exception { try { named node map attrs = node . get attributes ( ) ; for ( int i = num ; i < attrs . get length ( ) ; i ++ ) { node n = attrs . item ( i ) ; string key = n . get node name ( ) ; string value = n . get node value ( ) ; if ( is reserved ( key ) ) dap . add xml ( key , value ) ; } } catch ( dap exception de ) { throw new parse exception ( de ) ; } }	Pass reserved xml attributes unchanged.
public static string get subset string ( variable var , int begin ind , int end ind , int id ) { if ( var == null ) return null ; string sub str = str ; list < dimension > dim list = var . get dimensions ( ) ;	Gets the subset string to be used in NetCDFFile.read given a variable and some indicies.useful for subsetting timeseries.
static public ma factory ma ( array structure from ) throws io { if ( from instanceof ma ) return ( ma ) from ;	Turn any ArrayStructure into a ArrayStructureMA.
public void set member array ( string member name , array data ) { structure members . member m = members . find member ( member name ) ; m . set data array ( data ) ; }	Set the data array for this member.
static public ma factory ma ( structure from , int [ ] shape ) throws io { structure members sm = from . make structure members ( ) ; for ( variable v : from . get variables ( ) ) { array data ; if ( v instanceof sequence ) { data = array . factory ( data type . sequence , shape ) ;	Create an ArrayStructure for a Structure.
public geometry type get geometry type ( string name ) { variable geometry var = ds . find variable ( name ) ; if ( geometry var == null ) return null ;	Given a variable name, returns the geometry type which that variable is associated with.If the variable has no simple geometry information, null will be returned.
public station time series feature make station ( structure data station data , int recnum ) { station feature s = ft . make station ( station data ) ; if ( s == null ) return null ; return new standard station feature impl ( s , time unit , station data , recnum ) ; }	Make a Station from the station data structure.
protected void compile ast ( ceast ast ) throws dap exception { switch ( ast . sort ) { case constraint : for ( ceast clause : ast . clauses ) { compile ast ( clause ) ; }	Recursive AST walker; compilation of filters is done elsewhere.
public void compilefilter ( dap variable var , dap sequence seq , ceast expr ) throws dap exception { if ( expr == null ) return ; if ( expr . sort == ceast . sort . segment ) {	Convert field references in a filter.
protected void dimredef ( ceast node ) throws dap exception { dap dimension dim = ( dap dimension ) dataset . find by fqn ( node . name , dap sort . dimension ) ; if ( dim == null ) throw new dap exception ( str + node . name ) ; slice slice = node . slice ; slice . finish ( ) ; ce . add redef ( dim , slice ) ; }	Process a dim redefinition.
protected array create view ( index index ) { return array object . factory ( data type , element type , is vlen , index , storage ) ; }	create new Array with given indexImpl and the same backing store.
public boolean contained in ( lat lon rect b ) { return ( b . get width ( ) >= width ) && b . contains ( upper right ) && b . contains ( lower left ) ; }	Determine if this bounding box is contained in another LatLonRect.
public void extend ( lat lon point p ) { if ( contains ( p ) ) return ; double lat = p . get latitude ( ) ; double lon = p . get longitude ( ) ;	Extend the bounding box to contain this point.
public void extend ( lat lon rect r ) { preconditions . check not null ( r ) ;	Extend the bounding box to contain the given rectangle.
public lat lon rect intersect ( lat lon rect clip ) { double lat min = math . max ( get lat min ( ) , clip . get lat min ( ) ) ; double lat max = math . min ( get lat max ( ) , clip . get lat max ( ) ) ; double delta lat = lat max - lat min ; if ( delta lat < num ) return null ;	Create the instersection of this LatLon with the given one.
public static array add ( array a , array b ) throws illegal argument exception { array result = array . factory ( a . get data type ( ) , a . get shape ( ) ) ; if ( a . get element type ( ) == double . class ) { add double ( result , a , b ) ; } else throw new unsupported operation exception ( ) ; return result ; }	Add elements of two arrays together, allocating the result array.The result type and the operation type are taken from the type of a.
public static boolean conformable ( array a , array b ) { return conformable ( a . get shape ( ) , b . get shape ( ) ) ; }	Check that two arrays are conformable.
public static boolean conformable ( int [ ] shape a , int [ ] shape b ) { if ( reduced rank ( shape a ) != reduced rank ( shape b ) ) return bool ; int rank b = shape b . length ; int dim b = num ; for ( int a shape a : shape a ) {	Check that two array shapes are conformable.The shapes must match exactly, except that dimensions of length 1 are ignored.
public static array convert ( array org , data type want type ) { if ( org == null ) return null ; class want class = want type . get primitive class type ( ) ; if ( org . get element type ( ) . equals ( want class ) ) return org ; array result = array . factory ( want type , org . get shape ( ) ) ; copy ( want type , org . get index iterator ( ) , result . get index iterator ( ) ) ; return result ; }	Convert original array to desired type.
public static void copy ( array result , array a ) throws illegal argument exception { class class type = a . get element type ( ) ; if ( class type == double . class ) { copy double ( result , a ) ; } else if ( class type == float . class ) { copy float ( result , a ) ; } else if ( class type == long . class ) { copy long ( result , a ) ; } else if ( class type == int . class ) { copy int ( result , a ) ; } else if ( class type == short . class ) { copy short ( result , a ) ; } else if ( class type == char . class ) { copy char ( result , a ) ; } else if ( class type == byte . class ) { copy byte ( result , a ) ; } else if ( class type == boolean . class ) { copy boolean ( result , a ) ; } else copy object ( result , a ) ; }	Copy array a to array result, the result array will be in canonical orderThe operation type is taken from the type of a.
public static void copy boolean ( array result , array a ) throws illegal argument exception { if ( ! conformable ( a , result ) ) throw new illegal argument exception ( str ) ; index iterator iter a = a . get index iterator ( ) ; index iterator iter r = result . get index iterator ( ) ; while ( iter a . has next ( ) ) iter r . set boolean next ( iter a . get boolean next ( ) ) ; }	copy array a to array result as bytesThe array a and result must be type boolean.
public static void copy object ( array result , array a ) throws illegal argument exception { if ( ! conformable ( a , result ) ) throw new illegal argument exception ( str ) ; index iterator iter a = a . get index iterator ( ) ; index iterator iter r = result . get index iterator ( ) ; while ( iter a . has next ( ) ) { iter r . set object next ( iter a . get object next ( ) ) ; } }	copy array a to array result as an ObjectThe array a and result must be type object.
public static ma . min max get min max ( array a ) { index iterator iter = a . get index iterator ( ) ; double max = - double . max value ; double min = double . max value ; while ( iter . has next ( ) ) { double val = iter . get double next ( ) ; if ( double . is na n ( val ) ) continue ; if ( val > max ) max = val ; if ( val < min ) min = val ; } return new min max ( min , max ) ; }	Find min and max value in this array, getting values as doubles.
public static void set double ( array result , double val ) { index iterator iter = result . get index iterator ( ) ; while ( iter . has next ( ) ) { iter . set double next ( val ) ; } }	Set all the elements of this array to the given double value.The value is converted to the element type of the array, if needed.
public catalog builder make catalog builder ( ) { catalog builder builder = new catalog builder ( this ) ; for ( dataset ds : get datasets local ( ) ) { builder . add dataset ( make dataset builder ( null , ds ) ) ; } return builder ; }	turn ConfigCatalog into a mutable CatalogBuilder so we can mutate.
static public projection impl factory ( projection proj ) { if ( proj instanceof projection impl ) { return ( projection impl ) proj ; } return new projection adapter ( proj ) ; }	Create a ProjectionImpl from the projection.
public static string unescape dap ( string id ) { string s ; try { s = unescape string ( id ) ; } catch ( exception e ) { s = null ; } return s ; }	Define the DEFINITIVE opendap identifier unescape function.
public static string url decode ( string s ) { try {	Define the DEFINITIVE URL unescape function.
public static string unescape url ( string url ) { string newurl ; newurl = url decode ( url ) ; return newurl ; }	Decode all of the parts of the url including query and fragment.
static public string backslash escape ( string x , string reserved chars ) { if ( x == null ) { return null ; } else if ( reserved chars == null ) { return x ; } boolean ok = bool ; for ( int pos = num ; pos < x . length ( ) ; pos ++ ) { char c = x . char at ( pos ) ; if ( reserved chars . index of ( c ) >= num ) { ok = bool ; break ; } } if ( ok ) return x ;	backslash escape a string.
static public string backslash unescape ( string x ) { if ( ! x . contains ( str ) ) return x ;	backslash unescape a string.
public static list < string > tokenize escaped name ( string escaped name ) { list < string > result = new array list < > ( ) ; int pos = num ; int start = num ; while ( bool ) { pos = escaped name . index of ( sep , pos + num ) ; if ( pos <= num ) break ; if ( ( pos > num ) && escaped name . char at ( pos - num ) != str ) { result . add ( escaped name . substring ( start , pos ) ) ; start = pos + num ; } } result . add ( escaped name . substring ( start , escaped name . length ( ) ) ) ;	Tokenize an escaped name using "." as delimiter, skipping "\.".
public static int index of ( string escaped name , char c ) { int pos = num ; while ( bool ) { pos = escaped name . index of ( c , pos + num ) ; if ( pos <= num ) return pos ; if ( ( pos > num ) && escaped name . char at ( pos - num ) != str ) return pos ; } }	Find first occurence of char c in escapedName, excluding escaped c.
public static string backslash to dap ( string bs ) { string builder buf = new string builder ( ) ; int len = bs . length ( ) ; for ( int i = num ; i < len ; i ++ ) { char c = bs . char at ( i ) ; if ( i < ( len - num ) && c == str ) { c = bs . char at ( ++ i ) ; } if ( allowable in dap . index of ( c ) < num ) { buf . append ( uri ) ;	Given a backslash escaped name,convert to a DAP escaped name.
protected object read atomic scalar ( var notes vi , type notes ti ) throws dap exception { dap variable atomvar = ( dap variable ) get template ( ) ;	Read a top-level scalar atomic variable.
static list < nc4 cursor > get cursor path ( nc4 cursor cursor ) { list < nc4 cursor > path = new array list < > ( ) ; for ( ; ; ) { if ( ! cursor . get scheme ( ) . is compound array ( ) )	Given a cursor, get a list of "containing" cursorswith the following constraints.1.
public static object get ui ( class clazz , string property ) { object ret val = null ; ui defaults = get ui ( clazz ) ; list < object > list keys = collections . list ( defaults . keys ( ) ) ; for ( object key : list keys ) { if ( key . equals ( property ) ) { return defaults . get ( key ) ; } if ( key . to string ( ) . equals ignore case ( property ) ) { ret val = defaults . get ( key ) ; } } return ret val ; }	Convenience method for retrieving the UIDefault for a single propertyof a particular class.
public static < t extends j > class get j ( t component ) { class < ? > clazz = component . get class ( ) ; while ( ! clazz . get name ( ) . matches ( str ) ) { clazz = clazz . get superclass ( ) ; } return clazz ; }	Convenience method to obtain the Swing class from which thiscomponent was directly or indirectly derived.
public void compile ( ) throws dap exception { assert ( this . dataset != null && this . databuffer != null ) ;	The goal here is to process the serializeddatabuffer and locate top-level variable positionsin the serialized databuffer.
protected d4 cursor compile structure array ( dap variable var , d4 cursor container ) throws dap exception { dap structure dapstruct = ( dap structure ) var . get base type ( ) ; d4 cursor structarray = new d4 cursor ( scheme . structarray , this . dsp , var , container ) . set offset ( get pos ( this . databuffer ) ) ; list < dap dimension > dimset = var . get dimensions ( ) ; long dimproduct = dap util . dim product ( dimset ) ; d4 cursor [ ] instances = new d4 cursor [ ( int ) dimproduct ] ; odometer odom = odometer . factory ( dap util . dimset to slices ( dimset ) , dimset ) ; while ( odom . has next ( ) ) { index index = odom . next ( ) ; d4 cursor instance = compile structure ( var , dapstruct , structarray ) ; instance . set index ( index ) ; instances [ ( int ) index . index ( ) ] = instance ; } structarray . set elements ( instances ) ; return structarray ; }	Compile a structure array.
protected d4 cursor compile structure ( dap variable var , dap structure dapstruct , d4 cursor container ) throws dap exception { int pos = get pos ( this . databuffer ) ; d4 cursor d4ds = new d4 cursor ( scheme . structure , ( dsp ) this . dsp , var , container ) . set offset ( pos ) ; list < dap variable > dfields = dapstruct . get fields ( ) ; for ( int m = num ; m < dfields . size ( ) ; m ++ ) { dap variable dfield = dfields . get ( m ) ; d4 cursor dvfield = compile var ( dfield , d4ds ) ; d4ds . add field ( m , dvfield ) ; assert dfield . get parent ( ) != null ; } return d4ds ; }	Compile a structure instance.
protected d4 cursor compile sequence array ( dap variable var , d4 cursor container ) throws dap exception { dap sequence dapseq = ( dap sequence ) var . get base type ( ) ; d4 cursor seqarray = new d4 cursor ( scheme . seqarray , this . dsp , var , container ) . set offset ( get pos ( this . databuffer ) ) ; list < dap dimension > dimset = var . get dimensions ( ) ; long dimproduct = dap util . dim product ( dimset ) ; d4 cursor [ ] instances = new d4 cursor [ ( int ) dimproduct ] ; odometer odom = odometer . factory ( dap util . dimset to slices ( dimset ) , dimset ) ; while ( odom . has next ( ) ) { index index = odom . next ( ) ; d4 cursor instance = compile sequence ( var , dapseq , seqarray ) ; instance . set index ( index ) ; instances [ ( int ) index . index ( ) ] = instance ; } seqarray . set elements ( instances ) ; return seqarray ; }	Compile a sequence array.
public d4 cursor compile sequence ( dap variable var , dap sequence dapseq , d4 cursor container ) throws dap exception { int pos = get pos ( this . databuffer ) ; d4 cursor seq = new d4 cursor ( scheme . sequence , this . dsp , var , container ) . set offset ( pos ) ; list < dap variable > dfields = dapseq . get fields ( ) ;	Compile a sequence as a set of records.
public long read le ( ) throws io { read fully ( w , num , num ) ; return ( long ) ( w [ num ] & num ) << num | ( long ) ( w [ num ] & num ) << num | ( long ) ( w [ num ] & num ) << num | ( long ) ( w [ num ] & num ) << num | ( long ) ( w [ num ] & num ) << num | ( long ) ( w [ num ] & num ) << num | ( long ) ( w [ num ] & num ) << num | ( long ) ( w [ num ] & num ) ; }	read a long in little endian format.
public field get field ( string name ) { field fld = flds . get ( name ) ; if ( fld == null ) return null ; return ( fld instanceof field resizable ) ? ( ( field resizable ) fld ) . get delegate ( ) : fld ; }	Find the field with the specified name.
public object get field value ( string name ) { field fld = get field ( name ) ; if ( fld == null ) throw new illegal argument exception ( str + name ) ; return fld . get value ( ) ; }	Get current value of the named field.
public void set field value ( string name , object value ) { field fld = get field ( name ) ; if ( fld == null ) throw new illegal argument exception ( str + name ) ; fld . set value ( value ) ; }	Set the current value of the named field.
public field add field ( field fld ) { add field ( fld , cursor col , cursor row , null ) ; cursor row ++ ; return fld ; }	Add a field created by the user.
public field . check box add check box field ( string fld name , string label , boolean def value ) { field . check box fld = new field . check box ( fld name , label , def value , store data ) ; add field ( fld ) ; return fld ; }	Add a boolean field as a checkbox.
public field . date add date field ( string fld name , string label , date def value ) { field . date fld = new field . date ( fld name , label , def value , store data ) ; add field ( new field resizable ( fld , this ) ) ; return fld ; }	Add a field that edits a date.
public field . double add double field ( string fld name , string label , double def value ) { field . double fld = new field . double ( fld name , label , def value , - num , store data ) ; add field ( new field resizable ( fld , this ) ) ; return fld ; }	Add a field that edits a double.
public field . int add int field ( string fld name , string label , int def value ) { field . int fld = new field . int ( fld name , label , def value , store data ) ; add field ( new field resizable ( fld , this ) ) ; return fld ; }	Add a field that edits an integer.
public field . password add password field ( string fld name , string label , string def value ) { field . password fld = new field . password ( fld name , label , def value , store data ) ; add field ( new field resizable ( fld , this ) ) ; return fld ; }	Add a password text field.
public field . text add text field ( string fld name , string label , string def value ) { field . text fld = new field . text ( fld name , label , def value , store data ) ; add field ( new field resizable ( fld , this ) ) ; return fld ; }	Add a text field.
public field . text combo add text combo field ( string fld name , string label , java . util . collection def values , int n keep , boolean editable ) { field . text combo fld = new field . text combo ( fld name , label , def values , n keep , store data ) ; add field ( fld ) ; fld . set editable ( editable ) ; return fld ; }	Add a text combobox field.
public field . text area add text area field ( string fld name , string label , string def , int nrows ) { field . text area fld = new field . text area ( fld name , label , def , nrows , store data ) ; add field ( fld ) ; return fld ; }	Add a TextArea field.
public void add heading ( string heading , int row ) { layout components . add ( new layout component ( heading , num , row , null ) ) ; }	Add a heading at the specified row. this spans all columns.
public void add component ( component comp , int col , int row , string constraint ) { layout components . add ( new layout component ( comp , col , row , constraint ) ) ; }	Add a Component.
public void add empty row ( int row , int size ) { layout components . add ( new layout component ( null , size , row , null ) ) ; }	Add a seperator after the last field added.
static public frame find active frame ( ) { frame [ ] frames = j . get frames ( ) ; for ( frame frame : frames ) { if ( frame . is visible ( ) ) return frame ; } return null ; }	thanks to Heinz M. Kabutz.
public float get cell spacing ( ) throws descriptor exception { float [ ] cell ranges = my celv . get cell ranges ( ) ;	Get the cell spacing.
public final factor [ ] get factors ( ) { final factor [ ] factors = new factor [ factors . length ] ; system . arraycopy ( factors , num , factors , num , factors . length ) ; return factors ; }	Returns the array of Factor-s constituting this dimension.
protected factor [ ] mult ( final dimension that ) {	Multiplies this dimension by another dimension.
protected factor [ ] pow ( final int power ) { factor [ ] factors ; if ( power == num ) { factors = new factor [ num ] ; } else { factors = get factors ( ) ; if ( power != num ) { for ( int i = factors . length ; -- i >= num ; ) { factors [ i ] = factors [ i ] . pow ( power ) ; } } } return factors ; }	Raises this dimension to a power.
public final boolean is reciprocal of ( final dimension that ) { final factor [ ] these factors = factors ; final factor [ ] those factors = that . factors ; boolean is reciprocal of ; if ( these factors . length != those factors . length ) { is reciprocal of = bool ; } else { int i ; for ( i = these factors . length ; -- i >= num ; ) { if ( ! these factors [ i ] . is reciprocal of ( those factors [ i ] ) ) { break ; } } is reciprocal of = i < num ; } return is reciprocal of ; }	Indicates if this Dimension is the reciprocal of another dimension.
public final boolean is dimensionless ( ) { for ( int i = factors . length ; -- i >= num ; ) { if ( ! factors [ i ] . is dimensionless ( ) ) { return bool ; } } return bool ; }	Indicates if this dimension is dimensionless.
public static grib1 param tables factory ( string param table path , string lookup table path ) throws io { if ( param table path == null && lookup table path == null ) return new grib1 param tables ( ) ; lookup lookup = null ; grib1 param table reader override = null ; grib1 param table reader table ; if ( param table path != null ) { table = local table hash . get ( param table path ) ; if ( table == null ) { table = new grib1 param table reader ( param table path ) ; local table hash . put ( param table path , table ) ; override = table ; } } if ( lookup table path != null ) { lookup = new lookup ( ) ; if ( ! lookup . read lookup table ( lookup table path ) ) throw new file not found exception ( str + lookup table path ) ; } return new grib1 param tables ( lookup , override ) ; }	Get a Grib1ParamTables object, optionally specifying a parameter table or lookup table specific to this dataset.
public static grib1 param tables factory ( org . jdom2 . element param table elem ) { if ( param table elem == null ) return new grib1 param tables ( ) ; return new grib1 param tables ( null , new grib1 param table reader ( param table elem ) ) ; }	Get a Grib1Tables object, optionally specifiying a parameter table in XML specific to this dataset.
public static boolean add parameter table lookup ( string lookup filename ) throws io { lookup lookup = new lookup ( ) ; if ( ! lookup . read lookup table ( lookup filename ) ) return bool ; synchronized ( lock ) { standard lookup . tables . add all ( standard tables start , lookup . tables ) ; standard tables start += lookup . tables . size ( ) ; } return bool ; }	Add all tables in list to standard tables.
public static void add parameter table ( int center , int subcenter , int table version , string table filename ) { grib1 param table reader table = new grib1 param table reader ( center , subcenter , table version , table filename ) ; synchronized ( lock ) { standard lookup . tables . add ( standard tables start , table ) ; standard tables start ++ ; } }	Add table to standard tables for a specific center, subcenter and version.
@ override protected unit my raise to ( final int power ) throws raise exception { if ( power == num ) { return derived unit impl . dimensionless ; } if ( power == num ) { return this ; } throw new raise exception ( this ) ; }	Raise this unit to a power.
public float [ ] to derived unit ( final float [ ] input , final float [ ] output ) throws conversion exception { for ( int i = input . length ; -- i >= num ; ) { output [ i ] = ( float ) ( math . exp ( input [ i ] * ln base ) ) ; } return reference . to derived unit ( output , output ) ; }	Converts values in this unit to the equivalent values in the convertiblederived unit.
private static void init unit table ( ) { unit table = new hashtable < > ( ) ;	Initialize the unit table.
private variable make vertical variable ( int vert sys , int n levels , float [ ] vert args ) throws io { string vert unit = null ; string vert type ; array float . d1 data = new array float . d1 ( n levels ) ; axis type axis type = null ; switch ( vert sys ) { case ( num ) : vert unit = null ; vert type = str ; break ; case ( num ) : case ( num ) : vert unit = str ; vert type = str ; axis type = axis type . height ; break ; case ( num ) : vert unit = str ; vert type = str ; axis type = axis type . pressure ; break ; default : throw new io ( str ) ; } variable vert var = new variable ( ncfile , null , null , vert type ) ; vert var . set dimensions ( level ) ; vert var . set data type ( data type . float ) ; if ( vert unit != null ) { vert var . add attribute ( new attribute ( cdm . units , vert unit ) ) ; } if ( axis type != null ) { vert var . add attribute ( new attribute ( coordinate . axis type , axis type . to string ( ) ) ) ; } switch ( vert sys ) { case ( num ) : case ( num ) : for ( int i = num ; i < n levels ; i ++ ) { data . set ( i , vert args [ num ] + vert args [ num ] * i ) ; } break ; case ( num ) :	Create a vertical dimension variable based on the info.
protected static string peek name ( random access file file ) throws descriptor exception { try { long filepos = file . get file pointer ( ) ; byte [ ] name bytes = new byte [ num ] ; if ( file . read ( name bytes ) == - num ) return null ;	Return the name of the DORADE descriptor at the current locationin the file.
protected short grab short ( byte [ ] bytes , int offset ) { int ndx0 = offset + ( little endian data ? num : num ) ; int ndx1 = offset + ( little endian data ? num : num ) ;	Unpack a two-byte integer from the given byte array.
protected static int grab int ( byte [ ] bytes , int offset , boolean little endian data ) { int ndx0 = offset + ( little endian data ? num : num ) ; int ndx1 = offset + ( little endian data ? num : num ) ; int ndx2 = offset + ( little endian data ? num : num ) ; int ndx3 = offset + ( little endian data ? num : num ) ;	Unpack a four-byte integer from the given byte array.
protected float grab float ( byte [ ] bytes , int offset ) throws descriptor exception { try { byte [ ] src ; if ( little endian data ) { src = new byte [ num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset ] ; offset = num ; } else { src = bytes ; } data input stream stream = new data input stream ( new byte array input stream ( src , offset , num ) ) ; return stream . read float ( ) ; } catch ( exception ex ) { throw new descriptor exception ( ex ) ; } }	Unpack a four-byte IEEE float from the given byte array.
protected double grab double ( byte [ ] bytes , int offset ) throws descriptor exception { try { byte [ ] src ; if ( little endian data ) { src = new byte [ num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset + num ] ; src [ num ] = bytes [ offset ] ; offset = num ; } else { src = bytes ; } data input stream stream = new data input stream ( new byte array input stream ( src , offset , num ) ) ; return stream . read double ( ) ; } catch ( exception ex ) { throw new descriptor exception ( ex ) ; } }	Unpack an eight-byte IEEE float from the given byte array.
private void aa ( final string alias , final string name ) throws unit exists exception , no such unit exception , unit parse exception , specification exception , db , db , operation exception , name exception , unit system exception { aa ( alias , name , null ) ; }	Adds an alias for a unit to the database.
private void as ( final string symbol , final string name ) throws unit exists exception , no such unit exception , unit parse exception , specification exception , db , db , operation exception , name exception , unit system exception { add symbol ( symbol , name ) ; }	Adds a symbol for a unit to the database.
public static converter create ( unit from unit , unit to unit ) throws conversion exception { return from unit . get converter to ( to unit ) ; }	Factory method for creating a unit converter.
public void set structure data ( list < structure data > structure data ) throws io { data model = new structure data model ( structure data ) ; init table ( data model ) ; }	Set the data as a collection of StructureData.
public void set point feature data ( list < point feature > obs data ) throws io { data model = new point feature data model ( obs data ) ; init table ( data model ) ; }	Set the data as a collection of PointFeature.
public void draw ( java . awt . d g , affine transform pixel at ) { g . set color ( color ) ; g . set rendering hint ( rendering hints . key antialiasing , rendering hints . value antialias off ) ; g . set stroke ( new java . awt . basic stroke ( num ) ) ; d clip rect = ( d ) g . get clip ( ) ; iterator siter = get shapes ( g , pixel at ) ; while ( siter . has next ( ) ) { shape s = ( shape ) siter . next ( ) ; d shape bounds = s . get bounds2 d ( ) ; if ( shape bounds . intersects ( clip rect ) ) g . draw ( s ) ; } }	Draws all the features that are within the graphics clip rectangle,using the previously set displayProjection.
protected iterator get shapes ( java . awt . d g , affine transform normal2device ) { if ( shape list != null ) return shape list . iterator ( ) ; if ( debug . is set ( str ) ) system . out . println ( str ) ; projection impl data project = get data projection ( ) ;	get the set of shapes to draw, convert projections if need be.
public void process stream ( input stream is ) throws io { int pos = - num ; buffer b = null ; while ( bool ) { b = ( pos < num ) ? read buffer ( is ) : read buffer ( is , b , pos ) ; pos = process buffer ( b , is ) ; if ( b . done ) break ; } }	process all the bytes in the stream.
private boolean read buffer ( input stream is , byte [ ] dest , int start , int want ) throws io { int done = num ; while ( done < want ) { int got = is . read ( dest , start + done , want - done ) ; if ( got < num ) return bool ; done += got ; } if ( show read ) system . out . println ( str + bytes read + str + done ) ; bytes read += done ; return bool ; }	read into dest byte array, until buffer is full or end of stream.
private void get more bytes ( ) throws io { current offset = num ;	Get more bytes into buffer.
public int read ( byte b [ ] , int off , int len ) throws io { if ( len <= num ) { return num ; } int c = read ( ) ; if ( c == - num ) return - num ; b [ off ] = ( byte ) c ;	Reads up to len bytes of data from this input stream into an array ofbytes.
public long skip ( long n ) { if ( bytes remaining >= n ) { bytes remaining -= n ; return n ; } else { int old bytes remaining = bytes remaining ; bytes remaining = num ; return old bytes remaining ; } }	Skips over and discards n bytes of data from the input stream.
void add dimensions to netcdf file ( netcdf file ncfile , group g ) { if ( ! is vert dimension used ( ) ) return ; int nlevs = levels . size ( ) ; if ( coord values != null ) nlevs = coord values . length ; ncfile . add dimension ( g , new dimension ( get variable name ( ) , nlevs , bool ) ) ; }	Add this coord as a dimension to the netCDF file.
private int coord index ( grid record record ) { double val = record . get level1 ( ) ; double val2 = record . get level2 ( ) ; if ( uses bounds && ( val > val2 ) ) { val = record . get level2 ( ) ; val2 = record . get level1 ( ) ; } for ( int i = num ; i < levels . size ( ) ; i ++ ) { level coord lc = ( level coord ) levels . get ( i ) ; if ( uses bounds ) { if ( ucar . nc2 . util . misc . nearly equals ( lc . value1 , val ) && ucar . nc2 . util . misc . nearly equals ( lc . value2 , val2 ) ) { return i ; } } else { if ( ucar . nc2 . util . misc . nearly equals ( lc . value1 , val ) ) { return i ; } } } return - num ; }	Get the coordinate index for the record.
public boolean is valid file ( ucar . unidata . io . random access file raf ) { now local header = new now ( ) ; return ( local header . is valid file ( raf ) ) ; }	checking the file.
public void open ( ucar . unidata . io . random access file raf , ucar . nc2 . netcdf file file , ucar . nc2 . util . cancel task cancel task ) throws io { super . open ( raf , ncfile , cancel task ) ; header parser = new now ( ) ; try { header parser . read ( this . raf , ncfile ) ; } catch ( exception e ) { }	Open the file and read the header part.
public array read data ( variable v2 , section section ) throws io , invalid range exception {	Read the data for each variable passed in.
public byte [ ] read one row data ( byte [ ] ddata , int r len , int xt ) throws io , invalid range exception { int run ; byte [ ] bdata = new byte [ xt ] ; int nbin = num ; int total = num ; for ( run = num ; run < r len ; run ++ ) { int drun = data type . unsigned byte to short ( ddata [ run ] ) > > num ; byte dcode1 = ( byte ) ( data type . unsigned byte to short ( ddata [ run ] ) & num ) ; for ( int i = num ; i < drun ; i ++ ) { bdata [ nbin ++ ] = dcode1 ; total ++ ; } } if ( total < xt ) { for ( run = total ; run < xt ; run ++ ) { bdata [ run ] = num ; } } return bdata ; }	Read data from encoded values and run len into regular data array.
private void create from dataset ( netcdf dataset ncd ) {	take advantage of the work already done by NetcdfDataset.
private base type create variable ( netcdf file ncfile , variable v ) { base type bt ; if ( v . get rank ( ) == num )	turn Variable into opendap variable.
public void set map area ( projection rect ma ) { if ( debug bb ) system . out . println ( str + ma ) ; navigate . set map area ( ma ) ; }	Set the Map Area.
public void set map area ( lat lon rect llbb ) { if ( debug bb ) system . out . println ( str + llbb ) ; navigate . set map area ( project . lat lon to proj bb ( llbb ) ) ; }	Set the Map Area by converting LatLonRect to a ProjectionRect.
public void set lat lon center map area ( double lat , double lon ) { projection point center = project . lat lon to proj ( lat , lon ) ; projection rect ma = get map area ( ) ; ma . set x ( center . get x ( ) - ma . get width ( ) / num ) ; ma . set y ( center . get y ( ) - ma . get height ( ) / num ) ; set map area ( ma ) ; }	set the center point of the MapArea.
public void set projection impl ( projection impl p ) {	Set the Projection, change the Map Area to the projection's default.
public void add actions to menu ( j menu ) { ba . add action to menu ( menu , zoom in ) ; ba . add action to menu ( menu , zoom out ) ; ba . add action to menu ( menu , zoom back ) ; ba . add action to menu ( menu , zoom default ) ; menu . add separator ( ) ; ba . add action to menu ( menu , move up ) ; ba . add action to menu ( menu , move down ) ; ba . add action to menu ( menu , move right ) ; ba . add action to menu ( menu , move left ) ; menu . add separator ( ) ; ba . add action to menu ( menu , set reference action ) ; }	Add all of the toolbar's actions to a menu.
private void redraw later ( int delay ) { boolean already = ( redraw timer != null ) && ( redraw timer . is running ( ) ) ; if ( debug thread ) system . out . println ( str + already ) ; if ( already ) return ;	from panning, so wait delay msecs before doing the redraw.
private void new screen size ( rectangle b ) { boolean same size = ( b . width == my bounds . width ) && ( b . height == my bounds . height ) ; if ( debug bounds ) system . out . println ( str + my bounds ) ; if ( same size && ( b . x == my bounds . x ) && ( b . y == my bounds . y ) ) return ; my bounds . set bounds ( b ) ; if ( same size ) return ; if ( debug bounds ) system . out . println ( str + b ) ;	when component resizes we need a new buffer.
public void set selected ( if v ) { if ( v == null ) { return ; }	Set the currently selected Variable.
public double get double ( int offset ) { dap variable d4var = ( dap variable ) get template ( ) ; long [ ] dimsizes = dap util . get dim sizes ( d4var . get dimensions ( ) ) ; return get double ( dap util . offset to index ( offset , dimsizes ) ) ; }	Convert int base to Index based.
protected double get double ( dap4 . core . util . index idx ) { assert data . get scheme ( ) == scheme . atomic ; try { object value = data . read ( idx ) ; value = convert . convert ( dap type . floa , this . basetype , value ) ; return ( double ) java . lang . reflect . array . get ( value , num ) ; } catch ( io ioe ) { throw new index out of bounds exception ( ioe . get message ( ) ) ; } }	Get the array element at a specific dap4 index as a double.
protected object get object ( dap4 . core . util . index idx ) { assert data . get scheme ( ) == scheme . atomic ; try { object value = data . read ( idx ) ; value = java . lang . reflect . array . get ( value , num ) ; return value ; } catch ( io ioe ) { throw new index out of bounds exception ( ioe . get message ( ) ) ; } }	Get the array element at a specific dap4 index as an Object.
string gini id ( int ent id ) { string name ; switch ( ent id ) { case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; case num : name = str ; break ; default : name = str ; } return name ; }	Return the string of Sector for the GINI image file.
private double read scaled int ( byte buffer buf ) {	Read a scaled, 3-byte integer from file and convert to double.
public parameter find parameter ignore case ( string name ) { for ( parameter a : params ) { if ( name . equals ignore case ( a . get name ( ) ) ) return a ; } return null ; }	Convenience function; look up Parameter by name, ignoring case.
private void swap byte order ( ) {	Swap the byte order from the system default.
public int [ ] get time steps per file ( string filename ) { if ( chsubs != null ) { for ( chsub ch : chsubs ) { if ( filename . contains ( ch . sub string ) ) { return new int [ ] { ch . num times , ch . start time index } ; } } } return new int [ ] { time steps per file , num } ; }	Get the number of timesteps per file and the starting offset.
public string get file name ( int e index , int t index ) { string data file path = data file ; if ( ( get template type ( ) == ens template ) || ( get template type ( ) == ens time template ) ) { data file path = get ensemble dimension ( ) . replace file template ( data file path , e index ) ; } data file path = get time dimension ( ) . replace file template ( data file path , t index ) ; if ( ( chsubs != null ) && ( data file path . contains ( chsub template id ) ) ) { for ( chsub ch : chsubs ) { if ( ( t index >= ch . start time index ) && ( t index <= ch . end time index ) ) { data file path = data file path . replace ( chsub template id , ch . sub string ) ; break ; } } } return get full path ( data file path ) ; }	Get the file name for the particular time and ensemble index.
private list < string > get file names ( ) throws io { if ( file names == null ) { file names = new array list < > ( ) ; time steps per file = t dim . get size ( ) ; if ( ! is template ( ) ) {	Get the list of filenames.
private string get ddf ( ) { if ( path to ddf == null ) { int last slash = dd file . last index of ( str ) ; if ( last slash < num ) { last slash = dd file . last index of ( file . separator ) ; } path to ddf = ( last slash < num ) ? str : dd file . substring ( num , last slash + num ) ; } return path to ddf ; }	Get the path to the Data Descriptor File.
private string get full path ( string filename ) { string file ; string ddf path = get ddf ( ) ; if ( filename . starts with ( str ) ) { file = filename . replace ( str , str ) ; file = ddf path + file ; } else { file f = new file ( filename ) ; if ( ! f . is absolute ( ) ) { file = ddf path + filename ; } else { file = filename ; } } return file ; }	Get the full path for a given filename.
private void add chsub ( chsub sub ) { if ( chsubs == null ) { chsubs = new array list < > ( ) ; } chsubs . add ( sub ) ; }	Add a Chsub.
public time coord intv value convert reference date ( calendar date ref date , calendar period time unit ) { if ( time unit == null ) { throw new illegal argument exception ( str ) ; } int start offset = time unit . get offset ( ref date , start ) ;	Calculate the offset in units of timeUnit from the given reference date?.
int read wmo ( ucar . unidata . io . random access file raf ) throws io { int pos = num ;	read the header of input file and parsing the WMO part.
public byte [ ] get uncomp data ( int offset , int len ) { if ( len == num ) len = uncompdata . length - offset ; byte [ ] data = new byte [ len ] ; system . arraycopy ( uncompdata , offset , data , num , len ) ; return data ; }	read the compressed data.
int pcode 12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean is z , string struct name , int code ) {	construct a dataset for special graphic symbol packet with code 12, 13, and 14.
int pcode 25 ( int [ ] pos , int hoff , int len , boolean is z ) { array list dims = new array list ( ) ; dimension s dim = new dimension ( str , len ) ; ncfile . add dimension ( null , s dim ) ; dims . add ( s dim ) ; structure dist = new structure ( ncfile , null , null , str ) ; dist . set dimensions ( dims ) ; ncfile . add variable ( null , dist ) ; dist . add attribute ( new attribute ( cdm . long name , str ) ) ; variable ii0 = new variable ( ncfile , null , dist , str ) ; ii0 . set dimensions ( ( string ) null ) ; ii0 . set data type ( data type . short ) ; dist . add member variable ( ii0 ) ; variable ii1 = new variable ( ncfile , null , dist , str ) ; ii1 . set dimensions ( ( string ) null ) ; ii1 . set data type ( data type . short ) ; dist . add member variable ( ii1 ) ; variable jj0 = new variable ( ncfile , null , dist , str ) ; jj0 . set dimensions ( ( string ) null ) ; jj0 . set data type ( data type . short ) ; dist . add member variable ( jj0 ) ; int [ ] pos1 = new int [ len ] ; system . arraycopy ( pos , num , pos1 , num , len ) ; dist . set s ( new vinfo ( num , num , num , num , hoff , num , is r , is z , pos1 , null , num , num ) ) ; return num ; }	construct a dataset for special symbol packet with code 25.
int check msg header ( ucar . unidata . io . random access file raf ) throws io { int rc ; long actual size ; int read len ; actual size = raf . length ( ) ; int pos = num ; raf . seek ( pos ) ;	check level III file header.
int pcode 5 ( int [ ] pos , int hoff , int len , boolean is z ) { array list dims = new array list ( ) ;	construct a dataset for vector arrow data packet with code 5.
int pcode 128 ( int [ ] pos , int [ ] size , int code , int hoff , int len , string struct name , string abbre , boolean is z ) {	construct a dataset for text and special symbol packets with code 1, 2, and 8.
public int [ ] get levels ( int nlevel , short [ ] th ) { int [ ] levels = new int [ nlevel ] ; int ival ; int isign ; for ( int i = num ; i < nlevel ; i ++ ) { ival = convert short2unsigned int ( th [ i ] ) ; if ( ( ival & num ) == num ) { isign = - num ; if ( ( ival & num ) == num ) isign = num ; levels [ i ] = isign * ( ival & num ) ; } else { levels [ i ] = - num + ( ival & num ) ; } } return levels ; }	get the table to calibrate data value.
public int [ ] get dualpol levels ( short [ ] th ) { int inc = th . length ; int [ ] levels = new int [ inc ] ;	get the calibrate data values for dualpol data.
void add variable ( string p name , string long name , netcdf file nc , array list dims , string coordinates , data type dtype , string ut , long hoff , long hedsiz , boolean is z , int nlevel , int [ ] levels , int iscale ) { variable v = new variable ( nc , null , null , p name ) ; v . set data type ( dtype ) ; v . set dimensions ( dims ) ; ncfile . add variable ( null , v ) ; v . add attribute ( new attribute ( cdm . long name , long name ) ) ; v . add attribute ( new attribute ( cdm . units , ut ) ) ; v . add attribute ( new attribute ( coordinate . axes , coordinates ) ) ; v . set s ( new vinfo ( num x , num x0 , num y , num y0 , hoff , hedsiz , is r , is z , null , levels , iscale , nlevel ) ) ; }	adding new variable to the netcdf file.
void add parameter ( string p name , string long name , netcdf file nc , array list dims , attribute att , data type dtype , string ut , long hoff , long doff , boolean is z , int y0 ) { string v name = p name ; variable v var = new variable ( nc , null , null , v name ) ; v var . set data type ( dtype ) ; if ( dims != null ) v var . set dimensions ( dims ) ; else v var . set dimensions ( str ) ; if ( att != null ) v var . add attribute ( att ) ; v var . add attribute ( new attribute ( cdm . units , ut ) ) ; v var . add attribute ( new attribute ( cdm . long name , long name ) ) ; nc . add variable ( null , v var ) ; v var . set s ( new vinfo ( num x , num x0 , num y , y0 , hoff , doff , is r , is z , null , null , num , num ) ) ; }	adding new parameter to the netcdf file.
byte [ ] uncompressed ( byte buffer buf , int offset , int uncomplen ) throws io { byte [ ] header = new byte [ offset ] ; buf . position ( num ) ; buf . get ( header ) ; byte [ ] out = new byte [ offset + uncomplen ] ; system . arraycopy ( header , num , out , num , offset ) ; cb cbzip2 = new cb ( ) ; int num comp bytes = buf . remaining ( ) ; byte [ ] bufc = new byte [ num comp bytes ] ; buf . get ( bufc , num , num comp bytes ) ; byte array input stream bis = new byte array input stream ( bufc , num , num comp bytes - num ) ;	uncompress the TDWR products.
int get u ( byte [ ] b , int num ) { int base = num ; int i ; int word = num ; int bv [ ] = new int [ num ] ; for ( i = num ; i < num ; i ++ ) { bv [ i ] = convertunsigned byte2 short ( b [ i ] ) ; } for ( i = num - num ; i >= num ; i -- ) { word += base * bv [ i ] ; base *= num ; } return word ; }	get unsigned integer from byte array.
int get int ( byte [ ] b , int num ) { int base = num ; int i ; int word = num ; int bv [ ] = new int [ num ] ; for ( i = num ; i < num ; i ++ ) { bv [ i ] = convertunsigned byte2 short ( b [ i ] ) ; } if ( bv [ num ] > num ) { bv [ num ] -= num ; base = - num ; } for ( i = num - num ; i >= num ; i -- ) { word += base * bv [ i ] ; base *= num ; } return word ; }	get signed integer from bytes.
protected object convert ( byte [ ] barray , data type data type , int nelems , int byte order ) { if ( data type == data type . byte ) { return barray ; } if ( data type == data type . char ) { return iosp helper . convert byte to char ( barray ) ; } byte buffer bbuff = byte buffer . wrap ( barray ) ; if ( byte order >= num ) bbuff . order ( byte order == ucar . unidata . io . random access file . little endian ? byte order . little endian : byte order . big endian ) ; if ( data type == data type . short ) { short buffer tbuff = bbuff . as short buffer ( ) ; short [ ] pa = new short [ nelems ] ; tbuff . get ( pa ) ; return pa ; } else if ( data type == data type . int ) { int buffer tbuff = bbuff . as int buffer ( ) ; int [ ] pa = new int [ nelems ] ; tbuff . get ( pa ) ; return pa ; } else if ( data type == data type . float ) { float buffer tbuff = bbuff . as float buffer ( ) ; float [ ] pa = new float [ nelems ] ; tbuff . get ( pa ) ; return pa ; } else if ( data type == data type . double ) { double buffer tbuff = bbuff . as double buffer ( ) ; double [ ] pa = new double [ nelems ] ; tbuff . get ( pa ) ; return pa ; } throw new illegal state exception ( ) ; }	this converts a byte array to another primitive array.
protected void do dmr ( dap request drq , dap context cxt ) throws io {	Process a DMR request.
protected dap request get request state ( http servlet request rq , http servlet response rsp ) throws io { return new dap request ( this , rq , rsp ) ; }	Merge the servlet inputs into a single objectfor easier transport as well as adding value.
protected void senderror ( dap request drq , int httpcode , throwable t ) throws io { if ( httpcode == num ) httpcode = http servlet response . sc bad request ; error response err = new error response ( ) ; err . set code ( httpcode ) ; if ( t == null ) { err . set message ( str + drq . get url ( ) ) ; } else { string writer sw = new string writer ( ) ; print writer p = new print writer ( sw ) ; t . print stack trace ( p ) ; p . close ( ) ; sw . close ( ) ; err . set message ( sw . to string ( ) ) ; } err . set context ( drq . get url ( ) ) ; string errormsg = err . build xml ( ) ; drq . get response ( ) . send error ( httpcode , errormsg ) ; }	Generate an error based on the parameters.
public boolean anchor ( point p ) { first stretch = bool ; anchor pt . x = p . x ; anchor pt . y = p . y ; stretched pt . x = last pt . x = anchor pt . x ; stretched pt . y = last pt . y = anchor pt . y ; return bool ; }	Set the anchor point.
public void stretch ( point p ) { last pt . x = stretched pt . x ; last pt . y = stretched pt . y ; stretched pt . x = p . x ; stretched pt . y = p . y ; d g = ( d ) component . get graphics ( ) ; if ( g != null ) { try { g . set xor ( component . get background ( ) ) ; if ( first stretch == bool ) first stretch = bool ; else draw last ( g ) ; draw next ( g ) ; } finally { g . dispose ( ) ; }	Erase the last rectangle and draw a new one from the anchor point to this point.
private date date only format ( string text ) throws java . text . parse exception { text = ( text == null ) ? str : text . trim ( ) ; date only format ( ) ; return date only format . parse ( text ) ; }	Parse text in the format "yyyy-MM-dd".
protected void replace data vars ( structure members sm ) { for ( structure members . member m : sm . get members ( ) ) { if org = this . cols . get ( m . get name ( ) ) ; int rank = org . get rank ( ) ; list < dimension > org dims = org . get dimensions ( ) ;	change shape of the data variables.
public static void ensure array size okay ( long t size , string attribute to ) { if ( t size >= integer . max value ) throw new runtime exception ( memory too much data + str + message format . format ( memory array size , str + t size , str + integer . max value ) + ( attribute to == null || attribute to . length ( ) == num ? str : str + attribute to + str ) ) ; }	Even if JavaBits is 64, the limit on an array size is Integer.MAX_VALUE.
public static int int2 ( random access file raf ) throws io { int a = raf . read ( ) ; int b = raf . read ( ) ; return int2 ( a , b ) ; }	Convert 2 bytes into a signed integer.
public static int uint ( random access file raf ) throws io { int a = raf . read ( ) ; return ( int ) data type . unsigned byte to short ( ( byte ) a ) ; }	Convert unsigned bytes into an integer.
public static int int3 ( random access file raf ) throws io { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; return int3 ( a , b , c ) ; }	Convert 3 bytes into a signed integer.
public static int uint2 ( random access file raf ) throws io { int a = raf . read ( ) ; int b = raf . read ( ) ; return uint2 ( a , b ) ; }	Convert 2 bytes into an unsigned integer.
public static int uint3 ( random access file raf ) throws io { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; return uint3 ( a , b , c ) ; }	Convert 3 bytes into an unsigned integer.
public static float float4 ( random access file raf ) throws io { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; int d = raf . read ( ) ; return float4 ( a , b , c , d ) ; }	Convert 4 bytes into a float value.
public static float float4 ( int a , int b , int c , int d ) { int sgn , mant , exp ; mant = b << num | c << num | d ; if ( mant == num ) { return num ; } sgn = - ( ( ( a & num ) > > num ) - num ) ; exp = ( a & num ) - num ; return ( float ) ( sgn * math . pow ( num , exp - num ) * mant ) ; }	Convert 4 bytes to a float.
public static long int8 ( random access file raf ) throws io { int a = raf . read ( ) ; int b = raf . read ( ) ; int c = raf . read ( ) ; int d = raf . read ( ) ; int e = raf . read ( ) ; int f = raf . read ( ) ; int g = raf . read ( ) ; int h = raf . read ( ) ; return ( num - ( ( a & num ) > > num ) ) * ( ( long ) ( a & num ) << num | ( long ) b << num | ( long ) c << num | ( long ) d << num | e << num | f << num | g << num | h ) ; }	Convert 8 bytes into a signed long.
public static int count bits ( byte [ ] bitmap ) { int bits = num ; for ( byte b : bitmap ) { short s = data type . unsigned byte to short ( b ) ; bits += long . bit count ( s ) ; } return bits ; }	count number of bits on in bitmap.
@ override public projection impl construct copy ( ) { projection impl result = new lambert conformal ( get origin lat ( ) , get origin lon ( ) , get parallel one ( ) , get parallel two ( ) , get false easting ( ) , get false northing ( ) , earth radius ) ; result . set default map area ( default map area ) ; result . set name ( name ) ; return result ; }	lon naught ??.
public string to wks ( ) { string builder sbuff = new string builder ( ) ; sbuff . append ( str ) . append ( get name ( ) ) . append ( str ) ; if ( bool ) { sbuff . append ( str ) ; sbuff . append ( str ) ; sbuff . append ( str ) ; } else { sbuff . append ( str ) ; sbuff . append ( str ) ; sbuff . append ( str ) ; sbuff . append ( str ) ; } sbuff . append ( str ) ; sbuff . append ( str ) ; sbuff . append ( str ) ; sbuff . append ( str ) . append ( get origin lat ( ) ) . append ( str ) ;	Create a WKS string.
static public string entity escape ( string s , string wrt ) { if ( wrt == null ) wrt = entityescapes ; string builder escaped = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char c = s . char at ( i ) ; int index = wrt . index of ( c ) ; if ( index < num ) escaped . append ( c ) ; else switch ( c ) { case str : escaped . append ( str + entity amp + str ) ; break ; case str : escaped . append ( str + entity lt + str ) ; break ; case str : escaped . append ( str + entity gt + str ) ; break ; case str : escaped . append ( str + entity quot + str ) ; break ; case str : escaped . append ( str + entity apos + str ) ; break ; case str : case str : case str : escaped . append ( c ) ;	Escape selected characters in a string using XML entities.
static public string backslash unescape ( string s ) { string builder clear = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; ) { char c = s . char at ( i ++ ) ; if ( c == str ) { c = s . char at ( i ++ ) ; switch ( c ) { case str : c = str ; break ; case str : c = str ; break ; case str : c = str ; break ; case str : c = str ; break ; default : break ; } clear . append ( c ) ; } else clear . append ( c ) ; } return clear . to string ( ) ; }	Remove backslashed characters in a string.
static public list < string > backslashsplit ( string s , char sep ) { list < string > path = new array list < string > ( ) ; int len = s . length ( ) ; string builder piece = new string builder ( ) ; int i = num ; for ( ; i <= len - num ; i ++ ) { char c = s . char at ( i ) ; if ( c == str && i < ( len - num ) ) { piece . append ( c ) ;	Split a string with respect to a separatorcharacter and taking backslashes into consideration.
private fmrc inv make fmrc inv ( formatter debug ) throws io { try { map < calendar date , fmr inv > fmr map = new hash map < > ( ) ;	scan has been done, create FmrcInv.
static public string get service special ( string path ) { string ss = null ; if ( path . starts with ( str ) ) ss = str ; else if ( path . starts with ( str ) ) ss = str ; return ss ; }	the ones that dont start with thredds.
public int projected components ( boolean constrained ) { int comp ; if ( constrained ) { comp = ( ( d ) array var ) . is project ( ) ? num : num ; enumeration e = map vars . elements ( ) ; while ( e . has more elements ( ) ) { if ( ( ( d ) e . next element ( ) ) . is project ( ) ) comp ++ ; } } else { comp = num + map vars . size ( ) ; } return comp ; }	How many prohected components of this Grid object?.
public final calendar date get reference time ( ) { int sec = ( second < num || second > num ) ? num : second ; return calendar date . of ( null , year , month , day , hour , minute , sec ) ; }	return record header time as a CalendarDate.
static public bb factory ( bb org , section section ) { if ( section == null || section . compute size ( ) == org . get size ( ) ) return org ; return new b ( org . get structure members ( ) , org . get shape ( ) , org . get byte buffer ( ) , section ) ; }	Make a section of an ArrayStructureBB.
public static void main1 ( string [ ] args ) { if ( index dir . exists ( ) ) { system . out . println ( str + index dir + str ) ; system . exit ( num ) ; } lucene indexer indexer = new lucene indexer ( ) ; date start = new date ( ) ; try { index writer writer = new index writer ( index dir , new standard analyzer ( ) , bool ) ; system . out . println ( str + index dir + str ) ; indexer . index docs ( writer , doc dir ) ; system . out . println ( str ) ; writer . optimize ( ) ; writer . close ( ) ; date end = new date ( ) ; system . out . println ( end . get time ( ) - start . get time ( ) + str ) ; } catch ( io e ) { system . out . println ( str + e . get class ( ) + str + e . get message ( ) ) ; } }	Index all text files under a directory.
private grib1 record read record ( grib1 index proto . grib1 record p ) { grib1 section indicator is = new grib1 section indicator ( p . get grib message start ( ) , p . get grib message length ( ) ) ; grib1 section product definition pds = new grib1 section product definition ( p . get pds ( ) . to byte array ( ) ) ; grib1 section grid definition gds = pds . gds exists ( ) ? gds list . get ( p . get gds idx ( ) ) : new grib1 section grid definition ( pds ) ; grib1 section bit map bms = pds . bms exists ( ) ? new grib1 section bit map ( p . get bms pos ( ) ) : null ; grib1 section binary data data section = new grib1 section binary data ( p . get data pos ( ) , p . get data len ( ) ) ; return new grib1 record ( p . get header ( ) . to byte array ( ) , is , gds , pds , bms , data section ) ; }	deserialize the Grib1Record object.
public static boolean is mine ( netcdf file ncfile ) { return ( null != ncfile . find global attribute ( str ) ) && ( null != ncfile . find global attribute ( str ) ) && ( null != ncfile . find global attribute ( str ) ) && ( null != ncfile . find global attribute ( str ) ) && ( null != ncfile . find global attribute ( str ) ) && ( null != ncfile . find global attribute ( str ) ) ;	Do we think this is a M3IO file.
private coordinate transform make utm ( netcdf dataset ds ) { int zone = ( int ) find attribute double ( ds , str ) ; double ycent = find attribute double ( ds , str ) ;	Intend to use EPSG system parameters.
public void reacquire ( ) throws io { try { area reader . af = new area file ( location ) ; } catch ( throwable e ) { throw new io ( e ) ; } }	reacquire any resources like file handles.
public boolean before ( date d ) { if ( is present ( ) ) return bool ; return date . is before ( calendar date . of ( d ) ) ; }	Is this date before the given date.
public boolean before ( date type d ) { if ( d . is present ( ) ) return bool ; if ( is present ( ) ) return bool ; return date . is before ( d . get calendar date ( ) ) ; }	Is this date before the given date.
public boolean after ( date d ) { if ( is present ( ) ) return bool ; return date . is after ( calendar date . of ( d ) ) ; }	Is this date after the given date.
public final void set value ( int i , base type new val ) { vals [ i ] = new val ; base type parent = ( base type ) get template ( ) . get parent ( ) ; vals [ i ] . set parent ( parent ) ; }	Set the i'th value of the array.
public void add coordinate system ( coordinate system cs ) { if ( cs == null ) throw new runtime exception ( str + for var . get full name ( ) ) ; if ( coord sys == null ) coord sys = new array list < > ( num ) ; coord sys . add ( cs ) ; }	Add a CoordinateSystem to the dataset.
public void set units string ( string units ) { this . units = units ; for var . add attribute ( new attribute ( cdm . units , units ) ) ; }	Set the Unit String for this Variable.
public string get units string ( ) { string result = units ; if ( ( result == null ) && ( for var != null ) ) { attribute att = for var . find attribute ( cdm . units ) ; if ( att == null ) att = for var . find attribute ignore case ( cdm . units ) ; if ( ( att != null ) && att . is string ( ) ) result = att . get string value ( ) ; } return ( result == null ) ? null : result . trim ( ) ; }	Get the Unit String for the Variable.
public synchronized void init ( read mode read mode , preferences ext prefs ) { if ( read mode == null ) read mode = default read mode ; this . prefs = prefs ; tracker number = prefs . get long ( str , num ) ; number catalogs = prefs . get int ( str , num ) ; next cat id = prefs . get long ( str , num ) ; make debug actions ( ) ; this . content root path = this . tds context . get thredds directory ( ) ; this . context path = tds context . get context path ( ) ; reread ( read mode , bool ) ; }	called from TdsInit on spring-managed auto-wired bean.
private config catalog read catalog ( string catalog rel path , string catalog full path ) { uri uri ; try {	Does the actual work of reading a catalog.
private void process datasets ( long cat id , read mode read mode , string dir path , list < dataset > datasets , set < string > id map ) throws io { if ( exceed limit ) return ; for ( dataset ds : datasets ) { if ( dataset tracker . track dataset ( cat id , ds , callback ) ) count datasets ++ ; if ( max datasets process > num && count datasets > max datasets process ) exceed limit = bool ;	dirPath = the directory path, reletive to the rootDir.
private void read cats in directory ( read mode read mode , string dir path , path directory ) throws io { if ( exceed limit ) return ;	dirPath is the directory relative to rootDir, directory is absolute.
static public boolean between lon ( double lon , double lon beg , double lon end ) { lon beg = lon normal ( lon beg , lon ) ; lon end = lon normal ( lon end , lon ) ; return ( lon >= lon beg ) && ( lon <= lon end ) ; }	Test if point lies between two longitudes, deal with wrapping.
static public string lat to string ( double lat , int ndec ) { boolean is north = ( lat >= num ) ; if ( ! is north ) lat = - lat ; string f = str + ndec + str ; formatter lat buff = new formatter ( ) ; lat buff . format ( f , lat ) ; lat buff . format ( str , is north ? str : str ) ; return lat buff . to string ( ) ; }	Make a nicely formatted representation of a latitude, eg 40.34N or 12.9S.
static public string lon to string ( double lon , int ndec ) { double wlon = lon normal ( lon ) ; boolean is east = ( wlon >= num ) ; if ( ! is east ) wlon = - wlon ; string f = str + ndec + str ; formatter lat buff = new formatter ( ) ; lat buff . format ( f , wlon ) ; lat buff . format ( str , is east ? str : str ) ; return lat buff . to string ( ) ; }	Make a nicely formatted representation of a longitude, eg 120.3W or 99.99E.
public int compare to ( final base quantity that ) { int comp ; if ( this == that ) { comp = num ; } else { comp = get name ( ) . compare to ignore case ( that . get name ( ) ) ; if ( comp == num && get symbol ( ) != null ) { comp = get symbol ( ) . compare to ( that . get symbol ( ) ) ; } } return comp ; }	Compares this base quantity to another base quantity.
public dataset node get selected dataset ( ) { inv catalog tree node tnode = get selected node ( ) ; return tnode == null ? null : tnode . ds ; }	Get the currently selected InvDataset.
public void set selected dataset ( dataset ds ) { if ( ds == null ) return ; tree path path = make path ( ds ) ; if ( path == null ) return ; tree . set selection path ( path ) ; tree . scroll path to visible ( path ) ; }	Set the currently selected InvDataset.
tree path make tree path ( tree node node ) { array list < tree node > path = new array list < > ( ) ; path . add ( node ) ; tree node parent = node . get parent ( ) ; while ( parent != null ) { path . add ( num , parent ) ; parent = parent . get parent ( ) ; } object [ ] paths = path . to array ( ) ; return new tree path ( paths ) ; }	Create the TreePath corresponding to the given TreeNode.
public void open all ( boolean include catref ) { if ( catalog == null ) return ; open ( ( inv catalog tree node ) model . get root ( ) , include catref ) ; tree . repaint ( ) ; }	Open all nodes of the tree.
public void set catalog ( string location ) { catalog builder builder = new catalog builder ( ) ; try { catalog cat = builder . build from location ( location , null ) ; set catalog ( cat ) ; } catch ( exception ioe ) { j . show message dialog ( this , str + location + str + builder . get error message ( ) ) ; } }	Set the InvCatalog to display.The catalog is read asynchronously and displayed if successfully read.You must use a PropertyChangeEventListener to be notified if successful.
public void set catalog ( catalog catalog ) { if ( catalog == null ) return ; string catalog name = catalog . get base uri ( ) . to string ( ) ; this . catalog = catalog ;	Set the catalog to be displayed.
private string find alias ( netcdf dataset ds , variable v ) { string alias = ds . find att value ignore case ( v , str , null ) ; if ( alias == null ) alias = ds . find att value ignore case ( v , str , str ) ; return alias ; }	look for an coord_axis or coord_alias attribute.
public int write v ( int i ) throws io { int count = num ; while ( ( i & ~ num ) != num ) { write byte ( ( byte ) ( ( i & num ) | num ) ) ; i >>>= num ; count ++ ; } write byte ( ( byte ) i ) ; return count + num ; }	Writes an int in a variable-length format.
public int write chars ( string s , int start , int length ) throws io { final int end = start + length ; int count = num ; for ( int i = start ; i < end ; i ++ ) { final int code = ( int ) s . char at ( i ) ; if ( code >= num && code <= num ) { write byte ( ( byte ) code ) ; count ++ ; } else if ( ( ( code >= num ) && ( code <= num ) ) || code == num ) { write byte ( ( byte ) ( num | ( code > > num ) ) ) ; write byte ( ( byte ) ( num | ( code & num ) ) ) ; count += num ; } else { write byte ( ( byte ) ( num | ( code > > > num ) ) ) ; write byte ( ( byte ) ( num | ( ( code > > num ) & num ) ) ) ; write byte ( ( byte ) ( num | ( code & num ) ) ) ; count += num ; } } return count ; }	Writes a sequence of UTF-8 encoded characters from a string.
public void read chars ( char [ ] buffer , int start , int length ) throws io { final int end = start + length ; for ( int i = start ; i < end ; i ++ ) { byte b = read byte ( ) ; if ( ( b & num ) == num ) buffer [ i ] = ( char ) ( b & num ) ; else if ( ( b & num ) != num ) { buffer [ i ] = ( char ) ( ( ( b & num ) << num ) | ( read byte ( ) & num ) ) ; } else buffer [ i ] = ( char ) ( ( ( b & num ) << num ) | ( ( read byte ( ) & num ) << num ) | ( read byte ( ) & num ) ) ; } }	Reads UTF-8 encoded characters into an array.
public static void set debug flags ( ucar . nc2 . util . debug flags debug flag ) { debug read = debug flag . is set ( str ) ; debug index only = debug flag . is set ( str ) ; debug index only show = debug flag . is set ( str ) ; debug gbx index only = debug flag . is set ( str ) ; }	we are running with only ncx index files, no data.
public void add member ( member m ) { members . add ( m ) ; if ( member hash != null ) member hash . put ( m . get name ( ) , m ) ; }	Add a member.
public int hide member ( member m ) { if ( m == null ) return - num ; int index = members . index of ( m ) ; members . remove ( m ) ; if ( member hash != null ) member hash . remove ( m . get name ( ) ) ; return index ; }	Remove the given member.
public java . util . list < string > get member names ( ) { list < string > member names = new array list < > ( ) ; for ( member m : members ) { member names . add ( m . get name ( ) ) ; } return member names ; }	Get the names of the members.
public member find member ( string member name ) { if ( member name == null ) return null ; if ( member hash == null ) {	Find the member by its name.
@ nullable public byte [ ] get bitmap ( random access file raf ) throws io { if ( starting position <= num ) { throw new illegal state exception ( str ) ; } raf . seek ( starting position ) ;	Read the bitmap array when needed, return null if none.
public void restore state ( preferences ext store ) { if ( store == null ) return ; int ncols = table . get column count ( ) ;	Set the state from the last saved in the PreferencesExt.
public iterator get selected rows ( ) { tree path [ ] paths = table . get selection paths ( ) ; if ( ( paths == null ) || ( paths . length < num ) ) return null ; hash set set = new hash set ( num * paths . length ) ; for ( tree path path : paths ) { model . add rows to set from path ( table . get tree ( ) , path , set ) ; } return set . iterator ( ) ; }	Get the currently selected rows.
public int [ ] get model index ( ) { int [ ] model index = new int [ model . get column count ( ) ] ; try { table column model tcm = table . get column model ( ) ; for ( int i = num ; i < model . get column count ( ) ; i ++ ) { table column tc = tcm . get column ( i ) ; model index [ i ] = tc . get model index ( ) ; } } catch ( java . lang . array index out of bounds exception e ) {	this array translates the column index to the model index.
public array get array ( structure members . member m ) { if ( m == null ) throw new illegal argument exception ( str ) ; return member data . get ( m ) ; }	Get member data array of any type as an Array.
public double get scalar double ( structure members . member m ) { array data = get array ( m ) ; return data . get double ( index . scalar index immutable ) ; }	Get member data of type double.
public double [ ] get java array double ( structure members . member m ) { array data = get array ( m ) ; return ( double [ ] ) data . get storage ( ) ; }	Get java double array for a member of type double.
public float get scalar float ( structure members . member m ) { array data = get array ( m ) ; return data . get float ( index . scalar index immutable ) ; }	Get member data of type float.
public float [ ] get java array float ( structure members . member m ) { array data = get array ( m ) ; return ( float [ ] ) data . get storage ( ) ; }	Get java float array for a member of type float.
public byte get scalar byte ( structure members . member m ) { array data = get array ( m ) ; return data . get byte ( index . scalar index immutable ) ; }	Get member data of type byte.
public byte [ ] get java array byte ( structure members . member m ) { array data = get array ( m ) ; return ( byte [ ] ) data . get storage ( ) ; }	Get java byte array for a member of type byte.
public int get scalar int ( structure members . member m ) { array data = get array ( m ) ; return data . get int ( index . scalar index immutable ) ; }	Get member data of type int.
public int [ ] get java array int ( structure members . member m ) { array data = get array ( m ) ; return ( int [ ] ) data . get storage ( ) ; }	Get java int array for a member of type int.
public short get scalar short ( structure members . member m ) { array data = get array ( m ) ; return data . get short ( index . scalar index immutable ) ; }	Get member data of type short.
public short [ ] get java array short ( structure members . member m ) { array data = get array ( m ) ; return ( short [ ] ) data . get storage ( ) ; }	Get java short array for a member of type short.
public long get scalar long ( structure members . member m ) { array data = get array ( m ) ; return data . get long ( index . scalar index immutable ) ; }	Get member data of type long.
public long [ ] get java array long ( structure members . member m ) { array data = get array ( m ) ; return ( long [ ] ) data . get storage ( ) ; }	Get java long array for a member of type long.
public char get scalar char ( structure members . member m ) { array data = get array ( m ) ; return data . get char ( index . scalar index immutable ) ; }	Get member data of type char.
public char [ ] get java array char ( structure members . member m ) { array data = get array ( m ) ; return ( char [ ] ) data . get storage ( ) ; }	Get java char array for a member of type char.
public void do one dataset ( inv dataset ds ) { if ( debug ) system . out . println ( str + ds . get name ( ) ) ; if ( is dataset useable ( ds , mess buffer ) ) { string id = string util2 . replace ( ds . get id ( ) , str , str ) ; string file out name = file dir + str + id + str ; try { output stream out = new buffered output stream ( new file output stream ( file out name ) ) ;	Write a DIF record for a specific dataset.
public dataset copy dataset ( dataset node parent ) { return new dataset ( parent , name , flds , access builders , dataset builders ) ; }	make an immutable copy without changin DatasetBuilder.
public void transfer metadata ( dataset node from , boolean parents also ) { if ( parents also ) { thredds metadata inherit = get inheritable metadata ( ) ;	transfer all metadata, optionally also inheritable metadata from parents.
public thredds metadata get inheritable metadata ( ) { thredds metadata tmi = ( thredds metadata ) get ( dataset . thredds metadata inheritable ) ; if ( tmi == null ) { tmi = new thredds metadata ( ) ; put ( dataset . thredds metadata inheritable , tmi ) ; } return tmi ; }	get the inheritable ThreddsMetadata object. If doesnt exist, create new, empty one.
void add product ( grid record record ) { records . add ( record ) ; if ( first record == null ) { first record = record ; } }	Add in a new product.
public void show missing ( formatter f ) {	Dump out the missing data.
public int show missing summary ( formatter f ) { int count = num ; int total = record tracker . length ; for ( int i = num ; i < total ; i ++ ) { if ( record tracker [ i ] == null ) count ++ ; } f . format ( str , count , total , name ) ; return count ; }	Dump out the missing data as a summary.
public grid record find record ( int ens , int time , int level ) { if ( has ensemble ( ) ) { return record tracker [ ens * ( ntimes * nlevels ) + ( time * nlevels ) + level ] ; } else { return record tracker [ time * nlevels + level ] ; } }	Find the grid record for the time and level indicesCanonical ordering is ens, time, level.
public string dump ( ) { date formatter formatter = new date formatter ( ) ; formatter sbuff = new formatter ( ) ; sbuff . format ( str , name , records . size ( ) ) ; for ( grid record record : records ) { sbuff . format ( str , record . get level type1 ( ) , record . get level1 ( ) ) ; if ( null != record . get valid time ( ) ) sbuff . format ( str , formatter . to date time string ( record . get valid time ( ) ) ) ; sbuff . format ( str ) ; } return sbuff . to string ( ) ; }	Dump this variable.
protected string make long name ( ) { formatter f = new formatter ( ) ; grid parameter param = lookup . get parameter ( first record ) ; if ( param == null ) return null ; f . format ( str , param . get description ( ) ) ; string level name = make level name ( first record , lookup ) ; if ( level name . length ( ) != num ) f . format ( str , level name ) ; return f . to string ( ) ; }	Make a long name for the variable.
public optional < coverage coord axis > subset by intervals ( list < ma . min max > lon intvs , int stride ) { if ( axis type != axis type . lon ) return optional . empty ( str ) ; if ( ! is regular ( ) ) return optional . empty ( str ) ; coord axis helper helper = new coord axis helper ( this ) ; double start = double . n ; boolean first = bool ; list < range iterator > ranges = new array list < > ( ) ; for ( ma . min max lon intv : lon intvs ) { if ( first ) start = lon intv . min ; first = bool ; optional < range iterator > opt = helper . make range ( lon intv . min , lon intv . max , stride ) ; if ( ! opt . is present ( ) ) return optional . empty ( opt . get error message ( ) ) ; ranges . add ( opt . get ( ) ) ; } try { range composite composite range = new range composite ( axis type . lon . to string ( ) , ranges ) ; int npts = composite range . length ( ) ; double end = start + npts * resolution ; coverage coord axis builder builder = new coverage coord axis builder ( this ) ;	only for longitude, only for regular (do we need a subclass for longitude 1D coords ??.
static boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { if ( b1 == b2 ) return bool ; if ( b1 == null || b2 == null ) return bool ; if ( b1 . length < len || b2 . length < len ) return bool ; for ( int i = num ; i < len ; i ++ ) { if ( b1 [ i ] != b2 [ i ] ) return bool ; } return bool ; }	Not quite memcmp.
protected dap dataset parse dmr ( string document ) throws dap exception {	It is common to want to parse a DMR text to a DapDataset,so provide this utility.
protected void process attributes ( dap dataset dataset ) throws dap exception { list < dap node > nodes = dataset . get node list ( ) ; for ( dap node node : nodes ) { switch ( node . get sort ( ) ) { case group : case dataset : case variable : map < string , dap attribute > attrs = node . get attributes ( ) ; if ( attrs . size ( ) > num ) { list < dap attribute > suppressed = new array list < > ( ) ; for ( dap attribute dattr : attrs . values ( ) ) { if ( suppress ( dattr . get short name ( ) ) ) suppressed . add ( dattr ) ; } for ( dap attribute dattr : suppressed ) { node . remove attribute ( dattr ) ; } } break ; default : break ; } }	Walk the dataset tree and remove selected attributessuch as _Unsigned.
public void add coords ( list < coordinate > coords , partition collection mutable . partition part ) { coordinate runtime = null ; for ( coordinate coord : coords ) { switch ( coord . get type ( ) ) { case runtime : coordinate runtime rtime = ( coordinate runtime ) coord ; if ( runtime builder == null ) runtime builder = new coordinate runtime . builder2 ( rtime . get time units ( ) ) ; runtime builder . add all ( coord ) ; runtime = coord ; if ( debug partition errors && ! duplicate runtime message && part != null ) test duplicate runtime ( rtime , part ) ; break ; case time : coordinate time time = ( coordinate time ) coord ; if ( time builder == null ) time builder = new coordinate time . builder2 ( coord . get code ( ) , time . get time unit ( ) , time . get ref date ( ) ) ; time builder . add all ( coord ) ; break ; case time intv : coordinate time intv time intv = ( coordinate time intv ) coord ; if ( time intv builder == null ) time intv builder = new coordinate time intv . builder2 ( null , coord . get code ( ) , time intv . get time unit ( ) , time intv . get ref date ( ) ) ; time intv builder . add all ( interval filter ( ( coordinate time intv ) coord ) ) ; break ; case time2 d : d time2 d = ( d ) coord ; if ( time2 d == null ) time2 d = new d ( time2 d . is time interval ( ) , time2 d . get time unit ( ) , coord . get code ( ) , bool , logger ) ; time2 d . add all ( time2 d ) ;	only one message per CoordinatePartitionUnionizer instance.
public void set gaussian lats ( int nparallels , float la1 , float la2 ) { log . debug ( str , la1 , la2 ) ; if ( this . gauss lats != null ) throw new runtime exception ( str ) ; int nlats = ( num * nparallels ) ; gaussian latitudes gauss lats = gaussian latitudes . factory ( nlats ) ; int best start index = num , best end index = num ; double best start diff = double . max value ; double best end diff = double . max value ; for ( int i = num ; i < nlats ; i ++ ) { double diff = math . abs ( gauss lats . latd [ i ] - la1 ) ; if ( diff < best start diff ) { best start diff = diff ; best start index = i ; } diff = math . abs ( gauss lats . latd [ i ] - la2 ) ; if ( diff < best end diff ) { best end diff = diff ; best end index = i ; } } log . debug ( str , best start index , best end index ) ; if ( math . abs ( best end index - best start index ) + num != ny raw ) { log . warn ( str ) ;	some weird adjustment for la1 and la2.
private static parsed section spec parse variable selector ( object parent , string selector ) throws invalid range exception { string var name esc , index select = null ; int pos1 = escape strings . index of ( selector , str ) ; if ( pos1 < num ) {	parse variable name and index selector out of the selector String. variable name must be escaped.
public static string make section spec string ( variable v , list < range > ranges ) throws invalid range exception { string builder sb = new string builder ( ) ; make spec ( sb , v , ranges ) ; return sb . to string ( ) ; }	Make section specification String from a range list for a Variable.
private boolean box9 ( double want lat , double want lon , int [ ] rect index ) { int row = rect index [ num ] ; int minrow = math . max ( row - num , num ) ; int maxrow = math . min ( row + num , nrows ) ; int col = rect index [ num ] ; int mincol = math . max ( col - num , num ) ; int maxcol = math . min ( col + num , ncols ) ; if ( debug ) system . out . printf ( str ) ; for ( int i = minrow ; i <= maxrow ; i ++ ) for ( int j = mincol ; j <= maxcol ; j ++ ) { rect index [ num ] = i ; rect index [ num ] = j ; if ( contains ( want lat , want lon , rect index ) ) return bool ; } return bool ; }	we think its got to be in one of the 9 boxes around rectIndex.
public synchronized void close ( ) { if ( closed ) return ;	Calling close will force the method to close, and willforce any open stream to terminate.
public int execute ( ) throws http { http response res = execute raw ( ) ; if ( res != null ) return res . get status line ( ) . get status code ( ) ; else throw new http ( str ) ; }	Create a request, add headers, and content,then send to HTTPSession to do the bulk of the work.
protected boolean identify encoding station ( netcdf dataset ds , encoding info info , cf . feature type ftype , formatter errlog ) {	for stations, figure out the encoding.
protected string match axis type and dimension ( netcdf dataset ds , axis type type , final dimension outer ) { variable var = coord sys evaluator . find coord by type ( ds , type , new coord sys evaluator . predicate ( ) { public boolean match ( coordinate axis axis ) { if ( ( outer == null ) && ( axis . get rank ( ) == num ) ) return bool ; if ( ( outer != null ) && ( axis . get rank ( ) == num ) && ( outer . equals ( axis . get dimension ( num ) ) ) ) return bool ;	class, I don't understand enough of the code base to anticipate implementation artifacts.
public void set stream ( input stream z stream ) { last = num ; orig ptr = num ; block size100k = num ; block randomised = bool ; bs buff = num ; bs live = num ; m crc = new crc ( ) ; n in use = num ; bs stream = null ; stream end = bool ; current char = - num ; current state = start block state ; stored block crc = stored combined crc = num ; computed block crc = computed combined crc = num ; i2 = count = ch prev = ch2 = num ; i = t pos = num ; r n = num ; r t = num ; j2 = num ; z = num ; bs set stream ( z stream ) ; initialize ( ) ; if ( ! stream end ) {	Added 5-30-2006 to allow for resetting of the input usedby this object. This saves in memory allocation costs.
public int read ( ) { if ( stream end ) { return - num ; } else { int ret char = current char ; switch ( current state ) { case start block state : break ; case rand part a state : break ; case rand part b state : setup rand part b ( ) ; break ; case rand part c state : setup rand part c ( ) ; break ; case no rand part a state : break ; case no rand part b state : setup no rand part b ( ) ; break ; case no rand part c state : setup no rand part c ( ) ; break ; default : break ; } return ret char ; } }	Reads the stream.
public void start ( java . awt . component top , string task name , int progress max count ) {	Call this from awt event thread.The task is run in a background thread.
static public uri parse to uri ( final string u ) throws uri { string builder buf = new string builder ( ) ; int i = num ; while ( i < u . length ( ) ) { char c = u . char at ( i ) ; if ( c == str ) { if ( i + num == u . length ( ) ) throw new uri ( u , str ) ; buf . append ( str ) ; i ++ ; c = u . char at ( i ) ; buf . append ( string . format ( str , ( int ) c ) ) ; } else buf . append ( c ) ; i ++ ; } return new uri ( buf . to string ( ) ) ; }	Convert a uri string to an instance of java.net.URI.The critical thing is that this procedure can handle backslashescaped uris as well as %xx escaped uris.
static uri uri exclude ( final uri uri , uri ... excludes ) { uri urib = new uri ( ) ; enum set < uri > set = enum set . of ( excludes [ num ] , excludes ) ; for ( uri part : uri . values ( ) ) { if ( set . contains ( part ) ) continue ; switch ( part ) { case scheme : urib . set scheme ( uri . get scheme ( ) ) ; break ; case userinfo : urib . set user info ( uri . get user info ( ) ) ; break ; case host : urib . set host ( uri . get host ( ) ) ; break ; case port : urib . set port ( uri . get port ( ) ) ; break ; case path : urib . set path ( uri . get path ( ) ) ; break ; case query : urib . set custom query ( uri . get query ( ) ) ; break ; case fragment : urib . set fragment ( uri . get fragment ( ) ) ; break ; } } try { return urib . build ( ) ; } catch ( uri e ) { throw new illegal argument exception ( e . get message ( ) ) ; } }	Remove selected fields from a URI producing a new URI.
static public string nullify ( string s ) { if ( s != null && s . length ( ) == num ) s = null ; return s ; }	Convert a zero-length string to null.
static public string canonjoin ( string prefix , string suffix ) { if ( prefix == null ) prefix = str ; if ( suffix == null ) suffix = str ; prefix = http . canonicalpath ( prefix ) ; suffix = http . canonicalpath ( suffix ) ; string builder result = new string builder ( ) ; result . append ( prefix ) ; int prelen = prefix . length ( ) ; if ( prelen > num && result . char at ( prelen - num ) != str ) { result . append ( str ) ; prelen ++ ; } if ( suffix . length ( ) > num && suffix . char at ( num ) == str ) result . append ( suffix . substring ( num ) ) ; else result . append ( suffix ) ; int len = result . length ( ) ; if ( len > num && result . char at ( len - num ) == str ) { result . delete char at ( len - num ) ; len -- ; } return result . to string ( ) ; }	Join two string together to form proper pathWITHOUT trailing slash.
public boolean accept ( crawlable dataset dataset ) { date last mod date = dataset . last modified ( ) ; if ( last mod date != null ) { long now = system . current time millis ( ) ; if ( now - last mod date . get time ( ) > last modified limit in millis ) return bool ; } return bool ; }	Accept datasets whose last modified date is at least thelast modified limit of milliseconds in the past.
void copy info ( grib collection mutable from ) { this . center = from . center ; this . subcenter = from . subcenter ; this . master = from . master ; this . local = from . local ; this . gen process type = from . gen process type ; this . gen process id = from . gen process id ; this . back process id = from . back process id ; }	for making partition collection.
public list < string > get filenames ( ) { list < string > result = new array list < > ( ) ; for ( m file : file map . values ( ) ) result . add ( file . get path ( ) ) ; collections . sort ( result ) ; return result ; }	The files that comprise the collection.Actual paths, including the grib cache if used.
void set index raf ( random access file index raf ) { this . index raf = index raf ; if ( index raf != null ) { this . index filename = index raf . get location ( ) ; } }	public by accident, do not use.
private string get index filepath in cache ( ) { file index file = grib cdm index . make index file ( name , directory ) ; return grib index cache . get file or cache ( index file . get path ( ) ) . get path ( ) ; }	get index filename.
public int ncounters ( ) { if ( nested == null ) return num ; else { int ncounters = num ; for ( bit counter compressed [ ] counters : nested ) { if ( counters == null ) continue ; for ( bit counter compressed counter : counters ) if ( counter != null ) ncounters += counter . ncounters ( ) ; } return ncounters ; } }	Number of nested fields.
public attribute add global attribute ( string name , string value ) { return add global attribute ( new attribute ( name , value ) ) ; }	Add a Global attribute of type String to the file.
public attribute add global attribute ( string name , array values ) { return add global attribute ( new attribute ( name , values ) ) ; }	Add a Global attribute of type Array to the file.
public attribute delete global attribute ( string att name ) { if ( ! define mode ) throw new unsupported operation exception ( str ) ; attribute att = find global attribute ( att name ) ; if ( null == att ) return null ; root group . remove ( att ) ; return att ; }	Delete a global Attribute.
public attribute rename global attribute ( string old name , string new name ) { if ( ! define mode ) throw new unsupported operation exception ( str ) ; attribute att = find global attribute ( old name ) ; if ( null == att ) return null ; root group . remove ( att ) ; att = new attribute ( new name , att . get values ( ) ) ; root group . add attribute ( att ) ; return att ; }	Rename a global Attribute.
public void add variable attribute ( string var name , string att name , string value ) { add variable attribute ( var name , new attribute ( att name , value ) ) ; }	Add an attribute of type String to the named Variable.
public void add variable attribute ( string var name , string att name , array value ) { attribute att = new attribute ( att name , value ) ; add variable attribute ( var name , att ) ; }	Add an attribute of type Array to the named Variable.
public attribute delete variable attribute ( string var name , string att name ) { if ( ! define mode ) throw new unsupported operation exception ( str ) ; variable v = find variable ( var name ) ; if ( v == null ) return null ; attribute att = v . find attribute ( att name ) ; if ( null == att ) return null ; v . remove ( att ) ; return att ; }	Delete a variable Attribute.
public attribute rename variable attribute ( string var name , string att name , string new name ) { if ( ! define mode ) throw new unsupported operation exception ( str ) ; variable v = find variable ( var name ) ; if ( v == null ) return null ; attribute att = v . find attribute ( att name ) ; if ( null == att ) return null ; v . remove ( att ) ; att = new attribute ( new name , att . get values ( ) ) ; v . add attribute ( att ) ; return att ; }	Rename a variable Attribute.
protected void make file sub type ( ) {	Set the file subType.
private void write headers and bb ( ) { file output += str + wfsxml . enc quotes ( str + namespace + str + server + str + wfsxml . ampersand + str + wfsxml . ampersand + str + wfsxml . ampersand + str + wfs . tdsnamespace + str + ft name ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( str ) + str + wfs . tdsnamespace + str + wfsxml . enc quotes ( namespace ) + str + wfsxml . enc quotes ( str ) + str + wfsxml . enc quotes ( string . value of ( geometries . size ( ) ) ) + str + wfsxml . enc quotes ( string . value of ( geometries . size ( ) ) ) + str ; double [ ] bound lower ; double [ ] bound upper ; if ( geometries . is empty ( ) ) { bound lower = new double [ num ] ; bound upper = new double [ num ] ; bound lower [ num ] = - num ; bound lower [ num ] = - num ; bound upper [ num ] = num ; bound upper [ num ] = num ; } else { bound lower = geometries . get ( num ) . get bb ( ) ; bound upper = geometries . get ( num ) . get bb ( ) ; }	Writes headers and bounding box.
public void write members ( ) { int index = num ; gml writer = new gml ( ) ; for ( simple geometry geometry item : geometries ) {	In the WFS specification for GetFeature each feature type is its ownmember and so writeMembers add each member to the fileOutput.
public string write station obs dataset xml ( ) { xml fmt = new xml ( format . get pretty format ( ) ) ; return fmt . output string ( make station obs dataset document ( ) ) ; }	Write stationObsDataset XML document.
public string write station collection xml ( ) throws io { xml fmt = new xml ( format . get pretty format ( ) ) ; return fmt . output string ( make station collection document ( ) ) ; }	Write stationCollection XML document.
public void write dsr ( string dsr ) throws io { if ( state != state . initial ) throw new dap exception ( str ) ; if ( dsr == null ) throw new dap exception ( str ) ;	Write the DSR; do not bother to cache.
void send dxr ( byte [ ] dxr8 ) throws io { if ( dxr8 == null || dxr8 . length == num ) return ;	Output the specifiedd DMR or DSR or..., but xml only.
public void write error ( int httpcode , string msg , string cxt , string other ) throws io { dmr8 = null ; error response response = new error response ( httpcode , msg , cxt , other ) ; string errorbody = response . build xml ( ) ;	Write an error chunk.If mode == DMR then replaces the dmrelse reset the current chunk thuslosing any partial write.
public void close ( ) throws io { if ( closed ) return ; closed = bool ; if ( dmr8 != null ) { send dxr ( dmr8 ) ; dmr8 = null ; } if ( mode == request mode . dmr ) return ;	Closes this output stream and releases any system resourcesassociated with this stream. Except, the underlying stream is notactually closed; that is left to the servlet level.
@ override public void flush ( ) throws io { if ( mode == request mode . dmr ) return ;	Overload flush to also write out the DMR.
public boolean contains ( int want ) { if ( want < first ( ) ) return bool ; if ( want > last ( ) ) return bool ; if ( stride == num ) return bool ; return ( want - first ) % stride == num ; }	Is want contained in this Range?.
public int element ( int i ) throws invalid range exception { if ( i < num ) throw new invalid range exception ( str ) ; if ( i >= length ) throw new invalid range exception ( str ) ; return first + i * stride ; }	Get ith element.
public range shift origin ( int origin ) throws invalid range exception { if ( this == vlen ) return vlen ; int first = first ( ) - origin ; int last = last ( ) - origin ; return new range ( name , first , last , stride ) ; }	Create a new Range shifting this range by a constant factor.
protected object read data ( layout index , data type data type ) throws java . io . io { return iosp helper . read data fill ( raf , index , data type , null , - num ) ; }	Read data subset from file for a variable, create primitive array.
protected long read data ( layout index , data type data type , writable byte channel out ) throws java . io . io { long count = num ; if ( data type . get primitive class type ( ) == byte . class || data type == data type . char ) { while ( index . has next ( ) ) { layout . chunk chunk = index . next ( ) ; count += raf . read to byte channel ( out , chunk . get src pos ( ) , chunk . get nelems ( ) ) ; } } else if ( data type . get primitive class type ( ) == short . class ) { while ( index . has next ( ) ) { layout . chunk chunk = index . next ( ) ; count += raf . read to byte channel ( out , chunk . get src pos ( ) , num * chunk . get nelems ( ) ) ; } } else if ( data type . get primitive class type ( ) == int . class || ( data type == data type . float ) ) { while ( index . has next ( ) ) { layout . chunk chunk = index . next ( ) ; count += raf . read to byte channel ( out , chunk . get src pos ( ) , num * chunk . get nelems ( ) ) ; } } else if ( ( data type == data type . double ) || data type . get primitive class type ( ) == long . class ) { while ( index . has next ( ) ) { layout . chunk chunk = index . next ( ) ; count += raf . read to byte channel ( out , chunk . get src pos ( ) , num * chunk . get nelems ( ) ) ; } } return count ; }	Read data subset from file for a variable, to WritableByteChannel.Will send as bigendian, since thats what the underlying file has.
public primitive vector subset ( int start , int stop , int stride ) { boolean primitive vector n = new boolean primitive vector ( get template ( ) ) ; stride = math . max ( stride , num ) ; stop = math . max ( start , stop ) ; int length = num + ( stop - start ) / stride ; n . set length ( length ) ; int count = num ; for ( int i = start ; i <= stop ; i += stride ) { n . set value ( count , vals [ i ] ) ; count ++ ; } return n ; }	Create a new primitive vector using a subset of the data.
public void set values ( float [ ] values ) { vals = values ; proj = gempak util . st itoc ( float . float to int bits ( vals [ num ] ) ) . trim ( ) ; add param ( proj , proj ) ; add param ( gds key , this . to string ( ) ) ; set params ( ) ; }	Set the grid nav block values.
private double [ ] make double array ( int [ ] ints ) { double [ ] new array = new double [ ints . length ] ; for ( int i = num ; i < ints . length ; i ++ ) { new array [ i ] = ints [ i ] ; } return new array ; }	make a double array out of an int array.
@ request mapping ( str ) public void get dataset boundaries ( ncss params bean params , http servlet request req , http servlet response res ) throws io , unsupported response format exception { supported format format = supported operation . dataset boundaries request . get supported format ( params . get accept ( ) ) ; switch ( format ) { case wkt : get dataset boundaries wkt ( req , res ) ; break ; case json : get dataset boundaries geo json ( req , res ) ; break ; default : throw new illegal argument exception ( string . format ( str , supported format . wkt , supported format . json , format ) ) ; } }	Supported for backwards compatibility.
private void check requested vars ( coverage collection gcd , ncss grid params bean params ) throws variable not contained in dataset exception {	Checks that all the requested vars exist.
public static dataset source structure get structure ( string name ) { if ( name == null ) return null ; return ( dataset source structure ) hash . get ( name ) ; }	Find the DatasetSourceStructure that matches this name.
@ override public string get resource path ( dap request drq , string location ) throws dap exception { string realpath ; if ( tds requested dataset . get dataset manager ( ) != null ) { realpath = tds requested dataset . get location from request path ( location ) ; } else { assert tds requested dataset . get dataset manager ( ) == null ; string prefix = drq . get resource root ( ) ; assert ( prefix != null ) ; realpath = dap util . canonjoin ( prefix , location ) ; } if ( ! testing ) { if ( ! tds requested dataset . resource control ok ( drq . get request ( ) , drq . get response ( ) , realpath ) ) throw new dap exception ( str + location ) . set code ( dap codes . sc forbidden ) ; } file f = new file ( realpath ) ; if ( ! f . exists ( ) || ! f . can read ( ) ) throw new dap exception ( str + location ) . set code ( dap codes . sc not found ) ;	to work under Intellij.
private void make vertical dimensions ( list < grid vert coord > vert coord list , netcdf file ncfile , group group ) {	Make a vertical dimensions.
boolean read pib ( random access file raf ) throws io { this . first header = new awx file first header ( ) ; int pos = num ; raf . seek ( pos ) ;	Read the header and populate the ncfile.
public boolean finish ( ) { boolean ok = bool ; java . util . iterator iter ; logger . debug ( str + get name ( ) + str + get id ( ) ) ; authority name = null ; data type = null ; data format type = null ; default service = null ; gc = null ; tc = null ; docs = new array list < > ( ) ; metadata = new array list < > ( ) ; properties = new array list < > ( ) ; creators = new array list < > ( ) ; contributors = new array list < > ( ) ; dates = new array list < > ( ) ; keywords = new array list < > ( ) ; projects = new array list < > ( ) ; publishers = new array list < > ( ) ; variables = new array list < > ( ) ; canonicalize ( ) ;	Finish constructing after all elements have been added.This does the inheritence thingThis can be called again if new elements are added.
private void transfer inheritable2 public metadata ( inv dataset impl parent ) { if ( parent == null ) return ; logger . debug ( str + parent . get id ( ) ) ; transfer2 public metadata ( parent . get local metadata inheritable ( ) , bool ) ;	Look for InvMetadata elements in the parent that need to be added to the public metadata of this dataset.Recurse up through all ancestors.
public void transfer metadata ( inv dataset impl from ds , boolean copy inherited metadata from parents ) { if ( from ds == null ) return ; logger . debug ( str + from ds . get name ( ) ) ; if ( this != from ds ) get local metadata ( ) . add ( from ds . get local metadata ( ) , bool ) ; transfer inheritable metadata ( from ds , get local metadata inheritable ( ) , copy inherited metadata from parents ) ; set resource control ( from ds . get restrict access ( ) ) ; }	Transfer all inheritable metadata from fromDs to the local metadata of this dataset.Called by InvDatasetScan to transfer inheritable metaddata to the nested catalogRef.
private void transfer inheritable metadata ( inv dataset impl from ds , thredds metadata target , boolean copy inherited metadata from parents ) { if ( from ds == null ) return ; logger . debug ( str + from ds . get name ( ) ) ; target . add ( from ds . get local metadata inheritable ( ) , bool ) ;	transfer inherited metadata, consolidating it into target.
public void set contributors ( list < thredds metadata . contributor > a ) { list < thredds metadata . contributor > dest = tm . get contributors ( ) ; for ( thredds metadata . contributor item : a ) { if ( ! dest . contains ( item ) ) dest . add ( item ) ; } hash code = num ; }	LOOK these are wrong.
public void add dataset ( int index , inv dataset impl ds ) { if ( ds == null ) return ; ds . set parent ( this ) ; datasets . add ( index , ds ) ; hash code = num ; }	Add a nested dataset at the location indicated by index.
public boolean remove dataset ( inv dataset impl ds ) { if ( this . datasets . remove ( ds ) ) { ds . set parent ( null ) ; inv catalog impl cat = ( inv catalog impl ) get parent catalog ( ) ; if ( cat != null ) cat . remove dataset by id ( ds ) ; return ( bool ) ; } return ( bool ) ; }	Remove the given dataset element from this dataset if it is in the dataset.
public boolean replace dataset ( inv dataset impl remove , inv dataset impl add ) { for ( int i = num ; i < datasets . size ( ) ; i ++ ) { inv dataset dataset = datasets . get ( i ) ; if ( dataset . equals ( remove ) ) { datasets . set ( i , add ) ; inv catalog impl cat = ( inv catalog impl ) get parent catalog ( ) ; if ( cat != null ) { cat . remove dataset by id ( remove ) ; cat . add dataset by id ( add ) ; } return bool ; } } return bool ; }	Replace the given dataset if it is a nesetd dataset.
public void add service ( inv service service ) {	Add a service to this dataset.
public void remove service ( inv service service ) { services local . remove ( service ) ; services . remove ( service ) ;	Remove a service from this dataset.
public void set services local ( java . util . list < inv service > s ) { this . services = new array list < > ( ) ; this . services local = new array list < > ( ) ; for ( inv service elem : s ) { add service ( elem ) ; } hash code = num ; }	Set the list of services attached specifically to this dataset.Discard any previous servies.
public boolean remove local metadata ( inv metadata metadata ) { inv dataset impl parent dataset = ( ( inv dataset impl ) metadata . get parent dataset ( ) ) ; list local mdata = parent dataset . get local metadata ( ) . get metadata ( ) ; if ( local mdata . contains ( metadata ) ) { if ( local mdata . remove ( metadata ) ) { hash code = num ;	Remove the given InvMetadata from the set of metadata local to this dataset.
public object get user property ( object key ) { if ( user map == null ) return null ; return user map . get ( key ) ; }	Look up the User property having the given key.
boolean validate ( string builder out ) { this . is valid = bool ;	Validate this DatasetNamer object.
public final list < string > get descriptors ( ) { list < string > desc = new array list < string > ( ) ; for ( short fxy : descriptors ) desc . add ( descriptor . make string ( fxy ) ) ; return desc ; }	get list of data descriptors as Strings.
public static string construct server path ( http servlet request hsreq ) { return hsreq . get scheme ( ) + str + hsreq . get server name ( ) + str + hsreq . get server port ( ) + str ; }	Constructs the full server URI from a request.
private void get capabilities ( print writer out , http servlet request hsreq , cs sgcs ) { wfs gcdw = new wfs ( out , wfs . construct server path ( hsreq ) ) ; gcdw . start xml ( ) ; gcdw . add operation ( wfs . get capabilities ) ; gcdw . add operation ( wfs . describe feature type ) ; gcdw . add operation ( wfs . get feature ) ; gcdw . write operations ( ) ; list < string > series names = sgcs . get geometry series names ( ) ; for ( string name : series names ) { gcdw . add feature ( new wfs ( tdsnamespace + str + name , name ) ) ; } gcdw . write feature types ( ) ; gcdw . finish xml ( ) ; }	Processes GetCapabilities requests.
private wfs get feature ( print writer out , http servlet request hsreq , cs sgcs , string ft name , string full ft name ) { list < simple geometry > geometry list = new array list < simple geometry > ( ) ; geometry type geo t = sgcs . get geometry type ( ft name ) ; if ( geo t == null ) { return new wfs ( str + full ft name + str , str , str ) ; } try { switch ( geo t ) { case point : point pt = sgcs . get point ( ft name , num ) ; int j = num ; while ( pt != null ) { geometry list . add ( pt ) ; j ++ ; pt = sgcs . get point ( ft name , j ) ; } break ; case line : line line = sgcs . get line ( ft name , num ) ; int k = num ; while ( line != null ) { geometry list . add ( line ) ; k ++ ; line = sgcs . get line ( ft name , k ) ; } break ; case polygon : polygon poly = sgcs . get polygon ( ft name , num ) ; int i = num ; while ( poly != null ) { geometry list . add ( poly ) ; i ++ ; poly = sgcs . get polygon ( ft name , i ) ; } break ; } }	Processes GetFeature requests.
private wfs check parameters for error ( string request , string version , string service , string type name ) {	Checks request parameters for errors.Will send back an XML Exception if any errors are encountered.
@ request mapping ( str ) public void http handler ( http servlet request hsreq , http servlet response hsres ) { try { print writer wr = hsres . get writer ( ) ; list < string > param names = new linked list < string > ( ) ; enumeration < string > param names e = hsreq . get parameter names ( ) ; while ( param names e . has more elements ( ) ) param names . add ( param names e . next element ( ) ) ;	A handler for WFS based HTTP requests that sends to other request handlersto handle the request.Servlet Path: /wfs/{request}.
public string get capabilities ( string url ) throws io {	Provide a method for getting the capabilities document.
@ override public long length ( ) {	Returns the size of the dataset, in bytes.
@ override public date last modified ( ) { s3 object summary object summary = object summary cache . get if present ( s3uri ) ; if ( object summary != null ) { return object summary . get last modified ( ) ; } object metadata metadata = thredds s3 client . get object metadata ( s3uri ) ; if ( metadata != null ) { return metadata . get last modified ( ) ; } else {	Returns the date that the dataset was last modified.
public static void return file ( http servlet servlet , string content path , string path , http servlet request req , http servlet response res , string content type ) throws io { string filename = servlet util . form filename ( content path , path ) ; log . debug ( str + filename + str ) ;	Write a file to the response stream.
public static void return string ( string contents , http servlet response res ) throws io { try { servlet output stream out = res . get output stream ( ) ; io . copy ( new byte array input stream ( contents . get bytes ( cdm . utf8 charset ) ) , out ) ; } catch ( io e ) { log . error ( str , e ) ; res . send error ( http servlet response . sc not found , str + e . get message ( ) ) ; } }	Send given content string as the HTTP response.
public static int set response content length ( http servlet response response , string s ) throws unsupported encoding exception { int length = s . get bytes ( response . get character encoding ( ) ) . length ; response . set content length ( length ) ; return length ; }	Set the proper content length for the string.
public static uri get request uri ( http servlet request req ) { try { return new uri ( get request base ( req ) ) ; } catch ( uri e ) { e . print stack trace ( ) ; return null ; } }	The request base as a URI.
public static string get request path ( http servlet request req ) { string builder buff = new string builder ( ) ; if ( req . get servlet path ( ) != null ) buff . append ( req . get servlet path ( ) ) ; if ( req . get path info ( ) != null ) buff . append ( req . get path info ( ) ) ; return buff . to string ( ) ; }	servletPath + pathInfo.
public static string get request ( http servlet request req ) { string query = req . get query string ( ) ; return get request base ( req ) + ( query == null ? str : str + query ) ; }	The entire request including query string.
public static string get parameter ignore case ( http servlet request req , string param name ) { enumeration e = req . get parameter names ( ) ; while ( e . has more elements ( ) ) { string s = ( string ) e . next element ( ) ; if ( s . equals ignore case ( param name ) ) return req . get parameter ( s ) ; } return null ; }	Return the value of the given parameter for the given request.
public void save ( ) { if ( cat list box != null ) cat list box . save ( ) ; if ( prefs != null ) { if ( file chooser != null ) file chooser . save ( ) ; if ( catgen file chooser != null ) catgen file chooser . save ( ) ; prefs . put int ( hdivider , split . get divider location ( ) ) ; } }	Save persistent state.
public int write directory ( http servlet response res , file dir , string path ) throws io {	Write a file directory.
public bit counter uncompressed make nested ( data descriptor sub key , int n , int row , int replication count size ) { if ( sub counters == null ) sub counters = new hash map < data descriptor , bit counter uncompressed [ ] > ( num ) ;	Track nested Tables.
int count bits ( int start bit ) { count bits = replication count size ; this . start bit = new int [ nrows ] ; for ( int i = num ; i < nrows ; i ++ ) { this . start bit [ i ] = start bit + count bits ; if ( debug ) system . out . println ( str + i + str + this . start bit [ i ] ) ; for ( data descriptor nd : parent . sub keys ) { bit counter uncompressed [ ] bit counter = ( sub counters == null ) ? null : sub counters . get ( nd ) ; if ( bit counter == null )	total bits of this table and all subtables.
public void append line ( string line ) { if ( count >= nlines ) { try { int remove = math . max ( remove incr , count - nlines ) ;	Append this line to the bottom of the JTextArea.A newline is added and JTextArea is scrolled to bottom;remove lines at top if needed.
public document make station collection document ( lat lon rect bb , string [ ] names ) throws io { list < dsg feature collection > list = fdp . get point feature collection list ( ) ; dsg feature collection fc = list . get ( num ) ;	Create an XML document for the stations in this dataset, possible subsetted by bb.Must be a station dataset.
public document get capabilities document ( ) { element root elem = new element ( str ) ; document doc = new document ( root elem ) ; if ( null != path ) { root elem . set attribute ( str , path ) ; element elem = new element ( str ) ; feature type ft = fdp . get feature type ( ) ; elem . set attribute ( str , ft . to string ( ) . to lower case ( ) ) ; string url = path . replace ( str , ft . to string ( ) . to lower case ( ) + str ) ; elem . set attribute ( str , url ) ; root elem . add content ( elem ) ; } list < dsg feature collection > list = fdp . get point feature collection list ( ) ; dsg feature collection fc = list . get ( num ) ;	Create the capabilities XML document for this dataset.
@ nullable synchronized record get record at ( subset params coords ) { int [ ] want = new int [ get rank ( ) ] ; int count = num ; int run idx = - num ; for ( coordinate coord : get coordinates ( ) ) { int idx = - num ; switch ( coord . get type ( ) ) { case runtime : calendar date runtime cooord = coords . get run time ( ) ; idx = coord . get index ( runtime cooord ) ; run idx = idx ; break ; case time intv : double [ ] time intv = coords . get time offset intv ( ) ; idx = coord . get index ( new time coord intv value ( ( int ) time intv [ num ] , ( int ) time intv [ num ] ) ) ; break ; case time : double time offset = coords . get time offset ( ) ;	coord based record finding. note only one record at a time.
public coordinate get coordinate ( int index ) { int grp index = coord index . get ( index ) ; return group . coords . get ( grp index ) ; }	get the ith coordinate.
public void add item ( object item ) { if ( item == null ) return ; for ( int i = num ; i < get item count ( ) ; i ++ ) { if ( item . equals ( get item at ( i ) ) ) { if ( i == num ) { set selected index ( num ) ; return ;	Add the item to the top of the list.
@ exception handler ( throwable . class ) public response entity < string > handle ( throwable ex ) throws throwable {	LOOK this could be a problem.
public int step ( int firstpos , int lastpos ) { for ( int i = lastpos - num ; i >= firstpos ; i -- ) {	return -1 if we have completed.
@ nullable public static map < integer , string > get ncep gen process ( ) { if ( gen process map != null ) return gen process map ; string path = str ; try ( input stream is = grib resource reader . get input stream ( path ) ) { sax builder = new sax ( ) ; org . jdom2 . document doc = builder . build ( is ) ; element root = doc . get root element ( ) ; hash map < integer , string > result = new hash map < > ( num ) ; list < element > params = root . get children ( str ) ; for ( element elem1 : params ) { int code = integer . parse int ( elem1 . get attribute value ( str ) ) ; string desc = elem1 . get child text ( str ) ; result . put ( code , desc ) ; } return collections . unmodifiable map ( result ) ;	public so can be called from Grib2.
public static feature type is cdmrf endpoint ( string endpoint ) throws io { http http client = http . new session ( endpoint ) ; string url = endpoint + str ;	all CdmrFeatureDatasets must return their featureType - use as a fail-fast test of the endpoint.
public void set has value ( int type ) { this . type = type ; if ( debug ) { system . out . println ( str + ( char ) sw + str + type + str + set + str + val ) ; } }	Set the value type of the option switch to the type passed.
public static grib1 gds factory ( int center , int grid number ) { if ( center == num ) { return factory ncep ( grid number ) ; } else throw new illegal argument exception ( str + grid number + str + center ) ; }	Constructs a Grib1Gds object from a pds and predefined tables.
static public long copy b ( input stream in , output stream out , int buffer size ) throws io { long total bytes read = num ; int done = num , next = num ; byte [ ] buffer = new byte [ buffer size ] ; while ( bool ) { int n = in . read ( buffer ) ; if ( n == - num ) break ; out . write ( buffer , num , n ) ; total bytes read += n ; if ( show copy ) { done += n ; if ( done > num * num * next ) { system . out . println ( next + str ) ; next ++ ; } } } out . flush ( ) ; return total bytes read ; }	copy all bytes from in to out, specify buffer size.
static public string read contents ( input stream is , string charset ) throws io { byte array output stream bout = new byte array output stream ( num * default file buffersize ) ; io . copy ( is , bout ) ; return bout . to string ( charset ) ; }	Read the contents from the inputStream and place into a String,with any error messages put in the return String.
static public byte [ ] read contents to byte array ( input stream is ) throws io { byte array output stream bout = new byte array output stream ( num * default file buffersize ) ; io . copy ( is , bout ) ; return bout . to byte array ( ) ; }	Read the contents from the inputStream and place into a byte array,with any error messages put in the return String.
static public void write contents ( string contents , output stream os ) throws io { byte array input stream bin = new byte array input stream ( contents . get bytes ( cdm . utf8 charset ) ) ; io . copy ( bin , os ) ; }	Wite the contents from the String to a Stream,.
static public void copy file b ( file file in , output stream out , int buffer size ) throws io { try ( file input stream fin = new file input stream ( file in ) ) { input stream in = new buffered input stream ( fin ) ; io . copy b ( in , out , buffer size ) ; } }	copy file to output stream, specify internal buffer size.
static public long copy raf b ( ucar . unidata . io . random access file raf , long offset , long length , output stream out , byte [ ] buffer ) throws io { int buffer size = buffer . length ; long want = length ; raf . seek ( offset ) ; while ( want > num ) { int len = ( int ) math . min ( want , buffer size ) ; int bytes read = raf . read ( buffer , num , len ) ; if ( bytes read <= num ) break ; out . write ( buffer , num , bytes read ) ; want -= bytes read ; } out . flush ( ) ; return length - want ; }	Copy part of a RandomAccessFile to output stream, specify internal buffer size.
static public void copy dir tree ( string from dir name , string to dir name ) throws io { file from dir = new file ( from dir name ) ; file to dir = new file ( to dir name ) ; if ( ! from dir . exists ( ) ) return ; if ( ! to dir . exists ( ) ) { if ( ! to dir . mkdirs ( ) ) { throw new io ( str + to dir ) ; } } file [ ] files = from dir . list files ( ) ; if ( files != null ) for ( file f : files ) { if ( f . is directory ( ) ) copy dir tree ( f . get absolute path ( ) , to dir . get absolute path ( ) + str + f . get name ( ) ) ; else copy file ( f . get absolute path ( ) , to dir . get absolute path ( ) + str + f . get name ( ) ) ; } }	Copy an entire directory tree.
static public byte [ ] read file to byte array ( string filename ) throws io { try ( file input stream fin = new file input stream ( filename ) ) { input stream in = new buffered input stream ( fin ) ; return read contents to byte array ( in ) ; } }	Read the file and place contents into a byte array,with any error messages put in the return String.
static public string read file ( string filename ) throws io { try ( file input stream fin = new file input stream ( filename ) ) { input stream reader reader = new input stream reader ( fin , cdm . utf8 charset ) ; string writer swriter = new string writer ( num ) ; unsynchronized buffered writer writer = new unsynchronized buffered writer ( swriter ) ; writer . write ( reader ) ; return swriter . to string ( ) ; } }	Read the contents from the named file and place into a String, assuming UTF-8 encoding.
static public void write to file ( string contents , file file ) throws io { try ( file output stream fout = new file output stream ( file ) ) { output stream writer fw = new output stream writer ( fout , cdm . utf8 charset ) ; unsynchronized buffered writer writer = new unsynchronized buffered writer ( fw ) ; writer . write ( contents ) ; writer . flush ( ) ; } }	Write String contents to a file, using UTF-8 encoding.
static public void write to file ( string contents , string file out name ) throws io { write to file ( contents , new file ( file out name ) ) ; }	Write contents to a file, using UTF-8 encoding.
static public long write to file ( input stream in , string file out name ) throws io { try ( file output stream fout = new file output stream ( file out name ) ) { output stream out = new buffered output stream ( fout ) ; return io . copy ( in , out ) ; } finally { if ( null != in ) in . close ( ) ; } }	copy input stream to file.
public void parse exception handler ( parse exception pe , http servlet response response ) {	Turns a ParseException into a OPeNDAP DAP2 error and sends it to the client.
public void dap2 exception handler ( da de , http servlet response response ) {	Sends a OPeNDAP DAP2 error to the client.
public void bad url ( http servlet request request , http servlet response response ) throws exception { if ( debug . is set ( str ) ) { log . debug ( str ) ; }	Sends an html document to the client explaining that they have used apoorly formed URL and then the help page...
public void do get catalog ( req state rs ) throws exception { rs . get response ( ) . set header ( str , get server version ( ) ) ; rs . get response ( ) . set content type ( str ) ; rs . get response ( ) . set header ( str , str ) ; print writer pw = new print writer ( new output stream writer ( rs . get response ( ) . get output stream ( ) , util . ut ) ) ; print catalog ( rs , pw ) ; pw . flush ( ) ; rs . get response ( ) . set status ( http servlet response . sc ok ) ; }	Handler for OPeNDAP catalog.xml requests.
protected void print catalog ( req state rs , print writer os ) throws io { os . println ( str ) ; os . println ( str + get server version ( ) ) ; }	to be overridden by servers that implement catalogs.
protected void print status ( print writer os ) { os . println ( str + get server version ( ) + str ) ; os . println ( str + hit counter + str ) ; if ( track ) { int n = pr arr . size ( ) ; int pending = num ; string builder preqs = new string builder ( ) ; for ( int i = num ; i < n ; i ++ ) { req state rs = ( req state ) pr arr . get ( i ) ; request debug req d = ( request debug ) rs . get user object ( ) ; if ( ! req d . done ) { preqs . append ( str ) ; preqs . append ( str ) ; preqs . append ( req d . reqno ) ; preqs . append ( str ) ; preqs . append ( req d . thread desc ) ; preqs . append ( str ) ; preqs . append ( rs . to string ( ) ) ; preqs . append ( str ) ; pending ++ ; } } os . println ( str + pending + str ) ; os . println ( preqs . to string ( ) ) ; } }	to be overridden by servers that implement status report.
private void print bad url ( print writer pw ) { pw . println ( str ) ; pw . println ( str ) ; pw . println ( str ) ; pw . println ( str ) ; pw . println ( str ) ; pw . println ( str ) ; pw . println ( str ) ; }	Prints the Bad URL Page page to the passed PrintWriter.
public calendar date get reference date ( ) { return calendar date . of ( null , year , month , day , hour , minute , second ) ; }	reference reference or base time as Dare.
private array read vlen data ( variable v , section section , data storage data storage ) throws io , invalid range exception { raf . seek ( data storage . file pos ) ; int nelems = read v ( raf ) ; array [ ] result = new array [ nelems ] ; for ( int elem = num ; elem < nelems ; elem ++ ) { int dsize = read v ( raf ) ; byte [ ] data = new byte [ dsize ] ; raf . read fully ( data ) ; array data array = array . factory ( v . get data type ( ) , ( int [ ] ) null , byte buffer . wrap ( data ) ) ; result [ elem ] = data array ; }	lOOK probably desnt work.
static public ncml collection reader read nc ml ( string ncml string , formatter errlog ) throws io { string reader reader = new string reader ( ncml string ) ; org . jdom2 . document doc ; try { sax builder = new sax ( ) ; if ( debug url ) system . out . println ( str + ncml string + str ) ; doc = builder . build ( new string reader ( ncml string ) ) ; } catch ( jdom e ) { throw new io ( e . get message ( ) ) ; } if ( debug xml ) system . out . println ( str ) ; return read xml ( doc , errlog , null ) ; }	Read an NcML file from a String, and construct a NcmlCollectionReader from its scan or scanFmrc element.
static public ncml collection reader open ( string ncml location , formatter errlog ) throws io { if ( ! ncml location . starts with ( str ) && ! ncml location . starts with ( str ) ) ncml location = str + ncml location ; url url = new url ( ncml location ) ; org . jdom2 . document doc ; try { sax builder = new sax ( ) ; if ( debug url ) system . out . println ( str + url + str ) ; doc = builder . build ( url ) ; } catch ( jdom e ) { throw new io ( e . get message ( ) ) ; } if ( debug xml ) system . out . println ( str ) ; return read xml ( doc , errlog , ncml location ) ; }	Read an NcML file from a URL location, and construct a NcmlCollectionReader from its scan or scanFmrc element.
static public string allow ( string x , string allow chars , char replace char ) { boolean ok = bool ; for ( int pos = num ; pos < x . length ( ) ; pos ++ ) { char c = x . char at ( pos ) ; if ( ! ( character . is letter or digit ( c ) || ( num <= allow chars . index of ( c ) ) ) ) { ok = bool ; break ; } } if ( ok ) return x ;	Replace any char not alphanumeric or in allowChars by replaceChar.
public static string cleanup ( byte [ ] h ) { byte [ ] bb = new byte [ h . length ] ; int count = num ; for ( byte b : h ) { if ( b >= num && b < num ) bb [ count ++ ] = b ; } return new string ( bb , num , count , cdm . utf8 charset ) ; }	Delete any non-printable characters.
static public string filter ( string x , string ok chars ) { boolean ok = bool ; for ( int pos = num ; pos < x . length ( ) ; pos ++ ) { char c = x . char at ( pos ) ; if ( ! ( character . is letter or digit ( c ) || ( num <= ok chars . index of ( c ) ) ) ) { ok = bool ; break ; } } if ( ok ) { return x ; }	Remove any char not alphanumeric or in okChars.
static public string filter7bits ( string s ) { if ( s == null ) return null ; char [ ] bo = new char [ s . length ( ) ] ; int count = num ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char c = s . char at ( i ) ; if ( ( c < num ) && ( c > num ) || ( ( c == str ) || ( c == str ) ) ) { bo [ count ++ ] = c ; } } return new string ( bo , num , count ) ; }	Remove all but printable ascii.
static public string make valid cdm object name ( string name ) { name = name . trim ( ) ;	transform embedded space to "_".
static public int match ( string s1 , string s2 ) { int i = num ; while ( ( i < s1 . length ( ) ) && ( i < s2 . length ( ) ) ) { if ( s1 . char at ( i ) != s2 . char at ( i ) ) { break ; } i ++ ; } return i ; }	Count number of chars that match in two strings, starting from front.
public static string pad left ( string s , int desired length , string pad string ) { while ( s . length ( ) < desired length ) { s = pad string + s ; } return s ; }	Pad the given string with padString on the left up to the given length.
public static string pad right ( string s , int desired length , string pad string ) { string builder ret = new string builder ( s ) ; while ( ret . length ( ) < desired length ) { ret . append ( pad string ) ; } return ret . to string ( ) ; }	Pad the given string with padString on the right up to the given length.
static public string remove ( string s , string sub ) { int len = sub . length ( ) ; int pos ; while ( num <= ( pos = s . index of ( sub ) ) ) { s = s . substring ( num , pos ) + s . substring ( pos + len ) ; } return s ; }	Remove all occurrences of the substring sub in the string s.
static public string remove ( string s , int c ) { if ( num > s . index of ( c ) ) {	Remove all occurrences of the character c in the string s.
static public string remove from end ( string s , int c ) { if ( num > s . index of ( c ) )	Remove all occurrences of the character c at the end of s.
static public string collapse whitespace ( string s ) { int len = s . length ( ) ; string builder b = new string builder ( len ) ; for ( int i = num ; i < len ; i ++ ) { char c = s . char at ( i ) ; if ( ! character . is whitespace ( c ) ) { b . append ( c ) ; } else { b . append ( str ) ; while ( ( i + num < len ) && character . is whitespace ( s . char at ( i + num ) ) ) { i ++ ;	Collapse continuous whitespace into one single " ".
static public string replace ( string s , char out , string in ) { if ( s . index of ( out ) < num ) { return s ; }	Replace any char "out" in s with "in".
static public string replace ( string x , char [ ] replace char , string [ ] replace with ) {	Replace all occurrences of any char in replaceChar with corresponding String in replaceWith.
public static string replace ( string string , string pattern , string value ) { if ( pattern . length ( ) == num ) return string ; if ( ! string . contains ( pattern ) ) return string ;	Replaces all occurrences of "pattern" in "string" with "value".
static public string substitute ( string original , string match , string subst ) { string s = original ; int pos ; while ( num <= ( pos = s . index of ( match ) ) ) { string builder sb = new string builder ( s ) ; s = sb . replace ( pos , pos + match . length ( ) , subst ) . to string ( ) ; } return s ; }	Find all occurrences of the "match" in original, and substitute the "subst" string.
static public string substitute ( string original , string [ ] match , string [ ] subst ) { boolean ok = bool ; for ( string a match : match ) { if ( original . contains ( a match ) ) { ok = bool ; break ; } } if ( ok ) { return original ; }	Find all occurences of match strings in original, and substitute the correspondingsubst string.
static public void remove ( string builder sb , string out ) { int i = num ; while ( i < sb . length ( ) ) { int c = sb . char at ( i ) ; boolean ok = bool ; for ( int j = num ; j < out . length ( ) ; j ++ ) { if ( out . char at ( j ) == c ) { sb . delete ( i , i + num ) ; ok = bool ; break ; } } if ( ok ) i ++ ; } }	Remove any of the characters in out from sb.
static public void unreplace ( string builder sb , string out , char in ) { int pos ; while ( num <= ( pos = sb . index of ( out ) ) ) { sb . set char at ( pos , in ) ; sb . delete ( pos + num , pos + out . length ( ) ) ; } }	Replace any String "out" in sb with char "in".
static public void replace ( string builder sb , string out , string in ) { for ( int i = num ; i < sb . length ( ) ; i ++ ) { int c = sb . char at ( i ) ; for ( int j = num ; j < out . length ( ) ; j ++ ) { if ( out . char at ( j ) == c ) sb . set char at ( i , in . char at ( j ) ) ; } } }	Replace any of the characters from out with corresponding character from in.
static public void substitute ( string builder sbuff , string match , string subst ) { int pos , from index = num ; int subst len = subst . length ( ) ; int match len = match . length ( ) ; while ( num <= ( pos = sbuff . index of ( match , from index ) ) ) { sbuff . replace ( pos , pos + match len , subst ) ; from index = pos + subst len ;	Find all occurences of the "match" in original, and substitute the "subst" string,directly into the original.
static public string trim ( string s , int bad ) { int len = s . length ( ) ; int st = num ; while ( ( st < len ) && ( s . char at ( st ) == bad ) ) { st ++ ; } while ( ( st < len ) && ( s . char at ( len - num ) == bad ) ) { len -- ; } return ( ( st > num ) || ( len < s . length ( ) ) ) ? s . substring ( st , len ) : s ; }	Remove bad char from beginning or end of string.
@ subscribe public void process event ( collection update event event ) { if ( ! config . collection name . equals ( event . get collection name ( ) ) ) return ;	called by eventBus, this is where the trigger comes in.
protected state check state ( ) throws io { state local state ; synchronized ( lock ) { if ( first ) { first init ( ) ; update collection ( state , config . update config . update type ) ;	A request has come in, check that the state has been initialized.this is called from the request thread.
protected void update ( collection update type force ) throws io {	Collection was changed, update internal objects.called by CollectionUpdater, trigger via handleCollectionEvent, so in a quartz scheduler thread.
@ override public java . util . list < inv dataset > get datasets ( ) { read ( ) ; return use proxy ? proxy . get datasets ( ) : super . get datasets ( ) ; }	Get a list of all the nested datasets.
public void release ( ) { datasets = new java . util . array list < > ( ) ; proxy = null ; use proxy = bool ; init = bool ; }	Release resources - undo the read of the catalog.
static public structure data deep copy ( structure data sdata , structure members members ) { bb abb = copy to array bb ( sdata , members , byte order . big endian ) ; return new structure data deep ( abb ) ; }	Make deep copy from sdata to another StructureData object whose data is self contained.
static public bb copy to array bb ( array structure as , byte order bo , boolean canonical ) throws io { if ( ! canonical && as . get class ( ) . equals ( bb . class ) ) {	Make deep copy from an ArrayStructure to a ArrayStructureBB whose data is contained in a ByteBuffer.
static public bb copy to array bb ( structure s , array structure as , byte order bo ) throws io { structure members sm = s . make structure members ( ) ; bb abb = new bb ( sm , as . get shape ( ) ) ; bb . set offsets ( sm ) ; if ( bo != null ) { byte buffer bb = abb . get byte buffer ( ) ; bb . order ( bo ) ; } try ( structure data iterator iter = as . get structure data iterator ( ) ) { while ( iter . has next ( ) ) copy to array bb ( iter . next ( ) , abb ) ; } return abb ; }	Make deep copy to an ArrayStructureBB whose data is contained in a ByteBuffer.Use the order of the members in the given Structure; skip copying any not in the Structure.
static public bb copy to array bb ( structure data sdata ) { return copy to array bb ( sdata , new structure members ( sdata . get structure members ( ) ) , byte order . big endian ) ; }	Make deep copy from a StructureData to a ArrayStructureBB whose data is contained in a ByteBuffer.
static public bb copy to array bb ( structure data sdata , structure members sm , byte order bo ) { int size = sm . get structure size ( ) ; byte buffer bb = byte buffer . allocate ( size ) ;	Make deep copy from a StructureData to a ArrayStructureBB whose data is contained in a ByteBuffer.
@ override public double get forecast time interval size in hours ( grib2 pds pds ) { grib2 pds . pds interval pds intv = ( grib2 pds . pds interval ) pds ;	Only use in GribVariable to decide on variable identity when intvMerge = false.By returning a constant, we dont intvMerge = false.Problem is we cant reconstruct interval length without reference time, which is not in the pds.
public d section ( range r ) throws invalid range exception { section section = new section ( ) . append range ( r ) ; d result = ( d ) section ( section ) ; int len = r . length ( ) ;	Create a new CoordinateAxis1D as a section of this CoordinateAxis1D.
static public table analyzer factory ( table configurer tc , feature type want feature type , netcdf dataset ds ) throws io {	Create a TableAnalyser for this dataset with the given TableConfigurer.
private void analyze ( feature type want feature type ) throws io {	Make a NestedTable object for the dataset.
public boolean sync ( ) { try { if ( ! mc grid reader . init ( ) ) { return bool ; } grid index index = mc grid reader . get grid index ( ) ;	Sync and extend.
public static double [ ] get gaussian latitudes ( string type , int start , int num ) throws illegal argument exception { double [ ] base array = null ; start -- ;	Get the latitude values for the given type.
static public long swap long ( byte [ ] b , int offset ) {	Returns the long resulting from reversing 8 bytes at a specifiedoffset in a byte array.
static public float swap float ( byte [ ] b , int offset ) { int accum = num ; for ( int shift by = num , i = offset ; shift by < num ; shift by += num , i ++ ) accum |= ( b [ i ] & num ) << shift by ; return float . int bits to float ( accum ) ; }	Returns the float resulting from reversing 4 bytes at a specifiedoffset in a byte array.
static public char swap char ( byte [ ] b , int offset ) {	Returns the char resulting from swapping 2 bytes at a specifiedoffset in a byte array.
protected void find coordinate axes ( netcdf dataset ds ) {	The attribute "coordinates" is an alias for _CoordinateAxes.
protected boolean add parameter2 ( coordinate transform rs , string param name , netcdf file ds , attribute container v , string att name , boolean read data ) { string var name ; if ( null == ( var name = v . find att value ignore case ( att name , null ) ) ) { parse info . format ( str , att name ) ; return bool ; } var name = var name . trim ( ) ; variable data var ; if ( null == ( data var = ds . find variable ( var name ) ) ) { parse info . format ( str , var name ) ; return bool ; } if ( read data ) { array data ; try { data = data var . read ( ) ; } catch ( io e ) { parse info . format ( str , var name , e . get message ( ) ) ; return bool ; } double [ ] vals = ( double [ ] ) data . get1 d ( data type . double ) ; rs . add parameter ( new parameter ( param name , vals ) ) ; } else rs . add parameter ( new parameter ( param name , var name ) ) ; return bool ; }	Add a Parameter to a CoordinateTransform.
public group common parent ( group other ) { if ( is parent ( other ) ) return this ; if ( other . is parent ( this ) ) return other ; while ( ! other . is parent ( this ) ) other = other . get parent group ( ) ; return other ; }	Get the common parent of this and the other group.Cant fail, since the root group is always a parent of any 2 groups.
public boolean is parent ( group other ) { while ( ( other != this ) && ( other . get parent group ( ) != null ) ) other = other . get parent group ( ) ; return ( other == this ) ; }	Is this a parent of the other Group?.
public void set parent group ( group parent ) { if ( immutable ) throw new illegal state exception ( str ) ; super . set parent group ( parent == null ? ncfile . get root group ( ) : parent ) ; }	Set the Group's parent Group.
public void add dimension ( dimension dim ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( ! dim . is shared ( ) ) { throw new illegal argument exception ( str ) ; } if ( find dimension local ( dim . get short name ( ) ) != null ) throw new illegal argument exception ( str + dim . get short name ( ) + str + get short name ( ) ) ; dimensions . add ( dim ) ; dim . set group ( this ) ; }	Adds the specified shared dimension to this group.
public boolean add dimension if not exists ( dimension dim ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( ! dim . is shared ( ) ) { throw new illegal argument exception ( str ) ; } if ( find dimension local ( dim . get short name ( ) ) != null ) return bool ; dimensions . add ( dim ) ; dim . set group ( this ) ; return bool ; }	Adds the specified shared dimension to this group, but only if another dimension with the same name doesn'talready exist.
public void add group ( group g ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( find group ( g . get short name ( ) ) != null ) throw new illegal argument exception ( str + g . get short name ( ) + str + get short name ( ) ) ; groups . add ( g ) ; g . set parent group ( this ) ;	Add a nested Group.
public void add enumeration ( enum typedef e ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( e == null ) return ; e . set parent group ( this ) ; enum typedefs . add ( e ) ; }	Add an Enumeration.
public void add variable ( variable v ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( v == null ) return ; if ( find variable ( v . get short name ( ) ) != null ) {	Add a Variable.
public boolean remove dimension ( string dim name ) { if ( immutable ) throw new illegal state exception ( str ) ; for ( int i = num ; i < dimensions . size ( ) ; i ++ ) { dimension d = dimensions . get ( i ) ; if ( dim name . equals ( d . get short name ( ) ) ) { dimensions . remove ( d ) ; return bool ; } } return bool ; }	remove a Dimension using its name, in this group only.
public group make relative group ( netcdf file ncf , string path , boolean ignorelast ) { path = path . trim ( ) ; path = path . replace ( str , str ) ; boolean isabsolute = ( path . char at ( num ) == str ) ; if ( isabsolute ) path = path . substring ( num ) ;	Create groups to ensure path is defined.
private string convert dds das ( string attribute ) throws malformed alias exception { string prefix = str ; vector a names = tokenize alias field ( attribute ) ;	This method just makes sure that the attribute field in each Aliases resolves correctlyif there ends up being a "looseEnds" Attribute Table at the top level.
public void print das ( print writer pw ) { das my das = null ; try { my das = this . get das ( ) ; my das . print ( pw ) ; } catch ( das das e ) { pw . println ( str + str + das e . get message ( ) ) ; } }	Print a DAS constructed from this DDS and it's BaseType variables.
public base type get variable ( string name ) throws no such variable exception { stack s = new stack ( ) ; s = search ( name , s ) ; return ( base type ) s . pop ( ) ; }	Returns a reference to the named variable.
public void write grid ( grid dataset dataset , grid datatype grid , array data , boolean grey scale ) throws io { grid coord system gcs = grid . get coordinate system ( ) ; if ( ! gcs . is regular spatial ( ) ) { throw new illegal argument exception ( str + grid . get full name ( ) ) ; } d xaxis = ( d ) gcs . get x ( ) ; d yaxis = ( d ) gcs . get y ( ) ;	Write GridDatatype data to the geotiff file.
private array float replace missing values ( is missing evaluator grid , array data , ma . min max data min max ) { float min value = ( float ) ( data min max . min - num ) ; array float float array = ( array float ) array . factory ( data type . float , data . get shape ( ) ) ; index iterator data iter = data . get index iterator ( ) ; index iterator float iter = float array . get index iterator ( ) ; while ( data iter . has next ( ) ) { float v = data iter . get float next ( ) ; if ( grid . is missing ( ( double ) v ) ) { v = min value ; } float iter . set float next ( v ) ; } return float array ; }	Replace missing values with dataMinMax.min - 1.0; return a floating point data array.
private array byte replace missing values and scale ( is missing evaluator grid , array data , ma . min max data min max ) { double scale = num / ( data min max . max - data min max . min ) ; array byte byte array = ( array byte ) array . factory ( data type . byte , data . get shape ( ) ) ; index iterator data iter = data . get index iterator ( ) ; index iterator result iter = byte array . get index iterator ( ) ; byte bv ; while ( data iter . has next ( ) ) { double v = data iter . get double next ( ) ; if ( grid . is missing ( v ) ) { bv = num ; } else { int iv = ( int ) ( ( v - data min max . min ) * scale + num ) ; bv = ( byte ) ( iv & num ) ; } result iter . set byte next ( bv ) ; } return byte array ; }	Replace missing values with 0; scale other values between 1 and 255, return a byte data array.
private double geo shift get xstart ( array lon , double inc ) { index ilon = lon . get index ( ) ; int [ ] lon shape = lon . get shape ( ) ; index iterator lon iter = lon . get index iterator ( ) ; double xlon = num ; lat lon point p0 = new lat lon point impl ( num , lon . get float ( ilon . set ( num ) ) ) ; lat lon point p n = new lat lon point impl ( num , lon . get float ( ilon . set ( lon shape [ num ] - num ) ) ) ; xlon = p0 . get longitude ( ) ; while ( lon iter . has next ( ) ) { float l = lon iter . get float next ( ) ; lat lon point pn = new lat lon point impl ( num , l ) ; if ( pn . get longitude ( ) < xlon ) { xlon = pn . get longitude ( ) ; } } if ( p0 . get longitude ( ) == p n . get longitude ( ) ) { xlon = xlon - inc ; } return xlon ; }	LOOK WTF ?? is this the seam crossing ??.
public void write grid ( geo referenced array array , boolean grey scale ) throws io { coverage coord sys gcs = array . get coord sys for data ( ) ; if ( ! gcs . is regular spatial ( ) ) throw new illegal argument exception ( str + array . get coverage name ( ) ) ; projection proj = gcs . get projection ( ) ; d xaxis = ( d ) gcs . get x ( ) ; d yaxis = ( d ) gcs . get y ( ) ;	Write GridCoverage data to the geotiff file.
public void write ( http servlet response hsr ) throws io { print writer xml response = hsr . get writer ( ) ; xml response . append ( str ) ; xml response . append ( str + str + str ) ; xml response . append ( str ) ; if ( locator != null ) xml response . append ( str + locator + str ) ; xml response . append ( str + exception code + str ) ; xml response . append ( str + text + str ) ; xml response . append ( str ) ; xml response . append ( str ) ; }	Given the information on construction, writes the necessary exception information.
private static file make top index file from config ( feature collection config config ) { formatter errlog = new formatter ( ) ; collection spec parser specp = config . get collection spec parser ( errlog ) ; string name = string util2 . replace ( config . collection name , str , str ) ;	This is only used for the top level GribCollection.
public static grib collection type get type ( random access file raf ) throws io { string magic ; raf . seek ( num ) ; magic = raf . read string ( grib2 collection writer . magic start . get bytes ( cdm . utf8 charset ) . length ) ; switch ( magic ) { case grib2 collection writer . magic start : return grib collection type . gri ; case grib1 collection writer . magic start : return grib collection type . gri ; case grib2 partition builder . magic start : return grib collection type . partition2 ; case grib1 partition builder . magic start : return grib collection type . partition1 ; } return grib collection type . none ; }	Find out what kind of index this is.
public static boolean update grib collection ( feature collection config config , collection update type update type , logger logger ) throws io { if ( logger == null ) logger = class logger ; long start = system . current time millis ( ) ; formatter errlog = new formatter ( ) ; collection spec parser specp = config . get collection spec parser ( errlog ) ; path root path = paths . get ( specp . get root dir ( ) ) ; boolean is grib1 = config . type == feature collection type . gri ; boolean changed ; if ( config . ptype == feature collection config . partition type . none || config . ptype == feature collection config . partition type . all ) { try ( collection abstract dcm = new collection path matcher ( config , specp , logger ) ) { changed = update grib collection ( is grib1 , dcm , update type , feature collection config . partition type . none , logger , errlog ) ; } } else if ( config . ptype == feature collection config . partition type . time period ) { try ( time partition tp = new time partition ( config , specp , logger ) ) { changed = update time partition ( is grib1 , tp , update type , logger ) ; } } else {	Update Grib Collection if needed.
private static boolean update leaf collection ( boolean is grib1 , feature collection config config , collection update type update type , boolean is top , logger logger , path dir path ) throws io { if ( config . ptype == feature collection config . partition type . file ) { return update file partition ( is grib1 , config , update type , is top , logger , dir path ) ; } else { formatter errlog = new formatter ( ) ; collection spec parser specp = config . get collection spec parser ( errlog ) ; try ( directory collection dcm = new directory collection ( config . collection name , dir path , is top , config . older than , logger ) ) { dcm . put aux info ( feature collection config . aux config , config ) ; if ( specp . get filter ( ) != null ) dcm . set stream filter ( new stream filter ( specp . get filter ( ) , specp . get filter on name ( ) ) ) ; boolean changed = update grib collection ( is grib1 , dcm , update type , feature collection config . partition type . directory , logger , errlog ) ; logger . debug ( str , changed , dir path ) ; return changed ; } } }	Update all the gbx indices in one directory, and the ncx index for that directory.
private static grib collection immutable open grib collection from data file ( boolean is grib1 , random access file data raf , feature collection config config , collection update type update type , formatter errlog , org . slf4j . logger logger ) throws io { string filename = data raf . get location ( ) ; file data file = new file ( filename ) ; m mfile = new m os ( data file ) ; return open grib collection from data file ( is grib1 , mfile , update type , config , errlog , logger ) ; }	Open a grib collection from a single grib1 or grib2 file.Create the gbx9 and ncx2 files if needed.
@ nullable public static grib collection immutable open grib collection from data file ( boolean is grib1 , m mfile , collection update type update type , feature collection config config , formatter errlog , org . slf4j . logger logger ) throws io { m dcm = new collection single file ( mfile , logger ) ; dcm . put aux info ( feature collection config . aux config , config ) ; if ( is grib1 ) { grib1 collection builder builder = new grib1 collection builder ( dcm . get collection name ( ) , dcm , logger ) ;	from a single file, read in the index, create if it doesnt exist; return null on failure.
static boolean url match ( url pattern , url url ) { int relation ; if ( pattern == null ) return ( url == null ) ; if ( ! ( url . get host ( ) . ends with ( pattern . get host ( ) ) ) ) return bool ;	Match has different semantics than urlCompare.
static synchronized public void add ( string key , string value , string url ) { if ( key == null ) return ; if ( ! initialized ) rc . initialize ( ) ; triple t = new triple ( key , value , url ) ; dfalt rc . insert ( t ) ;	Allow users to add to the default rc.
static synchronized public string find ( string key , string url ) { if ( key == null ) return null ; if ( ! initialized ) rc . initialize ( ) ; triple t = dfalt rc . lookup ( key , url ) ; return ( t == null ? null : t . value ) ; }	Allow users to search the default rc.
static void set well known ( ) { if ( dfalt rc . triplestore . size ( ) == num ) return ;	Record some well known parameters.
public triple insert ( triple t ) { if ( t . key == null ) return null ; list < triple > list = triplestore . get ( t . key ) ; if ( list == null ) list = new array list < triple > ( ) ; triple prev = addtriple ( list , t ) ; triplestore . put ( t . key , list ) ; return prev ; }	Allow for external loading.
public list < dataset > get datasets local ( ) { list < dataset > datasets = ( list < dataset > ) flds . get ( dataset . datasets ) ; return datasets == null ? new array list < > ( num ) : datasets ; }	Get top level datasets contained directly in this catalog.Do not dereference catRefs.
public dataset find dataset by name ( string name ) { for ( dataset ds : get datasets ( ) ) { if ( ds . get name ( ) . equals ( name ) ) return ds ; dataset result = ds . find dataset by name ( name ) ; if ( result != null ) return result ; } return null ; }	Look though all datasets here or under here. do not go into catrefs.
public void set projection ( projection impl project ) { display project = project ; if ( feat set list == null ) return ; iterator iter = feat set list . iterator ( ) ; while ( iter . has next ( ) ) { feature set fs = ( feature set ) iter . next ( ) ; fs . new projection = bool ; } }	Sets new projection for subsequent drawing.
protected iterator get shapes ( java . awt . d g , affine transform normal2device ) { long start time = system . current time millis ( ) ; if ( feat set list == null ) { init feat set list ( ) ; assert ! feat set list . is empty ( ) ; }	we have to deal with both projections and resolution-dependence.
private array list make shapes ( iterator feat list ) { shape shape ; array list shape list = new array list ( ) ; projection impl data project = get data projection ( ) ; if ( debug . is set ( str ) ) { system . out . println ( str + display project ) ; } while ( feat list . has next ( ) ) { abstract gis feature feature = ( abstract gis feature ) feat list . next ( ) ; if ( data project . is lat lon ( ) )	make an ArrayList of Shapes from the given featureList and current display Projection.
public final int compare to ( string string ) { return get id ( ) . length ( ) >= string . length ( ) ? get id ( ) . compare to ignore case ( string ) : get id ( ) . compare to ignore case ( string . substring ( num , get id ( ) . length ( ) ) ) ; }	Compares this PrefixName with a string.
public boolean start progress monitor task ( progress monitor task pmt ) { if ( busy ) return bool ; busy = bool ; this . task = pmt ; is cancelled = bool ; count = num ; set icon ( icon [ num ] ) ;	The given task is run in a background thread.Progress is indicated once a second.You cannot call this method again till the task is completed.
private boolean needs update ( collection update type ff , file collection index file ) throws io { long collection last modified = collection index file . last modified ( ) ; set < string > new file set = new hash set < > ( ) ; for ( m dcm : partition manager . make partitions ( collection update type . test ) ) { string partition index filename = string util2 . replace ( dcm . get index filename ( grib cdm index . ncx suffix ) , str , str ) ; file partition index file = grib index cache . get existing file or cache ( partition index filename ) ; if ( partition index file == null )	LOOK need an option to only scan latest last partition or something.
static public void normalize ( ens coord result , list < ens coord > ec list ) { list < ens coord > extra = new array list < > ( ) ; for ( ens coord ec : ec list ) { if ( ! result . equals data ( ec ) ) {	Extend result with all the values in the list of EnsCoord.
public void set object ( int index , object value ) { if ( sdata == null ) sdata = new structure data [ nelems ] ; sdata [ index ] = ( structure data ) value ; }	Set the index-th StructureData of this ArrayStructure.
public structure data get structure data ( int index ) { if ( sdata == null ) sdata = new structure data [ nelems ] ; if ( index >= sdata . length ) throw new illegal argument exception ( index + str + sdata . length ) ; if ( sdata [ index ] == null ) sdata [ index ] = make structure data ( this , index ) ; return sdata [ index ] ; }	Get the index-th StructureData of this ArrayStructure.
protected void copy structures ( int recnum , structure members . member m , index iterator result ) { array data = get array ( recnum , m ) ; index iterator data iter = data . get index iterator ( ) ; while ( data iter . has next ( ) ) result . set object next ( data iter . get object next ( ) ) ; }	member data is itself a structure, and may be an array of structures.
public object get scalar object ( int recno , structure members . member m ) { data type data type = m . get data type ( ) ; if ( data type == data type . double ) { return get scalar double ( recno , m ) ; } else if ( data type == data type . float ) { return get scalar float ( recno , m ) ; } else if ( data type . get primitive class type ( ) == byte . class ) { return get scalar byte ( recno , m ) ; } else if ( data type . get primitive class type ( ) == short . class ) { return get scalar short ( recno , m ) ; } else if ( data type . get primitive class type ( ) == int . class ) { return get scalar int ( recno , m ) ; } else if ( data type . get primitive class type ( ) == long . class ) { return get scalar long ( recno , m ) ; } else if ( data type == data type . char ) { return get scalar string ( recno , m ) ; } else if ( data type == data type . string ) { return get scalar string ( recno , m ) ; } else if ( data type == data type . structure ) { return get scalar structure ( recno , m ) ; } else if ( data type == data type . opaque ) { array object data = ( array object ) m . get data array ( ) ; return data . get object ( recno * m . get size ( ) ) ;	Get member data array of any type as an Object, eg, Float, Double, String, StructureData etc.
public double convert scalar double ( int recnum , structure members . member m ) { if ( m . get data type ( ) == data type . double ) return get scalar double ( recnum , m ) ; if ( m . get data type ( ) == data type . float ) return ( double ) get scalar float ( recnum , m ) ; object o = get scalar object ( recnum , m ) ; if ( o instanceof number ) return ( ( number ) o ) . double value ( ) ; throw new forbidden conversion exception ( str + m . get data type ( ) + str ) ; }	Get scalar value as a double, with conversion as needed.
public int convert scalar int ( int recnum , structure members . member m ) { if ( m . get data type ( ) == data type . int || m . get data type ( ) == data type . uint ) return get scalar int ( recnum , m ) ; if ( m . get data type ( ) == data type . short ) return ( int ) get scalar short ( recnum , m ) ; if ( m . get data type ( ) == data type . ushort ) return data type . unsigned short to int ( get scalar short ( recnum , m ) ) ; if ( m . get data type ( ) == data type . byte ) return ( int ) get scalar byte ( recnum , m ) ; if ( m . get data type ( ) == data type . ubyte ) return ( int ) data type . unsigned byte to short ( get scalar byte ( recnum , m ) ) ; if ( m . get data type ( ) == data type . long || m . get data type ( ) == data type . ulong ) return ( int ) get scalar long ( recnum , m ) ; object o = get scalar object ( recnum , m ) ; if ( o instanceof number ) return ( ( number ) o ) . int value ( ) ; throw new forbidden conversion exception ( str + m . get data type ( ) + str ) ; }	Get scalar value as an int, with conversion as needed.
public float get scalar float ( int recnum , structure members . member m ) { if ( m . get data type ( ) != data type . float ) throw new illegal argument exception ( str + m . get data type ( ) + str ) ; array data = m . get data array ( ) ; return data . get float ( recnum * m . get size ( ) ) ;	Get scalar member data of type float.
public byte get scalar byte ( int recnum , structure members . member m ) { if ( ! ( m . get data type ( ) . get primitive class type ( ) == byte . class ) ) throw new illegal argument exception ( str + m . get data type ( ) + str ) ; array data = m . get data array ( ) ; return data . get byte ( recnum * m . get size ( ) ) ;	Get scalar member data of type byte.
public short get scalar short ( int recnum , structure members . member m ) { if ( ! ( m . get data type ( ) . get primitive class type ( ) == short . class ) ) throw new illegal argument exception ( str + m . get data type ( ) + str ) ; array data = m . get data array ( ) ; return data . get short ( recnum * m . get size ( ) ) ;	Get scalar member data of type short.
public char get scalar char ( int recnum , structure members . member m ) { if ( m . get data type ( ) != data type . char ) throw new illegal argument exception ( str + m . get data type ( ) + str ) ; array data = m . get data array ( ) ; return data . get char ( recnum * m . get size ( ) ) ;	Get scalar member data of type char.
public string get scalar string ( int recnum , structure members . member m ) { if ( m . get data type ( ) == data type . char ) { array char data = ( array char ) m . get data array ( ) ; return data . get string ( recnum ) ; } if ( m . get data type ( ) == data type . string ) { array data = m . get data array ( ) ; return ( string ) data . get object ( recnum ) ; } throw new illegal argument exception ( str + m . get data type ( ) + str ) ; }	Get member data of type String or char.
public array structure get array structure ( int recnum , structure members . member m ) { if ( ( m . get data type ( ) != data type . structure ) && ( m . get data type ( ) != data type . sequence ) ) throw new illegal argument exception ( str + m . get data type ( ) + str ) ; if ( m . get data type ( ) == data type . sequence ) return get array sequence ( recnum , m ) ; array structure array = ( array structure ) m . get data array ( ) ; int count = m . get size ( ) ; structure data [ ] this sdata = new structure data [ count ] ; for ( int i = num ; i < count ; i ++ ) this sdata [ i ] = array . get structure data ( recnum * count + i ) ;	Get member data of type array of Structure.
public array sequence get array sequence ( int recnum , structure members . member m ) { if ( m . get data type ( ) != data type . sequence ) throw new illegal argument exception ( str + m . get data type ( ) + str ) ;	Get member data of type ArraySequence.
public array object get array object ( int recnum , structure members . member m ) { if ( m . get data type ( ) != data type . opaque ) throw new illegal argument exception ( str + m . get data type ( ) + str ) ; array object array = ( array object ) m . get data array ( ) ; return ( array object ) array . get object ( recnum ) ;	Get member data of type ArrayObject.
static protected long minmax ( long value , long min , long max ) { if ( value < min ) return min ; if ( value > max ) return max ; return value ; }	Peg a value to either the min or maxdepending on sign.
protected object eval ( dap variable var , dap sequence seq , data cursor record , ceast expr ) throws dap exception { switch ( expr . sort ) { case constant : return expr . value ; case segment : return field value ( var , seq , record , expr . name ) ; case expr : object lhs = eval ( var , seq , record , expr . lhs ) ; object rhs = ( expr . rhs == null ? null : eval ( var , seq , record , expr . rhs ) ) ; if ( rhs != null ) switch ( expr . op ) { case lt : return compare ( lhs , rhs ) < num ; case le : return compare ( lhs , rhs ) <= num ; case gt : return compare ( lhs , rhs ) > num ; case ge : return compare ( lhs , rhs ) >= num ; case eq : return lhs . equals ( rhs ) ; case neq : return ! lhs . equals ( rhs ) ; case req : return lhs . to string ( ) . matches ( rhs . to string ( ) ) ; case and : return ( ( boolean ) lhs ) && ( ( boolean ) rhs ) ; } else switch ( expr . op ) { case not : return ! ( ( boolean ) lhs ) ; } } throw new dap exception ( str ) ; }	Evaluate a filter with respect to a Sequence record.Assumes the filter has been canonicalized so thatthe lhs is a variable.
public string to constraint string ( ) { string builder buf = new string builder ( ) ; boolean first = bool ; for ( int i = num ; i < segments . size ( ) ; i ++ ) { segment seg = segments . get ( i ) ; if ( ! seg . var . is top level ( ) ) continue ; if ( ! first ) buf . append ( str ) ; first = bool ; dumpvar ( seg , buf , bool ) ; } return buf . to string ( ) ; }	Convert the view to a constraint string suitablefor use in a URL, except not URL encoded.
public boolean references ( dap node node ) { boolean isref = bool ; switch ( node . get sort ( ) ) { case dimension : dap dimension dim = this . redef . get ( ( dap dimension ) node ) ; if ( dim == null ) dim = ( dap dimension ) node ; isref = this . dimrefs . contains ( dim ) ; break ; case enumeration : isref = ( this . enums . contains ( ( dap enumeration ) node ) ) ; break ; case variable : isref = ( find variable index ( ( dap variable ) node ) >= num ) ; break ; case group : case dataset : isref = ( this . groups . contains ( ( dap group ) node ) ) ; break ; default : break ; } return isref ; }	Reference X match.
protected boolean matches ( dap variable var , dap sequence seq , data cursor rec , ceast filter ) throws dap exception { object value = eval ( var , seq , rec , filter ) ; return ( ( boolean ) value ) ; }	Evaluate a filter with respect to a Sequence record.
protected int expansion count ( dap structure struct ) { int count = num ; for ( dap variable field : struct . get fields ( ) ) { if ( find variable index ( field ) >= num ) count ++ ; } return count ; }	Count the number of fields of a structure thatalready in this view.
protected void computeenums ( ) { for ( int i = num ; i < variables . size ( ) ; i ++ ) { dap variable var = variables . get ( i ) ; if ( var . get sort ( ) != dap sort . variable ) continue ; dap type daptype = var . get base type ( ) ; if ( ! daptype . is enum type ( ) ) continue ; if ( ! this . enums . contains ( ( dap enumeration ) daptype ) ) this . enums . add ( ( dap enumeration ) daptype ) ; } }	Walk all the included variables and accumulatethe referenced enums.
protected void computegroups ( ) {	Walk all the included declarationsand accumulate the set of referenced groups.
static public ce compile ( string sce , dap dataset dmr ) throws dap exception {	Static Utility for compiling a constraint string.
@ override public boolean is valid file ( random access file raf ) throws io { if ( raf instanceof http ) {	accept grib2 or ncx files.
private void make actions system ( ) { abstract action clear debug flags action = new abstract action ( ) { public void action performed ( action event e ) { } } ; ba . set action properties ( clear debug flags action , null , str , bool , str , - num ) ; }	actions that are system-wide.
public int get byte order ( int kmachn ) { if ( ( kmachn == mtvax ) || ( kmachn == mtultx ) || ( kmachn == mtalph ) || ( kmachn == mtlnux ) || ( kmachn == mtigph ) ) { return random access file . little endian ; } return random access file . big endian ; }	Get the byte order for the machine type.
void set byte order ( ) { string arch = system . get property ( str ) ; if ( arch . equals ( str ) ||	LOOK WTF ??Set the machine type for this system.
public key find key ( string name ) { if ( keys == null ) { return null ; }	Find a key with the given name.
public dm find file header ( string name ) { if ( ( file header info == null ) || file header info . is empty ( ) ) { return null ; } for ( dm fhi : file header info ) { if ( name . equals ( fhi . kfhnam ) ) { return fhi ; } } return null ; }	Find the file header with this name.
public float [ ] get file header ( string name ) throws io { dm fh = find file header ( name ) ; if ( ( fh == null ) || ( fh . kfhtyp != mdreal ) ) { return null ; } int knt = file header info . index of ( fh ) ;	Read in the values for the file header.
public void print parts ( ) { if ( parts == null ) { return ; } for ( int i = num ; i < parts . size ( ) ; i ++ ) { system . out . println ( str + i + str ) ; system . out . println ( parts . get ( i ) ) ; } }	Print the part information.
public int get data pointer ( int irow , int icol , string part name ) { int ipoint = - num ; if ( ( irow < num ) || ( irow > dm label . krow ) || ( icol < num ) || ( icol > dm label . kcol ) ) { system . out . println ( str + irow + str + icol ) ; return ipoint ; } int iprt = get part number ( part name ) ; if ( iprt == num ) { system . out . println ( str ) ; return ipoint ; }	Get the pointer to the data. Taken from DM_RDTR.
public float dm rflt ( int word ) throws io { if ( rf == null ) { throw new io ( str ) ; } if ( dm label == null ) { throw new io ( str ) ; } rf . seek ( get offset ( word ) ) ; if ( need to swap ) {	Read a float.
public string dm rstr ( int isword , int nchar ) throws io { if ( rf == null ) { throw new io ( str ) ; } rf . seek ( get offset ( isword ) ) ; return rf . read string ( nchar ) ; }	Read a String.
public float [ ] dm unpk ( dm part , int [ ] ibitst ) { int nparms = part . kparms ; int nwordp = part . kwordp ; int npack = ( ibitst . length - num ) / nwordp + num ; if ( npack * nwordp != ibitst . length ) {	Unpack an array of packed integers.
protected static string get bits ( int b ) { formatter s = new formatter ( ) ; for ( int i = num ; i >= num ; i -- ) { if ( ( b & ( num << i ) ) != num ) { s . format ( str ) ; } else { s . format ( str ) ; } if ( i % num == num ) { s . format ( str ) ; } } return s . to string ( ) ; }	Get a bit string for an integer.
public static void write to channel ( netcdf file ncfile , writable byte channel wbc ) throws io , invalid range exception { data output stream stream = new data output stream ( new buffered output stream ( channels . new output stream ( wbc ) , num ) ) ;	Write ncfile to a WritableByteChannel.
private void parse base ( element e , string indent ) throws das , no such type exception , bad semantics exception { parse level ++ ; string type = e . get name ( ) ; if ( type . equals ( str ) ) {	This method recursively travels through the DOM tree, locatingBaseType derived nodes and placing them in the DDS.
private void parse grid ( element grid element , string indent ) throws das , no such type exception , bad semantics exception { parse level ++ ;	Grids are unusual examples of DConstructor and require specialhandling when parsing.
private void parse aliases ( element e , string indent ) throws das { parse level ++ ; string sub indent = indent + str ; if ( debug ) system . out . println ( indent + str ) ; if ( debug ) system . out . println ( sub indent + str + current bt . get type name ( ) + str + current bt . get clear name ( ) ) ;	Parse all of the Alias tags in this element of the XML document.Add each one to the correct Attribute Table.
private list < data descriptor > decode ( list < short > key desc , bufr table lookup lookup ) { if ( key desc == null ) return null ; list < data descriptor > keys = new array list < data descriptor > ( ) ; for ( short id : key desc ) { data descriptor dd = new data descriptor ( id , lookup ) ; keys . add ( dd ) ; if ( dd . f == num ) { d . descriptor tdd = lookup . get descriptor table d ( dd . fxy ) ; if ( tdd == null || tdd . get sequence ( ) == null ) { dd . bad = bool ; } else { dd . name = tdd . get name ( ) ; dd . sub keys = decode ( tdd . get sequence ( ) , lookup ) ; } } } return keys ; }	convert ids to DataDescriptors, expand table D.
private list < data descriptor > replicate ( list < data descriptor > keys ) { list < data descriptor > tree = new array list < data descriptor > ( ) ; iterator < data descriptor > dk iter = keys . iterator ( ) ; while ( dk iter . has next ( ) ) { data descriptor dk = dk iter . next ( ) ; if ( dk . f == num ) { dk . sub keys = new array list < data descriptor > ( ) ; dk . replication = dk . y ;	look for replication, move replicated items into subtree.
public string get dataset filename ( ) { string s = get encoded name ( ) ; system . out . println ( s ) ; return ( s ) ; }	Get the dataset filename.
public string get cf ( ) { if ( gemreader . get file sub type ( ) . equals ( gempak surface file reader . ship ) ) { return cf . feature type . point . to string ( ) ; } return cf . feature type . time series . to string ( ) ; }	Get the CF feature type.
public static boolean nearly equals abs ( float a , float b , float max abs diff ) { return absolute difference ( a , b ) <= math . abs ( max abs diff ) ; }	Check if two numbers are nearly equal with given absolute tolerance.
@ override public boolean references ( dap node node ) { switch ( node . get sort ( ) ) { case dimension : case enumeration : case variable : case group : case dataset : return bool ; default : break ; } return bool ; }	Selected consult or iterator overrides for efficiency.
public final unit parse ( final string spec ) throws no such unit exception , unit parse exception , specification exception , db , db , unit system exception { synchronized ( mutex ) { return parse ( spec , db . instance ( ) ) ; } }	Parses a unit specification.
private boolean is tiled ( variable v ) { for ( dimension d : v . get dimensions ( ) ) { for ( range r : section . get ranges ( ) ) { if ( d . get short name ( ) . equals ( r . get name ( ) ) ) return bool ; } } return bool ; }	a variable is tiled if any of its dimensions are tiled.
public coordinate time abstract make best from complete ( ) { int [ ] best = new int [ time2runtime . length ] ; int last = - num ; int count = num ; for ( int i = num ; i < time2runtime . length ; i ++ ) { int time = time2runtime [ i ] ; if ( time >= last ) { last = time ; best [ i ] = time ; count ++ ; } else { best [ i ] = - num ; } } return make best from complete ( best , count ) ; }	Implements coverting a "complete best" to a "monotonic best".The reftime is not allowed to decrease.
public projection rect [ ] lat lon to proj rect ( lat lon rect latlon r ) { double lat0 = latlon r . get lower left point ( ) . get latitude ( ) ; double height = math . abs ( latlon r . get upper right point ( ) . get latitude ( ) - lat0 ) ; double width = latlon r . get width ( ) ; double lon0 = lat lon point impl . lon normal ( latlon r . get lower left point ( ) . get longitude ( ) , center lon ) ; double lon1 = lat lon point impl . lon normal ( latlon r . get upper right point ( ) . get longitude ( ) , center lon ) ; projection rect [ ] rects = new projection rect [ ] { new projection rect ( ) , new projection rect ( ) } ; if ( lon0 < lon1 ) { rects [ num ] . set rect ( lon0 , lat0 , width , height ) ; rects [ num ] = null ; } else { double y = center lon + num - lon0 ; rects [ num ] . set rect ( lon0 , lat0 , y , height ) ; rects [ num ] . set rect ( lon1 - width + y , lat0 , width - y , height ) ; } return rects ; }	Split a latlon rectangle to the equivalent ProjectionRectusing this LatLonProjection to split it at the seam if needed.
private void show time series all ( java . util . list < log reader . log > logs ) { time series bytes sent data = new time series ( str , minute . class ) ; time series time took data = new time series ( str , minute . class ) ; time series nreq data = new time series ( str , minute . class ) ; string interval s = str ;	construct the TImeSeries plot for the list of logs passed in.
static public map < string , attribute > make map ( list < attribute > atts ) { int size = ( atts == null ) ? num : atts . size ( ) ; map < string , attribute > result = new hash map < > ( size ) ; if ( atts == null ) return result ; for ( attribute att : atts ) result . put ( att . get short name ( ) , att ) ; return result ; }	Turn a list into a map.
public array get values ( ) { if ( values == null && svalue != null ) { values = array . factory ( data type . string , new int [ ] { num } ) ; values . set object ( values . get index ( ) , svalue ) ; } return values ; }	Get the value as an Array.
public number get numeric value ( int index ) { if ( ( index < num ) || ( index >= nelems ) ) return null ;	Retrieve a numeric value by index.
protected void write cdl ( formatter f , boolean strict , string parentname ) { if ( strict && ( is string ( ) || this . get enum type ( ) != null ) )	Write CDL representation into f.
private void set string value ( string val ) { if ( val == null ) throw new illegal argument exception ( str ) ;	set the value as a String, trimming trailing zeroes.
public void set values ( array arr ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( arr == null ) { data type = data type . string ; return ; } if ( arr . get element type ( ) == char . class ) {	set the values from an Array.
public void scan ( ) throws io { if ( state == num ) throw new illegal state exception ( str ) ; if ( state >= num ) throw new illegal state exception ( str ) ; state = num ;	Scan the collection and gather information on contained datasets.
public inv catalog impl generate proxy ds resolver catalog ( proxy dataset handler pdh ) { if ( state != num ) throw new illegal state exception ( str ) ; if ( ! proxy ds handlers . contains value ( pdh ) ) throw new illegal argument exception ( str ) ;	Generate the catalog for a resolver request of the given ProxyDatasetHandler.
void schedule write ( message m ) { q . add ( m ) ; if ( ! is scheduled . get and set ( bool ) ) { executor . submit ( this ) ; } }	put a message on the queue, schedule writing if not already scheduled.
private void set thredds datatype ( thredds . client . catalog . dataset inv dataset , string wants ) { if ( inv dataset == null ) return ; boolean wants viewer = wants . equals ( str ) ; boolean wants coord sys = wants . equals ( str ) ; try {	Jump to the appropriate tab based on datatype of InvDataset.
private void jumpto thredds datatype ( thredds . client . catalog . access inv access ) { if ( inv access == null ) { return ; } thredds . client . catalog . service s = inv access . get service ( ) ; if ( s . get type ( ) == service type . http ) { download file ( inv access . get standard url name ( ) ) ; return ; } if ( s . get type ( ) == service type . wms ) { open wms ( inv access . get standard url name ( ) ) ; return ; } if ( s . get type ( ) == service type . cdmr feature ) { open coverage dataset ( inv access . get wrapped url name ( ) ) ; return ; } thredds . client . catalog . dataset ds = inv access . get dataset ( ) ; if ( ds . get feature type ( ) == null ) {	jump to the appropriate tab based on datatype of InvAccess.
private static void prepare gui ( ) { final string os name = system . get property ( str ) . to lower case ( ) ; final boolean is mac os = os name . starts with ( str ) ; if ( is mac os ) { system . set property ( str , str ) ;	Set look-and-feel.
private static void create tools frame ( ) {	Must call this method on the event thread.
static public string make name ( list < coordinate axis > axes ) { list < coordinate axis > axes sorted = new array list < > ( axes ) ; collections . sort ( axes sorted , new coordinate axis . axis comparator ( ) ) ; string builder buff = new string builder ( ) ; for ( int i = num ; i < axes sorted . size ( ) ; i ++ ) { coordinate axis axis = axes sorted . get ( i ) ; if ( i > num ) buff . append ( str ) ; buff . append ( axis . get full name escaped ( ) ) ; } return buff . to string ( ) ; }	Create standard name from list of axes. Sort the axes first.
private coordinate axis lesser rank ( coordinate axis a1 , coordinate axis a2 ) { if ( a1 == null ) return a2 ; return ( a1 . get rank ( ) <= a2 . get rank ( ) ) ? a1 : a2 ; }	prefer smaller ranks, in case more than one.
public coordinate axis find axis ( axis type type ) { coordinate axis result = null ; for ( coordinate axis axis : coord axes ) { axis type axis type = axis . get axis type ( ) ; if ( ( axis type != null ) && ( axis type == type ) ) result = lesser rank ( result , axis ) ; } return result ; }	Find the CoordinateAxis that has the given AxisType.If more than one, return the one with lesser rank.
public ct get projection ct ( ) { for ( coordinate transform ct : coord trans ) { if ( ct instanceof ct ) return ( ct ) ct ; } return null ; }	Find the first ProjectionCT from the list of CoordinateTransforms.
public boolean is geo xy ( ) { if ( ( x axis == null ) || ( y axis == null ) ) return bool ; return null != get projection ( ) && ! ( projection instanceof lat lon projection ) ; }	true if it has X and Y CoordinateAxis, and a CoordTransform Projection.
public boolean is regular ( ) { for ( coordinate axis axis : coord axes ) { if ( ! ( axis instanceof d ) ) return bool ; if ( ! ( ( d ) axis ) . is regular ( ) ) return bool ; } return bool ; }	true if all axes are CoordinateAxis1D and are regular.
public static boolean is subset ( collection < dimension > subset , collection < dimension > set ) { for ( dimension d : subset ) { if ( ! ( set . contains ( d ) ) ) return bool ; } return bool ; }	Test if all the Dimensions in subset are in set.
public boolean contains axes ( list < coordinate axis > want axes ) { for ( coordinate axis ca : want axes ) { if ( ! contains axis ( ca . get full name ( ) ) ) return bool ; } return bool ; }	Do we have all the axes in the list?.
public boolean contains axis ( string axis name ) { for ( coordinate axis ca : coord axes ) { if ( ca . get full name ( ) . equals ( axis name ) ) return bool ; } return bool ; }	Do we have the named axis?.
public boolean contains domain ( list < dimension > want dimensions ) { for ( dimension d : want dimensions ) { if ( ! domain . contains ( d ) ) return bool ; } return bool ; }	Do we have all the dimensions in the list?.
public boolean contains axis types ( list < axis type > want axes ) { for ( axis type want axis type : want axes ) { if ( ! contains axis type ( want axis type ) ) return bool ; } return bool ; }	Do we have all the axes types in the list?.
public boolean contains axis type ( axis type want axis type ) { for ( coordinate axis ca : coord axes ) { if ( ca . get axis type ( ) == want axis type ) return bool ; } return bool ; }	Do we have an axes of the given type?.
public dap clone dag ( clone map map ) throws clone not supported exception { dap node = ( dap ) super . clone ( ) ;	This procedure does the actual recursive clone.
public object get selected bean ( ) { int view row index = jtable . get selected row ( ) ; if ( view row index < num ) return null ; int model row index = jtable . convert row index to model ( view row index ) ; return ( model row index < num ) || ( model row index >= beans . size ( ) ) ? null : beans . get ( model row index ) ; }	Get the currently selected bean, or null if none selected.
public list get selected beans ( ) { array list < object > list = new array list < > ( ) ; int [ ] view row indices = jtable . get selected rows ( ) ; for ( int view row index : view row indices ) { int model row index = jtable . convert row index to model ( view row index ) ; list . add ( beans . get ( model row index ) ) ; if ( debug selected ) system . out . println ( str + model row index + str + beans . get ( model row index ) ) ; } return list ; }	Get the currently selected beans. Use this for multiple selection.
public array list < object > get selected cells ( ) { array list < object > list = new array list < > ( ) ; int [ ] view row indices = jtable . get selected rows ( ) ; int [ ] view column indices = jtable . get selected columns ( ) ; for ( int i = num ; i < view row indices . length ; i ++ ) for ( int j = num ; i < view column indices . length ; j ++ ) { int model row index = jtable . convert row index to model ( view row indices [ i ] ) ; int model column index = jtable . convert column index to model ( view column indices [ j ] ) ; list . add ( model . get value at ( model row index , model column index ) ) ; } return list ; }	Get the currently selected cells.Use this for multiple row selection, when columnSelection is on.
public void set selected bean ( object bean ) { if ( bean == null ) return ; int model row index = beans . index of ( bean ) ; int view row index = jtable . convert row index to view ( model row index ) ; if ( view row index >= num ) jtable . get selection model ( ) . set selection interval ( view row index , view row index ) ; make row visible ( view row index ) ; }	Set which row is selected.
protected void restore state ( ) { if ( store == null ) { return ; } array list prop col objs = ( array list ) store . get bean ( str , new array list ( ) ) ; hidable table column model table column model = ( hidable table column model ) jtable . get column model ( ) ; int new view index = num ; for ( object prop col obj : prop col objs ) { property col prop col = ( property col ) prop col obj ; try { int current view index = table column model . get column index ( prop col . get name ( ) ) ;	Restore state from PreferencesExt.
public static unknown unit create ( string name ) throws name exception { unknown unit unit ; name = name . to lower case ( ) ; synchronized ( map ) { unit = map . get ( name ) ; if ( unit == null ) { unit = new unknown unit ( name ) ; map . put ( unit . get name ( ) , unit ) ; map . put ( unit . get plural ( ) , unit ) ; } } return unit ; }	Factory method for constructing an unknown unit from a name.
@ override public void close ( ) throws io { if ( closed ) return ; closed = bool ; try { consume ( ) ; } finally { super . close ( ) ; } if ( method != null ) method . close ( ) ; }	Closes this input stream and releases any system resources associatedwith the stream; closes the method also.
private boolean is extra ( variable v ) { return v != null && extras != null && extras . contains ( v ) ; }	Has v already been added to the set of extra variables?.
private boolean is coordinate ( variable v ) { if ( v == null ) return bool ; string name = v . get short name ( ) ; return ( lat ve != null && lat ve . axis name . equals ( name ) ) || ( lon ve != null && lon ve . axis name . equals ( name ) ) || ( alt ve != null && alt ve . axis name . equals ( name ) ) || ( stn alt ve != null && stn alt ve . axis name . equals ( name ) ) || ( time ve != null && time ve . axis name . equals ( name ) ) || ( nom time ve != null && nom time ve . axis name . equals ( name ) ) ; }	Is v a coordinate axis for this feature type?.
private coord var extractor find coordinate axis ( table . coord name coord name , table t , int nesting level ) { if ( t == null ) return null ; string axis name = t . find coordinate variable name ( coord name ) ; if ( axis name != null ) { ds v = t . find variable ( axis name ) ; if ( v != null ) return new coord var extractor variable ( v , axis name , nesting level ) ; if ( t . extra joins != null ) { for ( join j : t . extra joins ) { v = j . find variable ( axis name ) ; if ( v != null ) return new coord var extractor variable ( v , axis name , nesting level ) ; } }	find a coord axis of the given type in the table and its parents.
private void add data variables ( list < if > list , table t ) { if ( t . parent != null ) add data variables ( list , t . parent ) ; for ( if col : t . cols . values ( ) ) { if ( t . nondata vars . contains ( col . get full name ( ) ) ) continue ; if ( t . nondata vars . contains ( col . get short name ( ) ) ) continue ;	use recursion so that parent variables come first.
void add parent join ( cursor cursor ) throws io { int level = cursor . current index ; table t = get table ( level ) ; if ( t . extra joins != null ) { list < structure data > sdata = new array list < > ( num ) ; sdata . add ( cursor . table data [ level ] ) ; for ( join j : t . extra joins ) { sdata . add ( j . get join data ( cursor ) ) ; } cursor . table data [ level ] = structure data factory . make ( sdata . to array ( new structure data [ sdata . size ( ) ] ) ) ;	add table join to this cursor level.
station feature make station ( structure data station data ) { if ( stn ve . is missing ( station data ) ) return null ; string station name = stn ve . get coord value as string ( station data ) ; string station desc = ( stn desc ve == null ) ? str : stn desc ve . get coord value as string ( station data ) ; string stn wmo id = ( wmo ve == null ) ? str : wmo ve . get coord value as string ( station data ) ; double lat = lat ve . get coord value ( station data ) ; double lon = lon ve . get coord value ( station data ) ; double elev = ( stn alt ve == null ) ? double . n : stn alt ve . get coord value ( station data ) ;	also called from StandardPointFeatureIterator.
public node map < cdm , dap node > create ( ) throws dap exception {	Do the conversion and return a NodeMaprepresenting the conversion.
static public simple unit factory ( string name ) { try { return factory with exceptions ( name ) ; } catch ( exception e ) { if ( debug parse ) system . out . println ( str + name + str + e ) ; return null ; } }	Create a SimpleUnit from the given name, catch Exceptions.
static public simple unit factory with exceptions ( string name ) throws unit exception { unit format format = unit format manager . instance ( ) ; unit uu = format . parse ( name ) ;	Create a SimpleUnit from the given name, allow Exceptions.
static public boolean is compatible with exceptions ( string unit string1 , string unit string2 ) throws unit exception { unit format format = unit format manager . instance ( ) ; unit uu1 = format . parse ( unit string1 ) ; unit uu2 = format . parse ( unit string2 ) ; return uu1 . is compatible ( uu2 ) ; }	Return true if unitString1 is convertible to unitString2.
static public boolean is date unit ( ucar . units . unit uu ) { boolean ok = uu . is compatible ( date reference unit ) ; if ( ! ok ) return bool ; try { uu . get converter to ( date reference unit ) ; return bool ; } catch ( conversion exception e ) { return bool ; } }	Return true if this ucar.units.Unit is a Date.
static public boolean is time unit ( string unit string ) { simple unit su = factory ( unit string ) ; return su != null && is time unit ( su . get unit ( ) ) ; }	Return true if the given unit is a time Unit, eg "seconds".
static public double get conversion factor ( string input unit string , string output unit string ) throws illegal argument exception { simple unit input unit = simple unit . factory ( input unit string ) ; simple unit output unit = simple unit . factory ( output unit string ) ; return input unit . convert to ( num , output unit ) ; }	Get the conversion factor to convert inputUnit to outputUnit.
public double convert to ( double value , simple unit output unit ) throws illegal argument exception { try { return uu . convert to ( value , output unit . get unit ( ) ) ; } catch ( conversion exception e ) { throw new illegal argument exception ( e . get message ( ) ) ; } }	Convert given value of this unit to the new unit.
public boolean is unknown unit ( ) { ucar . units . unit uu = get unit ( ) ; if ( uu instanceof ucar . units . unknown unit ) return bool ; if ( uu instanceof ucar . units . derived unit ) return is unknown unit ( ( ucar . units . derived unit ) uu ) ; if ( uu instanceof ucar . units . scaled unit ) { ucar . units . scaled unit scu = ( ucar . units . scaled unit ) uu ; unit u = scu . get unit ( ) ; if ( u instanceof ucar . units . unknown unit ) return bool ; if ( u instanceof ucar . units . derived unit ) return is unknown unit ( ( ucar . units . derived unit ) u ) ; } return bool ; }	Is this an instance of an UnknownUnit?.
public double get value ( ) { if ( ! ( uu instanceof scaled unit ) ) return double . n ; scaled unit offset = ( scaled unit ) uu ; return offset . get scale ( ) ; }	Extract the value, can only be called for ScaledUnit.
public top level clause new rel op clause ( int operator , sub clause lhs , list rhs ) throws da { return new rel op clause ( operator , lhs , rhs ) ; }	Generates a clause which which compares subclauses, using one of therelative operators supported by the Operator class.
public top level clause new bool function clause ( string function name , list children ) throws da , no such function exception { bool function function = function library . get bool function ( function name ) ; if ( function == null ) { if ( function library . get bt ( function name ) != null ) { throw new no such function exception ( str + function name + str + str + str ) ; } else { throw new no such function exception ( str + function name + str ) ; } } return new bool function clause ( function , children ) ; }	Generates a clause which invokes a function that returns aboolean value.
public sub clause new bt ( string function name , list children ) throws da , no such function exception { bt function = function library . get bt ( function name ) ; if ( function == null ) { if ( function library . get bool function ( function name ) != null ) { throw new no such function exception ( str + function name + str + str ) ; } else { throw new no such function exception ( str + function name + str ) ; } } return new bt ( function , children ) ; }	Generates a clause which invokes a function that returns aBaseType.
public static java . awt . image . buffered image make grayscale image ( array ma , is missing evaluator miss eval ) { if ( ma . get rank ( ) < num ) return null ; if ( ma . get rank ( ) == num ) ma = ma . reduce ( ) ; if ( ma . get rank ( ) == num ) ma = ma . slice ( num , num ) ;	Adapt a rank 2 array into a java.awt.image.BufferedImage.If passed a rank 3 array, take first 2D slice.
public int crawl ( inv catalog impl cat , cancel task task , print writer out , object context ) { if ( out != null ) out . println ( str + cat . get create from ( ) ) ; count catrefs = num ; for ( inv dataset ds : cat . get datasets ( ) ) { if ( type == type . all ) crawl dataset ( ds , task , out , context , bool ) ; else crawl direct datasets ( ds , task , out , context , bool ) ; if ( ( task != null ) && task . is cancel ( ) ) break ; } return num + count catrefs ; }	Crawl a catalog thats already been opened.When you get to a dataset containing leaf datasets, do all, only the first, or a randomly chosen one.
public void crawl dataset ( inv dataset ds , cancel task task , print writer out , object context , boolean release ) { boolean is cat ref = ( ds instanceof inv catalog ref ) ; if ( filter != null && filter . skip all ( ds ) ) { if ( is cat ref && release ) ( ( inv catalog ref ) ds ) . release ( ) ; return ; } boolean is data scan = ds . find property ( str ) != null ; if ( is cat ref ) { inv catalog ref catref = ( inv catalog ref ) ds ; if ( out != null ) out . println ( str + catref . get uri ( ) + str + ds . get name ( ) + str ) ; count catrefs ++ ; if ( ! listen . get catalog ref ( catref , context ) ) { if ( release ) catref . release ( ) ; return ; } } if ( ! is cat ref || is data scan ) listen . get dataset ( ds , context ) ;	Crawl this dataset recursively, return all datasets.
public void crawl direct datasets ( inv dataset ds , cancel task task , print writer out , object context , boolean release ) { boolean is cat ref = ( ds instanceof inv catalog ref ) ; if ( filter != null && filter . skip all ( ds ) ) { if ( is cat ref && release ) ( ( inv catalog ref ) ds ) . release ( ) ; return ; } if ( is cat ref ) { inv catalog ref catref = ( inv catalog ref ) ds ; if ( out != null ) out . println ( str + catref . get uri ( ) + str + ds . get name ( ) + str ) ; count catrefs ++ ; if ( ! listen . get catalog ref ( catref , context ) ) { if ( release ) catref . release ( ) ; return ; } }	Crawl this dataset recursively. Only send back direct datasets.
public static file get file or cache ( string file location ) { file result = get existing file or cache ( file location ) ; if ( result != null ) return result ; return get disk cache2 ( ) . get file ( file location ) ; }	Get index file, may be in cache directory, may not exist.
public static file get existing file or cache ( string file location ) { file result = get disk cache2 ( ) . get existing file or cache ( file location ) ; if ( result == null && grib . debug gbx index only && file location . ends with ( str ) ) {	Looking for an existing file, in cache or not.
static public void set debug leaks ( boolean b ) { if ( b ) { count open files . set ( num ) ; max open files . set ( num ) ; all files = new hash set < > ( num ) ; } debug leaks = b ; }	Debugging, do not use in production.Set counters to zero, set debugging on.
static public list < string > get all files ( ) { if ( null == all files ) return null ; list < string > result = new array list < > ( ) ; result . add all ( all files ) ; collections . sort ( result ) ; return result ; }	Debugging, do not use.
public synchronized void close ( ) throws io { if ( cache != null ) { if ( cache state > num ) { if ( cache state == num ) { cache state = num ; if ( cache . release ( this ) )	Close the file, and release any associated system resources.
public void seek ( long pos ) throws io { if ( pos < num ) throw new java . io . io ( str ) ;	Set the position in the file for the next read or write.
public void flush ( ) throws io { if ( buffer modified ) { file . seek ( buffer start ) ; file . write ( buffer , num , data size ) ;	Copy the contents of the buffer to the disk.
public int read ( ) throws io {	Read a byte of data from the file, blocking until data isavailable.
public final void read short ( short [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { pa [ start + i ] = read short ( ) ; } }	Read an array of shorts.
public final int read int unbuffered ( long pos ) throws io { byte [ ] bb = new byte [ num ] ; read ( pos , bb , num , num ) ; int ch1 = bb [ num ] & num ; int ch2 = bb [ num ] & num ; int ch3 = bb [ num ] & num ; int ch4 = bb [ num ] & num ; if ( ( ch1 | ch2 | ch3 | ch4 ) < num ) { throw new eof ( ) ; } if ( big endian ) { return ( ( ch1 << num ) + ( ch2 << num ) + ( ch3 << num ) + ( ch4 ) ) ; } else { return ( ( ch4 << num ) + ( ch3 << num ) + ( ch2 << num ) + ( ch1 ) ) ; } }	Read an integer at the given position, bypassing all buffering.
public final void read int ( int [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { pa [ start + i ] = read int ( ) ; } }	Read an array of ints.
public final void read long ( long [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { pa [ start + i ] = read long ( ) ; } }	Read an array of longs.
public final void read float ( float [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { pa [ start + i ] = float . int bits to float ( read int ( ) ) ; } }	Read an array of floats.
public final void read double ( double [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { pa [ start + i ] = double . long bits to double ( read long ( ) ) ; } }	Read an array of doubles.
public string read string ( int nbytes ) throws io { byte [ ] data = new byte [ nbytes ] ; read fully ( data ) ; return new string ( data , cdm . utf8 charset ) ; }	Read a String of known length.
public string read string max ( int nbytes ) throws io { byte [ ] b = new byte [ nbytes ] ; read fully ( b ) ; int count ; for ( count = num ; count < nbytes ; count ++ ) if ( b [ count ] == num ) break ; return new string ( b , num , count , cdm . utf8 charset ) ; }	Read a String of max length, zero terminate.
public final void write boolean ( boolean [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { write boolean ( pa [ start + i ] ) ; } }	Write an array of booleans.
public final void write short ( short [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { write short ( pa [ start + i ] ) ; } }	Write an array of shorts.
public final void write char ( char [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { write char ( pa [ start + i ] ) ; } }	Write an array of chars.
public final void write int ( int [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { write int ( pa [ start + i ] ) ; } }	Write an array of ints.
public final void write long ( long [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { write long ( pa [ start + i ] ) ; } }	Write an array of longs.
public final void write float ( float [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { write float ( pa [ start + i ] ) ; } }	Write an array of floats.
public final void write double ( double [ ] pa , int start , int n ) throws io { for ( int i = num ; i < n ; i ++ ) { write double ( pa [ start + i ] ) ; } }	Write an array of doubles.
public final void write bytes ( string s ) throws io { int len = s . length ( ) ; for ( int i = num ; i < len ; i ++ ) { write ( ( byte ) s . char at ( i ) ) ; } }	Writes the string to the file as a sequence of bytes.
public final void write bytes ( char b [ ] , int off , int len ) throws io { for ( int i = off ; i < len ; i ++ ) { write ( ( byte ) b [ i ] ) ; } }	Writes the character array to the file as a sequence of bytes.
public boolean search forward ( kmp match , int max bytes ) throws io { long start = get file pointer ( ) ; long last = ( max bytes < num ) ? length ( ) : math . min ( length ( ) , start + max bytes ) ; long need to scan = last - start ;	Search forward from the current pos, looking for a match.
public void append query ( string buffer sbuff , array list values ) { if ( template != null ) append query from template ( sbuff , values ) ; else append query from param value ( sbuff , values ) ; }	Create the selector result string, and append.
static public m factory ( feature collection config config , path top dir , boolean is top , index reader index reader , string suffix , org . slf4j . logger logger ) throws io { directory builder builder = new directory builder ( config . collection name , top dir . to string ( ) , suffix ) ; directory partition dpart = new directory partition ( config , top dir , is top , index reader , suffix , logger ) ; if ( ! builder . is leaf ( index reader ) ) {	returns a DirectoryPartition or DirectoryCollection.
public boolean find index ( ) throws io { path index path = paths . get ( dir . to string ( ) , partition name + suffix ) ; if ( files . exists ( index path ) ) { this . index = index path ; basic file attributes attr = files . read attributes ( index path , basic file attributes . class ) ; this . index last modified = attr . last modified time ( ) ; this . index size = attr . size ( ) ; return bool ; } return bool ; }	Find the index file, using its canonical name.
private boolean is leaf ( index reader index reader ) throws io { if ( partition status == partition status . unknown ) { int count dir = num , count file = num , count = num ; try ( directory stream < path > dir stream = files . new directory stream ( dir ) ) { iterator < path > iterator = dir stream . iterator ( ) ; while ( iterator . has next ( ) && count ++ < num ) { path p = iterator . next ( ) ; basic file attributes attr = files . read attributes ( p , basic file attributes . class ) ; if ( attr . is directory ( ) ) count dir ++ ; else count file ++ ; } } partition status = ( count file > count dir ) ? partition status . is leaf : partition status . is directory partition ; } return partition status == partition status . is leaf ; }	Scans first 100 files to decide if its a leaf.
public list < directory builder > construct children ( index reader index reader , collection update type force collection ) throws io { if ( children constructed ) return children ; if ( index != null && force collection == collection update type . nocheck ) {	Find all children directories.
private void scan for children ( ) { if ( debug ) system . out . printf ( str , dir ) ; int count = num ; try ( directory stream < path > ds = files . new directory stream ( dir ) ) { for ( path p : ds ) { basic file attributes attr = files . read attributes ( p , basic file attributes . class ) ; if ( attr . is directory ( ) ) { children . add ( new directory builder ( top collection name , p , attr , suffix ) ) ; if ( debug && ( ++ count % num == num ) ) system . out . printf ( str , count ) ; } } } catch ( io e ) { e . print stack trace ( ) ; } if ( debug ) system . out . printf ( str , count ) ; children constructed = bool ; }	Scan for subdirectories, make each into a DirectoryBuilder and add as a child.
public list < m > read files from index ( index reader index reader ) throws io { list < m > result = new array list < > ( num ) ; if ( index == null ) return result ; index reader . read m ( index , result ) ; return result ; }	read the list of files from the index.
public list < ucar . nc2 . dt . grid dataset . gridset > get gridsets ( ) { return new array list < ucar . nc2 . dt . grid dataset . gridset > ( gridset hash . values ( ) ) ; }	Return GridDatatype objects grouped by GridCoordSys.
public file cacheable acquire ( file factory factory , dataset url durl , ucar . nc2 . util . cancel task cancel task ) throws io { return acquire ( factory , durl . trueurl , durl , - num , cancel task , null ) ; }	Acquire a FileCacheable, and lock it so no one else can use it.call FileCacheable.close when done.
private void remove ( cache element . cache file want ) { want . remove ( ) ; files . remove ( want . ncfile ) ; try { want . ncfile . set file cache ( null ) ;	LOOK should you remove the entire CacheElement ?.
@ override public void eject ( object hash key ) { if ( disabled . get ( ) ) return ;	Remove all instances of object from the cache.
@ override public boolean release ( file cacheable ncfile ) throws io { if ( ncfile == null ) return bool ; if ( disabled . get ( ) ) { ncfile . set file cache ( null ) ;	Release the file. This unlocks it, updates its lastAccessed date.Normally applications need not call this, just close the file as usual.The FileCacheable has to do tricky stuff.
private static int int4 ( int a , int b , int c , int d ) {	Convert 4 bytes into a signed integer.
private cache element update in cache ( cache element elem ) { if ( shadow cache . first key ( ) == elem ) return elem ; elem . update accessed ( ) ; cache element prev = shadow cache . put ( elem , elem ) ;	get CacheElement specified by hashKey.
public synchronized void clear cache ( boolean force ) { list < cache element . cache file > delete list = new array list < > ( num * cache . size ( ) ) ; if ( force ) { cache . clear ( ) ;	Remove all cache entries.
void make vertical transform ( grid dataset gds , formatter parse info ) { if ( vt != null ) return ;	we have to delay making these, since we dont identify the dimensions specifically until now.
@ override public boolean is global lon ( ) { if ( ! is lat lon ) return bool ; if ( ! ( horiz xaxis instanceof d ) ) return bool ; d lon = ( d ) horiz xaxis ; double first = lon . get coord edge ( num ) ; double last = lon . get coord edge ( ( int ) lon . get size ( ) ) ; double min = math . min ( first , last ) ; double max = math . max ( first , last ) ; return ( max - min ) >= num ; }	Is this a global coverage over longitude ?.
@ override public boolean is z ( ) { if ( vert zaxis == null ) return bool ; if ( vert zaxis . get positive ( ) != null ) { return vert zaxis . get positive ( ) . equals ignore case ( ucar . nc2 . constants . cf . positive up ) ; } if ( vert zaxis . get axis type ( ) == axis type . height ) return bool ; return vert zaxis . get axis type ( ) != axis type . pressure ; }	true if increasing z coordinate values means "up" in altitude.
@ override public int [ ] find x ( double x coord , double y coord , int [ ] result ) { if ( result == null ) result = new int [ num ] ; if ( ( horiz xaxis instanceof d ) && ( horiz yaxis instanceof d ) ) { result [ num ] = ( ( d ) horiz xaxis ) . find coord element ( x coord ) ; result [ num ] = ( ( d ) horiz yaxis ) . find coord element ( y coord ) ; return result ; } else if ( ( horiz xaxis instanceof d ) && ( horiz yaxis instanceof d ) ) { if ( g2d == null ) g2d = new d ( ( d ) horiz yaxis , ( d ) horiz xaxis ) ; int [ ] result2 = new int [ num ] ; boolean found = g2d . find coord element ( y coord , x coord , result2 ) ; if ( found ) { result [ num ] = result2 [ num ] ; result [ num ] = result2 [ num ] ; } else { result [ num ] = - num ; result [ num ] = - num ; } return result ; }	Given a point in x,y coordinate space, find the x,y index in the coordinate system.
@ override public int [ ] find x ( double x coord , double y coord , int [ ] result ) { if ( result == null ) result = new int [ num ] ; if ( ( horiz xaxis instanceof d ) && ( horiz yaxis instanceof d ) ) { result [ num ] = ( ( d ) horiz xaxis ) . find coord element bounded ( x coord ) ; result [ num ] = ( ( d ) horiz yaxis ) . find coord element bounded ( y coord ) ; return result ; } else if ( ( horiz xaxis instanceof d ) && ( horiz yaxis instanceof d ) ) { if ( g2d == null ) g2d = new d ( ( d ) horiz yaxis , ( d ) horiz xaxis ) ; int [ ] result2 = new int [ num ] ; g2d . find coord element ( y coord , x coord , result2 ) ;	Given a point in x,y coordinate space, find the x,y index in the coordinate system.If outside the range, the closest point is returned, eg, 0 or n-1 depending on if the coordinate is too small or too large.
@ override public int [ ] find x ( double lat , double lon , int [ ] result ) { projection data projection = get projection ( ) ; projection point pp = data projection . lat lon to proj ( new lat lon point impl ( lat , lon ) , new projection point impl ( ) ) ; return find x ( pp . get x ( ) , pp . get y ( ) , result ) ; }	Given a lat,lon point, find the x,y index in the coordinate system.
@ override public int [ ] find x ( double lat , double lon , int [ ] result ) { projection data projection = get projection ( ) ; projection point pp = data projection . lat lon to proj ( new lat lon point impl ( lat , lon ) , new projection point impl ( ) ) ; return find x ( pp . get x ( ) , pp . get y ( ) , result ) ; }	Given a lat,lon point, find the x,y index in the coordinate system.If outside the range, the closest point is returned.
protected int get item pos ( ) { if ( nitems < num ) return - arrow size ;	return slider indicator position for currently selected item.
protected int get item ( int pixel ) { if ( nitems < num ) return num ; int eff width = b . width - num * arrow size ;	return item selected by this pixel position.
public void iterate over m ( visitor visit ) throws io { if ( debug ) system . out . printf ( str , collection dir ) ; int count = num ; try ( directory stream < path > ds = files . new directory stream ( collection dir , new my stream filter ( ) ) ) { for ( path p : ds ) { try { basic file attributes attr = files . read attributes ( p , basic file attributes . class ) ; if ( ! attr . is directory ( ) ) visit . consume ( new m o ( p ) ) ; if ( debug ) system . out . printf ( str , count ++ ) ; } catch ( io ioe ) {	this idiom keeps the iterator from escaping, so that we can use try-with-resource, and ensure DirectoryStream closes. like++.
public void get remote files ( final cancel task cancel ) { this . cancel = cancel ; string urls = config . get server prefix ( ) + str + type + str ; ta . append ( string . format ( str , urls ) ) ; string contents = null ; try ( http method = http . get ( session , urls ) ) { int status code = method . execute ( ) ; if ( status code == num ) contents = method . get response as string ( ) ; if ( ( contents == null ) || ( contents . length ( ) == num ) ) { ta . append ( string . format ( str , urls ) ) ; return ; } else { ta . append ( string . format ( str , urls , contents ) ) ; } } catch ( throwable t ) { ta . append ( string . format ( str , urls , t . get message ( ) ) ) ; t . print stack trace ( ) ; return ; }	copy remote files to localDir.
@ override public string get sub center name ( int center , int subcenter ) { switch ( subcenter ) { case num : return null ; case num : return str ; case num : return str ; } return super . get sub center name ( center , subcenter ) ; }	LOOK maybe combine grib1, grib2 and bufr ??.
public static calendar period . field from unit string ( string udunit ) { udunit = udunit . trim ( ) ; udunit = udunit . to lower case ( ) ; if ( udunit . equals ( str ) ) return field . second ; if ( udunit . equals ( str ) ) return field . millisec ;	Convert a period string into a CalendarPeriod.Field.
public static calendar period of ( int value , field field ) { calendar period want = new calendar period ( value , field ) ; if ( cache == null ) return want ; calendar period got = cache . get if present ( want ) ; if ( got != null ) return got ; cache . put ( want , want ) ; return want ; }	minimize memory use by interning. wacko shit in GribPartitionBuilder TimeCoordinate, whoduhthunk?.
public static calendar period of ( string udunit ) { int value ; string units ; string [ ] split = string util2 . split string ( udunit ) ; if ( split . length == num ) { value = num ; units = split [ num ] ; } else if ( split . length == num ) { try { value = integer . parse int ( split [ num ] ) ; } catch ( throwable t ) { return null ; } units = split [ num ] ; } else return null ; calendar period . field unit = calendar period . from unit string ( units ) ; return calendar period . of ( value , unit ) ; }	Convert a udunit period string into a CalendarPeriod.
public int subtract ( calendar date start , calendar date end ) { long diff = end . get difference in msecs ( start ) ; int thislen = millisecs ( ) ; if ( ( diff % thislen != num ) ) log . warn ( str ) ; return ( int ) ( diff / thislen ) ; }	Subtract two dates, return difference in units of this period.If not even, will round down and log a warning.
public double get convert factor ( calendar period from ) { if ( field == calendar period . field . month || field == calendar period . field . year ) { log . warn ( str ) ; } return ( double ) from . millisecs ( ) / millisecs ( ) ; }	Get the conversion factor of the other CalendarPeriod to this one.
public double get value in millisecs ( ) { if ( field == calendar period . field . month ) return num * num * num * num * num * value ; else if ( field == calendar period . field . year ) return num * num * num * num * num * value ; else return millisecs ( ) ; }	Get the duration in milliseconds -+.
public int get offset ( calendar date start , calendar date end ) { if ( start . equals ( end ) ) return num ; long start millis = start . get date time ( ) . get millis ( ) ; long end millis = end . get date time ( ) . get millis ( ) ;	start + offset = end.
public boolean sync ( ) throws io { if ( ( gemreader . get init file size ( ) < raf . length ( ) ) && extend index ) { gemreader . init ( bool ) ; grid index index = gemreader . get grid index ( ) ;	Sync the file.
private void init tables ( ) { try { gempak grid parameter table . add parameters ( str ) ; gempak grid parameter table . add parameters ( str ) ; } catch ( exception e ) { system . out . println ( str ) ; } }	Initialize the parameter tables.
private boolean put ( data root ext date root ext ) { map . put ( date root ext . get path ( ) , date root ext ) ; return tree set . add ( date root ext . get path ( ) ) ; }	Add a dataRootExt to in-memory tree.
public string find longest path match ( string req path ) { sorted set < string > tail = tree set . tail set ( req path ) ; if ( tail . is empty ( ) ) return null ; string after = tail . first ( ) ; if ( req path . starts with ( after ) )	Find the longest path match.
public data root find data root ( string req path ) { string path = find longest path match ( req path ) ; if ( path == null ) return null ; data root ext data root ext = map . get ( path ) ; if ( data root ext == null ) { logger . error ( str , path ) ; return null ; } return convert2 data root ( data root ext ) ; }	Find the longest DataRoot match.
public @ nonnull data root convert2 data root ( data root ext data root ext ) { data root data root = data root ext . get data root ( ) ; if ( data root != null ) return data root ;	convert a dataRootExt to a dataRoot.
public calendar date range get calendar date range ( calendar cal ) { if ( date range == null ) return null ; if ( cal . equals ( calendar . get default ( ) ) ) return date range ;	return requested CalendarDateRange.
public list < integer > reindex ( list < coordinate > coords ) { list < integer > result = new array list < > ( ) ; for ( coordinate coord : coords ) { coordinate sub = swap . get ( coord ) ; coordinate use = ( sub == null ) ? coord : sub ; integer idx = index map . get ( use ) ;	redo the variables against the shared coordinates.
static public netcdf file writer create new ( version version , string location , nc4 chunking chunker ) throws io { return new netcdf file writer ( version , location , bool , chunker ) ; }	Create a new Netcdf file, with fill mode true.
public group add group ( group parent , string name ) { if ( ! define mode ) throw new unsupported operation exception ( str ) ; if ( parent == null ) return ncfile . get root group ( ) ; group result = new group ( ncfile , parent , name ) ; parent . add group ( result ) ; return result ; }	Add a Group to the file.
public enum typedef add typedef ( group g , enum typedef td ) { if ( ! define mode ) throw new unsupported operation exception ( str ) ; if ( ! version . is extended model ( ) ) throw new illegal argument exception ( str + version ) ; g . add enumeration ( td ) ; return td ; }	Add a EnumTypedef to the file.
public attribute delete group attribute ( group g , string att name ) { if ( ! define mode ) throw new unsupported operation exception ( str ) ; if ( g == null ) g = ncfile . get root group ( ) ; attribute att = g . find attribute ( att name ) ; if ( null == att ) return null ; g . remove ( att ) ; return att ; }	Delete a group Attribute.
public attribute rename group attribute ( group g , string old name , string new name ) { if ( ! define mode ) throw new unsupported operation exception ( str ) ; if ( ! is valid object name ( new name ) ) { string newnew name = create valid object name ( new name ) ; log . warn ( str + new name + str + newnew name ) ; new name = newnew name ; } if ( g == null ) g = ncfile . get root group ( ) ; attribute att = g . find attribute ( old name ) ; if ( null == att ) return null ; g . remove ( att ) ; att = new attribute ( new name , att . get values ( ) ) ; g . add attribute ( att ) ; return att ; }	Rename a group Attribute.
public structure add record structure ( ) { if ( version != version . netcdf3 ) return null ; boolean ok = ( boolean ) ncfile . send iosp message ( netcdf file . iosp message add record structure ) ; if ( ! ok ) throw new illegal state exception ( str ) ; return ( structure ) ncfile . find variable ( str ) ; }	For netcdf3 only, take all unlimited variables and make them into a structure.
public void abort ( ) throws java . io . io { if ( spiw != null ) { spiw . close ( ) ; spiw = null ; } }	Abort writing to this file.
public void write properties ( print writer out ) throws io { if ( p == null ) p = bean parser . get parser ( o . get class ( ) ) ; p . write properties ( o , out ) ; }	write XML using the bean properties of the contained object.
public thredds metadata extract ( dataset thredds dataset ) throws io { thredds metadata metadata = new thredds metadata ( ) ; map < string , object > flds = metadata . get flds ( ) ; try ( data factory . result result = new data factory ( ) . open feature dataset ( thredds dataset , null ) ) { if ( result . fatal error ) { logger . warn ( str , result . err log ) ; return null ; } if ( result . feature type . is coverage feature type ( ) ) { grid dataset grid dataset = ( grid dataset ) result . feature dataset ;	extract info from underlying feature dataset.
@ override protected unit my divide into ( final unit that ) throws operation exception { return that instanceof offset unit ? get unit ( ) . divide into ( ( ( offset unit ) that ) . get unit ( ) ) : get unit ( ) . divide into ( that ) ; }	Divide this unit into another unit.
public double to derived unit ( final double amount ) throws conversion exception { if ( ! ( unit instanceof derivable unit ) ) { throw new conversion exception ( this , get derived unit ( ) ) ; } return ( ( derivable unit ) get unit ( ) ) . to derived unit ( amount + get offset ( ) ) ; }	Converts a value in this unit to the equivalent value in the convertiblederived unit.
public double from derived unit ( final double amount ) throws conversion exception { if ( ! ( unit instanceof derivable unit ) ) { throw new conversion exception ( get derived unit ( ) , this ) ; } return ( ( derivable unit ) get unit ( ) ) . from derived unit ( amount ) - get offset ( ) ; }	Converts a value in the convertible derived unit to the equivalent valuein this unit.
public array convert nested variable ( ucar . nc2 . variable v , list < range > section , v data v , boolean flatten ) throws io , da { array data = convert top variable ( v , section , data v ) ; if ( flatten ) { array structure as = ( array structure ) data ;	Convert a DataDDS into an Array for a Structure member variable.
public array convert top variable ( ucar . nc2 . variable v , list < range > section , v data v ) throws io , da { array data = convert ( data v ) ;	Convert a DataDDS into an Array for a top level variable, ie not a Structure member variable.
public array convert ( v data v ) throws io , da {	Convert a DataDDS into an Array.
static synchronized public void close all ( ) { list < metadata manager > close databases = new array list < > ( open databases ) ; for ( metadata manager mm : close databases ) { if ( debug ) system . out . println ( str + mm . collection name ) ; mm . close ( ) ; } open databases = new array list < > ( ) ;	this is called on TDS shutdown and reinit.
private synchronized void open database ( ) { if ( database != null ) return ; database config db config = new database config ( ) ; db config . set read only ( read only ) ; db config . set allow create ( ! read only ) ; if ( ! read only ) db config . set deferred write ( bool ) ; database = my env . open database ( null , collection name , db config ) ; open databases . add ( this ) ; }	assumes only one open at a time; could have MetadataManagers share open databases.
static org . joda . time . period convert to period ( int value , string udunit ) { if ( udunit . ends with ( str ) ) udunit = udunit . substring ( num , udunit . length ( ) - num ) ; switch ( udunit ) { case str : return period . millis ( value ) ; case str : return period . seconds ( value ) ; case str : return period . minutes ( value ) ; case str : case str : return period . hours ( value ) ; case str : return period . days ( value ) ; case str : return period . weeks ( value ) ; case str : return period . months ( value ) ; case str : return period . years ( value ) ; } throw new illegal argument exception ( str + udunit + str ) ; }	Convert a time udunit string.
public void ensure capacity ( long min capacity ) { if ( array . length < min capacity ) {	This ensures that the capacity is at least 'minCapacity'.
public string get ( int index ) { if ( index >= size ) throw new illegal argument exception ( erddap string2 . error + str + index + str + size + str ) ; return array [ index ] ; }	This gets a specified element.
public inv catalog impl make catalog for directory ( string org path , uri cat uri ) { if ( log . is debug enabled ( ) ) { log . debug ( str + cat uri ) ; log . debug ( str + org path ) ; log . debug ( str + root path ) ; log . debug ( str + scan location ) ; }	Try to build a catalog for the given path by scanning the locationassociated with this InvDatasetScan.
public inv catalog impl make proxy ds resolver catalog ( string path , uri base uri ) { if ( path == null ) return null ; if ( path . ends with ( str ) ) return null ;	Try to build a catalog for the given resolver path by scanning thelocation associated with this InvDatasetScan.
private data type get coordinate type ( ) { list < dataset > nested datasets = get datasets ( ) ; dataset outer dimension first = ( dataset outer dimension ) nested datasets . get ( num ) ; return first . is string valued ? data type . string : data type . double ; }	What is the data type of the aggregation coordinate ?.
@ nullable public static grib2 pds factory ( int template , byte [ ] input ) { switch ( template ) { case num : return new grib2 pds0 ( input ) ; case num : return new grib2 pds1 ( input ) ; case num : return new grib2 pds2 ( input ) ; case num : return new grib2 pds5 ( input ) ; case num : return new grib2 pds6 ( input ) ; case num : return new grib2 pds8 ( input ) ; case num : return new grib2 pds9 ( input ) ; case num : return new grib2 pds10 ( input ) ; case num : return new grib2 pds11 ( input ) ; case num : return new grib2 pds12 ( input ) ; case num : return new grib2 pds15 ( input ) ; case num : return new grib2 pds30 ( input ) ; case num : return new grib2 pds31 ( input ) ; case num : return new grib2 pds48 ( input ) ; case num : return new grib2 pds61 ( input ) ; default : log . warn ( str + template ) ; return null ; } }	Factory for Grib2Pds.
protected calendar date calc time ( int start index ) { int year = grib numbers . int2 ( get octet ( start index ++ ) , get octet ( start index ++ ) ) ; int month = get octet ( start index ++ ) ; int day = get octet ( start index ++ ) ; int hour = get octet ( start index ++ ) ; int minute = get octet ( start index ++ ) ; int second = get octet ( start index ++ ) ; if ( ( year == num ) && ( month == num ) && ( day == num ) && ( hour == num ) && ( minute == num ) && ( second == num ) ) return calendar date . unknown ;	null means use refTime.
double apply scale factor ( int scale , int value ) { return ( ( scale == num ) || ( scale == num ) || ( value == num ) ) ? value : value * math . pow ( num , - scale ) ; }	Apply scale factor to value, return a double result.
private void parse local concept ( string filename , string concept name ) throws io { try ( input stream is = new file input stream ( filename ) ) { add local concept ( is , concept name ) ; } }	Parse the localConcept files needed to create grib1 tables for use by the CDM.
private void add local concept ( input stream is , string concept name ) throws io { try ( buffered reader br = new buffered reader ( new input stream reader ( is , encoding ) ) ) { string line = br . read line ( ) ; while ( ! line . starts with ( str ) ) line = br . read line ( ) ;	Add the information from a localConcept file to super HashMap localConcepts.
private string clean line ( string line in ) { string line out ; line out = line in . replace all ( str , str ) ; line out = line out . replace all ( str , str ) ; line out = line out . replace all ( str , str ) ; return line out . trim ( ) ; }	clean the string representation of a line in the localConceptfile.
private void store concept ( string table version , string parameter number , string key , string value ) { hash map < string , hash map < string , string > > tmp table ; if ( local concepts . contains key ( table version ) ) { tmp table = local concepts . get ( table version ) ; if ( tmp table . contains key ( parameter number ) ) { hash map < string , string > tmp param = tmp table . get ( parameter number ) ; if ( ! tmp param . contains key ( key ) ) { tmp param . put ( key , value ) ; } else { system . out . println ( str + key + str + value ) ; } } else { hash map < string , string > tmp param = new hash map < > ( num ) ; tmp param . put ( key , value ) ; tmp table . put ( parameter number , tmp param ) ; } } else { tmp table = new hash map < > ( ) ; hash map < string , string > tmp param = new hash map < > ( num ) ; tmp param . put ( key , value ) ; tmp table . put ( parameter number , tmp param ) ; } local concepts . put ( table version , tmp table ) ; }	Store localConcept information in super HashMap localConcepts.
private void write grib1 tables ( ) throws io { simple date format date format = new simple date format ( str ) ; calendar cal = calendar . get instance ( ) ; string write date = date format . format ( cal . get time ( ) ) ; string grib1 info ; list < string > table nums = new array list < > ( ) ; hash map < string , string > param info ; path dir = paths . get ( ecmwf local concepts loc . replace ( str , str ) ) ; for ( string table num : local concepts . key set ( ) ) { table nums . add ( table num ) ; string file name = str + table num + str ; system . out . println ( str + file name ) ; path new file = dir . resolve ( file name ) ; files . delete if exists ( new file ) ; files . create file ( new file ) ; try ( buffered writer writer = files . new buffered writer ( new file , encoding ) ) { writer . write ( str + this . get class ( ) . get canonical name ( ) + str + write date ) ; writer . new line ( ) ; for ( string param num : local concepts . get ( table num ) . key set ( ) ) { param info = local concepts . get ( table num ) . get ( param num ) ; string short name = param info . get ( shortname id ) ; string description = param info . get ( description id ) ; string units = param info . get ( unit id ) ; grib1 info = param num + str + short name + str + description + str + units + str ; writer . write ( grib1 info ) ; writer . new line ( ) ; } } } write lookup table file ( table nums , dir , write date ) ; }	Write out grib1 tables based on localConcepts files - these are the tablesthat the CDM will read.
private void write lookup table file ( list < string > table nums , path dir , string write date ) throws io { system . out . println ( str ) ; collections . sort ( table nums ) ; path lookup table reg = dir . resolve ( str ) ; files . delete if exists ( lookup table reg ) ; files . create file ( lookup table reg ) ; try ( buffered writer writer = files . new buffered writer ( lookup table reg , encoding ) ) { writer . write ( str + this . get class ( ) . get canonical name ( ) + str + write date ) ; writer . new line ( ) ; for ( string tn : table nums ) { string table name = str + tn + str ; string reg = str + tn + str + table name ; writer . write ( reg ) ; writer . new line ( ) ; } } }	Write the lookupTables.txt file, which basically registers all of the new grib1 tableswith the CDM.
private void show local concepts ( ) { for ( string table num : local concepts . key set ( ) ) { for ( string param num : local concepts . get ( table num ) . key set ( ) ) { for ( string key : local concepts . get ( table num ) . get ( param num ) . key set ( ) ) { system . out . println ( key + str + local concepts . get ( table num ) . get ( param num ) . get ( key ) ) ; } } } }	Quick prinout to System.out of the different parameter metadata fields.
public static void main ( string [ ] args ) { ecmwf local concepts ec = new ecmwf local concepts ( ) ; try { ec . write grib1 tables ( ) ; system . out . println ( str ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	Generate grib1 tables for the CDM based on the localConcept files from ECMWF GRIB-API.
public static dataset source type get type ( string name ) { if ( name == null ) return null ; return ( ( dataset source type ) hash . get ( name ) ) ; }	Find the DatasetSourceType that matches this name.
public inv dataset expand ( ) throws io {	Crawl this DatasetSource and generate a new InvCatalog, return thetop-level InvDataset.Each object found on the DatasetSource becomes an InvDataset if it isaccepted by at least one DatasetFilter.
public inv catalog full expand ( ) throws io { logger . debug ( str , this . get name ( ) ) ; inv dataset top ds = this . expand ( ) ; inv catalog generated cat = top ds . get parent catalog ( ) ;	Crawl this DatasetSource and generate a new InvCatalog with all datasetsnamed, sorted, and organized as defined by this DatasetSource, return thenewly generated InvCatalog.
private void name datasets ( inv dataset impl dataset container ) { if ( this . get dataset namer list ( ) . is empty ( ) ) return ; if ( this . is flatten ( ) ) { logger . debug ( str ) ; this . name dataset list ( dataset container ) ; } else { logger . debug ( str + str ) ; inv dataset impl cur ds = null ; for ( int j = num ; j < dataset container . get datasets ( ) . size ( ) ; j ++ ) { cur ds = ( inv dataset impl ) dataset container . get datasets ( ) . get ( j ) ; this . name dataset tree ( cur ds ) ; } } return ; }	Use the list of dsNamers to name the given list of datasets.
private void name dataset list ( inv dataset impl dataset ) {	Name the datasets contained in the given dataset.The given dataset contains a flat list of datasets.
private void name dataset tree ( inv dataset impl dataset ) {	Name the datasets in the given dataset hierarchy using thisDatasetSource's list of datasetNamers.
public void load picture imd ( url image url , double rotation ) { tools . log ( str + image url . to string ( ) ) ; if ( source picture != null ) source picture . remove listener ( this ) ; source picture = new source picture ( ) ; source picture . add listener ( this ) ; set status ( loading , str + image url . to string ( ) ) ; scale after load = bool ; source picture . load picture ( image url , rotation ) ; }	Synchroneous method to load the image.It should only be called by something which is a thread itself such as the HtmlDistillerThread.Since this intended for large batch operations this bypasses the cache.
public void stop loading except ( url url ) { if ( source picture != null ) { boolean is currently loading = source picture . stop loading except ( url ) ; if ( ! is currently loading ) {	stops all picture loading except if the Url we desire is being loaded.
public void source status change ( int status code , string status message , source picture sp ) {	method that is invoked by the SourcePictureListener interface.
public void source load progress notification ( int status code , int percentage ) { enumeration e = scalable picture status listeners . elements ( ) ; while ( e . has more elements ( ) ) { ( ( scalable picture listener ) e . next element ( ) ) . source load progress notification ( status code , percentage ) ; } }	pass on the update on the loading Progress to the listening objects.
public void create scaled picture in thread ( int priority ) { set status ( scaling , str ) ; scale thread t = new scale thread ( this ) ; t . set priority ( priority ) ; t . start ( ) ; }	method that creates the scaled image in the background in it's own thread.
public dimension get scaled size ( ) { if ( scaled picture != null ) return new dimension ( scaled picture . get width ( ) , scaled picture . get height ( ) ) ; else return new dimension ( num , num ) ; }	return the size of the scaled image or Zero if there is none.
public string get scaled size string ( ) { if ( scaled picture != null ) return integer . to string ( scaled picture . get width ( ) ) + str + integer . to string ( scaled picture . get height ( ) ) ; else return str ; }	return the size of the scaled image as a neatly formatted text or Zero if there is none.
public list < string > get merged parts ( ) { list < string > list = new array list < > ( num ) ; list . add ( sndt ) ; return list ; }	Get the list of merged parts in this file.
private string make header ( gempak station stn , string date ) { string builder builder = new string builder ( ) ; builder . append ( str ) ; builder . append ( string util2 . pad right ( ( stn . get stid ( ) . trim ( ) + stn . get st ( ) . trim ( ) ) , num ) ) ; builder . append ( str ) ; builder . append ( str ) ; builder . append ( format . i ( stn . get stnm ( ) , num ) ) ; builder . append ( str ) ; builder . append ( str ) ; builder . append ( date ) ; builder . append ( str ) ; builder . append ( str ) ; builder . append ( format . d ( stn . get latitude ( ) , num ) ) ; builder . append ( str ) ; builder . append ( str ) ; builder . append ( format . d ( stn . get longitude ( ) , num ) ) ; builder . append ( str ) ; builder . append ( str ) ; builder . append ( format . d ( stn . get altitude ( ) , num ) ) ; builder . append ( str ) ; return builder . to string ( ) ; }	Make the header for the text report.
private list < string > sn ckua ( ) { list < string > types = new array list < > ( ) ; boolean above = bool ; boolean done = bool ; string part to check ; while ( ! done ) {	This subroutine checks the parts in a sounding data set for theunmerged data types.
private boolean check for valid group ( string part to check , string [ ] params ) { dm part = get part ( part to check ) ; if ( part == null ) { return bool ; } int i = num ; for ( dm parm : part . params ) { if ( ! ( parm . kprmnm . equals ( params [ i ++ ] ) ) ) { return bool ; } } return bool ; }	Check for valid groups.
static public void set root directory ( string cache dir ) { if ( ! cache dir . ends with ( str ) ) cache dir = cache dir + str ; root = string util2 . replace ( cache dir , str , str ) ;	Set the cache root directory.
static public void make root directory ( ) { file dir = new file ( root ) ; if ( ! dir . exists ( ) ) if ( ! dir . mkdirs ( ) ) throw new illegal state exception ( str + root + str ) ; check exist = bool ; }	Make sure that the current root directory exists.
static public file get cache file ( string file location ) { file f = new file ( make cache path ( file location ) ) ; if ( f . exists ( ) ) { if ( ! f . set last modified ( system . current time millis ( ) ) ) logger . warn ( str + f . get path ( ) ) ; } if ( ! check exist ) { file dir = f . get parent file ( ) ; if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) logger . warn ( str + dir . get path ( ) ) ; check exist = bool ; } return f ; }	Get a file in the cache.File may or may not exist.
static public void clean cache ( date cutoff , string builder sbuff ) { if ( sbuff != null ) sbuff . append ( str ) . append ( cutoff ) . append ( str ) ; file dir = new file ( root ) ; file [ ] children = dir . list files ( ) ; if ( children == null ) return ; for ( file file : children ) { date last mod = new date ( file . last modified ( ) ) ; if ( last mod . before ( cutoff ) ) { boolean ret = file . delete ( ) ; if ( sbuff != null ) { sbuff . append ( str ) . append ( file ) . append ( str ) . append ( last mod ) . append ( str ) ; if ( ! ret ) sbuff . append ( str ) . append ( file ) . append ( str ) ; } } } }	Remove all files with date < cutoff.
static public void clean cache ( long max bytes , comparator < file > file comparator , string builder sbuff ) { if ( sbuff != null ) sbuff . append ( str ) . append ( max bytes ) . append ( str ) . append ( root ) . append ( str ) ; file dir = new file ( root ) ; long total = num , total delete = num ; file [ ] files = dir . list files ( ) ; if ( files != null ) { list < file > file list = arrays . as list ( files ) ; collections . sort ( file list , file comparator ) ; for ( file file : file list ) { if ( file . length ( ) + total > max bytes ) { total delete += file . length ( ) ; if ( sbuff != null ) sbuff . append ( str ) . append ( file ) . append ( str ) . append ( file . length ( ) ) . append ( str ) ; if ( ! file . delete ( ) && sbuff != null ) sbuff . append ( str ) . append ( file ) . append ( str ) ; } else { total += file . length ( ) ; } } } if ( sbuff != null ) { sbuff . append ( str ) . append ( total delete ) . append ( str ) ; sbuff . append ( str ) . append ( total ) . append ( str ) ; } }	Remove files if needed to make cache have less than maxBytes bytes file sizes.This will remove files in sort order defined by fileComparator.The first files in the sort order are kept, until the max bytes is exceeded, then they are deleted.
static public boolean is bufr table ( short fxy ) { int f = ( fxy & num ) > > num ; int x = ( fxy & num ) > > num ; int y = ( fxy & num ) ; return ( f == num ) && ( x == num ) && ( y < num ) ; }	contains a BUFR table entry.
static public coordinate axis factory ( netcdf dataset ncd , ds vds ) { if ( ( vds . get rank ( ) == num ) || ( vds . get rank ( ) == num ) || ( vds . get rank ( ) == num && vds . get data type ( ) == data type . char ) ) { return new d ( ncd , vds ) ; } else if ( vds . get rank ( ) == num ) return new d ( ncd , vds ) ; else return new coordinate axis ( ncd , vds ) ; }	Create a coordinate axis from an existing Variable.
public coordinate axis copy no cache ( ) { coordinate axis axis = new coordinate axis ( ncd , get parent group ( ) , get short name ( ) , get data type ( ) , get dimensions string ( ) , get units string ( ) , get description ( ) ) ;	Make a copy, with an independent cache.
public boolean is numeric ( ) { return ( get data type ( ) != data type . char ) && ( get data type ( ) != data type . string ) && ( get data type ( ) != data type . structure ) ; }	Does the axis have numeric values.
public void get info ( formatter buf ) { buf . format ( str , get name and dimensions ( ) ) ; buf . format ( str , get units string ( ) ) ; if ( axis type != null ) { buf . format ( str , axis type . to string ( ) ) ; } buf . format ( str , get description ( ) ) ;	Get a string representation.
public ucar . nc2 . time . calendar get calendar from attribute ( ) { attribute cal = find attribute ( cf . calendar ) ; string s = ( cal == null ) ? null : cal . get string value ( ) ; if ( s == null ) {	needed by time coordinates.
public void set list ( array list row list ) { this . list = row list ; if ( list . size ( ) > num ) jtable . set row selection interval ( num , num ) ; else jtable . clear selection ( ) ; model . sort ( ) ; jtable . revalidate ( ) ; }	Replace the rowList with this one.
public table row get selected ( ) { if ( list . size ( ) == num ) return null ; int sel = jtable . get selected row ( ) ; if ( sel >= num ) return ( table row ) list . get ( sel ) ; else return null ; }	Get the currently selected row.
public void incr selected ( boolean increment ) { if ( list . size ( ) == num ) return ; int curr = jtable . get selected row ( ) ; if ( increment && ( curr < list . size ( ) - num ) ) set selected ( curr + num ) ; else if ( ! increment && ( curr > num ) ) set selected ( curr - num ) ; }	Increment or decrement the current selection by one row.
public int [ ] get model index ( ) { int [ ] model index = new int [ col name . length ] ; table column model tcm = jtable . get column model ( ) ; for ( int i = num ; i < col name . length ; i ++ ) { table column tc = tcm . get column ( i ) ; model index [ i ] = tc . get model index ( ) ; } return model index ; }	for each column, get the model index.
private void set selected index ( int idx ) { if ( z axis == null ) return ; event ok = bool ; current idx = idx ; slider . set value ( world2slider ( z axis . get coord value ( current idx ) ) ) ; event ok = bool ; }	set current value - no event.
static private void quick sort ( string a [ ] , int lo0 , int hi0 ) { int lo = lo0 ; int hi = hi0 ; string mid ; if ( hi0 > lo0 ) {	Internal recursive method to perform Quick Sort on name array.
static private void swap ( string a [ ] , int i , int j ) { string t ; t = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = t ; }	Private method to swap two elements in the array.
static public m os get existing file ( string filename ) { if ( filename == null ) return null ; file file = new file ( filename ) ; if ( file . exists ( ) ) return new m os ( file ) ; return null ; }	Make MFileOS if file exists, otherwise return null.
private double [ ] rotate ( double [ ] lonlat , double rot1 , double rot2 , double s ) { double e = math . to radians ( lonlat [ num ] - rot1 ) ;	Tor's transform algorithm renamed to rotate for clarity.
static public xml create from file ( string file name , xml stored defaults ) throws java . io . io { file prefs file = new file ( file name ) ;	Create an XMLStore reading from the specified filename.
static public xml create from input stream ( input stream is1 , input stream is2 , xml stored defaults ) throws java . io . io { if ( debug which store ) system . out . println ( str + is1 ) ; return new xml ( is1 , is2 , stored defaults ) ; }	Create an XMLStore reading from an input stream.
static public xml create from resource ( string resource name , xml stored defaults ) throws java . io . io {	Create a read-only XMLStore reading from the specified resource, opened as a Resource stream using theXMLStore ClassLoader.
static public string make standard filename ( string app name , string store name ) {	Convenience routine for creating an XMLStore file in a standard place.
public void save ( ) throws java . io . io { if ( prefs file == null ) throw new unsupported operation exception ( str ) ;	Save the current state of the Preferences tree to disk, using theoriginal filename.
public void save ( output stream out ) throws java . io . io { output exception message = null ;	Save the current state of the Preferences tree to the given OutputStream.
protected void write atomic variable ( data cursor data , serial writer dst ) throws io { dap variable template = ( dap variable ) data . get template ( ) ; assert ( this . ce . references ( template ) ) ; dap type basetype = template . get base type ( ) ;	Write out an atomic variable.
protected void write structure ( data cursor data , serial writer dst ) throws io { dap variable template = ( dap variable ) data . get template ( ) ; dap structure ds = ( dap structure ) template . get base type ( ) ; assert ( this . ce . references ( template ) ) ; list < slice > slices = ce . get constrained slices ( template ) ; odometer odom = odometer . factory ( slices ) ; while ( odom . has next ( ) ) { index index = odom . next ( ) ; data cursor [ ] instance = ( data cursor [ ] ) data . read ( index ) ; write structure1 ( instance [ num ] , dst ) ; } }	Write out a scalar or array structure instance.
protected void write structure1 ( data cursor instance , serial writer dst ) throws io { assert instance . get scheme ( ) == data cursor . scheme . structure ; dap variable template = ( dap variable ) instance . get template ( ) ; assert ( this . ce . references ( template ) ) ; dap structure ds = ( dap structure ) template . get base type ( ) ; list < dap variable > fields = ds . get fields ( ) ; for ( int i = num ; i < fields . size ( ) ; i ++ ) { dap variable field = fields . get ( i ) ; if ( ! this . ce . references ( field ) ) continue ;	Write out a single structure instance.
protected void write sequence ( data cursor data , serial writer dst ) throws io { dap variable template = ( dap variable ) data . get template ( ) ; dap sequence ds = ( dap sequence ) template . get base type ( ) ; assert ( this . ce . references ( template ) ) ; list < slice > slices = ce . get constrained slices ( template ) ; odometer odom = odometer . factory ( slices ) ; if ( bool ) while ( odom . has next ( ) ) { index index = odom . next ( ) ; data cursor [ ] instance = ( data cursor [ ] ) data . read ( index ) ; write sequence1 ( instance [ num ] , dst ) ; } else { data cursor [ ] instances = ( data cursor [ ] ) data . read ( slices ) ; for ( int i = num ; i < instances . length ; i ++ ) { write sequence1 ( instances [ i ] , dst ) ; } } }	Write out a single or array sequence instance.
protected void write record ( data cursor record , serial writer dst ) throws io { dap variable template = ( dap variable ) record . get template ( ) ; dap sequence seq = ( dap sequence ) template . get base type ( ) ; list < dap variable > fields = seq . get fields ( ) ; for ( int i = num ; i < fields . size ( ) ; i ++ ) { dap variable field = fields . get ( i ) ; if ( ! this . ce . references ( field ) ) continue ;	Write out a single Record instance.
static public boolean is valid file ( ucar . unidata . io . random access file raf ) throws io { raf . seek ( num ) ; if ( ! raf . search forward ( matcher , num * num ) ) return bool ;	is this a valid BUFR file.
public string get wmo id ( ) { string wmo id = str ; if ( ! ( stnm == gempak constants . imissd ) ) { wmo id = string . value of ( ( int ) ( stnm / num ) ) ; } return wmo id ; }	Get the WMO Station ID as a string.
int read row n ( data input stream ds , int n ) { if ( n > nrec ) return - num ; try { ds . read fully ( field , num , desc . field length ) ; } catch ( java . io . io e ) { return - num ; } switch ( desc . type ) { case str : case str : character [ n ] = new string ( field , cdm . utf8 charset ) ; break ; case str : numeric [ n ] = double . value of ( new string ( field , cdm . utf8 charset ) ) ; break ; case str : if ( desc . field length == num ) { numeric [ n ] = ( double ) swap . swap float ( field , num ) ; } else { numeric [ n ] = swap . swap double ( field , num ) ; } break ; case str : switch ( field [ num ] ) { case str : case str : case str : case str : logical [ n ] = bool ; break ; default : logical [ n ] = bool ; break ; } default : return - num ; } return num ; }	Method to read an entry from the data stream.
public object get data ( int i ) { switch ( type ) { case type char : return character [ i ] ; case type numeric : return numeric [ i ] ; case type boolean : return logical [ i ] ; } return null ; }	Method to retrieve data for this field.
private float [ ] get data0 ( random access file raf , grib2 drs . type0 gdrs ) throws io { int nb = gdrs . number of bits ; int d = gdrs . decimal scale factor ; float dd = ( float ) java . lang . math . pow ( ( double ) num , ( double ) d ) ; float r = gdrs . reference value ; int e = gdrs . binary scale factor ; float ee = ( float ) java . lang . math . pow ( num , ( double ) e ) ;	Grid point data - simple packing.
private float [ ] get data41 ( random access file raf , grib2 drs . type0 gdrs ) throws io { int nb = gdrs . number of bits ; int d = gdrs . decimal scale factor ; float dd = ( float ) java . lang . math . pow ( ( double ) num , ( double ) d ) ; float r = gdrs . reference value ; int e = gdrs . binary scale factor ; float ee = ( float ) java . lang . math . pow ( num , ( double ) e ) ;	Code taken from esupport ticket ZVT-415274.
static public void make file ( string location , ucar . nc2 . dt . grid dataset gds , list < string > grid list , lat lon rect llbb , calendar date range range ) throws io , invalid range exception { cf writer = new cf ( ) ; writer . make file ( location , gds , grid list , llbb , range , bool , num , num , num ) ; }	Write a netcdf-3 file from a subset of a grid dataset.
public long make grid file size estimate ( ucar . nc2 . dt . grid dataset gds , list < string > grid list , lat lon rect llbb , int horiz stride , range z range , calendar date range date range , int stride time , boolean add lat lon ) throws io , invalid range exception { return make or test size ( null , gds , grid list , llbb , horiz stride , z range , date range , stride time , add lat lon , bool , netcdf file writer . version . netcdf3 ) ; }	Write a netcdf-3 file from a subset of a grid dataset, as long as it doesnt exceed a certain file size.
public void make file ( string location , ucar . nc2 . dt . grid dataset gds , list < string > grid list , lat lon rect llbb , calendar date range range , boolean add lat lon , int horiz stride , int stride z , int stride time ) throws io , invalid range exception { make file ( location , gds , grid list , llbb , horiz stride , null , range , stride time , add lat lon , netcdf file writer . version . netcdf3 ) ; }	Write a CF compliant Netcdf-3 file from any gridded dataset.
public void set stations ( java . util . list < ucar . unidata . geoloc . station > stns ) { stations = new array list < ui > ( stns . size ( ) ) ; station hash . clear ( ) ; for ( int i = num ; i < stns . size ( ) ; i ++ ) { ucar . unidata . geoloc . station s = ( ucar . unidata . geoloc . station ) stns . get ( i ) ; ui sui = new ui ( s ) ;	Set the list of stations.
public void set selected station ( string name ) { ui sui = ( ui ) station hash . get ( name ) ; if ( sui != null ) { set selected station ( sui ) ; } }	set selected station based on the sttion id.
public ucar . unidata . geoloc . station pick ( d pick pt ) { if ( world2 normal == null || pick pt == null || stations . is empty ( ) ) return null ; world2 normal . transform ( pick pt , pt n ) ;	Find station that contains this point.
public ucar . unidata . geoloc . station pick closest ( d pick pt ) { if ( world2 normal == null || pick pt == null || stations . is empty ( ) ) return null ; world2 normal . transform ( pick pt , pt n ) ;	Find station closest to this point.
public ucar . unidata . geoloc . station get selected station ( ) { return ( selected != null ) ? selected . dd station : null ; }	Get the selected station.
public string get proj name ( int type ) { string proj name ; switch ( type ) { case pseudo mercator : case pseudo mercator general : proj name = str ; break ; case ps or lambert conic : proj name = ( vals [ num ] == vals [ num ] ) ? str : str ; break ; case equidistant : proj name = str ; break ; case lambert conformal tangent : proj name = str ; break ; default : proj name = str + type ; } return proj name ; }	Get the name for the projection type.
public list get stations ( ucar . unidata . geoloc . lat lon rect bounding box ) throws io { return typical . get stations ( bounding box ) ; }	Get all the Stations within a bounding box.
public ucar . unidata . geoloc . station get station ( string name ) { return typical . get station ( name ) ; }	Find a Station by name.
public data iterator get data iterator ( ucar . unidata . geoloc . station s ) throws io { return new station data iterator ( s ) ; }	Get all data for this Station.
public data iterator get data iterator ( ucar . unidata . geoloc . station s , date start , date end ) throws io { return new station date data iterator ( s , start , end ) ; }	Get data for this Station within the specified date range.
public void read data ( random access file raf , string abbrev , range gate range , index iterator ii ) throws io { long offset = ray offset ; offset += ( get data offset ( abbrev ) * num - num ) ; raf . seek ( offset ) ; byte [ ] b2 = new byte [ num ] ; int data count = get gate count ( abbrev ) ; byte [ ] data = new byte [ data count * num ] ; raf . read fully ( data ) ; for ( int gate idx : gate range ) { if ( gate idx >= data count ) ii . set short next ( uf header2 . missing ) ; else { b2 [ num ] = data [ gate idx * num ] ; b2 [ num ] = data [ gate idx * num + num ] ; short value = get short ( b2 , num ) ; ii . set short next ( value ) ; } } }	Read data from this ray.
public double dot ( ma v ) { if ( nelems != v . get nelems ( ) ) throw new illegal argument exception ( str + nelems + str + v . get nelems ( ) ) ; double sum = num ; for ( int k = num ; k < nelems ; k ++ ) sum += get double ( k ) * v . get double ( k ) ; return sum ; }	Dot product of 2 vectors.
public double norm ( ) { double sum = num ; for ( int k = num ; k < nelems ; k ++ ) { double val = get double ( k ) ; sum += val * val ; } return math . sqrt ( sum ) ; }	Get the L2 norm of this vector.
public void normalize ( ) { double norm = norm ( ) ; if ( norm <= num ) return ; for ( int k = num ; k < nelems ; k ++ ) { double val = get double ( k ) ; set double ( k , val / norm ) ; } }	Normalize this vector, so it has norm = 1.0.
private void set services ( iterable < dataset builder > ds iter ) { for ( dataset builder dsb : ds iter ) { for ( service s : dsb . get services ( ) ) { add service ( s ) ; } set services ( dsb . get datasets ( ) ) ;	pull services out of the datasets and into the catalog.
public grib1 parameter get parameter ( int id ) { if ( parameters == null ) { parameters = read parameter table ( ) ; } return parameters . get ( id ) ; }	Get the parameter with id.
public grib1 parameter get local parameter ( int id ) { if ( parameters == null ) { parameters = read parameter table ( ) ; } return parameters . get ( id ) ; }	Get the parameter with id, but dont look in default table.
public void add name ( final string name , final double value ) throws prefix exists exception { final prefix prefix = new prefix name ( name , value ) ; name set . add ( prefix ) ; }	Adds a prefix to the database by name.
public void add symbol ( final string symbol , final double value ) throws prefix exists exception { final prefix prefix = new prefix symbol ( symbol , value ) ; symbol set . add ( prefix ) ; value map . put ( new double ( value ) , prefix ) ; }	Adds a prefix symbol to the database.
private static prefix get prefix ( final string string , final set < prefix > set ) { for ( final iterator < prefix > iter = set . iterator ( ) ; iter . has next ( ) ; ) { final prefix prefix = iter . next ( ) ; final int comp = prefix . compare to ( string ) ; if ( comp == num ) { return prefix ; } if ( comp > num ) { break ; } } return null ; }	Returns the prefix from the given set with the given identifier.
protected boolean email ok ( thredds metadata . source p ) { string email = p . get email ( ) ; return email . index of ( str ) >= num ;	check its an acceptable form of email.
public double get parameter ( string name ) { double val = ( double ) parameters . get ( name . to lower case ( ) ) ; if ( val == null ) { throw new illegal argument exception ( str + name ) ; } return val . double value ( ) ; }	Get the value of the projection parameter.
public long calc crc ( ) { long crc ; if ( raw data == null ) crc = predefined grid definition center << num + predefined grid definition ; else { cr crc32 = new cr ( ) ; crc32 . update ( raw data ) ; crc = crc32 . get value ( ) ; } return crc ; }	Calculate the CRC of the entire byte array.
public final boolean is thin ( ) { if ( raw data == null ) return bool ; int octet5 = get octet ( num ) ; int nv = get octet ( num ) ; return ( octet5 != num ) && ( nv == num || nv == num ) ; }	is a "thin" grid.
@ override public int field index ( string name ) throws dap exception { dap structure ds ; if ( get template ( ) . get sort ( ) . is compound ( ) ) ds = ( dap structure ) get template ( ) ; else if ( get template ( ) . get sort ( ) . is var ( ) && ( ( ( dap variable ) get template ( ) ) . get base type ( ) . get sort ( ) . is compound ( ) ) ) ds = ( dap structure ) ( ( dap variable ) get template ( ) ) . get base type ( ) ; else throw new dap exception ( str ) ; int i = ds . index by name ( name ) ; if ( i < num ) throw new dap exception ( str + name ) ; return i ; }	Selected DataCursor API overrides.
public static string get time type name ( int time range indicator ) { string time range ; switch ( time range indicator ) { case num : time range = str ; break ;	code table 5 - 2010 edition of WMO manual on codes.
public string get time coord ( ) { if ( is interval ( ) ) { int [ ] intv = get interval ( ) ; return intv [ num ] + str + intv [ num ] ; } return integer . to string ( get forecast time ( ) ) ; }	A string representation of the time coordinate, whether its an interval or not.
public void set next ( polygon next ) { if ( next instanceof cf ) { set next ( ( cf ) next ) ; } else this . next = next ; }	Sets the next polygon which make up the multipolygon which this polygon is a part of.If next is a CFPolygon, automatically connects the other polygon to this polygon as well.
public void set prev ( polygon prev ) { if ( prev instanceof cf ) { set prev ( ( cf ) prev ) ; } else this . prev = prev ; }	Sets the previous polygon which makes up the multipolygon which this polygon is a part of.If prev is a CFPolygon, automatically connect the other polygon to this polygon as well.
public string find property ( string name ) { inv property result = null ; for ( inv property p : properties ) { if ( p . get name ( ) . equals ( name ) ) result = p ; } return ( result == null ) ? null : result . get value ( ) ; }	Get named property.
public void set current projection ( projection impl proj ) { int row ; if ( num <= ( row = model . search ( proj ) ) ) { if ( debug ) system . out . println ( str + row ) ; selected row = row ; set row selection interval ( row , row ) ; } else { if ( debug ) system . out . println ( str + row ) ; selected row = - num ; clear selection ( ) ; } }	set current projection if found, else deselect.
public optional < time offset axis > subset from time ( subset params params , calendar date run date ) { coord axis helper helper = new coord axis helper ( this ) ; coverage coord axis builder builder = null ; if ( params . is true ( subset params . time present ) ) { double offset = get offset in time units ( run date , calendar date . present ( ) ) ; builder = helper . subset closest ( offset ) ; } calendar date date wanted = ( calendar date ) params . get ( subset params . time ) ; if ( date wanted != null ) {	normal case already handled, this is the case where a time has been specified, and only one runtime.
static public void register io ( string class name ) throws illegal access exception , instantiation exception , class not found exception { class io class = netcdf file . class . get class loader ( ) . load class ( class name ) ; register io ( io class ) ; }	Register an IOServiceProvider, using its class string name.
static public void register io ( class iosp class , boolean last ) throws illegal access exception , instantiation exception { io spi ; spi = ( io ) iosp class . new instance ( ) ;	Register an IOServiceProvider. A new instance will be created when one of its files is opened.
static public boolean iosp registered ( class iosp class ) { for ( io spi : registered providers ) { if ( spi . get class ( ) == iosp class ) return bool ; } return bool ; }	See if a specific IOServiceProvider is registered.
static public boolean iosp de register ( class iosp class ) { for ( int i = num ; i < registered providers . size ( ) ; i ++ ) { io spi = registered providers . get ( i ) ; if ( spi . get class ( ) == iosp class ) { registered providers . remove ( i ) ; return bool ; } } return bool ; }	See if a specific IOServiceProvider is registered and if so, remove it.
static public boolean can open ( string location ) throws io { ucar . unidata . io . random access file raf = null ; try { raf = get raf ( location , - num ) ; return ( raf != null ) && can open ( raf ) ; } finally { if ( raf != null ) raf . close ( ) ; } }	Find out if the file can be opened, but dont actually open it.Experimental.
public static netcdf file open in memory ( string name , byte [ ] data , string iosp class name ) throws io , class not found exception , illegal access exception , instantiation exception { ucar . unidata . io . in memory random access file raf = new ucar . unidata . io . in memory random access file ( name , data ) ; class iosp class = netcdf file . class . get class loader ( ) . load class ( iosp class name ) ; io spi = ( io ) iosp class . new instance ( ) ; return new netcdf file ( spi , raf , name , null ) ; }	Open an in-memory netcdf file, with a specific iosp.
public static netcdf file open in memory ( string name , byte [ ] data ) throws io { ucar . unidata . io . in memory random access file raf = new ucar . unidata . io . in memory random access file ( name , data ) ; return open ( raf , name , null , null ) ; }	Open an in-memory netcdf file.
public static netcdf file open in memory ( string filename ) throws io { file file = new file ( filename ) ; byte array output stream bos = new byte array output stream ( ( int ) file . length ( ) ) ; try ( input stream in = new buffered input stream ( new file input stream ( filename ) ) ) { io . copy ( in , bos ) ; } return open in memory ( filename , bos . to byte array ( ) ) ; }	Read a local CDM file into memory.
public static netcdf file open in memory ( uri uri ) throws io { url url = uri . to url ( ) ; byte [ ] contents = io . read contents to byte array ( url . open stream ( ) ) ; return open in memory ( uri . to string ( ) , contents ) ; }	Read a remote CDM file into memory.
public attribute find global attribute ignore case ( string name ) { for ( attribute a : gattributes ) { if ( name . equals ignore case ( a . get short name ( ) ) ) return a ; } return null ; }	Look up global Attribute by name, ignore case.
public string to nc ml ( string url ) throws io { ml ncml writer = new ml ( ) ; ncml writer . set write variables predicate ( ml . write no variables predicate ) ; element netcdf element = ncml writer . make netcdf element ( this , url ) ; return ncml writer . write to string ( netcdf element ) ; }	CDL representation of Netcdf header info, non strict.
public void write cdl ( output stream out , boolean strict ) { print writer pw = new print writer ( new output stream writer ( out , cdm . utf8 charset ) ) ; to string start ( pw , strict ) ; to string end ( pw ) ; pw . flush ( ) ; }	Write CDL representation to OutputStream.
public void write cdl ( print writer pw , boolean strict ) { to string start ( pw , strict ) ; to string end ( pw ) ; pw . flush ( ) ; }	Write CDL representation to PrintWriter.
protected void write cdl ( formatter f , indent indent , boolean strict ) { to string start ( f , indent , strict ) ; f . format ( str , indent ) ; }	the actual work is here.
public attribute add attribute ( group parent , attribute att ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( parent == null ) parent = root group ; parent . add attribute ( att ) ; return att ; }	Add an attribute to a group.
public attribute add attribute ( group parent , string name , string value ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( value == null ) return null ; if ( parent == null ) parent = root group ; attribute att = new attribute ( name , value ) ; parent . add attribute ( att ) ; return att ; }	Add optional String attribute to a group.
public group add group ( group parent , group g ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( parent == null ) parent = root group ; parent . add group ( g ) ; return g ; }	Add a group to the parent group.
public dimension add dimension ( group parent , dimension d ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( parent == null ) parent = root group ; parent . add dimension ( d ) ; return d ; }	Add a shared Dimension to a Group.
public boolean remove dimension ( group g , string dim name ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( g == null ) g = root group ; return g . remove dimension ( dim name ) ; }	Remove a shared Dimension from a Group by name.
public variable add variable ( group g , variable v ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( g == null ) g = root group ; if ( v != null ) g . add variable ( v ) ; return v ; }	Add a Variable to the given group.
public variable add variable ( group g , string short name , data type dtype , string dims ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( g == null ) g = root group ; variable v = new variable ( this , g , null , short name ) ; v . set data type ( dtype ) ; v . set dimensions ( dims ) ; g . add variable ( v ) ; return v ; }	Create a new Variable, and add to the given group.
public variable add string variable ( group g , string short name , string dims , int strlen ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( g == null ) g = root group ; string dim name = short name + str ; add dimension ( g , new dimension ( dim name , strlen ) ) ; variable v = new variable ( this , g , null , short name ) ; v . set data type ( data type . char ) ; v . set dimensions ( dims + str + dim name ) ; g . add variable ( v ) ; return v ; }	Create a new Variable of type Datatype.CHAR, and add to the given group.
public boolean remove variable ( group g , string var name ) { if ( immutable ) throw new illegal state exception ( str ) ; if ( g == null ) g = root group ; return g . remove variable ( var name ) ; }	Remove a Variable from the given group by name.
public object send iosp message ( object message ) { if ( null == message ) return null ; if ( message == iosp message add record structure ) { variable v = root group . find variable ( str ) ; boolean gotit = ( v != null ) && ( v instanceof structure ) ; return gotit || make record structure ( ) ; } else if ( message == iosp message remove record structure ) { variable v = root group . find variable ( str ) ; boolean gotit = ( v != null ) && ( v instanceof structure ) ; if ( gotit ) { root group . remove ( v ) ; variables . remove ( v ) ; remove record structure ( ) ; } return ( gotit ) ; } if ( spi != null ) return spi . send iosp message ( message ) ; return null ; }	Generic way to send a "message" to the underlying IOSP.This message is sent after the file is open.
protected boolean make record structure ( ) { if ( immutable ) throw new illegal state exception ( str ) ; boolean didit = bool ; if ( ( spi != null ) && ( spi instanceof n3iosp ) && has unlimited dimension ( ) ) { didit = ( boolean ) spi . send iosp message ( iosp message add record structure ) ; } return didit ; }	If there is an unlimited dimension, make all variables that use it into a Structure.A Variable called "record" is added.You can then access these through the record structure.
public void finish ( ) { if ( immutable ) throw new illegal state exception ( str ) ; variables = new array list < > ( ) ; dimensions = new array list < > ( ) ; gattributes = new array list < > ( ) ; finish group ( root group ) ; }	Finish constructing the object model.This construsts the "global" variables, attributes and dimensions.It also looks for coordinate variables.
public array read section ( string variable section ) throws io , invalid range exception { parsed section spec cer = parsed section spec . parse variable section ( this , variable section ) ; if ( cer . child == null ) { return cer . v . read ( cer . section ) ; } if ( spi == null ) return iosp helper . read section ( cer ) ; else	Read a variable using the given section specification.The result is always an array of the type of the innermost variable.Its shape is the accumulation of all the shapes of its parent structures.
protected long read to byte channel ( ucar . nc2 . variable v , section section , writable byte channel wbc ) throws java . io . io , ucar . ma2 . invalid range exception {	Read data from a top level Variable and send data to a WritableByteChannel.
public java . util . list < array > read arrays ( java . util . list < variable > variables ) throws io { java . util . list < array > result = new java . util . array list < > ( ) ; for ( variable variable : variables ) result . add ( variable . read ( ) ) ; return result ; }	Do a bulk read on a list of Variables andreturn a corresponding list of Array that contains the resultsof a full read on each Variable.This is mostly here so DODSNetcdf can override it with one call to the server.
public array read ( string variable section , boolean flatten ) throws io , invalid range exception { if ( ! flatten ) throw new unsupported operation exception ( str ) ; return read section ( variable section ) ; }	Read a variable using the given section specification.
static protected string make full name ( cdm node , string reserved chars ) { group parent = node . get parent group ( ) ; if ( ( ( parent == null ) || parent . is root ( ) ) && ! node . is member of structure ( ) )	Given a CDMNode, create its full name withappropriate backslash escaping of the specified characters.
protected string make full name with string ( group parent , string name ) { name = make valid path name ( name ) ;	Create a synthetic full name from a group plus a string.
private boolean include ( m mfile ) { if ( include filters == null ) return bool ; for ( m filter : include filters ) { if ( filter . accept ( mfile ) ) return bool ; } return bool ; }	inclusion is an OR.
private boolean exclude ( m mfile ) { if ( exclude filters == null ) return bool ; for ( m filter : exclude filters ) { if ( filter . accept ( mfile ) ) return bool ; } return bool ; }	exclusion is an AND.
private boolean and filter ( m mfile ) { if ( and filters == null ) return bool ; for ( m filter : and filters ) { if ( ! filter . accept ( mfile ) ) return bool ; } return bool ; }	all AND filters must be satisfied.
public void append value ( string value , boolean check ) throws no such attribute exception , attribute bad value exception { check vector usage ( ) ; if ( check ) value = force value ( type , value ) ; ( ( vector ) attr ) . add element ( value ) ; }	Append a value to this attribute.
private static void dispatch check value ( int type , string value ) throws attribute bad value exception { switch ( type ) { case byte : if ( ! check byte ( value ) ) throw new attribute bad value exception ( str + value + str ) ; break ; case in : if ( ! check short ( value ) ) throw new attribute bad value exception ( str + value + str ) ; break ; case uin : if ( ! check u ( value ) ) throw new attribute bad value exception ( str + value + str ) ; break ; case in : if ( ! check int ( value ) ) throw new attribute bad value exception ( str + value + str ) ; break ; case uin : if ( ! check u ( value ) ) throw new attribute bad value exception ( str + value + str ) ; break ; case floa : if ( ! check float ( value ) ) throw new attribute bad value exception ( str + value + str ) ; break ; case floa : if ( ! check double ( value ) ) throw new attribute bad value exception ( str + value + str ) ; break ;	Check if the value is legal for a given type.
private static string force value ( int type , string value ) throws attribute bad value exception { try { dispatch check value ( type , value ) ; } catch ( attribute bad value exception abe ) { if ( type == byte ) {	Check if the value is legal for a given typeand try to convert to specified type.
private static final boolean check byte ( string s ) throws attribute bad value exception { try {	Check if string is a valid Byte.
private static final boolean check short ( string s ) { try { short val = short . parse short ( s ) ; if ( debug value checking ) { dap . log . debug ( str + s + str + val ) ; } return bool ; } catch ( number format exception e ) { return bool ; } }	Check if string is a valid Int16.
private static final boolean check int ( string s ) { try {	Check if string is a valid Int32.
private static final boolean check u ( string s ) {	Check if string is a valid UInt32.
private static final boolean check float ( string s ) { try {	Check if string is a valid Float32.
private static final boolean check double ( string s ) { try {	Check if string is a valid Float64.
private data type get attribute data type ( attribute attribute ) { data type data type = attribute . get data type ( ) ; if ( signedness == signedness . unsigned ) {	Get the data type of an attribute.
@ override public boolean is viewable ( dataset ds ) { access access = ds . get access ( service type . wms ) ; return access != null && ( thredds config . get boolean ( str , bool ) ) ; }	Returns true if this is a gridded dataset that is accessible via WMS.
@ suppress warnings ( { str } ) public static boolean valid boolean string ( string bool string ) { if ( bool string == null ) return bool ; matcher m = valid characters for boolean string pattern . matcher ( bool string ) ; if ( ! m . matches ( ) ) return bool ; return bool string . equals ignore case ( str ) || bool string . equals ignore case ( str ) ; }	Return true if the given String is "true" or "false", ignoring case.
public static boolean valid alphanumeric string ( string alph num string ) { if ( alph num string == null ) return bool ; matcher m = valid characters for alphanumeric string pattern . matcher ( alph num string ) ; return m . matches ( ) ; }	Return true if the given String is an alphanumeric string.
public static boolean valid alphanumeric string constrained set ( string alph num string , string [ ] constrained set , boolean ignore case ) { if ( alph num string == null || constrained set == null || constrained set . length == num ) return bool ; matcher m = valid characters for alphanumeric string pattern . matcher ( alph num string ) ; if ( ! m . matches ( ) ) return bool ; for ( string s : constrained set ) { if ( ignore case ? alph num string . equals ignore case ( s ) : alph num string . equals ( s ) ) return bool ; } return bool ; }	Return true if the given String is an alphanumeric string and one ofthe valid strings in the constrained set.
@ suppress warnings ( { str } ) public static boolean descend only file path ( string path ) { string [ ] path segments = path . split ( str ) ;	Return true if the given path does not ascend into parent directory.
public static string unicode code point2 percent hex string ( int code point , string charset name ) { if ( ! character . is defined ( code point ) ) throw new illegal argument exception ( string . format ( str , code point ) ) ; if ( character . get type ( code point ) == character . surrogate ) throw new illegal argument exception ( string . format ( str , code point ) ) ; charset charset = charset . available charsets ( ) . get ( charset name ) ; if ( charset == null ) throw new illegal argument exception ( string . format ( str , charset name ) ) ; char [ ] chars = character . to chars ( code point ) ; byte buffer byte buffer = null ; try { byte buffer = charset . new encoder ( ) . encode ( char buffer . wrap ( chars ) ) ; } catch ( character coding exception e ) { string message = string . format ( str , code point , charset name ) ; throw new illegal argument exception ( message , e ) ; } byte buffer . rewind ( ) ; string builder encoded string = new string builder ( ) ; for ( int i = num ; i < byte buffer . limit ( ) ; i ++ ) { string as hex = integer . to hex string ( byte buffer . get ( ) & num ) ; encoded string . append ( str ) . append ( as hex . length ( ) == num ? str : str ) . append ( as hex ) ; } return encoded string . to string ( ) ; }	Return the percentHexOctets string that represents the given Unicodecode point in the given character set or null if the given characterset cannot encode the given code point.
public final string get param ( string key ) { string value = param str . get ( key ) ; if ( value == null ) {	gets a param and value.
public static boolean compare ( grid def record local , grid def record other ) { java . util . set < string > keys = local . get keys ( ) ; java . util . set < string > okeys = other . get keys ( ) ; if ( keys . size ( ) != okeys . size ( ) ) return bool ; for ( string key : keys ) { if ( key . equals ( wind flag ) || key . equals ( resolution ) || key . equals ( vector component flag ) || key . equals ( gds key ) ) continue ; string val = local . get param ( key ) ; string oval = other . get param ( key ) ;	Compare GridDefRecords, the numerics will use nearlyEquals so values thatdiffer in 3 or 4th decimal places will return equal.
public void process ( input stream is ) throws io { int pos = - num ; buffer b = null ; while ( bool ) { b = ( pos < num ) ? read buffer ( is ) : read buffer ( is , b , pos ) ; pos = process ( b , is ) ; if ( b . done ) break ; } }	Step 1 - read and extract a Bufr Message.
private int process ( buffer b , input stream is ) throws io { int start = num ; while ( start < b . have ) { int match pos = matcher . index of ( b . buff , start , b . have - start ) ;	return where in the buffer we got to.
string remove quotes ( string s ) { if ( s . starts with ( str ) && s . ends with ( str ) ) return s . substring ( num , s . length ( ) - num ) ; else return s ; }	Remove double quotes from around a string.
void mark stacked variables ( stack s ) {	Given a stack of BaseType variables, mark these as part of thecurrent projection.
boolean write ncml ( string location ) { boolean err = bool ; close open files ( ) ; try { final string result ; ds = open dataset ( location , add coords , null ) ; if ( ds == null ) { editor . set text ( str + location + str ) ; } else { final ml ncml writer = new ml ( ) ; final element netcdf elem = ncml writer . make netcdf element ( ds , null ) ; result = ncml writer . write to string ( netcdf elem ) ; editor . set text ( result ) ; editor . set caret position ( num ) ; } } catch ( exception e ) { final string writer sw = new string writer ( num ) ; e . print stack trace ( ) ; e . print stack trace ( new print writer ( sw ) ) ; editor . set text ( sw . to string ( ) ) ; err = bool ; } return ! err ; }	write ncml from given dataset.
private static string get value from thredds config ( string key , string alternate key , string default value ) { string value = thredds config . get ( key , null ) ; if ( value == null && alternate key != null ) value = thredds config . get ( alternate key , null ) ; if ( value == null ) value = default value ; return value ; }	static so can be called from static enum classes.
public string write cdl ( boolean strict ) { formatter out = new formatter ( ) ; write cdl ( out , new indent ( num ) , strict ) ; return out . to string ( ) ; }	String representation.
@ override protected station helper create station helper ( ) throws io {	initialize the stationHelper.
protected boolean validate ( string builder out ) { this . is valid = bool ;	Validate this ResultService object.
public float get azimuth ( ) { if ( message type != num ) return - num ; if ( io . is sc ) return num * azimuth ang / num ; else if ( io . is cc ) return num * azimuth ang / num ; else if ( io . is c ) return azimuth ang * num ; return num * azimuth ang / num ; }	Get the azimuth in degrees.
public float get elevation ( ) { if ( message type != num ) return - num ; if ( io . is sc ) return num * elevation ang / num ; else if ( io . is cc ) return elevation ang * num ; else if ( io . is c ) return elevation ang * num ; return num * elevation ang / num ; }	Get the elevation angle in degrees.
public float [ ] get latitudes ( ) { if ( my asi == null ) return null ; float [ ] lats = new float [ n rays ] ; for ( int i = num ; i < n rays ; i ++ ) lats [ i ] = my asi [ i ] . get latitude ( ) ; return lats ; }	Get the array of per-ray latitudes.
public float [ ] get longitudes ( ) { if ( my asi == null ) return null ; float [ ] lons = new float [ n rays ] ; for ( int i = num ; i < n rays ; i ++ ) lons [ i ] = my asi [ i ] . get longitude ( ) ; return lons ; }	Get the array of per-ray longitudes.
public float [ ] get altitudes ( ) { if ( my asi == null ) return null ; float [ ] alts = new float [ n rays ] ; for ( int i = num ; i < n rays ; i ++ ) alts [ i ] = my asi [ i ] . get altitude ( ) ; return alts ; }	Get the array of per-ray altitudes.
public float [ ] get azimuths ( ) { if ( azimuths == null ) { azimuths = new float [ n rays ] ; for ( int r = num ; r < n rays ; r ++ ) { azimuths [ r ] = my ryi [ r ] . get azimuth ( ) ; } } return azimuths ; }	Get the array of azimuths for this sweep.
public float [ ] get elevations ( ) { if ( elevations == null ) { elevations = new float [ n rays ] ; for ( int r = num ; r < n rays ; r ++ ) { elevations [ r ] = my ryi [ r ] . get elevation ( ) ; } } return elevations ; }	Get the array of elevations for this sweep.
public structure select ( list < string > member names ) { structure result = ( structure ) copy ( ) ; list < variable > members = new array list < > ( ) ; for ( string name : member names ) { variable m = find variable ( name ) ; if ( null != m ) members . add ( m ) ; } result . set member variables ( members ) ; result . is subset = bool ; return result ; }	Create a subset of the Structure consisting only of the given member variables.
public structure select ( string var name ) { list < string > member names = new array list < > ( num ) ; member names . add ( var name ) ; return select ( member names ) ; }	Create a subset of the Structure consisting only of the one member variable.
public variable add member variable ( variable v ) { if ( is immutable ( ) ) throw new illegal state exception ( str ) ; members . add ( v ) ; member hash . put ( v . get short name ( ) , v ) ; v . set parent structure ( this ) ; return v ; }	Add a member variable.
public void set member variables ( list < variable > vars ) { if ( is immutable ( ) ) throw new illegal state exception ( str ) ; members = new array list < > ( ) ; member hash = new hash map < > ( num * vars . size ( ) ) ; for ( variable v : vars ) { add member variable ( v ) ; } }	Set the list of member variables.
@ override public void set parent group ( group group ) { if ( is immutable ( ) ) throw new illegal state exception ( str ) ; super . set parent group ( group ) ; if ( members != null ) { for ( variable v : members ) { v . set parent group ( group ) ; } } }	Set the parent group of this Structure, and all member variables.
public void calc element size ( ) { int total = num ; for ( variable v : members ) { total += v . get element size ( ) * v . get size ( ) ; } element size = total ; }	Force recalculation of size of one element of this structure - equals the sum of sizes of its members.This is used only by low level classes like IOSPs.
public structure data read structure ( int index ) throws io , ucar . ma2 . invalid range exception { section section = null ;	Use this when this is a one dimensional array of Structures, or you are doing the index calculation yourself fora multidimension array.
public array structure read structure ( int start , int count ) throws io , ucar . ma2 . invalid range exception { if ( get rank ( ) != num ) throw new java . lang . unsupported operation exception ( str ) ; int [ ] origin = new int [ ] { start } ; int [ ] shape = new int [ ] { count } ; if ( netcdf file . debug structure iterator ) system . out . println ( str + start + str + count ) ; return ( array structure ) read ( origin , shape ) ; }	For rank 1 array of Structures, read count Structures and return the data as an ArrayStructure.Use only when this is a one dimensional array of Structures.
static public string get data category ( int cat ) { if ( table a == null ) init ( ) ; string result = table a . get ( cat ) ; return result != null ? result : str + cat ; }	data category name, from table A.
public string get class name ( ) { string class name = get class ( ) . get name ( ) ; int index = class name . last index of ( str ) ; if ( index >= num ) { class name = class name . substring ( index + num ) ; } return class name ; }	Get the name of the type of the projection.
protected void add parameter ( string name , string value ) { atts . add ( new parameter ( name , value ) ) ; }	Add an attribute to this projection.
public static string get header ( ) { string builder header b = new string builder ( num ) ; header b . append ( str ) ; format . tab ( header b , num , bool ) ; header b . append ( str ) ; format . tab ( header b , num , bool ) ; header b . append ( str ) ; return header b . to string ( ) ; }	Get a header for display.
projection rect lat lon to proj b ( lat lon rect latlon rect ) { double minx , maxx , miny , maxy ; lat lon point impl llpt = latlon rect . get lower left point ( ) ; lat lon point impl urpt = latlon rect . get upper right point ( ) ; lat lon point impl lrpt = latlon rect . get lower right point ( ) ; lat lon point impl ulpt = latlon rect . get upper left point ( ) ; if ( is lat lon ( ) ) { minx = get min or max lon ( llpt . get longitude ( ) , ulpt . get longitude ( ) , bool ) ; miny = math . min ( llpt . get latitude ( ) , lrpt . get latitude ( ) ) ; maxx = get min or max lon ( urpt . get longitude ( ) , lrpt . get longitude ( ) , bool ) ; maxy = math . min ( ulpt . get latitude ( ) , urpt . get latitude ( ) ) ; } else { projection point ll = lat lon to proj ( llpt , new projection point impl ( ) ) ; projection point ur = lat lon to proj ( urpt , new projection point impl ( ) ) ; projection point lr = lat lon to proj ( lrpt , new projection point impl ( ) ) ; projection point ul = lat lon to proj ( ulpt , new projection point impl ( ) ) ; minx = math . min ( ll . get x ( ) , ul . get x ( ) ) ; miny = math . min ( ll . get y ( ) , lr . get y ( ) ) ; maxx = math . max ( ur . get x ( ) , lr . get x ( ) ) ; maxy = math . max ( ul . get y ( ) , ur . get y ( ) ) ; } return new projection rect ( minx , miny , maxx , maxy ) ; }	Alternate way to calculate latLonToProjBB, originally in GridCoordSys.Difficult to do this in a general way.
public static int get version ( string has conv name ) { int result = extract version ( has conv name ) ; if ( result >= num ) return result ; list < string > names = breakup convention names ( has conv name ) ; for ( string name : names ) { result = extract version ( name ) ; if ( result >= num ) return result ; } return - num ; }	Get which CF version this is, ie CF-1.x.
public static string get zis positive ( string zaxis name , string vert coord units ) { if ( vert coord units == null ) return cf . positive up ; if ( vert coord units . is empty ( ) ) return cf . positive up ; if ( simple unit . is compatible ( str , vert coord units ) ) return cf . positive down ; if ( simple unit . is compatible ( str , vert coord units ) ) return cf . positive up ;	Guess the value of ZisPositive based on z axis name and units.
private void set color scale params ( ) { if ( data min max type == color scale . min max type . hold && ! is new field ) return ; is new field = bool ; geo referenced array data arr = read h ( want level , want time , want ensemble , want run time ) ;	set colorscale limits, missing data.
public void render plan view ( java . awt . d g , affine transform d from n ) { if ( ( data state . grid == null ) || ( color scale == null ) || ( draw projection == null ) ) return ; if ( ! draw grid && ! draw contours ) return ;	Do the rendering to the given Graphics2D object.
boolean is child of ( h5 group that ) { if ( parent == null ) return bool ; if ( parent == that ) return bool ; return parent . is child of ( that ) ; }	is this a child of that ?.
public static message type get type ( string name ) { if ( name == null ) return null ; return hash . get ( name ) ; }	Find the MessageType that matches this name.
public static void install in all columns ( j table , int alignment ) {	Installs alignment decorators in all of the table's columns.
public coinbase builder with api key ( string api key , string api secret ) { this . api key = api key ; this . api secret = api secret ; return this ; }	Specify the HMAC api key and secret to be used for authenticated requestsHaving more than one client with the same api/secret globally is unsupportedand will result in sporadic auth errors as the nonce is calculated from the system time.
public static label of ( string value ) { return new label ( value , bool , bool , bool , bool , null , null ) ; }	Create a simple label.
public static label lines ( justification just , string ... lines ) { final string sep = just == left ? str : just == right ? str : str ; final string value = stream . of ( lines ) . map ( line -> line + sep ) . collect ( joining ( ) ) ; return new label ( value , bool , bool , bool , bool , null , null ) ; }	Create a simple multiline label.
public static label html ( string value ) { return new label ( value , bool , bool , bool , bool , null , null ) ; }	Create a HTML label.
public socket connect ( properties props , string socket path format ) throws io {	Creates a socket representing a connection to a Cloud SQL instance.
private static list < string > list ip types ( string cloud sql ip types ) { string [ ] raw types = cloud sql ip types . split ( str ) ; array list < string > result = new array list < > ( raw types . length ) ; for ( int i = num ; i < raw types . length ; i ++ ) { if ( raw types [ i ] . trim ( ) . equals ignore case ( str ) ) { result . add ( i , str ) ; } else { result . add ( i , raw types [ i ] . trim ( ) . to upper case ( ) ) ; } } return result ; }	Converts the string property of IP types to a list by splitting by commas, and upper-casing.
public < t extends closeable > t connect ( string host , int port number , properties props , int login timeout ) throws io { @ suppress warnings ( str ) t socket = ( t ) core socket factory . get instance ( ) . connect ( props , core socket factory . mysql socket file format ) ; return socket ; }	Implements the interface for com.mysql.cj.protocol.SocketFactory for mysql-connector-java priorto version 8.0.13.
protected synchronized void purge logger ( fluent logger logger ) { iterator < entry < fluent logger , string > > it = loggers . entry set ( ) . iterator ( ) ; while ( it . has next ( ) ) { if ( it . next ( ) . get key ( ) == logger ) { it . remove ( ) ; return ; } } }	Purges an invalid logger from the cache.
public class < ? > compile ( string class name , string source code ) throws exception { return add source ( class name , source code ) . compile all ( ) . get ( class name ) ; }	Compile single source.
public in memory java compiler add source ( string class name , string source code ) throws exception { source codes . put ( class name , new source code ( class name , source code ) ) ; return this ; }	Add source code to the compiler.
private void read graphic control ext ( ) {	Reads Graphics Control Extension values.
synchronized bitmap get next frame ( ) { if ( header . frame count <= num || frame pointer < num ) { if ( log . is loggable ( tag , log . debug ) ) { log . d ( tag , str + header . frame count + str + frame pointer ) ; } status = status format error ; } if ( status == status format error || status == status open error ) { if ( log . is loggable ( tag , log . debug ) ) { log . d ( tag , str + status ) ; } return null ; } status = status ok ; gif frame current frame = header . frames . get ( frame pointer ) ; gif frame previous frame = null ; int previous index = frame pointer - num ; if ( previous index >= num ) { previous frame = header . frames . get ( previous index ) ; }	Get the next frame in the animation sequence.
public selectable string list selectable persons property ( ) { if ( selectable persons == null ) { selectable persons = new selectable item list < > ( fx . observable array list ( repository . get persons ( ) ) , person -> person . get first name ( ) + str + person . get last name ( ) ) ; } return selectable persons ; }	Persons in string representation.
private void init list events ( ) { this . list change listener = new list change listener < source type > ( ) { @ override public void on changed ( change < ? extends source type > list event ) {	If the list changed we want the recreate the targetType representation.
public person get person by id ( final int id ) { for ( person person : persons ) { if ( id == person . get id ( ) ) { return person ; } } return null ; }	Gets a Person.s.
void add message ( validator validator , list < ? extends validation message > messages ) { if ( messages . is empty ( ) ) { return ; } final int validator hash = system . identity hash code ( validator ) ; if ( ! validator to messages map . contains key ( validator hash ) ) { validator to messages map . put ( validator hash , new array list < > ( ) ) ; } final list < integer > message hashes of this validator = validator to messages map . get ( validator hash ) ;	Add a list of validation messages for the specified validator.
public void set person id ( int person id ) { person = repository . get person by id ( person id ) ; string binding salutation binding = bindings . when ( person . gender property ( ) . is equal to ( gender . not specified ) ) . then ( str ) . otherwise ( bindings . when ( person . gender property ( ) . is equal to ( gender . male ) ) . then ( str ) . otherwise ( str ) ) ; welcome string . unbind ( ) ; welcome string . bind ( bindings . concat ( str , salutation binding , person . first name property ( ) , str , person . last name property ( ) ) ) ; }	Set Person id for the screen.
@ suppress warnings ( str ) public static < view type extends view < ? extends view model type > , view model type extends view model > view model type create view model ( view type view ) { final class < ? > view model type = type resolver . resolve raw argument ( view . class , view . get class ( ) ) ; if ( view model type == view model . class ) { return null ; } if ( type resolver . unknown . class == view model type ) { return null ; } return ( view model type ) dependency injector . get instance ( ) . get instance of ( view model type ) ; }	Creates a viewModel instance for a View type.
void load countries ( ) { input stream iso3166 resource = this . get class ( ) . get resource as stream ( iso 3166 location ) ; if ( iso3166 resource == null ) { throw new illegal state exception ( str + iso 3166 location ) ; } xml converter < country > country converter = new xml converter < > ( str , country . class ) ; try { data reader < country > data source = new input stream source < > ( iso3166 resource , country converter ) ; list data provider < country > list data provider = new list data provider < > ( data source ) ; list data provider . set result observable list ( countries ) ; worker < observable list < country > > worker = list data provider . retrieve ( ) ;	Load all countries from the XML file source with DataFX.
public static < view type extends java view < ? extends view model type > , view model type extends view model > java view step < view type , view model type > java view ( class < ? extends view type > view type ) { return new java view step < > ( view type ) ; }	This method is the entry point of the Fluent API to load a java basedview.
public static < view type extends fxml view < ? extends view model type > , view model type extends view model > fxml view step < view type , view model type > fxml view ( class < ? extends view type > view type ) { return new fxml view step < > ( view type ) ; }	This method is the entry point of the Fluent API to load a fxml basedView.
private < t , u > void clear map ( map < t , set < u > > map , bi consumer < t , u > consumer ) { for ( t observable : map . key set ( ) ) { for ( u listener : map . get ( observable ) ) { consumer . accept ( observable , listener ) ; } } map . clear ( ) ; }	This method is used to clear the given map.
private void create index events ( ) { selection model . selected index property ( ) . add listener ( ( bean , old val , new val ) -> { int index = new val . int value ( ) ; list type item = index == - num ? null : model list property ( ) . get ( index ) ; selected item . set ( item ) ; } ) ; selected item . add listener ( ( observable , old val , new val ) -> {	When the selected item changed we want to set the index property too.
public static < t > t access member ( final accessible object member , final callable < t > callable , string error message ) { if ( callable == null ) { return null ; } return access controller . do privileged ( ( privileged action < t > ) ( ) -> { boolean was accessible = member . is accessible ( ) ; try { member . set accessible ( bool ) ; return callable . call ( ) ; } catch ( exception exception ) { throw new illegal state exception ( error message , exception ) ; } finally { member . set accessible ( was accessible ) ; } } ) ; }	Helper method to execute a callback on a given member.
public < view type extends view < ? extends view model type > , view model type extends view model > view tuple < view type , view model type > load fxml view tuple ( class < ? extends view type > view type , resource bundle resource bundle , view type code behind , object root , view model type view model , context context , collection < scope > provided scopes , list < builder factory > builder factories ) { final string path to fxml = create fxml path ( view type ) ; return load fxml view tuple ( view type , path to fxml , resource bundle , code behind , root , view model , context , provided scopes , builder factories ) ; }	Load the viewTuple by it`s ViewType.
public style row query for row ( style mapping row style mapping row ) { style row style row = null ; attributes row attributes row = query for id row ( style mapping row . get related id ( ) ) ; if ( attributes row != null ) { style row = get row ( attributes row ) ; } return style row ; }	Query for the style row from a style mapping row.
public int get pixel value ( byte [ ] image bytes , int x , int y ) { png reader int reader = new png reader int ( new byte array input stream ( image bytes ) ) ; validate image type ( reader ) ; image line int row = ( image line int ) reader . read row ( y ) ; int pixel value = row . get scanline ( ) [ x ] ; reader . close ( ) ; return pixel value ; }	Get the pixel value as a 16 bit unsigned integer value.
public int [ ] get pixel values ( byte [ ] image bytes ) { png reader int reader = new png reader int ( new byte array input stream ( image bytes ) ) ; validate image type ( reader ) ; int [ ] pixels = new int [ reader . img info . cols * reader . img info . rows ] ; int row number = num ; while ( reader . has more rows ( ) ) { image line int row = reader . read row int ( ) ; int [ ] row values = row . get scanline ( ) ; system . arraycopy ( row values , num , pixels , row number * reader . img info . cols , row values . length ) ; row number ++ ; } reader . close ( ) ; return pixels ; }	Get the pixel values of the image as 16 bit unsigned integer values.
public static void validate image type ( png reader reader ) { if ( reader == null ) { throw new geo package exception ( str ) ; } if ( reader . img info . channels != num || reader . img info . bit depth != num ) { throw new geo package exception ( str + reader . img info . channels + str + reader . img info . bit depth ) ; } }	Validate that the image type is single channel 16 bit.
public coverage data png image create image ( int tile width , int tile height ) { image info image info = new image info ( tile width , tile height , num , bool , bool , bool ) ; coverage data png image image = new coverage data png image ( image info ) ; return image ; }	Create a new 16 bit single channel image.
public void set tile data ( bitmap bitmap , compress format format , int quality ) throws io { byte [ ] tile data = bitmap converter . to bytes ( bitmap , format , quality ) ; set tile data ( tile data ) ; }	Set the tile data from a bitmap.
public cursor raw query ( string sql , string [ ] args ) { return db . raw query ( sql , args ) ; }	Perform a raw database query.
public cursor result wrap query ( string sql , string [ ] selection args ) { return new cursor result ( raw query ( sql , selection args ) ) ; }	Perform the query and wrap as a result.
public t query ( t previous result ) { user query query = previous result . get query ( ) ; t result = query ( query ) ; return result ; }	Query using the query from a previous query result.
public t query ( user query query ) { cursor cursor = null ; string [ ] selection args = query . get selection args ( ) ; string sql = query . get sql ( ) ; if ( sql != null ) { cursor = database . raw query ( sql , selection args ) ; } else { string table = query . get table ( ) ; string [ ] columns = query . get columns ( ) ; string selection = query . get selection ( ) ; string group by = query . get group by ( ) ; string having = query . get having ( ) ; string order by = query . get order by ( ) ; string [ ] columns as = query . get columns as ( ) ; string limit = query . get limit ( ) ; if ( columns as != null && limit != null ) { cursor = database . query ( table , columns , columns as , selection , selection args , group by , having , order by , limit ) ; } else if ( columns as != null ) { cursor = database . query ( table , columns , columns as , selection , selection args , group by , having , order by ) ; } else if ( limit != null ) { cursor = database . query ( table , columns , selection , selection args , group by , having , order by , limit ) ; } else { cursor = database . query ( table , columns , selection , selection args , group by , having , order by ) ; } } t result = handle cursor ( cursor , query ) ; return result ; }	Query using the user query arguments.
private t handle cursor ( cursor cursor , user query query ) { t result = convert cursor ( cursor ) ; result . set query ( query ) ; if ( table != null ) { result . set table ( table ) ; } return result ; }	Convert the cursor to the result type cursor.
public feature row get feature row ( geometry index geometry index ) { long geom id = geometry index . get geom id ( ) ;	Get the feature row for the Geometry Index.
public void register table ( string table name , geo package cursor wrapper cursor wrapper ) {	Register a cursor wrapper for the provided table name. Database querieswill wrap the returned cursor.
private tile row retrieve tile row ( int x , int y , int zoom ) { return tile dao . query for tile ( x , y , zoom ) ; }	Retrieve the tile row.
public static coverage data < ? > get coverage data ( geo package geo package , tile dao tile dao , integer width , integer height , projection request projection ) { tile matrix set tile matrix set = tile dao . get tile matrix set ( ) ; gridded coverage dao gridded coverage dao = geo package . get gridded coverage dao ( ) ; gridded coverage gridded coverage = null ; try { if ( gridded coverage dao . is table exists ( ) ) { gridded coverage = gridded coverage dao . query ( tile matrix set ) ; } } catch ( sql e ) { throw new geo package exception ( str + tile matrix set . get table name ( ) , e ) ; } coverage data < ? > coverage data = null ; gridded coverage data type data type = gridded coverage . get data type ( ) ; switch ( data type ) { case integer : coverage data = new coverage data png ( geo package , tile dao , width , height , request projection ) ; break ; case float : coverage data = new coverage data tiff ( geo package , tile dao , width , height , request projection ) ; break ; default : throw new geo package exception ( str + data type ) ; } return coverage data ; }	Get a Tiled Gridded Coverage Data.
public static coverage data < ? > get coverage data ( geo package geo package , tile dao tile dao ) { return get coverage data ( geo package , tile dao , null , null , tile dao . get projection ( ) ) ; }	Get a Tiled Gridded Coverage Data, use the coverage data pixel tile sizeas the request size width and height.
public static coverage data < ? > get coverage data ( geo package geo package , tile dao tile dao , projection request projection ) { return get coverage data ( geo package , tile dao , null , null , request projection ) ; }	Get a Tiled Gridded Coverage Data, use the coverage data pixel tile sizeas the request size width and height, request as the specified projection.
private coverage data tile matrix results get results ( coverage data request request , bounding box request projected bounding box , int overlapping pixels ) {	Get the coverage data tile results by finding the tile matrix with values.
private coverage data tile matrix results get results zoom ( bounding box request projected bounding box , tile matrix tile matrix , int overlapping pixels ) { coverage data tile matrix results results = null ; if ( zoom in && zoom in before out ) { results = get results zoom in ( request projected bounding box , tile matrix , overlapping pixels ) ; } if ( results == null && zoom out ) { results = get results zoom out ( request projected bounding box , tile matrix , overlapping pixels ) ; } if ( results == null && zoom in && ! zoom in before out ) { results = get results zoom in ( request projected bounding box , tile matrix , overlapping pixels ) ; } return results ; }	Get the coverage data tile results by zooming in or out as needed from theprovided tile matrix to find values.
private coverage data tile matrix results get results zoom in ( bounding box request projected bounding box , tile matrix tile matrix , int overlapping pixels ) { coverage data tile matrix results results = null ; for ( long zoom level = tile matrix . get zoom level ( ) + num ; zoom level <= tile dao . get max zoom ( ) ; zoom level ++ ) { tile matrix zoom tile matrix = tile dao . get tile matrix ( zoom level ) ; if ( zoom tile matrix != null ) { results = get results ( request projected bounding box , zoom tile matrix , overlapping pixels ) ; if ( results != null ) { break ; } } } return results ; }	Get the coverage data tile results by zooming in from the provided tilematrix.
private coverage data tile matrix results get results zoom out ( bounding box request projected bounding box , tile matrix tile matrix , int overlapping pixels ) { coverage data tile matrix results results = null ; for ( long zoom level = tile matrix . get zoom level ( ) - num ; zoom level >= tile dao . get min zoom ( ) ; zoom level -- ) { tile matrix zoom tile matrix = tile dao . get tile matrix ( zoom level ) ; if ( zoom tile matrix != null ) { results = get results ( request projected bounding box , zoom tile matrix , overlapping pixels ) ; if ( results != null ) { break ; } } } return results ; }	Get the coverage data tile results by zooming out from the provided tilematrix.
private tile matrix get tile matrix ( coverage data request request ) { tile matrix tile matrix = null ;	Get the tile matrix for the zoom level as defined by the area of therequest.
public double get value ( tile row tile row , int x , int y ) { gridded tile gridded tile = get gridded tile ( tile row . get id ( ) ) ; double value = get value ( gridded tile , tile row , x , y ) ; return value ; }	Get the coverage data value of the pixel in the tile row image.
public void set icon ( icon row icon row , geometry type geometry type ) { if ( geometry type != null ) { if ( icon row != null ) { icons . put ( geometry type , icon row ) ; } else { icons . remove ( geometry type ) ; } } else { default icon = icon row ; } }	Set the icon for the geometry type.
public icon row get icon ( geometry type geometry type ) { icon row icon row = null ; if ( geometry type != null && ! icons . is empty ( ) ) { list < geometry type > geometry types = geometry utils . parent hierarchy ( geometry type ) ; geometry types . add ( num , geometry type ) ; for ( geometry type type : geometry types ) { icon row = icons . get ( type ) ; if ( icon row != null ) { break ; } } } if ( icon row == null ) { icon row = default icon ; } if ( icon row == null && geometry type == null && icons . size ( ) == num ) { icon row = icons . values ( ) . iterator ( ) . next ( ) ; } return icon row ; }	Get the icon for the geometry type.
public org . sqlite . database . sqlite . sq open or get bindings db ( ) { if ( bindings db == null ) { synchronized ( db ) { if ( bindings db == null ) { system . load library ( str ) ; bindings db = org . sqlite . database . sqlite . sq . open database ( db . get path ( ) , null , org . sqlite . database . sqlite . sq . open readwrite ) ; } } } return bindings db ; }	Open or get a connection using the SQLite Android Bindings connection.
public static bitmap to bitmap ( byte [ ] bytes , options options ) { bitmap bitmap = bitmap factory . decode byte array ( bytes , num , bytes . length , options ) ; return bitmap ; }	Decode the bytes to a bitmap, with options.
public static byte [ ] to bytes ( bitmap bitmap , compress format format , int quality ) throws io { byte [ ] bytes = null ; byte array output stream byte stream = new byte array output stream ( ) ; try { bitmap . compress ( format , quality , byte stream ) ; bytes = byte stream . to byte array ( ) ; } finally { byte stream . close ( ) ; } return bytes ; }	Compress the bitmap to a byte array.
public void create ( table metadata metadata ) { content values values = new content values ( ) ; values . put ( table metadata . column geopackage id , metadata . get geo package id ( ) ) ; values . put ( table metadata . column table name , metadata . get table name ( ) ) ; values . put ( table metadata . column last indexed , metadata . get last indexed ( ) ) ; long insert id = db . insert ( table metadata . table name , null , values ) ; if ( insert id == - num ) { throw new geo package exception ( str + metadata . get geo package id ( ) + str + metadata . get table name ( ) + str + metadata . get last indexed ( ) ) ; } }	Create a new table metadata.
public boolean delete ( long geo package id , string table name ) { geometry metadata data source geom ds = new geometry metadata data source ( db ) ; geom ds . delete ( geo package id , table name ) ; string where clause = table metadata . column geopackage id + str + table metadata . column table name + str ; string [ ] where args = new string [ ] { string . value of ( geo package id ) , table name } ; int delete count = db . delete ( table metadata . table name , where clause , where args ) ; return delete count > num ; }	Delete the database table name.
public table metadata get or create ( string geo package , string table name ) { geo package metadata data source ds = new geo package metadata data source ( db ) ; geo package metadata geo package metadata = ds . get or create ( geo package ) ; table metadata metadata = get ( geo package metadata . get id ( ) , table name ) ; if ( metadata == null ) { metadata = new table metadata ( ) ; metadata . set geo package id ( geo package metadata . get id ( ) ) ; metadata . set table name ( table name ) ; create ( metadata ) ; } return metadata ; }	Get a table metadata or create if it does not exist.
public long get geo package id ( string geo package ) { long id = - num ; geo package metadata data source ds = new geo package metadata data source ( db ) ; geo package metadata metadata = ds . get ( geo package ) ; if ( metadata != null ) { id = metadata . get id ( ) ; } return id ; }	Get a GeoPackage id from the name.
private table metadata create table metadata ( cursor cursor ) { table metadata metadata = new table metadata ( ) ; metadata . set geo package id ( cursor . get long ( num ) ) ; metadata . set table name ( cursor . get string ( num ) ) ; if ( ! cursor . is null ( num ) ) { metadata . set last indexed ( cursor . get long ( num ) ) ; } return metadata ; }	Create a table metadata from the current cursor location.
public extensions create ( ) { extensions extension = null ; if ( ! has ( ) ) { extension = r tree . create ( feature dao . get table ( ) ) ; if ( progress != null ) { progress . add progress ( count ( ) ) ; } } return extension ; }	Create the RTree extension for the feature table.
public feature row get feature row ( user custom cursor cursor ) { r row = get row ( cursor ) ; return get feature row ( row ) ; }	Get the feature row from the RTree Index Table row.
public user custom cursor raw query ( string sql , string [ ] selection args ) { validate r ( ) ; cursor cursor = database . raw query ( sql , selection args ) ; user custom cursor custom cursor = new user custom cursor ( get table ( ) , cursor ) ; return custom cursor ; }	Perform a raw query.
public user custom cursor query ( bounding box bounding box , projection projection ) { bounding box feature bounding box = project bounding box ( bounding box , projection ) ; return query ( feature bounding box ) ; }	Query for rows within the bounding box in the provided projection.
public user custom cursor query ( geometry envelope envelope ) { return query ( envelope . get min x ( ) , envelope . get min y ( ) , envelope . get max x ( ) , envelope . get max y ( ) ) ; }	Query for rows within the geometry envelope.
public long count ( geometry envelope envelope ) { return count ( envelope . get min x ( ) , envelope . get min y ( ) , envelope . get max x ( ) , envelope . get max y ( ) ) ; }	Count the rows within the geometry envelope.
public user custom cursor query ( double min x , double min y , double max x , double max y ) { string where = build where ( min x , min y , max x , max y ) ; string [ ] where args = build where args ( min x , min y , max x , max y ) ; return query ( where , where args ) ; }	Query for rows within the bounds.
private string build where ( double min x , double min y , double max x , double max y ) { string builder where = new string builder ( ) ; where . append ( build where ( r . column min x , max x , str ) ) ; where . append ( str ) ; where . append ( build where ( r . column min y , max y , str ) ) ; where . append ( str ) ; where . append ( build where ( r . column max x , min x , str ) ) ; where . append ( str ) ; where . append ( build where ( r . column max y , min y , str ) ) ; return where . to string ( ) ; }	Build a where clause from the bounds for overlapping ranges.
public manual feature query results query ( bounding box bounding box , projection projection ) { bounding box feature bounding box = feature dao . project bounding box ( bounding box , projection ) ; return query ( feature bounding box ) ; }	Manually query for rows within the bounding box in the providedprojection.
public long count ( bounding box bounding box , projection projection ) { bounding box feature bounding box = feature dao . project bounding box ( bounding box , projection ) ; return count ( feature bounding box ) ; }	Manually count the rows within the bounding box in the providedprojection.
public manual feature query results query ( geometry envelope envelope ) { return query ( envelope . get min x ( ) , envelope . get min y ( ) , envelope . get max x ( ) , envelope . get max y ( ) ) ; }	Manually query for rows within the geometry envelope.
public manual feature query results query ( double min x , double min y , double max x , double max y ) { list < long > feature ids = new array list < > ( ) ; long offset = num ; boolean has results = bool ; min x -= tolerance ; max x += tolerance ; min y -= tolerance ; max y += tolerance ; while ( has results ) { has results = bool ; feature cursor feature cursor = feature dao . query for chunk ( chunk limit , offset ) ; try { while ( feature cursor . move to next ( ) ) { has results = bool ; feature row feature row = feature cursor . get row ( ) ; geometry envelope envelope = feature row . get geometry envelope ( ) ; if ( envelope != null ) { double min x = math . max ( min x , envelope . get min x ( ) ) ; double max x = math . min ( max x , envelope . get max x ( ) ) ; double min y = math . max ( min y , envelope . get min y ( ) ) ; double max y = math . min ( max y , envelope . get max y ( ) ) ; if ( min x <= max x && min y <= max y ) { feature ids . add ( feature row . get id ( ) ) ; } } } } finally { feature cursor . close ( ) ; } offset += chunk limit ; } manual feature query results results = new manual feature query results ( feature dao , feature ids ) ; return results ; }	Manually query for rows within the bounds.
public long count ( double min x , double min y , double max x , double max y ) { return query ( min x , min y , max x , max y ) . count ( ) ; }	Manually count the rows within the bounds.
public void set data ( bitmap bitmap , bitmap . compress format format ) throws io { set data ( bitmap , format , num ) ; }	Set the data from a full quality bitmap.
public void set data ( bitmap bitmap , bitmap . compress format format , int quality ) throws io { set data ( bitmap converter . to bytes ( bitmap , format , quality ) ) ; }	Set the data from a bitmap.
public void set bitmap compression config ( config config ) { if ( options == null ) { options = new options ( ) ; } options . in preferred config = config ; }	Set the Bitmap Compress Config.
public int get tile count ( ) { if ( tile count == null ) { long count = num ; boolean degrees = projection . is unit ( units . degrees ) ; projection transform transform to web mercator = null ; if ( ! degrees ) { transform to web mercator = projection . get transformation ( projection constants . epsg web mercator ) ; } for ( int zoom = min zoom ; zoom <= max zoom ; zoom ++ ) { bounding box expanded bounding box = get bounding box ( zoom ) ;	Get the tile count of tiles to be generated.
private void adjust bounds ( bounding box bounding box , int zoom ) {	Adjust the tile matrix set and bounds.
private void adjust google bounds ( ) {	Adjust the tile matrix set and web mercator bounds for Google tile format.
private void adjust geo package bounds wg ( bounding box bounding box , int zoom ) {	Adjust the tile matrix set and WGS84 bounds for GeoPackage format.Determine the tile grid width and height.
private void adjust geo package bounds ( bounding box request web mercator bounding box , int zoom ) {	Adjust the tile matrix set and web mercator bounds for GeoPackage format.Determine the tile grid width and height.
public bounding box get bounding box ( long zoom level ) { bounding box bounding box = null ; tile matrix tile matrix = get tile matrix ( zoom level ) ; if ( tile matrix != null ) { tile grid tile grid = query for tile grid ( zoom level ) ; if ( tile grid != null ) { bounding box matrix set bounding box = get bounding box ( ) ; bounding box = tile bounding box utils . get bounding box ( matrix set bounding box , tile matrix , tile grid ) ; } } return bounding box ; }	Get the bounding box of tiles.
public tile grid get tile grid ( long zoom level ) { tile grid tile grid = null ; tile matrix tile matrix = get tile matrix ( zoom level ) ; if ( tile matrix != null ) { tile grid = new tile grid ( num , num , tile matrix . get matrix width ( ) - num , tile matrix . get matrix height ( ) - num ) ; } return tile grid ; }	Get the tile grid of the zoom level.
public tile row query for tile ( long column , long row , long zoom level ) { map < string , object > field values = new hash map < string , object > ( ) ; field values . put ( tile table . column tile column , column ) ; field values . put ( tile table . column tile row , row ) ; field values . put ( tile table . column zoom level , zoom level ) ; tile cursor cursor = query for field values ( field values ) ; tile row tile row = null ; try { if ( cursor . move to next ( ) ) { tile row = cursor . get row ( ) ; } } finally { cursor . close ( ) ; } return tile row ; }	Query for a Tile.
public tile cursor query for tile descending ( long zoom level ) { return query for eq ( tile table . column zoom level , zoom level , null , null , tile table . column tile row + str + tile table . column tile column + str ) ; }	Query for Tiles at a zoom level in descending row and column order.
public long get closest zoom level ( double length ) { long zoom level = tile dao utils . get closest zoom level ( widths , heights , tile matrices , length ) ; return zoom level ; }	Get the closest zoom level for the provided width and height in thedefault units.
public long get approximate zoom level ( double length ) { long zoom level = tile dao utils . get approximate zoom level ( widths , heights , tile matrices , length ) ; return zoom level ; }	Get the approximate zoom level for the provided length in the defaultunits.
public tile grid query for tile grid ( long zoom level ) { string where = build where ( tile table . column zoom level , zoom level ) ; string [ ] where args = build where args ( new object [ ] { zoom level } ) ; integer min x = min ( tile table . column tile column , where , where args ) ; integer max x = max ( tile table . column tile column , where , where args ) ; integer min y = min ( tile table . column tile row , where , where args ) ; integer max y = max ( tile table . column tile row , where , where args ) ; tile grid tile grid = null ; if ( min x != null && max x != null && min y != null && max y != null ) { tile grid = new tile grid ( min x , min y , max x , max y ) ; } return tile grid ; }	Query for the bounding.
public int delete tile ( long column , long row , long zoom level ) { string builder where = new string builder ( ) ; where . append ( build where ( tile table . column zoom level , zoom level ) ) ; where . append ( str ) ; where . append ( build where ( tile table . column tile column , column ) ) ; where . append ( str ) ; where . append ( build where ( tile table . column tile row , row ) ) ; string [ ] where args = build where args ( new object [ ] { zoom level , column , row } ) ; int deleted = delete ( where . to string ( ) , where args ) ; return deleted ; }	Delete a Tile.
public int count ( long zoom level ) { string where = build where ( tile table . column zoom level , zoom level ) ; string [ ] where args = build where args ( zoom level ) ; return count ( where , where args ) ; }	Count of Tiles at a zoom level.
public boolean is google tiles ( ) {	Determine if the tiles are in the Google tile coordinate format.
public float get pixel value ( byte [ ] image bytes , int x , int y ) { tiff tiff image = tiff reader . read tiff ( image bytes ) ; file directory directory = tiff image . get file directory ( ) ; validate image type ( directory ) ; rasters rasters = directory . read rasters ( ) ; float pixel value = rasters . get first pixel sample ( x , y ) . float value ( ) ; return pixel value ; }	Get the pixel value as a float from the image and the coordinate.
public float [ ] get pixel values ( byte [ ] image bytes ) { tiff tiff image = tiff reader . read tiff ( image bytes ) ; file directory directory = tiff image . get file directory ( ) ; validate image type ( directory ) ; rasters rasters = directory . read rasters ( ) ; float [ ] pixels = new float [ rasters . get width ( ) * rasters . get height ( ) ] ; for ( int y = num ; y < rasters . get height ( ) ; y ++ ) { for ( int x = num ; x < rasters . get width ( ) ; x ++ ) { int index = rasters . get sample index ( x , y ) ; pixels [ index ] = rasters . get pixel sample ( num , x , y ) . float value ( ) ; } } return pixels ; }	Get the pixel values of the image as floats.
public static void validate image type ( file directory directory ) { if ( directory == null ) { throw new geo package exception ( str ) ; } int samples per pixel = directory . get samples per pixel ( ) ; integer bits per sample = null ; if ( directory . get bits per sample ( ) != null && ! directory . get bits per sample ( ) . is empty ( ) ) { bits per sample = directory . get bits per sample ( ) . get ( num ) ; } integer sample format = null ; if ( directory . get sample format ( ) != null && ! directory . get sample format ( ) . is empty ( ) ) { sample format = directory . get sample format ( ) . get ( num ) ; } if ( samples per pixel != samples per pixel || bits per sample == null || bits per sample != bits per sample || sample format == null || sample format != tiff constants . sample format float ) { throw new geo package exception ( str + samples per pixel + str + bits per sample + str + sample format ) ; } }	Validate that the image type.
public coverage data tiff image create image ( int tile width , int tile height ) { rasters rasters = new rasters ( tile width , tile height , num , bits per sample , tiff constants . sample format float ) ; int rows per strip = rasters . calculate rows per strip ( tiff constants . planar configuration chunky ) ; file directory file directory = new file directory ( ) ; file directory . set image width ( tile width ) ; file directory . set image height ( tile height ) ; file directory . set bits per sample ( bits per sample ) ; file directory . set compression ( tiff constants . compression no ) ; file directory . set photometric interpretation ( tiff constants . photometric interpretation black is zero ) ; file directory . set samples per pixel ( samples per pixel ) ; file directory . set rows per strip ( rows per strip ) ; file directory . set planar configuration ( tiff constants . planar configuration chunky ) ; file directory . set sample format ( tiff constants . sample format float ) ; file directory . set write rasters ( rasters ) ; coverage data tiff image image = new coverage data tiff image ( file directory ) ; return image ; }	Create a new image.
public void set pixel value ( coverage data tiff image image , int x , int y , float pixel value ) { image . get rasters ( ) . set first pixel sample ( x , y , pixel value ) ; }	Set the pixel value into the image.
private geo package get or open ( string name , boolean writable , boolean cache ) { geo package geo package = get ( name ) ; if ( geo package == null ) { geo package = manager . open ( name , writable ) ; if ( cache ) { add ( geo package ) ; } } return geo package ; }	Get the cached GeoPackage or open and cache the GeoPackage.
private t get current row ( ) { t row = null ; if ( table != null ) { int [ ] column types = new int [ table . column count ( ) ] ; object [ ] values = new object [ table . column count ( ) ] ; boolean valid = bool ; for ( t column : table . get columns ( ) ) { int index = column . get index ( ) ; int column type = get type ( index ) ; if ( column . is primary key ( ) && column type == field type null ) { valid = bool ; } column types [ index ] = column type ; values [ index ] = get value ( column ) ; } row = get row ( column types , values ) ; if ( ! valid ) { invalid positions . add ( get position ( ) ) ; row . set valid ( bool ) ; } } return row ; }	Get the current row.
private boolean move to next invalid ( ) { boolean has next = bool ;	Move to the next position of invalid rows to requery.
public list < style mapping row > query by base feature id ( long id ) { list < style mapping row > rows = new array list < > ( ) ; user custom cursor cursor = query by base id ( id ) ; try { while ( cursor . move to next ( ) ) { rows . add ( get row ( cursor ) ) ; } } finally { cursor . close ( ) ; } return rows ; }	Query for style mappings by base id.
public int delete by base id ( long id , geometry type geometry type ) { string geometry type name = null ; if ( geometry type != null ) { geometry type name = geometry type . get name ( ) ; } string builder where = new string builder ( ) ; where . append ( build where ( style mapping table . column base id , id ) ) ; where . append ( str ) ; where . append ( build where ( style mapping table . column geometry type name , geometry type name ) ) ; list < object > where arguments = new array list < > ( ) ; where arguments . add ( id ) ; if ( geometry type name != null ) { where arguments . add ( geometry type name ) ; } string [ ] where args = build where args ( where arguments ) ; int deleted = delete ( where . to string ( ) , where args ) ; return deleted ; }	Delete by base is and geometry type.
public static rect get rectangle ( long width , long height , bounding box bounding box , bounding box bounding box section ) { f rect f = get float rectangle ( width , height , bounding box , bounding box section ) ; rect rect = new rect ( math . round ( rect f . left ) , math . round ( rect f . top ) , math . round ( rect f . right ) , math . round ( rect f . bottom ) ) ; return rect ; }	Get a rectangle using the tile width, height, bounding box, and thebounding box section within the outer box to build the rectangle from.
public static f get rounded float rectangle ( long width , long height , bounding box bounding box , bounding box bounding box section ) { rect rect = get rectangle ( width , height , bounding box , bounding box section ) ; f rect f = new f ( rect ) ; return rect f ; }	Get a rectangle with rounded floating point boundaries using the tile width,height, bounding box, and the bounding box section within the outer boxto build the rectangle from.
private list < string > delete missing databases ( list < string > databases ) { list < string > files exist = new array list < > ( ) ; for ( string database : databases ) { if ( exists ( database ) ) { files exist . add ( database ) ; } } return files exist ; }	Delete all databases that do not exist or the database file does not exist.
private void create and close geo package ( geo package database db ) { geo package connection connection = new geo package connection ( db ) ;	Create the required GeoPackage application id and tables in the newly created and open database connection.
private boolean is valid ( string database , boolean validate header , boolean validate integrity ) { boolean valid = bool ; if ( exists ( database ) ) { geo package cursor factory cursor factory = new geo package cursor factory ( ) ; string path = null ; sq sqlite ; geo package metadata metadata = get geo package metadata ( database ) ; if ( metadata != null && metadata . is external ( ) ) { path = metadata . get external path ( ) ; try { sqlite = sq . open database ( path , cursor factory , sq . open readwrite | sq . no localized collators ) ; } catch ( exception e ) { sqlite = sq . open database ( path , cursor factory , sq . open readonly | sq . no localized collators ) ; } } else { path = context . get database path ( database ) . get absolute path ( ) ; sqlite = context . open or create database ( database , context . mode private , cursor factory ) ; } try { valid = ( ! validate header || is database header valid ( sqlite ) ) && ( ! validate integrity || sqlite . is database integrity ok ( ) ) ; } catch ( exception e ) { log . e ( geo package manager impl . class . get simple name ( ) , str , e ) ; } finally { sqlite . close ( ) ; } } return valid ; }	Validate the GeoPackage database.
private void validate database and close on error ( sq sqlite database , boolean validate header , boolean validate integrity ) { validate database ( sqlite database , validate header , validate integrity , bool , bool ) ; }	Validate the database and close when validation fails.
private void validate database and close ( sq sqlite database , boolean validate header , boolean validate integrity ) { validate database ( sqlite database , validate header , validate integrity , bool , bool ) ; }	Validate the database and close it.
private void validate database ( sq sqlite database , boolean validate header , boolean validate integrity , boolean close , boolean close on error ) { try { if ( validate header ) { validate database header ( sqlite database ) ; } if ( validate integrity ) { validate database integrity ( sqlite database ) ; } } catch ( exception e ) { if ( close on error ) { sqlite database . close ( ) ; } throw e ; } if ( close ) { sqlite database . close ( ) ; } }	Validate the database header and integrity.
private void validate database header ( sq sqlite database ) { boolean valid header = is database header valid ( sqlite database ) ; if ( ! valid header ) { throw new geo package exception ( str + sqlite database . get path ( ) ) ; } }	Validate the header of the database file to verify it is a sqlite database.
private boolean is database header valid ( sq sqlite database ) { boolean valid header = bool ; file input stream fis = null ; try { fis = new file input stream ( sqlite database . get path ( ) ) ; byte [ ] header bytes = new byte [ num ] ; if ( fis . read ( header bytes ) == num ) { byte reader byte reader = new byte reader ( header bytes ) ; string header = byte reader . read string ( header bytes . length ) ; string header prefix = header . substring ( num , geo package constants . sqlite header prefix . length ( ) ) ; valid header = header prefix . equals ignore case ( geo package constants . sqlite header prefix ) ; } } catch ( exception e ) { log . e ( geo package manager impl . class . get simple name ( ) , str , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( io e ) {	Determine if the header of the database file is valid.
private void add internal databases ( collection < string > databases ) { string [ ] database array = context . database list ( ) ; for ( string database : database array ) { if ( ! is temporary ( database ) && ! database . equals ignore case ( geo package metadata db . database name ) ) { databases . add ( database ) ; } } }	Add all internal databases to the collection.
private void add external databases ( collection < string > databases ) {	Add all external databases to the collection.
private boolean import geo package ( string database , boolean override , input stream geo package stream , geo package progress progress ) { try { if ( exists ( database ) ) { if ( override ) { if ( ! delete ( database ) ) { throw new geo package exception ( str + database ) ; } } else { throw new geo package exception ( str + database ) ; } }	Import the GeoPackage stream.
private geo package metadata get geo package metadata ( string database ) { geo package metadata metadata = null ; geo package metadata db metadata db = new geo package metadata db ( context ) ; metadata db . open ( ) ; try { geo package metadata data source data source = new geo package metadata data source ( metadata db ) ; metadata = data source . get ( database ) ; } finally { metadata db . close ( ) ; } return metadata ; }	Get the GeoPackage metadata.
private geo package metadata get geo package metadata at external path ( string path ) { geo package metadata metadata = null ; geo package metadata db metadata db = new geo package metadata db ( context ) ; metadata db . open ( ) ; try { geo package metadata data source data source = new geo package metadata data source ( metadata db ) ; metadata = data source . get external at path ( path ) ; } finally { metadata db . close ( ) ; } return metadata ; }	Get the GeoPackage metadata of the database at the external path.
public long create ( geometry metadata metadata ) { content values values = new content values ( ) ; values . put ( geometry metadata . column geopackage id , metadata . get geo package id ( ) ) ; values . put ( geometry metadata . column table name , metadata . get table name ( ) ) ; values . put ( geometry metadata . column id , metadata . get id ( ) ) ; values . put ( geometry metadata . column min x , metadata . get min x ( ) ) ; values . put ( geometry metadata . column max x , metadata . get max x ( ) ) ; values . put ( geometry metadata . column min y , metadata . get min y ( ) ) ; values . put ( geometry metadata . column max y , metadata . get max y ( ) ) ; values . put ( geometry metadata . column min z , metadata . get min z ( ) ) ; values . put ( geometry metadata . column max z , metadata . get max z ( ) ) ; values . put ( geometry metadata . column min m , metadata . get min m ( ) ) ; values . put ( geometry metadata . column max m , metadata . get max m ( ) ) ; long insert id = db . insert ( geometry metadata . table name , null , values ) ; if ( insert id == - num ) { throw new geo package exception ( str + metadata . get geo package id ( ) + str + metadata . get table name ( ) + str + metadata . get id ( ) ) ; } metadata . set id ( insert id ) ; return insert id ; }	Create a new geometry metadata.
public geometry metadata populate ( long geo package id , string table name , long geom id , geometry envelope envelope ) { geometry metadata metadata = new geometry metadata ( ) ; metadata . set geo package id ( geo package id ) ; metadata . set table name ( table name ) ; metadata . set id ( geom id ) ; metadata . set min x ( envelope . get min x ( ) ) ; metadata . set max x ( envelope . get max x ( ) ) ; metadata . set min y ( envelope . get min y ( ) ) ; metadata . set max y ( envelope . get max y ( ) ) ; if ( envelope . has z ( ) ) { metadata . set min z ( envelope . get min z ( ) ) ; metadata . set max z ( envelope . get max z ( ) ) ; } if ( envelope . has m ( ) ) { metadata . set min m ( envelope . get min m ( ) ) ; metadata . set max m ( envelope . get max m ( ) ) ; } return metadata ; }	Populate a new geometry metadata from an envelope.
public int delete ( long geo package id ) { string where clause = geometry metadata . column geopackage id + str ; string [ ] where args = new string [ ] { string . value of ( geo package id ) } ; int delete count = db . delete ( geometry metadata . table name , where clause , where args ) ; return delete count ; }	Delete geometry metadata by database.
public boolean create or update ( geometry metadata metadata ) { boolean success = bool ; if ( exists ( metadata ) ) { success = update ( metadata ) ; } else { create ( metadata ) ; success = bool ; } return success ; }	Create the geometry metadata or update if it already exists.
public boolean update ( geometry metadata metadata ) { string where clause = geometry metadata . column geopackage id + str + geometry metadata . column table name + str + geometry metadata . column id + str ; string [ ] where args = new string [ ] { string . value of ( metadata . get geo package id ( ) ) , metadata . get table name ( ) , string . value of ( metadata . get id ( ) ) } ; content values values = new content values ( ) ; values . put ( geometry metadata . column min x , metadata . get min x ( ) ) ; values . put ( geometry metadata . column max x , metadata . get max x ( ) ) ; values . put ( geometry metadata . column min y , metadata . get min y ( ) ) ; values . put ( geometry metadata . column max y , metadata . get max y ( ) ) ; values . put ( geometry metadata . column min z , metadata . get min z ( ) ) ; values . put ( geometry metadata . column max z , metadata . get max z ( ) ) ; values . put ( geometry metadata . column min m , metadata . get min m ( ) ) ; values . put ( geometry metadata . column max m , metadata . get max m ( ) ) ; int update count = db . update ( geometry metadata . table name , values , where clause , where args ) ; return update count > num ; }	Update the geometry metadata.
public int count ( string geo package , string table name , bounding box bounding box ) { return count ( get geo package id ( geo package ) , table name , bounding box ) ; }	Query for all table geometry metadata count matching the bounding box in the same projection.
public static geometry metadata create geometry metadata ( cursor cursor ) { geometry metadata metadata = new geometry metadata ( ) ; metadata . set geo package id ( cursor . get long ( num ) ) ; metadata . set table name ( cursor . get string ( num ) ) ; metadata . set id ( cursor . get long ( num ) ) ; metadata . set min x ( cursor . get double ( num ) ) ; metadata . set max x ( cursor . get double ( num ) ) ; metadata . set min y ( cursor . get double ( num ) ) ; metadata . set max y ( cursor . get double ( num ) ) ; if ( ! cursor . is null ( num ) ) { metadata . set min z ( cursor . get double ( num ) ) ; } if ( ! cursor . is null ( num ) ) { metadata . set max z ( cursor . get double ( num ) ) ; } if ( ! cursor . is null ( num ) ) { metadata . set min m ( cursor . get double ( num ) ) ; } if ( ! cursor . is null ( num ) ) { metadata . set max m ( cursor . get double ( num ) ) ; } return metadata ; }	Create a geometry metadata from the current cursor location.
public int update ( content values values , string where clause , string [ ] where args ) { return db . update ( get table name ( ) , values , where clause , where args ) ; }	Update all rows matching the where clause with the provided values.
private bitmap draw tile ( int tile width , int tile height , string text ) {	Draw a tile with the provided text label in the middle.
public list < simple attributes row > get rows ( list < long > ids ) { list < simple attributes row > simple attributes rows = new array list < > ( ) ; for ( long id : ids ) { user custom row user custom row = query for id row ( id ) ; if ( user custom row != null ) { simple attributes rows . add ( get row ( user custom row ) ) ; } } return simple attributes rows ; }	Get the simple attributes rows that exist with the provided ids.
private cursor integrity check ( cursor cursor ) { if ( cursor . move to next ( ) ) { string value = cursor . get string ( num ) ; if ( value . equals ( str ) ) { cursor . close ( ) ; cursor = null ; } } return cursor ; }	Check the cursor returned from the integrity check to see if things are "ok".
public user mapping dao get mapping dao ( string table name ) { user mapping dao user mapping dao = new user mapping dao ( get user dao ( table name ) ) ; user mapping dao . register cursor wrapper ( get geo package ( ) ) ; return user mapping dao ; }	Get a User Mapping DAO from a table name.
public simple attributes dao get simple attributes dao ( string table name ) { simple attributes dao simple attributes dao = new simple attributes dao ( get user dao ( table name ) ) ; simple attributes dao . register cursor wrapper ( get geo package ( ) ) ; set contents ( simple attributes dao . get table ( ) ) ; return simple attributes dao ; }	Get a related simple attributes table DAO.
public list < long > get mappings for base ( extended relation extended relation , long base id ) { return get mappings for base ( extended relation . get mapping table name ( ) , base id ) ; }	Get the related id mappings for the base id.
public list < long > get mappings for related ( extended relation extended relation , long related id ) { return get mappings for related ( extended relation . get mapping table name ( ) , related id ) ; }	Get the base id mappings for the related id.
public boolean has mapping ( string table name , long base id , long related id ) { boolean has = bool ; user mapping dao user mapping dao = get mapping dao ( table name ) ; user custom cursor cursor = user mapping dao . query by ids ( base id , related id ) ; try { has = cursor . get count ( ) > num ; } finally { cursor . close ( ) ; } return has ; }	Determine if the base id and related id mapping exists.
protected int count ( user custom cursor cursor ) { int count = num ; try { count = cursor . get count ( ) ; } finally { cursor . close ( ) ; } return count ; }	Get the count of the cursor and close it.
public void register cursor wrapper ( geo package geo package ) { geo package . register cursor wrapper ( get table name ( ) , new geo package cursor wrapper ( ) { @ override public cursor wrap cursor ( cursor cursor ) { return new user custom cursor ( get table ( ) , cursor ) ; } } ) ; }	Register the cursor wrapper into the GeoPackage.
public static user custom dao read table ( geo package geo package , string table name ) { user custom connection user db = new user custom connection ( geo package . get connection ( ) ) ; final user custom table user custom table = user custom table reader . read table ( geo package . get connection ( ) , table name ) ; user custom dao dao = new user custom dao ( geo package . get name ( ) , geo package . get connection ( ) , user db , user custom table ) ; dao . register cursor wrapper ( geo package ) ; return dao ; }	Read the database table and create a DAO.
public geo package tile get tile ( bounding box request bounding box ) { geo package tile tile = null ;	Get the tile from the request bounding box in the request projection.
private bitmap draw tile ( tile matrix tile matrix , tile cursor tile results , bounding box request projected bounding box , int tile width , int tile height ) {	Draw the tile from the tile results.
private bitmap reproject tile ( bitmap tile , int requested tile width , int requested tile height , bounding box request bounding box , projection transform transform request to tiles , bounding box tiles bounding box ) { final double requested width units per pixel = ( request bounding box . get max longitude ( ) - request bounding box . get min longitude ( ) ) / requested tile width ; final double requested height units per pixel = ( request bounding box . get max latitude ( ) - request bounding box . get min latitude ( ) ) / requested tile height ; final double tiles distance width = tiles bounding box . get max longitude ( ) - tiles bounding box . get min longitude ( ) ; final double tiles distance height = tiles bounding box . get max latitude ( ) - tiles bounding box . get min latitude ( ) ; final int width = tile . get width ( ) ; final int height = tile . get height ( ) ;	Reproject the tile to the requested projection.
private tile cursor retrieve tile results ( bounding box projected request bounding box , tile matrix tile matrix ) { tile cursor tile results = null ; if ( tile matrix != null ) {	Get the tile row results of tiles needed to draw the requested bounding box tile.
public void calculate draw overlap ( ) { if ( point icon != null ) { height overlap = this . density * point icon . get height ( ) ; width overlap = this . density * point icon . get width ( ) ; } else { height overlap = this . density * point radius ; width overlap = this . density * point radius ; } float line paint half stroke = this . density * line stroke width / num ; height overlap = math . max ( height overlap , line paint half stroke ) ; width overlap = math . max ( width overlap , line paint half stroke ) ; float polygon paint half stroke = this . density * polygon stroke width / num ; height overlap = math . max ( height overlap , polygon paint half stroke ) ; width overlap = math . max ( width overlap , polygon paint half stroke ) ; if ( feature table styles != null && feature table styles . has ( ) ) {	Call after making changes to the point icon, point radius, or paint stroke widths.Determines the pixel overlap between tiles.
public void set density ( float density ) { this . density = density ; line paint . set stroke width ( this . density * line stroke width ) ; polygon paint . set stroke width ( this . density * polygon stroke width ) ; feature paint cache . clear ( ) ; }	Set the density.
public void set line paint ( paint line paint ) { if ( line paint == null ) { throw new assertion error ( str ) ; } this . line paint = line paint ; set line stroke width ( line paint . get stroke width ( ) ) ; }	Set the line paint.
public void set polygon paint ( paint polygon paint ) { if ( polygon paint == null ) { throw new assertion error ( str ) ; } this . polygon paint = polygon paint ; set polygon stroke width ( polygon paint . get stroke width ( ) ) ; }	Set the polygon paint.
public byte [ ] draw tile bytes ( int x , int y , int zoom ) { bitmap bitmap = draw tile ( x , y , zoom ) ; byte [ ] tile data = null ;	Draw the tile and get the bytes from the x, y, and zoom level.
public bitmap draw tile ( int x , int y , int zoom ) { bitmap bitmap ; if ( is index query ( ) ) { bitmap = draw tile query index ( x , y , zoom ) ; } else { bitmap = draw tile query all ( x , y , zoom ) ; } return bitmap ; }	Draw a tile bitmap from the x, y, and zoom level.
public bitmap draw tile query index ( int x , int y , int zoom ) {	Draw a tile bitmap from the x, y, and zoom level by querying features in the tile location.
public long query indexed features count ( int x , int y , int zoom ) {	Query for feature result count in the x, y, and zoom.
public long query indexed features count ( bounding box web mercator bounding box ) {	Query for feature result count in the bounding box.
public feature index results query indexed features ( int x , int y , int zoom ) {	Query for feature results in the x, y, and zoom level by querying features in the tile location.
public feature index results query indexed features ( bounding box web mercator bounding box ) {	Query for feature results in the bounding box.
public bitmap draw tile query all ( int x , int y , int zoom ) { bounding box bounding box = tile bounding box utils . get web mercator bounding box ( x , y , zoom ) ; bitmap bitmap = null ;	Draw a tile bitmap from the x, y, and zoom level by querying all features. This couldbe very slow if there are a lot of features.
protected list < point > simplify points ( double simplify tolerance , list < point > points ) { list < point > simplified points = null ; if ( simplify geometries ) {	When the simplify tolerance is set, simplify the points to a similarcurve with fewer points.
protected paint get point paint ( feature style feature style ) { paint paint = get feature style paint ( feature style , feature draw type . circle ) ; if ( paint == null ) { paint = point paint ; } return paint ; }	Get the point paint for the feature style, or return the default paint.
protected paint get line paint ( feature style feature style ) { paint paint = get feature style paint ( feature style , feature draw type . stroke ) ; if ( paint == null ) { paint = line paint ; } return paint ; }	Get the line paint for the feature style, or return the default paint.
protected paint get polygon paint ( feature style feature style ) { paint paint = get feature style paint ( feature style , feature draw type . stroke ) ; if ( paint == null ) { paint = polygon paint ; } return paint ; }	Get the polygon paint for the feature style, or return the default paint.
protected paint get polygon fill paint ( feature style feature style ) { paint paint = null ; boolean has style color = bool ; if ( feature style != null ) { style row style = feature style . get style ( ) ; if ( style != null ) { if ( style . has fill color ( ) ) { paint = get style paint ( style , feature draw type . fill ) ; } else { has style color = style . has color ( ) ; } } } if ( paint == null && ! has style color && fill polygon ) { paint = polygon fill paint ; } return paint ; }	Get the polygon fill paint for the feature style, or return the default paint.
private paint get feature style paint ( feature style feature style , feature draw type draw type ) { paint paint = null ; if ( feature style != null ) { style row style = feature style . get style ( ) ; if ( style != null && style . has color ( ) ) { paint = get style paint ( style , draw type ) ; } } return paint ; }	Get the feature style paint from cache, or create and cache it.
private paint get style paint ( style row style , feature draw type draw type ) { paint paint = feature paint cache . get paint ( style , draw type ) ; if ( paint == null ) { color color = null ; style paint style = null ; float stroke width = null ; switch ( draw type ) { case circle : color = style . get color or default ( ) ; paint style = style . fill ; break ; case stroke : color = style . get color or default ( ) ; paint style = style . stroke ; stroke width = this . density * ( float ) style . get width or default ( ) ; break ; case fill : color = style . get fill color ( ) ; paint style = style . fill ; stroke width = this . density * ( float ) style . get width or default ( ) ; break ; default : throw new geo package exception ( str + draw type ) ; } paint style paint = new paint ( ) ; style paint . set anti alias ( bool ) ; style paint . set style ( paint style ) ; style paint . set color ( color . get color with alpha ( ) ) ; if ( stroke width != null ) { style paint . set stroke width ( stroke width ) ; } synchronized ( feature paint cache ) { paint = feature paint cache . get paint ( style , draw type ) ; if ( paint == null ) { feature paint cache . set paint ( style , draw type , style paint ) ; paint = style paint ; } } } return paint ; }	Get the style paint from cache, or create and cache it.
public paint get paint ( style row style row , feature draw type type ) { return get paint ( style row . get id ( ) , type ) ; }	Get the paint for the style row and draw type.
public paint get paint ( long style id , feature draw type type ) { paint paint = null ; feature paint feature paint = get feature paint ( style id ) ; if ( feature paint != null ) { paint = feature paint . get paint ( type ) ; } return paint ; }	Get the paint for the style row id and draw type.
public bitmap put ( icon row icon row , bitmap bitmap ) { return put ( icon row . get id ( ) , bitmap ) ; }	Cache the icon bitmap for the icon row.
public static content values quote wrap ( content values values ) { content values quote values = null ; if ( values != null ) { map < string , object > quote map = new hash map < > ( ) ; for ( map . entry < string , object > value : values . value set ( ) ) { quote map . put ( sql . quote wrap ( value . get key ( ) ) , value . get value ( ) ) ; } parcel parcel = parcel . obtain ( ) ; parcel . write map ( quote map ) ; parcel . set data position ( num ) ; quote values = content values . creator . create from parcel ( parcel ) ; parcel . recycle ( ) ; } return quote values ; }	Wrap the content values names in quotes.
public bitmap create bitmap ( ) { bitmap bitmap = null ; canvas canvas = null ; for ( int layer = num ; layer < num ; layer ++ ) { bitmap layer bitmap = layered bitmap [ layer ] ; if ( layer bitmap != null ) { if ( bitmap == null ) { bitmap = layer bitmap ; canvas = layered canvas [ layer ] ; } else { canvas . draw bitmap ( layer bitmap , new matrix ( ) , null ) ; layer bitmap . recycle ( ) ; } layered bitmap [ layer ] = null ; layered canvas [ layer ] = null ; } } return bitmap ; }	Create the final bitmap from the layers, resets the layers.
public void recycle ( ) { for ( int layer = num ; layer < num ; layer ++ ) { bitmap bitmap = layered bitmap [ layer ] ; if ( bitmap != null ) { bitmap . recycle ( ) ; layered bitmap [ layer ] = null ; layered canvas [ layer ] = null ; } } }	Recycle the layered bitmaps.
private bitmap get bitmap ( int layer ) { bitmap bitmap = layered bitmap [ layer ] ; if ( bitmap == null ) { create bitmap and canvas ( layer ) ; bitmap = layered bitmap [ layer ] ; } return bitmap ; }	Get the bitmap for the layer index.
private canvas get canvas ( int layer ) { canvas canvas = layered canvas [ layer ] ; if ( canvas == null ) { create bitmap and canvas ( layer ) ; canvas = layered canvas [ layer ] ; } return canvas ; }	Get the canvas for the layer index.
private void create bitmap and canvas ( int layer ) { layered bitmap [ layer ] = bitmap . create bitmap ( tile width , tile height , bitmap . config . argb 8888 ) ; layered canvas [ layer ] = new canvas ( layered bitmap [ layer ] ) ; }	Create a new empty Bitmap and Canvas.
private style mapping dao get mapping dao ( string table prefix , string feature table ) { string table name = table prefix + feature table ; style mapping dao dao = null ; if ( geo package . is table ( table name ) ) { dao = new style mapping dao ( related tables . get user dao ( table name ) ) ; } return dao ; }	Get a Style Mapping DAO from a table name.
public style dao get style dao ( ) { style dao style dao = null ; if ( geo package . is table ( style table . table name ) ) { attributes dao attributes dao = get geo package ( ) . get attributes dao ( style table . table name ) ; style dao = new style dao ( attributes dao ) ; related tables . set contents ( style dao . get table ( ) ) ; } return style dao ; }	Get a style DAO.
public icon dao get icon dao ( ) { icon dao icon dao = null ; if ( geo package . is table ( icon table . table name ) ) { icon dao = new icon dao ( related tables . get user dao ( icon table . table name ) ) ; related tables . set contents ( icon dao . get table ( ) ) ; } return icon dao ; }	Get a icon DAO.
public feature styles get table feature styles ( string feature table ) { feature styles feature styles = null ; long id = contents id . get id ( feature table ) ; if ( id != null ) { styles styles = get table styles ( feature table , id ) ; icons icons = get table icons ( feature table , id ) ; if ( styles != null || icons != null ) { feature styles = new feature styles ( styles , icons ) ; } } return feature styles ; }	Get the feature table default feature styles.
public styles get table styles ( string feature table ) { styles styles = null ; long id = contents id . get id ( feature table ) ; if ( id != null ) { styles = get table styles ( feature table , id ) ; } return styles ; }	Get the feature table default styles.
public style row get table style ( string feature table , geometry type geometry type ) { style row style row = null ; styles table styles = get table styles ( feature table ) ; if ( table styles != null ) { style row = table styles . get style ( geometry type ) ; } return style row ; }	Get the style of the feature table and geometry type.
public icons get table icons ( string feature table ) { icons icons = null ; long id = contents id . get id ( feature table ) ; if ( id != null ) { icons = get table icons ( feature table , id ) ; } return icons ; }	Get the feature table default icons.
public icon row get table icon ( string feature table , geometry type geometry type ) { icon row icon row = null ; icons table icons = get table icons ( feature table ) ; if ( table icons != null ) { icon row = table icons . get icon ( geometry type ) ; } return icon row ; }	Get the icon of the feature table and geometry type.
public feature styles get feature styles ( feature row feature row ) { return get feature styles ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) ) ; }	Get the feature styles for the feature row.
public feature styles get feature styles ( string feature table , long feature id ) { styles styles = get styles ( feature table , feature id ) ; icons icons = get icons ( feature table , feature id ) ; feature styles feature styles = null ; if ( styles != null || icons != null ) { feature styles = new feature styles ( styles , icons ) ; } return feature styles ; }	Get the feature styles for the feature table and feature id.
public styles get styles ( feature row feature row ) { return get styles ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) ) ; }	Get the styles for the feature row.
public icons get icons ( feature row feature row ) { return get icons ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) ) ; }	Get the icons for the feature row.
private styles get styles ( long feature id , style mapping dao mapping dao ) { styles styles = null ; if ( mapping dao != null ) { style dao style dao = get style dao ( ) ; if ( style dao != null ) { list < style mapping row > style mapping rows = mapping dao . query by base feature id ( feature id ) ; if ( ! style mapping rows . is empty ( ) ) { for ( style mapping row style mapping row : style mapping rows ) { style row style row = style dao . query for row ( style mapping row ) ; if ( style row != null ) { if ( styles == null ) { styles = new styles ( ) ; } styles . set style ( style row , style mapping row . get geometry type ( ) ) ; } } } } } return styles ; }	Get the styles for feature id from the style mapping dao.
private icons get icons ( long feature id , style mapping dao mapping dao ) { icons icons = null ; if ( mapping dao != null ) { icon dao icon dao = get icon dao ( ) ; if ( icon dao != null ) { list < style mapping row > style mapping rows = mapping dao . query by base feature id ( feature id ) ; if ( ! style mapping rows . is empty ( ) ) { for ( style mapping row style mapping row : style mapping rows ) { icon row icon row = icon dao . query for row ( style mapping row ) ; if ( icon row != null ) { if ( icons == null ) { icons = new icons ( ) ; } icons . set icon ( icon row , style mapping row . get geometry type ( ) ) ; } } } } } return icons ; }	Get the icons for feature id from the icon mapping dao.
public void set table feature styles ( string feature table , feature styles feature styles ) { if ( feature styles != null ) { set table styles ( feature table , feature styles . get styles ( ) ) ; set table icons ( feature table , feature styles . get icons ( ) ) ; } else { delete table feature styles ( feature table ) ; } }	Set the feature table default feature styles.
public void set table styles ( string feature table , styles styles ) { delete table styles ( feature table ) ; if ( styles != null ) { if ( styles . get default ( ) != null ) { set table style default ( feature table , styles . get default ( ) ) ; } for ( entry < geometry type , style row > style : styles . get styles ( ) . entry set ( ) ) { set table style ( feature table , style . get key ( ) , style . get value ( ) ) ; } } }	Set the feature table default styles.
public void set table icons ( string feature table , icons icons ) { delete table icons ( feature table ) ; if ( icons != null ) { if ( icons . get default ( ) != null ) { set table icon default ( feature table , icons . get default ( ) ) ; } for ( entry < geometry type , icon row > icon : icons . get icons ( ) . entry set ( ) ) { set table icon ( feature table , icon . get key ( ) , icon . get value ( ) ) ; } } }	Set the feature table default icons.
public void set feature styles ( feature row feature row , feature styles feature styles ) { set feature styles ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) , feature styles ) ; }	Set the feature styles for the feature row.
public void set feature styles ( string feature table , long feature id , feature styles feature styles ) { if ( feature styles != null ) { set styles ( feature table , feature id , feature styles . get styles ( ) ) ; set icons ( feature table , feature id , feature styles . get icons ( ) ) ; } else { delete styles ( feature table , feature id ) ; delete icons ( feature table , feature id ) ; } }	Set the feature styles for the feature table and feature id.
public void set styles ( feature row feature row , styles styles ) { set styles ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) , styles ) ; }	Set the styles for the feature row.
public void set styles ( string feature table , long feature id , styles styles ) { delete styles ( feature table , feature id ) ; if ( styles != null ) { if ( styles . get default ( ) != null ) { set style default ( feature table , feature id , styles . get default ( ) ) ; } for ( entry < geometry type , style row > style : styles . get styles ( ) . entry set ( ) ) { set style ( feature table , feature id , style . get key ( ) , style . get value ( ) ) ; } } }	Set the styles for the feature table and feature id.
public void set style ( feature row feature row , style row style ) { set style ( feature row , feature row . get geometry type ( ) , style ) ; }	Set the style of the feature row.
public void set style default ( feature row feature row , style row style ) { set style ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) , null , style ) ; }	Set the default style of the feature row.
public void set style default ( string feature table , long feature id , style row style ) { set style ( feature table , feature id , null , style ) ; }	Set the default style of the feature.
public void set icons ( feature row feature row , icons icons ) { set icons ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) , icons ) ; }	Set the icons for the feature row.
public void set icons ( string feature table , long feature id , icons icons ) { delete icons ( feature table , feature id ) ; if ( icons != null ) { if ( icons . get default ( ) != null ) { set icon default ( feature table , feature id , icons . get default ( ) ) ; } for ( entry < geometry type , icon row > icon : icons . get icons ( ) . entry set ( ) ) { set icon ( feature table , feature id , icon . get key ( ) , icon . get value ( ) ) ; } } }	Set the icons for the feature table and feature id.
public void set icon ( feature row feature row , icon row icon ) { set icon ( feature row , feature row . get geometry type ( ) , icon ) ; }	Set the icon of the feature row.
public void set icon default ( feature row feature row , icon row icon ) { set icon ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) , null , icon ) ; }	Set the default icon of the feature row.
public void set icon default ( string feature table , long feature id , icon row icon ) { set icon ( feature table , feature id , null , icon ) ; }	Set the default icon of the feature.
private long get or insert style ( style row style ) { long style id ; if ( style . has id ( ) ) { style id = style . get id ( ) ; } else { style dao style dao = get style dao ( ) ; style id = style dao . create ( style ) ; } return style id ; }	Get the style id, either from the existing style or by inserting a newone.
private long get or insert icon ( icon row icon ) { long icon id ; if ( icon . has id ( ) ) { icon id = icon . get id ( ) ; } else { icon dao icon dao = get icon dao ( ) ; icon id = icon dao . create ( icon ) ; } return icon id ; }	Get the icon id, either from the existing icon or by inserting a new one.
private void insert style mapping ( style mapping dao mapping dao , long base id , long related id , geometry type geometry type ) { style mapping row row = mapping dao . new row ( ) ; row . set base id ( base id ) ; row . set related id ( related id ) ; row . set geometry type ( geometry type ) ; mapping dao . insert ( row ) ; }	Insert a style mapping row.
public void delete table style ( string feature table , geometry type geometry type ) { delete table mapping ( get table style mapping dao ( feature table ) , feature table , geometry type ) ; }	Delete the feature table style for the geometry type.
public void delete table icon ( string feature table , geometry type geometry type ) { delete table mapping ( get table icon mapping dao ( feature table ) , feature table , geometry type ) ; }	Delete the feature table icon for the geometry type.
private void delete table mappings ( style mapping dao mapping dao , string feature table ) { if ( mapping dao != null ) { long feature contents id = contents id . get id ( feature table ) ; if ( feature contents id != null ) { mapping dao . delete by base id ( feature contents id ) ; } } }	Delete the table style mappings.
private void delete table mapping ( style mapping dao mapping dao , string feature table , geometry type geometry type ) { if ( mapping dao != null ) { long feature contents id = contents id . get id ( feature table ) ; if ( feature contents id != null ) { mapping dao . delete by base id ( feature contents id , geometry type ) ; } } }	Delete the table style mapping with the geometry type value.
private void delete mapping ( style mapping dao mapping dao , long feature id , geometry type geometry type ) { if ( mapping dao != null ) { mapping dao . delete by base id ( feature id , geometry type ) ; } }	Delete the style mapping with the geometry type value.
public list < long > get all table style ids ( string feature table ) { list < long > style ids = null ; style mapping dao mapping dao = get table style mapping dao ( feature table ) ; if ( mapping dao != null ) { style ids = mapping dao . unique related ids ( ) ; } return style ids ; }	Get all the unique style row ids the table maps to.
public list < long > get all table icon ids ( string feature table ) { list < long > icon ids = null ; style mapping dao mapping dao = get table icon mapping dao ( feature table ) ; if ( mapping dao != null ) { icon ids = mapping dao . unique related ids ( ) ; } return icon ids ; }	Get all the unique icon row ids the table maps to.
public list < long > get all style ids ( string feature table ) { list < long > style ids = null ; style mapping dao mapping dao = get style mapping dao ( feature table ) ; if ( mapping dao != null ) { style ids = mapping dao . unique related ids ( ) ; } return style ids ; }	Get all the unique style row ids the features map to.
public list < long > get all icon ids ( string feature table ) { list < long > icon ids = null ; style mapping dao mapping dao = get icon mapping dao ( feature table ) ; if ( mapping dao != null ) { icon ids = mapping dao . unique related ids ( ) ; } return icon ids ; }	Get all the unique icon row ids the features map to.
public byte [ ] get image bytes ( ) { byte [ ] bytes = null ; if ( image bytes != null ) { bytes = image bytes ; } else if ( output stream != null ) { bytes = output stream . to byte array ( ) ; } return bytes ; }	Get the image bytes.
public void flush stream ( ) { if ( output stream != null ) { if ( image bytes == null ) { image bytes = output stream . to byte array ( ) ; } try { output stream . close ( ) ; } catch ( io e ) { log . w ( coverage data png image . class . get simple name ( ) , str , e ) ; } } }	Flush the output stream and set the image bytes, close the stream.
public int get pixel ( int x , int y ) { int pixel = - num ; if ( pixels == null ) { read pixels ( ) ; } if ( pixels != null ) { pixel = pixels [ y ] [ x ] ; } else { throw new geo package exception ( str ) ; } return pixel ; }	Get the pixel at the coordinate.
private void read pixels ( ) { if ( reader != null ) { pixels = new int [ reader . img info . rows ] [ reader . img info . cols ] ; int row count = num ; while ( reader . has more rows ( ) ) { image line int row = reader . read row int ( ) ; int [ ] column values = new int [ reader . img info . cols ] ; system . arraycopy ( row . get scanline ( ) , num , column values , num , column values . length ) ; pixels [ row count ++ ] = column values ; } reader . close ( ) ; } }	Read all the pixels from the image.
private boolean draw feature ( int zoom , bounding box bounding box , bounding box expanded bounding box , projection transform transform , feature tile canvas canvas , feature row row ) { boolean drawn = bool ; try { geo package geometry data geom data = row . get geometry ( ) ; if ( geom data != null ) { geometry geometry = geom data . get geometry ( ) ; if ( geometry != null ) { geometry envelope envelope = geom data . get or build envelope ( ) ; bounding box geometry bounding box = new bounding box ( envelope ) ; bounding box transformed bounding box = geometry bounding box . transform ( transform ) ; if ( expanded bounding box . intersects ( transformed bounding box , bool ) ) { double simplify tolerance = tile bounding box utils . tolerance distance ( zoom , tile width , tile height ) ; drawn = draw shape ( simplify tolerance , bounding box , transform , canvas , row , geometry ) ; } } } } catch ( exception e ) { log . e ( default feature tiles . class . get simple name ( ) , str + feature dao . get table name ( ) , e ) ; } return drawn ; }	Draw the feature on the canvas.
private boolean draw line path ( feature tile canvas canvas , path path , feature style feature style ) { canvas line canvas = canvas . get line canvas ( ) ; paint path paint = get line paint ( feature style ) ; line canvas . draw path ( path , path paint ) ; return bool ; }	Draw the line path on the canvas.
private boolean draw polygon path ( feature tile canvas canvas , path path , feature style feature style ) { canvas polygon canvas = canvas . get polygon canvas ( ) ; paint fill paint = get polygon fill paint ( feature style ) ; if ( fill paint != null ) { path . set fill type ( path . fill type . even odd ) ; polygon canvas . draw path ( path , fill paint ) ; } paint path paint = get polygon paint ( feature style ) ; polygon canvas . draw path ( path , path paint ) ; return bool ; }	Draw the path on the canvas.
private void add line string ( double simplify tolerance , bounding box bounding box , projection transform transform , path path , line string line string ) { list < point > points = line string . get points ( ) ; if ( points . size ( ) >= num ) {	Add the linestring to the path.
private void add polygon ( double simplify tolerance , bounding box bounding box , projection transform transform , path path , polygon polygon ) { list < line string > rings = polygon . get rings ( ) ; if ( ! rings . is empty ( ) ) {	Add the polygon on the canvas.
public feature cache get cache ( string table name ) { feature cache cache = table cache . get ( table name ) ; if ( cache == null ) { cache = new feature cache ( max cache size ) ; table cache . put ( table name , cache ) ; } return cache ; }	Get or create a feature row cache for the table name.
public feature row remove ( feature row feature row ) { return remove ( feature row . get table ( ) . get table name ( ) , feature row . get id ( ) ) ; }	Remove the cached feature row.
public void clear and resize ( int max cache size ) { set max cache size ( max cache size ) ; for ( feature cache cache : table cache . values ( ) ) { cache . clear and resize ( max cache size ) ; } }	Clear and resize all caches and update the max cache size.
public styles get cached table styles ( ) { styles styles = cached table feature styles . get styles ( ) ; if ( styles == null ) { synchronized ( cached table feature styles ) { styles = cached table feature styles . get styles ( ) ; if ( styles == null ) { styles = get table styles ( ) ; if ( styles == null ) { styles = new styles ( ) ; } cached table feature styles . set styles ( styles ) ; } } } if ( styles . is empty ( ) ) { styles = null ; } return styles ; }	Get the cached table styles, querying and caching if needed.
public icons get cached table icons ( ) { icons icons = cached table feature styles . get icons ( ) ; if ( icons == null ) { synchronized ( cached table feature styles ) { icons = cached table feature styles . get icons ( ) ; if ( icons == null ) { icons = get table icons ( ) ; if ( icons == null ) { icons = new icons ( ) ; } cached table feature styles . set icons ( icons ) ; } } } if ( icons . is empty ( ) ) { icons = null ; } return icons ; }	Get the cached table icons, querying and caching if needed.
public r get table dao ( feature dao feature dao ) { geo package connection connection = get geo package ( ) . get connection ( ) ; user custom connection user db = new user custom connection ( connection ) ; user custom table user custom table = get r ( feature dao . get table ( ) ) ; user custom dao user custom dao = new user custom dao ( geo package . get name ( ) , connection , user db , user custom table ) ; return new r ( this , user custom dao , feature dao ) ; }	Get a RTree Index Table DAO for the feature dao.
public void set width ( double width ) { if ( width != null && width < num ) { throw new geo package exception ( str + width ) ; } set value ( get width column index ( ) , width ) ; }	Set the width.
public void set height ( double height ) { if ( height != null && height < num ) { throw new geo package exception ( str + height ) ; } set value ( get height column index ( ) , height ) ; }	Set the height.
public double [ ] get derived dimensions ( ) { double width = get width ( ) ; double height = get height ( ) ; if ( width == null || height == null ) { bitmap factory . options options = get data bounds ( ) ; int data width = options . out width ; int data height = options . out height ; if ( width == null ) { width = ( double ) data width ; if ( height != null ) { width *= ( height / data height ) ; } } if ( height == null ) { height = ( double ) data height ; if ( width != null ) { height *= ( width / data width ) ; } } } return new double [ ] { width , height } ; }	Get the derived width and height from the values and icon data, scaled asneeded.
public static float tile density ( float density , int tile width , int tile height ) { return tile density ( density , math . min ( tile width , tile height ) ) ; }	Get the tile density based upon the display density scale and tile dimensions.
private void read blob value ( user row row , user column column ) { byte array output stream byte stream = new byte array output stream ( ) ; try { byte [ ] blob chunk = new byte [ ] { num } ; for ( int i = num ; blob chunk . length > num ; i += chunk size ) { if ( i > num ) { byte stream . write ( blob chunk ) ; } blob chunk = new byte [ ] { } ; string query = str + sql . quote wrap ( column . get name ( ) ) + str + i + str + chunk size + str + sql . quote wrap ( dao . get table name ( ) ) + str + sql . quote wrap ( row . get pk column ( ) . get name ( ) ) + str + row . get id ( ) ; cursor blob cursor = dao . get database connection ( ) . get db ( ) . raw query ( query , null ) ; try { if ( blob cursor . move to next ( ) ) { blob chunk = blob cursor . get blob ( num ) ; } } finally { blob cursor . close ( ) ; } } byte [ ] blob = byte stream . to byte array ( ) ; row . set value ( column . get index ( ) , blob ) ; } catch ( io e ) { log . e ( user invalid cursor . class . get simple name ( ) , str + dao . get table name ( ) + str + column . get name ( ) + str + get position ( ) , e ) ; } finally { io . close quietly ( byte stream ) ; } }	Read the blob column value in chunks.
public static user custom table read table ( geo package connection connection , string table name ) { user custom table reader table reader = new user custom table reader ( table name ) ; user custom table custom table = table reader . read table ( new user custom wrapper connection ( connection ) ) ; return custom table ; }	Read the table.
public color get color or default ( ) { color color = get color ( ) ; if ( color == null ) { color = new color ( ) ; } return color ; }	Get the color or default value.
private string validate color ( string color ) { string validated = color ; if ( color != null ) { if ( ! color . starts with ( str ) ) { validated = str + color ; } if ( ! color pattern . matcher ( validated ) . matches ( ) ) { throw new geo package exception ( str + color ) ; } validated = validated . to upper case ( ) ; } return validated ; }	Validate and adjust the color value.
private color create color ( string hex color , double opacity ) { color color = null ; if ( hex color != null || opacity != null ) { color = new color ( ) ; if ( hex color != null ) { color . set color ( hex color ) ; } if ( opacity != null ) { color . set opacity ( opacity . float value ( ) ) ; } } return color ; }	Create a color from the hex color and opacity.
public static geo package manager get manager ( context context ) { thread . current thread ( ) . set context class loader ( geo package manager . class . get class loader ( ) ) ; return new geo package manager impl ( context ) ; }	Get a GeoPackage Manager.
public void set progress ( geo package progress progress ) { feature table index . set progress ( progress ) ; feature indexer . set progress ( progress ) ; r tree index table dao . set progress ( progress ) ; }	Set the GeoPackage Progress.
public int index ( boolean force , list < feature index type > types ) { int count = num ; for ( feature index type type : types ) { int type count = index ( type , force ) ; count = math . max ( count , type count ) ; } return count ; }	Index the feature tables for the index types.
public boolean index ( feature row row , list < feature index type > types ) { boolean indexed = bool ; for ( feature index type type : types ) { if ( index ( type , row ) ) { indexed = bool ; } } return indexed ; }	Index the feature row for the index types.This method assumes that indexing has been completed andmaintained as the last indexed time is updated.
public boolean delete index ( collection < feature index type > types ) { boolean deleted = bool ; for ( feature index type type : types ) { if ( delete index ( type ) ) { deleted = bool ; } } return deleted ; }	Delete the feature index from the index types.
public boolean delete index ( feature row row , list < feature index type > types ) { boolean deleted = bool ; for ( feature index type type : types ) { if ( delete index ( type , row ) ) { deleted = bool ; } } return deleted ; }	Delete the feature index for the feature row from the index types.
public boolean delete index ( long geom id , list < feature index type > types ) { boolean deleted = bool ; for ( feature index type type : types ) { if ( delete index ( type , geom id ) ) { deleted = bool ; } } return deleted ; }	Delete the feature index for the geometry id from the index types.
public boolean delete index ( feature index type type , long geom id ) { if ( type == null ) { throw new geo package exception ( str ) ; } boolean deleted = bool ; switch ( type ) { case geopackage : deleted = feature table index . delete index ( geom id ) > num ; break ; case metadata : deleted = feature indexer . delete index ( geom id ) ; break ; case rtree :	Delete the feature index for the geometry id.
public boolean is indexed ( ) { boolean indexed = bool ; for ( feature index type type : index location query order ) { indexed = is indexed ( type ) ; if ( indexed ) { break ; } } return indexed ; }	Determine if the feature table is indexed.
public list < feature index type > get indexed types ( ) { list < feature index type > indexed = new array list < > ( ) ; for ( feature index type type : index location query order ) { if ( is indexed ( type ) ) { indexed . add ( type ) ; } } return indexed ; }	Get the indexed types that are currently indexed.
public feature index results query ( ) { feature index results results = null ; switch ( get indexed type ( ) ) { case geopackage : long count = feature table index . count ( ) ; closeable iterator < geometry index > geometry indices = feature table index . query ( ) ; results = new feature index geo package results ( feature table index , count , geometry indices ) ; break ; case metadata : cursor geometry metadata = feature indexer . query ( ) ; results = new feature index metadata results ( feature indexer , geometry metadata ) ; break ; case rtree : user custom cursor cursor = r tree index table dao . query for all ( ) ; results = new r ( r tree index table dao , cursor ) ; break ; default : feature cursor feature cursor = feature dao . query for all ( ) ; results = new feature index feature results ( feature cursor ) ; } return results ; }	Query for all feature index results.
public long count ( ) { long count = num ; switch ( get indexed type ( ) ) { case geopackage : count = feature table index . count ( ) ; break ; case metadata : count = feature indexer . count ( ) ; break ; case rtree : count = r tree index table dao . count ( ) ; break ; default : count = manual feature query . count with geometries ( ) ; } return count ; }	Query for all feature index count.
public bounding box get bounding box ( ) { bounding box bounds = null ; switch ( get indexed type ( ) ) { case geopackage : bounds = feature table index . get bounding box ( ) ; break ; case metadata : bounds = feature indexer . get bounding box ( ) ; break ; case rtree : bounds = r tree index table dao . get bounding box ( ) ; break ; default : bounds = manual feature query . get bounding box ( ) ; } return bounds ; }	Query for the feature index bounds.
public feature index results query ( bounding box bounding box , projection projection ) { feature index results results = null ; switch ( get indexed type ( ) ) { case geopackage : long count = feature table index . count ( bounding box , projection ) ; closeable iterator < geometry index > geometry indices = feature table index . query ( bounding box , projection ) ; results = new feature index geo package results ( feature table index , count , geometry indices ) ; break ; case metadata : cursor geometry metadata = feature indexer . query ( bounding box , projection ) ; results = new feature index metadata results ( feature indexer , geometry metadata ) ; break ; case rtree : user custom cursor cursor = r tree index table dao . query ( bounding box , projection ) ; results = new r ( r tree index table dao , cursor ) ; break ; default : results = manual feature query . query ( bounding box , projection ) ; } return results ; }	Query for feature index results within the bounding box inthe provided projection.
private feature index type get indexed type ( ) { feature index type index type = feature index type . none ;	Get the indexed type or throw an error if not indexed.
public static file get internal file ( context context , string file path ) { file internal file = null ; if ( file path != null ) { internal file = new file ( context . get files dir ( ) , file path ) ; } else { internal file = context . get files dir ( ) ; } return internal file ; }	Get the internal storage file for the file path.
public static string get internal file path ( context context , string file path ) { return get internal file ( context , file path ) . get absolute path ( ) ; }	Get the internal storage patch for the file path.
public geometry type get geometry type ( ) { geometry type geometry type = null ; string geometry type name = get geometry type name ( ) ; if ( geometry type name != null ) { geometry type = geometry type . from name ( geometry type name ) ; } return geometry type ; }	Get the geometry type.
public void set geometry type ( geometry type geometry type ) { string geometry type name = null ; if ( geometry type != null ) { geometry type name = geometry type . get name ( ) ; } set value ( get geometry type name column index ( ) , geometry type name ) ; }	Set the geometry type.
private boolean has bounding box ( string url ) { string replaced url = replace bounding box ( url , bounding box ) ; boolean has bounding box = ! replaced url . equals ( url ) ; return has bounding box ; }	Determine if the url has bounding box variables.
private string replace xyz ( string url , int z , long x , long y ) { url = url . replace all ( context . get string ( r . string . tile generator variable z ) , string . value of ( z ) ) ; url = url . replace all ( context . get string ( r . string . tile generator variable x ) , string . value of ( x ) ) ; url = url . replace all ( context . get string ( r . string . tile generator variable y ) , string . value of ( y ) ) ; return url ; }	Replace x, y, and z in the url.
private boolean has xyz ( string url ) { string replaced url = replace xyz ( url , num , num , num ) ; boolean has xyz = ! replaced url . equals ( url ) ; return has xyz ; }	Determine if the url has x, y, or z variables.
private string replace bounding box ( string url , int z , long x , long y ) { bounding box bounding box = tile bounding box utils . get projected bounding box ( projection , x , y , z ) ; url = replace bounding box ( url , bounding box ) ; return url ; }	Replace the bounding box coordinates in the url.
private string replace bounding box ( string url , bounding box bounding box ) { url = url . replace all ( context . get string ( r . string . tile generator variable min lat ) , string . value of ( bounding box . get min latitude ( ) ) ) ; url = url . replace all ( context . get string ( r . string . tile generator variable max lat ) , string . value of ( bounding box . get max latitude ( ) ) ) ; url = url . replace all ( context . get string ( r . string . tile generator variable min lon ) , string . value of ( bounding box . get min longitude ( ) ) ) ; url = url . replace all ( context . get string ( r . string . tile generator variable max lon ) , string . value of ( bounding box . get max longitude ( ) ) ) ; return url ; }	Replace the url parts with the bounding box.
public geo package geometry data get geometry ( ) { geo package geometry data geometry = null ; int column index = get table ( ) . get geometry column index ( ) ; int type = get type ( column index ) ; if ( type != field type null ) { byte [ ] geometry bytes = get blob ( column index ) ; if ( geometry bytes != null ) { geometry = new geo package geometry data ( geometry bytes ) ; } } return geometry ; }	Get the geometry.
private boolean index ( long geo package id , feature row row , boolean possible update ) { boolean indexed = bool ; geo package geometry data geom data = row . get geometry ( ) ; if ( geom data != null ) {	Index the feature row.
private void update last indexed ( geo package metadata db db , long geo package id ) { long indexed time = ( new date ( ) ) . get time ( ) ; table metadata data source ds = new table metadata data source ( db ) ; if ( ! ds . update last indexed ( geo package id , feature dao . get table name ( ) , indexed time ) ) { throw new geo package exception ( str + geo package id + str + feature dao . get table name ( ) + str + indexed time ) ; } }	Update the least indexed time.
public boolean delete index ( ) { table metadata data source table metadata data source = new table metadata data source ( db ) ; boolean deleted = table metadata data source . delete ( feature dao . get database ( ) , feature dao . get table name ( ) ) ; return deleted ; }	Delete the feature table index.
public boolean delete index ( long geom id ) { boolean deleted = geometry metadata data source . delete ( feature dao . get database ( ) , feature dao . get table name ( ) , geom id ) ; return deleted ; }	Delete the index for the geometry id.
public boolean is indexed ( ) { boolean indexed = bool ; date last indexed = get last indexed ( ) ; if ( last indexed != null ) { contents contents = feature dao . get geometry columns ( ) . get contents ( ) ; date last change = contents . get last change ( ) ; indexed = last indexed . equals ( last change ) || last indexed . after ( last change ) ; } return indexed ; }	Determine if the database table is indexed after database modifications.
public cursor query ( ) { cursor cursor = geometry metadata data source . query ( feature dao . get database ( ) , feature dao . get table name ( ) ) ; return cursor ; }	Query for all Geometry Metadata.
public cursor query ( bounding box bounding box ) { cursor cursor = geometry metadata data source . query ( feature dao . get database ( ) , feature dao . get table name ( ) , bounding box ) ; return cursor ; }	Query for Geometry Metadata within the bounding box, projectedcorrectly.
public int count ( bounding box bounding box ) { int count = geometry metadata data source . count ( feature dao . get database ( ) , feature dao . get table name ( ) , bounding box ) ; return count ; }	Query for Geometry Metadata count within the bounding box, projectedcorrectly.
public cursor query ( geometry envelope envelope ) { cursor cursor = geometry metadata data source . query ( feature dao . get database ( ) , feature dao . get table name ( ) , envelope ) ; return cursor ; }	Query for Geometry Metadata within the Geometry Envelope.
public int count ( geometry envelope envelope ) { int count = geometry metadata data source . count ( feature dao . get database ( ) , feature dao . get table name ( ) , envelope ) ; return count ; }	Query for Geometry Metadata count within the Geometry Envelope.
public cursor query ( bounding box bounding box , projection projection ) { bounding box feature bounding box = get feature bounding box ( bounding box , projection ) ; cursor cursor = query ( feature bounding box ) ; return cursor ; }	Query for Geometry Metadata within the bounding box inthe provided projection.
public long count ( bounding box bounding box , projection projection ) { bounding box feature bounding box = get feature bounding box ( bounding box , projection ) ; long count = count ( feature bounding box ) ; return count ; }	Query for Geometry Metadata count within the bounding box inthe provided projection.
private bounding box get feature bounding box ( bounding box bounding box , projection projection ) { projection transform projection transform = projection . get transformation ( feature dao . get projection ( ) ) ; bounding box feature bounding box = bounding box . transform ( projection transform ) ; return feature bounding box ; }	Get the bounding box in the feature projection from the bounding box inthe provided projection.
public geometry metadata get geometry metadata ( cursor cursor ) { geometry metadata geometry metadata = geometry metadata data source . create geometry metadata ( cursor ) ; return geometry metadata ; }	Get the Geometry Metadata for the current place in the cursor.
public feature row get feature row ( cursor cursor ) { geometry metadata geometry metadata = get geometry metadata ( cursor ) ; feature row feature row = get feature row ( geometry metadata ) ; return feature row ; }	Get the feature row for the current place in the cursor.
public feature row get feature row ( geometry metadata geometry metadata ) { long geom id = geometry metadata . get id ( ) ;	Get the feature row for the Geometry Metadata.
public list < tile dao > get tile daos for feature table ( string feature table ) { list < tile dao > tile daos = new array list < tile dao > ( ) ; list < string > tile tables = get tile tables for feature table ( feature table ) ; for ( string tile table : tile tables ) { if ( geo package . is tile table ( tile table ) ) { tile dao tile dao = geo package . get tile dao ( tile table ) ; tile daos . add ( tile dao ) ; } } return tile daos ; }	Query for the tile tables linked to a feature table and return tile DAOsto those tables.
public list < feature dao > get feature daos for tile table ( string tile table ) { list < feature dao > feature daos = new array list < feature dao > ( ) ; list < string > feature tables = get feature tables for tile table ( tile table ) ; for ( string feature table : feature tables ) { if ( geo package . is feature table ( feature table ) ) { feature dao feature dao = geo package . get feature dao ( feature table ) ; feature daos . add ( feature dao ) ; } } return feature daos ; }	Query for the feature tables linked to a tile table and return featureDAOs to those tables.
private static bounding box get bounding box ( geo package geo package , feature tiles feature tiles , bounding box bounding box , projection projection ) { string table name = feature tiles . get feature dao ( ) . get table name ( ) ; boolean manual query = bounding box == null ; bounding box feature bounding box = geo package . get bounding box ( projection , table name , manual query ) ; if ( feature bounding box != null ) { if ( bounding box == null ) { bounding box = feature bounding box ; } else { bounding box = bounding box . overlap ( feature bounding box ) ; } } if ( bounding box != null ) { bounding box = feature tiles . expand bounding box ( bounding box , projection ) ; } return bounding box ; }	Get the bounding box for the feature tile generator, from the providedand from the feature table.
public user custom cursor query by ids ( long base id , long related id ) { return query ( build where ids ( base id , related id ) , build where ids args ( base id , related id ) ) ; }	Query by both base id and related id.
public list < long > unique base ids ( ) { return query single column typed results ( str + sql . quote wrap ( user mapping table . column base id ) + str + sql . quote wrap ( get table name ( ) ) , null ) ; }	Get the unique base ids.
public list < long > unique related ids ( ) { return query single column typed results ( str + sql . quote wrap ( user mapping table . column related id ) + str + sql . quote wrap ( get table name ( ) ) , null ) ; }	Get the unique related ids.
public int delete by base id ( long base id ) { string builder where = new string builder ( ) ; where . append ( build where ( user mapping table . column base id , base id ) ) ; string [ ] where args = build where args ( new object [ ] { base id } ) ; int deleted = delete ( where . to string ( ) , where args ) ; return deleted ; }	Delete user mappings by base id.
public int delete by related id ( long related id ) { string builder where = new string builder ( ) ; where . append ( build where ( user mapping table . column related id , related id ) ) ; string [ ] where args = build where args ( new object [ ] { related id } ) ; int deleted = delete ( where . to string ( ) , where args ) ; return deleted ; }	Delete user mappings by related id.
public int delete by ids ( long base id , long related id ) { return delete ( build where ids ( base id , related id ) , build where ids args ( base id , related id ) ) ; }	Delete user mappings by both base id and related id.
private string build where ids ( long base id , long related id ) { string builder where = new string builder ( ) ; where . append ( build where ( user mapping table . column base id , base id ) ) ; where . append ( str ) ; where . append ( build where ( user mapping table . column related id , related id ) ) ; return where . to string ( ) ; }	Build the where ids clause.
public void create ( geo package metadata metadata ) { content values values = new content values ( ) ; values . put ( geo package metadata . column name , metadata . get name ( ) ) ; values . put ( geo package metadata . column external path , metadata . get external path ( ) ) ; long insert id = db . insert ( geo package metadata . table name , null , values ) ; if ( insert id == - num ) { throw new geo package exception ( str + metadata . get name ( ) + str + metadata . get external path ( ) ) ; } metadata . set id ( insert id ) ; }	Create a new GeoPackage metadata.
public boolean delete ( string database ) { geo package metadata metadata = get ( database ) ; if ( metadata != null ) { table metadata data source table ds = new table metadata data source ( db ) ; table ds . delete ( metadata . get id ( ) ) ; } string where clause = geo package metadata . column name + str ; string [ ] where args = new string [ ] { database } ; int delete count = db . delete ( geo package metadata . table name , where clause , where args ) ; return delete count > num ; }	Delete the database.
public boolean rename ( geo package metadata metadata , string new name ) { boolean renamed = rename ( metadata . get name ( ) , new name ) ; if ( renamed ) { metadata . set name ( new name ) ; } return renamed ; }	Rename the GeoPackage metadata to the new name.
public boolean rename ( string name , string new name ) { string where clause = geo package metadata . column name + str ; string [ ] where args = new string [ ] { name } ; content values values = new content values ( ) ; values . put ( geo package metadata . column name , new name ) ; int update count = db . update ( geo package metadata . table name , values , where clause , where args ) ; return update count > num ; }	Rename the GeoPackage name to the new name.
public list < geo package metadata > get all ( ) { list < geo package metadata > all metadata = new array list < geo package metadata > ( ) ; cursor cursor = db . query ( geo package metadata . table name , geo package metadata . columns , null , null , null , null , null ) ; try { while ( cursor . move to next ( ) ) { geo package metadata metadata = create geo package metadata ( cursor ) ; all metadata . add ( metadata ) ; } } finally { cursor . close ( ) ; } return all metadata ; }	Get all GeoPackage metadata.
public geo package metadata get ( string database ) { geo package metadata metadata = null ; string selection = geo package metadata . column name + str ; string [ ] selection args = new string [ ] { database } ; cursor cursor = db . query ( geo package metadata . table name , geo package metadata . columns , selection , selection args , null , null , null ) ; try { if ( cursor . move to next ( ) ) { metadata = create geo package metadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }	Get GeoPackage metadata by name.
public geo package metadata get ( long id ) { geo package metadata metadata = null ; string selection = geo package metadata . column id + str ; string [ ] selection args = new string [ ] { string . value of ( id ) } ; cursor cursor = db . query ( geo package metadata . table name , geo package metadata . columns , selection , selection args , null , null , null ) ; try { if ( cursor . move to next ( ) ) { metadata = create geo package metadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }	Get GeoPackage metadata by id.
public geo package metadata get or create ( string geo package ) { geo package metadata metadata = get ( geo package ) ; if ( metadata == null ) { metadata = new geo package metadata ( ) ; metadata . set name ( geo package ) ; create ( metadata ) ; } return metadata ; }	Get GeoPackage metadata or create it if it does not exist.
public boolean is external ( string database ) { geo package metadata metadata = get ( database ) ; return get ( database ) != null && metadata . get external path ( ) != null ; }	Determine if the GeoPackage is external.
public geo package metadata get external at path ( string path ) { geo package metadata metadata = null ; string selection = geo package metadata . column external path + str ; string [ ] selection args = new string [ ] { path } ; cursor cursor = db . query ( geo package metadata . table name , geo package metadata . columns , selection , selection args , null , null , null ) ; try { if ( cursor . move to next ( ) ) { metadata = create geo package metadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }	Get external GeoPackage metadata by external path.
public list < string > get metadata where name like ( string like , string sort column ) { return get metadata where name like ( like , sort column , bool ) ; }	Get metadata where the name is like.
public list < string > get metadata where name not like ( string not like , string sort column ) { return get metadata where name like ( not like , sort column , bool ) ; }	Get metadata where the name is not like.
private list < string > get metadata where name like ( string like , string sort column , boolean not like ) { list < string > names = new array list < > ( ) ; string builder where = new string builder ( geo package metadata . column name ) ; if ( not like ) { where . append ( str ) ; } where . append ( str ) ; string [ ] where args = new string [ ] { like } ; cursor cursor = db . query ( geo package metadata . table name , new string [ ] { geo package metadata . column name } , where . to string ( ) , where args , null , null , sort column ) ; try { while ( cursor . move to next ( ) ) { names . add ( cursor . get string ( num ) ) ; } } finally { cursor . close ( ) ; } return names ; }	Get metadata where the name is like or not like.
private geo package metadata create geo package metadata ( cursor cursor ) { geo package metadata metadata = new geo package metadata ( ) ; metadata . set id ( cursor . get long ( num ) ) ; metadata . set name ( cursor . get string ( num ) ) ; metadata . set external path ( cursor . get string ( num ) ) ; return metadata ; }	Create a GeoPackage metadata from the current cursor location.
public view on view created ( view view , context context , attribute set attrs ) { if ( view == null ) { return null ; } view = on view created internal ( view , context , attrs ) ; for ( on view created listener listener : other listeners ) { if ( listener != null ) { view = listener . on view created ( view , context , attrs ) ; } } return view ; }	Handle the created view.
private void add parallax view ( view view , int page index ) { if ( view instanceof view group ) {	attach attributes in tag.
@ override protected view on create view ( string name , attribute set attrs ) throws class not found exception {	The LayoutInflater onCreateView is the fourth port of call for LayoutInflation.BUT only for none CustomViews.Basically if this method doesn't inflate the View nothing probably will.
private view create custom view internal ( view parent , view view , string name , context context , attribute set attrs ) {	Nasty method to inflate custom layouts that haven't been handled else where.
protected void sub append ( cyclic buffer < i > cb , i event ) { if ( include caller data ) { event . get caller data ( ) ; } event . prepare for deferred processing ( ) ; cb . add ( event ) ; }	Perform SMTPAppender specific appending actions, mainly adding the event toa cyclic buffer.
private url find config file from system properties ( boolean update status ) { string logback config file = option helper . get system property ( config file property ) ; if ( logback config file != null ) { url result = null ; try { file file = new file ( logback config file ) ; if ( file . exists ( ) && file . is file ( ) ) { if ( update status ) { status on resource search ( logback config file , this . class loader , logback config file ) ; } result = file . to uri ( ) . to url ( ) ; } else { result = new url ( logback config file ) ; } return result ; } catch ( url e ) {	Finds a configuration file by system property.
private url get resource ( string filename , class loader my class loader , boolean update status ) { url url = my class loader . get resource ( filename ) ; if ( update status ) { string resource path = null ; if ( url != null ) { resource path = filename ; } status on resource search ( filename , my class loader , resource path ) ; } return url ; }	Uses the given classloader to search for a resource.
public void auto config ( ) throws joran exception { status listener config helper . install if asked ( logger context ) ; new android context util ( ) . setup properties ( logger context ) ; boolean verbose = bool ; boolean configured = bool ; joran configurator configurator = new joran configurator ( ) ; configurator . set context ( logger context ) ;	Configures logback with the first configuration found in the following search path.If no configuration found, nothing is done and logging is disabled.
private void status on resource search ( string resource name , class loader class loader , string path ) { status manager sm = logger context . get status manager ( ) ; if ( path == null ) { sm . add ( new info status ( str + resource name + str , logger context ) ) ; } else { sm . add ( new info status ( str + resource name + str + path + str , logger context ) ) ; } }	Adds a status message for the result of the resource search.
private string socket address to string ( socket address address ) { string addr = address . to string ( ) ; int i = addr . index of ( str ) ; if ( i >= num ) { addr = addr . substring ( i + num ) ; } return addr ; }	Converts a socket address to a reasonable display string.
static public executor service new executor service ( ) { return new thread pool executor ( core constants . core pool size , core constants . max pool size , num , time unit . milliseconds , new synchronous queue < runnable > ( ) , thread factory ) ; }	Creates an executor service suitable for use by logback components.
public static < e > void start converters ( converter < e > head ) { converter < e > c = head ; while ( c != null ) {	Start converters in the chain of converters.
@ override protected void sub append ( e event ) {	This method differentiates RollingFileAppender from its super class.
public void add substitution property ( string key , string value ) { if ( key == null || value == null ) { return ; }	Add a property to the properties of this execution context.
public string get property ( string key ) { string v = properties map . get ( key ) ; if ( v != null ) { return v ; } else { return context . get property ( key ) ; } }	If a key is found in propertiesMap then return it.
public converter < e > compile ( final node top , map < string , string > converter map ) { compiler < e > compiler = new compiler < e > ( top , converter map ) ; compiler . set context ( context ) ;	When the parsing step is done, the Node list can be transformed into aconverter chain.
node t ( ) throws scan exception { token t = get curent token ( ) ; expect not null ( t , str ) ; switch ( t . get type ( ) ) { case token . literal : advance token pointer ( ) ; return new node ( node . literal , t . get value ( ) ) ; case token . percent : advance token pointer ( ) ;	T = LITERAL | '%' C | '%' FORMAT_MODIFIER C.
public string to regex for fixed date ( date date ) { string builder buf = new string builder ( ) ; converter < object > p = head token converter ; while ( p != null ) { if ( p instanceof literal converter ) { buf . append ( p . convert ( null ) ) ; } else if ( p instanceof integer token converter ) { buf . append ( file finder . regex escape path ( str ) ) ; } else if ( p instanceof date token converter ) { date token converter < object > dtc = ( date token converter < object > ) p ; if ( dtc . is primary ( ) ) { buf . append ( p . convert ( date ) ) ; } else { buf . append ( file finder . regex escape path ( dtc . to regex ( ) ) ) ; } } p = p . get next ( ) ; } return buf . to string ( ) ; }	Given date, convert this instance to a regular expression.Used to compute sub-regex when the pattern has both %d and %i, and thedate is known.
public void begin ( interpretation context ec , string name , attributes attributes ) {	Instantiates an evaluator of the given class and sets its name.
@ suppress warnings ( str ) public void end ( interpretation context ec , string e ) { if ( in error ) { return ; } if ( evaluator instanceof life cycle ) { ( ( life cycle ) evaluator ) . start ( ) ; add info ( str + evaluator . get name ( ) + str ) ; } object o = ec . peek object ( ) ; if ( o != evaluator ) { add warn ( str ) ; } else { ec . pop object ( ) ; try { map < string , event evaluator < ? > > evaluator map = ( map < string , event evaluator < ? > > ) context . get object ( core constants . evaluator map ) ; if ( evaluator map == null ) { add error ( str ) ; } else { evaluator map . put ( evaluator . get name ( ) , evaluator ) ; } } catch ( exception ex ) { add error ( str + evaluator + str , ex ) ; } } }	Once the children elements are also parsed, now is the time to activate theevaluator options.
public void init ( logger context default logger context , object key ) throws class not found exception , no such method exception , instantiation exception , illegal access exception , invocation target exception { if ( this . key == null ) { this . key = key ; } else if ( this . key != key ) { throw new illegal access exception ( str ) ; } string context selector str = option helper . get system property ( classic constants . logback context selector ) ; if ( context selector str == null ) { context selector = new default context selector ( default logger context ) ; } else if ( context selector str . equals ( str ) ) { throw new runtime exception ( str ) ; } else { context selector = dynamical context selector ( default logger context , context selector str ) ; } }	FOR INTERNAL USE. This method is intended for use by StaticLoggerBinder.
static context selector dynamical context selector ( logger context default logger context , string context selector str ) throws class not found exception , security exception , no such method exception , illegal argument exception , instantiation exception , illegal access exception , invocation target exception { class < ? > context selector class = loader . load class ( context selector str ) ; constructor cons = context selector class . get constructor ( new class [ ] { logger context . class } ) ; return ( context selector ) cons . new instance ( default logger context ) ; }	Instantiate the context selector class designated by the user.
public void setup properties ( logger context context ) {	Sets properties for use in configs.
public string get mounted external storage directory path ( ) { string path = null ; string state = environment . get external storage state ( ) ; if ( state . equals ( environment . media mounted ) || state . equals ( environment . media mounted read only ) ) { path = abs path ( environment . get external storage directory ( ) ) ; } return path ; }	Gets the path to the external storage directory only ifmounted.
public string get database directory path ( ) { return this . context != null && this . context . get database path ( str ) != null ? this . context . get database path ( str ) . get parent ( ) : str ; }	Returns the absolute path to the directory on the Androidfilesystem where databases are stored for the current application.
private string get absolute file path ( string filename ) {	Gets the absolute path to the filename, starting from the app's"files" directory, if it is not already an absolute path.
public boolean evaluate ( i event ) throws null pointer exception , evaluation exception { return event . get level ( ) . level int >= level . error int ; }	Return true if event passed as parameter has level ERROR or higher, returnsfalse otherwise.
public string get discriminating value ( i event ) {	Return the value associated with an MDC entry designated by the Keyproperty.
private void update mask if necessary ( long now ) { final long time elapsed since last mask update check = now - last mask check ; last mask check = now ; if ( time elapsed since last mask update check < mask increase threshold && ( mask < max mask ) ) { mask = ( mask << num ) | num ; } else if ( time elapsed since last mask update check > mask decrease threshold ) { mask = mask > > > num ; } }	update the mask so as to execute change detection code about once every 100 to 8000 milliseconds.
public filter reply get filter chain decision ( e event ) { final filter < e > [ ] filter arrray = filter list . as typed array ( ) ; final int len = filter arrray . length ; for ( int i = num ; i < len ; i ++ ) { final filter reply r = filter arrray [ i ] . decide ( event ) ; if ( r == filter reply . deny || r == filter reply . accept ) { return r ; } }	Loop through the filters in the list.
private key manager [ ] create key managers ( context aware context ) throws no such provider exception , no such algorithm exception , unrecoverable key exception , key store exception { if ( get key store ( ) == null ) return null ; key store key store = get key store ( ) . create key store ( ) ; context . add info ( str + key store . get type ( ) + str + key store . get provider ( ) + str + get key store ( ) . get location ( ) ) ; key manager factory kmf = get key manager factory ( ) . create key manager factory ( ) ; context . add info ( str + kmf . get algorithm ( ) + str + kmf . get provider ( ) + str ) ; char [ ] passphrase = get key store ( ) . get password ( ) . to char array ( ) ; kmf . init ( key store , passphrase ) ; return kmf . get key managers ( ) ; }	Creates key managers using the receiver's key store configuration.
private trust manager [ ] create trust managers ( context aware context ) throws no such provider exception , no such algorithm exception , key store exception { if ( get trust store ( ) == null ) return null ; key store trust store = get trust store ( ) . create key store ( ) ; context . add info ( str + trust store . get type ( ) + str + trust store . get provider ( ) + str + get trust store ( ) . get location ( ) ) ; trust manager factory tmf = get trust manager factory ( ) . create trust manager factory ( ) ; context . add info ( str + tmf . get algorithm ( ) + str + tmf . get provider ( ) + str ) ; tmf . init ( trust store ) ; return tmf . get trust managers ( ) ; }	Creates trust managers using the receiver's trust store configuration.
private key store factory bean key store from system properties ( string property ) { if ( system . get property ( property ) == null ) return null ; key store factory bean key store = new key store factory bean ( ) ; key store . set location ( location from system property ( property ) ) ; key store . set provider ( system . get property ( property + str ) ) ; key store . set password ( system . get property ( property + str ) ) ; key store . set type ( system . get property ( property + str ) ) ; return key store ; }	Constructs a key store factory bean using JSSE system properties.
private string location from system property ( string name ) { string location = system . get property ( name ) ; if ( location != null && ! location . starts with ( str ) ) { location = str + location ; } return location ; }	Constructs a resource location from a JSSE system property.
public static url url for resource ( string location ) throws url , file not found exception { if ( location == null ) { throw new null pointer exception ( str ) ; } url url = null ; if ( ! location . matches ( scheme pattern ) ) { url = loader . get resource by self class loader ( location ) ; } else if ( location . starts with ( classpath scheme ) ) { string path = location . substring ( classpath scheme . length ( ) ) ; if ( path . starts with ( str ) ) { path = path . substring ( num ) ; } if ( path . length ( ) == num ) { throw new url ( str ) ; } url = loader . get resource by self class loader ( path ) ; } else { url = new url ( location ) ; } if ( url == null ) { throw new file not found exception ( location ) ; } return url ; }	Converts a string describing the location of a resource into a URL object.
public boolean chain handles throwable ( converter < i > head ) { converter < i > c = head ; while ( c != null ) { if ( c instanceof throwable handling converter ) { return bool ; } c = c . get next ( ) ; } return bool ; }	This method computes whether a chain of converters handles exceptions ornot.
protected void stop ( ) { add info ( str ) ; context hook context = get context ( ) ; if ( hook context instanceof context base ) { context base context = ( context base ) hook context ; context . stop ( ) ; } }	Default method for stopping the Logback context.
public static void print in case of errors or warnings ( context context , long threshold ) { if ( context == null ) { throw new illegal argument exception ( str ) ; } status manager sm = context . get status manager ( ) ; if ( sm == null ) { ps . println ( str + context . get name ( ) + str ) ; } else { status util status util = new status util ( context ) ; if ( status util . get highest level ( threshold ) >= error status . warn ) { print ( sm , threshold ) ; } } }	Print the contents of the context status, but only if they containwarnings or errors occurring later then the threshold.
public static void print if errors occured ( context context ) { if ( context == null ) { throw new illegal argument exception ( str ) ; } status manager sm = context . get status manager ( ) ; if ( sm == null ) { ps . println ( str + context . get name ( ) + str ) ; } else { status util status util = new status util ( context ) ; if ( status util . get highest level ( num ) == error status . error ) { print ( sm ) ; } } }	Print the contents of the context statuses, but only if they containerrors.
public static void print ( context context , long threshold ) { if ( context == null ) { throw new illegal argument exception ( str ) ; } status manager sm = context . get status manager ( ) ; if ( sm == null ) { ps . println ( str + context . get name ( ) + str ) ; } else { print ( sm , threshold ) ; } }	Print context's status data with a timestamp higher than the threshold.
private entry < c > get from either map ( string key ) { entry < c > entry = live map . get ( key ) ; if ( entry != null ) return entry ; else { return lingerers map . get ( key ) ; } }	Get an entry from the liveMap, if not found search the lingerersMap.
public void end of life ( string key ) { entry < c > entry = live map . remove ( key ) ; if ( entry == null ) return ; lingerers map . put ( key , entry ) ; }	Mark component identified by 'key' as having reached its end-of-life.
public static format info value of ( string str ) throws illegal argument exception { if ( str == null ) { throw new null pointer exception ( str ) ; } format info fi = new format info ( ) ; int index of dot = str . index of ( str ) ; string min part = null ; string max part = null ; if ( index of dot != - num ) { min part = str . substring ( num , index of dot ) ; if ( index of dot + num == str . length ( ) ) { throw new illegal argument exception ( str + str + str ) ; } else { max part = str . substring ( index of dot + num ) ; } } else { min part = str ; } if ( min part != null && min part . length ( ) > num ) { int min = integer . parse int ( min part ) ; if ( min >= num ) { fi . min = min ; } else { fi . min = - min ; fi . left pad = bool ; } } if ( max part != null && max part . length ( ) > num ) { int max = integer . parse int ( max part ) ; if ( max >= num ) { fi . max = max ; } else { fi . max = - max ; fi . left truncate = bool ; } } return fi ; }	This method is used to parse a string such as "5", ".7", "5.7" or "-5.7" intoa FormatInfo.
public void rename ( string src , string target ) throws rollover failure { if ( src . equals ( target ) ) { add warn ( str + src + str ) ; return ; } file src file = new file ( src ) ; if ( src file . exists ( ) ) { file target file = new file ( target ) ; create missing target dirs if necessary ( target file ) ; add info ( str + src file + str + target file + str ) ; boolean result = src file . rename to ( target file ) ; if ( ! result ) { add warn ( str + src file + str + target file + str ) ; boolean are on different volumes = are on different volumes ( src file , target file ) ; if ( boolean . true . equals ( are on different volumes ) ) { add warn ( str + src + str + target + str ) ; rename by copying ( src , target ) ; return ; } else { add warn ( str + rolling file appender . class . get simple name ( ) + str ) ; add warn ( str + renaming error url ) ; } } } else { throw new rollover failure ( str + src + str ) ; } }	A relatively robust file renaming method which in case of failure due tosrc and target being on different volumes, falls back ontorenaming by copying.
boolean are on different volumes ( file src file , file target file ) throws rollover failure { if ( ! env util . is jd ( ) ) { return bool ; }	Attempts tp determine whether both files are on different volumes.
public static string get env ( string key ) { try { return system . getenv ( key ) ; } catch ( security exception e ) { return null ; } }	Lookup a key from the environment.
public static string get android system property ( string key ) { try { return system properties proxy . get instance ( ) . get ( key , null ) ; } catch ( illegal argument exception e ) { return null ; } }	Gets an Android system property.
public void set mdc ( map < string , string > map ) { if ( mdc property map != null ) { throw new illegal state exception ( str ) ; } this . mdc property map = map ; }	Set the MDC map for this event.
private string output mdc ( map < string , string > mdc property map ) { string builder buf = new string builder ( ) ; boolean first = bool ; for ( map . entry < string , string > entry : mdc property map . entry set ( ) ) { if ( first ) { first = bool ; } else { buf . append ( str ) ; }	if no key is specified, return all the values present in the MDC, in the format "k1=v1, k2=v2, ...".
public static stack trace element [ ] extract ( throwable t , string fqn of invoking class , final int max depth , list < string > framework package list ) { if ( t == null ) { return null ; } stack trace element [ ] ste array = t . get stack trace ( ) ; stack trace element [ ] caller data array ; int found = line na ; for ( int i = num ; i < ste array . length ; i ++ ) { if ( is in framework space ( ste array [ i ] . get class name ( ) , fqn of invoking class , framework package list ) ) {	Extract caller data information as an array based on a Throwable passed asparameter.
private static boolean is in framework space list ( string current class , list < string > framework package list ) { if ( framework package list == null ) return bool ; for ( string s : framework package list ) { if ( current class . starts with ( s ) ) return bool ; } return bool ; }	Is currentClass present in the list of packages considered part of the logging framework?.
public void add ( status new status ) {	Add a new status object.
public boolean add ( status listener listener ) { synchronized ( status listener list lock ) { if ( listener instanceof on console status listener ) { boolean already present = check for presence ( status listener list , listener . get class ( ) ) ; if ( already present ) { return bool ; } } status listener list . add ( listener ) ; } return bool ; }	This implementation does not allow duplicate installations of OnConsoleStatusListener.
list < action > lookup implicit action ( element path element path , attributes attributes , interpretation context ec ) { int len = implicit actions . size ( ) ; for ( int i = num ; i < len ; i ++ ) { implicit action ia = ( implicit action ) implicit actions . get ( i ) ; if ( ia . is applicable ( element path , attributes , ec ) ) { list < action > action list = new array list < action > ( num ) ; action list . add ( ia ) ; return action list ; } } return null ; }	Check if any implicit actions are applicable.
list < action > get applicable action list ( element path element path , attributes attributes ) { list < action > applicable action list = rule store . match actions ( element path ) ;	Return the list of applicable patterns for this.
public void set class loader ( class loader cl ) throws class not found exception , security exception , no such method exception { if ( cl == null ) cl = this . get class ( ) . get class loader ( ) ; system properties = cl . load class ( str ) ; get string = system properties . get method ( str , new class [ ] { string . class , string . class } ) ; get boolean = system properties . get method ( str , new class [ ] { string . class , boolean . class } ) ; }	Sets the classloader to lookup the class for android.os.SystemProperties.
public string get ( string key , string def ) throws illegal argument exception { if ( system properties == null || get string == null ) return null ; string ret = null ; try { ret = ( string ) get string . invoke ( system properties , new object [ ] { key , def } ) ; } catch ( illegal argument exception e ) { throw e ; } catch ( exception e ) { }	Get the value for the given key in the Android system properties.
static public string decapitalize ( string name ) { if ( name == null || name . length ( ) == num ) { return name ; } else { string nm = name . substring ( num , num ) . to lower case ( locale . us ) ; if ( name . length ( ) > num ) { nm += name . substring ( num ) ; } return nm ; } }	Converts a name string's first letter to lowercase.
static public method descriptor [ ] get method descriptors ( class < ? > clazz ) { array list < method descriptor > methods = new array list < method descriptor > ( ) ; for ( method m : clazz . get methods ( ) ) { methods . add ( new method descriptor ( m . get name ( ) , m ) ) ; } return methods . to array ( new method descriptor [ num ] ) ; }	Gets a class's method descriptors.
static public property descriptor [ ] get property descriptors ( class < ? > clazz ) { final string setter prefix = str ; final string getter prefix = str ; final int len prefix = setter prefix . length ( ) ; map < string , property descriptor > map = new hash map < string , property descriptor > ( ) ; for ( method m : clazz . get methods ( ) ) { property descriptor pd = null ; string m name = m . get name ( ) ; boolean is get = m name . starts with ( getter prefix ) && ( m name . length ( ) > len prefix ) ; boolean is set = m name . starts with ( setter prefix ) && ( m name . length ( ) > len prefix ) ; if ( is get || is set ) { string prop name = decapitalize ( m name . substring ( len prefix ) ) ; pd = map . get ( prop name ) ; if ( pd == null ) { pd = new property descriptor ( prop name ) ; map . put ( prop name , pd ) ; } class < ? > [ ] parm types = m . get parameter types ( ) ; if ( is set ) { if ( parm types . length == num ) {	Gets a class's property descriptors.
public void start ( ) { int errors = num ; if ( this . encoder == null ) { add status ( new error status ( str + name + str , this ) ) ; errors ++ ; } if ( this . output stream == null ) { add status ( new error status ( str + name + str , this ) ) ; errors ++ ; }	Checks that requires parameters are set and if everything is in order,activates this appender.
static public void add on console listener instance ( context context , on console status listener on console status listener ) { on console status listener . set context ( context ) ; boolean effectively added = context . get status manager ( ) . add ( on console status listener ) ; if ( effectively added ) { on console status listener . start ( ) ; } }	This utility method adds a new OnConsoleStatusListener to the contextpassed as parameter.
public void end ( interpretation context ec , string name ) { if ( in error ) { return ; } object o = ec . peek object ( ) ; if ( o != definer ) { add warn ( str + property name + str ) ; } else { add info ( str + property name + str ) ; ec . pop object ( ) ;	Now property definer is initialized by all properties and we can putproperty value to context.
public string get discriminating value ( i event ) { string context name = event . get logger context vo ( ) . get name ( ) ; if ( context name == null ) { return default value ; } else { return context name ; } }	Return the name of the current context name as found in the logging event.
protected boolean is discardable ( i event ) { level level = event . get level ( ) ; return level . to int ( ) <= level . info int ; }	Events of level TRACE, DEBUG and INFO are deemed to be discardable.
@ override public void begin ( interpretation context ic , string name , attributes attributes ) throws action exception { hook = null ; in error = bool ; string class name = attributes . get value ( class attribute ) ; if ( option helper . is empty ( class name ) ) { class name = default shutdown hook . class . get name ( ) ; add info ( str + class name + str ) ; } try { add info ( str + class name + str ) ; hook = ( shutdown hook base ) option helper . instantiate by class name ( class name , shutdown hook base . class , context ) ; hook . set context ( context ) ; ic . push object ( hook ) ; } catch ( exception e ) { in error = bool ; add error ( str + class name + str , e ) ; throw new action exception ( e ) ; } }	Instantiates a shutdown hook of the given class and sets its name.The hook thus generated is placed in the {.
@ override public void end ( interpretation context ic , string name ) throws action exception { if ( in error ) { return ; } object o = ic . peek object ( ) ; if ( o != hook ) { add warn ( str ) ; } else { ic . pop object ( ) ; thread hook thread = new thread ( hook , str + context . get name ( ) + str ) ; add info ( str ) ; context . put object ( core constants . shutdown hook thread , hook thread ) ; runtime . get runtime ( ) . add shutdown hook ( hook thread ) ; } }	Once the children elements are also parsed, now is the time to activate theshutdown hook options.
private string [ ] enabled protocols ( string [ ] supported protocols , string [ ] default protocols ) { if ( enabled protocols == null ) {	Gets the set of enabled protocols based on the configuration.
private string [ ] enabled cipher suites ( string [ ] supported cipher suites , string [ ] default cipher suites ) { if ( enabled cipher suites == null ) {	Gets the set of enabled cipher suites based on the configuration.
private string [ ] included strings ( string [ ] defaults , string included , string excluded ) { list < string > values = new array list < string > ( defaults . length ) ; values . add all ( arrays . as list ( defaults ) ) ; if ( included != null ) { string collection util . retain matching ( values , string to array ( included ) ) ; } if ( excluded != null ) { string collection util . remove matching ( values , string to array ( excluded ) ) ; } return values . to array ( new string [ values . size ( ) ] ) ; }	Applies include and exclude patterns to an array of default string valuesto produce an array of strings included by the patterns.
static public scope string to scope ( string scope str ) { if ( scope . system . to string ( ) . equals ignore case ( scope str ) ) return scope . system ; if ( scope . context . to string ( ) . equals ignore case ( scope str ) ) return scope . context ; return scope . local ; }	Convert a string into a scope.
static public void set properties ( interpretation context ic , properties props , scope scope ) { switch ( scope ) { case local : ic . add substitution properties ( props ) ; break ; case context : context util cu = new context util ( ic . get context ( ) ) ; cu . add properties ( props ) ; break ; case system : option helper . set system properties ( ic , props ) ; } }	Add all the properties found in the argument named 'props' to anInterpretationContext.
public void add appender ( appender < e > new appender ) { if ( new appender == null ) { throw new illegal argument exception ( str ) ; } appender list . add if absent ( new appender ) ; }	Attach an appender. If the appender is already in the list in won't beadded again.
public boolean detach appender ( appender < e > appender ) { if ( appender == null ) { return bool ; } boolean result ; result = appender list . remove ( appender ) ; return result ; }	Remove the appender passed as parameter form the list of attachedappenders.
public boolean detach appender ( string name ) { if ( name == null ) { return bool ; } boolean removed = bool ; for ( appender < e > a : appender list ) { if ( name . equals ( ( a ) . get name ( ) ) ) { removed = appender list . remove ( a ) ; break ; } } return removed ; }	Remove the appender with the name passed as parameter form the list ofappenders.
private synchronized void handle parent level change ( int new parent level int ) {	This method is invoked by parent logger to let this logger know that theprent's levelInt changed.
public void call appenders ( i event ) { int writes = num ; for ( logger l = this ; l != null ; l = l . parent ) { writes += l . append loop on appenders ( event ) ; if ( ! l . additive ) { break ; } }	Invoke all the appenders of this logger.
public boolean detach appender ( appender < i > appender ) { if ( aai == null ) { return bool ; } return aai . detach appender ( appender ) ; }	Remove the appender passed as parameter form the list of appenders.
logger create child by last name part ( final string last part ) { int i index = logger name util . get first separator index of ( last part ) ; if ( i index != - num ) { throw new illegal argument exception ( str + last part + str + core constants . dot + str ) ; } if ( children list == null ) { children list = new copy on write array list < logger > ( ) ; } logger child logger ; if ( this . is root logger ( ) ) { child logger = new logger ( last part , this , this . logger context ) ; } else { child logger = new logger ( name + core constants . dot + last part , this , this . logger context ) ; } children list . add ( child logger ) ; child logger . effective level int = this . effective level int ; return child logger ; }	Create a child of this logger by suffix, that is, the part of the nameextending this logger.
private filter reply call turbo filters ( marker marker , level level ) { return logger context . get turbo filter chain decision 0 3 or more ( marker , this , level , null , null , null ) ; }	Method that calls the attached TurboFilter objects based on the logger andthe level.It is used by isYYYEnabled() methods.It returns the typical FilterReply values: ACCEPT, NEUTRAL or DENY.
public void log ( org . slf4j . event . logging event slf4j event ) { level level = level . from location aware logger integer ( slf4j event . get level ( ) . to int ( ) ) ; filter and log 0 ( fqcn , slf4j event . get marker ( ) , level , slf4j event . get message ( ) , slf4j event . get argument array ( ) , slf4j event . get throwable ( ) ) ; }	Support SLF4J interception during initialization as introduced in SLF4J version 1.7.15.
public socket call ( ) throws interrupted exception { use defaults for missing fields ( ) ; socket socket = create socket ( ) ; while ( socket == null && ! thread . current thread ( ) . is interrupted ( ) ) { thread . sleep ( delay strategy . next delay ( ) ) ; socket = create socket ( ) ; } return socket ; }	Loops until the desired connection is established and returns the resulting connector.
static public boolean create missing parent directories ( file file ) { file parent = file . get parent file ( ) ; if ( parent == null ) {	Creates the parent directories of a file.
public integer to integer ( ) { switch ( level int ) { case all int : return all integer ; case trace int : return trace integer ; case debug int : return debug integer ; case info int : return info integer ; case warn int : return warn integer ; case error int : return error integer ; case off int : return off integer ; default : throw new illegal state exception ( str + level str + str + level int + str ) ; } }	Convert a Level to an Integer object.
public static level to level ( int val , level default level ) { switch ( val ) { case all int : return all ; case trace int : return trace ; case debug int : return debug ; case info int : return info ; case warn int : return warn ; case error int : return error ; case off int : return off ; default : return default level ; } }	Convert an integer passed as argument to a Level.
public static set < url > get resource occurrence count ( string resource , class loader class loader ) throws io {	Compute the number of occurrences a resource can be found by a classloader.
public static url get resource ( string resource , class loader class loader ) { try { return class loader . get resource ( resource ) ; } catch ( throwable t ) { return null ; } }	Search for a resource using the classloader passed as parameter.
public static class loader get class loader of object ( object o ) { if ( o == null ) { throw new null pointer exception ( str ) ; } return get class loader of class ( o . get class ( ) ) ; }	Get the class loader of the object passed as argument.
public static class loader get class loader as privileged ( final class < ? > clazz ) { if ( ! has get class loader permission ) return null ; else return access controller . do privileged ( new privileged action < class loader > ( ) { public class loader run ( ) { return clazz . get class loader ( ) ; } } ) ; }	Returns the class loader of clazz in an access privileged section.
public static class loader get class loader of class ( final class < ? > clazz ) { class loader cl = clazz . get class loader ( ) ; if ( cl == null ) { return class loader . get system class loader ( ) ; } else { return cl ; } }	Return the class loader which loaded the class passed as argument.
@ override public void start ( ) { if ( ( this . encoder == null ) || ( this . encoder . get layout ( ) == null ) ) { add error ( str + name + str ) ; return ; }	Checks that required parameters are set, and if everything is in order,activates this appender.
protected string get tag ( i event ) {	Gets the logcat tag string of a logging event.
public void begin ( interpretation context ec , string local name , attributes attributes ) { if ( str . equals ( local name ) ) { add warn ( str ) ; } string name = attributes . get value ( name attribute ) ; string value = attributes . get value ( value attribute ) ; string scope str = attributes . get value ( scope attribute ) ; scope scope = action util . string to scope ( scope str ) ; if ( check file attribute sanity ( attributes ) ) { string file = attributes . get value ( file attribute ) ; file = ec . subst ( file ) ; try { file input stream istream = new file input stream ( file ) ; load and set properties ( ec , istream , scope ) ; } catch ( file not found exception e ) { add error ( str + file + str ) ; } catch ( io e1 ) { add error ( str + file + str , e1 ) ; } } else if ( check resource attribute sanity ( attributes ) ) { string resource = attributes . get value ( resource attribute ) ; resource = ec . subst ( resource ) ; url resource url = loader . get resource by self class loader ( resource ) ; if ( resource url == null ) { add error ( str + resource + str ) ; } else { try { input stream istream = resource url . open stream ( ) ; load and set properties ( ec , istream , scope ) ; } catch ( io e ) { add error ( str + resource + str , e ) ; } } } else if ( check value name attributes sanity ( attributes ) ) { value = regular escape util . basic escape ( value ) ;	Set a new property for the execution context by name, value pair, or addsall the properties found in the given file.
public static int get separator index of ( string name , int from index ) { int dot index = name . index of ( core constants . dot , from index ) ; int dollar index = name . index of ( core constants . dollar , from index ) ; if ( dot index == - num && dollar index == - num ) return - num ; if ( dot index == - num ) return dollar index ; if ( dollar index == - num ) return dot index ; return dot index < dollar index ? dot index : dollar index ; }	Get the position of the separator character, if any, starting at position'fromIndex'.
public boolean evaluate ( i event ) throws null pointer exception , evaluation exception { marker events marker = event . get marker ( ) ; if ( events marker == null ) { return bool ; } for ( string marker str : marker list ) { if ( events marker . contains ( marker str ) ) { return bool ; } } return bool ; }	Return true if event passed as parameter contains one of the specifieduser-markers.
protected string get client thread name ( socket socket ) { return string . format ( locale . us , str , socket . get remote socket address ( ) ) ; }	Returns a name to identify each client thread.
static public boolean are on same file store ( file a , file b ) throws rollover failure { if ( ! a . exists ( ) ) { throw new illegal argument exception ( str + a + str ) ; } if ( ! b . exists ( ) ) { throw new illegal argument exception ( str + b + str ) ; }	This method assumes that both files a and b exists.
protected void append ( e event object ) { if ( ! check entry conditions ( ) ) { return ; } string key = discriminator . get discriminating value ( event object ) ; long now = system . current time millis ( ) ; final cyclic buffer < e > cb = cb tracker . get or create ( key , now ) ; sub append ( cb , event object ) ; try { if ( event evaluator . evaluate ( event object ) ) {	Perform SMTPAppender specific appending actions, delegating some of them toa subclass and checking if the event triggers an e-mail to be sent.
protected void send buffer ( cyclic buffer < e > cb , e last event object ) {	Send the contents of the cyclic buffer as an e-mail message.
public void add mdc ( mdc mdc value level pair ) { if ( value level map . contains key ( mdc value level pair . get value ( ) ) ) { add error ( mdc value level pair . get value ( ) + str ) ; } else { value level map . put ( mdc value level pair . get value ( ) , mdc value level pair . get level ( ) ) ; } }	Add a new MDCValuePair.
@ suppress warnings ( str ) dynamic converter < e > create converter ( simple keyword node kn ) { string keyword = ( string ) kn . get value ( ) ; string converter class str = ( string ) converter map . get ( keyword ) ; if ( converter class str != null ) { try { return ( dynamic converter < e > ) option helper . instantiate by class name ( converter class str , dynamic converter . class , context ) ; } catch ( exception e ) { add error ( str + converter class str + str + keyword + str , e ) ; return null ; } } else { add error ( str + keyword + str ) ; return null ; } }	Attempt to create a converter using the information found in'converterMap'.
@ suppress warnings ( str ) composite converter < e > create composite converter ( composite node cn ) { string keyword = ( string ) cn . get value ( ) ; string converter class str = ( string ) converter map . get ( keyword ) ; if ( converter class str != null ) { try { return ( composite converter < e > ) option helper . instantiate by class name ( converter class str , composite converter . class , context ) ; } catch ( exception e ) { add error ( str + converter class str + str + keyword + str , e ) ; return null ; } } else { add error ( str + keyword + str ) ; return null ; } }	Attempt to create a converter using the information found in'compositeConverterMap'.
protected void determine compression mode ( ) { if ( file name pattern str . ends with ( str ) ) { add info ( str ) ; compression mode = compression mode . gz ; } else if ( file name pattern str . ends with ( str ) ) { add info ( str ) ; compression mode = compression mode . zip ; } else { add info ( str ) ; compression mode = compression mode . none ; } }	Given the FileNamePattern string, this method determines the compressionmode depending on last letters of the fileNamePatternStr.
public final void do configure ( url url ) throws joran exception { input stream in = null ; try { inform context of url ( get context ( ) , url ) ; url url connection = url . open connection ( ) ;	Configures logback with the configuration XML read from a file,located at the given URL.
public final void do configure ( file file ) throws joran exception { file input stream fis = null ; try { url url = file . to uri ( ) . to url ( ) ; inform context of url ( get context ( ) , url ) ; fis = new file input stream ( file ) ;	Configures logback with the configuration XML read from a given file.
public final void do configure ( input stream input stream ) throws joran exception { try { do configure ( new input source ( input stream ) ) ; } finally { try { input stream . close ( ) ; } catch ( io ioe ) { string err msg = str ; add error ( err msg , ioe ) ; throw new joran exception ( err msg , ioe ) ; } } }	Configures logback with the configuraiton XML read from an input stream,and then closes the stream.
protected void build interpreter ( ) { rule store rs = new simple rule store ( context ) ; add instance rules ( rs ) ; this . interpreter = new interpreter ( context , rs , initial element path ( ) ) ; interpretation context interpretation context = interpreter . get interpretation context ( ) ; interpretation context . set context ( context ) ; add implicit rules ( interpreter ) ; add default nested component registry rules ( interpretation context . get default nested component registry ( ) ) ; }	Builds a generic configuration-XML interpreter.
private final void do configure ( final input source input source ) throws joran exception { long threshold = system . current time millis ( ) ;	Configures logback with the configuration XML read from an input source.
public void do configure ( final list < sax event > event list ) throws joran exception { build interpreter ( ) ;	Configures logback with SAX events of configuration XML.
public string get property ( string key ) { if ( context name key . equals ( key ) ) return get name ( ) ; return ( string ) this . property map . get ( key ) ; }	Given a key, return the corresponding property value.
public void set name ( string name ) throws illegal state exception { if ( name != null && name . equals ( this . name ) ) { return ;	The context name can be set only if it is not already set, or if thecurrent name is the default context name, namely "default", or if thecurrent name and the old name are the same.
static public boolean context has status listener ( context context ) { status manager sm = context . get status manager ( ) ; if ( sm == null ) return bool ; list < status listener > listeners = sm . get copy of status listener list ( ) ; if ( listeners == null || listeners . size ( ) == num ) return bool ; else return bool ; }	Returns true if the StatusManager associated with the context passedas parameter has one or more StatusListener instances registered.
public long time of last reset ( ) { list < status > status list = sm . get copy of status list ( ) ; if ( status list == null ) return - num ; int len = status list . size ( ) ; for ( int i = len - num ; i >= num ; i -- ) { status s = status list . get ( i ) ; if ( core constants . reset msg prefix . equals ( s . get message ( ) ) ) { return s . get date ( ) ; } } return - num ; }	Return the time of last reset. -1 if last reset time could not be found.
@ override public void start ( ) { int error count = num ; try { parser < e > p = new parser < e > ( pattern ) ; p . set context ( get context ( ) ) ; node t = p . parse ( ) ; this . head = p . compile ( t , get effective converter map ( ) ) ; converter util . start converters ( this . head ) ; } catch ( scan exception ex ) { add error ( str , ex ) ; error count ++ ; } if ( error count == num ) { super . started = bool ; } }	Parses the pattern and creates the Converter linked list.
public map < string , string > get effective converter map ( ) { map < string , string > effective map = new hash map < string , string > ( ) ;	Returns a map where the default converter map is merged with the mapcontained in the context.
@ override public string get file header ( ) { string builder sbuf = new string builder ( ) ; sbuf . append ( str ) ; sbuf . append ( str ) ; sbuf . append ( line separator ) ; sbuf . append ( str ) ; sbuf . append ( line separator ) ; sbuf . append ( str ) ; sbuf . append ( line separator ) ; sbuf . append ( str ) ; sbuf . append ( title ) ; sbuf . append ( str ) ; sbuf . append ( line separator ) ; css builder . add css ( sbuf ) ; sbuf . append ( line separator ) ; sbuf . append ( str ) ; sbuf . append ( line separator ) ; sbuf . append ( str ) ; sbuf . append ( line separator ) ; return sbuf . to string ( ) ; }	Returns appropriate HTML headers.
@ override public string get file footer ( ) { string builder sbuf = new string builder ( ) ; sbuf . append ( line separator ) ; sbuf . append ( str ) ; return sbuf . to string ( ) ; }	Returns the appropriate HTML footers.
@ suppress warnings ( str ) public void begin ( interpretation context ec , string local name , attributes attributes ) throws action exception {	Instantiates an appender of the given class and sets its name.The appender thus generated is placed in the {.
public void end ( interpretation context ec , string name ) { if ( in error ) { return ; } if ( appender instanceof life cycle ) { ( ( life cycle ) appender ) . start ( ) ; } object o = ec . peek object ( ) ; if ( o != appender ) { add warn ( str + appender . get name ( ) + str ) ; } else { ec . pop object ( ) ; } }	Once the children elements are also parsed, now is the time to activate theappender options.
private collection < t > copy clients ( ) { clients lock . lock ( ) ; try { collection < t > copy = new array list < t > ( clients ) ; return copy ; } finally { clients lock . unlock ( ) ; } }	Creates a copy of the collection of all clients that are presentlybeing tracked by the server.
private void add client ( t client ) { clients lock . lock ( ) ; try { clients . add ( client ) ; } finally { clients lock . unlock ( ) ; } }	Adds a client to the collection of those being tracked by the server.
private void remove client ( t client ) { clients lock . lock ( ) ; try { clients . remove ( client ) ; } finally { clients lock . unlock ( ) ; } }	Removes a client from the collection of those being tracked by the server.
public map < string , string > get copy of context map ( ) { map < string , string > hash map = copy on thread local . get ( ) ; if ( hash map == null ) { return null ; } else { return new hash map < string , string > ( hash map ) ; } }	Return a copy of the current thread's context map.
public static method get value of method ( class < ? > type ) { try { return type . get method ( core constants . value of , sting class parameter ) ; } catch ( no such method exception e ) { return null ; } catch ( security exception e ) { return null ; } }	returned value may be null and in most cases it is null.
public filter reply get turbo filter chain decision ( final marker marker , final logger logger , final level level , final string format , final object [ ] params , final throwable t ) { final int size = size ( ) ;	Loop through the filters in the chain.
static public boolean is android os ( ) { string osname = option helper . get system property ( str ) ; string root = option helper . get env ( str ) ; string data = option helper . get env ( str ) ; return osname != null && osname . contains ( str ) && root != null && root . contains ( str ) && data != null && data . contains ( str ) ; }	Heuristically determines whether the current OS is Android.
void init ( ) { try { try { new context initializer ( default logger context ) . auto config ( ) ; } catch ( joran exception je ) { util . report ( str , je ) ; }	Package access for testing purposes.
public static file [ ] files in folder matching stem regex ( file file , final string stem regex ) { if ( file == null ) { return new file [ num ] ; } if ( ! file . exists ( ) || ! file . is directory ( ) ) { return new file [ num ] ; } return file . list files ( new filename filter ( ) { public boolean accept ( file dir , string name ) { return name . matches ( stem regex ) ; } } ) ; }	Return the set of files matching the stemRegex as found in 'directory'.
private void retrospective print ( ) { if ( context == null ) return ; long now = system . current time millis ( ) ; status manager sm = context . get status manager ( ) ; list < status > status list = sm . get copy of status list ( ) ; for ( status status : status list ) { long timestamp of status mesage = status . get date ( ) ; if ( is elapsed time longer than threshold ( now , timestamp of status mesage ) ) { print ( status ) ; } } }	Print status messages retrospectively.
public file get database file ( string filename ) { file db file = null ; if ( filename != null && filename . trim ( ) . length ( ) > num ) { db file = new file ( filename ) ; } if ( db file == null || db file . is directory ( ) ) { db file = new file ( new android context util ( ) . get database path ( str ) ) ; } return db file ; }	Gets a file object from a file path to a SQLite database.
private void clear expired logs ( sq db ) { if ( last check expired ( this . max history , this . last cleanup time ) ) { this . last cleanup time = this . clock . current time millis ( ) ; this . get log cleaner ( ) . perform log cleanup ( db , this . max history ) ; } }	Removes expired logs from the database.
private boolean last check expired ( duration expiry , long last cleanup time ) { boolean is expired = bool ; if ( expiry != null && expiry . get milliseconds ( ) > num ) { final long now = this . clock . current time millis ( ) ; final long time diff = now - last cleanup time ; is expired = ( last cleanup time <= num ) || ( time diff >= expiry . get milliseconds ( ) ) ; } return is expired ; }	Determines whether it's time to clear expired logs.
private long sub append ( i event , sq insert statement ) throws sql { bind logging event ( insert statement , event ) ; bind logging event arguments ( insert statement , event . get argument array ( ) ) ;	Inserts the main details of a log event into the database.
private void secondary sub append ( i event , long event id ) throws sql { map < string , string > merged map = merge property maps ( event ) ; insert properties ( merged map , event id ) ; if ( event . get throwable proxy ( ) != null ) { insert throwable ( event . get throwable proxy ( ) , event id ) ; } }	Updates an existing row of an event with the secondary details of the event.This includes MDC properties and any exception information.
private void bind logging event ( sq stmt , i event ) throws sql { stmt . bind long ( timestmp index , event . get time stamp ( ) ) ; stmt . bind string ( formatted message index , event . get formatted message ( ) ) ; stmt . bind string ( logger name index , event . get logger name ( ) ) ; stmt . bind string ( level string index , event . get level ( ) . to string ( ) ) ; stmt . bind string ( thread name index , event . get thread name ( ) ) ; stmt . bind long ( reference flag index , compute reference mask ( event ) ) ; }	Binds the main details of a log event to a SQLite statement's parameters.
private string as string truncated to254 ( object o ) { string s = null ; if ( o != null ) { s = o . to string ( ) ; } if ( s != null && s . length ( ) > num ) { s = s . substring ( num , num ) ; } return s == null ? str : s ; }	Gets the first 254 characters of an object's string representation.
private static short compute reference mask ( i event ) { short mask = num ; int mdc prop size = num ; if ( event . get mdc ( ) != null ) { mdc prop size = event . get mdc ( ) . key set ( ) . size ( ) ; } int context prop size = num ; if ( event . get logger context vo ( ) . get property map ( ) != null ) { context prop size = event . get logger context vo ( ) . get property map ( ) . size ( ) ; } if ( mdc prop size > num || context prop size > num ) { mask = properties exist ; } if ( event . get throwable proxy ( ) != null ) { mask |= exception exists ; } return mask ; }	Computes the reference mask for a logging event, includingflags to indicate whether MDC properties or exception infois available for the event.
private map < string , string > merge property maps ( i event ) { map < string , string > merged map = new hash map < string , string > ( ) ;	Merges a log event's properties with the properties of the logger context.The context properties are first in the map, and then the event's propertiesare appended.
private void insert exception ( sq stmt , string txt , short i , long event id ) throws sql { stmt . bind long ( num , event id ) ; stmt . bind long ( num , i ) ; stmt . bind string ( num , txt ) ; stmt . execute insert ( ) ; }	Inserts an exception into the logging_exceptions table.
public int get prefix match length ( element path p ) { if ( p == null ) { return num ; } int l size = this . part list . size ( ) ; int r size = p . part list . size ( ) ;	Returns the number of "prefix" components that this pattern has in commonwith the pattern p passed as parameter.
public synchronized int get effective level ( ) { int result = level ; int eff level ; iterator it = iterator ( ) ; status s ; while ( it . has next ( ) ) { s = ( status ) it . next ( ) ; eff level = s . get effective level ( ) ; if ( eff level > result ) { result = eff level ; } } return result ; }	different status objects lying on the same cycle.
private boolean is unequivocally instantiable ( class < ? > clazz ) { if ( clazz . is interface ( ) ) { return bool ; }	Can the given clazz instantiable with certainty?.
@ override protected hash map < string , string > child value ( hash map < string , string > parent value ) { if ( parent value == null ) { return null ; } else { return new hash map < string , string > ( parent value ) ; } }	Child threads should get a copy of the parent's hashmap.
@ override protected void process include ( interpretation context ic , url url ) throws joran exception { input stream in = open url ( url ) ; try { if ( in != null ) {	Processes an include.
private input stream open url ( url url ) { try { return url . open stream ( ) ; } catch ( io e ) { optional warning ( str + url . to string ( ) + str , e ) ; return null ; } }	Opens the given URL, logging any exceptions.
private void trim head and tail ( sax event recorder recorder ) { list < sax event > sax event list = recorder . get sax event list ( ) ; if ( sax event list . size ( ) == num ) { return ; } boolean included tag found = bool ; boolean config tag found = bool ;	Removes the head tag and tail tag if they are named either"included" or "configuration".
protected boolean should start ( ) { server socket server socket = null ; try { server socket = get server socket factory ( ) . create server socket ( get port ( ) , get backlog ( ) , get inet address ( ) ) ; server listener < remote appender client > listener = create server listener ( server socket ) ; runner = create server runner ( listener , get context ( ) . get scheduled executor service ( ) ) ; runner . set context ( get context ( ) ) ; return bool ; } catch ( exception ex ) { add error ( str + ex , ex ) ; close util . close quietly ( server socket ) ; return bool ; } }	Starts the server.
public boolean is transient ( ) { throwable cause = get cause ( ) ; if ( cause == null ) { return is server error ( status code ) ; } else if ( cause instanceof algolia exception ) { return ( ( algolia exception ) cause ) . is transient ( ) ; } else if ( cause instanceof io ) { return bool ; } else { return bool ; } }	Test whether this error is transient.
private void set default hosts ( ) { list < string > fallback hosts = arrays . as list ( str , str , str ) ; collections . shuffle ( fallback hosts ) ; list < string > hosts = new array list < > ( fallback hosts . size ( ) + num ) ; hosts . add ( str ) ; hosts . add all ( fallback hosts ) ; string [ ] hosts array = hosts . to array ( new string [ hosts . size ( ) ] ) ; set read hosts ( hosts array ) ; set write hosts ( hosts array ) ; }	Set the default hosts for Algolia Places.
private synchronized void ensure local index ( ) { if ( local index == null ) { local index = new local index ( get client ( ) . get root data dir ( ) . get absolute path ( ) , get client ( ) . get application id ( ) , get raw index name ( ) ) ; } }	Lazy instantiate the local index.
public void sync ( ) { if ( get data selection queries ( ) . length == num ) { throw new illegal state exception ( str ) ; } synchronized ( this ) { if ( syncing ) return ; syncing = bool ; } get client ( ) . local build executor service . submit ( new runnable ( ) { @ override public void run ( ) { sync ( ) ; } } ) ; }	Launch a sync.If a sync is already running, this call is ignored.
public void sync if needed ( ) { long current date = system . current time millis ( ) ; if ( current date - mirror settings . get last sync date ( ) . get time ( ) > delay between syncs || mirror settings . get queries modification date ( ) . compare to ( mirror settings . get last sync date ( ) ) > num ) { sync ( ) ; } }	Launch a sync only if the data is obsolete.The data is obsolete if the last successful sync is older than the delay between syncs, or if the data selectionqueries have been changed in the meantime.
public json wait task ( string task id , long time to wait ) throws algolia exception { try { while ( bool ) { json obj = client . get request ( str + encoded index name + str + url . encode ( task id , str ) , null , bool , null ) ; if ( obj . get string ( str ) . equals ( str ) ) { return obj ; } try { thread . sleep ( time to wait >= max time ms to wait ? max time ms to wait : time to wait ) ; } catch ( interrupted exception e ) { continue ; } final long new timeout = time to wait * num ; time to wait = ( new timeout <= num || new timeout >= max time ms to wait ) ? max time ms to wait : new timeout ; } } catch ( json e ) { throw new algolia exception ( e . get message ( ) ) ; } catch ( unsupported encoding exception e ) { throw new runtime exception ( e ) ; } }	Wait the publication of a task on the server.All server task are asynchronous and you can check with this method that the task is published.
private json list indexes offline sync ( ) throws algolia exception { try { final string root data path = get root data dir ( ) . get absolute path ( ) ; final file app dir = get app dir ( ) ; final file [ ] directories = app dir . list files ( new file filter ( ) { @ override public boolean accept ( file pathname ) { return pathname . is directory ( ) ; } } ) ; json response = new json ( ) ; json items = new json ( ) ; if ( directories != null ) { for ( file directory : directories ) { final string name = directory . get name ( ) ; if ( has offline data ( name ) ) { items . put ( new json ( ) . put ( str , name ) ) ;	List existing offline indices.**Note:** This applies both to {.
private static string to char array ( input stream stream ) throws io { input stream reader is = new input stream reader ( stream , str ) ; string builder builder = new string builder ( ) ; char [ ] buf = new char [ num ] ; int l = num ; while ( l >= num ) { builder . append ( buf , num , l ) ; l = is . read ( buf ) ; } is . close ( ) ; return builder . to string ( ) ; }	Reads the InputStream as UTF-8.
private static byte [ ] to byte array ( input stream stream ) throws algolia exception { byte array output stream out = new byte array output stream ( ) ; int read ; byte [ ] buffer = new byte [ num ] ; try { while ( ( read = stream . read ( buffer , num , buffer . length ) ) != - num ) { out . write ( buffer , num , read ) ; } out . flush ( ) ; return out . to byte array ( ) ; } catch ( io e ) { throw new algolia exception ( str + e . get message ( ) ) ; } }	Reads the InputStream into a byte array.
private static void consume quietly ( final url connection ) { try { int read = num ; while ( read != - num ) { read = connection . get input stream ( ) . read ( ) ; } connection . get input stream ( ) . close ( ) ; read = num ; while ( read != - num ) { read = connection . get error stream ( ) . read ( ) ; } connection . get error stream ( ) . close ( ) ; connection . disconnect ( ) ; } catch ( io e ) {	Ensures that the entity content is fully consumed and the content stream, if exists,is closed.
private list < string > hosts that are up ( list < string > hosts ) { list < string > up hosts = new array list < > ( ) ; for ( string host : hosts ) { if ( is up or could be retried ( host ) ) { up hosts . add ( host ) ; } } return up hosts . is empty ( ) ? hosts : up hosts ; }	Get the hosts that are not considered down in a given list.
public @ non null places query set type ( type type ) { if ( type == null ) { set ( key type , null ) ; } else { switch ( type ) { case city : set ( key type , str ) ; break ; case country : set ( key type , str ) ; break ; case address : set ( key type , str ) ; break ; case bus stop : set ( key type , str ) ; break ; case train station : set ( key type , str ) ; break ; case town hall : set ( key type , str ) ; break ; case airport : set ( key type , str ) ; break ; } } return this ; }	Set the type of place to search for.
public void start ( ) { if ( started ) { throw new illegal state exception ( ) ; } started = bool ; request = index . browse async ( query , request options , completion handler ) ; }	Start the iteration.
public v put ( k key , v value ) { v previous = null ; synchronized ( this ) { long timeout = system . current time millis ( ) + time unit . milliseconds . convert ( expiration timeout , expiration time unit ) ; final pair < v , long > previous pair = lru cache . put ( key , new pair < > ( value , timeout ) ) ; if ( previous pair != null ) { previous = previous pair . first ; } } return previous ; }	Puts a value in the cache, computing an expiration time.
synchronized public v get ( k key ) { final pair < v , long > cache pair = lru cache . get ( key ) ; if ( cache pair != null && cache pair . first != null ) { if ( cache pair . second > system . current time millis ( ) ) { return cache pair . first ; } else { lru cache . remove ( key ) ; } } return null ; }	Get a value from the cache.
public void await completion ( ) { for ( thread thread : threads ) { try { thread . join ( ) ; } catch ( interrupted exception e ) { throw rethrow ( e ) ; } } if ( caught exception != null ) { throw rethrow ( caught exception ) ; } }	Waits for all threads to finish.If {.
public static void report ( string test id , throwable cause ) { if ( cause == null ) { logger . fatal ( str ) ; return ; } long exception count = failure id . increment and get ( ) ; if ( exception count > max exception count ) { logger . warn ( str + exception count + str + str , cause ) ; return ; } logger . warn ( str + exception count + str , cause ) ; string target file name = exception count + str ; file dir = get user dir ( ) ; file tmp file = new file ( dir , target file name + str ) ; try { if ( ! tmp file . create new file ( ) ) { throw new io ( str + tmp file . get absolute path ( ) ) ; } } catch ( io e ) { logger . fatal ( str , e ) ; return ; } write text ( test id + new line + throwable to string ( cause ) , tmp file ) ; file file = new file ( dir , target file name ) ; logger . info ( file . get absolute path ( ) ) ; rename ( tmp file , file ) ; }	Writes the cause to file.
public static void copy directory ( file src , file target ) { check not null ( src , str ) ; check not null ( target , str ) ; file [ ] files = src . list files ( ) ; if ( files == null ) { return ; } for ( file src file : files ) { if ( src file . is directory ( ) ) { file target child = new file ( target , src file . get name ( ) ) ; ensure existing directory ( target child ) ; copy directory ( src file , target child ) ; } else { copy file to directory ( src file , target ) ; } } }	Copies a directory recursively.
public simulator properties init ( file file ) { if ( file == null ) {	Initializes the SimulatorProperties with additional properties.
public static < e > e get static field value ( class clazz , string field name , class field type ) { field field = get field ( clazz , field name , field type ) ; if ( field == null ) { throw new reflection exception ( format ( str , clazz . get name ( ) , field name ) ) ; } field . set accessible ( bool ) ; return get field value0 ( null , field , clazz . get name ( ) , field name ) ; }	Gets the value for a static field.
public static method get method by name ( class clazz , string method name ) { for ( method method : clazz . get declared methods ( ) ) { if ( method . get name ( ) . equals ( method name ) ) { return method ; } } return null ; }	Searches a method by name.
public static string format percentage ( long value , long base value ) { double percentage = ( base value > num ? ( one hundred * value ) / base value : num ) ; return format double ( percentage , percentage format length ) ; }	Formats a percentage of two numbers and adds padding to the left.
public static string format double ( double number , int length ) { return pad left ( format ( locale . us , str , number ) , length ) ; }	Formats a double number and adds padding to the left.Very inefficient implementation, but a lot easier than to deal with the formatting API.
public static string format long ( long number , int length ) { return pad left ( format ( locale . us , str , number ) , length ) ; }	Formats a long number and adds padding to the left.Very inefficient implementation, but a lot easier than to deal with the formatting API.
private void write json string ( byte [ ] b ) throws io { context . write ( ) ; transport . write ( quote ) ; int len = b . length ; for ( int i = num ; i < len ; i ++ ) { if ( ( b [ i ] & num ) >= num ) { if ( b [ i ] == backslash [ num ] ) { transport . write ( backslash ) ; transport . write ( backslash ) ; } else { transport . write ( b , i , num ) ; } } else { tmpbuf [ num ] = json char table [ b [ i ] ] ; if ( tmpbuf [ num ] == num ) { transport . write ( b , i , num ) ; } else if ( tmpbuf [ num ] > num ) { transport . write ( backslash ) ; transport . write ( tmpbuf , num , num ) ; } else { transport . write ( escseq ) ; tmpbuf [ num ] = hex char ( ( byte ) ( b [ i ] > > num ) ) ; tmpbuf [ num ] = hex char ( b [ i ] ) ; transport . write ( tmpbuf , num , num ) ; } } } transport . write ( quote ) ; }	Write the bytes in array buf as a Json characters, escaping as needed.
private void write json integer ( long num ) throws io { context . write ( ) ; string str = long . to string ( num ) ; boolean escape num = context . escape num ( ) ; if ( escape num ) { transport . write ( quote ) ; } try { byte [ ] buf = str . get bytes ( str ) ; transport . write ( buf ) ; } catch ( unsupported encoding exception e ) { throw new assertion error ( e ) ; } if ( escape num ) { transport . write ( quote ) ; } }	wrapped in quotes to output as a Json string.
private void write json double ( double num ) throws io { context . write ( ) ; string str = double . to string ( num ) ; boolean special = bool ; switch ( str . char at ( num ) ) { case str :	context dictates escaping, write out as Json string.
private string read json numeric chars ( ) throws io { string builder strbld = new string builder ( ) ; while ( bool ) { byte ch = reader . peek ( ) ; if ( ! is json numeric ( ch ) ) { break ; } strbld . append ( ( char ) reader . read ( ) ) ; } return strbld . to string ( ) ; }	not do a complete regex check to validate that this is actually a number.
private long read json integer ( ) throws io { context . read ( ) ; if ( context . escape num ( ) ) { read json syntax char ( quote ) ; } string str = read json numeric chars ( ) ; if ( context . escape num ( ) ) { read json syntax char ( quote ) ; } try { return long . value of ( str ) ; } catch ( number format exception ex ) { throw new protocol exception ( str ) ; } }	Read in a Json number.
private double read json double ( ) throws io { context . read ( ) ; if ( reader . peek ( ) == quote [ num ] ) { byte string str = read json string ( bool ) ; double dub = double . value of ( str . utf8 ( ) ) ; if ( ! context . escape num ( ) && ! double . is na n ( dub ) && ! double . is infinite ( dub ) ) {	when expected or if wrapped in quotes when not expected.
private byte string read json base64 ( ) throws io { byte string str = read json string ( bool ) ; return byte string . decode base64 ( str . utf8 ( ) ) ; }	Read in a Json string containing base-64 encoded data and decode it.
protected final object execute ( method call < ? > method call ) throws exception { if ( ! running . get ( ) ) { throw new illegal state exception ( str ) ; } try { return invoke request ( method call ) ; } catch ( server exception e ) { throw e . thrift exception ; } }	When invoked by a derived instance, sends the given call to the server.
final object invoke request ( method call < ? > call ) throws exception { boolean is one way = call . call type id == t . oneway ; int sid = seq id . increment and get ( ) ; protocol . write message begin ( call . name , call . call type id , sid ) ; call . send ( protocol ) ; protocol . write message end ( ) ; protocol . flush ( ) ; if ( is one way ) {	Send the given call to the server.
protected void enqueue ( method call < ? > method call ) { if ( ! running . get ( ) ) { throw new illegal state exception ( str ) ; } if ( ! pending calls . offer ( method call ) ) {	When invoked by a derived instance, places the given call in a queue tobe sent to the server.
public static i get resource from fs ( string location ) { return activator . get default ( ) . get workspace ( ) . get root ( ) . get file for location ( new path ( location ) ) ; }	Resolves a file system location to an Eclipse workspace resource.
public static void update decoration ( ) { final i workbench = activator . get default ( ) . get workbench ( ) ; workbench . get display ( ) . sync exec ( new runnable ( ) { public void run ( ) { i manager = workbench . get decorator manager ( ) ; manager . update ( guvnor decorator . decorator id ) ; } } ) ; }	Causes the platform to update Guvnor decoration notions.
public static void refresh repository view ( ) { i active window = activator . get default ( ) . get workbench ( ) . get active workbench window ( ) ;	Causes the Repository view to refresh, if it is open.
public static resource history view get resource history view ( ) throws exception { i active window = activator . get default ( ) . get workbench ( ) . get active workbench window ( ) ;	Tries to find the Resource History view, attempting to open it if necessary.
public static void open editor ( string contents , string name ) { i window = ui . get workbench ( ) . get active workbench window ( ) ; i storage = new string storage ( contents , name ) ; i input = new string input ( storage ) ; i page = window . get active page ( ) ; i desc = ui . get workbench ( ) . get editor registry ( ) . get default editor ( name ) ;	Opens a read-only, in-memory editor.
public static void report authentication failure ( ) { display display = ui . get workbench ( ) . get display ( ) ; display . async exec ( new runnable ( ) { public void run ( ) { display display = display . get current ( ) ; shell shell = display . get active shell ( ) ; message dialog . open error ( shell , messages . get string ( str ) ,	Convenience method for reporting log in failure.
public auth prompt results prompt for authentication ( final string server ) { display display = ui . get workbench ( ) . get display ( ) ; auth prompt runnable op = new auth prompt runnable ( server ) ; display . sync exec ( op ) ; return op . get results ( ) ; }	Prompts for user name and password for a given Guvnor repository.
private control create default page ( form toolkit kit ) { form form = kit . create form ( book ) ; composite body = form . get body ( ) ; grid layout layout = new grid layout ( num , bool ) ; body . set layout ( layout ) ; link hlink = new link ( body , swt . none ) ; hlink . set text ( str ) ; hlink . set background ( book . get display ( ) . get system color ( swt . color list background ) ) ; grid data gd = new grid data ( swt . left , swt . fill , bool , bool ) ; hlink . set layout data ( gd ) ; hlink . add selection listener ( new selection adapter ( ) { public void widget selected ( selection event e ) {	Creates a page displayed when there are no servers defined.
protected void start thread ( ) { if ( animation active ) return ; stop animation = bool ; final display display = tree viewer == null ? display . get default ( ) : tree viewer . get control ( ) . get display ( ) ; final int sleep = num ; final runnable [ ] animator = new runnable [ num ] ; animator [ num ] = new runnable ( ) { public void run ( ) { if ( ! stop animation ) { try { int size = num ; string [ ] servers ; synchronized ( starting ) { size = starting . size ( ) ; servers = new string [ size ] ; starting . to array ( servers ) ; } for ( int i = num ; i < size ; i ++ ) { i server = server core . find server ( servers [ i ] ) ; if ( server != null ) {	Start the animation thread.
public void set is keep all alive ( boolean is keep all alive ) { element child = get first child ( root , child names ) ; boolean is already keep all alive = bool ; if ( is dav ( child , str ) )	Sets whether this propertybehavior is in the "keep all alive" form ornot.
public void set is omit ( boolean is omit ) { element child = get first child ( root , child names ) ; boolean is already omit = is dav ( child , str ) ;	Sets whether this propertybehavior is in the "omit" form or not.
public owner set owner ( ) { element owner = set child ( root , str , child names , bool ) ;	Creates and sets an owner element on this activelock and returns aneditor on it.
public void add condition factor ( condition factor factor ) throws dav { if ( condition factors . contains ( factor ) ) throw new dav ( i . sc bad request , policy . bind ( str ) ) ;	Add a ConditionFactor to a ConditionTerm.
public static condition term create ( stream tokenizer tokenizer ) throws dav { condition term term = new condition term ( ) ; try { int token = tokenizer . ttype ; if ( token == str ) token = tokenizer . next token ( ) ; else throw new dav ( i . sc bad request , policy . bind ( str , string . value of ( token ) , str ) ) ;	Create a ConditionTerm by parsing the given If header as defined bysection 9.4 in the WebDAV spec.
public boolean matches ( condition term condition term ) { int number of items to match = num ; boolean match = bool ; enumeration factors = get condition factors ( ) ; while ( match && factors . has more elements ( ) ) { condition factor factor = ( condition factor ) factors . next element ( ) ; if ( factor . not ( ) ) { match = ! condition term . contains ( factor ) ; } else { match = condition term . contains ( factor ) ; number of items to match ++ ; } } match = match && number of items to match == condition term . number of factors ( ) ; return match ; }	See if this ConditionTerm matches the given ConditionTerm.
public static reader get dsl ( string rule source , i input ) throws core exception { string dsl file name = find dsl ( rule source , input ) ; if ( dsl file name == null ) { return null ; } i res = find dsl ( input , dsl file name ) ; if ( res instanceof i ) { i dsl conf = ( i ) res ; if ( dsl conf . exists ( ) ) { return new input stream reader ( dsl conf . get contents ( ) ) ; } } return null ; }	Get a reader to the DSL contents.
private void load config ( i input ) { i res = find dsl ( input , dsl config name ) ; if ( res instanceof i ) { i dsl conf = ( i ) res ; if ( dsl conf . exists ( ) ) { input stream stream = null ; try { stream = dsl conf . get contents ( ) ; read config ( stream ) ; valid = bool ; } catch ( exception e ) { throw new illegal state exception ( str + e . get message ( ) + str ) ; } finally { close stream ( stream ) ; } } } }	This does the hunting around the projec to find the .dsl file.
void read config ( input stream stream ) throws io , core exception { dsl file = new dsl ( ) ; file . parse and load ( new input stream reader ( stream ) ) ; dsl grammar = file . get mapping ( ) ; list < dsl > conditions = grammar . get entries ( dsl . condition ) ; list < dsl > consequences = grammar . get entries ( dsl . consequence ) ; condition proposals = build proposals ( conditions ) ; consequence proposals = build proposals ( consequences ) ; dsl tree . build tree ( grammar ) ; }	This will load in the DSL config file, using the DSLMapping from drools-compiler.
public menu get menu ( control parent ) { set menu ( new menu ( parent ) ) ; final shell shell = parent . get shell ( ) ; add project wizard ( menu , shell ) ; add rule wizard ( menu , shell ) ; add dsl ( menu , shell ) ; add dt ( menu , shell ) ; return menu ; }	Return a menu which launches the various wizards.
public response body add response ( ) { element response = add child ( root , str , child names , bool ) ;	Creates and adds a response element to this multistatus and returnsan editor on it.
public void add href ( string href ) { string encoded href = encode href ( href ) ; if ( is duplicate ( encoded href ) ) return ; append child ( root , str , encoded href ) ;	Adds the given href to the end of the set of hrefs.
public void insert href before ( string new href , string ref href ) { string ref href encoded = encode href ( ref href ) ; string new href encoded = encode href ( new href ) ; if ( is duplicate ( new href encoded ) ) return ; element child = get first child ( root , str ) ;	Inserts the given newHref before the given refHref in the set ofhrefs.
public void remove href ( string href ) { string encoded href = encode href ( href ) ; element child = get first child ( root , str ) ;	Remove the given href from the set of hrefs.
public prop stat add prop stat ( ) { element first href = get first child ( root , str ) ;	Creates and adds a propstat element on this response and returns aneditor on it.
public string get href ( ) throws malformed element exception { string href = get child text ( root , str , bool ) ;	Returns this response's first href.
public string get status ( ) throws malformed element exception { element status = get first child ( root , str ) ;	Returns this response's status.
public static i get stack frame ( i value ) throws core exception { i handler = get stack frame provider ( ) ; if ( handler != null ) { i stack frame = ( i ) handler . handle status ( fg need stack frame , value ) ; if ( stack frame != null ) { return stack frame ; } } i target = value . get debug target ( ) ; i java target = ( i ) target . get adapter ( i . class ) ; if ( java target != null ) { i [ ] threads = java target . get threads ( ) ; for ( int i = num ; i < threads . length ; i ++ ) { i thread = threads [ i ] ; if ( thread . is suspended ( ) ) { return ( i ) thread . get top stack frame ( ) ; } } } return null ; }	Return the current stack frame context, or a valid stack frame for thegiven value.
private boolean is subtype of ( string class1 , string class2 ) { if ( class1 == null || class2 == null ) { return bool ; } class1 = convert to non primitive class ( class1 ) ; class2 = convert to non primitive class ( class2 ) ;	Returns true if the first class is the same or a subtype of the secondclass.
public static boolean contains proposal ( final collection < i > proposals , string new proposal ) { for ( i prop : proposals ) { string display string = prop . get display string ( ) ; string [ ] existings = display string . split ( str ) ; if ( existings . length == num ) { continue ; } string [ ] new proposals = new proposal . split ( str ) ; if ( new proposals . length == num ) { continue ; } if ( existings [ num ] . equals ( new proposals [ num ] ) ) { return bool ; } } return bool ; }	Attempt to compare proposals of different types based on the tokenized display string.
public void reset ( ) throws io { if ( file == null ) { ( ( byte array input stream ) is ) . reset ( ) ; } else { if ( fos != null ) { while ( skip ( num ) > num ) ; fos . close ( ) ; fos = null ; if ( length == - num ) { length = total bytes read ; } } is . close ( ) ; is = new file input stream ( file ) ; } total bytes read = num ; }	Resets the stream to its beginning so it can be read again.
protected void create actions ( ) { super . create actions ( ) ; i a = new text operation action ( rule editor messages . get resource bundle ( ) , str , this , i . contentassist proposals ) ; a . set action definition id ( i . content assist proposals ) ; set action ( str , a ) ; a = new text operation action ( rule editor messages . get resource bundle ( ) , str , this , i . contentassist context information ) ;	For user triggered content assistance.
public void add connection ( connection conn ) { if ( conn == null || conn . get source ( ) == conn . get target ( ) ) { throw new illegal argument exception ( ) ; } if ( conn . get source ( ) == this ) { source connections . add ( conn ) ; fire property change ( source connections prop , null , conn ) ; } else if ( conn . get target ( ) == this ) { target connections . add ( conn ) ; fire property change ( target connections prop , null , conn ) ; } }	Add an incoming or outgoing connection to this vertex.
public object get property value ( object property id ) { if ( xpos prop . equals ( property id ) ) { return integer . to string ( location . x ) ; } if ( ypos prop . equals ( property id ) ) { return integer . to string ( location . y ) ; } if ( height prop . equals ( property id ) ) { return integer . to string ( size . height ) ; } if ( width prop . equals ( property id ) ) { return integer . to string ( size . width ) ; } return null ; }	Return the property value for the given propertyId, or null.
public void remove connection ( connection conn ) { if ( conn == null ) { throw new illegal argument exception ( ) ; } if ( conn . get source ( ) == this ) { source connections . remove ( conn ) ; fire property change ( source connections prop , null , conn ) ; } else if ( conn . get target ( ) == this ) { target connections . remove ( conn ) ; fire property change ( target connections prop , null , conn ) ; } }	Remove an incoming or outgoing connection from this vertex.
public void set location ( point new location ) { if ( new location == null ) { throw new illegal argument exception ( ) ; } location . set location ( new location ) ; fire property change ( location prop , null , location ) ; }	Set the Location of this vertex.
public void set property value ( object property id , object value ) { if ( xpos prop . equals ( property id ) ) { int x = integer . parse int ( ( string ) value ) ; set location ( new point ( x , location . y ) ) ; } else if ( ypos prop . equals ( property id ) ) { int y = integer . parse int ( ( string ) value ) ; set location ( new point ( location . x , y ) ) ; } else if ( height prop . equals ( property id ) ) { int height = integer . parse int ( ( string ) value ) ; set size ( new dimension ( size . width , height ) ) ; } else if ( width prop . equals ( property id ) ) { int width = integer . parse int ( ( string ) value ) ; set size ( new dimension ( width , size . height ) ) ; } }	Set the property value for the given property id.
public void set size ( dimension new size ) { if ( new size != null ) { size . set size ( new size ) ; fire property change ( size prop , null , size ) ; } }	Set the Size of this vertex.Will not update the size if newSize is null.
public static string dump constraints ( final constraint [ ] constraints ) { if ( constraints == null ) { return null ; } final string buffer buffer = new string buffer ( ) ; for ( int i = num , length = constraints . length ; i < length ; i ++ ) { buffer . append ( constraints [ i ] . to string ( ) + str ) ; } return buffer . to string ( ) ; }	Constructs constraints string.
public lock entry add lock entry ( ) { element lockentry = add child ( root , str , child names , bool ) ;	Creates a new lockentry and adds it to this supported lock.
public boolean add child ( base vertex vertex ) { if ( vertex != null && vertices . add ( vertex ) ) { fire property change ( prop child added , null , vertex ) ; return bool ; } return bool ; }	Add new BaseVertex to the graph.
public boolean remove child ( base vertex vertex ) { if ( vertex != null && vertices . remove ( vertex ) ) { fire property change ( prop child removed , null , vertex ) ; return bool ; } return bool ; }	Remove a vertex from this graph.
public void start ( bundle context context ) throws exception { super . start ( context ) ; i preference store = get preference store ( ) ; use cache preference = preference store . get boolean ( i . cache parsed rules ) ; preference store . add property change listener ( new i ( ) { public void property change ( property change event event ) { if ( i . cache parsed rules . equals ( event . get property ( ) ) ) { use cache preference = ( ( boolean ) event . get new value ( ) ) . boolean value ( ) ; if ( ! use cache preference ) { clear cache ( ) ; } } } } ) ; }	This method is called upon plug-in activation.
public void stop ( bundle context context ) throws exception { super . stop ( context ) ; plugin = null ; resource bundle = null ; parsed rules = null ; compiled rules = null ; process infos = null ; process infos by id = null ; for ( color color : colors . values ( ) ) { color . dispose ( ) ; } }	This method is called when the plug-in is stopped.
public static string get resource string ( string key ) { resource bundle bundle = drools eclipse plugin . get default ( ) . get resource bundle ( ) ; try { return ( bundle != null ) ? bundle . get string ( key ) : key ; } catch ( missing resource exception e ) { return key ; } }	Returns the string from the plugin's resource bundle,or 'key' if not found.
public resource bundle get resource bundle ( ) { try { if ( resource bundle == null ) resource bundle = resource bundle . get bundle ( str ) ; } catch ( missing resource exception x ) { resource bundle = null ; } return resource bundle ; }	Returns the plugin's resource bundle,.
public form colors get rule builder form colors ( display display ) { if ( rule builder form colors == null ) { rule builder form colors = new form colors ( display ) ; rule builder form colors . mark shared ( ) ; } return rule builder form colors ; }	Form Colors, default colors for now.
public void set date time ( string date ) { string [ ] patterns = { rfc 1123 pattern , iso 8601 utc pattern , iso 8601 utc millis pattern , iso 8601 pattern , iso 8601 millis pattern , rfc 850 pattern , asctime pattern } ; for ( int i = num ; i < patterns . length ; i ++ ) { if ( set date time ( date , patterns [ i ] ) ) break ; } }	Do nothing if date format is not supported.
protected boolean set date time ( string date , string pattern ) { boolean date changed = bool ; date format . apply pattern ( pattern ) ; try { set date time ( date format . parse ( date ) ) ; } catch ( parse exception e ) { date changed = bool ; } return date changed ; }	Do nothing if date format is not supported.
public static i error ( final string message , final throwable thr ) { return new status ( i . error , plugin id , num , message , thr ) ; }	Utility to create an error status for this plug-in.
public static void log error ( final string message , final throwable thr ) { get default ( ) . get log ( ) . log ( error ( message , thr ) ) ; }	Utility method to log errors in the Egit plugin.
protected void add field ( field editor editor ) { if ( fields == null ) { fields = new array list < field editor > ( ) ; }	Adds the given field editor to this page.
protected void adjust grid layout ( ) { int num columns = calc number of columns ( ) ; ( ( grid layout ) field editor parent . get layout ( ) ) . num columns = num columns ; if ( fields != null ) { for ( int i = num ; i < fields . size ( ) ; i ++ ) { field editor field editor = fields . get ( i ) ; field editor . fill into grid ( field editor parent , num columns ) ; } } }	Adjust the layout of the field editors so that they are properly aligned.
protected void apply font ( ) { if ( fields != null ) { iterator < field editor > e = fields . iterator ( ) ; while ( e . has next ( ) ) { field editor pe = e . next ( ) ;	Applys the font to the field editors managed by this page.
private int calc number of columns ( ) { int result = num ; if ( fields != null ) { iterator < field editor > e = fields . iterator ( ) ; while ( e . has next ( ) ) { field editor pe = e . next ( ) ; result = math . max ( result , pe . get number of controls ( ) ) ; } } return result ; }	Calculates the number of columns needed to host all field editors.
protected void initialize ( ) { if ( fields != null ) { iterator < field editor > e = fields . iterator ( ) ; while ( e . has next ( ) ) { field editor pe = e . next ( ) ; pe . set page ( this ) ; pe . set property change listener ( this ) ; pe . set preference store ( get preference store ( ) ) ; pe . load ( ) ; } } }	Initializes all field editors.
public void fire property change event ( object source , string name , object old value , object new value ) { property change event event = new property change event ( source , name , old value , new value ) ; object [ ] listeners = f listeners . get listeners ( ) ; for ( int i = num ; i < listeners . length ; i ++ ) ( ( i ) listeners [ i ] ) . property change ( event ) ; }	Fires a property change event with the given source, property name, old and new value.
public void set active editor ( i part ) { super . set active editor ( part ) ; if ( part instanceof drl ) { drl p = ( drl ) part ; p . set zoom combo contribution item ( zitem ) ; p . set zoom in action ( zoom in ) ; p . set zoom out action ( zoom out ) ; } }	In addition to .
public void contribute to tool bar ( i tool bar manager ) { super . contribute to tool bar ( tool bar manager ) ; tool bar manager . add ( new separator ( ) ) ; string [ ] zoom strings = new string [ ] { zoom manager . fit all , zoom manager . fit height , zoom manager . fit width } ; zitem = new zoom combo contribution item ( get page ( ) , zoom strings ) ; zitem . set zoom manager ( null ) ; zitem . set visible ( bool ) ; zoom in = new zoom in action2 ( ) ; zoom in . set enabled ( bool ) ; zoom out = new zoom out action2 ( ) ; zoom out . set enabled ( bool ) ; tool bar manager . add ( zitem ) ; tool bar manager . add ( zoom in ) ; tool bar manager . add ( zoom out ) ; }	Adds Zoom-related contributions.
private void determine dialect ( string back text ) { dialect = null ; boolean mvel = mvel dialect pattern . matcher ( back text ) . matches ( ) ; boolean java = java dialect pattern . matcher ( back text ) . matches ( ) ; if ( mvel ) { dialect = mvel dialect ; } else if ( java ) { dialect = java dialect ; } }	especially when parsing incomplete rules.
protected i new context ( i user context , i locator ) throws url { assert . is not null ( user context ) ; assert . is not null ( locator ) ; i context = dav factory . new context ( user context ) ; if ( locator . get label ( ) != null ) context . set label ( locator . get label ( ) ) ; return context ; }	Returns a new context that is based on the given context.
public void do save ( i monitor ) { file editor input input = ( file editor input ) get editor input ( ) ; file output file = input . get file ( ) . get location ( ) . to file ( ) ; save file ( monitor , output file , input ) ; }	for the sort field.
private void create table listeners ( ) {	Setup table listeners for GUI events.
public void put ( string url , object value ) throws url { assert . is not null ( url ) ; assert . is not null ( value ) ; put ( new url ( url ) , value ) ; }	Maps the given URL to the given value in this table.
private void put ( url url , object value ) { assert . is not null ( url ) ; assert . is not null ( value ) ;	Maps the specified URL to the given value in this table.
public node add token ( string token ) { node newnode = new node ( token ) ;	The method will create a new Node instance and try to add it asa child node.
public node add child ( node n ) { if ( ! this . children . contains key ( n . get token ( ) ) ) { this . children . put ( n . get token ( ) , n ) ; n . set parent ( this ) ; return n ; } else { return ( node ) this . children . get ( n . get token ( ) ) ; } }	The method will check to see if a Node with the same string tokenalready exists.
void set file ( i file , int offset , int length ) { this . file = file ; this . offset = offset ; this . length = length ; }	be used directly. Use DroolsModelBuilder instead.
public void add condition ( condition condition ) throws dav {	Add a Condition to this Precondition.
public void add state token condition ( string resource uri , string state token ) throws dav { condition condition = new condition ( resource uri ) ; condition term term = new condition term ( ) ; term . add condition factor ( new state token ( state token ) ) ; condition . add condition term ( term ) ; add condition ( condition ) ; }	Add a condition created from the given URI and state token.
public boolean matches ( condition condition ) { boolean match = bool ; enumeration conditions = get conditions ( ) ; while ( ! match && conditions . has more elements ( ) ) { condition existing condition = ( condition ) conditions . next element ( ) ; match = existing condition . matches ( condition ) ; } return match ; }	See if this Precondition contains a matching Condition.
public prop get prop ( ) throws malformed element exception { element prop = get first child ( root , str ) ;	Returns this propstat's prop.
public string get status ( ) throws malformed element exception { string status = get child text ( root , str , bool ) ;	Returns this propstat's status.
public prop set prop ( ) { element prop = set child ( root , str , child names , bool ) ;	Creates and sets a new prop on this propstat and returns an editor onit.
public string get last line ( string back text ) { buffered reader breader = new buffered reader ( new string reader ( back text ) ) ; string last = str ; string line = null ; try { while ( ( line = breader . read line ( ) ) != null ) {	because of how the backText works, we need to get the last line, so thatwe can pass it to the DSLUtility.
public string get last non dash line ( string back text ) { buffered reader breader = new buffered reader ( new string reader ( back text ) ) ; string last = str ; string line = null ; try { while ( ( line = breader . read line ( ) ) != null ) {	Returns the last line that doesn't start with a dash.
public static string bind ( string id , string binding ) { return bind ( id , new string [ ] { binding } ) ; }	Lookup the message with the given ID in this catalog and bind itssubstitution locations with the given string.
public static string bind ( string id , string binding1 , string binding2 ) { return bind ( id , new string [ ] { binding1 , binding2 } ) ; }	Lookup the message with the given ID in this catalog and bind itssubstitution locations with the given strings.
public static string bind ( string id , string [ ] bindings ) { if ( id == null ) return str ;	Lookup the message with the given ID in this catalog and bind itssubstitution locations with the given string values.
private void create process ( i project , i monitor , string example type ) throws core exception , io {	Create the sample process file.
private void create process sample j ( i project , string example type , i monitor ) throws java model exception , io { string s = str + example type + str ; i runtime = start page . get runtime ( ) ; if ( runtime . get version ( ) . get major ( ) == num ) { s += str ; } else { s += str ; } i folder = project . get project ( ) . get folder ( str ) ; i package fragment root = project . get package fragment root ( folder ) ; i package fragment = package fragment root . create package fragment ( str , bool , monitor ) ; input stream inputstream = get class ( ) . get class loader ( ) . get resource as stream ( s ) ; package fragment . create compilation unit ( str , new string ( file utils . read stream ( inputstream ) ) , bool , monitor ) ; }	Create the sample process junit test file.
@ override public string get runtime id ( ) { i store = org . kie . eclipse . activator . get default ( ) . get preference store ( ) ; string value = store . get string ( get kie version preference key ( ) ) ; return value ; }	Return the version number of the KIE Workbench that is installed on thegiven server.
public void visit rete ( final rete rete ) { this . root vertex = ( rete vertex ) this . visited nodes . get ( dot id ( rete ) ) ; if ( this . root vertex == null ) { this . root vertex = new rete vertex ( rete ) ; this . visited nodes . put ( dot id ( rete ) , this . root vertex ) ; } this . graph . add child ( this . root vertex ) ; this . parent vertex = this . root vertex ; for ( entry point node node : rete . get entry point nodes ( ) . values ( ) ) { visit ( node ) ; } }	Rete visits each of its ObjectTypeNodes.
private void visit node ( final object node ) { object real node = node ; if ( node instanceof object hash map . object entry ) { object hash map . object entry entry = ( object hash map . object entry ) node ; real node = entry . get value ( ) ; } visit ( real node ) ; }	Helper method to ensure nodes are not visited more than once.
private static string dot id ( final object object ) { return integer . to hex string ( system . identity hash code ( object ) ) . to upper case ( ) ; }	The identity hashCode for the given object is used as its unique DOTidentifier.
public prop add remove ( ) { element remove = append child ( root , str ) ;	Adds a remove to the given propertyupdate and returns an editor onits prop.
public prop add set ( ) { element set = append child ( root , str ) ;	Adds a set to the given propertyupdate and returns an editor on itsprop.
public i new locator ( string resource url , string label ) { return locator factory . new locator ( resource url , label ) ; }	Answer a new resource locator that identifies a particularserver resource by it's URL and label.
public i get presentation reconciler ( i source viewer ) { presentation reconciler reconciler = new presentation reconciler ( ) ;	Define reconciler - this has to be done for each partition.Currently there are 3 partitions, Inside rule, outside rule and inside comment.
public boolean same as ( object obj ) { if ( obj == null || ! ( obj instanceof status ) ) return bool ; status other = ( status ) obj ; if ( other . code != code || ! other . message . equals ( message ) ) return bool ; return other . extended status . equals ( extended status ) ; }	Answers whether the receiver and the argument are consideredidentical.
public boolean contains ( condition term term ) {	Does this Condition contain the given ConditionTerm?.
public static condition factor create ( stream tokenizer tokenizer ) throws dav { state token state token = new state token ( ) ; try { int token = tokenizer . ttype ; if ( token == str ) token = tokenizer . next token ( ) ; else throw new dav ( i . sc bad request , policy . bind ( str , string . value of ( token ) , str ) ) ;	Create a StateToken by parsing the given If header as defined bysection 9.4 in the WebDAV spec.
protected void add pages ( ) { try { text editor = new drl ( ) { public void close ( boolean save ) { super . close ( save ) ; drl . this . close ( save ) ; } protected void set part name ( string part name ) { super . set part name ( part name ) ; drl . this . set part name ( part name ) ; } } ; rete viewer = new rete viewer ( text editor ) ; int text = add page ( text editor , get editor input ( ) ) ; int rete = add page ( rete viewer , get editor input ( ) ) ; set page text ( text , str ) ; set page text ( rete , str ) ; text editor . get document provider ( ) . get document ( get editor input ( ) ) . add document listener ( new i ( ) { public void document about to be changed ( document event event ) { } public void document changed ( document event event ) { rete viewer . fire document changed ( ) ; } } ) ; } catch ( part init exception e ) { drools eclipse plugin . log ( e ) ; } }	Adds Text Editor for rules and Rete graph viewer.
protected string http delete ( string request ) throws io { string host = get kie rest ( ) ; url url = new url ( host + str + request ) ; activator . println ( str + url . to string ( ) ) ; url conn = ( url ) url . open connection ( ) ; conn . set request method ( str ) ; conn . set request property ( str , str ) ; set http credentials ( conn ) ; string response = new buffered reader ( new input stream reader ( ( conn . get input stream ( ) ) ) ) . read line ( ) ; activator . println ( str + response ) ; if ( conn . get response code ( ) != url . http accepted ) { throw new io ( str + conn . get response code ( ) ) ; } json object jo = json object . read from ( response ) ; string status = jo . get ( str ) . as string ( ) ; if ( status != null && ! status . is empty ( ) ) { if ( ! str . equals ( status ) ) throw new io ( str + status ) ; } string job id = jo . get ( str ) . as string ( ) ; if ( job id != null && ! job id . is empty ( ) ) return job id ; return response ; }	Send an HTTP DELETE request to the KIE console.
protected string http post ( string request , json object body ) throws io , runtime exception { string host = get kie rest ( ) ; url url = new url ( host + str + request ) ; activator . println ( str + url . to string ( ) + str + body ) ; url conn = ( url ) url . open connection ( ) ; conn . set do output ( body != null ) ; conn . set request method ( str ) ; conn . set request property ( str , str ) ; set http credentials ( conn ) ; if ( body != null ) { java . io . output stream os = conn . get output stream ( ) ; writer writer = new output stream writer ( os , str ) ; body . write to ( writer ) ; writer . close ( ) ; os . flush ( ) ; } string response = new buffered reader ( new input stream reader ( ( conn . get input stream ( ) ) ) ) . read line ( ) ; activator . println ( str + response ) ; if ( conn . get response code ( ) != url . http accepted ) { throw new io ( str + conn . get response code ( ) ) ; } json object jo = json object . read from ( response ) ; string status = jo . get ( str ) . as string ( ) ; if ( status != null && ! status . is empty ( ) ) { if ( ! str . equals ( status ) ) throw new io ( str + status ) ; } string job id = jo . get ( str ) . as string ( ) ; if ( job id != null && ! job id . is empty ( ) ) return job id ; return response ; }	Send an HTTP POST request to the KIE console.
public string get job status ( final string job id , final string title ) throws io , interrupted exception { final atomic reference < string > ar = new atomic reference < string > ( ) ; i wb = ui . get workbench ( ) ; i ps = wb . get progress service ( ) ; try { ps . busy cursor while ( new i ( ) { public void run ( i pm ) throws interrupted exception { pm . begin task ( str + job id + str + title , status request timeout ) ; pm . sub task ( title ) ; long start time = system . current time millis ( ) ; long stop time = start time ; do { try {	Sends a job status request to the KIE Server.
@ suppress warnings ( str ) public void execute ( i monitor ) { try { pull operation . execute ( monitor ) ; results . put all ( pull operation . get results ( ) ) ; } catch ( core exception e ) { if ( e . get status ( ) . get severity ( ) == i . cancel ) results . put all ( pull operation . get results ( ) ) ; else repo node . handle exception ( ( throwable ) e ) ; } }	Starts this operation synchronously.
private void handle pull results ( final map < repository , object > results map ) { if ( tasks to wait for . decrement and get ( ) == num && ! results . is empty ( ) ) show results ( ) ; }	Post-process the pull results, allowing the user to deal with uncommittedchanges and re-pull if the initial pull failed because of these changes.
public json array set ( int index , string value ) { values . set ( index , value of ( value ) ) ; return this ; }	Replaces the element at the specified position in this array with the JSON representation ofthe specified string.
public active lock add active lock ( ) { element activelock = add child ( root , str , child names , bool ) ;	Creates and adds a new activelock on this lockdiscovery and returnsan editor on it.
protected static void filter proposals on prefix ( string prefix , list < i > props ) { if ( prefix != null && prefix . trim ( ) . length ( ) > num ) { iterator < i > iterator = props . iterator ( ) ; string prefix lc = prefix . to lower case ( ) ; while ( iterator . has next ( ) ) { i item = iterator . next ( ) ; string content = item . get display string ( ) . to lower case ( ) ; if ( ! content . to lower case ( ) . starts with ( prefix lc ) ) { iterator . remove ( ) ; } } } }	Filter out the proposals whose content does not start with the given prefix.
protected string read backwards ( int document offset , i doc ) throws bad location exception { int start part = doc . get partition ( document offset ) . get offset ( ) ; string prefix = doc . get ( start part , document offset - start part ) ; return prefix ; }	Read some text from behind the cursor position.This provides context to both filter what is shown basedon what the user has typed in, and also to provide more information for thelist of suggestions based on context.
public static row list calculate rete rows ( base vertex root ) { row list row list = new row list ( ) ; row list . add ( num , root ) ; int cur row = num ; final set < base vertex > seen vertices = new hash set < base vertex > ( ) ; seen vertices . add ( root ) ; while ( cur row < row list . get depth ( ) ) { final list < base vertex > row vertices = row list . get ( cur row ) . get vertices ( ) ; for ( final iterator < base vertex > row node iter = row vertices . iterator ( ) ; row node iter . has next ( ) ; ) { final base vertex row node = row node iter . next ( ) ; final list < connection > edges = row node . get source connections ( ) ; for ( final iterator < connection > edge iter = edges . iterator ( ) ; edge iter . has next ( ) ; ) { final connection edge = edge iter . next ( ) ; final base vertex dest node = edge . get opposite ( row node ) ; if ( ! seen vertices . contains ( dest node ) ) { row list . add ( cur row + num , dest node ) ; seen vertices . add ( dest node ) ; } } seen vertices . add ( row node ) ; } ++ cur row ; } row list . optimize ( ) ; return row list ; }	Calculates layouting for provided graph.
private edit part get part for element ( object model element ) { if ( model element instanceof rete graph ) { return new diagram edit part ( ) ; } if ( model element instanceof base vertex ) { return new vertex edit part ( ) ; } if ( model element instanceof connection ) { return new connection edit part ( ) ; } drools eclipse plugin . log ( new exception ( str + ( ( model element != null ) ? model element . get class ( ) . get name ( ) : str ) ) ) ; return null ; }	Maps object to EditPart.
public static image descriptor get image descriptor ( string path ) { jbpm plugin = get default ( ) ; image registry reg = plugin . get image registry ( ) ; image descriptor des = reg . get descriptor ( path ) ; if ( des == null ) { des = ui . image descriptor from plugin ( str , path ) ; reg . put ( path , des ) ; } return des ; }	Returns an image descriptor for the image file at the givenplug-in relative path.Uses the plug ins image registry to "cache" it.
public final static void declare registry image ( string key , string path ) { image descriptor desc = image descriptor . get missing image descriptor ( ) ; try { desc = image descriptor . create from url ( make icon file url ( path ) ) ; } catch ( url e ) { drools eclipse plugin . log ( e ) ; } image registry . put ( key , desc ) ; }	Declare an Image in the registry table.
public void add ( final int depth , final base vertex vertex ) { if ( this . rows . size ( ) < ( depth + num ) ) { final int add rows = depth - this . rows . size ( ) + num ; for ( int i = num ; i < add rows ; ++ i ) { this . rows . add ( new row ( ( depth - add rows ) + i ) ) ; } } ( ( row ) this . rows . get ( depth ) ) . add ( vertex ) ; }	Adds new vertex to specified depth.
public int get row ( final base vertex vertex ) { final int num rows = this . rows . size ( ) ; for ( int i = num ; i < num rows ; ++ i ) { if ( ( ( row ) this . rows . get ( i ) ) . contains ( vertex ) ) { return i ; } } return - num ; }	Finds specified vertex from the rows.
public int get width ( ) { int width = num ; for ( final iterator < row > row iter = this . rows . iterator ( ) ; row iter . has next ( ) ; ) { final row row = row iter . next ( ) ; final int row width = row . get width ( ) ; if ( row width > width ) { width = row width ; } } return width ; }	Finds the longest row width.
public void dump ( ) { final int num rows = this . rows . size ( ) ; for ( int i = num ; i < num rows ; ++ i ) { system . err . println ( i + str + get ( i ) . get vertices ( ) ) ; } }	Dumps all row vertices to System.err.
public void optimize ( ) { final int num rows = this . rows . size ( ) ; for ( int i = num ; i < num rows ; ++ i ) { get ( i ) . optimize ( ) ; } }	Optimizes all rows for optimal presentation.
protected void initialize graphical viewer ( ) { zoom manager zoom manager = root edit part . get zoom manager ( ) ;	Loads Rete model and initializes zoom manager.
public void draw graph ( rete graph new graph ) { layer manager manager = ( layer manager ) get graphical viewer ( ) . get edit part registry ( ) . get ( layer manager . id ) ; connection layer conn layer = ( connection layer ) manager . get layer ( layer constants . connection layer ) ;	Draws graph.
public drools line breakpoint get drools breakpoint ( string source ) { if ( source == null ) { return null ; } iterator < i > iterator = get breakpoints ( ) . iterator ( ) ; while ( iterator . has next ( ) ) { i element = ( i ) iterator . next ( ) ; if ( element instanceof drools line breakpoint && ( ( drools line breakpoint ) element ) . get dialect name ( ) . equals ( str ) ) { drools line breakpoint l = ( drools line breakpoint ) element ; try { int match line = l . get line number ( ) ; string match source = l . get rule name ( ) ; if ( source . equals ( match source ) || l . get file rule mappings ( ) . contains key ( source ) ) { return l ; } } catch ( core exception e ) { log error ( e ) ; } } } return null ; }	Tries to find a match for the provided breakpoint information from the list of registered breakpoints.For stepping and possibly other purposes it returns also a breakpoint for cases where exactly the same line was not found.If breakpoint is not found for line at source then it takes the first line that is above thespecified line at the same file.
public void set href ( string href ) { assert . is not null ( href ) ; set child ( root , str , encode href ( href ) , child names , bool ) ;	Sets this baseline control elment description to the given href.
public boolean can talk dav ( ) throws dav { i response = null ; try {	Return a boolean value indicating whether or not the server for this resourceis DAV compliant.
public void copy ( i destination , string depth , boolean overwrite , collection property names ) throws dav {	Make a copy of this resource and place it at the location specifiedby the given destination locator.
protected void examine multi status response ( i response ) throws dav {	If the given response contains a multistatus body, the bodies status'are checked for errors.
protected url extract prop stats ( multi status multi status ) throws io , malformed element exception {	Helper method to extract the property status response froma multi status reponse, and populate a URLTable with theresults.
public response input stream get content ( ) throws dav { i response = null ; try { response = dav client . get ( locator , new context ( ) ) ; examine response ( response ) ; } catch ( io e ) { close response ( response ) ; throw new system exception ( e ) ; } return new response input stream ( response ) ; }	Return the content of this resource as an input stream.
public enumeration get locks ( ) throws dav { lock discovery lockdiscovery = null ; try { element element = get property ( dav lock discovery ) . get property ( ) ; lockdiscovery = new lock discovery ( element ) ; return lockdiscovery . get active locks ( ) ; } catch ( dav exception ) { if ( exception . get status code ( ) == i . sc not found ) return new empty enumeration ( ) ; throw exception ; } catch ( malformed element exception elem exception ) { throw new system exception ( elem exception ) ; } }	Return an Enumeration over ActiveLocks which lists the locks currentlyheld on this resource.
public property status get property ( qualified name property name ) throws dav { collection names = new hash set ( ) ; names . add ( property name ) ; url result = get properties ( names , i . depth zero ) ; url url = null ; try { url = new url ( locator . get resource url ( ) ) ; } catch ( url e ) { throw new system exception ( e ) ; } hashtable prop table = ( hashtable ) result . get ( url ) ; if ( prop table == null ) throw new dav ( policy . bind ( str , url . to external form ( ) ) ) ;	Return the property status for the property with the given name.
public i head ( ) throws dav { i response = null ; try { response = dav client . head ( locator , new context ( ) ) ; examine response ( response ) ; return response . get context ( ) ; } catch ( io exception ) { throw new system exception ( exception ) ; } finally { close response ( response ) ; } }	Return the header from a message send to the server.
public lock token lock ( boolean is shared , string depth , int timeout , string owner ) throws dav {	Lock this resource using the specified parameters.
public void move ( i destination , boolean overwrite , enumeration names ) throws dav { i context = new context ( ) ; context . set overwrite ( overwrite ) ; document document = new document ( ) ; property behavior property behavior = property behavior . create ( document ) ; if ( names == null ) { property behavior . set is keep all alive ( bool ) ; } else { while ( names . has more elements ( ) ) { object obj = names . next element ( ) ; assert . is true ( obj instanceof qualified name , policy . bind ( str ) ) ;	Move this resource to the location specified by the given locator.If a resource already exists at the destination and the overwriteboolean is true, then write over top of the existing resource.
protected i protected check in ( ) throws dav { i response = null ; try { response = dav client . checkin ( locator , new context ( ) , null ) ; examine response ( response ) ; string version url = response . get context ( ) . get location ( ) ; return dav client . get dav ( ) . new stable locator ( version url ) ; } catch ( io e ) { throw new system exception ( e ) ; } finally { close response ( response ) ; } }	Check in the receiver and answer a new Locator on theresulting version resource.
public void refresh lock ( lock token lock token , int timeout ) throws dav {	Refresh the lock on this resource with the given lock token.
public void remove properties ( collection property names ) throws dav { assert . is not null ( property names ) ;	Remove the properties with the given names, from this resource.
public void remove property ( qualified name property name ) throws dav { collection property names = new vector ( num ) ; property names . add ( property name ) ; remove properties ( property names ) ; }	Remove the property with the given name from this resource.
public void set content ( string content type , input stream input ) throws dav { i response = null ; try { i context = new context ( ) ; context . set content type ( content type ) ; response = dav client . put ( locator , context , input ) ; examine response ( response ) ; } catch ( io e ) { throw new system exception ( e ) ; } finally { close response ( response ) ; } }	Set the content of this resource to be the data stored in the giveninput stream.
public void set properties ( collection properties ) throws dav { assert . is not null ( properties ) ;	Set the given properties on this resource.
public void set property ( element property ) throws dav { collection properties = new vector ( num ) ; properties . add ( property ) ; set properties ( properties ) ; }	Set the given property on this resource.
public void unlock ( lock token token ) throws dav {	Unlock this resource with the given lock token.
public void update ( i version ) throws dav { document document = new document ( ) ; update . create version ( document , version . get resource url ( ) ) ; i response = null ; try { response = dav client . update ( locator , new context ( ) , document ) ; examine response ( response ) ; } catch ( io e ) { throw new system exception ( e ) ; } finally { close response ( response ) ; } }	Perform an UPDATE on the receiver to set the version itis based upon.
public void version control ( ) throws dav { i response = null ; try { response = dav client . version control ( locator , new context ( ) , null ) ; examine response ( response ) ; } catch ( io e ) { throw new system exception ( e ) ; } finally { close response ( response ) ; } }	Bring the receiver under version control.
public void delete ( boolean must exist ) throws dav { i response = null ; try { response = dav client . delete ( locator , new context ( ) ) ; if ( ! must exist && ( response . get status code ( ) == i . sc not found ) ) return ; examine response ( response ) ; examine multi status response ( response ) ; } catch ( io exception ) { throw new system exception ( exception ) ; } finally { close response ( response ) ; } }	Delete this resource from the repository, optionally succeedingin the delete if the resource was not found on the server.
protected void examine status code ( int code , string message ) throws dav { if ( code >= num && code <= num ) throw new redirection exception ( code , message ) ; if ( code >= num && code <= num ) throw new client exception ( code , message ) ; if ( code >= num && code <= num ) throw new server exception ( code , message ) ; }	Check the given status code and throw a WebDAVexception if the code indicates failure.
protected boolean property has child ( qualified name property name , qualified name child name ) throws dav {	This is a helper method to check to see if the resource has aproperty with the given name that in turn has a child with agiven name.
public void write ( output stream os ) throws io { if ( request body writer == null ) { if ( input read ) { is . reset ( ) ; input read = bool ; } super . write ( os ) ; } else { request body writer . write request body ( os ) ; } }	Writes this request's body to the given output stream.
public static string to hex ( byte [ ] arr ) { string buffer buf = new string buffer ( ) ; for ( int i = num ; i < arr . length ; ++ i ) { buf . append ( integer . to hex string ( ( arr [ i ] > > num ) & num ) ) ; buf . append ( integer . to hex string ( arr [ i ] & num ) ) ; } return buf . to string ( ) ; }	Converts the given byte array to its equivalent hexadecimal stringand returns the result.
public static string to hex ( int [ ] arr ) { string buffer buf = new string buffer ( ) ; for ( int i = num ; i < arr . length ; ++ i ) { buf . append ( integer . to hex string ( ( arr [ i ] > > num ) & num ) ) ; buf . append ( integer . to hex string ( ( arr [ i ] > > num ) & num ) ) ; buf . append ( integer . to hex string ( ( arr [ i ] > > num ) & num ) ) ; buf . append ( integer . to hex string ( ( arr [ i ] > > num ) & num ) ) ; buf . append ( integer . to hex string ( ( arr [ i ] > > num ) & num ) ) ; buf . append ( integer . to hex string ( ( arr [ i ] > > num ) & num ) ) ; buf . append ( integer . to hex string ( ( arr [ i ] > > num ) & num ) ) ; buf . append ( integer . to hex string ( ( arr [ i ] ) & num ) ) ; } return buf . to string ( ) ; }	Converts the given int array to its equivalent hexadecimal stringand returns the result.
public void set is all prop ( boolean is all prop ) { element child = get first child ( root , child names ) ; boolean is already all prop = is dav ( child , str ) ;	Sets whether this propfind is in the "all prop" form.
public void set is prop name ( boolean is prop name ) { element child = get first child ( root , child names ) ; boolean is already prop name = is dav ( child , str ) ;	Sets whether this propfind is in the "prop name" form.
public prop set prop ( ) { assert . is true ( get first child ( root , new string [ ] { str , str } ) == null ) ;	Creates and sets a new prop on this propfind and returns an editor onit.
public static string strip last word ( string prefix ) { if ( str . equals ( prefix ) ) { return prefix ; } if ( prefix . char at ( prefix . length ( ) - num ) == str ) { return str ; } else { char [ ] c = prefix . to char array ( ) ; int start = num ; for ( int i = c . length - num ; i >= num ; i -- ) { if ( character . is whitespace ( c [ i ] ) || c [ i ] == str || c [ i ] == str || c [ i ] == str || c [ i ] == str || c [ i ] == str || c [ i ] == str || c [ i ] == str || c [ i ] == str || c [ i ] == str ) { start = i + num ; break ; } } prefix = prefix . substring ( start , prefix . length ( ) ) ; return prefix ; } }	Looks behind, gets stuff after the white space.
public void update ( ) { tree viewer viewer = get tree viewer ( ) ; if ( viewer != null ) { control control = viewer . get control ( ) ; if ( control != null && ! control . is disposed ( ) ) { init rules ( ) ; populate package tree node ( ) ; viewer . refresh ( ) ; control . set redraw ( bool ) ; viewer . expand to level ( num ) ; control . set redraw ( bool ) ; } } }	Updates the outline page.
public void write ( output stream os ) throws io { assert . is true ( ! input read ) ; assert . is true ( ! has input stream ) ; int bytes read = num ; int total bytes read = num ; byte [ ] buffer = buffer pool . get buffer ( ) ; long content length = get content length ( ) ; try { while ( bytes read != - num && ( content length == - num || content length > total bytes read ) ) { if ( content length == - num ) { bytes read = is . read ( buffer ) ; } else { bytes read = is . read ( buffer , num , ( int ) math . min ( buffer . length , content length - total bytes read ) ) ; } if ( bytes read == - num ) { if ( content length >= num ) { throw new io ( policy . bind ( str ) ) ;	Writes this messages body to the given output stream.
public synchronized void step over ( ) throws debug exception {	I don't see the need for any of this custom stepOver stuff, why is it here?.
protected void mark parse errors ( list < drools build marker > markers , list < base knowledge builder result impl > parser errors ) { for ( iterator < base knowledge builder result impl > iter = parser errors . iterator ( ) ; iter . has next ( ) ; ) { object error = iter . next ( ) ; if ( error instanceof parser error ) { parser error err = ( parser error ) error ; markers . add ( new drools build marker ( err . get message ( ) , err . get row ( ) ) ) ; } else if ( error instanceof knowledge builder result ) { knowledge builder result res = ( knowledge builder result ) error ; int [ ] error lines = res . get lines ( ) ; markers . add ( new drools build marker ( res . get message ( ) , error lines != null && error lines . length > num ? error lines [ num ] : - num ) ) ; } else if ( error instanceof expander exception ) { expander exception exc = ( expander exception ) error ;	This will create markers for parse errors.
public void skip white space ( ) { while ( pos < s . length ( ) && character . is whitespace ( s . char at ( pos ) ) ) ++ pos ; }	Skips the next sequence of white space in s.
public static boolean add resource to guvnor ( string rep loc , string target loc , i selected file ) { boolean res = bool ; try { string full path = target loc + selected file . get name ( ) ; i client = web dav server cache . get web dav client ( rep loc ) ; if ( client == null ) { client = web dav client factory . create client ( new url ( rep loc ) ) ; web dav server cache . cache web dav client ( rep loc , client ) ; } try {	Adds a resource to Guvnor.
public static void commit file changes ( i selected file ) { try { guvnor metadata props props = guvnor metadata utils . get guvnor metadata ( selected file ) ; i client = web dav server cache . get web dav client ( props . get repository ( ) ) ; if ( client == null ) { client = web dav client factory . create client ( new url ( props . get repository ( ) ) ) ; web dav server cache . cache web dav client ( props . get repository ( ) , client ) ; } resource properties remote props = null ; try { remote props = client . query properties ( props . get fullpath ( ) ) ; } catch ( web dav exception wde ) { if ( wde . get error code ( ) != i . sc unauthorized ) {	Commits changes to Guvnor.
public int get age ( ) { string age string = get ( age ) ; return ( age string == null ) ? - num : integer . parse int ( age string ) ; }	Get the sender's estimate of the time since the response was generated.Return the int value for the AGE key.
public long get content length ( ) { string length string = get ( content length ) ; return ( length string == null ) ? - num : long . parse long ( length string ) ; }	Get the content length in bytes of the entity body.Return the value for the CONTENT_LENGTH key.Returns -1 if the Content-Length has not been set.
public int get max forwards ( ) { string s = get ( max forwards ) ; return s == null ? - num : integer . parse int ( s ) ; }	Return the integer value for the MAX_FORWARDS key.
public boolean get overwrite ( ) { string overwrite string = get ( overwrite ) ; return overwrite string == null ? bool : overwrite string . equals ignore case ( str ) ;	Get the flag that indicates if copy or move should overwritean existing destination.
public boolean get passthrough ( ) { string s = get ( passthrough ) ; return s == null ? bool : s . equals ignore case ( str ) ;	Return the boolean value for the PASSTHROUGH key.
public int get timeout ( ) { string timeout string = get ( timeout ) ; if ( timeout string == null ) return - num ; if ( timeout string . equals ignore case ( depth infinity ) ) return - num ; if ( timeout string . region matches ( bool , num , str , num , num ) )	Get the lock timeout value.
public void put ( string key , string value ) { context key ckey = new context key ( key ) ; if ( ( value == null ) || ( value . length ( ) == num ) ) properties . remove ( ckey ) ; else properties . put ( ckey , value ) ; }	Put the given key-value pair into the context.
public void set timeout ( int value ) { if ( value == - num ) put ( timeout , str ) ;	Set the lock timeout value in seconds.
protected buffered reader open dsl ( string filename ) { try { file reader reader = new file reader ( filename ) ; buffered reader breader = new buffered reader ( reader ) ; return breader ; } catch ( io e ) { e . print stack trace ( ) ; return null ; } }	method will create a BufferedReader to read the file.
protected void parse file ( buffered reader reader ) { string line = null ; try { while ( ( line = reader . read line ( ) ) != null ) { section section = get section ( line ) ; string nl = strip heading and code ( line ) ; string objname = this . get obj metadata ( nl ) ; nl = this . strip obj metadata ( nl ) ; add entry ( section , nl , objname ) ; } } catch ( io e ) { e . print stack trace ( ) ; } }	method will use the BufferedReader to read the contents of the file.It calls other methods to parse the line and build the tree.
protected string get obj metadata ( string text ) { if ( text . starts with ( str ) ) { return text . substring ( num , text . last index of ( str ) ) ; } else { return str ; } }	Method will return just the object metadata.
protected string strip obj metadata ( string text ) { if ( text . starts with ( str ) ) { return text . substring ( text . last index of ( str ) + num ) ; } else { return text ; } }	method will strip the metadata from the text string.
public void add tokens ( string [ ] tokens , node root node ) { node thenode = root node ; for ( int i = num ; i < tokens . length ; i ++ ) { node newnode = thenode . add token ( tokens [ i ] ) ; thenode = newnode ; } }	method adds the token to root.
public node [ ] get condition children ( string text ) { node thenode = this . root cond ; if ( text . length ( ) > num ) { string tokenizer tokenz = new string tokenizer ( text ) ; this . last = this . current ; while ( tokenz . has more tokens ( ) ) { string strtk = tokenz . next token ( ) ; node ch = thenode . get child ( strtk ) ;	the method will tokenize the text and try to findthe node that matches and return the children.
public node [ ] get children ( string obj , string text ) { node thenode = this . root cond . get child ( obj ) ; if ( thenode == null ) { for ( node child : this . root cond . get children ( ) ) { string token text = child . get token ( ) ; if ( token text != null ) { int index = token text . index of ( str ) ; if ( index != - num ) { string substring = token text . substring ( num , index ) ; if ( obj != null && obj . starts with ( substring ) ) { thenode = child ; } } } } } if ( thenode != null && text . length ( ) > num ) { string tokenizer tokenz = new string tokenizer ( text ) ; this . last = this . current ; while ( tokenz . has more tokens ( ) ) { string strtk = tokenz . next token ( ) ; node ch = thenode . get child ( strtk ) ;	the method expects the caller to pass the object.
public void add child to list ( node n , string prefix , array list < string > list ) { if ( n . get children ( ) . size ( ) > num ) { for ( node child : n . get children ( ) ) { if ( prefix != null && str . equals ( child . get token ( ) ) ) { if ( ! list . contains ( prefix ) ) { list . add ( prefix ) ; } return ; } string text = ( prefix == null ? str : prefix + str ) + child . get token ( ) ;	method will prepend the parent text to the child and generatethe possible combinations in text format.
public void print tree ( ) { system . out . println ( str ) ; for ( node n : root cond . get children ( ) ) { print node ( n ) ; } }	The method will print the DSLTree to System.out in text format.
protected void print node ( node n ) { print tabs ( n . get depth ( ) ) ; system . out . println ( str + n . get token ( ) + str ) ; for ( node c : n . get children ( ) ) { print node ( c ) ; } }	method will print the node and then iterate over the children.
protected void print tabs ( int count ) { for ( int idx = num ; idx < count ; idx ++ ) { system . out . print ( tab ) ; } }	Method will print n number of tabs.
public static json value read from ( string text ) { try { return new json parser ( text ) . parse ( ) ; } catch ( io exception ) {	Reads a JSON value from the given string.
public static image descriptor get image descriptor ( string id ) { image descriptor ret val = get default ( ) . get image registry ( ) . get descriptor ( id ) ; if ( ret val == null ) { ret val = load image descriptor ( id ) ; get default ( ) . get image registry ( ) . put ( id , ret val ) ; } return ret val ; }	Returns an image descriptor for the image file at the givenplug-in relative path.
public response invoke ( request request ) throws io { assert . is not null ( request ) ; try { open ( ) ; url resource url = request . get resource url ( ) ; url origin server url = new url ( resource url . get protocol ( ) , resource url . get host ( ) , resource url . get port ( ) , str ) ;	Sends the given request to the server and returns the server'sresponse.
public void set request header field ( string field name , string field value ) { assert . is not null ( field name ) ; assert . is not null ( field value ) ; end request ( ) ; request header . add field ( field name , field value ) ; }	Sets the request header value associated with the given field.
private void create rule sample launcher ( i project ) throws java model exception , io { version version = start page . get runtime ( ) . get version ( ) ; if ( version . get major ( ) == num ) { create project java file ( project , str , str ) ; } else if ( version . get major ( ) == num ) { create project java file ( project , str , str ) ; } else if ( version . get major ( ) >= num ) { create project java file ( project , str , str ) ; } }	Create the sample rule launcher file.
private void create rule ( i project , i monitor ) throws core exception { if ( start page . get runtime ( ) . get version ( ) . get major ( ) >= num ) { file utils . create folder ( project , str , monitor ) ; create project file ( project , monitor , str , str , str ) ; } else { create project file ( project , monitor , str , str , str ) ; } }	Create the sample rule file.
private void create rule flow ( i project , i monitor ) throws core exception { version version = start page . get runtime ( ) . get version ( ) ; if ( version . get major ( ) == num ) { create project file ( project , monitor , str , str , str ) ; create project file ( project , monitor , str , str , str ) ; create project file ( project , monitor , str , str , str ) ; } else if ( version . get major ( ) == num && version . get minor ( ) == num ) { create project file ( project , monitor , str , str , str ) ; } else if ( version . get major ( ) == num ) { create project file ( project , monitor , str , str , str ) ; } else { file utils . create folder ( project , str , monitor ) ; create project file ( project , monitor , str , str , str ) ; } }	Create the sample RuleFlow file.
private void create rule flow sample launcher ( i project ) throws java model exception , io { string s ; version version = start page . get runtime ( ) . get version ( ) ; if ( version . get major ( ) == num ) { s = str ; } else if ( version . get major ( ) == num && version . get minor ( ) == num ) { s = str ; } else if ( version . get major ( ) == num ) { s = str ; } else { s = str ; } create project java file ( project , s , str ) ; }	Create the sample RuleFlow launcher file.
public list < i > get selected i ( ) { list < i > result = new array list < i > ( ) ; for ( object o : get checked elements ( ) ) { if ( o instanceof iu ) { iu item = ( iu ) o ; if ( item . parent != null ) result . add ( item . iu ) ; } } return result ; }	Returns only the installable units that are features, ignoring feature groups.
public void create image ( output stream stream , int format ) { swt g = null ; gc gc = null ; image image = null ; layer manager layer manager = ( layer manager ) get graphical viewer ( ) . get edit part registry ( ) . get ( layer manager . id ) ; i figure = layer manager . get layer ( layer constants . printable layers ) ; rectangle r = figure . get bounds ( ) ; try { image = new image ( display . get default ( ) , r . width , r . height ) ; gc = new gc ( image ) ; g = new swt ( gc ) ; g . translate ( r . x * - num , r . y * - num ) ; figure . paint ( g ) ; image loader image loader = new image loader ( ) ; image loader . data = new image data [ ] { image . get image data ( ) } ; image loader . save ( stream , format ) ; } catch ( throwable t ) { drools eclipse plugin . log ( t ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( gc != null ) { gc . dispose ( ) ; } if ( image != null ) { image . dispose ( ) ; } } }	Writes the content of this editor to the given stream.Possible formats are for example SWT.IMAGE_BMP, IMAGE_GIF,IMAGE_JPEG, IMAGE_PNG.
public string get field name ( ) { alpha node field constraint constraint = this . node . get constraint ( ) ; if ( constraint instanceof mvel constraint ) { mvel constraint mvel constraint = ( mvel constraint ) constraint ; internal read accessor accessor = mvel constraint . get field extractor ( ) ; if ( accessor instanceof class field reader ) { return ( ( class field reader ) accessor ) . get field name ( ) ; } } return null ; }	Constraint has field extractor and this method is returning fieldNameit.
public string get evaluator ( ) { alpha node field constraint constraint = this . node . get constraint ( ) ; if ( constraint instanceof mvel constraint ) { mvel constraint mvel constraint = ( mvel constraint ) constraint ; return mvel constraint . to string ( ) ; } return null ; }	Constraint's evaluator string.
public string get value ( ) { alpha node field constraint constraint = this . node . get constraint ( ) ; if ( constraint instanceof mvel constraint ) { mvel constraint mvel constraint = ( mvel constraint ) constraint ; field value field = mvel constraint . get field ( ) ; return field != null ? field . to string ( ) : null ; } return null ; }	Constraint field string.
private void add guvnor resource properties ( resource properties props , string filename , string resource ) throws exception { if ( props == null ) { return ; } i response = null ; try { string path = resource . substring ( num , resource . last index of ( str ) ) ; string api ver = change to api ( path ) ; properties guv props = new properties ( ) ; response = get resource input stream ( api ver ) ; guv props . load ( response . get input stream ( ) ) ; string val = guv props . get property ( filename ) ; if ( val != null ) { string tokenizer tokens = new string tokenizer ( val , str ) ;	Adds Guvnor-specific resource properties to the collection.
public void baseline control ( i baseline ) throws dav { assert . is not null ( baseline ) ;	Create a new version-controlled configuration on the given baseline.
public void bind ( string member , i source ) throws dav { bind ( member , source , bool ) ; }	Binds the given member in this collection to the resource identifiedby the given source locator.
public i get member ( string member name ) { assert . is true ( locator . get label ( ) == null ) ; assert . is true ( ! locator . is stable ( ) ) ; string parent name = locator . get resource url ( ) ; string child name ; if ( parent name . ends with ( str ) )	Return the locator of the member of this collection, with the givenname.
public void optimize ( ) { final list < base vertex > sorted = new array list < base vertex > ( this . vertices ) ; collections . sort ( sorted , new comparator < base vertex > ( ) { public int compare ( final base vertex v1 , final base vertex v2 ) { int v1 out degree = v1 . get source connections ( ) . size ( ) ; int v2 out degree = v2 . get source connections ( ) . size ( ) ; if ( v1 out degree < v2 out degree ) { return num ; } if ( v1 out degree > v2 out degree ) { return - num ; } return num ; } } ) ; final linked list < base vertex > optimized = new linked list < base vertex > ( ) ; boolean front = bool ; for ( final iterator < base vertex > vertex iter = sorted . iterator ( ) ; vertex iter . has next ( ) ; ) { final base vertex vertex = vertex iter . next ( ) ; if ( front ) { optimized . add first ( vertex ) ; } else { optimized . add last ( vertex ) ; } front = ! front ; } this . vertices = optimized ; }	Optimizing vertices for optimal presentation.
private void initialize controls ( ) { if ( original file != null ) { resource group . set container full path ( original file . get parent ( ) . get full path ( ) ) ; string file name = original file . get name ( ) ; int index = file name . last index of ( str ) ; if ( index != - num ) { file name = file name . substring ( num , index ) ; } file name += str ; resource group . set resource ( file name ) ; } else if ( original name != null ) { resource group . set resource ( original name ) ; } set dialog complete ( validate page ( ) ) ; }	Initializes the controls of this dialog.
private boolean validate page ( ) { if ( ! resource group . are all values valid ( ) ) { if ( ! resource group . get resource ( ) . equals ( str ) ) {	Returns whether this page's visual components all contain valid values.
public static entity tag generate entity tag ( ) { string xx = basetime + str + integer . to hex string ( thread . current thread ( ) . hash code ( ) ) ;	Construct a unique EntityTag.
public base vertex get opposite ( base vertex vertex ) {	Gets opposite of specified vertex.Returning null if specified not does not belong into this connection.
private boolean validate otps ( list < string > otps , name callback name cb ) throws login exception { boolean validated = bool ; for ( string otp : otps ) { log . trace ( str , otp ) ; verification response ykr ; try { ykr = this . yc . verify ( otp ) ; } catch ( yubico verification exception e ) { log . warn ( str , e ) ; throw new login exception ( str + e . get message ( ) ) ; } catch ( yubico validation failure e ) { log . warn ( str , e ) ; throw new login exception ( str + e . get message ( ) ) ; } if ( ykr != null ) { log . trace ( str , otp , ykr . get status ( ) . to string ( ) ) ; if ( ykr . get status ( ) == response status . ok ) { string public id = yubico client . get public id ( otp ) ; log . info ( str , public id ) ; if ( is right user ( name cb . get name ( ) , public id ) ) { this . principals . add ( new yubikey principal ( public id , this . id realm ) ) ; validated = bool ; } } else { log . debug ( str , ykr . get status ( ) . to string ( ) ) ; } } } return validated ; }	Try to validate all the OTPs provided.
private boolean is right user ( string username , string public id ) { log . debug ( str , public id , username ) ; return this . ykmap . is right user ( username , public id ) ; }	After validation of an OTP, check that it came from a YubiKey that actuallybelongs to the user trying to authenticate.
private string get username for id ( string public id , string filename ) throws file not found exception { scanner sc = null ; file file = new file ( filename ) ; try { sc = new scanner ( file ) ; while ( sc . has next line ( ) ) { string line = sc . next line ( ) ; if ( line . starts with ( str + public id + str ) ) { string ykuser = line . split ( str ) [ num ] . trim ( ) ; return ykuser ; } } } finally { if ( sc != null ) { sc . close ( ) ; } } return null ; }	Given publicId "vvcccccfhc", scans filename for a line like "yk.vvcccccfhc.user = alice"and returns "alice" if found.
private void add yubikey to user ( string public id , string username , string filename ) { try { file file = new file ( filename ) ; file writer writer = new file writer ( file , bool ) ; writer . write ( str + public id + str + username + system . get property ( str ) ) ; writer . close ( ) ; } catch ( io ex ) { log . error ( str , filename , ex ) ; } }	Stores an association between username and YubiKey publicId in filename.
boolean verify otp ( string user name , string otp ) { try { string auth string = user name + str + otp ; string auth string enc = base64 . encode base64 url ( auth string . get bytes ( ) ) ; buffered reader in = attempt authentication ( auth string enc ) ; string input line ; while ( ( input line = in . read line ( ) ) != null ) { if ( input line . contains ( expected output ) ) { return bool ; } } } catch ( exception ex ) { log . error ( str , ex ) ; } return bool ; }	Access protectedUrl using userName and otp for basic auth.Check if what we get back contains expectedOutput.
public void clear password ( ) { for ( char pw [ ] : this . secrets ) { for ( int i = num ; i < pw . length ; i ++ ) { pw [ i ] = num ; } } this . secrets = new array list < char [ ] > ( ) ; }	Tries to clear all the passwords from memory.
public static string get public id ( string otp ) { if ( ( otp == null ) || ( otp . length ( ) < otp min len ) ) {	Extract the public ID of a YubiKey from an OTP it generated.
public static boolean is valid otp ( string otp ) { if ( otp == null ) { return bool ; } int len = otp . length ( ) ; for ( char c : otp . to char array ( ) ) { if ( c < num || c > num ) { return bool ; } } return otp min len <= len && len <= otp max len ; }	Determines whether a given OTP is of the correct lengthand only contains printable characters, as per the recommendation.
public evaluation create ( simple node node , object source ) { return create ( node , source , bool ) ; }	Returns an Evaluation that contains the node, source and whether itis a set operation.
public evaluation create ( simple node node , object source , boolean set operation ) {	Returns an Evaluation that contains the node, source and whether itis a set operation.
public static void clear cache ( ) { method parameter types cache . clear ( ) ; ctor parameter types cache . clear ( ) ; property descriptor cache . clear ( ) ; constructor cache . clear ( ) ; static method cache . clear ( ) ; instance method cache . clear ( ) ; invoke permission cache . clear ( ) ; field cache . clear ( ) ; superclasses . clear ( ) ; declared methods [ num ] . clear ( ) ; declared methods [ num ] . clear ( ) ; method access cache . clear ( ) ; method perm cache . clear ( ) ; }	Clears all of the cached reflection information normally usedto improve the speed of expressions that operate on the same classesor are executed multiple times.
public static boolean is jdk15 ( ) { if ( jdk checked ) return jdk15 ; try { class . for name ( str ) ; jdk15 = bool ; } catch ( exception e ) { } jdk checked = bool ; return jdk15 ; }	Checks if the current jvm is java language >= 1.5 compatible.
public static string get package name ( object o ) { return ( o == null ) ? null : get class package name ( o . get class ( ) ) ; }	Returns the package name of the object's class.
public static string get class package name ( class c ) { string s = c . get name ( ) ; int i = s . last index of ( str ) ; return ( i < num ) ? null : s . substring ( num , i ) ; }	Returns the package name of the class given.
public static string get unique descriptor ( object object , boolean fully qualified ) { string buffer result = new string buffer ( ) ; if ( object != null ) { if ( object instanceof proxy ) { class interface class = object . get class ( ) . get interfaces ( ) [ num ] ; result . append ( get class name ( interface class , fully qualified ) ) ; result . append ( str ) ; object = proxy . get invocation handler ( object ) ; } result . append ( get class name ( object , fully qualified ) ) ; result . append ( str ) ; result . append ( get pointer string ( object ) ) ; } else { result . append ( null object string ) ; } return new string ( result ) ; }	Returns a unique descriptor string that includes the object's class and a unique integeridentifier.
public static final class get arg class ( object arg ) { if ( arg == null ) return null ; class c = arg . get class ( ) ; if ( c == boolean . class ) return boolean . type ; else if ( c . get superclass ( ) == number . class ) { if ( c == integer . class ) return integer . type ; if ( c == double . class ) return double . type ; if ( c == byte . class ) return byte . type ; if ( c == long . class ) return long . type ; if ( c == float . class ) return float . type ; if ( c == short . class ) return short . type ; } else if ( c == character . class ) return character . type ; return c ; }	Gets the class for a method argument that is appropriate for looking up methods byreflection, by looking for the standard primitive wrapper classes and exchanging for themtheir underlying primitive class objects.
public static final boolean is more specific ( class [ ] classes1 , class [ ] classes2 ) { for ( int index = num , count = classes1 . length ; index < count ; ++ index ) { class c1 = classes1 [ index ] , c2 = classes2 [ index ] ; if ( c1 == c2 ) continue ; else if ( c1 . is primitive ( ) ) return bool ; else if ( c1 . is assignable from ( c2 ) ) return bool ; else if ( c2 . is assignable from ( c1 ) ) return bool ; }	Tells whether the first array of classes is more specific than the second.
public static final object get method value ( ognl context context , object target , string property name , boolean check access and existence ) throws ognl exception , illegal access exception , no such method exception , introspection exception { object result = null ; method m = get get method ( context , ( target == null ) ? null : target . get class ( ) , property name ) ; if ( m == null ) m = get read method ( ( target == null ) ? null : target . get class ( ) , property name , null ) ; if ( check access and existence ) { if ( ( m == null ) || ! context . get member access ( ) . is accessible ( context , target , m , property name ) ) { result = not found ; } } if ( result == null ) { if ( m != null ) { try { result = invoke method ( target , m , no arguments ) ; } catch ( invocation target exception ex ) { throw new ognl exception ( property name , ex . get target exception ( ) ) ; } } else { throw new no such method exception ( property name ) ; } } return result ; }	If the checkAccessAndExistence flag is true this method will check to see if the methodexists and if it is accessible according to the context's MemberAccess.
public static map get property descriptors ( class target class ) throws introspection exception , ognl exception { map result ; if ( ( result = ( map ) property descriptor cache . get ( target class ) ) == null ) { synchronized ( property descriptor cache ) { if ( ( result = ( map ) property descriptor cache . get ( target class ) ) == null ) { property descriptor [ ] pda = introspector . get bean info ( target class ) . get property descriptors ( ) ; result = new hash map ( num ) ; for ( int i = num , icount = pda . length ; i < icount ; i ++ ) {	This method returns the property descriptors for the given class as a Map.
public static property descriptor get property descriptor from array ( class target class , string name ) throws introspection exception { property descriptor result = null ; property descriptor [ ] pda = get property descriptors array ( target class ) ; for ( int i = num , icount = pda . length ; ( result == null ) && ( i < icount ) ; i ++ ) { if ( pda [ i ] . get name ( ) . compare to ( name ) == num ) { result = pda [ i ] ; } } return result ; }	Gets the property descriptor with the given name for the target class given.
public static method get read method ( class target , string name ) { return get read method ( target , name , null ) ; }	Finds the best possible match for a method on the specified target class with a matchingname.
public char read char ( ) throws java . io . io { if ( in buf > num ) { -- in buf ; if ( ++ bufpos == bufsize ) bufpos = num ; return buffer [ bufpos ] ; } char c ; if ( ++ bufpos == available ) adjust buff size ( ) ; if ( ( buffer [ bufpos ] = c = read byte ( ) ) == str ) { update line column ( c ) ; int back slash cnt = num ; for ( ; ; )	Read a character.
final public void projection ( ) throws parse exception { ast jjtn000 = new ast ( jjtproject ) ; boolean jjtc000 = bool ; jjtree . open node scope ( jjtn000 ) ; try { jj consume token ( num ) ; expression ( ) ; jj consume token ( num ) ; } catch ( throwable jjte000 ) { if ( jjtc000 ) { jjtree . clear node scope ( jjtn000 ) ; jjtc000 = bool ; } else { jjtree . pop node ( ) ; } if ( jjte000 instanceof runtime exception ) { { if ( bool ) throw ( runtime exception ) jjte000 ; } } if ( jjte000 instanceof parse exception ) { { if ( bool ) throw ( parse exception ) jjte000 ; } } { if ( bool ) throw ( error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . close node scope ( jjtn000 , bool ) ; } } }	Apply an expression to all elements of a collection, creating a new collectionas the result.
final public void select all ( ) throws parse exception { ast jjtn000 = new ast ( jjtselect ) ; boolean jjtc000 = bool ; jjtree . open node scope ( jjtn000 ) ; try { jj consume token ( num ) ; jj consume token ( num ) ; expression ( ) ; jj consume token ( num ) ; } catch ( throwable jjte000 ) { if ( jjtc000 ) { jjtree . clear node scope ( jjtn000 ) ; jjtc000 = bool ; } else { jjtree . pop node ( ) ; } if ( jjte000 instanceof runtime exception ) { { if ( bool ) throw ( runtime exception ) jjte000 ; } } if ( jjte000 instanceof parse exception ) { { if ( bool ) throw ( parse exception ) jjte000 ; } } { if ( bool ) throw ( error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . close node scope ( jjtn000 , bool ) ; } } }	Apply a boolean expression to all elements of a collection, creating a new collectioncontaining those elements for which the expression returned true.
public static long long value ( object value ) throws number format exception { if ( value == null ) return num ; class c = value . get class ( ) ; if ( c . get superclass ( ) == number . class ) return ( ( number ) value ) . long value ( ) ; if ( c == boolean . class ) return ( ( boolean ) value ) . boolean value ( ) ? num : num ; if ( c == character . class ) return ( ( character ) value ) . char value ( ) ; return long . parse long ( string value ( value , bool ) ) ; }	Evaluates the given object as a long integer.
public static double double value ( object value ) throws number format exception { if ( value == null ) return num ; class c = value . get class ( ) ; if ( c . get superclass ( ) == number . class ) return ( ( number ) value ) . double value ( ) ; if ( c == boolean . class ) return ( ( boolean ) value ) . boolean value ( ) ? num : num ; if ( c == character . class ) return ( ( character ) value ) . char value ( ) ; string s = string value ( value , bool ) ; return ( s . length ( ) == num ) ? num : double . parse double ( s ) ; }	Evaluates the given object as a double-precision floating-point number.
public static big integer big int value ( object value ) throws number format exception { if ( value == null ) return big integer . value of ( num ) ; class c = value . get class ( ) ; if ( c == big integer . class ) return ( big integer ) value ; if ( c == big decimal . class ) return ( ( big decimal ) value ) . to big integer ( ) ; if ( c . get superclass ( ) == number . class ) return big integer . value of ( ( ( number ) value ) . long value ( ) ) ; if ( c == boolean . class ) return big integer . value of ( ( ( boolean ) value ) . boolean value ( ) ? num : num ) ; if ( c == character . class ) return big integer . value of ( ( ( character ) value ) . char value ( ) ) ; return new big integer ( string value ( value , bool ) ) ; }	Evaluates the given object as a BigInteger.
public static big decimal big dec value ( object value ) throws number format exception { if ( value == null ) return big decimal . value of ( num ) ; class c = value . get class ( ) ; if ( c == big decimal . class ) return ( big decimal ) value ; if ( c == big integer . class ) return new big decimal ( ( big integer ) value ) ; if ( c == boolean . class ) return big decimal . value of ( ( ( boolean ) value ) . boolean value ( ) ? num : num ) ; if ( c == character . class ) return big decimal . value of ( ( ( character ) value ) . char value ( ) ) ; return new big decimal ( string value ( value , bool ) ) ; }	Evaluates the given object as a BigDecimal.
public static string string value ( object value , boolean trim ) { string result ; if ( value == null ) { result = ognl runtime . null string ; } else { result = value . to string ( ) ; if ( trim ) { result = result . trim ( ) ; } } return result ; }	Evaluates the given object as a String and trims it if the trim flag is true.
public static int get numeric type ( object value ) { if ( value != null ) { class c = value . get class ( ) ; if ( c == integer . class ) return int ; if ( c == double . class ) return double ; if ( c == boolean . class ) return bool ; if ( c == byte . class ) return byte ; if ( c == character . class ) return char ; if ( c == short . class ) return short ; if ( c == long . class ) return long ; if ( c == float . class ) return float ; if ( c == big integer . class ) return bigint ; if ( c == big decimal . class ) return bigdec ; } return nonnumeric ; }	Returns a constant from the NumericTypes interface that represents the numeric type of thegiven object.
public static object convert value ( object value , class to type ) { return convert value ( value , to type , bool ) ; }	Returns the value converted numerically to the given class type This method also detects whenarrays are being converted and converts the components of one array to the type of the other.
public static int get int value ( object value ) { try { if ( value == null ) return - num ; if ( number . class . is instance ( value ) ) { return ( ( number ) value ) . int value ( ) ; } string str = string . class . is instance ( value ) ? ( string ) value : value . to string ( ) ; return integer . parse int ( str ) ; } catch ( throwable t ) { throw new runtime exception ( str + value + str , t ) ; } }	Converts the specified value to a primitive integer value.
public static int get numeric type ( int t1 , int t2 , boolean can be non numeric ) { if ( t1 == t2 ) return t1 ; if ( can be non numeric && ( t1 == nonnumeric || t2 == nonnumeric || t1 == char || t2 == char ) ) return nonnumeric ; if ( t1 == nonnumeric ) t1 = double ;	Returns the constant from the NumericTypes interface that best expresses the type of anoperation, which can be either numeric or not, on the two given types.
public static int get numeric type ( object v1 , object v2 , boolean can be non numeric ) { return get numeric type ( get numeric type ( v1 ) , get numeric type ( v2 ) , can be non numeric ) ; }	Returns the constant from the NumericTypes interface that best expresses the type of anoperation, which can be either numeric or not, on the two given objects.
public static number new integer ( int type , long value ) { switch ( type ) { case bool : case char : case int : return new integer ( ( int ) value ) ; case float : if ( ( long ) ( float ) value == value ) { return new float ( ( float ) value ) ; }	Returns a new Number object of an appropriate type to hold the given integer value.
public evaluation pop evaluation ( ) { evaluation result ; result = current evaluation ; set current evaluation ( result . get parent ( ) ) ; if ( current evaluation == null ) { set last evaluation ( get keep last evaluation ( ) ? result : null ) ; set root evaluation ( null ) ; set current node ( null ) ; } return result ; }	Pops the current Evaluation off of the top of the stack.
protected string generate ognl getter ( ct class clazz , ct method value getter , ct field node ) throws exception { string body = str + node . get name ( ) + str ; value getter . set body ( body ) ; clazz . add method ( value getter ) ; return body ; }	Fail safe getter creation when normal compilation fails.
protected string generate ognl setter ( ct class clazz , ct method value setter , ct field node ) throws exception { string body = node . get name ( ) + str ; value setter . set body ( body ) ; clazz . add method ( value setter ) ; return body ; }	Fail safe setter creation when normal compilation fails.
protected void flatten tree ( ) { boolean should flatten = bool ; int new size = num ; for ( int i = num ; i < children . length ; ++ i ) if ( children [ i ] . get class ( ) == get class ( ) ) { should flatten = bool ; new size += children [ i ] . jjt get num children ( ) ; } else ++ new size ; if ( should flatten ) { node [ ] new children = new node [ new size ] ; int j = num ; for ( int i = num ; i < children . length ; ++ i ) { node c = children [ i ] ; if ( c . get class ( ) == get class ( ) ) { for ( int k = num ; k < c . jjt get num children ( ) ; ++ k ) new children [ j ++ ] = c . jjt get child ( k ) ; } else new children [ j ++ ] = c ; } if ( j != new size ) throw new error ( str + j + str + new size ) ; children = new children ; } }	This method may be called from subclasses' jjtClose methods.
public void init ( simple node node , object source , boolean set operation ) { this . node = node ; this . source = source ; this . set operation = set operation ; result = null ; exception = null ; parent = null ; next = null ; previous = null ; first child = null ; last child = null ; }	Reinitializes this Evaluation to the parameters specified.
private char escape char ( ) { int ofs = image . length ( ) - num ; switch ( image . char at ( ofs ) ) { case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; }	Converts an escape sequence into a character value.
public static void set root ( map context , object root ) { context . put ( ognl context . root context key , root ) ; }	Sets the root object to use for all expressions in the given context - doesn't necessarily replaceroot object instances explicitly passed in to other expression resolving methods on this class.
public static object get value ( string expression , map context , object root ) throws ognl exception { return get value ( expression , context , root , null ) ; }	Evaluates the given OGNL expression to extract a value from the given root object in a givencontext.
public static void set value ( expression accessor expression , ognl context context , object root , object value ) { expression . set ( context , root , value ) ; }	Sets the value given using the pre-compiled expression on the specified rootobject.
public static void set value ( object tree , object root , object value ) throws ognl exception { set value ( tree , create default context ( root ) , root , value ) ; }	Evaluates the given OGNL expression tree to insert a value into the object graph rooted atthe given root object.
public static boolean is constant ( string expression , map context ) throws ognl exception { return is constant ( parse expression ( expression ) , context ) ; }	Checks if the specified expression represents a constant expression.
public static string get default watch service id ( ) { string result = str ; string os name = system . get property ( str ) ; if ( os name != null ) { os name = os name . to lower case ( locale . english ) ; if ( os name . contains ( str ) || os name . contains ( str ) ) { result = is at least java7 ( ) ? str : str ; } else if ( os name . contains ( str ) ) { result = str ; } } return result ; }	Returns default watch service identifier based on operating system.
@ override public synchronized object reload ( ) { object result = null ; try { boolean reload required = build link . build ( ) ; if ( reload required ) { int version = ++ class loader version ; string name = str + version + str ; current application class loader = new delegated resources class loader ( name , to urls ( output directories ) , base loader ) ; result = current application class loader ; } } catch ( url e ) { throw new unexpected exception ( str , e ) ;	Contrary to its name, this doesn't necessarily reload the app.
protected archiver get archiver ( string archiver name ) throws no such archiver exception { archiver result = archiver manager . get archiver ( archiver name ) ; result . set duplicate behavior ( archiver . duplicates fail ) ;	Returns preconfigured archiver.
protected void check archiver for problems ( archiver archiver ) { for ( resource iterator iter = archiver . get resources ( ) ; iter . has next ( ) ; ) { iter . next ( ) ; } }	Check for potential "Duplicate file" exception before archive processing starts.
protected string read file as string ( file file ) throws io { file input stream is = new file input stream ( file ) ; try { byte [ ] buffer = new byte [ num ] ; int len = is . read ( buffer ) ; byte array output stream out = new byte array output stream ( ) ; while ( len != - num ) { out . write ( buffer , num , len ) ; len = is . read ( buffer ) ; } return charset name != null ? new string ( out . to byte array ( ) , charset name ) : new string ( out . to byte array ( ) ) ; } finally { is . close ( ) ; } }	Reads the content of the file to a string.
protected project create project ( ) { final project ant project = new project ( ) ; final project helper helper = project helper . get project helper ( ) ; ant project . add reference ( project helper . projecthelper reference , helper ) ; helper . get import stack ( ) . add element ( str ) ;	Creates and configures Ant project for Java task.
protected void add system property ( java java , string property name , string property value ) { environment . variable sys prop play home = new environment . variable ( ) ; sys prop play home . set key ( property name ) ; sys prop play home . set value ( property value ) ; java . add sysproperty ( sys prop play home ) ; }	Adds string type system property to Ant Java task.
protected void add system property ( java java , string property name , file property value ) { environment . variable sys prop play home = new environment . variable ( ) ; sys prop play home . set key ( property name ) ; sys prop play home . set file ( property value ) ; java . add sysproperty ( sys prop play home ) ; }	Adds file type system property to Ant Java task.
private void change directory ( final file dir ) { if ( dir == null ) { debug ( str ) ; } else if ( ! dir . is directory ( ) ) { debug ( str ) ; } else { final file [ ] contents = dir . list files ( ) ; if ( contents != null ) { int num directories = num ; for ( final file f : contents ) { if ( f . is directory ( ) ) { num directories ++ ; } } m files in dir = new file [ num directories ] ; m filenames . clear ( ) ; for ( int i = num , counter = num ; i < num directories ; counter ++ ) { if ( contents [ counter ] . is directory ( ) ) { m files in dir [ i ] = contents [ counter ] ; m filenames . add ( contents [ counter ] . get name ( ) ) ; i ++ ; } } arrays . sort ( m files in dir ) ; collections . sort ( m filenames ) ; m selected dir = dir ; m txtv selected folder . set text ( dir . get absolute path ( ) ) ; m list directories adapter . notify data set changed ( ) ; m file observer = create file observer ( dir . get absolute path ( ) ) ; m file observer . start watching ( ) ; debug ( str , dir . get absolute path ( ) ) ; } else { debug ( str ) ; } } refresh button state ( ) ; }	Change the directory that is currently being displayed.
private void refresh button state ( ) { final activity activity = get activity ( ) ; if ( activity != null && m selected dir != null ) { m btn confirm . set enabled ( is valid file ( m selected dir ) ) ; get activity ( ) . invalidate options menu ( ) ; } }	Changes the state of the buttons depending on the currently selected fileor folder.
private file observer create file observer ( final string path ) { return new file observer ( path , file observer . create | file observer . delete | file observer . moved from | file observer . moved to ) { @ override public void on event ( final int event , final string path ) { debug ( str , event ) ; final activity activity = get activity ( ) ; if ( activity != null ) { activity . run on ui thread ( new runnable ( ) { @ override public void run ( ) { refresh directory ( ) ; } } ) ; } } } ; }	Sets up a FileObserver to watch the current directory.
private void return selected folder ( ) { if ( m selected dir != null ) { debug ( str , m selected dir . get absolute path ( ) ) ; m listener . foreach ( new unit function < on fragment interaction listener > ( ) { @ override public void apply ( final on fragment interaction listener f ) { f . on select directory ( m selected dir . get absolute path ( ) ) ; } } ) ; } else { m listener . foreach ( new unit function < on fragment interaction listener > ( ) { @ override public void apply ( final on fragment interaction listener f ) { f . on cancel chooser ( ) ; } } ) ; } }	Returns the selected folder as a result to the activity the fragment's attached to.
private int create folder ( ) { if ( m new directory name != null && m selected dir != null && m selected dir . can write ( ) ) { final file new dir = new file ( m selected dir , m new directory name ) ; if ( new dir . exists ( ) ) { return r . string . create folder error already exists ; } else { final boolean result = new dir . mkdir ( ) ; if ( result ) { return r . string . create folder success ; } else { return r . string . create folder error ; } } } else if ( m selected dir != null && ! m selected dir . can write ( ) ) { return r . string . create folder error no write access ; } else { return r . string . create folder error ; } }	Creates a new folder in the current directory with the nameCREATE_DIRECTORY_NAME.
private boolean is valid file ( final file file ) { return ( file != null && file . is directory ( ) && file . can read ( ) && ( m config . allow read only directory ( ) || file . can write ( ) ) ) ; }	Returns true if the selected file or directory would be valid selection.
public void start background job ( int msg id , runnable runnable ) {	Start a background job showing a progress bar as long as the job runs.This seems contradictory but with background job we mean one that runs offthe ui thread to prevent an ANR.We still have to wait for the processing to be done because we need the result.
private void start list ( boolean is ordered list , attributes attributes ) { boolean is indentation = is indentation ( attributes ) ; paragraph type new type = is indentation && is ordered list ? paragraph type . indentation ol : is indentation && ! is ordered list ? paragraph type . indentation ul : is ordered list ? paragraph type . numbering : paragraph type . bullet ; accumulated paragraph style current style = m paragraph styles . is empty ( ) ? null : m paragraph styles . peek ( ) ; if ( current style == null ) {	Handles OL and UL start tags.
private void end list ( boolean ordered list ) { if ( ! m paragraph styles . is empty ( ) ) { accumulated paragraph style style = m paragraph styles . peek ( ) ; paragraph type type = style . get type ( ) ; if ( ( ordered list && ( type . is numbering ( ) || type == paragraph type . indentation ol ) ) || ( ! ordered list && ( type . is bullet ( ) || type == paragraph type . indentation ul ) ) ) {	Handles OL and UL end tags.
void handle motion ( int edge , float dx , float dy ) { rect r = compute layout ( ) ; if ( edge == grow none ) { return ; } else if ( edge == move ) {	The "edge" parameter specifies which edges the user is dragging.
public rect get crop rect ( ) { return new rect ( ( int ) m crop rect . left , ( int ) m crop rect . top , ( int ) m crop rect . right , ( int ) m crop rect . bottom ) ; }	Returns the cropping rectangle in image space.
private rect compute layout ( ) { f r = new f ( m crop rect . left , m crop rect . top , m crop rect . right , m crop rect . bottom ) ; m matrix . map rect ( r ) ; return new rect ( math . round ( r . left ) , math . round ( r . top ) , math . round ( r . right ) , math . round ( r . bottom ) ) ; }	Maps the cropping rectangle from image space to screen space.
void register ( rt listener , rt < rt , rt , rt > media factory ) { m listener = listener ; m media factory = media factory ; }	This needs to be called before anything else because we need the mediafactory.
private void add span watcher ( ) { spannable spannable = get text ( ) ; if ( spannable . get spans ( num , spannable . length ( ) , get class ( ) ) != null ) { spannable . set span ( this , num , spannable . length ( ) , spanned . span inclusive inclusive ) ; } }	Add a SpanWatcher for the Changeable implementation.
@ suppress lint ( str ) @ override public final view get view ( int position , view convert view , view group parent ) { view spinner view = m inflater . inflate ( m spinner id , parent , bool ) ; m parent = parent ; text view spinner title view = ( text view ) spinner view . find view by id ( r . id . title ) ; update spinner title ( spinner title view ) ; return spinner view ; }	This method returns the spinner view.
@ suppress lint ( str ) @ override public view get drop down view ( int position , view convert view , view group parent ) { spinner item spinner item = m items . get ( position ) ; spinner item . set on changed listener ( this , position ) ;	Returns the spinner entry view.
public rt < rt , rt , rt > convert ( final spanned text , rt . html rt format ) { m text = text ; m rt = rt format ; m out = new string builder ( ) ; m images = new array list < > ( ) ; m paragraph styles . clear ( ) ;	Converts a spanned text to HTML.
private void within paragraph ( final spanned text , int start , int end ) {	Convert a spanned text within a paragraph.
public static file create unique file ( file target folder , string original file , boolean keep original ) { string mime type = mime type map . get singleton ( ) . get mime type from extension ( original file ) ; return create unique file ( target folder , original file , mime type , keep original ) ; }	Creates a file with a non-conflicting file name in a specified folder based on an existing file name.
public static string determine original file ( context context , uri uri ) throws illegal argument exception { string original file = null ; if ( uri != null ) {	Retrieve local file path for an arbitrary Uri.
public string namespace ( string name , boolean attribute ) { int colon = name . index of ( str ) ; if ( colon == - num ) { return attribute ? str : the schema . get uri ( ) ; } string prefix = name . substring ( num , colon ) ; if ( prefix . equals ( str ) ) { return str ; } else { return ( str + prefix ) . intern ( ) ; } }	Return a namespace name from a Qname.
public string local name ( string name ) { int colon = name . index of ( str ) ; if ( colon == - num ) { return name ; } else { return name . substring ( colon + num ) . intern ( ) ; } }	Return a local name from a Qname.
public void set attribute ( attributes impl atts , string name , string type , string value ) { if ( name . equals ( str ) || name . starts with ( str ) ) { return ; } ; string namespace = namespace ( name , bool ) ; string local name = local name ( name ) ; int i = atts . get index ( name ) ; if ( i == - num ) { name = name . intern ( ) ; if ( type == null ) type = str ; if ( ! type . equals ( str ) ) value = normalize ( value ) ; atts . add attribute ( namespace , local name , name , type , value ) ; } else { if ( type == null ) type = atts . get type ( i ) ; if ( ! type . equals ( str ) ) value = normalize ( value ) ; atts . set attribute ( i , namespace , local name , name , type , value ) ; } }	Sets an attribute and its value into an AttributesImpl object.
public void set attribute ( string name , string type , string value ) { set attribute ( the atts , name , type , value ) ; }	Sets an attribute and its value into this element type.
static string get font name ( string file path ) { ttf in = null ; try { random access file file = new random access file ( file path , str ) ; in = new ttf ( file ) ; return get ttf ( in , file path ) ; } catch ( io e ) { return null ;	Retrieve the file name for a system font.
static string get font name ( asset manager assets , string file path ) { ttf in = null ; try { input stream file = assets . open ( file path , asset manager . access random ) ; in = new ttf ( file ) ; return get ttf ( in , file path ) ; } catch ( file not found exception e ) { return null ;	Retrieve the file name for a font in the asset folder.
private void need new buffer ( int newcount ) { if ( current buffer index < buffers . size ( ) - num ) {	Makes a new buffer available either by allocatinga new one or re-cycling an existing one.
@ override public void write ( byte [ ] b , int off , int len ) { if ( ( off < num ) || ( off > b . length ) || ( len < num ) || ( ( off + len ) > b . length ) || ( ( off + len ) < num ) ) { throw new index out of bounds exception ( ) ; } else if ( len == num ) { return ; } synchronized ( this ) { int newcount = count + len ; int remaining = len ; int in buffer pos = count - filled buffer sum ; while ( remaining > num ) { int part = math . min ( remaining , current buffer . length - in buffer pos ) ; system . arraycopy ( b , off + len - remaining , current buffer , in buffer pos , part ) ; remaining -= part ; if ( remaining > num ) { need new buffer ( newcount ) ; in buffer pos = num ; } } count = newcount ; } }	Write the bytes to byte array.
@ override public synchronized void write ( int b ) { int in buffer pos = count - filled buffer sum ; if ( in buffer pos == current buffer . length ) { need new buffer ( count + num ) ; in buffer pos = num ; } current buffer [ in buffer pos ] = ( byte ) b ; count ++ ; }	Write a byte to byte array.
public synchronized int write ( input stream in ) throws io { int read count = num ; int in buffer pos = count - filled buffer sum ; int n = in . read ( current buffer , in buffer pos , current buffer . length - in buffer pos ) ; while ( n != - num ) { read count += n ; in buffer pos += n ; count += n ; if ( in buffer pos == current buffer . length ) { need new buffer ( current buffer . length ) ; in buffer pos = num ; } n = in . read ( current buffer , in buffer pos , current buffer . length - in buffer pos ) ; } return read count ; }	Writes the entire contents of the specified input stream to thisbyte stream.
public synchronized void write to ( output stream out ) throws io { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; out . write ( buf , num , c ) ; remaining -= c ; if ( remaining == num ) { break ; } } }	Writes the entire contents of this byte stream to thespecified output stream.
public synchronized byte [ ] to byte array ( ) { int remaining = count ; if ( remaining == num ) { return empty byte array ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = num ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; system . arraycopy ( buf , num , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == num ) { break ; } } return newbuf ; }	Gets the curent contents of this byte stream as a byte array.The result is independent of this stream.
@ override public void set font size ( int size ) { if ( m font size != null ) { if ( size <= num ) { m font size adapter . update spinner title ( str ) ; m font size adapter . set selected item ( num ) ; m font size . set selection ( num ) ; } else { size = helper . convert sp to px ( size ) ; m font size adapter . update spinner title ( integer . to string ( size ) ) ; for ( int pos = num ; pos < m font size adapter . get count ( ) ; pos ++ ) { font size spinner item item = m font size adapter . get item ( pos ) ; if ( size == item . get font size ( ) ) { m font size adapter . set selected item ( pos ) ; m font size . set selection ( pos ) ; break ; } } } } }	Set the text size.
public static string separators to unix ( string path ) { if ( path == null || path . index of ( windows separator ) == - num ) { return path ; } return path . replace ( windows separator , unix separator ) ; }	Converts all separators to the Unix separator of forward slash.
private void recompute focus ( motion event event ) { for ( int i = num ; i < m highlight views . size ( ) ; i ++ ) { highlight view hv = m highlight views . get ( i ) ; hv . set focus ( bool ) ; hv . invalidate ( ) ; } for ( int i = num ; i < m highlight views . size ( ) ; i ++ ) { highlight view hv = m highlight views . get ( i ) ; int edge = hv . get hit ( event . get x ( ) , event . get y ( ) ) ; if ( edge != highlight view . grow none ) { if ( ! hv . has focus ( ) ) { hv . set focus ( bool ) ; hv . invalidate ( ) ; } break ; } } invalidate ( ) ; }	hitting cropping rectangle.
private void ensure visible ( highlight view hv ) { rect r = hv . m draw rect ; int pan delta x1 = math . max ( num , m left - r . left ) ; int pan delta x2 = math . min ( num , m right - r . right ) ; int pan delta y1 = math . max ( num , m top - r . top ) ; int pan delta y2 = math . min ( num , m bottom - r . bottom ) ; int pan delta x = pan delta x1 != num ? pan delta x1 : pan delta x2 ; int pan delta y = pan delta y1 != num ? pan delta y1 : pan delta y2 ; if ( pan delta x != num || pan delta y != num ) { pan by ( pan delta x , pan delta y ) ; } }	Pan the displayed image to make sure the cropping rectangle is visible.
private void center based on highlight view ( highlight view hv ) { rect draw rect = hv . m draw rect ; float width = draw rect . width ( ) ; float height = draw rect . height ( ) ; float this width = get width ( ) ; float this height = get height ( ) ; float z1 = this width / width * num ; float z2 = this height / height * num ; float zoom = math . min ( z1 , z2 ) ; zoom = zoom * this . get scale ( ) ; zoom = math . max ( num , zoom ) ; if ( ( math . abs ( zoom - get scale ( ) ) / zoom ) > num ) { float [ ] coordinates = new float [ ] { hv . m crop rect . center x ( ) , hv . m crop rect . center y ( ) } ; get image matrix ( ) . map points ( coordinates ) ; zoom to ( zoom , coordinates [ num ] , coordinates [ num ] , num ) ; } ensure visible ( hv ) ; }	view's center and scale according to the cropping rectangle.
public void reset document locator ( string publicid , string systemid ) { the publicid = publicid ; the systemid = systemid ; the last line = the last column = the current line = the current column = num ; }	Reset document locator, supplying systemid and publicid.
public string validate ( string value ) { if ( value == null ) { return null ; } for ( int i = num ; i < patterns . length ; i ++ ) { matcher matcher = patterns [ i ] . matcher ( value ) ; if ( matcher . matches ( ) ) { int count = matcher . group count ( ) ; if ( count == num ) { return matcher . group ( num ) ; } string buffer buffer = new string buffer ( ) ; for ( int j = num ; j < count ; j ++ ) { string component = matcher . group ( j + num ) ; if ( component != null ) { buffer . append ( component ) ; } } return buffer . to string ( ) ; } } return null ; }	Validate a value against the set of regular expressionsreturning a String value of the aggregated groups.
@ suppress lint ( str ) public void element type ( string name , int model , int member of , int flags ) { element type e = new element type ( name , model , member of , flags , this ) ; the element types . put ( name . to lower case ( ) , e ) ; if ( member of == m root ) the root = e ; }	Add or replace an element type for this schema.
public void attribute ( string elem name , string attr name , string type , string value ) { element type e = get element type ( elem name ) ; if ( e == null ) { throw new error ( str + attr name + str + elem name ) ; } e . set attribute ( attr name , type , value ) ; }	Add or replace a default attribute for an element type in this schema.
public void parent ( string name , string parent name ) { element type child = get element type ( name ) ; element type parent = get element type ( parent name ) ; if ( child == null ) { throw new error ( str + name + str + parent name ) ; } if ( parent == null ) { throw new error ( str + parent name + str + name ) ; } child . set parent ( parent ) ; }	Specify natural parent of an element in this schema.
@ suppress lint ( str ) public element type get element type ( string name ) { return ( element type ) ( the element types . get ( name . to lower case ( ) ) ) ; }	Get an ElementType by name.
public int get entity ( string name ) {	Get an entity value by name.
public static void cleanup paragraphs ( rt editor , effect ... exclude ) { cleanup paragraphs ( editor , effects . alignment , exclude ) ; cleanup paragraphs ( editor , effects . indentation , exclude ) ; cleanup paragraphs ( editor , effects . bullet , exclude ) ; cleanup paragraphs ( editor , effects . number , exclude ) ; }	This important method makes sure that all paragraph effects are applied to whole paragraphs.While it's optimized for performance it's still an expensive operation so it shouldn't becalled too often.
public void apply to selection ( rt editor , v value ) { selection selection = get selection ( editor ) ;	Apply this effect to the selection.If value is Null then the effect will be removed from the current selection.
protected boolean is valid domain ( string domain ) {	Returns true if the domain component of an email address is valid.
synchronized void executed ( rt editor , operation op ) { stack < operation > undo stack = get undo stack ( editor ) ; stack < operation > redo stack = get redo stack ( editor ) ;	Call this when an operation is performed to add it to the undo stack.
synchronized void redo ( rt editor ) { stack < operation > redo stack = get redo stack ( editor ) ; if ( ! redo stack . empty ( ) ) { stack < operation > undo stack = get undo stack ( editor ) ; operation op = redo stack . pop ( ) ; push ( op , undo stack ) ; op . redo ( editor ) ; while ( ! redo stack . empty ( ) && op . can merge ( redo stack . peek ( ) ) ) { op = redo stack . pop ( ) ; push ( op , undo stack ) ; op . redo ( editor ) ; } } }	Re-do the last undone operation for a specific rich text editor.
private static string replace all ( string source , string search , string replace ) { if ( use replace all ) { return source . replace all ( search , replace ) ; } else { pattern p = pattern . compile ( search ) ; matcher m = p . matcher ( source ) ; string buffer sb = new string buffer ( ) ; boolean at least one found = bool ; while ( m . find ( ) ) { m . append replacement ( sb , replace ) ; at least one found = bool ; } if ( at least one found ) { m . append tail ( sb ) ; return sb . to string ( ) ; } else { return source ; } } }	A memory optimized algorithm for String.replaceAll.
private synchronized thread status get or create thread status ( thread t ) { thread status status = m thread status . get ( t ) ; if ( status == null ) { status = new thread status ( ) ; m thread status . put ( t , status ) ; } return status ; }	Get thread status and create one if specified.
private synchronized void set decoding options ( thread t , bitmap factory . options options ) { get or create thread status ( t ) . m options = options ; }	The following three methods are used to keep track ofBitmapFaction.Options used for decoding and cancelling.
public synchronized boolean can thread decoding ( thread t ) { thread status status = m thread status . get ( t ) ; if ( status == null ) {	The following three methods are used to keep track of which thread isbeing disabled for bitmap decoding.
public bitmap decode file descriptor ( file descriptor fd , bitmap factory . options options ) { if ( options . m cancel ) { return null ; } thread thread = thread . current thread ( ) ; if ( ! can thread decoding ( thread ) ) { return null ; } set decoding options ( thread , options ) ; bitmap b = bitmap factory . decode file descriptor ( fd , null , options ) ; remove decoding options ( thread ) ; return b ; }	The real place to delegate bitmap decoding to BitmapFactory.
public static sorted set < rt > get fonts ( context context ) { map < string , string > asset fonts = get asset fonts ( context ) ; asset manager assets = context . get resources ( ) . get assets ( ) ; for ( string font name : asset fonts . key set ( ) ) { string file path = asset fonts . get ( font name ) ; if ( ! all fonts . contains ( font name ) ) { try { typeface typeface = typeface . create from asset ( assets , file path ) ; all fonts . add ( new rt ( font name , typeface ) ) ; } catch ( exception e ) {	Retrieve the fonts from the asset and the system folder.
private static map < string , string > get asset fonts ( context context ) { synchronized ( asset fonts by name ) { if ( asset fonts by name . is empty ( ) ) { asset manager assets = context . get resources ( ) . get assets ( ) ; collection < string > font files = asset index . get asset index ( context ) ; if ( font files == null || font files . is empty ( ) ) { font files = list font files ( context . get resources ( ) ) ; } for ( string file path : font files ) { if ( file path . to lower case ( locale . get default ( ) ) . ends with ( str ) ) { string font name = ttf . get font name ( assets , file path ) ; if ( font name == null ) { font name = get file name ( file path ) ; } asset fonts by name . put ( font name , file path ) ; } } } return asset fonts by name ; } }	Retrieve the fonts from the asset folder.
private static map < string , string > get system fonts ( ) { synchronized ( system fonts by name ) { for ( string font dir : font dirs ) { file dir = new file ( font dir ) ; if ( ! dir . exists ( ) ) continue ; file [ ] files = dir . list files ( ) ; if ( files == null ) continue ; for ( file file : files ) { string file path = file . get absolute path ( ) ; if ( ! system fonts by path . contains key ( file path ) ) { string font name = ttf . get font name ( file . get absolute path ( ) ) ; if ( font name == null ) { font name = get file name ( file path ) ; } system fonts by path . put ( file path , font name ) ; system fonts by name . put ( font name , file path ) ; } } } return system fonts by name ; } }	Retrieve the fonts from the system folders.
private void setup ( ) { if ( the schema == null ) the schema = new html ( ) ; if ( the scanner == null ) the scanner = new html ( ) ; if ( the auto detector == null ) { the auto detector = new auto detector ( ) { public reader auto detecting reader ( input stream i ) { return new input stream reader ( i ) ; } } ; } the stack = new element ( the schema . get element type ( str ) , default attributes ) ; the pcdata = new element ( the schema . get element type ( str ) , default attributes ) ; the new element = null ; the attribute name = null ; the pi = null ; the saved = null ; the entity = num ; virgin stack = bool ; the doctype name = the doctype public id = the doctype system id = null ; }	Sets up instance variables that haven't been set by setFeature.
private reader get reader ( input source s ) throws sax , io { reader r = s . get character stream ( ) ; input stream i = s . get byte stream ( ) ; string encoding = s . get encoding ( ) ; string publicid = s . get public id ( ) ; string systemid = s . get system id ( ) ; if ( r == null ) { if ( i == null ) i = get input stream ( publicid , systemid ) ;	Buffer both the InputStream and the Reader.
private input stream get input stream ( string publicid , string systemid ) throws io , sax { url basis = new url ( str , str , system . get property ( str ) + str ) ; url url = new url ( basis , systemid ) ; url c = url . open connection ( ) ; return c . get input stream ( ) ; }	Get an InputStream based on a publicid and a systemid.
@ override public void adup ( char [ ] buff , int offset , int length ) throws sax { if ( the new element != null && the attribute name != null ) { the new element . set attribute ( the attribute name , null , the attribute name ) ; the attribute name = null ; } }	needs to support chars past U+FFFF.
private string expand entities ( string src ) { int ref start = - num ; int len = src . length ( ) ; char [ ] dst = new char [ len ] ; int dstlen = num ; for ( int i = num ; i < len ; i ++ ) { char ch = src . char at ( i ) ; dst [ dstlen ++ ] = ch ; if ( ch == str && ref start == - num ) {	with a semicolon.
private int lookup entity ( char [ ] buff , int offset , int length ) { int result = num ; if ( length < num ) return result ;	deferring to the schema for named ones.
private void restart ( element e ) throws sax { while ( the saved != null && the stack . can contain ( the saved ) && ( e == null || the saved . can contain ( e ) ) ) { element next = the saved . next ( ) ; push ( the saved ) ; the saved = next ; } }	e is the next element to be started, if we know what it is.
private void pop ( ) throws sax { if ( the stack == null ) return ;	Pop the stack irrevocably.
private void restartably pop ( ) throws sax { element popped = the stack ; pop ( ) ; if ( restart elements && ( popped . flags ( ) & schema . f restart ) != num ) { popped . anonymize ( ) ; popped . set next ( the saved ) ; the saved = popped ; } }	Pop the stack restartably.
private string prefix of ( string name ) { int i = name . index of ( str ) ; string prefix = str ; if ( i != - num ) prefix = name . substring ( num , i ) ; return prefix ; }	Get the prefix from a QName.
private boolean foreign ( string prefix , string namespace ) {	Return true if we have a foreign name.
private static string trimquotes ( string in ) { if ( in == null ) return in ; int length = in . length ( ) ; if ( length == num ) return in ; char s = in . char at ( num ) ; char e = in . char at ( length - num ) ; if ( s == e && ( s == str || s == str ) ) { in = in . substring ( num , in . length ( ) - num ) ; } return in ; }	If the String is quoted, trim the quotes.
private static string [ ] split ( string val ) throws illegal argument exception { val = val . trim ( ) ; if ( val . length ( ) == num ) { return new string [ num ] ; } else { array list < string > l = new array list < string > ( ) ; int s = num ; int e = num ; boolean sq = bool ;	Recognises quotes around a phrase and doesn't split it.
private void rectify ( element e ) throws sax { element sp ; while ( bool ) { for ( sp = the stack ; sp != null ; sp = sp . next ( ) ) { if ( sp . can contain ( e ) ) break ; } if ( sp != null ) break ; element type parent type = e . parent ( ) ; if ( parent type == null ) break ; element parent = new element ( parent type , default attributes ) ;	so that the argument can be safely pushed.
public void on save instance state ( bundle out state ) { out state . put string ( str , m toolbar visibility . name ( ) ) ; out state . put boolean ( str , m toolbar is visible ) ; out state . put int ( str , m active editor ) ; if ( m link selection != null ) { out state . put serializable ( str , m link selection ) ; } }	Called to retrieve per-instance state before being killed so that thestate can be restored in the constructor.
public void on destroy ( boolean is saved ) { event bus . get default ( ) . unregister ( this ) ; for ( rt editor : m editors . values ( ) ) { editor . unregister ( ) ; editor . on destroy ( is saved ) ; } m editors . clear ( ) ; for ( rt toolbar : m toolbars . values ( ) ) { toolbar . remove toolbar listener ( ) ; } m toolbars . clear ( ) ; m rt = null ; }	Perform any final cleanup before the component is destroyed.
@ subscribe ( sticky = bool , thread mode = thread mode . main ) public void on event main thread ( media event event ) { rt editor = m editors . get ( m active editor ) ; rt media = event . get media ( ) ; if ( editor != null && media instanceof rt ) { insert image ( editor , ( rt ) media ) ; event bus . get default ( ) . remove sticky event ( event ) ; m active editor = integer . max value ; } }	Media file was picked -> process the result.
@ subscribe ( thread mode = thread mode . main ) public void on event main thread ( link event event ) { final string fragment tag = event . get fragment tag ( ) ; m rt . remove fragment ( fragment tag ) ; if ( ! event . was cancelled ( ) && id 01 link fragment . equals ( fragment tag ) ) { rt editor = get active editor ( ) ; if ( editor != null ) { link link = event . get link ( ) ; string url = null ; if ( link != null && link . is valid ( ) ) {	LinkFragment has closed -> process the result.
private void get proper base matrix ( rotate bitmap bitmap , matrix matrix ) { float view width = get width ( ) ; float view height = get height ( ) ; float w = bitmap . get width ( ) ; float h = bitmap . get height ( ) ; matrix . reset ( ) ;	Setup the base matrix so that the image is centered and scaled properly.
protected float max zoom ( ) { if ( m bitmap displayed . get bitmap ( ) == null ) { return num ; } float fw = ( float ) m bitmap displayed . get width ( ) / ( float ) m this width ; float fh = ( float ) m bitmap displayed . get height ( ) / ( float ) m this height ; float max = math . max ( fw , fh ) * num ; return max ; }	rather than the current 1024x768, this should be changed down to 200%.
final public boolean exists in selection ( rt editor ) { selection selection = get selection ( editor ) ; list < rt < v > > spans = get spans ( editor . get text ( ) , selection , span collect mode . span flags ) ; return ! spans . is empty ( ) ; }	Check whether the effect exists in the currently selected text of the active RTEditText.
protected void find spans2 remove ( spannable str , paragraph paragraph , paragraph span processor < v > span processor ) { list < rt < v > > spans = get spans ( str , paragraph , span collect mode . exact ) ; span processor . remove spans ( spans , paragraph ) ; }	Find spans within that paragraph and add them to the ParagraphSpanProcessor to be removedonce the ParagraphSpanProcessor processes its spans.
public static boolean pick directory ( activity activity , file start path , int request code ) { package manager package mgr = activity . get package manager ( ) ; for ( string [ ] intent : pick directory intents ) { string intent action = intent [ num ] ; string uri prefix = intent [ num ] ; intent start intent = new intent ( intent action ) . put extra ( str , activity . get string ( r . string . save as ) ) . set data ( uri . parse ( uri prefix + start path . get path ( ) ) ) ; try { if ( start intent . resolve activity ( package mgr ) != null ) { activity . start activity for result ( start intent , request code ) ; return bool ; } } catch ( activity not found exception e ) { show no file picker error ( activity , e ) ; } } return bool ; }	Tries to open a known file browsers to pick a directory.
private bitmap rotate image ( bitmap src , float degree ) {	Thong added for rotate.
public void set output ( writer writer ) { if ( writer == null ) { output = new output stream writer ( system . out ) ; } else { output = writer ; } }	Set a new output destination for the document.
private void write ( char c ) throws sax { try { output . write ( c ) ; } catch ( io e ) { throw new sax ( e ) ; } }	Write a raw character.
private void write ( string s ) throws sax { try { output . write ( s ) ; } catch ( io e ) { throw new sax ( e ) ; } }	Write a raw string.
private boolean boolean attribute ( string local name , string q name , string value ) { string name = local name ; if ( name == null ) { int i = q name . index of ( str ) ; if ( i != - num ) name = q name . substring ( i + num , q name . length ( ) ) ; } if ( ! name . equals ( value ) ) return bool ; for ( int j = num ; j < booleans . length ; j ++ ) { if ( name . equals ( booleans [ j ] ) ) return bool ; } return bool ; }	Return true if the attribute is an HTML boolean from the above list.
private void write esc ut ( string s , int start , int length , boolean is att val ) throws sax { string sub string = s . substring ( start , start + length ) ; write ( string escape utils . escape html4 ( sub string ) ) ; }	Write an array of data characters with escaping.
@ suppress warnings ( str ) private void write ns ( ) throws sax { enumeration < string > prefixes = ( enumeration < string > ) ns support . get declared prefixes ( ) ; while ( prefixes . has more elements ( ) ) { string prefix = ( string ) prefixes . next element ( ) ; string uri = ns support . get uri ( prefix ) ; if ( uri == null ) { uri = str ; } write ( str ) ; if ( str . equals ( prefix ) ) { write ( str ) ; } else { write ( str ) ; write ( prefix ) ; write ( str ) ; } write esc ut ( uri , num , uri . length ( ) , bool ) ; write ( str ) ; } }	Write out the list of Namespace declarations.
private void write name ( string uri , string local name , string q name , boolean is element ) throws sax { string prefix = do prefix ( uri , q name , is element ) ; if ( prefix != null && ! str . equals ( prefix ) ) { write ( prefix ) ; write ( str ) ; } if ( local name != null && ! str . equals ( local name ) ) { write ( local name ) ; } else { int i = q name . index of ( str ) ; write ( q name . substring ( i + num , q name . length ( ) ) ) ; } }	Write an element or attribute name.
private static void create stream if not exists ( amazon kinesis kinesis , string stream name , int shard count ) { perform amazon action with retry ( str , ( ) -> { describe stream request describe stream request = new describe stream request ( ) . with stream name ( stream name ) . with limit ( num ) ; try { kinesis . describe stream ( describe stream request ) ; } catch ( resource not found exception e ) { kinesis . create stream ( stream name , shard count ) ; } return null ; } , default retry count , default retry duration in millis ) ; }	Create a stream if it does not already exist.
private static void wait stream activation ( amazon kinesis consumer , string stream name , long stream creation timeout millis ) { describe stream request describe stream request = new describe stream request ( ) . with stream name ( stream name ) . with limit ( num ) ; describe stream result describe stream result = null ; string stream status = null ; long end time = system . current time millis ( ) + stream creation timeout millis ; do { try { describe stream result = consumer . describe stream ( describe stream request ) ; stream status = describe stream result . get stream description ( ) . get stream status ( ) ; if ( active stream status . equals ( stream status ) ) { break ; } thread . sleep ( num ) ; } catch ( resource not found exception | limit exceeded exception ignored ) {	Waits that the stream has been created.
private static void complete store snapshot with missing instance snapshots ( path target stores path ) { string transaction id regex alone = str ; string transaction id regex replace = str ; pattern transaction id pattern = compile ( transaction id regex alone ) ; set < file > previous snapshots = new hash set < > ( ) ; arrays . stream ( target stores path . resolve ( snapshot directory name ) . to file ( ) . list files ( ) ) . sorted ( ) . for each ( snapshot -> { set < string > snapshot names = arrays . stream ( snapshot . list files ( ) ) . map ( file :: get name ) . collect ( to set ( ) ) ; previous snapshots . stream ( ) . filter ( previous snapshot -> ! snapshot names . contains ( previous snapshot . get name ( ) ) ) . for each ( previous snapshot -> { try { path target path = snapshot . to path ( ) . resolve ( previous snapshot . get name ( ) ) ; path source path = previous snapshot . to path ( ) ; long count = count transaction id ( transaction id pattern , source path ) ; if ( count != num ) { throw new store exception ( str , args -> args . add ( str , count ) ) ; } big integer new transaction id = new big integer ( snapshot . get name ( ) ) ; replace transaction id value ( transaction id regex replace , source path , target path , new transaction id . to string ( ) ) ; } catch ( io e ) { throw new io ( e ) ; } } ) ; previous snapshots . clear ( ) ; previous snapshots . add all ( arrays . stream ( snapshot . list files ( ) ) . collect ( to set ( ) ) ) ; } ) ; }	Complete snapshot N with lacking instance snapshots from snapshot N - 1.
private boolean wait the minimal duration to execute the next provisioning request ( ) { if ( m last get shard iterator request time != null ) { long delay = m duration between requests . get ( ) - ( system . current time millis ( ) - m last get shard iterator request time ) ; if ( delay > num ) { try { thread . sleep ( delay ) ; } catch ( interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; return bool ; } } } m last get shard iterator request time = system . current time millis ( ) ; return bool ; }	Wait that the minimum duration between two GetShardIteratorRequests has elapsed.
@ nullable private list < record > get records ( get records request get records request ) { return try amazon action ( str , ( ) -> { get records result get records result = m kinesis . get records ( get records request ) ; m shard iterator = get records result . get next shard iterator ( ) ; list < record > records = get records result . get records ( ) ; log . trace ( str , args -> args . add ( str , m stream name ) . add ( str , records . size ( ) ) . add ( str , get records result . get millis behind latest ( ) ) ) ; return records ; } , m duration between requests ) . or else ( list . of ( ) ) ; }	Retrieves records corresponding to the request.
public static < t > t perform amazon action with retry ( string action label , supplier < t > action , int retry limit , int duration in millis ) { int retry count = num ; do { try { return action . get ( ) ; } catch ( limit exceeded exception | provisioned throughput exceeded exception | kms e ) {	Handle retry for amazon quotas.
public static < t > optional < t > try amazon action ( string action label , supplier < t > action , atomic long duration between requests ) { try { return of ( action . get ( ) ) ; } catch ( limit exceeded exception | provisioned throughput exceeded exception | kms e ) { int duration random modifier = num + random . next int ( num ) ;	Try to perform an Amazon action and increase the duration between requests if some exception is exceeding resource usage exception is thrown.
static string check bucket is accessible ( amazon s3 amazon s3 , string bucket name ) { head bucket request head bucket request = new head bucket request ( bucket name ) ; try { amazon s3 . head bucket ( head bucket request ) ; } catch ( amazon service exception e ) { throw new aws s3 exception ( str , args -> args . add ( str , bucket name ) , e ) ; } return bucket name ; }	Throws an exception if the bucket does not exist or is not readable.
optional < big integer > load stores ( function < string , entity stores > entity stores by store name , bi function < serializable snapshot , string , serializable snapshot > snapshot post processor ) { optional < big integer > latest snapshot tx id ; try { latest snapshot tx id = m snapshot store . list snapshots ( ) . stream ( ) . max ( big integer :: compare to ) ; } catch ( io e ) { throw new unrecoverable store exception ( str , e ) ; } latest snapshot tx id . if present ( last tx -> { log . info ( str , args -> args . add ( str , last tx ) ) ; var post process = new snapshot post processor ( snapshot post processor ) ; try { flowable . from publisher ( m snapshot store . create snapshot reader ( last tx ) )	Load the stores.
void trigger wildcard expander ( final collection < file > all files , final wildcard context wildcard context ) throws io { log . debug ( str , all files ) ; if ( all files . is empty ( ) ) { final string message = string . format ( str , wildcard context . get wildcard ( ) ) ; log . warn ( message ) ; throw new io ( message ) ; } if ( wildcard expander handler != null ) { try { wildcard expander handler . apply ( all files ) ; } catch ( final io e ) {	Uses the wildcardExpanderHandler to process all found files and directories.
private static string replace ( final string in string , final string old pattern , final string new pattern ) { if ( ! has length ( in string ) || ! has length ( old pattern ) || new pattern == null ) { return in string ; } final string buffer sbuf = new string buffer ( ) ;	Replace all occurrences of a substring within a string with another string.
private static string delete any ( final string in string , final string chars to delete ) { if ( ! has length ( in string ) || ! has length ( chars to delete ) ) { return in string ; } final string buffer out = new string buffer ( ) ; for ( int i = num ; i < in string . length ( ) ; i ++ ) { final char c = in string . char at ( i ) ; if ( chars to delete . index of ( c ) == - num ) { out . append ( c ) ; } } return out . to string ( ) ; }	Delete any character in a given String.
public lint report < t > add report ( final resource lint report < t > resource lint report ) { validate . not null ( resource lint report ) ; reports . add ( resource lint report ) ; return this ; }	Add a single lint report to underlying collection.
private void update properties with configuration ( final properties props , final string key ) { final filter config filter config = context . get ( ) . get filter config ( ) ;	Add to properties a new key with value extracted either from filterConfig or from configurable properties file.This method helps to ensure backward compatibility of the filterConfig vs configProperties configuration.
private properties get config properties ( ) { if ( config properties == null ) { config properties = new config properties ( ) ; if ( additional config properties != null ) { config properties . put all ( additional config properties ) ; } } return config properties ; }	Use this method rather than accessing the field directly, because it will create a default one if none is provided.
private input stream create auto detected stream ( final string default file name ) throws io { try { validate . not null ( wro file , str ) ; if ( auto detect wro file ) { final file file = new file ( wro file . get parent file ( ) , default file name ) ; log . debug ( str + file ) ; return new file input stream ( file ) ; } log . debug ( str + wro file ) ; return new file input stream ( wro file ) ; } catch ( final file not found exception e ) {	Handles the resource model auto detection.
private map < string , resource post processor > to post processors ( final map < string , resource pre processor > pre processors map ) { final map < string , resource post processor > map = new hash map < string , resource post processor > ( ) ; for ( final entry < string , resource pre processor > entry : pre processors map . entry set ( ) ) { map . put ( entry . get key ( ) , new processor decorator ( entry . get value ( ) ) ) ; } return map ; }	Creates a map of postProcessors form a map of preProcessors.
public string compile ( final string content , final string optional argument ) { final rhino script builder builder = init script builder ( ) ; final string arg str = create arg str ( optional argument ) + create arg str ( get arguments ( ) ) ; final string compile script = string . format ( str , get compile command ( ) , wro util . to js ( content ) , arg str ) ; return ( string ) builder . evaluate ( compile script , get compile command ( ) ) ; }	Compiles the javascript template into plain javascript.
private void reload cache with new value ( final long new value ) { final long new value as primitive = new value == null ? get cache update period ( ) : new value ; log . debug ( str , cache update period listeners . size ( ) ) ; for ( final property change listener listener : cache update period listeners ) { final property change event event = new property change event ( this , str , get cache update period ( ) , new value as primitive ) ; listener . property change ( event ) ; } }	Notify all listeners about cachePeriod property changed.
private void reload model with new value ( final long new value ) { final long new value as primitive = new value == null ? get model update period ( ) : new value ; for ( final property change listener listener : model update period listeners ) { final property change event event = new property change event ( this , str , get model update period ( ) , new value as primitive ) ; listener . property change ( event ) ; } }	Notify all listeners about cachePeriod property changed.
private servlet request get wrapped servlet request ( final http servlet request request , final string location ) { final http servlet request wrapped request = new http servlet request wrapper ( request ) { @ override public string get request uri ( ) { return get context path ( ) + location ; } @ override public string get path info ( ) { return wro util . get path info from location ( this , location ) ; } @ override public string get servlet path ( ) { return wro util . get servlet path from location ( this , location ) ; } } ;	Build a wrapped servlet request which will be used for dispatching.
public static transformer < string > base name suffix transformer ( final string suffix ) { return new transformer < string > ( ) { public string transform ( final string input ) { final string base name = filename utils . get base name ( input ) ; final string extension = filename utils . get extension ( input ) ; return base name + suffix + str + extension ; } } ; }	Appends a suffix to the source baseName.
private void on error ( final int sc , final string msg ) { log . debug ( str , sc , msg ) ; final output stream empty stream = new byte array output stream ( ) ; print writer = new print writer ( empty stream ) ; servlet output stream = new delegating servlet output stream ( empty stream ) ; }	Use an empty stream to avoid container writing unwanted message when a resource is missing.
@ override public void send redirect ( final string location ) throws io { try { log . debug ( str , location ) ; final input stream is = external resource locator . locate ( location ) ; io . copy ( is , servlet output stream ) ; is . close ( ) ; servlet output stream . close ( ) ; } catch ( final io e ) { log . warn ( str , e . get class ( ) . get name ( ) , location ) ; throw e ; } }	By default, redirect does not allow writing to output stream its content.
private void process resource ( final group group , final resource resource ) { final uri locator uri locator = locator factory . get instance ( resource . get uri ( ) ) ; if ( uri locator instanceof wildcard uri locator support ) { final wildcard stream locator wildcard stream locator = ( ( wildcard uri locator support ) uri locator ) . get wildcard stream locator ( ) ;	Process each resource and replace it with a collection of resources if it contains wildcard.
public function < collection < file > , void > create expander handler ( final group group , final resource resource , final string base name folder ) { log . debug ( str , base name folder , resource ) ; return new function < collection < file > , void > ( ) { public void apply ( final collection < file > files ) { if ( base name folder == null ) {	create the handler which expand the resources containing wildcard.
public final input stream locate ( final string uri ) throws io { final uri locator uri locator = get instance ( uri ) ; if ( uri locator == null ) { throw new wro runtime exception ( str + uri ) ; } log . debug ( str , uri , uri locator . get class ( ) . get simple name ( ) ) ; return new auto close input stream ( uri locator . locate ( uri ) ) ; }	Locates an InputStream for the given uri.
private wro configuration create configuration ( ) {	Creates configuration by looking up in servletContext attributes.
private void register change listeners ( ) { wro configuration . register cache update period change listener ( new property change listener ( ) { public void property change ( final property change event event ) {	Register property change listeners.
private void process request ( final http servlet request request , final http servlet response response ) throws servlet exception , io { set response headers ( response ) ;	Perform actual processing.
public final void set configuration ( final wro configuration config ) { not null ( config ) ; wro configuration factory = new object factory < wro configuration > ( ) { public wro configuration create ( ) { return config ; } } ; }	Once set, this configuration will be used, instead of the one built by the factory.
private void identify duplicate group names ( final collection < group > groups ) { log . debug ( str ) ; final list < string > group names = new array list < string > ( ) ; for ( final group group : groups ) { if ( group names . contains ( group . get name ( ) ) ) { throw new wro runtime exception ( str + group . get name ( ) ) ; } group names . add ( group . get name ( ) ) ; } }	Identify duplicate group names.
public void merge ( final wro model imported model ) { validate . not null ( imported model , str ) ; log . debug ( str , imported model ) ; for ( final string group name : new wro model inspector ( imported model ) . get group names ( ) ) { if ( new wro model inspector ( this ) . get group names ( ) . contains ( group name ) ) { throw new wro runtime exception ( str + group name ) ; } final group imported group = new wro model inspector ( imported model ) . get group by name ( group name ) ; add group ( imported group ) ; } }	Merge this model with another model.
public input stream locate ( final string uri ) throws io { final uri locator locator = get instance ( uri ) ; if ( locator == null ) { return get decorated object ( ) . locate ( uri ) ; } return locator . locate ( uri ) ; }	This implementation shows the problem with current design of locator implementation.
private string apply post processors ( final cache key cache key , final string content ) throws io { final collection < resource post processor > processors = processors factory . get post processors ( ) ; log . debug ( str , processors ) ; if ( processors . is empty ( ) ) { return content ; } final resource resource = resource . create ( cache key . get group name ( ) , cache key . get type ( ) ) ; reader reader = new string reader ( content . to string ( ) ) ; writer writer = null ; for ( final resource post processor processor : processors ) { final resource pre processor decorated processor = decorate processor ( processor , cache key . is minimize ( ) ) ; writer = new string writer ( ) ; decorated processor . process ( resource , reader , writer ) ; reader = new string reader ( writer . to string ( ) ) ; } return writer . to string ( ) ; }	Apply resourcePostProcessors.
private synchronized processor decorator decorate processor ( final resource post processor processor , final boolean minimize ) { final processor decorator decorated = new default processor decorator ( processor , minimize ) { @ override public void process ( final resource resource , final reader reader , final writer writer ) throws io { try { callback registry . on before post process ( ) ; super . process ( resource , reader , writer ) ; } finally { callback registry . on after post process ( ) ; } } } ; injector . inject ( decorated ) ; return decorated ; }	This method is synchronized to ensure that processor is injected before it is being used by other thread.
private void do process ( final string request uri , final reader reader , final writer writer ) throws io { reader input = reader ; writer output = null ; log . debug ( str , request uri ) ; try { final stop watch stop watch = new stop watch ( ) ; final injector injector = injector builder . create ( new base wro manager factory ( ) ) . build ( ) ; final list < resource pre processor > processors = get processors list ( ) ; if ( processors == null || processors . is empty ( ) ) { io . copy ( reader , writer ) ; } else { for ( final resource pre processor processor : processors ) { stop watch . start ( str + processor . get class ( ) . get simple name ( ) ) ;	Applies configured processor on the intercepted stream.
public string [ ] split options ( final string option as string ) { return option as string == null ? array utils . empty string array : option as string . split ( str ) ; }	Split multiple options into an array of options.
public properties load ( final input stream input stream ) throws io { validate . not null ( input stream ) ; final string raw content = io . to string ( input stream , char encoding . utf 8 ) ; parse properties ( raw content . replace all ( regex comments , str ) ) ; return this . properties ; }	Load the properties from the stream.
private void parse properties ( final string properties as string ) {	parse the properties from the provided string containing a raw properties.
private wro manager factory create custom manager factory ( ) throws mojo execution exception { wro manager factory factory = null ; try { final class < ? > wro manager factory class = thread . current thread ( ) . get context class loader ( ) . load class ( wro manager factory . trim ( ) ) ; factory = ( wro manager factory ) wro manager factory class . new instance ( ) ; } catch ( final exception e ) { throw new mojo execution exception ( str + wro manager factory , e ) ; } return factory ; }	Creates a custom instance of Manager factory.
private void persist resource fingerprints ( final list < string > group names ) { final wro model inspector model inspector = new wro model inspector ( get model ( ) ) ; for ( final string group name : group names ) { final group group = model inspector . get group by name ( group name ) ; if ( group != null ) { for ( final resource resource : group . get resources ( ) ) { get resource change handler ( ) . remember ( resource ) ; } } } }	Store digest for all resources contained inside the list of provided groups.
private boolean is target group ( final group group ) { not null ( group ) ; final string target groups = get target groups ( ) ;	Check if the provided group is a target group.
protected final void extend plugin classpath ( ) throws mojo execution exception {	Update the classpath.
protected input stream get model resource as stream ( ) throws io { final servlet context servlet context = context . get servlet context ( ) ;	Override this method, in order to provide different xml definition file name.
private wro manager factory init factory ( final properties properties ) { wro manager factory factory = null ; final string wro manager class name = properties . get property ( config constants . manager factory class name . name ( ) ) ; if ( string utils . is empty ( wro manager class name ) ) {	Initialized inner factory based on provided configuration.
public model transformer factory set transformers ( final list < transformer < wro model > > model transformers ) { validate . not null ( model transformers ) ; this . model transformers = model transformers ; return this ; }	Set a list of transformers to apply on decorated model factory.
@ override public string compile ( final string content , final string name ) { final string precompiled function = super . compile ( content , str ) ; return string . format ( str , name , precompiled function ) ; }	visible for testing, the init of a HandlebarsJs template.
public string process and merge ( final list < resource > resources , final boolean minimize ) throws io { return process and merge ( resources , processing criteria . create ( processing type . all , minimize ) ) ; }	Apply preProcessors on resources and merge them after all preProcessors are applied.
public string process and merge ( final list < resource > resources , final processing criteria criteria ) throws io { not null ( criteria ) ; log . debug ( str , criteria ) ; callback registry . on before merge ( ) ; try { not null ( resources ) ; log . debug ( str , resources ) ; final string buffer result = new string buffer ( ) ; if ( should run in parallel ( resources ) ) { result . append ( run in parallel ( resources , criteria ) ) ; } else { for ( final resource resource : resources ) { log . debug ( str , resource ) ; result . append ( apply pre processors ( resource , criteria ) ) ; } } return result . to string ( ) ; } finally { callback registry . on after merge ( ) ; } }	Apply preProcessors on resources and merge them.
private string run in parallel ( final list < resource > resources , final processing criteria criteria ) throws io { log . debug ( str ) ; final string buffer result = new string buffer ( ) ; final list < callable < string > > callables = new array list < callable < string > > ( ) ; for ( final resource resource : resources ) { callables . add ( new callable < string > ( ) { public string call ( ) throws exception { log . debug ( str , resource ) ; return apply pre processors ( resource , criteria ) ; } } ) ; } final executor service exec = get executor service ( ) ; final list < future < string > > futures = new array list < future < string > > ( ) ; for ( final callable < string > callable : callables ) {	runs the pre processors in parallel.
private string apply pre processors ( final resource resource , final processing criteria criteria ) throws io { final collection < resource pre processor > processors = processors factory . get pre processors ( ) ; log . debug ( str , processors ) ; string resource content = null ; try { resource content = get resource content ( resource ) ; } catch ( final io e ) { log . debug ( str , resource ) ; if ( context . get ( ) . get config ( ) . is ignore missing resources ( ) ) { return string utils . empty ; } else { log . error ( str , resource ) ; throw e ; } } if ( ! processors . is empty ( ) ) { writer writer = null ; for ( final resource pre processor processor : processors ) { final resource pre processor decorated processor = decorate pre processor ( processor , criteria ) ; writer = new string writer ( ) ; final reader reader = new string reader ( resource content ) ;	Apply a list of preprocessors on a resource.
private synchronized resource pre processor decorate pre processor ( final resource pre processor processor , final processing criteria criteria ) { final resource pre processor decorated = new default processor decorator ( processor , criteria ) { @ override public void process ( final resource resource , final reader reader , final writer writer ) throws io { try { callback registry . on before pre process ( ) ; super . process ( resource , reader , writer ) ; } finally { callback registry . on after pre process ( ) ; } } } ; injector . inject ( decorated ) ; return decorated ; }	Decorates preProcessor with mandatory decorators.This method is synchronized to ensure that processor is injected before it is being used by other thread.
public void persist ( ) { output stream os = null ; try { os = new file output stream ( fallback storage file ) ; fallback storage . store ( os , str ) ; log . debug ( str , fallback storage file ) ; } catch ( final io e ) { log . warn ( str , fallback storage file , e ) ; } finally { io . close quietly ( os ) ; } }	Persist the fallbackStorage to the fallbackStorageFile.
private collection < field > get all fields ( final object object ) { final collection < field > fields = new array list < field > ( ) ; fields . add all ( arrays . as list ( object . get class ( ) . get declared fields ( ) ) ) ;	Return all fields for given object, also those from the super classes.
public string rewrite ( final string css uri , final string image url ) { not null ( css uri ) ; not null ( image url ) ; if ( string utils . is empty ( image url ) ) { return image url ; } if ( servlet context uri locator . is valid ( css uri ) ) { if ( servlet context uri locator . is valid ( image url ) ) { return prepend context path ( image url ) ; }	Computes the url of the image to be replaced in a css resource.
private string compute new image location ( final string css uri , final string image url ) { log . debug ( str , css uri , image url ) ; final string clean image url = clean image url ( image url ) ;	Concatenates cssUri and imageUrl after few changes are applied to both input parameters.
public base wro manager factory add model transformer ( final transformer < wro model > model transformer ) { if ( model transformers == null ) { model transformers = new array list < transformer < wro model > > ( ) ; } this . model transformers . add ( model transformer ) ; return this ; }	Add a single model transformer.
public void serve processed bundle ( ) throws io { final wro configuration configuration = context . get config ( ) ; final http servlet request request = context . get request ( ) ; final http servlet response response = context . get response ( ) ; output stream os = null ; try { final cache key cache key = get safe cache key ( request ) ; init aggregated folder path ( request , cache key . get type ( ) ) ; final cache value cache value = cache strategy . get ( cache key ) ;	Write to stream the content of the processed resource bundle.
private void init aggregated folder path ( final http servlet request request , final resource type type ) { if ( resource type . css == type && context . get aggregated folder path ( ) == null ) { final string request uri = request . get request uri ( ) ; final string css folder = string utils . remove end ( request uri , filename utils . get name ( request uri ) ) ; final string aggregated folder = string utils . remove start ( css folder , request . get context path ( ) ) ; log . debug ( str , aggregated folder ) ; context . get ( ) . set aggregated folder path ( aggregated folder ) ; } }	Set the aggregatedFolderPath if required.
private map < string , string > extract variables ( final string variables body ) { final map < string , string > map = new hash map < string , string > ( ) ; final matcher m = pattern variables body . matcher ( variables body ) ; log . debug ( str ) ; while ( m . find ( ) ) { final string key = m . group ( num ) ; final string value = m . group ( num ) ; if ( map . contains key ( key ) ) { log . warn ( str , key , value ) ; } map . put ( key , value ) ; } return map ; }	Extract variables map from variables body.
private string parse css ( final string css ) {	Parse css, find all defined variables & replace them.
private string replace variables ( final string css , final map < string , string > variables ) { final string buffer sb = new string buffer ( ) ; final matcher m = pattern variable holder . matcher ( css ) ; while ( m . find ( ) ) { final string old match = m . group ( ) ; final string variable name = m . group ( num ) ; final string variable value = variables . get ( variable name ) ; if ( variable value != null ) { final string new replacement = old match . replace ( old match , variable value ) ; m . append replacement ( sb , new replacement . trim ( ) ) ; } else { log . warn ( str + variable name + str ) ; } } m . append tail ( sb ) ; return sb . to string ( ) ; }	Replace variables from css with provided variables map.
private static resource pre processor to pre processor ( final resource post processor post processor ) { return new abstract processor decorator support < resource post processor > ( post processor ) { public void process ( final resource resource , final reader reader , final writer writer ) throws io { post processor . process ( reader , writer ) ; } @ override protected boolean is minimize internal ( ) { return is minimize for processor ( post processor ) ; } @ override protected supported resource type get supported resource type internal ( ) { return get supported resource type for processor ( post processor ) ; } @ override public string to string ( ) { return post processor . to string ( ) ; } } ; }	Transforms a post processor into pre processor.
public final boolean is eligible ( final boolean minimize , final resource type searched type ) { validate . not null ( searched type ) ; final supported resource type supported type = get supported resource type ( ) ; final boolean is type satisfied = supported type == null || ( supported type != null && searched type == supported type . value ( ) ) ; final boolean is minimized satisfied = minimize == bool || ! is minimize ( ) ; return is type satisfied && is minimized satisfied ; }	Indicates if the processor is eligible for usage based on provided criteria.
private void do gzip response ( final http servlet request req , final http servlet response response , final filter chain chain ) throws io , servlet exception { log . debug ( str + req . get request uri ( ) ) ; response . set header ( http header . content encoding . to string ( ) , str ) ; final byte array output stream baos = new byte array output stream ( ) ; final counting output stream counting stream = new counting output stream ( new gzip ( new buffered output stream ( baos ) ) ) ;	Performs actual gzip of the filtered content.
public static path pattern processor decorator include ( final object processor , final string ... patterns ) { return new path pattern processor decorator ( processor , bool , patterns ) ; }	Decorates a processor which will be applied on provided patterns.
public static path pattern processor decorator exclude ( final object processor , final string ... patterns ) { return new path pattern processor decorator ( processor , bool , patterns ) ; }	Decorates a processor which will not be applied on provided patterns.
public static resource change handler create ( final wro manager factory manager factory , final log log ) { not null ( manager factory , str ) ; not null ( log , str ) ; return new resource change handler ( ) . set manager factory ( manager factory ) . set log ( log ) ; }	Factory method which requires all mandatory fields.
public void remember ( final resource resource ) { final wro manager manager = get manager factory ( ) . create ( ) ; final hash strategy hash strategy = manager . get hash strategy ( ) ; final uri locator factory locator factory = manager . get uri locator factory ( ) ; if ( remembered set . contains ( resource . get uri ( ) ) ) {	Will persist the information regarding the provided resource in some internal store.
private void for each css import apply ( final function < string , change status > func , final resource resource , final reader reader ) throws io { final resource pre processor processor = create css import processor ( func ) ; injector builder . create ( get manager factory ( ) ) . build ( ) . inject ( processor ) ; processor . process ( resource , reader , new string writer ( ) ) ; }	Invokes the provided function for each detected css import.
private list < t > filter ( final collection < t > collection ) { final list < t > null free list = new array list < t > ( ) ; if ( collection != null ) { for ( final t item : collection ) { if ( item != null ) { null free list . add ( item ) ; } } } return null free list ; }	This filtering is required, in order to ensure that no nulls are passed (which happens when using gson fordeserializing json collection.
public boolean is minimized ( final http servlet request request ) { validate . not null ( request ) ; final string minimize as string = request . get parameter ( param minimize ) ; return ! ( context . get ( ) . get config ( ) . is debug ( ) && str . equals ignore case ( minimize as string ) ) ; }	The minimization is can be switched off only in debug mode.
private list < resource > find imported resources ( final string resource uri , final string css content ) throws io {	Find a set of imported resources inside a given resource.
private string compute absolute url ( final string relative resource uri , final string import url ) { final string folder = wro util . get full path ( relative resource uri ) ;	Computes absolute url of the imported resource.
public static string create items as string ( final string ... items ) { final string buffer sb = new string buffer ( ) ; for ( int i = num ; i < items . length ; i ++ ) { sb . append ( items [ i ] ) ; if ( i < items . length - num ) { sb . append ( token delimiter ) ; } } return sb . to string ( ) ; }	Creates a comma separated list of items.
private list < string > get alias list ( final string alias csv ) { log . debug ( str , alias csv ) ; final list < string > list = new array list < string > ( ) ; if ( ! string utils . is empty ( alias csv ) ) { final string [ ] tokens = alias csv . split ( token delimiter ) ; for ( final string token : tokens ) { list . add ( token . trim ( ) ) ; } } return list ; }	Creates a list of aliases based on provided string containing comma separated values of aliases.
private scriptable object create context ( final scriptable object initial scope ) { final context context = get context ( ) ; context . set optimization level ( - num ) ;	Initialize the context.
public object evaluate ( final reader reader , final string source name ) throws io { not null ( reader ) ; try { return evaluate ( io . to string ( reader ) , source name ) ; } finally { reader . close ( ) ; } }	Evaluates a script from a reader.
public object evaluate ( final string script , final string source name ) { not null ( script ) ;	Evaluates a script.
public final void process ( ) throws io {	Perform processing of the uri.
private boolean is handler request ( final http servlet request request ) { string api handler value = request . get parameter ( path api ) ; return path handler . equals ( api handler value ) && retrieve cache key ( request ) != null ; }	Checks if the provided url is a resource proxy request.
public static string create handler request path ( final cache key cache key , final http servlet request request ) { final string handler query path = get request handler path ( cache key . get group name ( ) , cache key . get type ( ) ) ; return request . get servlet path ( ) + handler query path ; }	Computes the servlet context relative url to call this handler using a server-side invocation.
private string rename ( final string group , final input stream input ) throws exception { try { final string new name = get manager factory ( ) . create ( ) . get naming strategy ( ) . rename ( group , input ) ; group names . set property ( group , new name ) ; return new name ; } catch ( final io e ) { throw new mojo execution exception ( str , e ) ; } }	Encodes a version using some logic.
private file compute destination folder ( final resource type resource type ) throws mojo execution exception { file folder = destination folder ; if ( resource type == resource type . js ) { if ( js destination folder != null ) { folder = js destination folder ; } } if ( resource type == resource type . css ) { if ( css destination folder != null ) { folder = css destination folder ; } } get log ( ) . info ( str + folder ) ; if ( folder == null ) { throw new mojo execution exception ( str + resource type + str + str ) ; } if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } return folder ; }	Computes the destination folder based on resource type.
private void process group ( final string group , final file parent foder ) throws exception { byte array output stream result output stream = null ; input stream result input stream = null ; try { get log ( ) . info ( str + group ) ;	Process a single group.
public boolean check change for group ( final string uri , final string group name ) throws io { not null ( uri ) ; not null ( group name ) ; log . debug ( str , group name , uri ) ; final resource change info resource info = change info map . get ( uri ) ; if ( resource info . is check required for group ( group name ) ) { final input stream input stream = locator factory . locate ( uri ) ; try { final string current hash = hash strategy . get hash ( input stream ) ; resource info . update hash for group ( current hash , group name ) ; } finally { io . close quietly ( input stream ) ; } } return resource info . is changed ( group name ) ; }	Check if an uri from a particular group has changed.
@ override public input stream locate ( final string uri ) throws io { valid state ( standalone context != null , str ) ; exception last exception = null ; final string [ ] context folders = standalone context . get context folders ( ) ; for ( final string context folder : context folders ) { try { return locate stream with context folder ( uri , context folder ) ; } catch ( final io e ) { last exception = e ; log . debug ( str , uri , context folder ) ; } } final string exception message = string . format ( str , uri , arrays . to string ( standalone context . get context folders ( ) ) ) ; throw new io ( exception message , last exception ) ; }	This implementation will try to locate the provided resource inside contextFolder configured by standaloneContext.If a resource cannot be located, the next contextFolder from the list will be tried.
private generic object pool < t > create object pool ( final object factory < t > object factory ) { final generic object pool < t > pool = new object pool ( object factory ) ; not null ( pool ) ; return pool ; }	Ensure that a not null pool will be created.
@ override public input stream locate stream ( final string uri , final file folder ) throws io { not null ( folder ) ; final file jar path = get jar file ( folder ) ; if ( is supported ( jar path ) ) { return locate stream from jar ( uri , jar path ) ; } return super . locate stream ( uri , folder ) ; }	Finds the specified URI pattern inside a JAR file.
jar file open ( final file jar file ) throws io { is true ( jar file . exists ( ) , str ) ; return new jar file ( jar file ) ; }	Opens the specified JAR file and returns a valid handle.
private string extract path ( final string uri ) { return default wildcard stream locator . strip query path ( uri . replace ( prefix , string utils . empty ) ) ; }	Replaces the protocol specific prefix and removes the query path if it exist, since it should not be accepted.
private boolean is minimized ( final http servlet request request ) { return context . get config ( ) . is minimize enabled ( ) ? group extractor . is minimized ( request ) : bool ; }	Uses isMinimizeEnabled configuration to compute minimize value.
public final simple uri locator factory add locator ( final uri locator ... locators ) { for ( final uri locator locator : locators ) { uri locators . add ( locator ) ; } return this ; }	Allow adding more than one uriLocators.
public static wro model factory decorate ( final wro model factory decorated , final list < transformer < wro model > > model transformers ) { return decorated instanceof default wro model factory decorator ? decorated : new default wro model factory decorator ( decorated , model transformers ) ; }	Factory method which takes care of redundant decoration.
public void add require ( final string require ) { if ( require != null && require . trim ( ) . length ( ) > num ) { requires . add ( require . trim ( ) ) ; } }	Adds a ruby require to the ruby script to be run by this RubySassEngine.
public string process ( final string content ) { if ( is empty ( content ) ) { return string utils . empty ; } try { synchronized ( this ) { return engine initializer . get ( ) . eval ( build update script ( content ) ) . to string ( ) ; } } catch ( final script exception e ) { throw new wro runtime exception ( e . get message ( ) , e ) ; } }	Transforms a sass content into css using Sass ruby engine.
public void log summary ( ) { final string message = total found errors == num ? str : string . format ( str , total found errors , total resources with errors ) ; log . info ( str ) ; log . info ( string . format ( str , total resources ) ) ; log . info ( message ) ; log . info ( str ) ; }	Logs the summary as it was collected at this point.
public synchronized void on processing resource ( final resource resource ) { total resources ++ ; log . debug ( str + resource . get uri ( ) ) ; if ( is log required ( ) ) { log . info ( str + get total resources ( ) + str + resource . get uri ( ) ) ; update last invocation ( ) ; } }	A method which should be invoked on each new resource processing, having as a side effect an increment of thecounter holding the number of total processed resources.
private read write lock get lock for key ( final k key ) { final read write lock lock = locks . put if absent ( key , new reentrant read write lock ( ) ) ; return lock == null ? locks . get ( key ) : lock ; }	Ensure that the returned lock will never be null.
private process create process ( final file source file ) throws io { not null ( source file ) ; final string [ ] command line = get command line ( source file . get path ( ) ) ; log . debug ( str , arrays . as list ( command line ) ) ; return new process builder ( command line ) . redirect error stream ( bool ) . start ( ) ; }	Creates process responsible for running lessc shell command by reading the file content from the sourceFilePath.
private property [ ] parse properties ( final string contents ) { final string [ ] parts = contents . split ( str ) ; final list < property > results as list = new array list < property > ( ) ; for ( string part : parts ) { try {	Parses out the properties of a selector's body.
public task info [ ] get task info ( ) { if ( ! this . keep task list ) { throw new unsupported operation exception ( str ) ; } return ( task info [ ] ) this . task list . to array ( new task info [ this . task list . size ( ) ] ) ; }	Return an array of the data for tasks performed.
private string get compilation command ( final string input ) { return string . format ( str , wro util . to js ( input ) , ecma script version ) ; }	Creates compilation command for provided typescript input.
private void parse header ( final string header ) { log . debug ( str , header ) ; final string header name = header . substring ( num , header . index of ( str ) ) ; if ( ! headers map . contains key ( header name ) ) { final string value = header . substring ( header . index of ( str ) + num ) ; headers map . put ( header name , string utils . trim ( value ) ) ; } }	Parse header value & puts the found values in headersMap field.
private static void add no cache headers ( final map < string , string > map ) { map . put ( http header . pragma . to string ( ) , str ) ; map . put ( http header . cache control . to string ( ) , str ) ; map . put ( http header . expires . to string ( ) , str ) ; }	Populates the map with headers used to disable cache.
public static string get path info from location ( final http servlet request request , final string location ) { if ( string utils . is empty ( location ) ) { throw new illegal argument exception ( str ) ; } final string context path = request . get context path ( ) ; if ( context path != null ) { if ( starts with ignore case ( location , context path ) ) { return location . substring ( context path . length ( ) ) ; } else { return location ; } } final string no slash = location . substring ( num ) ; final int next slash = no slash . index of ( str ) ; if ( next slash == - num ) { return str ; } return no slash . substring ( next slash ) ; }	Retrieve pathInfo from a given location.
public static string get servlet path from location ( final http servlet request request , final string location ) { return location . replace ( get path info from location ( request , location ) , string utils . empty ) ; }	Retrieve servletPath from a given location.
public static boolean matches url ( final http servlet request request , final string path ) { final pattern pattern = pattern . compile ( str + path + str , pattern . case insensitive ) ; if ( request . get request uri ( ) != null ) { final matcher m = pattern . matcher ( request . get request uri ( ) ) ; return m . matches ( ) ; } return bool ; }	Utility used to verify that requestURI matches provided path.
public static string load regexp with key ( final string key ) { input stream stream = null ; try { stream = wro util . class . get resource as stream ( str ) ; final properties props = new regexp properties ( ) . load ( stream ) ; return props . get property ( key ) ; } catch ( final io e ) { throw new wro runtime exception ( str + key + str , e ) ; } finally { close quietly ( stream ) ; } }	Load the regular expression stored in in regexp.properties resource file.
public static void safe copy ( final reader reader , final writer writer ) throws io { try { io . copy ( reader , writer ) ; } finally { io . close quietly ( reader ) ; io . close quietly ( writer ) ; } }	Copy and close the reader and writer streams.
public static file create temp file ( final string extension ) { try { final string file name = string . format ( str , uuid . random uuid ( ) . to string ( ) , extension ) ; final file file = new file ( create temp directory ( ) , file name ) ; file . create new file ( ) ; return file ; } catch ( final io e ) { throw wro runtime exception . wrap ( e ) ; } }	Creates a temp file which has a certain extension.
public static final string clean image url ( final string image url ) { not null ( image url ) ; return image url . replace ( str , str ) . replace ( str , str ) . trim ( ) ; }	Cleans the image url by trimming result and removing \' or \" characters if such exists.
final void set attribute ( final attribute attribute , final object object ) { validate . not null ( attribute ) ; log . debug ( str , attribute , object ) ; validate . is true ( attribute . is valid ( object ) , object + str + attribute ) ; servlet context . set attribute ( get attribute name ( attribute ) , object ) ; }	Sets the attribute into the servlet context.
public string generate data uri ( final input stream input stream , final string file name ) throws io { final string writer writer = new string writer ( ) ; final byte [ ] bytes = io . to byte array ( input stream ) ; input stream . close ( ) ; final string mime type = get mime type ( file name ) ;	Generate the dataUri as string associated to the passed InputStream with encoding & type based on providedfileName.
private void generate data uri ( final byte [ ] bytes , final writer out , final string mime type ) throws io {	Generates a data URI from a byte array and outputs to the given writer.
public static void set ( final context context , final wro configuration config ) { not null ( context ) ; not null ( config ) ; context . set config ( config ) ; final string correlation id = generate correlation id ( ) ; correlation id . set ( correlation id ) ; context map . put ( correlation id , context ) ; }	Associate a context with the CURRENT request cycle.
public static void unset ( ) { final string correlation id = correlation id . get ( ) ; if ( correlation id != null ) { context map . remove ( correlation id ) ; } correlation id . remove ( ) ; }	Remove context from the local thread.
public void check ( final cache key cache key , final callback callback ) { not null ( cache key ) ; log . debug ( str ) ; final stop watch watch = new stop watch ( ) ; watch . start ( str ) ; try { final group group = new wro model inspector ( model factory . create ( ) ) . get group by name ( cache key . get group name ( ) ) ; if ( is group changed ( group . collect resources of type ( cache key . get type ( ) ) , callback ) ) { callback . on group changed ( cache key ) ; cache strategy . put ( cache key , null ) ; } resource change detector . reset ( ) ; } catch ( final exception e ) { on exception ( e ) ; } finally { watch . stop ( ) ; log . debug ( str , watch . pretty print ( ) ) ; } }	Check if resources from a group were changed.
protected void on exception ( final exception e ) {	Invoked when exception occurs.
private void check resource change ( final resource resource , final group group , final callback callback , final atomic boolean is changed ) throws exception { if ( is changed ( resource , group . get name ( ) ) ) { is changed . compare and set ( bool , bool ) ; callback . on resource changed ( resource ) ; lifecycle callback . on resource changed ( resource ) ; } }	Will check if a given resource was changed and will invoke the appropriate callback.
public void update hash for group ( final string hash , final string group name ) { not null ( group name ) ; this . current hash = hash ; if ( is changed hash ( ) ) { log . debug ( str , group name ) ;	Updates the hash associated with the resource for a give groupName.
public final boolean has resources of type ( final resource type resource type ) { not null ( resource type , str ) ; for ( final resource resource : resources ) { if ( resource type . equals ( resource . get type ( ) ) ) { return bool ; } } return bool ; }	Check if the group has at least one resource of some type.
private process create process ( final file source file , final file dest file ) throws io { not null ( source file ) ; final string [ ] command line = get command line ( source file . get path ( ) , dest file . get path ( ) ) ; log . debug ( str , arrays . as list ( command line ) ) ; final process process = new process builder ( command line ) . redirect error stream ( bool ) . start ( ) ;	Creates process responsible for running tsc shell command by reading the file content from the sourceFilePath.
private collection < resource > parse group ( final element element ) { final string name = element . get attribute ( attr group name ) ; final string is abstract as string = element . get attribute ( attr group abstract ) ; final boolean is abstract group = string utils . is not empty ( is abstract as string ) && boolean . value of ( is abstract as string ) ; if ( groups in process . contains ( name ) ) { throw new recursive group definition exception ( str + name + str + groups in process ) ; } log . debug ( str , name ) ; groups in process . add ( name ) ;	Recursive method. Add the parsed element group to the group collection. If the group contains group-ref element,parse recursively this group.
protected group create group ( final element element ) { final string name = element . get attribute ( attr group name ) ; final group group = new group ( name ) ; final list < resource > resources = new array list < resource > ( ) ; final node list resource node list = element . get child nodes ( ) ; for ( int i = num ; i < resource node list . get length ( ) ; i ++ ) { final node node = resource node list . item ( i ) ; if ( node instanceof element ) { final element resource element = ( element ) node ; parse resource ( resource element , resources ) ; } } group . set resources ( resources ) ; return group ; }	Creates a group and all its associated resources.
private void parse resource ( final element resource element , final collection < resource > resources ) { final string tag name = resource element . get tag name ( ) ; final string uri = resource element . get text content ( ) ; if ( tag group ref . equals ( tag name ) ) {	Creates a resource from a given resourceElement.
private collection < resource > get resources for group ( final string group name ) { final wro model inspector model inspector = new wro model inspector ( model ) ; final group found group = model inspector . get group by name ( group name ) ; if ( found group == null ) { final element group element = all group elements . get ( group name ) ; if ( group element == null ) { throw new wro runtime exception ( str + group name ) ; } return parse group ( group element ) ; } return found group . get resources ( ) ; }	Search for all resources for a group with a given name.
public static long stop named timer ( string timer name , int todo flags , long thread id ) { elk timer key = new elk timer ( timer name , todo flags , thread id ) ; if ( registered timers . contains key ( key ) ) { return registered timers . get ( key ) . stop ( ) ; } else { return - num ; } }	Stop a timer of the given string name for the given thread.
public static elk timer get named timer ( string timer name , int todo flags ) { return get named timer ( timer name , todo flags , thread . current thread ( ) . get id ( ) ) ; }	Get a timer of the given string name and todos for the current thread.
public static elk timer get named timer ( string timer name , int todo flags , long thread id ) { elk timer key = new elk timer ( timer name , todo flags , thread id ) ; elk timer previous = registered timers . put if absent ( key , key ) ; if ( previous != null ) { return previous ; }	Get a timer of the given string name for the given thread.
public void print statistics ( ) { rule application factory . get saturation statistics ( ) . print ( logger ) ; if ( logger . is debug enabled ( ) ) { if ( aggregated stats . jobs submitted no > num ) logger . debug ( str , aggregated stats . jobs submitted no , aggregated stats . jobs already done no , aggregated stats . jobs processed no ) ; logger . debug ( str + aggregated stats . locks ) ; } }	Print statistics about the saturation.
private void wake up workers ( ) { if ( ! workers waiting ) { return ; } stop workers lock . lock ( ) ; try { workers waiting = bool ; there are contexts to process . signal all ( ) ; } finally { stop workers lock . unlock ( ) ; } }	waking up all workers waiting for new saturated contexts.
private void update processed counters ( int snapshot finished workers ) { if ( is interrupted ( ) ) { wake up workers ( ) ; return ; } if ( count started workers . get ( ) > snapshot finished workers ) { return ; } int snapshot count jobs submitted = count jobs submitted upper . get ( ) ; int snapshot count context non saturated = saturation state . get context mark non saturated count ( ) ; int snapshot count started workers = count started workers . get ( ) ; if ( snapshot count started workers > snapshot finished workers ) { return ; } if ( update if smaller ( count contexts saturated lower , snapshot count context non saturated ) ) { wake up workers ( ) ; } update if smaller ( count jobs processed lower , snapshot count jobs submitted ) ; }	Updates the counter for processed contexts and jobs.
private void update finished counters ( this statistics local statistics ) throws interrupted exception { int snapshot jobs processed = count jobs processed lower . get ( ) ; for ( ; ; ) { int snapshot count contexts saturated lower = count contexts saturated lower . get ( ) ; saturation state . set contexts saturated ( snapshot count contexts saturated lower ) ; if ( saturation state . get context set saturated count ( ) < snapshot count contexts saturated lower ) { return ; } int updated snapshot jobs processed = count jobs processed lower . get ( ) ; if ( updated snapshot jobs processed == snapshot jobs processed ) { break ; } snapshot jobs processed = updated snapshot jobs processed ; } for ( ; ; ) { int snapshot jobs finished = count jobs finished upper . get ( ) ; if ( snapshot jobs finished >= snapshot jobs processed ) { break ; } if ( ! count jobs finished upper . compare and set ( snapshot jobs finished , snapshot jobs finished + num ) ) { continue ; }	Check if the counter for saturated contexts and processed jobs can beincreased and post-process the finished jobs.
private static boolean update if smaller ( atomic integer counter , int value ) { for ( ; ; ) { int snapshot coutner = counter . get ( ) ; if ( snapshot coutner >= value ) return bool ; if ( counter . compare and set ( snapshot coutner , value ) ) return bool ; } }	Update the counter to the value provided it is greater.
protected < p > o default visit ( rule < p > rule , p premise , context premises premises , class inference producer producer ) { if ( logger . is trace enabled ( ) ) { logger . trace ( str , premise , rule , premises ) ; } return null ; }	The default implementation of all methods.
private void instert into taxonomy ( final indexed object property property ) { final map < indexed object property , elk object property > equivalent = collect equivalent ( property ) ; if ( equivalent == null ) {	Adds the specified object property into the taxonomy if it is not in ityet and sets its direct sub-properties if not set yet.
public synchronized void ensure loading ( ) throws elk exception { if ( ! is loading finished ( ) ) { if ( is incremental mode ( ) ) { if ( ! stage manager . incremental addition stage . is completed ( ) ) { complete ( stage manager . incremental addition stage ) ; } } else { if ( ! stage manager . context initialization stage . is completed ( ) ) { complete ( stage manager . context initialization stage ) ; } } logger . trace ( str ) ; stage manager . input loading stage . invalidate recursive ( ) ;	Flushes index, if needed, and completes loading if there is new input.Incremental mode should be changed only during completing loading.
private void restore saturation ( ) throws elk exception { ensure loading ( ) ; final boolean changed ; if ( is incremental mode ( ) ) { changed = ! stage manager . incremental taxonomy cleaning stage . is completed ( ) ; complete ( stage manager . incremental taxonomy cleaning stage ) ; } else { changed = ! stage manager . context initialization stage . is completed ( ) ; complete ( stage manager . context initialization stage ) ; } if ( changed ) { stage manager . consistency checking stage . invalidate recursive ( ) ; } }	Ensures that saturation is restored and taxonomies are cleaned.
public synchronized boolean is inconsistent ( ) throws elk exception { restore consistency check ( ) ; if ( ! consistency checking state . is inconsistent ( ) ) { incompleteness . log ( incompleteness . get incompleteness monitor for classification ( ) ) ; } return consistency checking state . is inconsistent ( ) ; }	Check consistency of the current ontology, if this has not been done yet.
protected taxonomy < elk class > restore taxonomy ( ) throws elk inconsistent ontology exception , elk exception { rule and conclusion stats . reset ( ) ;	Complete the taxonomy computation stage and the stages it depends on, ifit has not been done yet.
protected instance taxonomy < elk class , elk named individual > restore instance taxonomy ( ) throws elk inconsistent ontology exception , elk exception { rule and conclusion stats . reset ( ) ;	Completes instance taxonomy computation stage and the stages that itdepends on, if this has not been done yet.
public proof < ? extends entailment inference > get evidence ( final boolean at most one ) { return new proof < entailment inference > ( ) { @ suppress warnings ( str ) @ override public collection < ontology inconsistency entailment inference > get inferences ( final object conclusion ) { if ( ! ontology inconsistency impl . instance . equals ( conclusion ) ) { return collections . empty list ( ) ; }	Explains why an ontology inconsistency is entailed.
@ override public boolean pre execute ( ) { if ( is initialized ) return bool ; logger . trace ( str , this ) ; this . worker no = reasoner . get number of workers ( ) ; return is initialized = bool ; }	Initialize the parameters of the computation for this stage; this is thefirst thing to be done before stage is executed.
public void invalidate recursive ( ) { queue < abstract reasoner stage > to invalidate = new linked list < abstract reasoner stage > ( ) ; to invalidate . add ( this ) ; abstract reasoner stage next ; while ( ( next = to invalidate . poll ( ) ) != null ) { if ( next . invalidate ( ) ) { for ( abstract reasoner stage post stage : next . post stages ) { to invalidate . add ( post stage ) ; } } } }	Invalidates this stage and all subsequent stages if not already done so.
collection < indexed individual > get to add ( ) { if ( taxonomy == null ) {	Returns collection that contains at least all individuals that are inontology, but either are removed from taxonomy or their type nodes intaxonomy were removed.
collection < indexed individual > get to remove ( ) { if ( taxonomy == null ) {	Returns collection that contains at least all individuals that are intaxonomy, but either are removed from ontology or their context becamenot saturated.
private static unsupported operation exception unsupported owl api method ( string method ) { string message = str + method + str ; logger wrap . log ( logger , log level . warn , marker unsupported method , message ) ; return new unsupported operation exception ( message ) ; }	Logs a warning message for unsupported OWL API method.
static < e > void remove ( e [ ] d , int pos ) { for ( ; ; ) { int next = get moved position ( d , pos ) ; e moved = d [ pos ] = d [ next ] ; if ( moved == null ) return ;	Removes the element at the given position of the table shifting, ifnecessary, other elements so that all elements can be found by linearprobing.
static < k , v > void remove ( k [ ] k , v [ ] v , int pos ) { for ( ; ; ) { int next = get moved position ( k , pos ) ; k moved = k [ pos ] = k [ next ] ; v [ pos ] = v [ next ] ; if ( moved == null ) return ;	Removes the element at the given position of the table and thecorresponding value at the same position, shifting, if necessary, otherelements and values so that all elements can be found by linear probing.
static < e > int get moved position ( e [ ] d , int del ) { int j = del ; for ( ; ; ) { if ( ++ j == d . length ) j = num ;	Finds the position of the next element starting from the given positionthat would not be found by linear probing if the element at the givenposition are deleted.
static < e > boolean contains ( e [ ] d , object o ) { int pos = get position ( d , o ) ; if ( d [ pos ] == null ) return bool ;	Tests if the set represented by given data array contains a given object.
static < e > boolean add ( e [ ] d , e e ) { int pos = get position ( d , e ) ; if ( d [ pos ] == null ) { d [ pos ] = e ; return bool ; }	Adds the element to the set represented by given data array, if it didnot contain there already.
public final void check occurrence numbers ( ) { if ( logger . is trace enabled ( ) ) logger . trace ( to string ( ) + str + print occurrence numbers ( ) ) ; if ( positive occurrence no < num || negative occurrence no < num ) throw new elk unexpected indexing exception ( to string ( ) + str + print occurrence numbers ( ) ) ; }	verifies that occurrence numbers are not negative.
public synchronized void add ( class conclusion timer timer ) { this . time composed subsumers += timer . time composed subsumers ; this . time decomposed subsumers += timer . time decomposed subsumers ; this . time backward links += timer . time backward links ; this . time forward links += timer . time forward links ; this . time contradictions += timer . time contradictions ; this . time propagations += timer . time propagations ; this . time disjoint subsumers += timer . time disjoint subsumers ; this . time context initializations += timer . time context initializations ; this . time sub context initializations += timer . time sub context initializations ; }	Adds all timers of the argument to the corresponding counters of thisobject.
public synchronized void add ( rule application timer timer ) { time owl thing context init rule += timer . time owl thing context init rule ; time root context initialization rule += timer . time root context initialization rule ; time disjoint subsumer from member rule += timer . time disjoint subsumer from member rule ; time contradiction from negation rule += timer . time contradiction from negation rule ; time object intersection from first conjunct rule += timer . time object intersection from first conjunct rule ; time object intersection from second conjunct rule += timer . time object intersection from second conjunct rule ; time super class from sub class rule += timer . time super class from sub class rule ; time propagation from existential filler rule += timer . time propagation from existential filler rule ; time object union from disjunct rule += timer . time object union from disjunct rule ; time backward link chain from backward link rule += timer . time backward link chain from backward link rule ; time reflexive backward link composition rule += timer . time reflexive backward link composition rule ; time non reflexive backward link composition rule += timer . time non reflexive backward link composition rule ; time subsumer backward link rule += timer . time subsumer backward link rule ; time contradiction over backward link rule += timer . time contradiction over backward link rule ; time contradiction propagation rule += timer . time contradiction propagation rule ; time contradiction composition rule += timer . time contradiction composition rule ; time indexed object intersection of decomposition += timer . time indexed object intersection of decomposition ; time indexed object some values from decomposition += timer . time indexed object some values from decomposition ; time indexed object complement of decomposition += timer . time indexed object complement of decomposition ; time indexed object has self decomposition += timer . time indexed object has self decomposition ; time contradiction from owl nothing rule += timer . time contradiction from owl nothing rule ; time subsumer propagation rule += timer . time subsumer propagation rule ; time propagation initialization rule += timer . time propagation initialization rule ; time backward link from forward link rule += timer . time backward link from forward link rule ; time composed from decomposed subsumer rule += timer . time composed from decomposed subsumer rule ; time indexed class decomposition rule += timer . time indexed class decomposition rule ; time indexed class from definition rule += timer . time indexed class from definition rule ; time equivalent class first from second rule += timer . time equivalent class first from second rule ; time equivalent class second from first rule += timer . time equivalent class second from first rule ; }	Add the values the corresponding values of the given timer.
private static < k , v > v put key value ( k [ ] keys , v [ ] values , k key , v value ) { int pos = linear probing . get position ( keys , key ) ; if ( keys [ pos ] == null ) { keys [ pos ] = key ; values [ pos ] = value ; return null ; }	Associates the given key with the given value in the map defined by thekeys and value arrays.
private static < k , v > v remove entry ( k [ ] keys , v [ ] values , object key ) { int pos = linear probing . get position ( keys , key ) ; if ( keys [ pos ] == null ) return null ;	Remove the entry in the keys and values such that the key of the entry isequal to the given object according to the equality function.
private void enlarge ( ) { int old capacity = keys . length ; if ( old capacity == linear probing . maximum capacity ) throw new illegal argument exception ( str + linear probing . maximum capacity ) ; k old keys [ ] = keys ; v old values [ ] = values ; int new capacity = old capacity << num ; @ suppress warnings ( str ) k new keys [ ] = ( k [ ] ) new object [ new capacity ] ; @ suppress warnings ( str ) v new values [ ] = ( v [ ] ) new object [ new capacity ] ; for ( int i = num ; i < old capacity ; i ++ ) { k key = old keys [ i ] ; if ( key != null ) put key value ( new keys , new values , key , old values [ i ] ) ; } this . keys = new keys ; this . values = new values ; }	Increasing the capacity of the map.
private void shrink ( ) { int old capacity = keys . length ; if ( old capacity <= linear probing . default initial capacity ) return ; k old keys [ ] = keys ; v old values [ ] = values ; int new capacity = old capacity > > num ; @ suppress warnings ( str ) k new keys [ ] = ( k [ ] ) new object [ new capacity ] ; @ suppress warnings ( str ) v new values [ ] = ( v [ ] ) new object [ new capacity ] ; for ( int i = num ; i < old capacity ; i ++ ) { k key = old keys [ i ] ; if ( key != null ) put key value ( new keys , new values , key , old values [ i ] ) ; } this . keys = new keys ; this . values = new values ; }	Decreasing the capacity of the map.
public void save configuration ( file config on disk , base configuration config ) throws configuration exception , io { input stream stream = null ; base configuration loaded config = null ; properties disk props = new properties ( ) ; try { stream = new file input stream ( config on disk ) ; loaded config = get configuration ( stream , str , config . get class ( ) ) ;	Not a thread-safe method.
protected static void print declarations ( taxonomy < elk class > class taxonomy , elk object . factory object factory , appendable writer ) throws io { list < elk class > classes = new array list < elk class > ( class taxonomy . get nodes ( ) . size ( ) * num ) ; for ( taxonomy node < elk class > class node : class taxonomy . get nodes ( ) ) { for ( elk class clazz : class node ) { if ( ! clazz . get iri ( ) . equals ( predefined elk iris . owl thing ) && ! clazz . get iri ( ) . equals ( predefined elk iris . owl nothing ) ) { classes . add ( clazz ) ; } } } collections . sort ( classes , class comparator ) ; for ( elk class clazz : classes ) { elk declaration axiom decl = object factory . get declaration axiom ( clazz ) ; owl functional style printer . append ( writer , decl , bool ) ; writer . append ( str ) ; } }	Prints class declarations.
public static < t extends elk entity , i extends elk entity , tn extends generic type node < t , i , tn , in > , in extends generic instance node < t , i , tn , in > > set < ? extends in > get all instance nodes ( final generic type node < t , i , tn , in > node ) { return taxonomy node utils . collect from all reachable ( node . get direct sub nodes ( ) , node . get direct instance nodes ( ) , new operations . functor < generic type node < t , i , tn , in > , set < ? extends generic type node < t , i , tn , in > > > ( ) { @ override public set < ? extends tn > apply ( final generic type node < t , i , tn , in > node ) { return node . get direct sub nodes ( ) ; } } , new operations . functor < generic type node < t , i , tn , in > , set < ? extends in > > ( ) { @ override public set < ? extends in > apply ( final generic type node < t , i , tn , in > node ) { return node . get direct instance nodes ( ) ; } } ) ; }	Returns all instance nodes of the specified type node and all itssub-nodes.
@ override public void clear ( ) { mod count ++ ; e [ ] tab = buckets ; for ( int i = num ; i < tab . length ; i ++ ) tab [ i ] = null ; size = num ; }	Removes all entries from this set.
public static int combine list hash ( int ... hashes ) { int hash = num ; for ( int h : hashes ) { hash += h ; hash += ( hash << num ) ; hash ^= ( hash > > num ) ; } hash += ( hash << num ) ; hash ^= ( hash > > num ) ; hash += ( hash << num ) ; return hash ; }	Combine many hash codes into one in a way that depends on their order.The current implementation is based on the Jenkins One-at-a-Time hash,see http://www.burtleburtle.net/bob/hash/doobs.html and alsohttp://en.wikipedia.org/wiki/Jenkins_hash_function.
public static int copy ( input stream input , output stream output ) throws io { byte [ ] buffer = new byte [ buffer size ] ; buffered input stream in = new buffered input stream ( input , buffer size ) ; buffered output stream out = new buffered output stream ( output , buffer size ) ; int count = num , n = num ; try { while ( ( n = in . read ( buffer , num , buffer size ) ) != - num ) { out . write ( buffer , num , n ) ; count += n ; } out . flush ( ) ; } finally { io . close quietly ( in ) ; io . close quietly ( out ) ; } return count ; }	Copies bytes from the input stream to the output stream.
public incompleteness monitor get reasoner incompleteness monitor ( final incompleteness monitor ... additional monitors ) { final list < incompleteness monitor > monitors = new array list < incompleteness monitor > ( additional monitors . length + num ) ; monitors . add ( get incompleteness due to stated axioms monitor ( ) ) ; monitors . add all ( arrays . as list ( additional monitors ) ) ; return new delegating incompleteness monitor ( monitors ) { @ override public boolean log new incompleteness reasons ( final logger logger ) { final boolean result = super . log new incompleteness reasons ( logger ) ; if ( result ) { logger wrap . log ( logger , log level . warn , marker , str ) ; } return result ; } } ; }	Combines the provided partial incompleteness monitors into the top-levelmonitor for reasoning tasks.
protected static < t extends elk entity > void process taxomomy ( final taxonomy < t > taxonomy , final appendable writer ) throws io { final elk object . factory factory = new elk object entity recycling factory ( ) ;	Process a taxonomy and write a normalized serialization.
public synchronized boolean submit ( i input ) throws interrupted exception { if ( termination || is interrupted ( ) ) return bool ; buffer . put ( input ) ; return bool ; }	Submitting a new input for processing.
public static void append ( appendable appender , elk object elk object ) throws io { append ( appender , elk object , bool ) ; }	Printing an ELK Object through an appender.
private query state mark not computed ( final indexed class expression query class ) { final query state state = indexed . get ( query class ) ; if ( state == null || ! state . is computed ) { return null ; } state . is computed = bool ; if ( state . node != null ) { remove all related ( query class , state . node ) ; state . node = null ; } return state ; }	If the specified query was added to the index, this method marks it asnot-computed and deletes the query results.
@ override public synchronized void add direct type node ( final utn type node ) { logger . trace ( str , this , type node ) ; direct type nodes . add ( type node ) ; }	Add a direct super-class node.
protected static void check chain match ( final elk sub object property expression full chain , final int start pos ) {	some methods for checking correctness of arguments.
public static < i , o > set < o > map ( final set < ? extends i > input , final functor ex < i , o > functor ) { return new abstract set < o > ( ) { @ override public iterator < o > iterator ( ) { return new map iterator < i , o > ( input . iterator ( ) , functor ) ; } @ override public boolean contains ( object o ) { i element = functor . deapply ( o ) ; return element == null ? bool : input . contains ( element ) ; } @ override public int size ( ) { return input . size ( ) ; } } ; }	A simple second-order map function for sets.
public boolean add ( int s , e e ) { if ( e == null ) throw new null pointer exception ( ) ; int mask = ( num << s ) ; int old mask = add mask ( logs , data , masks , e , mask ) ; int new mask = old mask | mask ; if ( new mask == old mask ) return bool ; else if ( old mask == num && ++ occupied == linear probing . get upper size ( data . length ) ) enlarge ( ) ; sizes [ s ] ++ ; return bool ; }	Inserts a given element into the given slice.
public boolean remove ( int s , object o ) { if ( o == null ) throw new null pointer exception ( ) ; int mask = num << s ; int old mask = remove mask ( logs , data , masks , o , mask ) ; int new mask = old mask & ~ mask ; if ( new mask == old mask ) return bool ;	Removes the given object from the given slice.
public synchronized void add ( class conclusion counter counter ) { this . count sub class inclusion decomposed += counter . count sub class inclusion decomposed ; this . count sub class inclusion composed += counter . count sub class inclusion composed ; this . count backward link += counter . count backward link ; this . count forward link += counter . count forward link ; this . count contradiction += counter . count contradiction ; this . count propagation += counter . count propagation ; this . count disjoint subsumer += counter . count disjoint subsumer ; this . count context initialization += counter . count context initialization ; this . count sub context initialization += counter . count sub context initialization ; }	Adds all counters of the argument to the corresponding counters of thisobject.
public static void log memory usage ( logger logger , log level priority ) { if ( logger wrap . is enabled for ( logger , priority ) ) {	Log the current total memory usage with the specified priority.
public synchronized void set configuration options ( reasoner configuration config ) { this . worker no = config . get parameter as int ( reasoner configuration . num of working threads ) ; set allow incremental mode ( config . get parameter as boolean ( reasoner configuration . incremental mode allowed ) ) ; }	This supposed to be the central place where the reasoner gets itsconfiguration options.
public synchronized boolean shutdown ( long timeout , time unit unit ) throws interrupted exception { boolean success = bool ; if ( success ) { logger . info ( str ) ; } else { logger . error ( str ) ; } return success ; }	Tries to shut down the reasoner within the specified time.
public void print header ( ) { print separator ( ) ; add padding ( str , header params ) ; logger . debug ( string . format ( header format , header params ) ) ; print separator ( ) ; }	Prints the heading together with the separators.
public void print ( object ... values ) { add padding ( str , values ) ; logger . debug ( string . format ( values format , values ) ) ; }	Formats and the given values, adding padding symbols if necessary.
static string get string ( char c , int n ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < n ; i ++ ) { sb . append ( c ) ; } return sb . to string ( ) ; }	Creates a string of the given length consisting of the given character.
public synchronized void add ( rule counter counter ) { count owl thing context init rule += counter . count owl thing context init rule ; count root context initialization rule += counter . count root context initialization rule ; count disjoint subsumer from member rule += counter . count disjoint subsumer from member rule ; count contradiction from negation rule += counter . count contradiction from negation rule ; count object intersection from first conjunct rule += counter . count object intersection from first conjunct rule ; count object intersection from second conjunct rule += counter . count object intersection from second conjunct rule ; count super class from sub class rule += counter . count super class from sub class rule ; count propagation from existential filler rule += counter . count propagation from existential filler rule ; count object union from disjunct rule += counter . count object union from disjunct rule ; count backward link chain from backward link rule += counter . count backward link chain from backward link rule ; count subsumer backward link rule += counter . count subsumer backward link rule ; count contradiction over backward link rule += counter . count contradiction over backward link rule ; count contradiction propagation rule += counter . count contradiction propagation rule ; count contradiction composition rule += counter . count contradiction composition rule ; count non reflexive backward link composition rule += counter . count non reflexive backward link composition rule ; count indexed object intersection of decomposition += counter . count indexed object intersection of decomposition ; count indexed object some values from decomposition += counter . count indexed object some values from decomposition ; count indexed object complement of decomposition += counter . count indexed object complement of decomposition ; count indexed object has self decomposition += counter . count indexed object has self decomposition ; count contradiction from owl nothing rule += counter . count contradiction from owl nothing rule ; count subsumer propagation rule += counter . count subsumer propagation rule ; count reflexive backward link composition rule += counter . count reflexive backward link composition rule ; count propagation initialization rule += counter . count propagation initialization rule ; count backward link from forward link rule += counter . count backward link from forward link rule ; count composed from decomposed subsumer rule += counter . count composed from decomposed subsumer rule ; count indexed class decomposition rule += counter . count indexed class decomposition rule ; count indexed class from definition rule += counter . count indexed class from definition rule ; count equivalent class first from second rule += counter . count equivalent class first from second rule ; count equivalent class second from first rule += counter . count equivalent class second from first rule ; }	Add the values the corresponding values of the given counter.
private void write resource ( xhtml writer writer , object object ) { if ( object == null ) { return ; } try { if ( object instanceof resource ) { resource < ? > resource = ( resource < ? > ) object ; writer . begin list item ( ) ; write resource ( writer , resource . get content ( ) ) ; writer . write links ( resource . get links ( ) ) ; writer . end list item ( ) ; } else if ( object instanceof resources ) { resources < ? > resources = ( resources < ? > ) object ;	Recursively converts object to xhtml data.
@ override public action input parameter get action input parameter ( string name ) { action input parameter ret = request params . get ( name ) ; if ( ret == null ) { ret = path variables . get ( name ) ; } if ( ret == null ) { for ( action input parameter annotated parameter : get input parameters ( ) ) {	Gets input parameter info which is part of the URL mapping, be it request parameters, path variables or requestbody attributes.
property descriptor get property descriptor for property path ( string property path , class < ? > property type ) { int pos = property accessor utils . get first nested property separator index ( property path ) ;	Recursively navigate to return a BeanWrapper for the nested property path.
@ override public map < string , action input parameter > get required parameters ( ) { map < string , action input parameter > ret = new hash map < string , action input parameter > ( ) ; for ( map . entry < string , action input parameter > entry : request params . entry set ( ) ) { action input parameter annotated parameter = entry . get value ( ) ; if ( annotated parameter . is required ( ) ) { ret . put ( entry . get key ( ) , annotated parameter ) ; } } for ( map . entry < string , action input parameter > entry : path variables . entry set ( ) ) { action input parameter annotated parameter = entry . get value ( ) ; ret . put ( entry . get key ( ) , annotated parameter ) ; }	Determines action input parameters for required url variables.
public static boolean is single value type ( class < ? > clazz ) { boolean ret ; if ( is number ( clazz ) || is boolean ( clazz ) || is string ( clazz ) || is enum ( clazz ) || is date ( clazz ) || is calendar ( clazz ) || is currency ( clazz ) ) { ret = bool ; } else { ret = bool ; } return ret ; }	Determines if the given class holds only one data item.
public void add rel ( string rel ) { assert . has length ( rel ) ; link params . add ( rel . param name , rel ) ; }	The relation type of the link.
public void set type ( string media type ) { if ( media type != null ) link params . set ( type . param name , media type ) ; else link params . remove ( type . param name ) ; }	The "type" parameter, when present, is a hint indicating what the media type of the result of dereferencing thelink should be.
public void add hreflang ( string hreflang ) { assert . has length ( hreflang ) ; link params . add ( hreflang . param name , hreflang ) ; }	The "hreflang" parameter, when present, is a hint indicating what the language of the result of dereferencing thelink should be.
public void add rev ( string rev ) { assert . has length ( rev ) ; link params . add ( rev . param name , rev ) ; }	The "rev" parameter has been used in the past to indicate that the semantics of the relationship are in thereverse direction.
public void add link param ( string param name , string ... values ) { assert . not empty ( values ) ; for ( string value : values ) { assert . has length ( value ) ; link params . add ( param name , value ) ; } }	Adds link-extension params, i.e.
@ override public affordance expand ( map < string , ? extends object > arguments ) { uri template template = new uri template ( partial uri template . as components ( ) . to string ( ) ) ; string expanded = template . expand ( arguments ) . to ascii ( ) ; return new affordance ( expanded , link params , action descriptors ) ; }	Expands template variables, arguments must satisfy all required template variables, unsatisfied optionalarguments will be removed.
@ json ignore public list < string > get rels ( ) { final list < string > rels = link params . get ( rel . param name ) ; return rels == null ? collections . < string > empty list ( ) : collections . unmodifiable list ( rels ) ; }	Allows to retrieve all rels defined for this affordance.
@ json ignore public list < string > get revs ( ) { final list < string > revs = link params . get ( rev . param name ) ; return revs == null ? collections . < string > empty list ( ) : collections . unmodifiable list ( revs ) ; }	Retrieves all revs for this affordance.
@ json ignore public boolean has unsatisfied required variables ( ) { for ( action descriptor action descriptor : action descriptors ) { map < string , action input parameter > required parameters = action descriptor . get required parameters ( ) ; for ( action input parameter annotated parameter : required parameters . values ( ) ) { if ( ! annotated parameter . has value ( ) ) { return bool ; } } } return bool ; }	Determines if the affordance has unsatisfied required variables.
public string get value formatted ( ) { string ret ; if ( value == null ) { ret = null ; } else { ret = ( string ) conversion service . convert ( value , type descriptor , type descriptor . value of ( string . class ) ) ; } return ret ; }	The value of the parameter at sample invocation time, formatted according to conversion configuration.
@ override public boolean is hidden ( string property ) { annotation [ ] param annotations = method parameter . get parameter annotations ( ) ; input input annotation = method parameter . get parameter annotation ( input . class ) ; return input annotation != null && array contains ( input annotation . hidden ( ) , property ) ; }	Determines if request body input parameter has a hidden input property.
private boolean contains property include value ( string property ) { return array contains ( input annotation . read only ( ) , property ) || array contains ( input annotation . hidden ( ) , property ) || array contains ( input annotation . include ( ) , property ) ; }	Find out if property is included by searching through all annotations.
private boolean has explicit or implicit property include value ( ) {	Has any explicit include value or might have implicit includes because there is a hidden or readOnly flag.
public boolean is required ( ) { boolean ret ; if ( is request body ( ) ) { ret = request body . required ( ) ; } else if ( is request param ( ) ) { ret = ! ( is defined ( request param . default value ( ) ) || ! request param . required ( ) ) ; } else if ( is request header ( ) ) { ret = ! ( is defined ( request header . default value ( ) ) || ! request header . required ( ) ) ; } else { ret = bool ; } return ret ; }	Is this action input parameter required, based on the presence of a default value, the parameter annotations andthe kind of input parameter.
public string get default value ( ) { string ret ; if ( is request param ( ) ) { ret = is defined ( request param . default value ( ) ) ? request param . default value ( ) : null ; } else if ( is request header ( ) ) { ret = ! ( value constants . default none . equals ( request header . default value ( ) ) ) ? request header . default value ( ) : null ; } else { ret = null ; } return ret ; }	Determines default value of request param or request header, if available.
@ override public string get parameter name ( ) { string ret = null ; if ( request param != null ) { string request param name = request param . value ( ) ; if ( ! request param name . is empty ( ) ) ret = request param name ; } if ( path variable != null ) { string path variable name = path variable . value ( ) ; if ( ! path variable name . is empty ( ) ) ret = path variable name ; } if ( ret == null ) { string parameter name = method parameter . get parameter name ( ) ; if ( parameter name == null ) { method parameter . init parameter name discovery ( new local variable table parameter name discoverer ( ) ) ; ret = method parameter . get parameter name ( ) ; } else { ret = parameter name ; } } return ret ; }	Gets request parameter name of this action input parameter.
private string get exposed property or param name ( action input parameter input parameter ) { final expose expose = input parameter . get annotation ( expose . class ) ; string property ; if ( expose != null ) { property = expose . value ( ) ; } else { property = input parameter . get parameter name ( ) ; } return property ; }	Gets exposed property or parameter name.
public string get vocab ( mixin source mixin source , object bean , class < ? > mix in class ) { if ( proxy unwrapper != null ) { bean = proxy unwrapper . unwrap proxy ( bean ) ; }	Gets vocab for given bean.
public string get query ( ) { string builder query = new string builder ( ) ; if ( query tail . length ( ) > num ) { if ( query head . length ( ) == num ) { query . append ( str ) . append ( query tail ) . append ( str ) ; } else if ( query head . length ( ) > num ) { query . append ( query head ) . append ( str ) . append ( query tail ) . append ( str ) ; } } else { query . append ( query head ) ; } return query . to string ( ) ; }	Query consisting of expanded parameters and unexpanded parameters.
private void append form ( affordance affordance , action descriptor action descriptor ) throws io { string form name = action descriptor . get action name ( ) ; request method http method = request method . value of ( action descriptor . get http method ( ) ) ;	Appends form and squashes non-GET or POST to POST.
private void input button ( type type , string value ) throws io { write ( str ) ; write ( type . to string ( ) ) ; write ( str ) ; write ( str ) ; write ( str ) ; quote ( ) ; write ( value ) ; quote ( ) ; write ( str ) ; }	Classic submit or reset button.
private void append input or select ( action input parameter parent input parameter , string param name , action input parameter child input parameter , object [ ] possible values ) throws io { if ( possible values . length > num ) { if ( child input parameter . is array or collection ( ) ) {	Appends simple input or select, depending on availability of possible values.
public affordance builder and ( affordance builder affordance builder ) { for ( action descriptor action descriptor : affordance builder . action descriptors ) { this . action descriptors . add ( action descriptor ) ; } return this ; }	Adds actionDescriptors of the given AffordanceBuilder to this affordanceBuilder.
public partial uri template components as components ( ) { return get uri template components ( collections . < string , object > empty map ( ) , collections . < string > empty list ( ) ) ; }	Returns the template as uri components, without variable expansion.
public partial uri template components strip optional variables ( list < action descriptor > action descriptors ) { return get uri template components ( collections . < string , object > empty map ( ) , get required arg names ( action descriptors ) ) ; }	Strips all variables which are not required by any of the given action descriptors.
public uber node get first by name ( string name ) {	Gets first child of this uber node having the given name attribute.
public uber node get first by rel ( string rel ) {	Gets first child of this uber node having the given rel attribute.
@ override public iterator < uber node > iterator ( ) { return new iterator < uber node > ( ) { int index = num ; @ override public void remove ( ) { throw new unsupported operation exception ( str ) ; } @ override public uber node next ( ) { index = find next child with data ( ) ; return data . get ( index ++ ) ; } @ override public boolean has next ( ) { return find next child with data ( ) != - num ; } private int find next child with data ( ) { for ( int i = index ; i < data . size ( ) ; i ++ ) { if ( ! data . get ( i ) . get data ( ) . is empty ( ) ) { return i ; } } return - num ; } } ; }	Allows iterating over children of this uber node which have a data attribute.
@ suppress warnings ( str ) public static < k , v > persistent hash map < k , v > of eq ( equator < k > eq , iterable < map . entry < k , v > > es ) { if ( es == null ) { return empty ( eq ) ; } mutable hash map < k , v > map = empty mutable ( eq ) ; for ( map . entry < k , v > entry : es ) { if ( entry != null ) { map . assoc ( entry . get key ( ) , entry . get value ( ) ) ; } } return map . immutable ( ) ; }	Returns a new PersistentHashMap of the given keys and their paired values, skipping any nullEntries.
public static < k extends comparable < k > , v > persistent tree map < k , v > of ( iterable < map . entry < k , v > > es ) { if ( es == null ) { return empty ( ) ; } persistent tree map < k , v > map = new persistent tree map < > ( equator . default comparator ( ) , null , num ) ; for ( map . entry < k , v > entry : es ) { if ( entry != null ) { map = map . assoc ( entry . get key ( ) , entry . get value ( ) ) ; } } return map ; }	Returns a new PersistentTreeMap of the given comparable keys and their paired values, skippingany null Entries.
public static < k , v > persistent tree map < k , v > empty ( comparator < ? super k > c ) { return new persistent tree map < > ( c , null , num ) ; }	Returns a new empty PersistentTreeMap that will use the specified comparator.
@ override public im sorted set < entry < k , v > > entry set ( ) {	Returns a view of the mappings contained in this map.
@ override public k last key ( ) { un entry < k , v > max = last ( ) ; if ( max == null ) { throw new no such element exception ( str ) ; } return max . get key ( ) ; }	Returns the last key in this map or throws a NoSuchElementException if the map is empty.
@ suppress warnings ( str ) private static < h > h fold ( iterable source , operation [ ] ops , int op idx , h ident , fn2 reducer ) { object ret = ident ;	than lazily evaluated and cached linked-list, Sequence model.
@ override public xform < a > drop while ( fn1 < ? super a , boolean > predicate ) { if ( predicate == null ) { throw new illegal argument exception ( str ) ; } return new drop while desc < > ( this , predicate ) ; }	The number of items to drop from the beginning of the output.
@ override public < b > b fold ( b ident , fn2 < ? super b , ? super a , b > reducer ) { if ( reducer == null ) { throw new illegal argument exception ( str ) ; }	Provides a way to collect the results of the transformation.
public static < k , v > tuple2 < k , v > of ( map . entry < k , v > entry ) {	Map.Entry factory method.
@ suppress warnings ( str ) public < r > r match ( fn1 < a , r > fa , fn1 < b , r > fb , fn1 < c , r > fc ) { if ( sel == num ) { return fa . apply ( ( a ) item ) ; } else if ( sel == num ) { return fb . apply ( ( b ) item ) ; } else { return fc . apply ( ( c ) item ) ; } }	If sel is managed correctly, it ensures that the cast is accurate.
public static im list < class > register classes ( class ... cs ) { if ( cs == null ) { throw new illegal argument exception ( str ) ; } if ( cs . length == num ) { throw new illegal argument exception ( str ) ; } for ( class c : cs ) { if ( c == null ) { throw new illegal argument exception ( str ) ; } } array holder < class > ah = new array holder < > ( cs ) ; im list < class > registered types ; synchronized ( lock . instance ) { registered types = type map . get ( ah ) ; if ( registered types == null ) { im list < class > vec cs = vec ( cs ) ; type map . put ( ah , vec cs ) ; registered types = vec cs ; } }	Use this to prevent duplicate runtime types.
@ override public e get ( int i ) { e [ ] node = leaf node array for ( i ) ; return node [ i & low bits ] ; }	Returns the item specified by the given index.
@ suppress warnings ( str ) @ override public persistent vector < e > append ( e val ) {	Inserts a new item at the end of the Vecsicle.
@ override public persistent vector < e > concat ( iterable < ? extends e > items ) { return ( persistent vector < e > ) im list . super . concat ( items ) ; }	Efficiently adds items to the end of this PersistentVector.
@ safe varargs public static < t > mutable set < t > mutable set ( t ... items ) { mutable set < t > ret = persistent hash set . empty mutable ( ) ; if ( items == null ) { return ret ; } for ( t t : items ) { ret . put ( t ) ; } return ret ; }	Returns a new MutableSet of the values.
@ safe varargs public static < t > mutable list < t > mutable vec ( t ... items ) { mutable list < t > ret = persistent vector . empty mutable ( ) ; if ( items == null ) { return ret ; } for ( t t : items ) { ret . append ( t ) ; } return ret ; }	Returns a MutableVector of the given items.
@ safe varargs public static < t > im set < t > set ( t ... items ) { if ( ( items == null ) || ( items . length < num ) ) { return persistent hash set . empty ( ) ; } return persistent hash set . of ( arrays . as list ( items ) ) ; }	Returns a new PersistentHashSet of the values.
@ safe varargs static public < t > im list < t > vec ( t ... items ) { if ( ( items == null ) || ( items . length < num ) ) { return persistent vector . empty ( ) ; } return mutable vec ( items ) . immutable ( ) ; }	Returns a new PersistentVector of the given items.
@ safe varargs public static < t > unmod iterable < t > xform array ( t ... items ) { return xform . of ( arrays . as list ( items ) ) ; }	If you need to wrap a regular Java array outside this project to performa transformation on it, this method is the most convenient, efficient way to do so.
public static string builder indent space ( int len ) { string builder s b = new string builder ( ) ; if ( len < num ) { return s b ; } while ( len > spaces length minus one ) { s b . append ( spaces [ spaces length minus one ] ) ; len = len - spaces length minus one ; } return s b . append ( spaces [ len ] ) ; }	Creates a new StringBuilder with the given number of spaces and returns it.
public static < t > string array string ( t [ ] items ) { string builder s b = new string builder ( str ) ; boolean is first = bool ; for ( t item : items ) { if ( is first ) { is first = bool ; } else { s b . append ( str ) ; } if ( item instanceof string ) { s b . append ( str ) . append ( item ) . append ( str ) ; } else { s b . append ( item ) ; } } return s b . append ( str ) . to string ( ) ; }	There is Arrays.toString, but this is intended to produce Cymling code some day.
public static < t > lazy ref < t > of ( fn0 < t > producer ) { if ( producer == null ) { throw new illegal argument exception ( str ) ; } return new lazy ref < > ( producer ) ; }	Construct a LazyRef from the given initialization function.
public synchronized t apply ex ( ) {	This whole method is synchronized on the advice of Goetz2006 p. 347.
public static < t > t [ ] insert into array at ( t item , t [ ] items , int idx , class < t > t class ) {	Returns a new array one longer than the given one, with the specified item inserted at the specified index.
public static < t > t [ ] array copy ( t [ ] items , int length , class < t > t class ) {	Returns a new array containing the first n items of the given array.
private void suspend if assoaciated with thread ( ) throws system exception {	Some operations require that the transaction be suspended.
private void before async operation ( ) throws illegal state exception , security exception { try { int status = transaction . get status ( ) ; if ( async operation initiated . get and set ( bool ) || ( status != status . status active && status != status . status marked rollback ) ) { throw new illegal state exception ( str + status ) ; } suspend if assoaciated with thread ( ) ; } catch ( system exception e ) { throw new illegal state exception ( e ) ; } }	Verifies if the wrapped transaction is active and if dissociates it fromthe thread if needed.
public list < service component impl > build components ( string service descriptor file name , jar file deployable unit jar ) throws deployment exception {	Builds a service component contained in the specified du jar file, with the specified and adds it to the specified deployable unit.
static private void validate directory ( file a directory ) throws file not found exception { if ( a directory == null ) { throw new illegal argument exception ( str ) ; } if ( ! a directory . exists ( ) ) { throw new file not found exception ( str + a directory ) ; } if ( ! a directory . is directory ( ) ) { throw new illegal argument exception ( str + a directory ) ; } if ( ! a directory . can read ( ) ) { throw new illegal argument exception ( str + a directory ) ; } }	Directory is valid if it exists, does not represent a file, and can be read.
public static void create inheritance link ( ct class concrete class , ct class super class ) { if ( super class == null ) return ; try { concrete class . set superclass ( super class ) ; logger . trace ( concrete class . get name ( ) + str + super class . get name ( ) + str ) ; } catch ( cannot compile exception cce ) { cce . print stack trace ( ) ; } }	Create the inheritance link with the sbb absract class provided by thesbb developer.
public static void copy methods ( ct class source , ct class destination , ct class [ ] exceptions ) { copy methods ( source . get declared methods ( ) , destination , exceptions ) ; }	Copy declared methods from one class to another.
public static void copy methods ( ct method [ ] methods , ct class destination , ct class [ ] exceptions ) { ct method method copy = null ; for ( ct method method : methods ) { try { method copy = new ct method ( method , destination , null ) ; if ( exceptions != null ) { try { method copy . set exception types ( exceptions ) ; } catch ( not found exception e ) { throw new slee ( e . get message ( ) , e ) ; } } destination . add method ( method copy ) ; } catch ( cannot compile exception e ) { throw new slee ( e . get message ( ) , e ) ; } } }	Copy methods to a class.
private void remove sbb entity with current class loader ( final sbb entity sbb entity ) {	Removes the specified sbb entity but without changing to sbb's classloader first.
public boolean get notifications enabled ( string param name ) { boolean are notifications enabled = param names . get ( param name ) ; if ( ! is slee11 ) { if ( are notifications enabled == null || are notifications enabled . boolean value ( ) ) {	Indicates if notifications are enabled for the specified parameter name.
public set < string > get referenced ra ( service component service component ) { set < string > result = new hash set < string > ( ) ; set < string > ra link names = slee container . get resource management ( ) . get link names set ( ) ; for ( string ra link : service component . get resource adaptor entity links ( component repository impl ) ) { if ( ! ra link names . contains ( ra link ) ) { result . add ( ra link ) ; } } return result ; }	Retrieves the set of ra entity link names referenced by the servicecomponen, which do not exist.
public void install service ( final service component service component ) throws exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + service component ) ; }	Install a service into SLEE.
public void uninstall service ( final service component service component ) throws system exception , unrecognized service exception , instance not found exception , m , null pointer exception , unrecognized resource adaptor entity exception , management exception , invalid state exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + service component . get service id ( ) ) ; } if ( service component . get service state ( ) . is stopping ( ) ) {	uninstall a service.
public boolean is ra ( string ra link name ) { if ( ra link name == null ) { throw new null pointer exception ( str ) ; } boolean b = bool ; try { b = transaction manager . require transaction ( ) ; for ( id service id : component repository impl . get service i ( ) ) { service component service component = component repository impl . get component by id ( service id ) ; if ( service component . get service state ( ) != service state . inactive && service component . get resource adaptor entity links ( component repository impl ) . contains ( ra link name ) ) { return bool ; } } return bool ; } finally { try { transaction manager . require transaction end ( b , bool ) ; } catch ( throwable ex ) { throw new slee ( ex . get message ( ) , ex ) ; } } }	Verifies if the specified ra entity link name is referenced by a noninactive service.
public synchronized string [ ] get usage parameter sets ( id sbb id ) throws null pointer exception , unrecognized sbb exception , invalid argument exception , management exception { if ( sbb id == null ) throw new null pointer exception ( str ) ;	This method returns a list containing the names of the named SBB usageparameter sets that belong to the SBB specified by the sbbID argument andthe Service represented by the ServiceUsageMBean object.
public synchronized void reset all usage parameters ( ) throws management exception { try {	Resets the usage parameters of all SBBs within the Service represented bythe ServiceUsageMBean object.
public void display result ( ) {	Method to display result of operation.
protected string unfold array ( string prefix , object [ ] array , property editor editor ) {	Default implementation.
void execute ( final activity handle real handle , final activity handle ref handle , final fireable event type event type , final object event , final address address , final receivable service receivable service , final int event flags ) throws activity is ending exception , fire event exception , slee , unrecognized activity handle exception { final slee transaction tx = super . suspend transaction ( ) ; try { slee endpoint . fire event ( real handle , ref handle , event type , event , address , receivable service , event flags , tx ) ; } finally { if ( tx != null ) { super . resume transaction ( tx ) ; } } }	Executes a non transacted fire event operation.
public void bind name ( object ach , string name ) throws name already bound exception { final node node = get node ( ) ; if ( node . has child ( name ) ) { throw new name already bound exception ( str ) ; } else { node . add child ( fqn . from elements ( name ) ) . put ( cache node map key , ach ) ; } }	Binds the specified aci name with the specified activity context handle.
public object unbind name ( string name ) throws name not bound exception { final node node = get node ( ) ; final node child node = node . get child ( name ) ; if ( child node == null ) { throw new name not bound exception ( str ) ; } else { final object ach = child node . get ( cache node map key ) ; node . remove child ( name ) ; return ach ; } }	Unbinds the specified aci name with the specified activity context id.
public object lookup name ( string name ) { final node child node = get node ( ) . get child ( name ) ; if ( child node == null ) { return null ; } else { return child node . get ( cache node map key ) ; } }	Lookup of the activity context id bound to the specified aci name.
public map get name bindings ( ) { map result = new hash map ( ) ; node child node = null ; object name = null ; for ( object obj : get node ( ) . get children ( ) ) { child node = ( node ) obj ; name = child node . get fqn ( ) . get last element ( ) ; result . put ( name , child node . get ( cache node map key ) ) ; } return result ; }	Retrieves a map of the bindings. Key is the aci name and Value is the activity context handle.
public result next ( activity context ac , event context slee event , set < id > sbb entities that handled current event , slee container slee container ) { id sbb entity id = null ; sbb entity sbb entity = null ; event entry descriptor m event entry = null ;	Retrieves the next sbb entity to handle the event.
public boolean is higher level ( trace level other ) throws null pointer exception { if ( other == null ) throw new null pointer exception ( str ) ; return this . level < other . level ; }	Determine if this TraceLevel object represents a level that is higher than some otherTraceLevel object.
private void extract jar ( jar file jar file , file dst dir ) throws deployment exception {	This method will extract all the files in the jar file.
private void pipe stream ( input stream is , output stream os ) throws io { synchronized ( buffer ) { try { for ( int bytes read = is . read ( buffer ) ; bytes read != - num ; bytes read = is . read ( buffer ) ) os . write ( buffer , num , bytes read ) ; is . close ( ) ; os . close ( ) ; } catch ( io ioe ) { try { is . close ( ) ; } catch ( exception ioexc ) { } try { os . close ( ) ; } catch ( exception ioexc ) { } throw ioe ; } } }	Pipes data from the input stream into the output stream.
@ suppress warnings ( str ) public object put object ( object key , object value ) { return get node ( ) . put ( key , value ) ; }	Puts an object in cache data.
public boolean attach sbb entity ( id sbb entity id ) { final node node = get attached sbbs node ( bool ) ; if ( ! node . has child ( sbb entity id ) ) { node . add child ( fqn . from elements ( sbb entity id ) ) ; return bool ; } else { return bool ; } }	Tries to attaches an sbb entity.
public boolean detach sbb entity ( id sbb entity id ) { final node node = get attached sbbs node ( bool ) ; return node != null ? node . remove child ( sbb entity id ) : bool ; }	Detaches an sbb entity.
public boolean no sbb entities attached ( ) { final node node = get attached sbbs node ( bool ) ; return node != null ? node . get children names ( ) . is empty ( ) : bool ; }	Verifies if there at least one sbb entity attached.
@ suppress warnings ( str ) public set < id > get sbb entities attached ( ) { final node node = get attached sbbs node ( bool ) ; return node != null ? node . get children names ( ) : collections . empty set ( ) ; }	Return a set with all sbb entities attached.
public boolean attach timer ( id timer id ) { final node node = get attached timers node ( bool ) ; if ( ! node . has child ( timer id ) ) { node . add child ( fqn . from elements ( timer id ) ) ; return bool ; } else { return bool ; } }	Attaches a timer.
public boolean detach timer ( id timer id ) { final node node = get attached timers node ( bool ) ; return node != null ? node . remove child ( timer id ) : bool ; }	Detaches a timer.
public boolean no timers attached ( ) { final node node = get attached timers node ( bool ) ; return node != null ? node . get children names ( ) . is empty ( ) : bool ; }	Verifies if there at least one timer attached.
public set get attached timers ( ) { final node node = get attached timers node ( bool ) ; return node != null ? node . get children names ( ) : collections . empty set ( ) ; }	Returns the set of timers attached to the ac.
public void name bound ( string name ) { final node node = get names bound node ( bool ) ; if ( ! node . has child ( name ) ) { node . add child ( fqn . from elements ( name ) ) ; } }	Adds the specified name to the set of names bound to the ac.
public boolean name unbound ( string name ) { final node node = get names bound node ( bool ) ; return node != null ? node . remove child ( name ) : bool ; }	Removes the specified name from the set of names bound to the ac.
public boolean no names bound ( ) { final node node = get names bound node ( bool ) ; return node != null ? node . get children names ( ) . is empty ( ) : bool ; }	Verifies if there at least one name bound to the ac.
public set get names bound copy ( ) { final node node = get names bound node ( bool ) ; return node != null ? node . get children names ( ) : collections . empty set ( ) ; }	Returns the set of names bound to the ac.
@ suppress warnings ( str ) public void set cmp attribute ( string attr name , object attr value ) { final node node = get cmp attributes node ( bool ) ; node cmp node = node . get child ( attr name ) ; if ( cmp node == null ) { cmp node = node . add child ( fqn . from elements ( attr name ) ) ; } cmp node . put ( cmp attributes node map key , attr value ) ; }	Sets the aci cmp attribute.
@ suppress warnings ( str ) public object get cmp attribute ( string attr name ) { final node node = get cmp attributes node ( bool ) ; if ( node == null ) { return null ; } else { final node cmp node = node . get child ( attr name ) ; if ( cmp node != null ) { return cmp node . get ( cmp attributes node map key ) ; } else { return null ; } } }	Retrieves the aci cmp attribute.
@ suppress warnings ( str ) public map get cmp attributes copy ( ) { final node node = get cmp attributes node ( bool ) ; if ( node == null ) { return collections . empty map ( ) ; } else { map result = new hash map ( ) ; node cmp node = null ; for ( object obj : node . get children ( ) ) { cmp node = ( node ) obj ; result . put ( cmp node . get fqn ( ) . get last element ( ) , cmp node . get ( cmp attributes node map key ) ) ; } return result ; } }	Retrieves a map copy of the aci attributes set.
private static m [ ] init notification info ( ) { string [ ] notification types = new string [ ] { profile table notification . usage notification type , resource adaptor entity notification . usage notification type , sbb notification . usage notification type , subsystem notification . usage notification type } ; return new m [ ] { new m ( notification types , usage notification . class . get name ( ) , str ) } ; }	Initiates the notification info for usage mbeans.
public void send usage notification ( long value , long seqno , string usage parameter set name , string usage parameter name , boolean is counter ) { m notification manager = parent . get usage notification manager m ( notification source ) ; if ( notification manager == null || notification manager . get notifications enabled ( usage parameter name ) ) {	Send the notification.
private file download remote du ( url du url , file deployment root ) throws exception { input stream in = null ; output stream out = null ; try {	Downloads a remote DU to a local folder.
public void update deployed components ( ) { try {	Updates the list of components already deployed to SLEE.
public void install deployable unit ( deployable unit du ) throws exception {	Method for installing a Deployable Unit into SLEE.
public void uninstall deployable unit ( deployable unit du ) throws exception {	Method for uninstalling a Deployable Unit into SLEE.
private void process internal undeploy ( deployable unit du ) throws exception {	Sets the DU as not installed and remove it from waiting list if present there.Also, tries to undeploy DU's waiting for dependencies to be removed.
public string show status ( ) {	Method for showing current status of the Deployment Manager.
public boolean is loggable ( log record record ) { logger logger = get logger ( record ) ; if ( record . get thrown ( ) != null ) { log with throwable ( logger , record ) ; } else { log without throwable ( logger , record ) ; } return bool ; }	If the message should be logged, convert the JDK 1.4LogRecord to a Log4J message.
private logger get logger ( log record record ) { string logger name = record . get logger name ( ) ; logger logger = logger cache . get ( logger name ) ; if ( logger == null ) { logger = logger . get logger ( logger name ) ; logger cache . put ( logger name , logger ) ; } return logger ; }	get the Log4J logger corresponding to the java.util.logger.LogRecord.
public set < id > get sbb entities ( ) { final node node = get node ( ) ; if ( node == null ) { return collections . empty set ( ) ; } hash set < id > result = new hash set < id > ( ) ; id service id = null ; for ( object obj : node . get children names ( ) ) { service id = ( id ) obj ; for ( id sbb entity id : get root sbb entity i ( service id ) ) { result . add ( sbb entity id ) ; collect sbb entities ( sbb entity id , result ) ; } } return result ; }	Retrieves a set containing sbb entity ids in the factorycache data.
private permissions get permissions ( permissions permissions , final code source cs , principal [ ] principals ) { list < policy holder entry > entries = this . current policy . get ( ) . policy holder entries ; for ( policy holder entry phe : entries ) {	generic, for all calls.
public string get code sources ( ) { list < string > css = new array list < string > ( ) ; for ( policy holder entry phe : this . current policy . get ( ) . policy holder entries ) { css . add ( phe . get code source ( ) . get location ( ) == null ? str : phe . get code source ( ) . get location ( ) . to string ( ) ) ; } return arrays . to string ( css . to array ( ) ) ; }	Some methods to expose info about what is goign on.
public boolean profile exists ( string profile name ) { boolean result = component . get profile entity framework ( ) . find profile ( this . get profile table name ( ) , profile name ) != null ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + profile name + ( result ? str : str ) + str + this . get profile table name ( ) ) ; } return result ; }	Determines if profile is in back end storage == visible to othercompoenents than MBean, if null is passed as argumetn it must check forany other than defualt?.
public void remove ( boolean is uninstall ) throws slee { if ( logger . is trace enabled ( ) ) { logger . trace ( str + profile table name ) ; }	Triggers remove operation on this profile table.
public void update configuration properties ( config properties properties ) throws invalid configuration exception , invalid state exception { if ( ! component . get descriptor ( ) . get supports active reconfiguration ( ) && ( slee container . get slee state ( ) != slee state . stopped ) && ( state == resource adaptor entity state . active || state == resource adaptor entity state . stopping ) ) { throw new invalid state exception ( str ) ; } else { object . ra configuration update ( properties ) ; } }	Updates the ra entity config properties.
@ suppress warnings ( { str , str } ) public void slee running ( ) throws invalid state exception {	Signals that the container is in RUNNING state.
public void slee stopping ( ) throws invalid state exception , transaction required local exception { if ( state != null && state . is active ( ) ) { try { object . ra stopping ( ) ; } catch ( throwable t ) { logger . error ( str , t ) ; } schedule all activities end ( ) ; } }	Signals that the container is in STOPPING state.
@ suppress warnings ( { str , str } ) public void activate ( ) throws invalid state exception { if ( ! this . state . is inactive ( ) ) { throw new invalid state exception ( str + name + str + this . state ) ; } this . state = resource adaptor entity state . active ;	Activates the ra entity.
public void deactivate ( ) throws invalid state exception , transaction required local exception { if ( ! this . state . is active ( ) ) { throw new invalid state exception ( str + name + str + this . state ) ; } this . state = resource adaptor entity state . stopping ; if ( object . get state ( ) == resource adaptor object state . active ) { object . ra stopping ( ) ; }	Deactivates the ra entity.
private void schedule all activities end ( ) throws transaction required local exception {	schedules the ending of all the entity activities, this is needed on raentity deactivation or slee container stop, once the process ends it willinvoke allActivitiesEnded to complete those processes.
public void remove ( ) throws invalid state exception { if ( ! this . state . is inactive ( ) ) { throw new invalid state exception ( str + name + str + this . state ) ; } object . ra unconfigure ( ) ; if ( object . is fault tolerant ( ) ) { object . unset fault tolerant resource adaptor context ( ) ; ft resource adaptor context . shutdown ( ) ; } object . unset resource adaptor context ( ) ; this . slee container . get trace management ( ) . deregister notification source ( this . get notification source ( ) ) ; state = null ; }	Removes the entity, it will unconfigure and unset the ra context, theentity object can not be reused.
public object get resource adaptor interface ( id ra type ) { return object . get resource adaptor interface ( slee container . get component repository ( ) . get component by id ( ra type ) . get descriptor ( ) . get resource adaptor interface ( ) ) ; }	Retrieves the ra interface for this entity and the specified ra type.
public void service active ( id service id ) { try { receivable service receivable service = resource adaptor context . get service lookup facility ( ) . get receivable service ( service id ) ; if ( receivable service . get receivable events ( ) . length > num ) { object . service active ( receivable service ) ; } } catch ( throwable e ) { logger . warn ( str , e ) ; } }	Indicates a service was activated, the entity will forward thisnotification to the ra object.
activity handle derrefer activity handle ( activity handle handle ) { activity handle ah = null ; if ( resource management . get handle reference factory ( ) != null && handle . get class ( ) == activity handle reference . class ) { activity handle reference ah reference = ( activity handle reference ) handle ; ah = resource management . get handle reference factory ( ) . get activity handle ( ah reference ) ; } else { ah = handle ; } return ah ; }	if it is a handle reference it gets the referred handle.
public void activity ended ( final activity handle handle , int activity flags ) { logger . trace ( str + handle + str ) ; activity handle ah = null ; if ( handle instanceof activity handle reference ) {	Callback to notify the entity and possibly the ra object, informing activity handled ended.
public void ra configuration update ( config properties properties ) throws invalid configuration exception { if ( do trace logs ) { logger . trace ( str + properties + str ) ; } verify config properties ( properties ) ; object . ra configuration update ( config properties ) ; }	Updates the ra configuration.
private void verify config properties ( config properties new properties ) throws invalid configuration exception { if ( do trace logs ) { logger . trace ( str + new properties + str ) ; }	Merges the current properties values with the new ones and uses the ra toverify the configuration.
public void ra stopping ( ) throws invalid state exception { if ( do trace logs ) { logger . trace ( str ) ; } if ( state == resource adaptor object state . active ) { state = resource adaptor object state . stopping ; object . ra stopping ( ) ; } else { throw new invalid state exception ( str + state ) ; } }	Requests the stopping of the ra object.
public void ra inactive ( ) throws invalid state exception { if ( do trace logs ) { logger . trace ( str ) ; } if ( state == resource adaptor object state . stopping ) { state = resource adaptor object state . inactive ; object . ra inactive ( ) ; } else { throw new invalid state exception ( str + state ) ; } }	Requests the deactivation of the ra object.
public void ra unconfigure ( ) throws invalid state exception { if ( do trace logs ) { logger . trace ( str ) ; } if ( state == resource adaptor object state . inactive ) { state = resource adaptor object state . unconfigured ; object . ra unconfigure ( ) ; } else { throw new invalid state exception ( str + state ) ; } }	Unconfigures the ra object.
public void unset resource adaptor context ( ) throws invalid state exception { if ( do trace logs ) { logger . trace ( str ) ; } if ( state == resource adaptor object state . unconfigured ) { object . unset resource adaptor context ( ) ; state = null ; } else { throw new invalid state exception ( str + state ) ; } }	Unsets the context of the ra object.
@ suppress warnings ( str ) public void unset fault tolerant resource adaptor context ( ) throws illegal argument exception { if ( do trace logs ) { logger . trace ( str ) ; } if ( is fault tolerant ( ) ) { ( ( fault tolerant resource adaptor < serializable , serializable > ) this . object ) . unset fault tolerant resource adaptor context ( ) ; } else { throw new illegal argument exception ( str ) ; } }	Unsets the ft context of the ra object.
private void build profile attribute map ( ) throws deployment exception { hash map < string , profile attribute > map = new hash map < string , profile attribute > ( ) ; class < ? > cmp interface = get profile cmp interface class ( ) ; string attribute getter method prefix = str ; for ( method method : cmp interface . get methods ( ) ) { if ( ! method . get declaring class ( ) . equals ( object . class ) && method . get name ( ) . starts with ( attribute getter method prefix ) ) { string attribute name = method . get name ( ) . substring ( attribute getter method prefix . length ( ) ) ; switch ( attribute name . length ( ) ) { case num : throw new deployment exception ( str + method . get name ( ) ) ; case num : attribute name = attribute name . to lower case ( ) ; break ; default : attribute name = attribute name . substring ( num , num ) . to lower case ( ) + attribute name . substring ( num ) ; break ; } profile attribute impl profile attribute = null ; try { profile attribute = new profile attribute impl ( attribute name , method . get return type ( ) ) ; } catch ( throwable e ) { throw new deployment exception ( str + attribute name + str + method . get return type ( ) + str , e ) ; } if ( is slee11 ( ) ) { for ( cmp cmp field : get descriptor ( ) . get profile cmp ( ) . get cmp fields ( ) ) { if ( cmp field . get cmp field name ( ) . equals ( attribute name ) ) {	Builds the profile attribute map using the cmp interface class.
private void resume ( ) {	the real logic to resume the event context.
@ suppress warnings ( str ) public set < activity context handle > get activity context handles ( ) { final node node = get node ( ) ; return node != null ? node . get children names ( ) : collections . empty set ( ) ; }	Retrieves a set containing all activity context handles in the factory'scache data.
public object name get usage m ( string param set name ) throws null pointer exception , unrecognized usage parameter set name exception , management exception { if ( param set name == null ) throw new null pointer exception ( str ) ; return get usage m ( param set name ) ; }	Retrieves the object name for the usage param mbean with the specifiedname.
public boolean decorate abstract class ( ) throws deployment exception { class pool pool = component . get class pool ( ) ; profile abstract class descriptor abstract class = component . get descriptor ( ) . get profile abstract class ( ) ; if ( abstract class == null ) { return bool ; } string abstract class name = abstract class . get profile abstract class name ( ) ; try { ct class = pool . get ( abstract class name ) ; } catch ( not found exception nfe ) { throw new deployment exception ( str + abstract class name , nfe ) ; } decorate class jndi ( ) ; if ( is abstract class decorated ) { try { string deploy dir = component . get deployment dir ( ) . get absolute path ( ) ; ct class . write file ( deploy dir ) ; ct class . detach ( ) ;	Decorate the abstract Class.
public static void fire event ( sbb entity sbb entity , id event type id , object event object , activity context interface aci , address address ) { fire event ( sbb entity , event type id , event object , aci , address , null ) ; }	The logic to fire an event from an SLEE 1.0 Sbb.
public static void fire event ( sbb entity sbb entity , id event type id , object event object , activity context interface aci , address address , id service id ) { if ( slee container . get congestion control ( ) . refuse fire event ( ) ) { throw new slee ( str ) ; }	The logic to fire an event from an SLEE 1.1 Sbb.
public static object get profile cmp ( sbb entity sbb entity , string get profile cmp , id profile id ) throws unrecognized profile table name exception , unrecognized profile name exception { cmp m get profile cmp = sbb entity . get sbb component ( ) . get descriptor ( ) . get get profile cmp ( ) . get ( get profile cmp ) ; if ( m get profile cmp == null ) throw new abstract method error ( str ) ; if ( sbb entity . get sbb object ( ) . get state ( ) != sbb object state . ready ) { throw new illegal state exception ( str ) ; } profile management slee profile manager = slee container . get slee profile table manager ( ) ; profile table profile table = slee profile manager . get profile table ( profile id . get profile table name ( ) ) ; if ( ! profile table . profile exists ( profile id . get profile name ( ) ) ) { throw new unrecognized profile name exception ( profile id . to string ( ) ) ; } return profile table . get profile ( profile id . get profile name ( ) ) . get profile cmp slee10 wrapper ( ) ; }	Retrieves a profile given the cmp method name and profile id.
public static map get abstract methods from class ( ct class sbb abstract class ) { hash map abstract methods = new hash map ( ) ; ct method [ ] methods = sbb abstract class . get declared methods ( ) ; for ( int i = num ; i < methods . length ; i ++ ) { if ( modifier . is abstract ( methods [ i ] . get modifiers ( ) ) ) { abstract methods . put ( methods [ i ] . get name ( ) , methods [ i ] ) ; } } return abstract methods ; }	Retrieve all abstract methods from a class.
public static map get interface methods from interface ( ct class interface class , map except methods ) { hash map interface methods = new hash map ( ) ; ct method [ ] methods = interface class . get declared methods ( ) ; for ( int i = num ; i < methods . length ; i ++ ) { if ( except methods . get ( methods [ i ] . get name ( ) ) == null ) { concrete class generator utils . logger . trace ( methods [ i ] . get name ( ) ) ; interface methods . put ( get method key ( methods [ i ] ) , methods [ i ] ) ; } } map temp = get super classes abstract methods from interface ( interface class ) ; for ( iterator i = temp . key set ( ) . iterator ( ) ; i . has next ( ) ; ) { string key = ( string ) i . next ( ) ; if ( ! except methods . contains key ( key ) ) { interface methods . put ( key , temp . get ( key ) ) ; } } return interface methods ; }	Retrieve all methods from an interface, including super interfaces, except the ones specified in the provided map.
public void create object pool ( final profile table impl profile table , final slee transaction manager slee transaction manager ) { if ( logger . is trace enabled ( ) ) { logger . trace ( str + profile table ) ; } create object pool ( profile table ) ; if ( slee transaction manager != null ) {	Creates an object pool for the specified profile table.
public void remove object pool ( final profile table impl profile table , final slee transaction manager slee transaction manager ) { transactional action action = new transactional action ( ) { public void execute ( ) { if ( logger . is trace enabled ( ) ) { logger . trace ( str + profile table ) ; } remove object pool ( profile table ) ; } } ; if ( slee transaction manager != null ) { slee transaction manager . get transaction context ( ) . get after commit actions ( ) . add ( action ) ; } else { action . execute ( ) ; } }	Removes the object pool for the specified profile table.
public boolean is source owner of alarm ( notification source wrapper notification source , string alarm id ) { alarm place holder aph = this . alarm id to alarm . get ( alarm id ) ; if ( aph == null ) return bool ; return aph . get notification source ( ) . get notification source ( ) . equals ( notification source . get notification source ( ) ) ; }	NON MBEAN - used only internal, those methods are not exposed via jmx.
public string raise alarm ( notification source wrapper notification source , string alarm type , string instance id , alarm level level , string message , throwable cause ) { synchronized ( notification source ) { if ( is alarm alive ( notification source , alarm type , instance id ) ) {	THis methods raises alarm.
public static object get usage parameter set ( profile object impl profile object , string name ) throws unrecognized usage parameter set name exception { if ( logger . is debug enabled ( ) ) { logger . info ( str + name + str + profile object ) ; } if ( name == null ) { throw new null pointer exception ( str ) ; } profile table impl profile table = profile object . get profile table ( ) ; object result = profile table . get profile table usage m ( ) . get installed usage parameter set ( name ) ; if ( result == null ) { throw new unrecognized usage parameter set name exception ( ) ; } else { return result ; } }	Usage methods. Here we can be static for sure. Rest must be tested.
public javax . slee . management . event type descriptor get specs descriptor ( ) { if ( specs descriptor == null ) { specs descriptor = new javax . slee . management . event type descriptor ( get event type id ( ) , get deployable unit ( ) . get deployable unit id ( ) , get deployment unit source ( ) , descriptor . get library refs ( ) . to array ( new id [ descriptor . get library refs ( ) . size ( ) ] ) , get descriptor ( ) . get event class name ( ) ) ; } return specs descriptor ; }	Retrieves the JAIN SLEE specs event type descriptor.
public boolean accepts ( url deployable unit url , string deployable unit name ) { deployable unit wrapper du = new deployable unit wrapper ( deployable unit url , deployable unit name ) ; url url = du . get url ( ) ; if ( logger . is trace enabled ( ) ) { logger . trace ( str + url + str + deployable unit name + str ) ; } try { string full path = url . get file ( ) ; string file name = full path . substring ( full path . last index of ( str ) + num , full path . length ( ) ) ;	Method for deciding whether or not to accept the file.
public void init ( url deployable unit url , string deployable unit name ) throws deployment exception { url url = deployable unit url ; deployable unit wrapper du = new deployable unit wrapper ( deployable unit url , deployable unit name ) ; if ( logger . is trace enabled ( ) ) { logger . trace ( str + deployable unit url + str + deployable unit name + str ) ; }	Initializer method for accepted files.
public void start ( url deployable unit url , string deployable unit name ) throws deployment exception { deployable unit wrapper du = new deployable unit wrapper ( deployable unit url , deployable unit name ) ; if ( logger . is trace enabled ( ) ) { logger . trace ( str + du . get url ( ) + str + deployable unit name + str ) ; } try {	This is where the fun begins. Time to deploy!.
public void stop ( url deployable unit url , string deployable unit name ) throws deployment exception { if ( logger . is trace enabled ( ) ) { logger . trace ( str + deployable unit url + str ) ; } deployable unit wrapper du = new deployable unit wrapper ( deployable unit url , deployable unit name ) ; deployable unit real du = null ; string file name = du . get file name ( ) ; if ( ( real du = deployable units . get ( du . get file name ( ) ) ) != null ) { if ( logger . is trace enabled ( ) ) { logger . trace ( str + real du . get deployment info short name ( ) ) ; } if ( ! is in undeploy list ( file name ) ) { add to undeploy list ( file name ) ; } try {	Fun has ended. Time to undeploy.
public string show status ( ) throws deployment exception { string output = str ; output += str ; for ( string key : deployable units . key set ( ) ) { output += str + key + str + deployable units . get ( key ) + str ; for ( string du component : deployable units . get ( key ) . get components ( ) ) { output += str + du component + str ; } } output += str ; for ( string key : to accept . key set ( ) ) { output += str + key + str + to accept . get ( key ) + str ; } output += str ; for ( string undeploy : undeploys ) { output += str + undeploy + str ; } output += str ; output += slee container deployer . get deployment manager ( ) . show status ( ) ; return output ; }	MBean operation for getting Deployer status.
protected void execute after commit actions ( ) { if ( after commit actions != null ) { if ( trace ) { logger . trace ( str ) ; } execute actions ( after commit actions , trace ) ; after commit actions = null ; } }	Executes actions scheduled after commit succeeds.
protected void execute after commit priority actions ( ) { if ( after commit priority actions != null ) { if ( trace ) { logger . trace ( str ) ; } execute actions ( after commit priority actions , trace ) ; after commit priority actions = null ; } }	Executes actions scheduled to run first after commit succeeds.
protected void execute after rollback actions ( ) { if ( after rollback actions != null ) { if ( trace ) { logger . trace ( str ) ; } execute actions ( after rollback actions , trace ) ; after rollback actions = null ; } }	Executes actions scheduled for after a rollback.
protected void execute before commit actions ( ) { if ( before commit actions != null ) { if ( trace ) { logger . trace ( str ) ; } execute actions ( before commit actions , trace ) ; before commit actions = null ; } }	Executes actions scheduled for before commit.
protected void execute before commit priority actions ( ) { if ( before commit priority actions != null ) { if ( trace ) { logger . trace ( str ) ; } execute actions ( before commit priority actions , trace ) ; before commit priority actions = null ; } }	Executes actions scheduled for before commit at first.
public string [ ] get defined tracer names ( ) { set < string > names = new hash set < string > ( ) ; for ( tracer impl t : this . tracers . values ( ) ) { if ( t . is explicitly set tracer level ( ) ) names . add ( t . get tracer name ( ) ) ; } if ( names . is empty ( ) ) return new string [ num ] ; return names . to array ( new string [ names . size ( ) ] ) ; }	This method returns tracer names that have been defined explicitly viasetTraceLevel from TraceMBean.
public tracer create tracer ( string tracer name , boolean requested by source ) { tracer impl tparent = null ; tracer impl t = tracers . get ( tracer name ) ; if ( t == null ) { string [ ] split = tracer name . split ( str ) ; string current name = str ; for ( string s : split ) { if ( tparent == null ) {	This method can be called multiple times.
public void remove replicate data ( ) { if ( replicated data with failover != null ) { replicated data with failover . remove ( ) ; replicated data with failover = null ; } if ( replicated data != null ) { replicated data . remove ( ) ; replicated data = null ; } }	Removes all replicated data.
public void process ( slee component with usage parameters interface component ) throws deployment exception { class pool class pool = component . get class pool ( ) ; string deployment dir = component . get deployment dir ( ) . get absolute path ( ) ; class < ? > usage parameters interface = component . get usage parameters interface ( ) ; if ( usage parameters interface != null ) { try {	Generates classes for a slee component, which defines usage parameters.
public sbb object pool impl get object pool ( id service id , id sbb id ) { return pools . get ( new object pool map key ( service id , sbb id ) ) ; }	Retrieves the object pool for the specified sbb and service.
public void create object pool ( final id service id , final sbb component sbb component , final slee transaction manager slee transaction manager ) { if ( logger . is trace enabled ( ) ) { logger . trace ( str + service id + str + sbb component ) ; } create object pool ( service id , sbb component ) ; if ( slee transaction manager != null && slee transaction manager . get transaction context ( ) != null ) {	Creates an object pool for the specified service and sbb.
void execute ( final activity handle handle ) throws unrecognized activity handle exception { final slee transaction tx = super . suspend transaction ( ) ; try { slee endpoint . end activity ( handle , tx ) ; } finally { if ( tx != null ) { super . resume transaction ( tx ) ; } } }	Executes a non transacted End Activity operation.
activity context handle start activity ( activity handle handle , int activity flags , final slee transaction barrier tx ) { activity context ac = null ; if ( ra entity . get handle reference factory ( ) != null && ! activity flags . has slee may marshal ( activity flags ) ) { final activity handle reference reference = ra entity . get handle reference factory ( ) . create activity handle reference ( handle ) ; try {	Start activity logic, independent of transaction management.
void end activity ( activity handle handle , final slee transaction barrier tx ) throws unrecognized activity handle exception { final activity context handle ach = new resource adaptor activity context handle impl ( ra entity , handle ) ;	End activity logic independent of transaction management.
private void check fire event preconditions ( activity handle handle , fireable event type event type , object event ) throws null pointer exception , illegal event exception , illegal state exception { if ( event == null ) throw new null pointer exception ( str ) ; if ( handle == null ) throw new null pointer exception ( str ) ; if ( event type == null ) { throw new null pointer exception ( str ) ; } final event type component event type component = component repository . get component by id ( event type . get event type ( ) ) ; if ( event type component == null ) { throw new illegal event exception ( str ) ; } if ( ! event type component . get event type class ( ) . is assignable from ( event . get class ( ) ) ) { throw new illegal event exception ( str ) ; } if ( event type . get class ( ) != fireable event type impl . class ) { throw new illegal event exception ( str ) ; } if ( ra entity . get allowed event types ( ) != null && ! ra entity . get allowed event types ( ) . contains ( event type . get event type ( ) ) ) { throw new illegal event exception ( str + event type . get event type ( ) + str ) ; } }	Checks that fire event methods can be invoked.
void fire event ( activity handle real handle , activity handle ref handle , fireable event type event type , object event , address address , receivable service receivable service , int event flags , final slee transaction barrier tx ) throws activity is ending exception , slee { final activity context handle ach = new resource adaptor activity context handle impl ( ra entity , ref handle ) ;	Event firing logic independent of transaction management.
public class generate sbb local object concrete class ( ) {	Generate the Sbb Local Object Class.
protected void make getter ( ) { if ( field class . equals ( boolean . class ) || field class . equals ( boolean . class ) ) { super . operation name = str + this . bean field name ; } else { super . operation name = str + this . bean field name ; } }	User should overide it to provide different name, for instance for boolean \"is\" prefix.
protected object convert ( string opt arg ) throws security exception , no such method exception , illegal argument exception , instantiation exception , illegal access exception , invocation target exception , command exception { if ( field class . is primitive ( ) ) {	This method is called to convert optArg from string form, if no conversion is needed it should return passed object.
public final void set profile id ( string profile table name , string profile name ) throws null pointer exception , illegal argument exception { if ( profile table name == null ) throw new null pointer exception ( str ) ; if ( profile name == null ) throw new null pointer exception ( str ) ; if ( profile table name . index of ( str ) >= num ) throw new illegal argument exception ( str ) ; this . profile table name = profile table name ; this . profile name = profile name ; this . address = null ; }	Set the profile table and profile referenced by this profile identifier to newvalues.
private string extract message ( string result ) {	protected DeployableUnitsCard deployableUnitsCard;.
public boolean contains ( object object ) { if ( ! ( object instanceof sbb local object ) ) return bool ; final sbb local object impl sbblocal = ( sbb local object impl ) object ; final id sbb entity id = sbblocal . get sbb entity id ( ) ; if ( ! id belongs to child relation ( sbb entity id ) ) { return bool ; } return new sbb entity cache data ( sbb entity id , slee container . get cluster ( ) . get mobicents cache ( ) ) . exists ( ) ; }	The contains method. This method returns true if the SBB entityrepresented by the SBB local object specified by the input argument is amember of this child relation. If the method argument is not an SBB localobject, is an invalid SBB local object, or is an SBB local object whoseunderlying SBB entity is not a member of this child relation, then thismethod returns false.
@ suppress warnings ( str ) public boolean contains all ( collection c ) { if ( c == null ) throw new null pointer exception ( str ) ; for ( iterator it = c . iterator ( ) ; it . has next ( ) ; ) { if ( ! contains ( it . next ( ) ) ) { return bool ; } } if ( logger . is debug enabled ( ) ) { logger . debug ( str + c + str ) ; } return bool ; }	This method returns true if all SBB entities represented by the SBB localobjects in the collection specified by the input argument are members ofthis child relation.
@ suppress warnings ( str ) public boolean remove all ( collection c ) { boolean flag = bool ; if ( c == null ) throw new null pointer exception ( str ) ; for ( iterator it = c . iterator ( ) ; it . has next ( ) ; ) { flag &= this . remove ( it . next ( ) ) ; } return flag ; }	Removing an SBB entity from a child relation initiates a cascadingremoval of the SBB entity tree rooted by the SBB entity, similar toinvoking the remove method on an SBB local object that represents the SBBentity.
public boolean is higher level ( level other ) throws null pointer exception { if ( other == null ) throw new null pointer exception ( str ) ; return this . level < other . level ; }	Determine if this Level object represents a level that is higher or more severethat some other Level object.
private object read resolve ( ) throws stream corrupted exception { if ( level == level off ) return off ; if ( level == level severe ) return severe ; if ( level == level warning ) return warning ; if ( level == level info ) return info ; if ( level == level config ) return config ; if ( level == level fine ) return fine ; if ( level == level finer ) return finer ; if ( level == level finest ) return finest ; throw new stream corrupted exception ( str ) ; }	Resolve deserialisation references so that the singleton property of eachenumerated object is preserved.
public void clean ( ) { for ( class path class path : class paths ) { class pool . remove class path ( class path ) ; } for ( string class made : classes made ) { try { class pool . get ( class made ) . detach ( ) ; } catch ( not found exception e ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + class made + str , e ) ; } } } }	cleans up the class pool cache.
@ suppress warnings ( str ) public static void add profile call ( profile object impl po ) throws slee { slee transaction manager slee transaction manager = slee container . get transaction manager ( ) ; try { if ( slee transaction manager . get transaction ( ) == null ) { return ; } } catch ( system exception se ) { throw new slee ( str , se ) ; } string key = make key ( po ) ; if ( logger . is trace enabled ( ) ) { logger . trace ( str + key + str ) ; } final transaction context tx context = slee transaction manager . get transaction context ( ) ; profile call recorder transaction data data = ( profile call recorder transaction data ) tx context . get data ( ) . get ( transaction context key ) ;	Adds call to this profile.
public profile object impl get profile ( string profile name ) throws transaction required local exception , slee { map tx data = get tx data ( ) ; id key = new id ( profile name , profile table . get profile table name ( ) ) ; profile object impl value = ( profile object impl ) tx data . get ( key ) ; if ( value == null ) { profile object pool pool = profile table . get profile management ( ) . get object pool management ( ) . get object pool ( profile table . get profile table name ( ) ) ; value = pool . borrow object ( ) ; passivate profile object on tx end ( profile table . get slee container ( ) . get transaction manager ( ) , value , pool ) ; try { value . profile activate ( profile name ) ; } catch ( unrecognized profile name exception e ) { value . invalidate object ( ) ; pool . invalidate object ( value ) ; return null ; } tx data . put ( key , value ) ; } return value ; }	Retrieves a profile object for the table and specified profile name,there is only one profile object per profile entity per transaction.
public static void passivate profile object on tx end ( slee transaction manager tx manager , final profile object impl profile object , final profile object pool pool ) { transactional action after rollback action = new transactional action ( ) { public void execute ( ) { profile object . invalidate object ( ) ; pool . return object ( profile object ) ; } } ; transactional action before commit action = new transactional action ( ) { public void execute ( ) { if ( profile object . get state ( ) == profile object state . ready ) { if ( ! profile object . get profile entity ( ) . is remove ( ) ) { profile object . fire add or updated event if needed ( ) ; profile object . profile passivate ( ) ; } else { profile object . profile remove ( bool , bool ) ; } pool . return object ( profile object ) ; } } } ; final transaction context tx context = tx manager . get transaction context ( ) ; tx context . get after rollback actions ( ) . add ( after rollback action ) ; tx context . get before commit actions ( ) . add ( before commit action ) ; }	Adds transactional actions to the active transaction to passivate aprofile object.
public void set as text ( string text ) { if ( text == null || text . equals ( str ) ) { super . set value ( new id [ num ] ) ; } else { java . util . array list results = new java . util . array list ( ) ;	Set the element as text value, parse it and setValue.The separator is CID_SEPARATOR.
public class generate activity context interface concrete class ( ) throws deployment exception { string tmp class name = concrete class generator utils . concrete activity interface class name prefix + activity context interface name + concrete class generator utils . concrete activity interface class name suffix ; concrete activity context interface = pool . make class ( tmp class name ) ; ct class sbb activity context interface = null ; try { activity context interface = pool . get ( activity context interface name ) ; sbb activity context interface = pool . get ( sbb activity context interface impl . class . get name ( ) ) ; } catch ( not found exception nfe ) { throw new deployment exception ( str + activity context interface name , nfe ) ; }	Generate the Activity Context Interface Class.
private void generate concrete methods ( map interface methods ) { if ( interface methods == null ) return ; iterator it = interface methods . values ( ) . iterator ( ) ; while ( it . has next ( ) ) { ct method interface method = ( ct method ) it . next ( ) ; if ( interface method != null	Generates the concrete methods of the class It generates a specificmethod implementation for the javax.slee.ActivityContextInterface methodsfor the methods coming from the ActivityContextInterface developer thecall is routed to the base asbtract class.
public void set data attribute ( string key , object new value ) { cache data . set cmp attribute ( key , new value ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + get activity context handle ( ) + str + key + str + new value ) ; } }	Set a shared data item for the ACI.
public void add name binding ( string aci name ) { cache data . name bound ( aci name ) ; if ( ac references handler != null ) { ac references handler . name reference created ( ) ; } }	add a naming binding to this activity context.
private void remove naming bindings ( ) { activity context naming facility acf = slee container . get activity context naming facility ( ) ; for ( object obj : cache data . get names bound copy ( ) ) { string aci name = ( string ) obj ; try { acf . remove name ( aci name ) ; } catch ( exception e ) { logger . warn ( str + aci name + str + get activity context handle ( ) , e ) ; } } }	This is called to release all the name bindings after the activity endevent is delivered to the sbb.
public boolean remove name binding ( string aci name ) { boolean removed = cache data . name unbound ( aci name ) ; if ( removed && ac references handler != null ) { ac references handler . name reference removed ( ) ; } return removed ; }	Add the given name to the set of activity context names that we are boundto.
public boolean attach timer ( id timer id ) { if ( cache data . attach timer ( timer id ) ) { if ( ac references handler != null ) { ac references handler . timer reference created ( ) ; } return bool ; } else { return bool ; } }	attach the given timer to the current activity context.
private void remove from timers ( ) { timer facility timer facility = slee container . get timer facility ( ) ;	End Event has been delivered on the Activity Context.
public boolean attach sbb entity ( id sbb entity id ) { boolean attached = cache data . attach sbb entity ( sbb entity id ) ; if ( attached ) { if ( ac references handler != null ) { ac references handler . sbbe reference created ( bool ) ; } } if ( logger . is trace enabled ( ) ) { logger . trace ( str + sbb entity id + str + get activity context handle ( ) + str + attached ) ; } return attached ; }	attach an sbb entity to this AC.
public void detach sbb entity ( id sbb entity id ) throws javax . slee . transaction required local exception { boolean detached = cache data . detach sbb entity ( sbb entity id ) ; if ( detached && ac references handler != null && ! is ending ( ) ) { ac references handler . sbbe reference removed ( ) ; if ( logger . is trace enabled ( ) ) { logger . trace ( str + sbb entity id + str + get activity context handle ( ) ) ; } } }	Detach the sbb entity.
public set < id > get sorted sbb attachment set ( set < id > exclude set ) { final set < id > sbb attachement set = cache data . get sbb entities attached ( ) ; set < id > result = new hash set < id > ( ) ; for ( id sbb entity id : sbb attachement set ) { if ( ! exclude set . contains ( sbb entity id ) ) { result . add ( sbb entity id ) ; } } if ( result . size ( ) > num ) { result = slee container . get sbb entity factory ( ) . sort by priority ( result ) ; } return result ; }	get an ordered copy of the set of SBBs attached to this ac.
public void end activity ( ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + get activity context handle ( ) ) ; } if ( cache data . set ending ( bool ) ) { fire event ( slee container . get event context factory ( ) . create activity end event context ( this , new activity end event unreferenced callback ( get activity context handle ( ) , factory ) ) , slee container . get transaction manager ( ) . get transaction context ( ) ) ; } }	Ends the activity context.
public void add component ( deployable component dc ) { if ( logger . is trace enabled ( ) ) logger . trace ( str + dc . get component key ( ) ) ;	Adder method for a Deployable Component.
public collection < string > get external dependencies ( ) {	Method for obtaining the external dependencies for this DU, if any.
public boolean has dependencies satisfied ( boolean show missing ) {	Method for checking if the DU has all the dependencies needed to be deployed.
public boolean has duplicates ( ) { array list < string > duplicates = new array list < string > ( ) ;	Method for checking if this DU contains any component that is already deployed.
public collection < management action > get install actions ( ) { array list < management action > i actions = new array list < management action > ( ) ;	Getter for the Install Actions.
public collection < management action > get uninstall actions ( ) { collection < management action > u actions = new array list < management action > ( uninstall actions ) ;	Getter for the Uninstall Actions.
private boolean has referring du ( ) throws exception {	Method for checking if this DU components are referred by any others.
public static void close ( string profile table name , string profile name ) { final object name object name = get object name ( profile table name , profile name ) ; if ( slee container . get m ( ) . is registered ( object name ) ) { runnable r = new runnable ( ) { public void run ( ) { try { slee container . get m ( ) . invoke ( object name , str , new object [ ] { } , new string [ ] { } ) ; } catch ( throwable e ) { logger . error ( e . get message ( ) , e ) ; } } } ; thread t = new thread ( r ) ; t . start ( ) ; } }	Closes and unregisters the mbean for the specified profile, if exists.
public static object name get object name ( string profile table name , string profile name ) {	Retrieves the JMX ObjectName for a profile, given its profile name andprofile table name.
private void write mode ( ) throws slee , management exception { if ( ! is profile writeable ( ) ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + profile name + str + this . profile table . get profile table name ( ) ) ; }	Moves to the write mode, using specified object.
protected void before set cmp field ( ) throws management exception , invalid state exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + profile name + str + profile table . get profile table name ( ) ) ; } if ( is profile writeable ( ) ) { try { slee container . get transaction manager ( ) . resume ( transaction ) ; } catch ( throwable e ) { throw new management exception ( e . get message ( ) , e ) ; } } else { throw new invalid state exception ( ) ; } }	Logic to execute before invoking a cmp setter method on the mbean.
protected void after set cmp field ( ) throws management exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + profile name + str + profile table . get profile table name ( ) ) ; } try { slee container . get transaction manager ( ) . suspend ( ) ; } catch ( throwable e ) { throw new management exception ( e . get message ( ) , e ) ; } }	Logic to execute after invoking a cmp setter method on the mbean.
protected boolean before get cmp field ( ) throws management exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + profile name + str + profile table . get profile table name ( ) ) ; } return before non set cmp field ( ) ; }	Logic to execute before invoking a cmp getter method on the mbean.
protected void after get cmp field ( boolean activated transaction ) throws management exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + activated transaction + str + profile name + str + profile table . get profile table name ( ) ) ; } after non set cmp field ( activated transaction ) ; }	Logic to execute after invoking a cmp getter method on the mbean.
protected boolean before management method invocation ( ) throws management exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + profile name + str + profile table . get profile table name ( ) ) ; } jndi management = slee container . get jndi management ( ) ; jndi management . push jndi context ( profile table . get profile specification component ( ) ) ; return before non set cmp field ( ) ; }	Logic to execute before invoking a management method on the mbean.
protected void after management method invocation ( boolean activated transaction ) throws management exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + activated transaction + str + profile name + str + profile table . get profile table name ( ) ) ; } after non set cmp field ( activated transaction ) ; jndi management . pop jndi context ( ) ; }	Logic to execute after invoking a management method on the mbean.
private void delete path ( file path ) { if ( path . is directory ( ) ) { file [ ] files = path . list files ( ) ; if ( files != null ) { for ( file file : files ) { delete path ( file ) ; } } } path . delete ( ) ; }	deletes the whole path, going through directories.
protected void create default constructor ( ) throws deployment exception { ct constructor default constructor = new ct constructor ( null , sbb concrete class ) ;	Create a default constructor on the Sbb Concrete Class.
private void create default usage parameter getter ( ct class sbb concrete ) throws deployment exception { string method name = str ; ct method method = ( ct method ) abstract methods . get ( method name ) ; if ( method == null ) { method = ( ct method ) super classes abstract methods . get ( method name ) ; } if ( method != null ) { try {	Create a default usage parameter getter and setter.
private void create sbb entity getter and setter ( ct class sbb concrete ) throws deployment exception { try { ct method get sbb entity = ct new method . make ( str + sbb entity . class . get name ( ) + str , sbb concrete ) ; get sbb entity . set modifiers ( modifier . public ) ; sbb concrete . add method ( get sbb entity ) ; ct method set sbb entity = ct new method . make ( str + sbb entity . class . get name ( ) + str + str + str + str , sbb concrete ) ; set sbb entity . set modifiers ( modifier . public ) ; sbb concrete . add method ( set sbb entity ) ; } catch ( exception e ) { throw new deployment exception ( e . get message ( ) , e ) ; } }	Create a method to retrive the entity from the SbbObject.
protected void create fire event methods ( collection < event entry descriptor > m event entries ) { if ( m event entries == null ) return ; for ( event entry descriptor m event entry : m event entries ) { if ( m event entry . is fired ( ) ) { string method name = str + m event entry . get event name ( ) ; ct method method = ( ct method ) abstract methods . get ( method name ) ; if ( method == null ) { method = ( ct method ) super classes abstract methods . get ( method name ) ; } if ( method != null ) { try {	Create the implementation of the fire event methods.
protected void create get sbb activity context interface method ( ct class activity context interface , class < ? > concrete activity context interface class ) throws deployment exception { string method to add = str + activity context interface . get name ( ) + str + str + str + illegal state exception . class . get name ( ) + str + str + sbb object state . class . get name ( ) + str + illegal state exception . class . get name ( ) + str + str + concrete activity context interface class . get name ( ) + str + str + concrete activity context interface class . get name ( ) + str + activity context interface . class . get name ( ) + str + str + str ; ct method method test ; try { method test = ct new method . make ( method to add , sbb concrete class ) ; sbb concrete class . add method ( method test ) ; if ( logger . is trace enabled ( ) ) { logger . trace ( str + method to add + str ) ; } } catch ( cannot compile exception e ) { throw new deployment exception ( e . get message ( ) , e ) ; } }	Create the narrow method to get the activity context interface.
protected final void add ( query expression expr ) throws null pointer exception , illegal argument exception { if ( expr == null ) throw new null pointer exception ( str ) ;	Add a query expression to this composite expression.
public static synchronized void bind ( string key , object target ) throws name already bound exception { if ( wrapper map . contains key ( key ) == bool ) throw new name already bound exception ( key + str ) ; wrapper map . put ( key , target ) ; }	Place an object into the NonSerializableFactory namespace for subsequentaccess by getObject.
public static synchronized void rebind ( name name , object target ) throws naming exception { rebind ( name , target , bool ) ; }	A convience method that simplifies the process of rebinding anon-zerializable object into a JNDI context.
public boolean decorate abstract sbb ( ) throws deployment exception { class pool pool = component . get class pool ( ) ; string sbb abstract class name = component . get descriptor ( ) . get sbb abstract class ( ) . get sbb abstract class name ( ) ; try { sbb abstract class = pool . get ( sbb abstract class name ) ; } catch ( not found exception nfe ) { throw new deployment exception ( str + sbb abstract class name , nfe ) ; }	Decorate the abstract sbb Class.
public void invoke and returnvoid ( sbb concrete proxy , string method name , object [ ] args , class < ? > [ ] arg types ) throws exception { invoke and return object ( proxy , method name , args , arg types ) ; }	Invokers for the simple types.
private string get real field name ( string field name ) { string real field name = sbb component . get descriptor ( ) . get activity context attribute aliases ( ) . get ( field name ) ; if ( real field name == null ) {	Computes the real aci data field name.
public void set field value ( string field name , object value ) { string real field name = get real field name ( field name ) ; aci impl . get activity context ( ) . set data attribute ( real field name , value ) ; }	Sets an sbb aci data field value.
public object get field value ( string field name , class < ? > return type ) { string real field name = get real field name ( field name ) ; object value = aci impl . get activity context ( ) . get data attribute ( real field name ) ; if ( value == null ) { if ( return type . is primitive ( ) ) { if ( return type . equals ( integer . type ) ) { return integer . value of ( num ) ; } else if ( return type . equals ( boolean . type ) ) { return boolean . false ; } else if ( return type . equals ( long . type ) ) { return long . value of ( num ) ; } else if ( return type . equals ( double . type ) ) { return double . value of ( num ) ; } else if ( return type . equals ( float . type ) ) { return float . value of ( num ) ; } } } return value ; }	Retrieves an sbb aci data field value.
private void profile initialize ( string profile name ) { if ( logger . is trace enabled ( ) ) { logger . trace ( str + this + str + profile name ) ; } if ( this . state != profile object state . pooled ) { throw new slee ( this . to string ( ) ) ; } if ( profile name == null ) {	initialize state from default profile.
public void unset profile context ( ) { if ( logger . is trace enabled ( ) ) { logger . trace ( str + this ) ; } if ( state == profile object state . pooled && profile concrete class info . is invoke unset profile context ( ) ) { final class loader old class loader = slee container utils . get current thread class loader ( ) ; try { final class loader cl = profile table . get profile specification component ( ) . get class loader ( ) ; if ( system . get security manager ( ) != null ) { access controller . do privileged ( new privileged action < object > ( ) { public object run ( ) { thread . current thread ( ) . set context class loader ( cl ) ; return null ; } } ) ; } else { thread . current thread ( ) . set context class loader ( cl ) ; } if ( is slee11 ) { try { profile concrete . unset profile context ( ) ; } catch ( runtime exception e ) { runtime exception on profile invocation ( e ) ; } } profile context . set profile object ( null ) ; state = profile object state . does not exist ; } finally { if ( system . get security manager ( ) != null ) { access controller . do privileged ( new privileged action < object > ( ) { public object run ( ) { thread . current thread ( ) . set context class loader ( old class loader ) ; return null ; } } ) ; } else { thread . current thread ( ) . set context class loader ( old class loader ) ; } } } }	Invoked when pool removes object.
public profile local object get profile local object ( ) { final class < ? > profile local object concrete class = profile table . get profile specification component ( ) . get profile local object concrete class ( ) ; profile local object profile local object = null ; if ( profile local object concrete class == null ) { profile local object = new profile local object impl ( this ) ; } else { try { profile local object = ( profile local object ) profile local object concrete class . get constructor ( profile object impl . class ) . new instance ( this ) ; } catch ( throwable e ) { throw new slee ( e . get message ( ) , e ) ; } } return profile local object ; }	Retrieves the local representation for this profile object.
public void fire add or updated event if needed ( ) { if ( state == profile object state . ready ) { if ( profile entity . is dirty ( ) ) {	Fires a profile added or updated event if the profile object state is ready and the persistent state is dirty.
public abstract profile cmp slee10 wrapper get profile cmp slee10 wrapper ( ) { if ( profile cmp slee10 wrapper == null ) { try { profile cmp slee10 wrapper = ( abstract profile cmp slee10 wrapper ) profile table . get profile specification component ( ) . get profile cmp slee10 wrapper class ( ) . get constructor ( profile object impl . class ) . new instance ( this ) ; } catch ( throwable e ) { throw new slee ( e . get message ( ) , e ) ; } } return profile cmp slee10 wrapper ; }	Retrieves the profile cmp slee 1.0 wrapper for this profile object.
public static ct class create class ( string class name , string [ ] interfaces ) throws exception { if ( class name == null ) { throw new null pointer exception ( str ) ; } ct class clazz = class pool . make class ( class name ) ; if ( interfaces != null && interfaces . length > num ) { clazz . set interfaces ( class pool . get ( interfaces ) ) ; } return clazz ; }	Creates a class with the desired name and linked to the mentioned interfaces.
public static void create inheritance link ( ct class concrete class , string super class name ) { if ( super class name != null && super class name . length ( ) >= num ) { try { concrete class . set superclass ( class pool . get ( super class name ) ) ; } catch ( cannot compile exception e ) { e . print stack trace ( ) ; } catch ( not found exception e ) { e . print stack trace ( ) ; } } }	Create the inheritance link with the absract class provided by the developer.
private static void add member values to annotation ( annotation annotation , const pool cp , linked hash map < string , object > member values ) {	Private method to add member values to annotation.
protected activity context interface get aci ( object activity ) throws null pointer exception , unrecognized activity exception , factory exception { if ( activity == null ) { throw new null pointer exception ( str ) ; } activity handle handle = null ; for ( resource adaptor entity ra entity : slee container . get resource management ( ) . get resource adaptor entities per type ( resource adaptor type id ) ) { handle = ra entity . get resource adaptor object ( ) . get activity handle ( activity ) ; if ( handle != null ) { activity context handle ach = new resource adaptor activity context handle impl ( ra entity , handle ) ; activity context ac = slee container . get activity context factory ( ) . get activity context ( ach ) ; if ( ac != null ) { return ac . get activity context interface ( ) ; } break ; } } throw new unrecognized activity exception ( activity . to string ( ) ) ; }	This method returns the aci for the specified activity, if exists, itshould be invoked by each impl of methods of an ra type aci factory.
public class pool get class pool ( ) { if ( class pool == null ) { if ( class loader == null ) { throw new illegal state exception ( str ) ; } class pool = new class pool ( ) ;	Retrieves the component javassist class pool.
public void set deployable unit ( deployable unit deployable unit ) throws already deployed exception { if ( this . deployable unit != null ) { throw new illegal state exception ( str + this . deployable unit ) ; } this . deployable unit = deployable unit ; if ( ! add to deployable unit ( ) ) { throw new already deployed exception ( str + get component id ( ) ) ; } }	Specifies the the Deployable Unit this component belongs. This methodalso sets the reverse relation, adding the component to the deployableunit.
public void undeployed ( ) { class loader = null ; if ( class loader domain != null ) { class loader domain . clear ( ) ; class loader domain = null ; } if ( class pool != null ) { class pool . clean ( ) ; class pool = null ; } if ( permissions != null ) { permissions . clear ( ) ; permissions = null ; } }	Indicates that the component was undeployed and thus should clean up any resources.
void execute ( final activity handle handle , final int activity flags , boolean suspend activity ) throws slee { final slee transaction tx = super . suspend transaction ( ) ; activity context handle ach = null ; try { ach = slee endpoint . start activity ( handle , activity flags , suspend activity ? tx : null ) ; } finally { if ( tx != null ) { super . resume transaction ( tx ) ;	Executes a non transacted start activity operation.
public static class check interfaces ( class class or interface with interfaces , string interface searched ) { class return value = null ; if ( class or interface with interfaces . get name ( ) . compare to ( interface searched ) == num ) { return class or interface with interfaces ; }	Searches for provided interface in passed Class object - it can be classor interface.
public static map < string , method > get all interfaces methods ( class x interface class , set < string > ignore ) { hash map < string , method > abstract methods = new hash map < string , method > ( ) ; method [ ] methods = null ; class [ ] super interfaces ; super interfaces = x interface class . get interfaces ( ) ; for ( class super interface : super interfaces ) { if ( ! ignore . contains ( super interface . get name ( ) ) ) abstract methods . put all ( get all interfaces methods ( super interface , ignore ) ) ; } methods = x interface class . get declared methods ( ) ; for ( int i = num ; i < methods . length ; i ++ ) { abstract methods . put ( get method key ( methods [ i ] ) , methods [ i ] ) ; } return abstract methods ; }	Returns methods of this interface and all super interfaces.
public static void check tracer name ( string tracer name , notification source notification source ) throws illegal argument exception { if ( tracer name . compare to ( str ) == num ) {	This checks if tracer name is ok. It must not be null;.
public static collection < profile local object > handle ( profile table impl profile table , string query name , object [ ] arguments ) throws null pointer exception , transaction required local exception , slee , unrecognized query name exception , attribute type mismatch exception , invalid argument exception { return profile table . get profiles by static query ( query name , arguments ) ; }	Method that does lookup and creates PLOs.
private file create temp du ( file deployment root , id deployable unit id ) { try {	Creates the directory that will be used for unpacking the child jars fora given DU.
@ suppress warnings ( str ) private entity manager get entity manager ( ) { if ( tx data key == null ) { tx data key = new string builder ( str ) . append ( component . get profile specification id ( ) ) . to string ( ) ; } final transaction context tx context = slee transaction manager . get transaction context ( ) ;	Retrieves the entity manager for the current tx and the framework profilespec.
public void start ( ) throws invalid state exception , management exception { try {	Start the SLEE container.
public static class loader switch safely class loader ( final class loader cl , final profile object po ) { class loader cl = null ; if ( system . get security manager ( ) != null ) { cl = ( class loader ) access controller . do privileged ( new privileged action ( ) { public object run ( ) { return switch safely class loader ( cl , po ) ; } } ) ; } else { cl = switch safely class loader ( cl , po ) ; } return cl ; }	This method depending if SecurityManger is present switches class loader using priviledged action,this is requried as some action may be initiated by unsecure domains.
public static object make safe proxy call ( final object proxy , final string method to callname , final class [ ] signature , final object [ ] values ) throws privileged action exception {	Its used to embed calls in AccessController in case of insturmented code, cause javassist does not support anonmous inner class.
protected void check transaction ( ) throws illegal state exception { try { if ( ! slee container . get transaction manager ( ) . get transaction ( ) . equals ( this . transaction ) ) { throw new illegal state exception ( ) ; } } catch ( system exception e ) { throw new illegal state exception ( ) ; } }	Verifies that the current transaction is still the one used to create the object.
private static string to ttl ( string last access , long timeout ) { long ttl = timeout - ( ( system . current time millis ( ) - long . parse long ( last access ) ) / num ) ; return ttl . to string ( ) ; }	Calculates the Activity TTL.
boolean is profile class visible ( ) { try { thread . current thread ( ) . get context class loader ( ) . load class ( profile after action . get class ( ) . get name ( ) ) ; return bool ; } catch ( throwable e ) { return bool ; } }	Verifies if the specified class can be loaded by current thread class loader.
profile object impl get profile object valid in current transaction ( profile entity profile entity ) throws transaction required local exception {	Retrieves a local object valid for thus current transaction.
public list < string > get logger names ( string regex ) throws management console exception { try { return ( list < string > ) this . mbean server . invoke ( log mgmt m , str , new object [ ] { regex } , new string [ ] { str } ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new management console exception ( m . do message ( e ) ) ; } }	SImilar to LoggingMXBean, return list of available loggers.
public void reset logger levels ( ) throws management console exception { try { this . mbean server . invoke ( log mgmt m , str , null , null ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new management console exception ( m . do message ( e ) ) ; } }	Resets all loggers level to default one.
public void clear loggers ( string name ) throws management console exception { try { this . mbean server . invoke ( log mgmt m , str , new object [ ] { name } , new string [ ] { str } ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new management console exception ( m . do message ( e ) ) ; } }	Removes all loggers under certain branch.
public boolean add logger ( string name , level level ) throws null pointer exception , management console exception { try { return ( ( boolean ) this . mbean server . invoke ( log mgmt m , str , new object [ ] { name , level } , new string [ ] { str , str } ) ) . boolean value ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new management console exception ( m . do message ( e ) ) ; } }	Tries to add logger if it doesnt exist.
public boolean remove handler ( string logger name , string handler name ) throws management console exception { try { return ( ( boolean ) this . mbean server . invoke ( log mgmt m , str , new object [ ] { logger name , handler name } , new string [ ] { str , str } ) ) . boolean value ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new management console exception ( m . do message ( e ) ) ; } }	Tries to remove handler from logger.
private string tracer name to log4 j ( string tracer name , notification source notification source ) { final string builder sb = new string builder ( str ) . append ( notification source . to string ( ) ) ; if ( ! tracer name . equals ( root tracer name ) ) { sb . append ( str ) . append ( tracer name ) ; } return sb . to string ( ) ; }	Generates the log4j logger name for the tracer with specified named and notification source.
void sync level with log4j ( ) {	syncs the slee tracer level with the one that related logger has in log4j.
private void assign log4 j ( level log4j level ) { if ( log4j level == null ) { return ; } if ( log4j level == level . debug ) { level = trace level . fine ; } else if ( log4j level == level . info ) { level = trace level . info ; } else if ( log4j level == level . warn ) { level = trace level . warning ; } else if ( log4j level == level . error ) { level = trace level . severe ; } else if ( log4j level == level . trace ) { level = trace level . finest ; } else if ( log4j level == level . off ) { level = trace level . off ; } }	assigns the equiv log4j level to the tracer.
void reset cache flags ( boolean reset childs ) { if ( is traceable ( trace level . finest ) ) { finest enabled = bool ; finer enabled = bool ; fine enabled = bool ; config enabled = bool ; info enabled = bool ; warning enabled = bool ; severe enabled = bool ; } else { finest enabled = bool ; if ( is traceable ( trace level . finer ) ) { finer enabled = bool ; fine enabled = bool ; config enabled = bool ; info enabled = bool ; warning enabled = bool ; severe enabled = bool ; } else { finer enabled = bool ; if ( is traceable ( trace level . fine ) ) { fine enabled = bool ; config enabled = bool ; info enabled = bool ; warning enabled = bool ; severe enabled = bool ; } else { fine enabled = bool ; if ( is traceable ( trace level . config ) ) { config enabled = bool ; info enabled = bool ; warning enabled = bool ; severe enabled = bool ; } else { if ( is traceable ( trace level . info ) ) { info enabled = bool ; warning enabled = bool ; severe enabled = bool ; } else { info enabled = bool ; if ( is traceable ( trace level . warning ) ) { warning enabled = bool ; severe enabled = bool ; } else { warning enabled = bool ; if ( is traceable ( trace level . severe ) ) { severe enabled = bool ; } else { severe enabled = bool ; } } } } } } } if ( reset childs ) {	manages the flags which cache if levels are enabled.
void send notification ( javax . slee . facilities . trace level level , string message , throwable t ) { if ( ! is traceable ( level ) ) { return ; } trace m . send notification ( new trace notification ( notification source . get notification source ( ) . get trace notification type ( ) , trace m , notification source . get notification source ( ) , get tracer name ( ) , level , message , t , notification source . get next sequence ( ) , system . current time millis ( ) ) ) ; }	THis is internaly called, by 1.1 tracers.
public static void check tracer name ( string tracer name , notification source notification source ) throws null pointer exception , invalid argument exception { if ( tracer name . equals ( str ) ) {	This checks if the specified tracer name is ok.
public static void write object ( object output stream out , object vendor data ) throws io {	Write the current object and vendor-specific data to the output stream.
public static object read object ( object input stream in , boolean vendor data deserialization enabled ) throws io , class not found exception {	Read the current object in the input stream from the stream, optionallydeserializing any vendor-specific data in the stream.
public void add direct dependency ( url domain ) { if ( logger . is trace enabled ( ) ) logger . trace ( to string ( ) + str + domain + str ) ; direct dependencies . add ( domain ) ; }	Adds a direct dependency to this domain.
public list < url > get all dependencies ( ) { list < url > result = new array list < url > ( ) ; this . get all dependencies ( result ) ; return result ; }	Retrieves a flat list containing all dependencies for the domain, i.e., all direct dependencies and their own dependencies.
protected class < ? > find class locally ( string name ) throws class not found exception { if ( logger . is trace enabled ( ) ) { logger . trace ( to string ( ) + str + name ) ; } final boolean acquired lock = acquire global lock ( ) ; try { return find class locally locked ( name ) ; } finally { if ( acquired lock ) { release global lock ( ) ; } } }	Finds a class locally, i.e., in the URLs managed by the extendedURLClassLoader.
protected url find resource locally ( string name ) { if ( logger . is trace enabled ( ) ) logger . trace ( to string ( ) + str + name ) ; return super . find resource ( name ) ; }	Finds a resource locally, i.e., in the URLs managed by the extendedURLClassLoader.
protected enumeration < url > find resources locally ( string name ) throws io { if ( logger . is trace enabled ( ) ) logger . trace ( to string ( ) + str + name ) ; return super . find resources ( name ) ; }	Finds resources locally, i.e., in the URLs managed by the extendedURLClassLoader.
private m create and register profile m ( string profile name , profile table impl profile table ) throws management exception { if ( logger . is debug enabled ( ) ) { logger . debug ( str + profile table + str + profile name + str ) ; } try { profile specification component component = profile table . get profile specification component ( ) ; constructor < ? > constructor = component . get profile m ( ) . get constructor ( class . class , string . class , profile table impl . class ) ; final m profile m = ( m ) constructor . new instance ( component . get profile m ( ) , profile name , profile table ) ; profile m . register ( ) ;	Creates and registers a profile mbean for the specified object.
void resume transaction ( slee transaction transaction ) throws slee { if ( transaction != null ) { try { tx manager . resume ( transaction ) ; } catch ( throwable e ) { throw new slee ( e . get message ( ) , e ) ; } } }	Resumes the specified tx.
public set < id > get sbb i ( component repository component repository ) { set < id > result = new hash set < id > ( ) ; build sbb tree ( descriptor . get root sbb id ( ) , result , component repository ) ; return result ; }	Retrieves the set of sbbs used by this service.
public set < string > get resource adaptor entity links ( component repository component repository ) { set < string > result = new hash set < string > ( ) ; for ( id sbb id : get sbb i ( component repository ) ) { sbb component sbb component = component repository . get component by id ( sbb id ) ; for ( resource adaptor type binding descriptor ra type binding : sbb component . get descriptor ( ) . get resource adaptor type bindings ( ) ) { for ( resource adaptor entity binding descriptor ra entity binding : ra type binding . get resource adaptor entity binding ( ) ) { result . add ( ra entity binding . get resource adaptor entity link ( ) ) ; } } } return result ; }	Retrieves the set of ra entity links referenced by the sbbs related with the service.
public void init slee ( ) throws invalid state exception { if ( slee state != null ) { throw new invalid state exception ( str + slee state + str ) ; }	Initiates the SLEE container.
public void shutdown slee ( ) throws invalid state exception { if ( slee state != slee state . stopped ) { throw new invalid state exception ( str + slee state + str ) ; }	Shutdown of the SLEE container.
private void validate state transition ( slee state old state , slee state new state ) throws invalid state exception { if ( old state == slee state . stopped ) { if ( new state == slee state . starting ) { return ; } } else if ( old state == slee state . starting ) { if ( new state == slee state . running || new state == slee state . stopping ) { return ; } } else if ( old state == slee state . running ) { if ( new state == slee state . stopping ) { return ; } } else if ( old state == slee state . stopping ) { if ( new state == slee state . stopped ) { return ; } } throw new invalid state exception ( str + old state + str + new state ) ; }	Ensures the standard SLEE lifecycle.
private void generate named usage parameter getter ( ct class profile concrete class ) { string method name = str ; for ( ct method ct method : profile concrete class . get methods ( ) ) { if ( ct method . get name ( ) . equals ( method name ) ) { try {	Create a named usage parameter getter.
public update query set ( string field name , object value ) { string updated field name = str + field name ; values . append ( field name ) . append ( str ) . append ( updated field name ) . append ( str ) ; query . set argument ( updated field name , value ) ; return this ; }	Set column to update.
public jdbc build ( ) { transaction manager manager ; if ( data source != null ) { manager = new data source transaction manager ( data source ) ; } else { manager = new external transaction manager ( connection provider ) ; } return new jdbc ( dialect , schema name , new column type mapper ( custom mappings ) , manager ) ; }	Return new PolyJDBC instance.
public insert query value ( string field name , object value ) { value names . append ( field name ) . append ( str ) ; values . append ( str ) . append ( field name ) . append ( str ) ; set argument ( field name , value ) ; return this ; }	Insert value into column of given name.
public < t > t run ( transaction wrapper < t > operation ) { query runner runner = null ; try { runner = query runner factory . create ( ) ; t result = operation . perform ( runner ) ; runner . commit ( ) ; return result ; } catch ( throwable throwable ) { the closer . rollback ( runner ) ; throw new transaction interrupted exception ( throwable ) ; } finally { the closer . close ( runner ) ; } }	Run specified operations in safe transaction block.
@ json creator public static region request from string ( string str ) throws resolving exception { if ( str . equals ( str ) ) { return new region request ( ) ; } if ( str . equals ( str ) ) { return new region request ( bool ) ; } matcher matcher = parse pat . matcher ( str ) ; if ( ! matcher . matches ( ) ) { throw new resolving exception ( str + str ) ; } if ( matcher . group ( num ) == null ) { return new region request ( integer . value of ( matcher . group ( num ) ) , integer . value of ( matcher . group ( num ) ) , integer . value of ( matcher . group ( num ) ) , integer . value of ( matcher . group ( num ) ) ) ; } else { return new region request ( new big decimal ( matcher . group ( num ) ) , new big decimal ( matcher . group ( num ) ) , new big decimal ( matcher . group ( num ) ) , new big decimal ( matcher . group ( num ) ) ) ; } }	Parse an IIIF Image API compliant region request string.
public d get region ( ) { if ( is relative ( ) ) { return new d . double ( relative box . x . double value ( ) , relative box . y . double value ( ) , relative box . w . double value ( ) , relative box . h . double value ( ) ) ; } else { return absolute box ; } }	Returns the requested region.
private string get on type ( deserialization context ctxt ) {	Get type for "on" values that are plain URIs by deducing the type from their parent.
public void set viewing hints ( list < viewing hint > viewing hints ) throws illegal argument exception { for ( viewing hint hint : viewing hints ) { boolean supports hint = ( hint . get type ( ) == viewing hint . type . other || this . get supported viewing hint types ( ) . contains ( hint . get type ( ) ) ) ; if ( ! supports hint ) { throw new illegal argument exception ( string . format ( str , this . get type ( ) , hint . to string ( ) ) ) ; } } this . viewing hints = viewing hints ; }	Set the viewing hints for this resource.
public resource add viewing hint ( viewing hint first , viewing hint ... rest ) throws illegal argument exception { list < viewing hint > hints = this . viewing hints ; if ( hints == null ) { hints = new array list < > ( ) ; } hints . add all ( lists . as list ( first , rest ) ) ; this . set viewing hints ( hints ) ; return this ; }	Add one or more viewing hints for this resource.
public void set renderings ( list < other content > renderings ) throws illegal argument exception { renderings . for each ( this :: verify rendering ) ; this . renderings = renderings ; }	Sets the renderings. All renderings must have both a profile and a format.
public resource add rendering ( other content first , other content ... rest ) { if ( renderings == null ) { this . renderings = new array list < > ( ) ; } list < other content > renderings to add = lists . as list ( first , rest ) ; renderings to add . for each ( this :: verify rendering ) ; this . renderings . add all ( renderings to add ) ; return this ; }	Add one or more renderings.
public static image api profile merge ( list < profile > profiles ) { return profiles . stream ( ) . filter ( image api profile . class :: is instance ) . map ( image api profile . class :: cast ) . reduce ( new image api profile ( ) , image api profile :: merge ) ; }	Merge multiple profiles into one.
@ json creator public static rotation request from string ( string str ) throws resolving exception { matcher matcher = pattern . matcher ( str ) ; if ( ! matcher . matches ( ) ) { throw new resolving exception ( str + str ) ; } return new rotation request ( new big decimal ( matcher . group ( num ) ) , ! ( matcher . group ( num ) == null ) ) ; }	Parse a rotation request from an IIIF Image API compliant rotation string.
@ json creator public static size request from string ( string str ) throws resolving exception { if ( str . equals ( str ) ) { return new size request ( ) ; } if ( str . equals ( str ) ) { return new size request ( bool ) ; } matcher matcher = parse pat . matcher ( str ) ; if ( ! matcher . matches ( ) ) { throw new resolving exception ( str + str ) ; } if ( matcher . group ( num ) != null ) { if ( matcher . group ( num ) . equals ( str ) ) { return new size request ( integer . value of ( matcher . group ( num ) ) , integer . value of ( matcher . group ( num ) ) , bool ) ; } else if ( matcher . group ( num ) . equals ( str ) ) { return new size request ( new big decimal ( matcher . group ( num ) ) ) ; } } integer width = null ; integer height = null ; if ( matcher . group ( num ) != null ) { width = integer . parse int ( matcher . group ( num ) ) ; } if ( matcher . group ( num ) != null ) { height = integer . parse int ( matcher . group ( num ) ) ; } return new size request ( width , height ) ; }	Parse an IIIF Image API compliant size request string.
protected void initialize adb connection ( ) {	Initializes the AndroidDebugBridge and registers the DefaultHardwareDeviceManager with theAndroidDebugBridge device change listener.
public string get dump ( ) { push automator2 device ( ) ; runtest ( ) ; string path = pull dump2 pc ( ) ; string xml = str ; try { file input stream file input stream = new file input stream ( path ) ; @ suppress warnings ( str ) buffered reader in = new buffered reader ( new input stream reader ( file input stream ) ) ; string buffer buffer = new string buffer ( ) ; string line = str ; while ( ( line = in . read line ( ) ) != null ) { buffer . append ( line ) ; } xml = buffer . to string ( ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } return xml ; }	get current android page's dump file.
public boolean handle pop box ( string device brand ) { push handle gps2 device ( ) ; command line exe command = null ; if ( device brand . contains ( str ) ) { exe command = adb command ( str , str , str , str , str , str ) ; } else if ( device brand . contains ( str ) ) { exe command = adb command ( str , str , str , str , str , str ) ; } string output = execute command quietly ( exe command ) ; log . debug ( str , output ) ; try {	try to click GPS Popup window.
private boolean push handle gps2 device ( ) { input stream io = abstract device . class . get resource as stream ( str ) ; file dest = new file ( file utils . get temp directory ( ) , str ) ; try { file utils . copy input stream to file ( io , dest ) ; } catch ( io e ) { e . print stack trace ( ) ; } command line pushcommand = adb command ( str , dest . get absolute path ( ) , str ) ; string output push = execute command quietly ( pushcommand ) ; log . debug ( str , output push ) ; try {	Push handlePopBox.jar to android tmp folder.
public void clean temp ( ) { command line dumpcommand = adb command ( str , str , str , str ) ; execute command quietly ( dumpcommand ) ; try {	clean file dump.xml, qian.xml, uidump.xml in tmp folder.
public string pull dump2 pc ( ) { string serial = device . get serial number ( ) ; file dest = new file ( file utils . get temp directory ( ) , serial + str ) ; string path = dest . get path ( ) ; log . debug ( str , path ) ; command line commandpull = adb command ( str , str , path ) ; string out = execute command quietly ( commandpull ) ; log . debug ( str , out ) ; return path ; }	pull dump file from android device to pc.
public string get crash log ( ) { string crash log file name = null ; file crash log file = new file ( get external storage path ( ) , crash log file name ) ;	Get crash log from AUT.
public text editor detabify ( final int tab width ) { replace all ( pattern . compile ( str ) , new replacement ( ) { public string replacement ( matcher m ) { string line so far = m . group ( num ) ; int width = line so far . length ( ) ; string builder replacement = new string builder ( line so far ) ; do { replacement . append ( str ) ; ++ width ; } while ( width % tab width != num ) ; return replacement . to string ( ) ; } } ) ; return this ; }	Convert tabs to spaces.
public text editor indent ( int spaces ) { string builder sb = new string builder ( spaces ) ; for ( int i = num ; i < spaces ; i ++ ) { sb . append ( str ) ; } return replace all ( str , sb . to string ( ) ) ; }	Introduce a number of spaces at the start of each line.
public collection < html > tokenize html ( ) { list < html > tokens = new array list < html > ( ) ; string nested tags = nested tags regex ( num ) ; pattern p = pattern . compile ( str + str + str + str + str + nested tags + str , pattern . case insensitive ) ; matcher m = p . matcher ( text ) ; int last pos = num ; while ( m . find ( ) ) { if ( last pos < m . start ( ) ) { tokens . add ( html . text ( text . substring ( last pos , m . start ( ) ) ) ) ; } tokens . add ( html . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; last pos = m . end ( ) ; } if ( last pos < text . length ( ) ) { tokens . add ( html . text ( text . substring ( last pos , text . length ( ) ) ) ) ; } return tokens ; }	Parse HTML tags, returning a Collection of HTMLToken objects.
public string markdown ( string txt ) { if ( txt == null ) { txt = str ; } text editor text = new text editor ( txt ) ;	Perform the conversion from Markdown to HTML.
private text editor escape special chars within tag attributes ( text editor text ) { collection < html > tokens = text . tokenize html ( ) ; text editor new text = new text editor ( str ) ; for ( html token : tokens ) { string value = token . get text ( ) ; if ( token . is tag ( ) ) { value = value . replace all ( str , char protector . encode ( str ) ) ; value = value . replace all ( str , char protector . encode ( str ) ) ; value = value . replace all ( str , char protector . encode ( str ) ) ; value = value . replace all ( str , char protector . encode ( str ) ) ; } new text . append ( value ) ; } return new text ; }	escape special charactersWithin tags -- meaning between -- encode [\ ` * _] so theydon't conflict with their use in Markdown for code, italics and strong.We're replacing each such character with its corresponding random stringvalue; this is likely overkill, but it should prevent us from collidingwith the escape values by accident.
final void add exception ( sql exception ) { if ( ! ( exception instanceof sql ) && ! ( exception instanceof sql ) ) { get or init ( ) . offer ( exception ) ;	This method will be called when an operation invoked on a JDBC object throws an SQLException.It will accumulate a list of all non-transient SQL exceptions.
@ override public void close ( ) { if ( closed . get and set ( bool ) ) { return ; } for ( map . entry < statement method , statement holder > entry : statement cache . entry set ( ) ) { statement holder value = entry . get value ( ) ; statement cache . remove ( entry . get key ( ) , value ) ; quiet close ( value . raw statement ( ) ) ; } }	Closes this ClhmStatementCache and removes all entries from it.
private string find parent fqcn ( type element type element , set < string > parents ) { type mirror type ; while ( bool ) { type = type element . get superclass ( ) ; if ( type . get kind ( ) == type kind . none ) { return null ; } type element = ( type element ) ( ( declared type ) type ) . as element ( ) ; if ( parents . contains ( type element . to string ( ) ) ) { string package name = get package name ( type element ) ; return package name + str + get class name ( type element , package name ) ; } } }	Finds the parent barbershop type in the supplied set, if any.
void write to filer ( filer filer ) throws io { class name target class name = class name . get ( class package , target class ) ; type spec . builder barber shop = type spec . class builder ( class name ) . add modifiers ( modifier . public ) . add type variable ( type variable name . get ( str , target class name ) ) . add method ( generate style method ( ) ) . add method ( generate check parent method ( ) ) ; if ( parent barbershop == null ) { barber shop . add superinterface ( parameterized type name . get ( class name . get ( barber . i . class ) , type variable name . get ( str ) ) ) ; barber shop . add field ( field spec . builder ( weak hash set . class , str , modifier . protected ) . initializer ( str , weak hash set . class ) . build ( ) ) ; } else { barber shop . superclass ( parameterized type name . get ( class name . best guess ( parent barbershop ) , type variable name . get ( str ) ) ) ; } java file java file = java file . builder ( class package , barber shop . build ( ) ) . build ( ) ; java file . write to ( filer ) ; }	Generates the class code and writes to a new source file.
public void write bit vector01 divider ( bit vector01 divider divider ) throws io { dos . write boolean ( divider . is first ( ) ) ; dos . write boolean ( divider . is zero counting ( ) ) ; }	Write BitVector01Divider to OutputStream.
public static void append bit strings ( bit vector bv , string [ ] bs ) { for ( string s : bs ) { if ( s . length ( ) != num ) throw new runtime exception ( str + s . length ( ) ) ; for ( char c : s . to char array ( ) ) { if ( c == str ) bv . append0 ( ) ; else if ( c == str ) bv . append1 ( ) ; else throw new runtime exception ( str + c + str ) ; } } }	Append bits from bit string.
public void read from ( input stream is ) throws io { data input stream dis = new data input stream ( is ) ; first = dis . read boolean ( ) ; zero counting = dis . read boolean ( ) ; }	Read data from InputStream.
protected static < type > list < type > get list ( string path , string key , class < type > expected class , list < string > filters ) { string builder temp path = new string builder ( path ) ; temp path . append ( str ) ; for ( string filter : filters ) { temp path . append ( filter ) . append ( str ) ; } return get list ( temp path . substring ( num , temp path . length ( ) - num ) , key , expected class ) ; }	Get the list of objects with a filter if there is anything that matches the filters.
private static synchronized void set klov report ( ) { if ( extent reports == null ) {	When running cucumber tests in parallel Klov reporter should be attached only once, in order to avoid duplicate builds on klov server.
public static void add screen capture from path ( string image path , string title ) throws io { get current step ( ) . add screen capture from path ( image path , title ) ; }	Adds the screenshot from the given path with the given title to the current step.
public static void set system info ( string key , string value ) { if ( system info key map . is empty ( ) || ! system info key map . contains key ( key ) ) { system info key map . put ( key , bool ) ; } if ( system info key map . get ( key ) ) { return ; } get extent report ( ) . set system info ( key , value ) ; system info key map . put ( key , bool ) ; }	Sets the system information with the given key value pair.
public static selector select ( final string prop name ) { return new selector ( prop name , prop name ) { @ override public void handle row ( int index , map < string , object > row , object item , map < string , field access > fields ) { get property value and put into row ( row , item , fields ) ; } @ override public void handle start ( collection < ? > results ) { } @ override public void handle complete ( list < map < string , object > > rows ) { } } ; }	Allows you to select a property or property path.
public static selector select as ( final string prop name , final string alias , final function transform ) { return new selector ( prop name , alias ) { @ override public void handle row ( int index , map < string , object > row , object item , map < string , field access > fields ) { if ( ! path && fields != null ) { row . put ( this . name , transform . apply ( fields . get ( this . name ) . get value ( item ) ) ) ; } else { row . put ( alias , transform . apply ( bean utils . at index ( item , prop name ) ) ) ; } } @ override public void handle start ( collection < ? > results ) { } @ override public void handle complete ( list < map < string , object > > rows ) { } } ; }	Selects but allows having a different alias for the output.
public static list < annotation data > extract validation annotation data ( annotation [ ] annotations , set < string > allowed packages ) { list < annotation data > annotations list = new array list < > ( ) ; for ( annotation annotation : annotations ) { annotation data annotation data = new annotation data ( annotation , allowed packages ) ; if ( annotation data . is allowed ( ) ) { annotations list . add ( annotation data ) ; } } return annotations list ; }	Create an annotation data list.
private static annotation [ ] extract all annotations for property ( class < ? > clazz , string property name , boolean use read ) { try { annotation [ ] annotations = find property annotations ( clazz , property name , use read ) ; if ( annotations . length == num ) { annotations = find property annotations ( clazz . get superclass ( ) , property name , use read ) ; } return annotations ; } catch ( exception ex ) { return exceptions . handle ( annotation [ ] . class , sputs ( str , property name , str , clazz , str , use read ) , ex ) ; } }	Extract all annotation for a given property.Searches current class and if none found searchessuper class for annotation.
private static annotation [ ] find property annotations ( class < ? > clazz , string property name , boolean use read ) throws introspection exception { property descriptor property descriptor = get property descriptor ( clazz , property name ) ; if ( property descriptor == null ) { return new annotation [ ] { } ; } method access method = null ; if ( use read ) { access method = property descriptor . get read method ( ) ; } else { access method = property descriptor . get write method ( ) ; } if ( access method != null ) { annotation [ ] annotations = access method . get annotations ( ) ; return annotations ; } else { return new annotation [ ] { } ; } }	Find annotation given a particular property name and clazz.
private static property descriptor do get property descriptor ( final class < ? > type , final string property name ) { try { bean info bean info = introspector . get bean info ( type ) ; property descriptor [ ] property descriptors = bean info . get property descriptors ( ) ; for ( property descriptor pd : property descriptors ) { if ( pd . get name ( ) . equals ( property name ) ) { return pd ; } } class < ? > superclass = type . get superclass ( ) ; if ( superclass != null ) { return do get property descriptor ( superclass , property name ) ; } return null ; } catch ( exception ex ) { throw new runtime exception ( str + property name + str + type , ex ) ; } }	This needs to be refactored and put into Reflection or something.
@ suppress warnings ( str ) public static < t > t from map ( map < string , object > map , class < t > clazz ) { return mapper . from map ( map , clazz ) ; }	From map.
@ suppress warnings ( str ) public static < t > t from map ( map < string , object > map , class < t > clazz , string ... exclude properties ) { set < string > ignore props = exclude properties . length > num ? sets . set ( exclude properties ) : null ; return new mapper complex ( field access mode . field then property . create ( bool ) , ignore props , null , bool ) . from map ( map , clazz ) ; }	fromMap converts a map into a java object.
public static map < string , object > to map ( final object object , final string ... ignore ) { return to map ( object , sets . set ( ignore ) ) ; }	Basic toMap to create an object into a map.
public static map < string , object > to map ( final object object , set < string > ignore ) { return new mapper complex ( ignore ) . to map ( object ) ; }	This could be refactored to use core.TypeType class and it would run faster.Converts an object into a map.
map < string , object > do get values ( annotation annotation ) { map < string , object > values = new hash map < string , object > ( ) ; method [ ] methods = annotation . annotation type ( ) . get declared methods ( ) ; final object [ ] noargs = ( object [ ] ) null ; for ( method method : methods ) { if ( method . get parameter types ( ) . length == num ) { try { object value = method . invoke ( annotation , noargs ) ; if ( value instanceof enum ) { enum enum val = ( enum ) value ; value = enum val . name ( ) ; } values . put ( method . get name ( ) , value ) ; } catch ( exception ex ) { throw new runtime exception ( ex ) ; } } } return values ; }	Get the values from the annotation.We use reflection to turn the annotation into a simple HashMapof values.
protected composite validator create validator ( list < validator meta data > validation meta data list ) { composite validator composite validator = new composite validator ( ) ;	Create the validator by looking it up in the ObjectRegistry and thenpopulating it with values from the meta-data list.
private list < field validator > lookup the list of validators and initialize them with meta data properties ( list < validator meta data > validation meta data list ) { list < field validator > validators list = new array list < > ( ) ; for ( validator meta data validation meta data : validation meta data list ) { field validator validator = lookup validator in registry ( validation meta data . get name ( ) ) ; apply validation meta data properties to validator ( validation meta data , validator ) ; validators list . add ( validator ) ; } return validators list ; }	Lookup the list of validators for the current field and initialize themwith validation meta-data properties.
private field validator lookup validator in registry ( string validation meta data name ) { map < string , object > application context = validation context . get ( ) . get object registry ( ) ; exceptions . require non null ( application context ) ; return ( field validator ) application context . get ( str + validation meta data name ) ; }	This method looks up the validator in the registry.
private void apply validation meta data properties to validator ( validator meta data meta data , field validator validator ) { map < string , object > properties = meta data . get properties ( ) ; if property blank remove ( properties , str ) ; if property blank remove ( properties , str ) ; bean utils . copy properties ( validator , properties ) ; }	This method applies the properties from the validationMetaData to thevalidator uses Spring's BeanWrapperImpl.
private void if property blank remove ( map < string , object > properties , string property ) { object object = properties . get ( property ) ; if ( object == null ) { properties . remove ( property ) ; } else if ( object instanceof string ) { string string = ( string ) object ; if ( str . equals ( string . trim ( ) ) ) { properties . remove ( property ) ; } } }	Removes a property if it is null or an empty string.This allows the property to have a null or emtpy string in themeta-data but we don't copy it to the validator if the propertyis not set.
@ override public void tick ( long time ) { this . time . set ( time ) ; approx time . set ( dates . utc now ( ) ) ; }	Calculate utc time. This gets called every 20 mili-seconds or so.
@ override public int size ( ) { int size = num ; for ( simple cache < k , v > cache : cache regions ) { size += cache . size ( ) ; } return size ; }	Get the size of the cache.This is not 100% accurate if cache is being concurrenly accessed.
private final int hash ( object k ) { int h = hash seed ; h ^= k . hash code ( ) ; h ^= ( h > > > num ) ^ ( h > > > num ) ; return h ^ ( h > > > num ) ^ ( h > > > num ) ; }	Calculate the hash.
private boolean open db ( file file , options options ) { try { database = db . factory . open ( file , options ) ; logger . info ( str ) ; return bool ; } catch ( io ex1 ) { try { database = db . factory . open ( file , options ) ; logger . info ( str ) ; return bool ; } catch ( io ex2 ) { return exceptions . handle ( boolean . class , ex2 ) ; } } }	Opens the database.
@ override public void put all ( map < byte [ ] , byte [ ] > values ) { write batch batch = database . create write batch ( ) ; try { for ( map . entry < byte [ ] , byte [ ] > entry : values . entry set ( ) ) { batch . put ( entry . get key ( ) , entry . get value ( ) ) ; } if ( put all write count . add and get ( values . size ( ) ) > num ) { put all write count . set ( num ) ; database . write ( batch , flush ) ; } else { database . write ( batch , write options ) ; } } finally { close batch ( batch ) ; } }	Puts values into the key value store in batch mode.
@ override public void remove all ( iterable < byte [ ] > keys ) { write batch batch = database . create write batch ( ) ; try { for ( byte [ ] key : keys ) { batch . delete ( key ) ; } database . write ( batch ) ; } finally { close batch ( batch ) ; } }	Remove all of the keys passed.
@ override public key value iterable < byte [ ] , byte [ ] > search ( byte [ ] start key ) { final db iterator = database . iterator ( ) ; iterator . seek ( start key ) ; return new key value iterable < byte [ ] , byte [ ] > ( ) { @ override public void close ( ) { close iterator ( iterator ) ; } @ override public iterator < entry < byte [ ] , byte [ ] > > iterator ( ) { return new iterator < entry < byte [ ] , byte [ ] > > ( ) { @ override public boolean has next ( ) { return iterator . has next ( ) ; } @ override public entry < byte [ ] , byte [ ] > next ( ) { map . entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; return new entry < > ( next . get key ( ) , next . get value ( ) ) ; } @ override public void remove ( ) { iterator . remove ( ) ; } } ; } } ; }	Search to a certain location.
@ override public map < byte [ ] , byte [ ] > load all by keys ( collection < byte [ ] > keys ) { if ( keys == null || keys . size ( ) == num ) { return collections . empty map ; } map < byte [ ] , byte [ ] > results = new linked hash map < > ( keys . size ( ) ) ; db iterator = null ; try { iterator = database . iterator ( ) ; iterator . seek ( keys . iterator ( ) . next ( ) ) ; while ( iterator . has next ( ) ) { final map . entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; results . put ( next . get key ( ) , next . get value ( ) ) ; } } finally { try { if ( iterator != null ) { iterator . close ( ) ; } } catch ( io e ) { exceptions . handle ( e ) ; } } return results ; }	Keys are expected to be sorted.
@ override public void close ( ) { try { flush ( ) ; database . close ( ) ; } catch ( exception e ) { exceptions . handle ( e ) ; } }	Close the database connection.
public static < t > double reduce by ( final double [ ] array , t object ) { if ( object . get class ( ) . is anonymous class ( ) ) { return reduce by r ( array , object ) ; } try { constant call site call site = invoker . invoke reducer long int return long method handle ( object ) ; method handle method handle = call site . dynamic invoker ( ) ; try { double sum = num ; for ( double v : array ) { sum = ( double ) method handle . invoke exact ( sum , v ) ; } return sum ; } catch ( throwable throwable ) { return handle ( long . class , throwable , str ) ; } } catch ( exception ex ) { return reduce by r ( array , object ) ; } }	Reduce by functional support for int arrays.
private static < t > double reduce by r ( final double [ ] array , t object ) { try { method method = invoker . invoke reducer long int return long method ( object ) ; double sum = num ; for ( double v : array ) { sum = ( double ) method . invoke ( object , sum , v ) ; } return sum ; } catch ( throwable throwable ) { return handle ( long . class , throwable , str ) ; } }	Fallback to reflection if the call-site will not work or did not work.
public static double variance double ( double [ ] values , final int start , final int length ) { double mean = mean ( values , start , length ) ; double temp = num ; for ( int index = start ; index < length ; index ++ ) { double a = values [ index ] ; temp += ( mean - a ) * ( mean - a ) ; } return temp / length ; }	Calculate Variance.
public static double mean double ( long [ ] values , final int start , final int length ) { double mean = ( ( double ) sum ( values , start , length ) ) / ( ( double ) length ) ; return mean ; }	Used internally to avoid loss and rounding errors a bit.
public static object invoke method from object arg ( object object , method access method , object args ) { return invoke method from object arg ( bool , null , null , object , method , args ) ; }	Invokes method from list or map depending on what the Object arg is.
public static double reduce by ( final float [ ] array , reduce by reduce by ) { double sum = num ; for ( float v : array ) { sum = reduce by . reduce ( sum , v ) ; } return sum ; }	A very fast reduce by.If performance is your thing, this seems to be as fast a plain for loop when benchmarking with JMH.
public static string euro utc ( long timestamp ) { calendar calendar = calendar . get instance ( ) ; calendar . set time in millis ( timestamp ) ; calendar . set time zone ( utc time zone ) ; int day = calendar . get ( calendar . day of month ) ; int month = calendar . get ( calendar . month ) ; int year = calendar . get ( calendar . year ) ; int hour = calendar . get ( calendar . hour of day ) ; int minute = calendar . get ( calendar . minute ) ; int second = calendar . get ( calendar . second ) ; char buf buf = char buf . create ( num ) ; buf . add ( str . zfill ( day , num ) ) . add ( str ) ; buf . add ( str . zfill ( month , num ) ) . add ( str ) ; buf . add ( year ) . add ( str ) ; buf . add ( str . zfill ( hour , num ) ) . add ( str ) ; buf . add ( str . zfill ( minute , num ) ) . add ( str ) ; buf . add ( str . zfill ( second , num ) ) . add ( str ) ; return buf . to string ( ) ; }	Useful for generated file names and generated work directories.
public static boolean matches ( object obj , criteria ... exp ) { return object filter . and ( exp ) . test ( obj ) ; }	Does the object match this expression.An expression is a collection of criteria.
public static criterion not in ( final object name , final object ... values ) { return new criterion < object > ( name . to string ( ) , operator . not in , values ) { @ override public boolean resolve ( object owner ) { object field value = field value ( ) ; if ( value == null ) { return bool ; } return ! value set ( ) . contains ( field value ) ; } } ; }	This has to convert values to field type.
public static criteria criteria from list ( list < ? > list ) { list < object > args = new array list ( list ) ; object o = at index ( args , - num ) ; if ( ! ( o instanceof list ) ) { at index ( args , - num , collections . singleton list ( o ) ) ; } return ( criteria ) invoker . invoke from list ( object filter . class , str , args ) ; }	Creates criteria from a list.
public static criteria criteria from json ( string json ) { return ( criteria ) invoker . invoke from object ( object filter . class , str , from json ( json ) ) ; }	Converts a JSON string into a Criteria.
public boolean add array ( double ... integers ) { if ( end + integers . length >= values . length ) { values = grow ( values , ( values . length + integers . length ) * num ) ; } system . arraycopy ( integers , num , values , end , integers . length ) ; end += integers . length ; return bool ; }	Add a new array to the list.
public static < t > t max ( t [ ] array ) { if ( array . length > num ) { sorting . sort desc ( array ) ; return array [ num ] ; } else { return null ; } }	Gets the max item from the array.Sorts the list descending first.
public static < t > list < t > first of ( list < t > list , int count , sort ... sorts ) { if ( list . size ( ) > num ) { sorting . sort ( list , sorts ) ; return lists . slice of ( list , num , count ) ; } else { return null ; } }	From the sorts, this is the first few items.
public static < t > t last of ( list < t > list , sort ... sorts ) { if ( list . size ( ) > num ) { sorting . sort ( list , sorts ) ; return list . get ( list . size ( ) - num ) ; } else { return null ; } }	Grabs the last items after the sort.
public static < t > list < t > last of ( list < t > list , int count , sort ... sorts ) { if ( list . size ( ) > num ) { sorting . sort ( list , sorts ) ; return lists . end slice of ( list , count * - num ) ; } else { return null ; } }	Grabs the last few items from the list.
public static < t > list < t > least ( list < t > list , int count ) { if ( list . size ( ) > num ) { sorting . sort ( list ) ; return lists . slice of ( list , num , count ) ; } else { return null ; } }	Returns the least few.
public static < t > t min ( list < t > list ) { if ( list . size ( ) > num ) { sorting . sort ( list ) ; return list . get ( num ) ; } else { return null ; } }	Returns the min value using a natural sort.
public static < t > t min ( t [ ] array , string sort by ) { if ( array . length > num ) { sorting . sort ( array , sort by ) ; return array [ num ] ; } else { return null ; } }	Returns the min value of the object with the property given.
private void process array of maps ( object new instance , field access field , map < string , object > [ ] maps ) { list < map < string , object > > list = lists . list ( maps ) ; handle collection of maps ( new instance , field , list ) ; }	Processes an array of maps.
@ suppress warnings ( str ) private void handle collection of maps ( object new instance , field access field , collection < map < string , object > > collection of maps ) { collection < object > new collection = conversions . create collection ( field . type ( ) , collection of maps . size ( ) ) ; class < ? > component class = field . get component class ( ) ; if ( component class != null ) { for ( map < string , object > map component : collection of maps ) { new collection . add ( from map ( map component , component class ) ) ; } field . set object ( new instance , new collection ) ; } }	Processes an collection of maps.
@ override public object from map ( map < string , object > map ) { string clazz = ( string ) map . get ( str ) ; class cls = reflection . load class ( clazz ) ; return from map ( map , cls ) ; }	fromMap converts a map into a Java object.This version will see if there is a class parameter in the map, and dies if there is not.
@ override public value get ( key key ) { remove then add key ( key ) ; return map . get ( key ) ; }	Get the value at key.
public static string create tool tip with name space ( final string namespace , final string field name , final resource bundle bundle , final string tool tip type ) { string tool tip = null ; try { try { tool tip = bundle . get string ( namespace + str + field name + str + tool tip type ) ; } catch ( missing resource exception mre ) { tool tip = bundle . get string ( field name + str + tool tip type ) ; } } catch ( missing resource exception mre ) { } return tool tip ; }	Get the tool tip.
public char sequence add hex ( final int decoded ) { int location = location ; char [ ] buffer = buffer ; int capacity = capacity ; if ( num + location > capacity ) { buffer = chr . grow ( buffer ) ; capacity = buffer . length ; } buffer [ location ] = ( char ) encode nibble to hex ascii char byte ( ( decoded > > num ) & num ) ; location ++ ; buffer [ location ] = ( char ) encode nibble to hex ascii char byte ( decoded & num ) ; ; location ++ ; location = location ; buffer = buffer ; capacity = capacity ; return this ; }	Turn a single bytes into two hex character representation.
private void process write queue ( ) throws interrupted exception { write status status = new write status ( ) ; while ( bool ) { data store request operation = write operations queue . poll ( data store config . poll timeout ms ( ) , time unit . milliseconds ) ; while ( operation != null ) { status . tracker . add call ( operation , output data queue ) ; write operations batch . add ( operation ) ; if ( write operations batch . size ( ) > data store config . process queue max batch size ( ) ) { break ; } operation = write operations queue . poll ( ) ; } if ( write operations batch . size ( ) > num ) { try { status . write batch size . add ( write operations batch . size ( ) ) ; recieved write batch ( new array list < > ( write operations batch ) ) ; } finally { write operations batch . clear ( ) ; } } else { flush writes if needed ( ) ; } if ( status . write batch size . size ( ) > num ) { status . send batch size ( source , output data queue ) ; } } }	Called from worker thread.Processes the incoming queue for read and writes.
public void start ( ) { scheduled executor service = executors . new scheduled thread pool ( num , new thread factory ( ) { @ override public thread new thread ( runnable runnable ) { thread thread = new thread ( runnable ) ; thread . set name ( str + source ) ; return thread ; } } ) ; future = scheduled executor service . schedule at fixed rate ( new runnable ( ) { @ override public void run ( ) { if ( stop . get ( ) ) { return ; } try { process write queue ( ) ; } catch ( interrupted exception ex ) {	Start up the queue handlers.
@ universal public static string at index ( string str , int index , char c ) { return idx ( str , index , c ) ; }	Puts character at index.
@ universal public static string slc ( string str , int start ) { return fast string utils . no copy string from chars ( chr . slc ( fast string utils . to char array ( str ) , start ) ) ; }	Gets slice of a string.
@ universal public static boolean in ( char [ ] chars , string str ) { return chr . in ( chars , fast string utils . to char array ( str ) ) ; }	See if chars is in another string.
@ universal public static string add ( string str , char c ) { return fast string utils . no copy string from chars ( chr . add ( fast string utils . to char array ( str ) , c ) ) ; }	Add a char to a string.
public static string add objects ( object ... objects ) { int length = num ; for ( object obj : objects ) { if ( obj == null ) { continue ; } length += obj . to string ( ) . length ( ) ; } char buf builder = char buf . create exact ( length ) ; for ( object str : objects ) { if ( str == null ) { continue ; } builder . add ( str . to string ( ) ) ; } return builder . to string ( ) ; }	Add many objects converted to strings together.Null are ignored so be careful.
public static string compact ( string str ) { return fast string utils . no copy string from chars ( chr . compact ( fast string utils . to char array ( str ) ) ) ; }	Gets rid of null characters lurking in the string.
public static string [ ] split ( string str ) { char [ ] [ ] split = chr . split ( fast string utils . to char array ( str ) ) ; return from char array of array to string array ( split ) ; }	Split a string.
public static string [ ] split by space ( string str ) { char [ ] [ ] split = char scanner . split by space ( fast string utils . to char array ( str ) ) ; return from char array of array to string array ( split ) ; }	Split a string by space.
public static string [ ] split by pipe ( string str ) { char [ ] [ ] split = char scanner . split by pipe ( fast string utils . to char array ( str ) ) ; return from char array of array to string array ( split ) ; }	Split a string by pipe.
public static string [ ] from char array of array to string array ( char [ ] [ ] split ) { string [ ] results = new string [ split . length ] ; char [ ] array ; for ( int index = num ; index < split . length ; index ++ ) { array = split [ index ] ; results [ index ] = array . length == num ? empty string : fast string utils . no copy string from chars ( array ) ; } return results ; }	Convert arrays of chars to arrays of strings.
public static string camel case ( string in str , boolean upper ) { char [ ] in = fast string utils . to char array ( in str ) ; char [ ] out = chr . camel case ( in , upper ) ; return fast string utils . no copy string from chars ( out ) ; }	Convert to camel case and pass upper or lower.
public static boolean inside of ( string start , string in str , string end ) { return chr . inside of ( fast string utils . to char array ( start ) , fast string utils . to char array ( in str ) , fast string utils . to char array ( end ) ) ; }	Checks to see if a string is inside of another.
public static string under bar case ( string in str ) { char [ ] in = fast string utils . to char array ( in str ) ; char [ ] out = chr . under bar case ( in ) ; return fast string utils . no copy string from chars ( out ) ; }	Convert to under bar case.
public static string num ( number count ) { if ( count == null ) { return str ; } if ( count instanceof double || count instanceof big decimal ) { string s = count . to string ( ) ; if ( idx ( s , num ) == str && s . length ( ) > num ) { s = slc ( s , num , num ) ; return s ; } else { return s ; } } else if ( count instanceof integer || count instanceof long || count instanceof short || count instanceof big integer ) { string s = count . to string ( ) ; s = new string builder ( s ) . reverse ( ) . to string ( ) ; char buf buf = char buf . create ( s . length ( ) ) ; int index = num ; for ( char c : s . to char array ( ) ) { index ++ ; buf . add ( c ) ; if ( index % num == num ) { buf . add ( str ) ; } } if ( buf . last char ( ) == str ) { buf . remove last char ( ) ; } s = buf . to string ( ) ; s = new string builder ( s ) . reverse ( ) . to string ( ) ; return s ; } return count . to string ( ) ; }	Do a nice pretty print of a number.Add commas and such.
public static sort sorts ( sort ... sorts ) { if ( sorts == null || sorts . length == num ) { return null ; } sort main = sorts [ num ] ; for ( int index = num ; index < sorts . length ; index ++ ) { main . then ( sorts [ index ] ) ; } return main ; }	Helper method to create a Sort that is a composite of other sorts.
public void sort ( list list , map < string , field access > fields ) { collections . sort ( list , this . comparator ( fields ) ) ; }	Sort if you already know the reflection fields.
public comparator comparator ( map < string , field access > fields ) { if ( comparator == null ) { comparator = universal comparator ( this . get name ( ) , fields , this . get type ( ) , this . child comparators ( fields ) ) ; } return comparator ; }	This is what really does the magic.
private list < comparator > child comparators ( map < string , field access > fields ) { if ( this . comparators == null ) { this . comparators = new array list < > ( this . sorts . size ( ) + num ) ; for ( sort sort : sorts ) { comparator comparator = universal comparator ( sort . get name ( ) , fields , sort . get type ( ) , sort . child comparators ( fields ) ) ; this . comparators . add ( comparator ) ; } } return this . comparators ; }	This creates a list of children comparators based on the child list.
public static < k , v > boolean value in ( v value , map < k , v > map ) { return map . contains value ( value ) ; }	End universal methods.
public static boolean equals or die ( int expected , int got ) { if ( expected != got ) { return die ( boolean . class , str , expected , str , got ) ; } return bool ; }	Checks to see if two values are the same.
public static boolean equals or die ( int [ ] expected , int [ ] got ) { if ( expected . length != got . length ) { die ( str , expected . length , str , got . length ) ; } for ( int index = num ; index < expected . length ; index ++ ) { if ( expected [ index ] != got [ index ] ) { die ( str , index , str , expected [ index ] , str , got [ index ] ) ; } } return bool ; }	Checks to see if two arrays are equals.
public static int sum ( int [ ] values , int start , int length ) { long sum = num ; for ( int index = start ; index < length ; index ++ ) { sum += values [ index ] ; } if ( sum < integer . min value ) { die ( str , sum ) ; } if ( sum > integer . max value ) { die ( str , sum ) ; } return ( int ) sum ; }	SumProvides overflow protection.
public static int round up to power of2 ( int number ) { int rounded = number >= num ? num : ( rounded = integer . highest one bit ( number ) ) != num ? ( integer . bit count ( number ) > num ) ? rounded << num : rounded : num ; return rounded ; }	Round up to the nearest power of 2.
public static void sort ( list list , string sort by , map < string , field access > fields , boolean ascending ) { sort ( list , sort by , fields , ascending , bool ) ; }	This is the work horse.
public static void sort ( list list , string sort by , map < string , field access > fields , boolean ascending , boolean nulls first ) { try { if ( list == null || list . size ( ) == num ) { return ; } object o = list . get ( num ) ; if ( sort by . equals ( str ) ) { collections . sort ( list , this universal comparator ( ascending , nulls first ) ) ; return ; } final field access field = fields . get ( sort by ) ; if ( field != null ) { collections . sort ( list , sorting . universal comparator ( field , ascending , nulls first ) ) ; } } catch ( exception ex ) { exceptions . handle ( ex , str , list , str , sort by , str , fields , str , ascending , str , nulls first ) ; } }	This is the work horse.
private void set field value from map ( final object parent object , final field access field , final map map inner ) { class < ? > field class type = field . type ( ) ; object value = null ; if ( ! typ . is map ( field class type ) ) { if ( ! field class type . is interface ( ) && ! typ . is abstract ( field class type ) ) { value = from map ( map inner , field . type ( ) ) ; } else { object o class name = map inner . get ( str ) ; if ( o class name != null ) { value = from map ( map inner , reflection . load class ( o class name . to string ( ) ) ) ; } else { value = null ; } } } else if ( typ . is map ( field class type ) ) { class key type = ( class ) field . get parameterized type ( ) . get actual type arguments ( ) [ num ] ; class value type = ( class ) field . get parameterized type ( ) . get actual type arguments ( ) [ num ] ; set < map . entry > set = map inner . entry set ( ) ; map new map = new linked hash map ( ) ; for ( map . entry entry : set ) { object evalue = entry . get value ( ) ; object key = entry . get key ( ) ; if ( evalue instanceof value container ) { evalue = ( ( value container ) evalue ) . to value ( ) ; } key = conversions . coerce ( key type , key ) ; evalue = conversions . coerce ( value type , evalue ) ; new map . put ( key , evalue ) ; } value = new map ; } field . set value ( parent object , value ) ; }	Inject a map into an object's field.
@ override public list < ? > to list ( object object ) { type type instance type = type type . get instance type ( object ) ; switch ( instance type ) { case null : return lists . list ( ( object ) null ) ; case array : case array int : case array byte : case array short : case array float : case array double : case array long : case array string : case array object : return conversions . to list ( object ) ; case instance : if ( reflection . responds to ( object , str ) ) { return ( list < ? > ) reflection . invoke ( object , str ) ; } break ; } return lists . list ( object ) ; }	Convert an object to a list.
protected void create load all version data sql ( string table ) { char buf buf = char buf . create ( num ) ; buf . add ( str ) ; buf . add ( table ) ; buf . add ( str ) ; buf . multiply ( str , this . load key count ) ; buf . remove last char ( ) ; buf . add ( str ) ; this . load all version data by keys sql = buf . to string ( ) ; }	Create load all keys SQL.
@ universal public static < v > list < v > deep copy ( list < v > list ) { if ( list instanceof linked list ) { return deep copy to list ( list , new linked list < v > ( ) ) ; } else if ( list instanceof copy on write array list ) { return deep copy to list ( list , new copy on write array list < v > ( ) ) ; } else { return deep copy ( ( collection ) list ) ; } }	Clones each list item into a new instance with copied fields.It is like doing a clone operation.If the passed list is a LinkedList then the returned list will be aLinkedList.If the passed list is a CopyOnWriteArrayList then the returned list willbe a CopyOnWriteArrayList list.All other lists become ArrayList.
public static boolean has string field ( final object value1 , final string name ) { class < ? > clz = value1 . get class ( ) ; return class has string field ( clz , name ) ; }	Checks to see if we have a string field.
public static boolean class has string field ( class < ? > clz , string name ) { list < field > fields = reflection . get all fields ( clz ) ; for ( field field : fields ) { if ( field . get type ( ) . equals ( typ . string ) && field . get name ( ) . equals ( name ) && ! modifier . is static ( field . get modifiers ( ) ) && field . get declaring class ( ) == clz ) { return bool ; } } return bool ; }	Checks to see if this class has a string field.
public static boolean class has field ( class < ? > clz , string name ) { list < field > fields = reflection . get all fields ( clz ) ; for ( field field : fields ) { if ( field . get name ( ) . equals ( name ) && ! modifier . is static ( field . get modifiers ( ) ) && field . get declaring class ( ) == clz ) { return bool ; } } return bool ; }	Checks to see if a class has a field.
public static string get first comparable or primitive from class ( class < ? > clz ) { list < field > fields = reflection . get all fields ( clz ) ; for ( field field : fields ) { if ( ( field . get type ( ) . is primitive ( ) || typ . is comparable ( field . get type ( ) ) && ! modifier . is static ( field . get modifiers ( ) ) && field . get declaring class ( ) == clz ) ) { return field . get name ( ) ; } } return null ; }	This can be used for default sort.
public static string get sortable field ( object value1 ) { if ( value1 instanceof map ) { return get sortable field from map ( ( map < string , ? > ) value1 ) ; } else { return get sortable field from class ( value1 . get class ( ) ) ; } }	Gets the first sortable fields found.
@ override public final int compare to ( cache entry other ) { switch ( type ) { case lfu : return compare to lfu ( other ) ; case lru : return compare to lru ( other ) ; case fifo : return compare to fifo ( other ) ; default : die ( ) ; return num ; } }	Comparison of entries this determines what we will order the cache bywhich determines which type of cache it is.
private final int compare time ( cache entry other ) { if ( time > other . time ) {	Compare the time.
public static void sort ( list list , sort ... sorts ) { sort . sorts ( sorts ) . sort ( list ) ; }	Takes a list an an array or sorts.
public static void sort ( list list , string sort by , boolean ascending , boolean nulls first ) { if ( list == null || list . size ( ) == num ) { return ; } if ( sort by . equals ( str ) ) { collections . sort ( list , this universal comparator ( ascending , nulls first ) ) ; return ; } iterator iterator = list . iterator ( ) ; object object = iterator . next ( ) ; map < string , field access > fields = null ; if ( object != null ) { fields = bean utils . get fields from object ( object ) ; } else { while ( iterator . has next ( ) ) { object = iterator . next ( ) ; if ( object != null ) { fields = bean utils . get fields from object ( object ) ; break ; } } } if ( fields != null ) { final field access field = fields . get ( sort by ) ; if ( field != null ) { collections . sort ( list , sorting . universal comparator ( field , ascending , nulls first ) ) ; } } }	Sort a list.
public static < k , v > collection < map . entry < k , v > > sort entries ( class < v > component type , map < k , v > map , string sort by , boolean ascending , boolean nulls first ) { return sort ( ( class ) component type , ( collection ) map . entry set ( ) , sort by , ascending , nulls first ) ; }	Sort map entries.
public static < k , v > collection < map . entry < k , v > > sort values ( class < v > component type , map < k , v > map , string sort by , boolean ascending , boolean nulls first ) { return sort ( ( class ) component type , ( collection ) map . values ( ) , sort by , ascending , nulls first ) ; }	Sort map values.
public static < k , v > collection < map . entry < k , v > > sort keys ( class < v > component type , map < k , v > map , string sort by , boolean ascending , boolean nulls first ) { return sort ( ( class ) component type , ( collection ) map . key set ( ) , sort by , ascending , nulls first ) ; }	Sort map keys.
public static < t > void sort ( t [ ] array , string sort by , boolean ascending , boolean nulls first ) { if ( array == null || array . length == num ) { return ; } if ( sort by . equals ( str ) ) { arrays . sort ( array , this universal comparator ( ascending , nulls first ) ) ; return ; } object object = array [ num ] ; map < string , field access > fields = null ; if ( object != null ) { fields = bean utils . get fields from object ( object ) ; } else { for ( int index = num ; index < array . length ; index ++ ) { object = array [ index ] ; if ( object != null ) { fields = bean utils . get fields from object ( object ) ; break ; } } } if ( fields != null ) { final field access field = fields . get ( sort by ) ; if ( field != null ) { arrays . sort ( array , sorting . universal comparator ( field , ascending , nulls first ) ) ; } } }	Sort an array.
public static comparator universal comparator ( final field access field , final boolean ascending , final boolean nulls first ) { return new comparator ( ) { @ override public int compare ( object o1 , object o2 ) { object value1 = null ; object value2 = null ; if ( ascending ) { value1 = field . get value ( o1 ) ; value2 = field . get value ( o2 ) ; } else { value1 = field . get value ( o2 ) ; value2 = field . get value ( o1 ) ; } return sorting . compare ( value1 , value2 , nulls first ) ; } } ; }	This creates the universal comparator object which is used by the sort work horse.
public static comparator this universal comparator ( final boolean ascending , final boolean nulls first ) { return new comparator ( ) { @ override public int compare ( object o1 , object o2 ) { object value1 ; object value2 ; if ( ascending ) { value1 = ( o1 ) ; value2 = ( o2 ) ; } else { value1 = ( o2 ) ; value2 = ( o1 ) ; } return sorting . compare ( value1 , value2 , nulls first ) ; } } ; }	This creates the universal comparator object used for "this".
public value get ( key key ) { cache entry < key , value > cache entry = map . get ( key ) ; if ( cache entry != null ) { cache entry . read count . increment and get ( ) ; return cache entry . value ; } else { return null ; } }	Get the value from the cache.
public value get silent ( key key ) { cache entry < key , value > cache entry = map . get ( key ) ; if ( cache entry != null ) { return cache entry . value ; } else { return null ; } }	Used for testing as it gets the value without updating stats.
private final void evict if needed ( ) { if ( list . size ( ) > evict size ) { final list < cache entry < key , value > > kill list = list . sort and return purge list ( num ) ; for ( cache entry < key , value > cache entry : kill list ) { map . remove ( cache entry . key ) ; } } }	Evict if we are over the size limit.
private void dynamically init if needed ( object value ) { if ( ! is initialized ( ) ) { if ( value instanceof integer ) { init ( new integer ( min . int value ( ) ) , new integer ( max . int value ( ) ) ) ; } else if ( value instanceof byte ) { init ( new byte ( min . byte value ( ) ) , new byte ( max . byte value ( ) ) ) ; } else if ( value instanceof short ) { init ( new short ( min . short value ( ) ) , new short ( max . short value ( ) ) ) ; } else { init ( min , max ) ; } } }	If the type was not initialized, we can still figure it out at runtime.
public final byte buffer allocate buffer ( int size ) { if ( recycle buffer ) { byte buffer spent buffer = recycle channel . poll ( ) ; if ( spent buffer == null ) { spent buffer = byte buffer . allocate direct ( size ) ; } spent buffer . clear ( ) ; return spent buffer ; } else { return byte buffer . allocate direct ( size ) ; } }	This gets called from the http post handler or event bus handler.
private boolean determine if we should exit ( ) { boolean should stop = stop . get ( ) ; if ( ! should stop ) { thread . interrupted ( ) ; } else { system . out . println ( str ) ; return bool ; } return bool ; }	See if it is time to stopWe have been interrupted.
private void manage input writer channel ( ) throws interrupted exception { try { byte buffer data to write to file ; data to write to file = input channel . poll ( ) ;	Queue and batch writer main logic.This is where the magic happens.
private void queue empty maybe flush ( ) { if ( periodic force flush ) { long current time = time . get ( ) ; if ( ( current time - last flush time ) > force flush after this many mili seconds ) { if ( writer . sync to disk ( ) ) {	If we detect that the in-coming transfer outputDataQueue channel is emptythen it could be an excellent time to sync to disk.
private void start monitor ( ) { final scheduled executor service monitor = executors . new scheduled thread pool ( num , new thread factory ( ) { @ override public thread new thread ( runnable runnable ) { thread thread = new thread ( runnable ) ; thread . set priority ( thread . norm priority + num ) ; return thread ; } } ) ; monitor future = monitor . schedule at fixed rate ( new runnable ( ) { @ override public void run ( ) { monitor ( ) ; } } , monitor interval seconds , monitor interval seconds , time unit . seconds ) ; runtime . get runtime ( ) . add shutdown hook ( new thread ( new runnable ( ) { @ override public void run ( ) { system . err . println ( str ) ; monitor ( ) ; } } ) ) ; }	Start up the health monitor.
public void start ( final time aware receiver ) {	Starts up the batch writer.
@ override public final object get ( object key ) { object object = null ; if ( map == null ) { build map ( ) ; } object = map . get ( key ) ; lazy chop if needed ( object ) ; return object ; }	Gets the item by key from the mapping.
private result set main query plan ( criteria [ ] expressions ) { result set internal results = new result set impl ( this . fields ) ; if ( expressions == null || expressions . length == num ) { results . add results ( searchable collection . all ( ) ) ; } group group = expressions . length == num && expressions [ num ] instanceof group ? ( group ) expressions [ num ] : object filter . and ( expressions ) ; do filter group ( group , results ) ; return results ; }	This is the main criteria plan in case the name was notobvious.
private void do filter group ( group group , result set internal results ) { if ( group . get grouping ( ) == grouping . or ) { or ( group . get expressions ( ) , fields , results ) ; } else { result set internal results for and = new result set impl ( fields ) ; and ( group . get expressions ( ) , fields , results for and ) ; results . add results ( results for and . as list ( ) ) ; } }	Run the filter on the group.
public void tick ( long time ) { this . time . set ( time ) ; long start time = file start time . get ( ) ; long duration = time - start time ; if ( duration > file timeout miliseconds ) { file time out . set ( bool ) ; } }	Recieves a tick from our clock.
public boolean sync to disk ( ) { if ( output stream != null && dirty ) { try {	flush to disk.
private void cleanup output stream ( ) { if ( output stream != null ) { try { output stream . close ( ) ; } catch ( io e ) { e . print stack trace ( system . err ) ; } finally { output stream = null ; } } }	Attempts to close down log stream.
public void next buffer to write ( final byte buffer buffer out ) throws interrupted exception { dirty = bool ; final int size = buffer out . limit ( ) ; write ( buffer out ) ; if ( ! error . get ( ) ) { total bytes transferred += size ; bytes transferred += size ; bytes since last flush += size ; buffers sent ++ ; } if ( this . bytes transferred >= file size bytes || file time out . get ( ) ) { try { output stream . close ( ) ; } catch ( io e ) { cleanup output stream ( ) ; e . print stack trace ( system . err ) ; } finally { output stream = null ; } } }	Writes a buffer of data to the log system.
private void write ( final byte buffer buffer out ) throws interrupted exception { init output stream ( ) ; try { if ( output stream != null ) { output stream . write ( buffer out ) ; } else { error . set ( bool ) ; } if ( bytes since last flush > flush every n bytes ) { sync to disk ( ) ; bytes since last flush = num ; } } catch ( closed by interrupt exception cbie ) { throw new interrupted exception ( str ) ; } catch ( exception e ) { cleanup output stream ( ) ; error . set ( bool ) ; e . print stack trace ( system . err ) ; diagnose ( ) ; exceptions . handle ( e ) ; } }	Write the actual data to disk.
private void init output stream ( ) { long time = this . time . get ( ) ; if ( error . get ( ) || this . total bytes transferred == num ) { cleanup output stream ( ) ; error . set ( bool ) ; time = system . nano time ( ) / num ; } if ( output stream != null ) { return ; } file name = log files config . get log file name ( format pattern , output dir path ( ) , num files , time , server name ) ; try { file time out . set ( bool ) ; output stream = stream creator ( ) ; file start time . set ( time ) ; bytes transferred = num ; bytes since last flush = num ; } catch ( exception ex ) { cleanup output stream ( ) ; error . set ( bool ) ; exceptions . handle ( ex ) ; } finally { num files ++ ; } }	Initialize the output stream.
public void put all ( map < k , v > values ) { set < map . entry < k , v > > entries = values . entry set ( ) ; map < string , string > map = new hash map < > ( values . size ( ) ) ; for ( map . entry < k , v > entry : entries ) { map . put ( to key string ( entry . get key ( ) ) , to value string ( entry . get value ( ) ) ) ; } store . put all ( map ) ; }	Put all of these values in the key value store.
protected byte [ ] to key bytes ( k key ) { byte [ ] key bytes = key cache . get ( key ) ; if ( key bytes == null ) { key bytes = this . key to byte array converter . apply ( key ) ; key cache . put ( key , key bytes ) ; } return key bytes ; }	Convert a String key to bytes.
public list < validator meta data > read meta data ( class < ? > clazz , string property name ) { properties props = load meta data props file ( clazz ) ; string unparsed string = props . get property ( property name ) ; return extract meta data from string ( clazz , property name , unparsed string ) ; }	Read the meta-data from a properties file.
private list < validator meta data > extract meta data from string ( class < ? > clazz , string property name , string unparsed string ) { string property key = clazz . get name ( ) + str + property name ; list < validator meta data > validator meta data list = meta data cache . get ( property key ) ; if ( validator meta data list == null ) { validator meta data list = new array list < validator meta data > ( ) ; string [ ] validators parts = unparsed string . split ( str ) ; for ( string validator string : validators parts ) { validator meta data validator meta data = new validator meta data ( ) ; validator meta data list . add ( validator meta data ) ; string [ ] parts = validator string . trim ( ) . split ( str ) ; validator meta data . set name ( parts [ num ] ) ; if ( parts . length > num ) { list < string > values = arrays . as list ( parts ) . sub list ( num , parts . length ) ; for ( string value : values ) { if ( value . index of ( str ) != - num ) { string [ ] value parts = value . split ( str ) ; validator meta data . get properties ( ) . put ( value parts [ num ] , value parts [ num ] ) ; } } } } meta data cache . put ( property key , validator meta data list ) ; } return validator meta data list ; }	This method extracts meta-data from a string.
public list < validator meta data > read meta data ( class < ? > clazz , string property name ) { string property key = clazz . get name ( ) + str + property name ; list < validator meta data > validator meta data list = meta data cache . get ( property key ) ; if ( validator meta data list == null ) {	Read the meta-data from annotation.
private list < validator meta data > extract validator meta data ( class < ? > clazz , string property name , list < validator meta data > validator meta data list ) { if ( validator meta data list == null ) {	Extract BaseValidator Meta Data.
private list < validator meta data > extract meta data from annotations ( collection < annotation data > annotations ) { list < validator meta data > list = new array list < validator meta data > ( ) ; for ( annotation data annotation data : annotations ) { validator meta data validator meta data = convert annotation data to validator meta data ( annotation data ) ; list . add ( validator meta data ) ; } return list ; }	Extract meta-data from the annotationData we collected thus far.
private validator meta data convert annotation data to validator meta data ( annotation data annotation data ) { validator meta data meta data = new validator meta data ( ) ; meta data . set name ( annotation data . get name ( ) ) ; meta data . set properties ( annotation data . get values ( ) ) ; return meta data ; }	Converts an AnnotationData into a ValidatorMetaData POJO.
public static string [ ] split ( final string string , final char split , final int limit ) { char [ ] [ ] comps = char scanner . split ( fast string utils . to char array ( string ) , split , limit ) ; return str . from char array of array to string array ( comps ) ; }	Splits a string into many parts.
public static string [ ] split by white space ( final string string ) { char [ ] [ ] comps = char scanner . split by chars ( fast string utils . to char array ( string ) , white space ) ; return str . from char array of array to string array ( comps ) ; }	Split string by white space.
public static string [ ] split by delimiters ( final string string , final string delimiters ) { char [ ] [ ] comps = char scanner . split by chars ( fast string utils . to char array ( string ) , delimiters . to char array ( ) ) ; return str . from char array of array to string array ( comps ) ; }	Split string by a list of delimiters.
public static string remove chars ( final string string , final char ... delimiters ) { char [ ] [ ] comps = char scanner . split by chars none empty ( fast string utils . to char array ( string ) , delimiters ) ; return new string ( chr . add ( comps ) ) ; }	remove chars from a string.
public static string [ ] split by chars none empty ( final string string , int start , int end , final char ... delimiters ) { exceptions . require non null ( string ) ; char [ ] [ ] comps = char scanner . split by chars none empty ( fast string utils . to char array ( string ) , start , end , delimiters ) ; return str . from char array of array to string array ( comps ) ; }	Split string by a list of delimiters but none are empty within a range.
public static double parse double ( string buffer , int from , int to ) { return char scanner . parse double ( fast string utils . to char array ( buffer ) , from , to ) ; }	parse a double.
public static int parse int ( string buffer , int from , int to ) { return char scanner . parse int ( fast string utils . to char array ( buffer ) , from , to ) ; }	parse an int within a range.
public static long parse long ( string buffer , int from , int to ) { return char scanner . parse long ( fast string utils . to char array ( buffer ) , from , to ) ; }	parse an long within a range.
public static object get prop by path ( object item , string ... path ) { object o = item ; for ( int index = num ; index < path . length ; index ++ ) { string prop name = path [ index ] ; if ( o == null ) { return null ; } else if ( o . get class ( ) . is array ( ) || o instanceof collection ) { o = get collection prop ( o , prop name , index , path ) ; break ; } else { o = get prop ( o , prop name ) ; } } return conversions . unify list or array ( o ) ; }	This method handles walking lists of lists.
public static map < string , field access > get fields from object ( object object ) { try { map < string , field access > fields ; if ( object instanceof map ) { fields = get fields from map ( ( map < string , object > ) object ) ; } else { fields = get property field access map ( object . get class ( ) ) ; } return fields ; } catch ( exception ex ) { require non null ( object , str ) ; return handle ( map . class , ex , str , class name ( object ) ) ; } }	Get fields from object or Map.Allows maps to act like they have fields.
public static class < ? > get property type ( final object root , final string property ) { map < string , field access > fields = get property field access map ( root . get class ( ) ) ; field access field = fields . get ( property ) ; return field . type ( ) ; }	Get property value, loads nested properties.
public static void inject into property ( object object , string path , object value ) { string [ ] properties = property path as string array ( path ) ; set property value ( object , value , properties ) ; }	Set property value to simulate dependency injection.
public static void idx ( class < ? > cls , string path , object value ) { string [ ] properties = property path as string array ( path ) ; set property value ( cls , value , properties ) ; }	Set a static value.
private static object get collection prop ( object o , string prop name , int index , string [ ] path ) { o = get field values from collection or array ( o , prop name ) ; if ( index + num == path . length ) { return o ; } else { index ++ ; return get collection prop ( o , path [ index ] , index , path ) ; } }	This is an amazing little recursive method. It walks a fanout ofnested collection to pull out the leaf nodes.
public static object get prop ( object object , final string property ) { if ( object == null ) { return null ; } if ( is digits ( property ) ) { object = idx ( object , string scanner . parse int ( property ) ) ; } class < ? > cls = object . get class ( ) ; map < string , field access > fields = reflection . get property field accessors ( cls ) ; if ( ! fields . contains key ( property ) ) { fields = reflection . get all accessor fields ( cls ) ; } if ( ! fields . contains key ( property ) ) { return null ; } else { return fields . get ( property ) . get value ( object ) ; } }	This is one is forgiving of null paths.This works with getters first, i.e., properties.
public static int get property int ( final object root , final string ... properties ) { final string last property = properties [ properties . length - num ] ; if ( is digits ( last property ) ) { return conversions . to int ( get property value ( root , properties ) ) ; } object object = base for get property ( root , properties ) ; map < string , field access > fields = get fields from object ( object ) ; field access field = fields . get ( last property ) ; if ( field . type ( ) == typ . intgr ) { return field . get int ( object ) ; } else { return conversions . to int ( field . get value ( object ) ) ; } }	Get an int property.
public void init ( ) { if ( name == null && parent == null ) { this . set detail message ( str + this . get class ( ) . get name ( ) + detail key + str ) ; this . set summary message ( str + this . get class ( ) . get name ( ) + summary key + str ) ; } else if ( name != null && parent == null ) { this . set detail message ( str + str + get name ( ) + detail key + str ) ; this . set summary message ( str + str + get name ( ) + summary key + str ) ; } else if ( parent != null ) { this . set detail message ( str + str + parent + detail key + str ) ; this . set summary message ( str + str + parent + summary key + str ) ; } }	The init method tries to generate the message keys.You should only call the init method if you don't injectvalues into the detailMessage and summaryMessage.
public string create message ( string key , list < string > arg keys , object ... args ) { string message = get message ( key ) ; object [ ] actual args ; if ( args . length > num ) { actual args = args ; } else if ( arg keys != null ) { actual args = keys to values ( arg keys ) ; } else { actual args = new object [ ] { } ; } return do create message ( message , actual args ) ; }	Creates a message.
@ suppress warnings ( str ) private string do create message ( string message , object [ ] actual args ) { return validation context . get ( ) . create message ( message , get subject ( ) , actual args ) ; }	Actually creates the message.
private object [ ] keys to values ( list < string > arg keys ) { list < string > values = new array list < > ( ) ; for ( string key : arg keys ) { values . add ( get message ( key ) ) ; } return values . to array ( ) ; }	Convert the keys to values.
public string get subject ( ) { return validation context . get ( ) . get current subject ( ) == null ? this . subject : validation context . get ( ) . get current subject ( ) ; }	Gets the current subject or the configured subject if thecurrent subject is not found.
public object parse text ( string text ) { if ( text == null || text . length ( ) == num ) { throw new illegal argument exception ( str ) ; } return json factory . create ( ) . from json ( text ) ; }	Parse a text representation of a JSON data structure.
private void send http request ( final request request , final org . boon . core . handler < response > response handler ) { final http client request http client request = http client . request ( request . get method ( ) , request . uri ( ) , handle response ( request , response handler ) ) ; final runnable runnable = new runnable ( ) { @ override public void run ( ) { if ( ! request . get method ( ) . equals ( str ) ) { http client request . put header ( str , str ) . end ( request . param body ( ) ) ; } else { http client request . end ( ) ; } } } ; if ( closed . get ( ) ) { this . scheduled executor service . schedule ( new runnable ( ) { @ override public void run ( ) { connect ( ) ; int retry = num ; while ( closed . get ( ) ) { sys . sleep ( num ) ; if ( ! closed . get ( ) ) { break ; } retry ++ ; if ( retry > num ) { break ; } if ( retry % num == num ) { connect ( ) ; } } if ( ! closed . get ( ) ) { runnable . run ( ) ; } else { response handler . handle ( new response ( str , - num , new error ( - num , str , str , - num ) ) ) ; } } } , num , time unit . milliseconds ) ; } else { runnable . run ( ) ; } }	This actually sends the request.
public void delete db ( string db name , string confirm ) { assert not empty ( db name , str ) ; if ( ! str . equals ( confirm ) ) throw new illegal argument exception ( str ) ; dbc . delete ( build uri ( dbc . get base uri ( ) ) . path ( db name ) . build ( ) ) ; }	Requests CouchDB deletes a database.
public void create db ( string db name ) { assert not empty ( db name , str ) ; input stream getresp = null ; http response putresp = null ; final uri uri = build uri ( dbc . get base uri ( ) ) . path ( db name ) . build ( ) ; try { getresp = dbc . get ( uri ) ; } catch ( no document exception e ) {	Requests CouchDB creates a new database; if one doesn't exist.
public list < string > uuids ( long count ) { final string uri = string . format ( str , dbc . get base uri ( ) , count ) ; final json object json = dbc . find any ( json object . class , uri ) ; return dbc . get gson ( ) . from json ( json . get ( str ) . to string ( ) , new type token < list < string > > ( ) { } . get type ( ) ) ; }	Request a database sends a list of UUIDs.
public replication result trigger ( ) { assert not empty ( source , str ) ; assert not empty ( target , str ) ; http response response = null ; try { json object json = create json ( ) ; if ( log . is debug enabled ( ) ) { log . debug ( json ) ; } final uri uri = build uri ( dbc . get base uri ( ) ) . path ( str ) . build ( ) ; response = dbc . post ( uri , json . to string ( ) ) ; final input stream reader reader = new input stream reader ( get stream ( response ) , charsets . utf 8 ) ; return dbc . get gson ( ) . from json ( reader , replication result . class ) ; } finally { close ( response ) ; } }	Triggers a replication request.
private < v > v query value ( class < v > class of v ) { input stream instream = null ; try { reader reader = new input stream reader ( instream = query for stream ( ) , charsets . utf 8 ) ; json array array = new json parser ( ) . parse ( reader ) . get as json object ( ) . get ( str ) . get as json array ( ) ; if ( array . size ( ) != num ) { throw new no document exception ( str + array . size ( ) ) ; } return json to object ( gson , array . get ( num ) , str , class of v ) ; } finally { close ( instream ) ; } }	Queries for scalar values.
public view descending ( boolean descending ) { this . descending = boolean . value of ( gson . to json ( descending ) ) ; uri builder . query ( str , this . descending ) ; return this ; }	Reverses the reading direction, not the sort order.
public void synchronize all with db ( ) { list < design document > documents = get all from desk ( ) ; for ( design document dd : documents ) { synchronize with db ( dd ) ; } }	Synchronize all design documents on desk to the database.
public design document get from db ( string id ) { assert not empty ( id , str ) ; final uri uri = build uri ( dbc . get db ( ) ) . path ( id ) . build ( ) ; return dbc . get ( uri , design document . class ) ; }	Gets a design document from the database.
public list < design document > get all from desk ( ) { final list < design document > design docs list = new array list < design document > ( ) ; for ( string doc name : list resources ( format ( str , design docs dir ) ) ) { design docs list . add ( get from desk ( doc name ) ) ; } return design docs list ; }	Gets all design documents from desk.
public design document get from desk ( string id ) { assert not empty ( id , str ) ; final design document dd = new design document ( ) ; final string root path = format ( str , design docs dir , id ) ; final list < string > elements = list resources ( root path ) ; if ( elements == null ) { throw new illegal argument exception ( str ) ; }	Gets a design document from desk.
public response save ( ) { assert not empty ( replicator doc . get source ( ) , str ) ; assert not empty ( replicator doc . get target ( ) , str ) ; if ( user ctx name != null ) { user ctx ctx = replicator doc . new user ctx ( ) ; ctx . set name ( user ctx name ) ; ctx . set roles ( user ctx roles ) ; replicator doc . set user ctx ( ctx ) ; } return dbc . put ( db uri , replicator doc , bool ) ; }	Adds a new document to the replicator database.
public replicator document find ( ) { assert not empty ( replicator doc . get id ( ) , str ) ; final uri uri = build uri ( db uri ) . path ( replicator doc . get id ( ) ) . query ( str , replicator doc . get revision ( ) ) . build ( ) ; return dbc . get ( uri , replicator document . class ) ; }	Finds a document in the replicator database.
public list < replicator document > find all ( ) { input stream instream = null ; try { final uri uri = build uri ( db uri ) . path ( str ) . query ( str , str ) . build ( ) ; final reader reader = new input stream reader ( instream = dbc . get ( uri ) , charsets . utf 8 ) ; final json array json array = new json parser ( ) . parse ( reader ) . get as json object ( ) . get as json array ( str ) ; final list < replicator document > list = new array list < replicator document > ( ) ; for ( json element json elem : json array ) { json element elem = json elem . get as json object ( ) . get ( str ) ; if ( ! get as string ( elem . get as json object ( ) , str ) . starts with ( str ) ) {	Finds all documents in the replicator database.
public response remove ( ) { assert not empty ( replicator doc . get id ( ) , str ) ; assert not empty ( replicator doc . get revision ( ) , str ) ; final uri uri = build uri ( db uri ) . path ( replicator doc . get id ( ) ) . query ( str , replicator doc . get revision ( ) ) . build ( ) ; return dbc . delete ( uri ) ; }	Removes a document from the replicator database.
public < t > t find ( class < t > class type , string id , params params ) { assert not empty ( class type , str ) ; assert not empty ( id , str ) ; final uri uri = build uri ( get db ( ) ) . path encoded ( id ) . query ( params ) . build ( ) ; return get ( uri , class type ) ; }	Finds an Object of the specified type.
public < t > list < t > find docs ( string json query , class < t > class of t ) { assert not empty ( json query , str ) ; http response response = null ; try { response = post ( build uri ( get db ( ) ) . path ( str ) . build ( ) , json query ) ; reader reader = new input stream reader ( get stream ( response ) , charsets . utf 8 ) ; json array json array = new json parser ( ) . parse ( reader ) . get as json object ( ) . get as json array ( str ) ; list < t > list = new array list < t > ( ) ; for ( json element json elem : json array ) { json element elem = json elem . get as json object ( ) ; t t = this . gson . from json ( elem , class of t ) ; list . add ( t ) ; } return list ; } finally { close ( response ) ; } }	Find documents using a declarative JSON querying syntax.
public boolean contains ( string id ) { assert not empty ( id , str ) ; http response response = null ; try { response = head ( build uri ( get db ( ) ) . path encoded ( id ) . build ( ) ) ; } catch ( no document exception e ) { return bool ; } finally { close ( response ) ; } return bool ; }	Checks if a document exist in the database.
public list < response > bulk ( list < ? > objects , boolean new edits ) { assert not empty ( objects , str ) ; http response response = null ; try { final string new edits val = new edits ? str : str ; final string json = string . format ( str , new edits val , str , get gson ( ) . to json ( objects ) ) ; final uri uri = build uri ( get db ( ) ) . path ( str ) . build ( ) ; response = post ( uri , json ) ; return get response list ( response ) ; } finally { close ( response ) ; } }	Performs bulk documents create and update request.
response put ( uri uri , object object , boolean new entity ) { assert not empty ( object , str ) ; http response response = null ; try { final json object json = get gson ( ) . to json tree ( object ) . get as json object ( ) ; string id = get as string ( json , str ) ; string rev = get as string ( json , str ) ; if ( new entity ) {	Performs a HTTP PUT request, saves or updates a document.
response put ( uri uri , input stream instream , string content type ) { http response response = null ; try { final http put http put = new http put ( uri ) ; final input stream entity entity = new input stream entity ( instream , - num ) ; entity . set content type ( content type ) ; http put . set entity ( entity ) ; response = execute request ( http put ) ; return get response ( response ) ; } finally { close ( response ) ; } }	Performs a HTTP PUT request, saves an attachment.
http response post ( uri uri , string json ) { http post post = new http post ( uri ) ; set entity ( post , json ) ; return execute request ( post ) ; }	Performs a HTTP POST request.
response delete ( uri uri ) { http response response = null ; try { http delete delete = new http delete ( uri ) ; response = execute request ( delete ) ; return get response ( response ) ; } finally { close ( response ) ; } }	Performs a HTTP DELETE request.
void validate ( http response response ) throws io { final int code = response . get status line ( ) . get status code ( ) ; if ( code == num || code == num || code == num ) {	Validates a HTTP response; on error cases logs status and throws relevant exceptions.
private void set entity ( http entity enclosing request base http request , string json ) { string entity entity = new string entity ( json , str ) ; entity . set content type ( str ) ; http request . set entity ( entity ) ; }	Sets a JSON String as a request entity.
public void add attachment ( string name , attachment attachment ) { if ( attachments == null ) attachments = new hash map < string , attachment > ( ) ; attachments . put ( name , attachment ) ; }	Adds an in-line document attachment.
public changes result get changes ( ) { final uri uri = uri builder . query ( str , str ) . build ( ) ; return dbc . get ( uri , changes result . class ) ; }	Requests Change notifications of feed type normal.
private boolean read next row ( ) { boolean has next = bool ; try { if ( ! stop ) { string row = str ; do { row = get reader ( ) . read line ( ) ; } while ( row . length ( ) == num ) ; if ( ! row . starts with ( str ) ) { set next row ( gson . from json ( row , row . class ) ) ; has next = bool ; } } } catch ( exception e ) { terminate ( ) ; throw new couch db exception ( str , e ) ; } if ( ! has next ) terminate ( ) ; return has next ; }	Reads and sets the next feed in the stream.
public string convert ( double the money ) { if ( the money == null ) { throw new illegal argument exception ( str ) ; } long int part = the money . long value ( ) ; long fract part = math . round ( ( the money - int part ) * nu ) ; if ( currency == currency . pe ) { fract part = math . round ( ( the money - int part ) * nu ) ; } return convert ( int part , fract part ) ; }	Converts double value to the text description.
public void shutdown ( ) { try { locks executor . shutdown ( ) ; locks executor . await termination ( num , time unit . seconds ) ; count down latch latch = new count down latch ( num ) ; active locks lock . write lock ( ) . lock ( ) ; observable . from ( active locks . entry set ( ) ) . map ( map . entry :: get value ) . flat map ( lock -> release lock ( lock . get name ( ) , lock . get value ( ) ) . map ( released -> new lock ( lock . get name ( ) , lock . get value ( ) , lock . get expiration ( ) , lock . get renewal rate ( ) , ! released ) ) ) . subscribe ( lock -> { if ( lock . is locked ( ) ) { logger . infof ( str , lock . get name ( ) ) ; } } , t -> { logger . info ( str , t ) ; latch . count down ( ) ; } , latch :: count down ) ; latch . await ( ) ; logger . info ( str ) ; } catch ( interrupted exception e ) { logger . debug ( str ) ; } }	Attempt to release any locks on shutdown so that other clients can obtain those locks without having to waitfor them to expire.
public static observable < void > write ( final observable < byte [ ] > data , final servlet output stream out ) { return observable . create ( new observable . on subscribe < void > ( ) { @ override public void call ( subscriber < ? super void > subscriber ) { observable < void > events = create ( out ) . on backpressure buffer ( ) ; observable < void > writeobs = observable . zip ( data , events , ( b , a void ) -> { try { out . write ( b ) ; } catch ( io ioe ) { exceptions . propagate ( ioe ) ; } return null ; } ) ; writeobs . subscribe ( subscriber ) ; } } ) ; }	Writes the given Observable data to ServletOutputStream.
@ override public observable < void > add tags ( metric < ? > metric , map < string , string > tags ) { try { check argument ( tags != null , str ) ; check argument ( is valid tag map ( tags ) , str ) ; } catch ( exception e ) { return observable . error ( e ) ; } return data access . insert into metrics tags index ( metric , tags ) . concat with ( data access . add tags ( metric , tags ) ) . to list ( ) . map ( l -> null ) ; }	functionality into a separate class.
public void verify and create temp tables ( ) { zoned date time current block = zoned date time . of instant ( instant . of epoch milli ( date time service . now . get ( ) . get millis ( ) ) , utc ) . with ( date time service . start of previous even hour ( ) ) ; zoned date time last startup block = current block . plus ( num , chrono unit . hours ) ; verify and create temp tables ( current block , last startup block ) . await ( ) ; }	Intended to be used at the startup of the MetricsServiceImpl to ensure we have enough tables for processing.
public string get namespace id ( string namespace name ) { return namespaces . compute if absent ( namespace name , n -> get project id ( namespace name , token ) ) ; }	Returns the namespace id for a particular namespace name.
private boolean is query ( http server exchange server exchange ) { if ( server exchange . get request method ( ) . to string ( ) . equals ignore case ( str ) || server exchange . get request method ( ) . to string ( ) . equals ignore case ( str ) ) {	Returns if the request is a query request, eg to perform a READ.
private void send authentication request ( http server exchange server exchange , pooled connection connection ) { auth context context = server exchange . get attachment ( auth context key ) ; string verb = get verb ( server exchange ) ; string resource ;	Executed when a pooled connection is acquired.
private string get verb ( http server exchange server exchange ) {	Determine the verb we should apply based on the HTTP method being requested.
private string generate subject access review ( string namespace , string verb , string resource ) { object node object node = object mapper . create object node ( ) ; object node . put ( str , str ) ; object node . put ( str , kind ) ; object node . put ( str , resource ) ; object node . put ( str , verb ) ; object node . put ( str , namespace ) ; return object node . to string ( ) ; }	Generates a SubjectAccessReview object used to request if a user has a certain permission or not.
private void on request result ( http server exchange server exchange , pooled connection connection , boolean allowed ) { connection pools . get ( server exchange . get io thread ( ) ) . release ( connection ) ;	Called when the Kubernetes master server reponse has been inspected.
private void on request failure ( http server exchange server exchange , pooled connection connection , io e , boolean retry ) { log . debug ( str , e ) ; io utils . safe close ( connection ) ; connection pool connection pool = connection pools . get ( server exchange . get io thread ( ) ) ; connection pool . release ( connection ) ; auth context context = server exchange . get attachment ( auth context key ) ; if ( context . retries < max retry && retry ) { context . retries ++ ; pooled connection waiter waiter = create waiter ( server exchange ) ; if ( ! connection pool . offer ( waiter ) ) { end exchange ( server exchange , internal server error , too many pending requests ) ; } } else { end exchange ( server exchange , internal server error , client request failure ) ; } }	Called if an exception occurs at any stage in the process.
public void init ( rx session session ) { this . session = session ; find configuration group = session . get session ( ) . prepare ( str ) . set consistency level ( consistency level . local quorum ) ; find configuration value = session . get session ( ) . prepare ( str ) . set consistency level ( consistency level . local quorum ) ; update configuration value = session . get session ( ) . prepare ( str ) . set consistency level ( consistency level . local quorum ) ; delete configuration value = session . get session ( ) . prepare ( str ) . set consistency level ( consistency level . local quorum ) ; delete configuration = session . get session ( ) . prepare ( str ) . set consistency level ( consistency level . local quorum ) ; }	eventually I would like service initialization async.
public observable < job details > find scheduled jobs ( date time slice , rx . scheduler scheduler ) { return session . execute and fetch ( find all scheduled . bind ( ) , scheduler ) . filter ( filter null jobs ) . filter ( row -> row . get timestamp ( num ) . compare to ( time slice ) <= num ) . map ( row -> create job details ( row . get uuid ( num ) , row . get string ( num ) , row . get string ( num ) , row . get map ( num , string . class , string . class ) , get trigger ( row . get udt ( num ) ) , job status . from code ( row . get byte ( num ) ) , time slice ) ) . collect ( hash map :: new , ( map < uuid , sorted set < job details > > map , job details details ) -> { sorted set < job details > set = map . get ( details . get job id ( ) ) ; if ( set == null ) { set = new tree set < > ( ( job details d1 , job details d2 ) -> long . compare ( d1 . get trigger ( ) . get trigger time ( ) , d2 . get trigger ( ) . get trigger time ( ) ) ) ; } set . add ( details ) ; map . put ( details . get job id ( ) , set ) ; } ) . flat map ( map -> observable . from ( map . entry set ( ) ) ) . map ( entry -> entry . get value ( ) . first ( ) ) ; }	This method is currently unused.
public static < t extends bucket point > list < t > to list ( map < long , t > point map , buckets buckets , bi function < long , long , t > empty bucket factory ) { list < t > result = new array list < > ( buckets . get count ( ) ) ; for ( int index = num ; index < buckets . get count ( ) ; index ++ ) { long from = buckets . get bucket start ( index ) ; t bucket point = point map . get ( from ) ; if ( bucket point == null ) { long to = from + buckets . get step ( ) ; bucket point = empty bucket factory . apply ( from , to ) ; } result . add ( bucket point ) ; } return result ; }	Converts bucket points indexed by start time into a list, ordered by start time.
public static void end exchange ( http server exchange exchange , int status code , string reason phrase ) { exchange . set status code ( status code ) ; if ( reason phrase != null ) { exchange . set reason phrase ( reason phrase ) ; } exchange . end exchange ( ) ; }	Changes the status code of the response, sets the HTTP reason phrase and ends the exchange.
@ override public observable < observable < row > > find all data from bucket ( long timestamp , int page size , int max concurrency ) { prepared statement ts = get temp statement ( metric type . undefined , temp statement . scan with token ranges , timestamp ) ;	Fetch all the data from a temporary table for the compression job.
public static buckets from step ( long start , long end , long step ) { check time range ( start , end ) ; check argument ( step > num , str , step ) ; if ( step > ( end - start ) ) { return new buckets ( start , step , num ) ; } long quotient = ( end - start ) / step ; long remainder = ( end - start ) % step ; long count ; if ( remainder == num ) { count = quotient ; } else { count = quotient + num ; } check argument ( count <= integer . max value , str , count ) ; return new buckets ( start , step , ( int ) count ) ; }	Force bucket step.
public boolean send msg ( message msg ) { send result send result = null ; try { send result = producer . send ( msg ) ; } catch ( exception e ) { logger . error ( str , e ) ; } return send result != null && send result . get send status ( ) == send status . send ok ; }	send msg.
public void send one way msg ( message msg ) { try { producer . send oneway ( msg ) ; } catch ( exception e ) { logger . error ( str , e ) ; } }	sene one way msg.
public boolean send delay msg ( string topic , string tag , message msg , int delay level ) { msg . set delay time level ( delay level ) ; send result send result = null ; try { send result = producer . send ( msg ) ; } catch ( exception e ) { logger . error ( str , e ) ; } return send result != null && send result . get send status ( ) == send status . send ok ; }	send delay msg.
@ override public scan result < string > scan ( string cursor , scan params params ) {	In this simple proposal, we're not testing complex iterationsof scan cursor.
public string add ( file file , boolean preserve external file name ) { file existing file = check file exists ( file ) ; string result = zip path for ( existing file , preserve external file name ) ; entries . put ( existing file , result ) ; return result ; }	Add a file to the ZIP.
public void replace ( file file , boolean preserve external file name , string text ) { string path = entries . contains key ( file ) ? entries . remove ( file ) : zip path for ( file , preserve external file name ) ; entries . put ( text , path ) ; }	Replace the contents of a file with a different text.
public file build ( ) throws io { if ( entries . is empty ( ) ) { throw new empty zip exception ( ) ; } string file name = str + system . current time millis ( ) + str ; file result = new file ( temp dir . to file ( ) , file name ) ; try ( zip output stream zip = new zip output stream ( files . new output stream ( result . to path ( ) , standard open option . create new ) ) ) { customization . init ( entries . values ( ) , this :: stream for ) ; for ( entry < object , string > entry : entries . entry set ( ) ) { try ( input stream input = to input stream ( entry . get key ( ) ) ) { add entry ( extra zip entry . of ( entry . get value ( ) , customization . customize ( entry . get value ( ) , input ) ) , zip ) ; } } customization . extra entries ( ) . for each ( entry -> add entry ( entry , zip ) ) ; zip . close entry ( ) ; } return result ; }	Build a ZIP file containing the added entries.
public metrics generate ( c component , data buffer product ) throws io { return generate ( collections . singleton list ( component ) , product ) ; }	Generate a product from a single piece.
@ override @ deprecated public content result fetch content ( string content id ) throws io { try { string content resource = resource cache . get ci resource uri ( ) ; uri builder = new uri ( content resource ) ; builder . set parameter ( str , content id ) ; uri uri = builder . build ( ) ; return rest client . get ( uri . to string ( ) , content result factory ) ; } catch ( uri e ) { throw new illegal state exception ( str , e ) ; } }	Fetch the content for the specified content id.
@ override @ deprecated public content result fetch order content ( order item order item ) throws io { string download uri = objects . require non null ( objects . require non null ( order item , str ) . get uri ( link download ) , str ) ; string fetch uri = rest client . uri ( download uri ) . add parameter ( str , str ) . build ( ) ; return rest client . get ( fetch uri , content result factory ) ; }	Fetch the content for the specified order item.
@ override @ deprecated public link container upload transformation ( export transformation export transformation , input stream zip ) throws io { string uri = export transformation . get uri ( link export transformation zip ) ; return rest client . post ( uri , link container . class , new binary part ( str , zip , str ) ) ; }	Upload the transformation zip with the stylesheet into Archive.
public file generation metrics generate ( iterator < c > components ) throws io { file result = file supplier . get ( ) ; return new file generation metrics ( result , generate ( components , new file buffer ( result ) ) ) ; }	Generate a file by assembling components.
public static file in ( file parent dir ) { file result = new file ( parent dir , uuid . random uuid ( ) . to string ( ) ) ; if ( ! result . mkdirs ( ) ) { throw new runtime io exception ( new io ( str + result ) ) ; } return result ; }	Create a new directory in the given parent directory.
public p end ( ) { parent . add child object ( english . plural ( object . get type ( ) ) , object ) ; return parent ; }	End this builder.
protected < s > void register adaptor ( st group , class < s > type , model adaptor adaptor ) { group . register model adaptor ( type , adaptor ) ; }	Registers a ModelAdaptor with the group.
protected < s > void register renderer ( st group , class < s > type , attribute renderer attribute renderer ) { group . register renderer ( type , attribute renderer ) ; }	Registers a renderer with the group.
protected st prepare template ( st prototype , d domain object , map < string , content info > content info ) { st template = new st ( prototype ) ; template . add ( model variable , domain object ) ; template . add ( content variable , content info ) ; return template ; }	Prepares the template by adding the variables.
public synchronized void add ( d domain object ) throws io { if ( should start new sip ( domain object ) ) { start sip ( ) ; } assembler . add ( domain object ) ; }	Add a domain object to the batch of SIPs.
public void set property ( string name , object value ) { properties . put ( name , to json value ( value ) ) ; }	Set the value of a property.
public void add child object ( string collection , configuration object child object ) { child objects . compute if absent ( collection , ignored -> new array list < > ( ) ) . add ( child object ) ; }	Add an object that is to be owned by this object.
public static supplier < file > from directory ( file dir , string prefix , string suffix ) { return new supplier < file > ( ) { private int count ; @ override public file get ( ) { return new file ( ensure dir ( dir ) , string . format ( str , prefix , ++ count , suffix ) ) ; } } ; }	Returns a supplier that creates sequentially named files in the given directory.
public static void copy ( input stream in , output stream out , int buffer size , hash assembler hash assembler ) throws io { byte [ ] buffer = new byte [ buffer size ] ; int num read = objects . require non null ( in , str ) . read ( buffer ) ; if ( num read == num ) { throw new illegal argument exception ( str ) ; } objects . require non null ( out , str ) ; while ( num read > num ) { out . write ( buffer , num , num read ) ; hash assembler . add ( buffer , num read ) ; num read = in . read ( buffer ) ; } }	Utility method to copy the bytes from an InputStream to an OutputStream while also assembling a hash value in theprocess.
public static document parse ( file file ) { if ( ! file . is file ( ) ) { throw new illegal argument exception ( str + file . get absolute path ( ) ) ; } try { try ( input stream stream = files . new input stream ( file . to path ( ) , standard open option . read ) ) { return parse ( stream ) ; } } catch ( io e ) { throw new illegal argument exception ( str + file . get absolute path ( ) , e ) ; } }	Parse the content of a given file into an XML document.
public static document parse ( reader reader ) { document builder document builder = get document builder ( ) ; try { return document builder . parse ( new input source ( reader ) ) ; } catch ( sax | io e ) { throw new illegal argument exception ( str , e ) ; } finally { document builder . reset ( ) ; } }	Parse the content of a given reader into an XML document.
public static stream < element > elements in ( element parent ) { return nodes in ( parent ) . filter ( n -> n . get node type ( ) == node . element node ) . map ( n -> ( element ) n ) ; }	Return the elements under a given parent element.
public static stream < node > nodes in ( element parent ) { return stream support . stream ( new child nodes spliterator ( parent ) , bool ) ; }	Return the nodes under a given parent element.
public static element get first child element ( element parent , string ... child names ) { return first of ( named elements in ( parent , child names ) ) ; }	Return the first child element of a given parent element whose tag matches any of the given names.
public static stream < element > named elements in ( element parent , string ... child names ) { return elements in ( parent ) . filter ( e -> is name ( e , child names ) ) ; }	Return the elements under a given parent element whose tag matches any of the given names.
public static void validate ( input stream xml , input stream xml schema , string human friendly document type ) throws io { try { new xml schema validator ( xml schema ) . validate ( new stream source ( objects . require non null ( xml ) ) ) ; } catch ( sax e ) { throw new validation exception ( str + human friendly document type , e ) ; } }	Validate an XML document against an XML Schema document.
public static void main ( string [ ] args ) { try { arguments arguments = new arguments ( args ) ; file root = new file ( arguments . next ( str ) ) ; if ( ! root . is directory ( ) ) { root = new file ( str ) ; } string root path = root . get canonical path ( ) ; string sip = arguments . next ( str ) ; new file archiver ( ) . run ( root path , sip ) ; } catch ( io e ) { e . print stack trace ( system . out ) ; system . exit ( num ) ; } }	Build a SIP archive from all files in a given directory tree.
public content builder < p > as ( input stream content ) { try { return as ( io . to string ( content , standard charsets . utf 8 ) ) ; } catch ( io e ) { throw new illegal argument exception ( str , e ) ; } }	Sets the content.
public content builder < p > from resource ( string name ) { try ( input stream content = content builder . class . get resource as stream ( name ) ) { return as ( content ) ; } catch ( io e ) { throw new illegal argument exception ( str + name , e ) ; } }	Sets the content from a named resource.
public < t > t and process entry ( string entry , function < input stream , t > processor ) { try ( zip file zip file = new zip file ( zip ) ) { return process entry ( zip file , entry , processor ) ; } catch ( io e ) { throw new runtime io exception ( e ) ; } }	Process a named entry in the ZIP file.
public static string ascii characters encoding ( string str ) throws qs { if ( qs . is empty ( str ) ) { return str ; } try { string encoded = url . encode ( str , qs . encoding ut ) ; encoded = encoded . replace ( str , str ) ; encoded = encoded . replace ( str , str ) ; encoded = encoded . replace ( str , str ) ; encoded = encoded . replace ( str , str ) ; return encoded ; } catch ( unsupported encoding exception e ) { throw new qs ( str , e ) ; } }	Chinese characters transform.
public void set signature ( string access key , string signature , string gmt time ) throws qs { builder . set header ( qs . header param key date , gmt time ) ; set signature ( access key , signature ) ; }	Set signature and server time.
private static int remove white space ( char [ ] data ) { if ( data == null ) { return num ; }	remove WhiteSpace from MIME containing encoded Base64 data.
private void sign ( request handler request handler ) throws qs { if ( call back != null ) { string signed = call back . on signature ( request handler . get string to signature ( ) ) ; if ( ! qs . is empty ( signed ) ) request handler . set signature ( call back . on access key ( ) , signed ) ; string correct time = call back . on correct time ( request handler . get string to signature ( ) ) ; if ( correct time != null && correct time . trim ( ) . length ( ) > num ) request handler . get builder ( ) . set header ( qs . header param key date , correct time ) ; } }	When sending a request will call this method to sign with server.
private void set data ( string object key , recorder recorder ) { if ( recorder == null ) return ; string upload = new gson ( ) . to json ( upload model ) ; recorder . set ( object key , upload . get bytes ( ) ) ; }	Set data in the upload with a recorder.
private void complete multi upload ( string object key , string file name , string e tag , string upload id , long length ) throws qs { complete multipart upload input complete multipart upload input = new complete multipart upload input ( upload id , part counts , num ) ; complete multipart upload input . set content length ( length ) ;	Complete the multi upload.
@ override public void invoke ( final action request req , final action response res ) throws io { final notification entry entry = get target ( ) ; final string notification id = entry . get id ( ) ; final set < string > favorite notices = this . get favorite notices ( req ) ; if ( favorite notices . contains ( notification id ) ) { favorite notices . remove ( notification id ) ; } else { favorite notices . add ( notification id ) ; } set favorite notices ( req , favorite notices ) ; }	Invoking a FavoriteAction toggles it.
public void add entry state ( portlet request req , string entry id , notification state state ) { if ( username finder . is authenticated ( req ) ) { final string username = username finder . find username ( req ) ; string id str = entry id . replace all ( id prefix , str ) ;	Caller must insure that the state being set has not already been added to the entryto avoid multiple events with the same state.
public boolean has expired ( ) { long now = system . current time millis ( ) ; if ( created + ( expires in * num ) + timeout buffer > now ) { return bool ; } return bool ; }	Helper method to determine if an SSPToken has expired.
@ request mapping ( value = str , method = request method . get ) @ response body public dto get notification ( http servlet response response , @ path variable ( str ) long id , @ request param ( value = str , required = bool , default value = str ) boolean full ) { dto notification = rest service . get notification ( id , full ) ; if ( notification == null ) { response . set status ( http status . not found . value ( ) ) ; return null ; } return notification ; }	Get 1 notification by id.
@ request mapping ( value = str , method = request method . get ) @ response body public set < dto > get addressees ( @ path variable ( str ) long id ) { return rest service . get addressees ( id ) ; }	Get the set of addressees for a notification.
@ request mapping ( value = str , method = request method . get ) @ response body public dto get addressee ( http servlet response resp , @ path variable ( str ) long notification id , @ path variable ( str ) long addressee id ) { dto dto = rest service . get addressee ( addressee id ) ; if ( dto == null ) { resp . set status ( http status . not found . value ( ) ) ; return null ; } return dto ; }	Get a specific addressee.
@ request mapping ( value = str , method = request method . get ) @ response body public list < dto > get events by notification ( @ path variable ( str ) long id ) { return rest service . get events by notification ( id ) ; }	Get the list of events for a notification.
@ request mapping ( value = str , method = request method . get ) @ response body public dto get event ( http servlet response response , @ path variable ( str ) long notification id , @ path variable ( str ) long event id ) { dto event = rest service . get event ( event id ) ; if ( event == null ) { response . set status ( http status . not found . value ( ) ) ; return null ; } return event ; }	Get a specific event.
private string get single notification rest ( http servlet request request , long id ) { string path = request . get context path ( ) + request root + id ; try { url url = new url ( request . get scheme ( ) , request . get server name ( ) , request . get server port ( ) , path ) ; return url . to external form ( ) ; } catch ( url e ) {	Build the URL for a specific notification.
@ override @ transactional ( read only = bool ) public jpa entry get entry ( long entry id ) { validate . is true ( entry id > num , str + entry id ) ; jpa entry rslt = entity manager . find ( jpa entry . class , entry id ) ; return rslt ; }	Search for a JpaEntry with the specified Id.
private synchronized ssp get authentication token ( boolean force update ) throws url , rest client exception { if ( authentication token != null && ! authentication token . has expired ( ) && ! force update ) { return authentication token ; } string auth string = get client id ( ) + str + get client secret ( ) ; string authentication = new base64 ( ) . encode to string ( auth string . get bytes ( ) ) ; http headers headers = new http headers ( ) ; headers . add ( authorization , basic + str + authentication ) ;	Get the authentication token to use.
@ json ignore @ xml transient public int size ( ) { return categories . stream ( ) . map ( notification category :: get entries ) . map to int ( list :: size ) . sum ( ) ; }	Provides the total number of notifications contained in the response.
private void add categories ( list < notification category > new categories ) { if ( new categories == null ) { return ; }	Insert the given categories and their entries into the any existingcategories of the same title.
@ override public notification response fetch ( portlet request req ) { portlet preferences preferences = req . get preferences ( ) ; string enabled = preferences . get value ( ssp notifications enabled , str ) ; if ( ! str . equals ignore case ( enabled ) ) { return new notification response ( ) ; } string person id = get person id ( req ) ; if ( person id == null ) {	Fetch the set of SSP tasks for the uPortal user.
private notification response notification error ( string error msg ) { notification error error = new notification error ( ) ; error . set error ( error msg ) ; error . set source ( get class ( ) . get simple name ( ) ) ; notification response notification = new notification response ( ) ; notification . set errors ( arrays . as list ( error ) ) ; return notification ; }	Error handler.
private notification response map to notification response ( portlet request request , response entity < string > response ) { configuration config = configuration . builder ( ) . options ( option . default path leaf to null ) . build ( ) ; read context read context = json path . using ( config ) . parse ( response . get body ( ) ) ;	Map and SSP Response to a NotificationResponse.
private notification entry map notification entry ( read context read context , int index , string source ) { boolean completed = read context . read ( format ( row completed query fmt , index ) , boolean . class ) ; if ( completed ) { return null ; } notification entry entry = new notification entry ( ) ; entry . set source ( source ) ; string id = read context . read ( format ( row id query fmt , index ) ) ; entry . set id ( id ) ; string title = read context . read ( format ( row name query fmt , index ) ) ; entry . set title ( title ) ; string desc = read context . read ( format ( row description query fmt , index ) ) ; entry . set body ( desc ) ; string link = read context . read ( format ( row link query fmt , index ) ) ; url fixed link = normalize link ( link ) ; if ( fixed link != null ) { entry . set url ( fixed link . to external form ( ) ) ; } date create date = read context . read ( format ( str , index ) , date . class ) ; map < notification state , date > states = new hash map < > ( ) ; states . put ( notification state . issued , create date ) ; try {	Map a single notification entry.
private void attach actions ( portlet request request , notification entry entry ) { portlet preferences prefs = request . get preferences ( ) ; string string val = prefs . get value ( ssp notifications enable mark completed , str ) ; boolean enable mark completed = ( str . equals ignore case ( string val ) ) ; list < notification action > actions = new array list < > ( ) ; if ( enable mark completed ) { mark task completed action action = new mark task completed action ( entry . get id ( ) ) ; actions . add ( action ) ; } entry . set available actions ( actions ) ; }	Attach any SSP specific actions to this entry, if enabled.
private url normalize link ( string link ) { try { if ( string utils . is empty ( link ) ) { return null ; } if ( link . starts with ( str ) ) { return ssp api . get ssp ( link , bool ) ; } if ( link . starts with ( str ) || link . starts with ( str ) ) { return new url ( link ) ; }	Some of the links I have seen from SSP are not well formed.
private notification category get notification category ( portlet request request ) { portlet preferences preferences = request . get preferences ( ) ; string title = preferences . get value ( notification category pref , default category ) ; notification category category = new notification category ( ) ; category . set title ( title ) ; return category ; }	Get the category name to use for SSP notifications.
private string get notification source ( portlet request req ) { portlet preferences preferences = req . get preferences ( ) ; string source = preferences . get value ( notification source pref , default notification source ) ; return source ; }	Get the source value to use for a Notification entry.
@ override public void invoke ( final action request req , final action response res ) throws io { final notification entry entry = get target ( ) ; final string notification id = entry . get id ( ) ; final set < string > read notices = this . get read notices ( req ) ; if ( read notices . contains ( notification id ) ) { read notices . remove ( notification id ) ; } else { read notices . add ( notification id ) ; } set read notices ( req , read notices ) ; }	Invoking a ReadAction toggles it.
private notification response read from file ( string filename ) { notification response rslt ; logger . debug ( str , filename ) ; url location = get class ( ) . get class loader ( ) . get resource ( filename ) ; if ( location != null ) { try { file f = new file ( location . to uri ( ) ) ; rslt = mapper . read value ( f , notification response . class ) ; } catch ( exception e ) { string msg = str + location ; logger . error ( msg , e ) ; rslt = prepare error response ( get name ( ) , msg ) ; } } else { string msg = str + filename ; rslt = prepare error response ( get name ( ) , msg ) ; } return rslt ; }	Deserialize the given JSON formatted file back into a object.
private string get school id ( portlet request request ) { portlet preferences prefs = request . get preferences ( ) ; string school id attribute name = prefs . get value ( str , str ) ; map < string , string > user info = ( map < string , string > ) request . get attribute ( portlet request . user info ) ; string student id = user info . get ( school id attribute name ) ; if ( ! string utils . is empty ( student id ) ) { return student id ; }	Get the schoolId value from the request.
private string extract user id ( string student id , response entity < string > response ) { configuration config = configuration . builder ( ) . options ( option . default path leaf to null ) . build ( ) ; read context read context = json path . using ( config ) . parse ( response . get body ( ) ) ; string success = read context . read ( success query ) ;	Parse the person lookup response from SSP.
@ override public void invoke ( final action request req , final action response res ) throws io { final notification entry entry = get target ( ) ; if ( ! is entry snoozed ( entry , req ) ) {	Invoking a HideAction toggles it.
@ json ignore public map < string , list < string > > get attributes map ( ) { map < string , list < string > > rslt = new hash map < > ( ) ; for ( notification attribute a : attributes ) { rslt . put ( a . get name ( ) , a . get values ( ) ) ; } return rslt ; }	Convenience method for obtaining the attributes in a more usable collection.
public static void normalize ( d p ) { double n = p . norm ( ) ; p . x /= n ; p . y /= n ; p . z /= n ; }	Normalizes the point such that the Frobenius norm is 1.
public static boolean contained ( d box a , d box b ) { return ( box a . p0 . x <= box b . p0 . x && box a . p1 . x >= box b . p1 . x && box a . p0 . y <= box b . p0 . y && box a . p1 . y >= box b . p1 . y && box a . p0 . z <= box b . p0 . z && box a . p1 . z >= box b . p1 . z ) ; }	Returns true if boxB is contained inside of or is identical to boxA.
public void closest point ( d p , d closest pt ) {	Find the closest point on the triangle to P.
public double sign ( d p ) { geometry math f64 . cross ( e1 , e0 , n ) ;	Returns the signed of the vector.
public void set ( se3 f64 se ) { r . set ( se . get r ( ) ) ; t . set ( se . get t ( ) ) ; }	Set's 'this' Se3_F64 to be identical to the provided transform.
public void set ( double x , double y , double z , euler type type , double rot a , double rot b , double rot c ) { t . set ( x , y , z ) ; d . euler to matrix ( type , rot a , rot b , rot c , r ) ; }	Fully specify the transform using Euler angles.
public static void convert ( d input , d output ) { if ( output . size ( ) != num ) throw new illegal argument exception ( str ) ; output . get ( num ) . set ( input . p0 . x , input . p0 . y ) ; output . get ( num ) . set ( input . p1 . x , input . p0 . y ) ; output . get ( num ) . set ( input . p1 . x , input . p1 . y ) ; output . get ( num ) . set ( input . p0 . x , input . p1 . y ) ; }	Converts a rectangle into a polygon.
public static void convert ( d input , quadrilateral f64 output ) { if ( input . size ( ) != num ) throw new illegal argument exception ( str ) ; output . a . set ( input . get ( num ) ) ; output . b . set ( input . get ( num ) ) ; output . c . set ( input . get ( num ) ) ; output . d . set ( input . get ( num ) ) ; }	Converts a polygon into a quadrilateral.
public static void bounding ( quadrilateral f64 quad , d rectangle ) { rectangle . p0 . x = math . min ( quad . a . x , quad . b . x ) ; rectangle . p0 . x = math . min ( rectangle . p0 . x , quad . c . x ) ; rectangle . p0 . x = math . min ( rectangle . p0 . x , quad . d . x ) ; rectangle . p0 . y = math . min ( quad . a . y , quad . b . y ) ; rectangle . p0 . y = math . min ( rectangle . p0 . y , quad . c . y ) ; rectangle . p0 . y = math . min ( rectangle . p0 . y , quad . d . y ) ; rectangle . p1 . x = math . max ( quad . a . x , quad . b . x ) ; rectangle . p1 . x = math . max ( rectangle . p1 . x , quad . c . x ) ; rectangle . p1 . x = math . max ( rectangle . p1 . x , quad . d . x ) ; rectangle . p1 . y = math . max ( quad . a . y , quad . b . y ) ; rectangle . p1 . y = math . max ( rectangle . p1 . y , quad . c . y ) ; rectangle . p1 . y = math . max ( rectangle . p1 . y , quad . d . y ) ; }	Finds the minimum area bounding rectangle around the quadrilateral.
public static void bounding ( d polygon , d rectangle ) { rectangle . p0 . set ( polygon . get ( num ) ) ; rectangle . p1 . set ( polygon . get ( num ) ) ; for ( int i = num ; i < polygon . size ( ) ; i ++ ) { d p = polygon . get ( i ) ; if ( p . x < rectangle . p0 . x ) { rectangle . p0 . x = p . x ; } else if ( p . x > rectangle . p1 . x ) { rectangle . p1 . x = p . x ; } if ( p . y < rectangle . p0 . y ) { rectangle . p0 . y = p . y ; } else if ( p . y > rectangle . p1 . y ) { rectangle . p1 . y = p . y ; } } }	Finds the minimum area bounding rectangle around the quadrilateral that is aligned with coordinatesystem axises.
public static d center ( quadrilateral f64 quad , d center ) { if ( center == null ) center = new d ( ) ; center . x = quad . a . x + quad . b . x + quad . c . x + quad . d . x ; center . y = quad . a . y + quad . b . y + quad . c . y + quad . d . y ; center . x /= num ; center . y /= num ; return center ; }	Computes the center or average point in the quadrilateral.
public static void vertex average ( d input , d average ) { average . set idx ( num , num ) ; for ( int i = num ; i < input . size ( ) ; i ++ ) { d v = input . vertexes . data [ i ] ; average . x += v . x ; average . y += v . y ; } average . x /= input . size ( ) ; average . y /= input . size ( ) ; }	Computes the average of all the vertexes.
public static void convex hull ( list < d > points , d hull ) { d [ ] array = new d [ points . size ( ) ] ; for ( int i = num ; i < points . size ( ) ; i ++ ) { array [ i ] = points . get ( i ) ; } andrew monotone convex hull f64 andrew = new andrew monotone convex hull f64 ( ) ; andrew . process ( array , array . length , hull ) ; }	Computes the convex hull of the set of points.
public static void remove almost parallel ( d polygon , double tol ) { for ( int i = num ; i < polygon . vertexes . size ( ) ; ) { int j = ( i + num ) % polygon . vertexes . size ( ) ; int k = ( i + num ) % polygon . vertexes . size ( ) ; d p0 = polygon . vertexes . get ( i ) ; d p1 = polygon . vertexes . get ( j ) ; d p2 = polygon . vertexes . get ( k ) ; double angle = d . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; if ( angle <= tol ) { polygon . vertexes . remove ( j ) ; if ( j < i ) i = polygon . vertexes . size ( ) - num ; } else { i ++ ; } } }	Removes a node from a polygon if the two lines its attached two are almost parallel.
public static double average of closest point error ( d model , d target , int number of samples ) { d line = new d ( ) ; double corner locations b [ ] = new double [ target . size ( ) + num ] ; double total length = num ; for ( int i = num ; i < target . size ( ) ; i ++ ) { d b0 = target . get ( i % target . size ( ) ) ; d b1 = target . get ( ( i + num ) % target . size ( ) ) ; corner locations b [ i ] = total length ; total length += b0 . distance ( b1 ) ; } corner locations b [ target . size ( ) ] = total length ; d point on b = new d ( ) ; double error = num ; int corner b = num ; for ( int k = num ; k < number of samples ; k ++ ) {	Compute the error as a function of the distance between the model and target.
public double compute area ( d a , d b ) { ssss = num ; sclx = num ; scly = num ; return inter ( a , b ) ; }	Computes the area of the intersection between the two polygons.Note: the area result has little more accuracy than a floatThis is true even if the polygon is specified with doubles.
public static boolean contains ( quadrilateral f64 quad , d pt ) { return contain triangle ( quad . a , quad . b , quad . d , pt ) || contain triangle ( quad . b , quad . c , quad . d , pt ) ; }	True if the point is contained inside the quadrilateral.
public static boolean contain triangle ( d a , d b , d c , d pt ) { boolean ret = bool ; if ( ( ( a . y > pt . y ) != ( b . y > pt . y ) ) && ( pt . x < ( b . x - a . x ) * ( pt . y - a . y ) / ( b . y - a . y ) + a . x ) ) ret = bool ; if ( ( ( b . y > pt . y ) != ( c . y > pt . y ) ) && ( pt . x < ( c . x - b . x ) * ( pt . y - b . y ) / ( c . y - b . y ) + b . x ) ) ret = ! ret ; if ( ( ( c . y > pt . y ) != ( a . y > pt . y ) ) && ( pt . x < ( a . x - c . x ) * ( pt . y - c . y ) / ( a . y - c . y ) + c . x ) ) ret = ! ret ; return ret ; }	Returns true of the the point is inside the triangle.This function is simply an unrolled version of {.
public static d intersection ( d a , d b , d ret ) { double t b = a . get slope x ( ) * ( b . get y ( ) - a . get y ( ) ) - a . get slope y ( ) * ( b . get x ( ) - a . get x ( ) ) ; double bottom = a . get slope y ( ) * b . get slope x ( ) - b . get slope y ( ) * a . get slope x ( ) ; if ( bottom == num ) return null ; t b /= bottom ; double x = b . get slope x ( ) * t b + b . get x ( ) ; double y = b . get slope y ( ) * t b + b . get y ( ) ; if ( ret == null ) ret = new d ( ) ; ret . set ( x , y ) ; return ret ; }	Finds the point of intersection between two lines and returns the point.
public static d intersection ( d l 0 , d l 1 , d ret ) { double a0 = l 0 . b . x - l 0 . a . x ; double b0 = l 0 . b . y - l 0 . a . y ; double a1 = l 1 . b . x - l 1 . a . x ; double b1 = l 1 . b . y - l 1 . a . y ; double top = b0 * ( l 1 . a . x - l 0 . a . x ) + a0 * ( l 0 . a . y - l 1 . a . y ) ; double bottom = a0 * b1 - b0 * a1 ; if ( bottom == num ) return null ; double t 1 = top / bottom ;	Finds the point of intersection between two lines segments.
public static d intersection ( d line a0 , d line a1 , d line b0 , d line b1 , d output ) { if ( output == null ) output = new d ( ) ; double slope ax = line a1 . x - line a0 . x ; double slope ay = line a1 . y - line a0 . y ; double slope bx = line b1 . x - line b0 . x ; double slope by = line b1 . y - line b0 . y ; double top = slope ay * ( line b0 . x - line a0 . x ) + slope ax * ( line a0 . y - line b0 . y ) ; double bottom = slope ax * slope by - slope ay * slope bx ; if ( bottom == num ) return null ; double t = top / bottom ; output . x = line b0 . x + t * slope bx ; output . y = line b0 . y + t * slope by ; return output ; }	Finds the point of intersection between the two lines defined by the set sets of points passed in.
public static double intersection ( d target , d l ) { double a1 = l . b . x - l . a . x ; double b1 = l . b . y - l . a . y ; double top = target . slope . y * ( l . a . x - target . p . x ) + target . slope . x * ( target . p . y - l . a . y ) ; double bottom = target . slope . x * b1 - target . slope . y * a1 ; if ( bottom == num ) return double . n ; double t 1 = top / bottom ;	Finds the point of intersection between a line and a line segment.
public static double intersection ( d a , d b ) { d alg = new d ( ) ; return math . abs ( alg . compute area ( a , b ) ) ; }	Finds the area of the intersection of two polygons.
public static boolean contains ( ellipse rotated f64 ellipse , double x , double y ) { return ( util ellipse f64 . evaluate ( x , y , ellipse ) <= num ) ; }	Tests to see if the provided point lies on or is contained inside the ellipse.
public static double intersection area ( d a , d b ) { if ( ! intersects ( a , b ) ) return num ; double x0 = math . max ( a . p0 . x , b . p0 . x ) ; double x1 = math . min ( a . p1 . x , b . p1 . x ) ; double y0 = math . max ( a . p0 . y , b . p0 . y ) ; double y1 = math . min ( a . p1 . y , b . p1 . y ) ; return ( x1 - x0 ) * ( y1 - y0 ) ; }	Returns the area of the intersection of two rectangles.
private static double get ( d r m , int index ) { if ( index < num ) { return - m . data [ - index - num ] ; } else { return m . data [ index - num ] ; } }	If the index is negative it returns the negative of the value at -index. Starts at 0.
public static quaternion f64 matrix to quaternion ( d r r , quaternion f64 quat ) { if ( quat == null ) quat = new quaternion f64 ( ) ;	Extracts quaternions from the provided rotation matrix.
public static d r rot x ( double ang , d r r ) { if ( r == null ) r = new d r ( num , num ) ; set rot x ( ang , r ) ; return r ; }	Creates a rotation matrix about the x-axis.
public static void set rot x ( double ang , d r r ) { double c = math . cos ( ang ) ; double s = math . sin ( ang ) ; r . set ( num , num , num ) ; r . set ( num , num , c ) ; r . set ( num , num , - s ) ; r . set ( num , num , s ) ; r . set ( num , num , c ) ; }	Sets the values in the specified matrix to a rotation matrix about the x-axis.
public static d r rot y ( double ang , d r r ) { r = check declare3x3 ( r ) ; set rot y ( ang , r ) ; return r ; }	Creates a rotation matrix about the y-axis.
public static d r rot z ( double ang , d r r ) { r = check declare3x3 ( r ) ; set rot z ( ang , r ) ; return r ; }	Creates a rotation matrix about the z-axis.
public static void set rot z ( double ang , d r r ) { double c = math . cos ( ang ) ; double s = math . sin ( ang ) ; r . set ( num , num , c ) ; r . set ( num , num , - s ) ; r . set ( num , num , s ) ; r . set ( num , num , c ) ; r . set ( num , num , num ) ; }	Sets the values in the specified matrix to a rotation matrix about the z-axis.
public static d r euler to matrix ( euler type type , double rot a , double rot b , double rot c , d r r ) { r = check declare3x3 ( r ) ; d r r a = rotation about axis ( type . get axis a ( ) , rot a , null ) ; d r r b = rotation about axis ( type . get axis b ( ) , rot b , null ) ; d r r c = rotation about axis ( type . get axis c ( ) , rot c , null ) ; d r a = new d r ( num , num ) ; ddrm . mult ( r b , r a , a ) ; ddrm . mult ( r c , a , r ) ; return r ; }	Converts an Euler coordinate into a rotation matrix.
private static d r rotation about axis ( int axis , double angle , d r r ) { switch ( axis ) { case num : return d . rot x ( angle , r ) ; case num : return d . rot y ( angle , r ) ; case num : return d . rot z ( angle , r ) ; default : throw new illegal argument exception ( str ) ; } }	Creates a rotation matrix about the specified axis.
public void set angle ( double angle ) { slope . set ( math . cos ( angle ) , math . sin ( angle ) ) ; }	Sets the slope to the unit vector specified by the provided angle.
public static twist coordinate f64 twist ( se3 f64 motion , twist coordinate f64 twist ) { if ( twist == null ) twist = new twist coordinate f64 ( ) ; if ( ddrm . is identity ( motion . r , grl constants . test ) ) { twist . w . set ( num , num , num ) ; twist . v . set ( motion . t ) ; } else { rodrigues f64 rod = new rodrigues f64 ( ) ; d . matrix to rodrigues ( motion . r , rod ) ; twist . w . set ( rod . unit axis rotation ) ; double theta = rod . theta ;	Converts a rigid body motion into a twist coordinate.
public void set transforms ( se3 f64 initial , se3 f64 end ) { this . initial . set ( initial ) ; translation . x = end . t . x - initial . t . x ; translation . y = end . t . y - initial . t . y ; translation . z = end . t . z - initial . t . z ; ddrm . mult trans a ( initial . get r ( ) , end . get r ( ) , r ) ; d . matrix to rodrigues ( r , rotation ) ; rot magnitude = rotation . theta ; }	Specify the two transforms which values are to be interpolated between.
public void interpolate ( double where , se3 f64 output ) { rotation . set theta ( where * rot magnitude ) ; d . rodrigues to matrix ( rotation , r ) ; output . t . x = initial . t . x + where * translation . x ; output . t . y = initial . t . y + where * translation . y ; output . t . z = initial . t . z + where * translation . z ; ddrm . mult ( initial . r , r , output . r ) ; }	Interpolates a value between the first and second transform.
public boolean svd ( list < d > points , d output center , d output normal ) { final int n = points . size ( ) ;	SVD based method for fitting a plane to a set of points.
public boolean solve point ( list < d > points , d point on plane , d output normal ) { final int n = points . size ( ) ;	SVD based method for fitting a plane to a set of points and a known point on the plane.
public double get side length ( int index ) { d a = vertexes . get ( index ) ; d b = vertexes . get ( ( index + num ) % vertexes . size ) ; return ( double ) a . distance ( b ) ; }	Resturns the length of the specified side that is composed of point index and index+1.
public boolean is inside ( d p ) { if ( is convex ( ) ) { return d . contain convex ( this , p ) ; } else { return d . contain concave ( this , p ) ; } }	Returns true if the point is inside the polygon.
public static d r convert ( conic general f64 src , d r dst ) { if ( dst == null ) dst = new d r ( num , num ) ; else dst . reshape ( num , num ) ; double b = src . b / num ; double d = src . d / num ; double e = src . e / num ; dst . data [ num ] = src . a ; dst . data [ num ] = b ; dst . data [ num ] = d ; dst . data [ num ] = b ; dst . data [ num ] = src . c ; dst . data [ num ] = e ; dst . data [ num ] = d ; dst . data [ num ] = e ; dst . data [ num ] = src . f ; return dst ; }	Converts symmetric 3x3 matrix back into a conic. [A B/2 D/2]dst = [B/2 C E/2][D/2 E/2 F ].
public static d convert ( conic general f64 src , d dst ) { if ( dst == null ) dst = new d ( ) ; double b = src . b / num ; double d = src . d / num ; double e = src . e / num ; dst . a11 = src . a ; dst . a12 = b ; dst . a13 = d ; dst . a21 = b ; dst . a22 = src . c ; dst . a23 = e ; dst . a31 = d ; dst . a32 = e ; dst . a33 = src . f ; return dst ; }	Converts the conic into a symmetric 3x3 matrix [A B/2 D/2]dst = [B/2 C E/2][D/2 E/2 F ].
public static parabola general f64 convert ( conic general f64 src , parabola general f64 dst ) { if ( dst == null ) dst = new parabola general f64 ( ) ;	Converts the conic into a parabola.
public static conic general f64 convert ( parabola general f64 src , conic general f64 dst ) { if ( dst == null ) dst = new conic general f64 ( ) ; dst . a = src . a * src . a ; dst . b = src . a * src . c * num ; dst . c = src . c * src . c ; dst . d = src . d ; dst . e = src . e ; dst . f = src . f ; return dst ; }	Converts the parabola into a conic.
public static void divide ( d p , double v ) { p . x /= v ; p . y /= v ; p . z /= v ; }	Divides each element by 'v'.
public static d r to matrix ( d in , d r out ) { if ( out == null ) out = new d r ( num , num ) ; else if ( out . get num elements ( ) != num ) throw new illegal argument exception ( str ) ; out . data [ num ] = in . x ; out . data [ num ] = in . y ; out . data [ num ] = in . z ; return out ; }	Converts a GeoTuple3D_F64 into DMatrixRMaj.
public static void to tuple3 d ( d r in , d out ) { out . x = ( double ) in . get ( num ) ; out . y = ( double ) in . get ( num ) ; out . z = ( double ) in . get ( num ) ; }	Converts a DMatrixRMaj into GeoTuple3D_F64.
public void set param vector ( double x , double y , double z ) { double ax = math . abs ( x ) ; double ay = math . abs ( y ) ; double az = math . abs ( z ) ; double max = math . max ( ax , ay ) ; max = math . max ( max , az ) ; if ( max == num ) { theta = num ; unit axis rotation . set ( num , num , num ) ; } else { x /= max ; y /= max ; z /= max ; theta = math . sqrt ( x * x + y * y + z * z ) ; unit axis rotation . x = x / theta ; unit axis rotation . y = y / theta ; unit axis rotation . z = z / theta ; theta *= max ; } }	Assign the Rodrigues coordinates using a 3 element vector.
public static double dist half ( double ang a , double ang b ) { double a = math . abs ( ang a - ang b ) ; if ( a <= math . pi / num ) return a ; else return math . pi - a ; }	Angular distance between two half circle angles.
public static boolean intersect ( d a , d b , d line ) {	Finds the line which is the intersection between the two planes.
private static boolean contained plane ( d t v0 , d output , d u , d v , d w0 ) { double uu , uv , vv , wu , wv , d ; uu = u . dot ( u ) ; uv = u . dot ( v ) ; vv = v . dot ( v ) ; w0 . minus ( output , t v0 ) ; wu = w0 . dot ( u ) ; wv = w0 . dot ( v ) ; d = uv * uv - uu * vv ;	Determines if the point on the same plane as T is contained inside of T.
public static boolean intersect ( d line , d sphere , d a , d b ) {	Finds the intersection of a line and sphere.
public static void interpolate ( se2 f64 a , se2 f64 b , double where , se2 f64 output ) { double w0 = num - where ; output . t . x = a . t . x * w0 + b . t . x * where ; output . t . y = a . t . y * w0 + b . t . y * where ;	Perform linear interpolation.
private void extract quaternion from q ( simple matrix q ) { evd < simple matrix > evd = q . eig ( ) ; int index max = evd . get index max ( ) ; simple matrix v max = evd . get eigen vector ( index max ) ; quat . w = ( double ) v max . get ( num ) ; quat . x = ( double ) v max . get ( num ) ; quat . y = ( double ) v max . get ( num ) ; quat . z = ( double ) v max . get ( num ) ; quat . normalize ( ) ; d . quaternion to matrix ( quat , motion . get r ( ) ) ; }	The unit eigenvector corresponding to the maximum eigenvalue of Q is the rotationparameterized as a quaternion.
public void process ( d [ ] input , int length , d hull ) {	Computes the convex hull.
public static void set to no motion ( se3 f64 se ) { ddrm . set identity ( se . get r ( ) ) ; se . get t ( ) . set ( num , num , num ) ; }	Sets the provided transform so that it does not transform any points.
public static d r to homogeneous ( se3 f64 se , d r ret ) { if ( ret == null ) ret = new d r ( num , num ) ; else { ret . set ( num , num , num ) ; ret . set ( num , num , num ) ; ret . set ( num , num , num ) ; } ddrm . insert ( se . get r ( ) , ret , num , num ) ; d t = se . get t ( ) ; ret . set ( num , num , t . x ) ; ret . set ( num , num , t . y ) ; ret . set ( num , num , t . z ) ; ret . set ( num , num , num ) ; return ret ; }	Converts it into a 4 by 4 homogeneous matrix.
public static d r to homogeneous ( se2 f64 se , d r ret ) { if ( ret == null ) ret = new d r ( num , num ) ; else { ret . set ( num , num , num ) ; ret . set ( num , num , num ) ; } final double c = se . get cosine yaw ( ) ; final double s = se . get sine yaw ( ) ; ret . set ( num , num , c ) ; ret . set ( num , num , - s ) ; ret . set ( num , num , s ) ; ret . set ( num , num , c ) ; ret . set ( num , num , se . get x ( ) ) ; ret . set ( num , num , se . get y ( ) ) ; ret . set ( num , num , num ) ; return ret ; }	Converts it into a 3 by 3 homogeneous matrix.
public static se3 f64 axis xyz ( double dx , double dy , double dz , double rot x , double rot y , double rot z , se3 f64 se ) { if ( se == null ) se = new se3 f64 ( ) ; double theta = math . sqrt ( rot x * rot x + rot y + rot y + rot z * rot z ) ; if ( theta == num ) { ddrm . set identity ( se . r ) ; } else { d . rodrigues to matrix ( rot x / theta , rot y / theta , rot z / theta , theta , se . get r ( ) ) ; } d t = se . get t ( ) ; t . x = dx ; t . y = dy ; t . z = dz ; return se ; }	Create SE3 using axis-angle for rotation and XYZ tanslation.
public static boolean is identical ( se3 f64 a , se3 f64 b , double tol t , double tol r ) { if ( math . abs ( a . t . x - b . t . x ) > tol t ) return bool ; if ( math . abs ( a . t . y - b . t . y ) > tol t ) return bool ; if ( math . abs ( a . t . z - b . t . z ) > tol t ) return bool ; d r d = new d r ( num , num ) ; ddrm . mult trans a ( a . r , b . r , d ) ; rodrigues f64 rod = new rodrigues f64 ( ) ; d . matrix to rodrigues ( d , rod ) ; return rod . theta <= tol r ; }	Can be used to see if two transforms are identical to within tolerance.
public static < t extends d < t > > t latlon to unit vector ( double lat , double lon , t vector ) { if ( vector == null ) vector = ( t ) new d ( ) ; vector . x = math . cos ( lat ) * math . cos ( lon ) ; vector . y = math . cos ( lat ) * math . sin ( lon ) ; vector . z = - math . sin ( lat ) ; return vector ; }	Converts latitude and longitude coordinates into a unit vector.
public static boolean circle ( d x0 , d x1 , d x2 , d circle ) {	Given three points find the circle that intersects all three.
public static double circle radius sq ( d x0 , d x1 , d x2 ) {	Radius squares of the circle that passes through these three points.
public static d closest point ( d l0 , d l1 , d ret ) { if ( ret == null ) { ret = new d ( ) ; } ret . x = l0 . p . x - l1 . p . x ; ret . y = l0 . p . y - l1 . p . y ; ret . z = l0 . p . z - l1 . p . z ;	Returns the point which minimizes the distance between the two lines in 3D.
public static d closest point ( d line , d pt , d ret ) { if ( ret == null ) { ret = new d ( ) ; } double dx = pt . x - line . p . x ; double dy = pt . y - line . p . y ; double dz = pt . z - line . p . z ; double n2 = line . slope . norm sq ( ) ; double d = ( line . slope . x * dx + line . slope . y * dy + line . slope . z * dz ) ; ret . x = line . p . x + d * line . slope . x / n2 ; ret . y = line . p . y + d * line . slope . y / n2 ; ret . z = line . p . z + d * line . slope . z / n2 ; return ret ; }	Finds the closest point on a line to the specified point.
public static d closest point origin ( d plane , d found ) { if ( found == null ) found = new d ( ) ; double n2 = plane . a * plane . a + plane . b * plane . b + plane . c * plane . c ; found . x = plane . a * plane . d / n2 ; found . y = plane . b * plane . d / n2 ; found . z = plane . c * plane . d / n2 ; return found ; }	Finds the closest point on the plane to the origin.
public static d closest point ( d line , d pt , d ret ) { if ( ret == null ) { ret = new d ( ) ; } double dx = pt . x - line . a . x ; double dy = pt . y - line . a . y ; double dz = pt . z - line . a . z ; double slope x = line . b . x - line . a . x ; double slope y = line . b . y - line . a . y ; double slope z = line . b . z - line . a . z ; double n = ( double ) math . sqrt ( slope x * slope x + slope y * slope y + slope z * slope z ) ; double d = ( slope x * dx + slope y * dy + slope z * dz ) / n ;	Finds the closest point on a line segment to the specified point.
public static d closest point ( d vertex a , d vertex b , d vertex c , d point , d ret ) { if ( ret == null ) { ret = new d ( ) ; } d alg = new d ( ) ; alg . set triangle ( vertex a , vertex b , vertex c ) ; alg . closest point ( point , ret ) ; return ret ; }	Closest point from a 3D triangle to a point.
public static d transform ( se2 f64 se , d orig , d result ) { if ( result == null ) { result = new d ( ) ; } final double c = se . get cosine yaw ( ) ; final double s = se . get sine yaw ( ) ;	Applies a 2D special euclidean transform to the point and stores the results in anothervariable.
public static void transform ( se2 f64 se , d points [ ] , int length ) { double tran x = se . get x ( ) ; double tran y = se . get y ( ) ; final double c = se . get cosine yaw ( ) ; final double s = se . get sine yaw ( ) ; for ( int i = num ; i < length ; i ++ ) { d pt = points [ i ] ; double x = pt . x ; double y = pt . y ; pt . x = tran x + x * c - y * s ; pt . y = tran y + x * s + y * c ; } }	Applies a 2D special euclidean transform to an array of points.
public boolean is equals ( quadrilateral f64 quad , double tol ) { tol *= tol ; if ( a . distance2 ( quad . a ) > tol ) return bool ; if ( b . distance2 ( quad . b ) > tol ) return bool ; if ( c . distance2 ( quad . c ) > tol ) return bool ; return d . distance2 ( quad . d ) <= tol ; }	Returns true if the two quadrilaterals are equal to each other to within tolerance.
public static double acute angle ( d a , d b ) { double la = math . sqrt ( a . a * a . a + a . b * a . b ) ; double lb = math . sqrt ( b . a * b . a + b . b * b . b ) ;	Returns the acute angle between the slope of two lines.
public static d convert ( d src , d ret ) { if ( ret == null ) ret = new d ( ) ; double c = ( double ) math . cos ( src . angle ) ; double s = ( double ) math . sin ( src . angle ) ; ret . p . set ( c * src . distance , s * src . distance ) ; ret . slope . set ( - s , c ) ; return ret ; }	Converts a line from polar form to parametric.
public static d convert ( d src , d ret ) { if ( ret == null ) ret = new d ( ) ; double r = math . sqrt ( src . a * src . a + src . b * src . b ) ; double sign = src . c < num ? - num : num ; ret . angle = math . atan2 ( - sign * src . b / r , - sign * src . a / r ) ; ret . distance = sign * src . c / r ; return ret ; }	Converts a line from general to polar.
public static d convert ( d src , d ret ) { if ( ret == null ) ret = new d ( ) ; ret . p . set ( src . a ) ; ret . slope . set ( src . slope x ( ) , src . slope y ( ) ) ; return ret ; }	Converts a line segment into a parametric line.
public static d convert ( d src , d ret ) { return convert ( src . a , src . b , ret ) ; }	Converts a line segment into a general line.
public static d convert ( d a , d b , d ret ) { if ( ret == null ) ret = new d ( ) ; ret . a = a . y - b . y ; ret . b = b . x - a . x ; ret . c = - ( ret . a * a . x + ret . b * a . y ) ; return ret ; }	Converts a line segment into a general line.
public static d convert ( d a , d b , d ret ) { if ( ret == null ) ret = new d ( ) ; ret . p . set ( a ) ; ret . slope . x = b . x - a . x ; ret . slope . y = b . y - a . y ; return ret ; }	Converts a line segment into a line in parametric format.
public static d convert ( d src , d ret ) { if ( ret == null ) ret = new d ( ) ; double top = src . slope . y * src . p . x - src . slope . x * src . p . y ; ret . distance = top / src . slope . norm ( ) ; ret . angle = math . atan2 ( - src . slope . x , src . slope . y ) ; if ( ret . distance < num ) { ret . distance = - ret . distance ; ret . angle = util angle . bound ( ret . angle + math . pi ) ; } return ret ; }	Converts a line from parametric to polar.
public static d convert ( d src , d ret ) { if ( ret == null ) { ret = new d ( ) ; } ret . a = - src . slope . y ; ret . b = src . slope . x ; ret . c = - ret . a * src . p . x - ret . b * src . p . y ; return ret ; }	Converts a line from parametric to general.
public static d convert ( d src , d ret ) { if ( ret == null ) { ret = new d ( ) ; } ret . slope . x = src . b ; ret . slope . y = - src . a ;	Converts a line from general to parametric.
public static d convert ( d input , d output ) { if ( output == null ) output = new d ( ) ; d n = input . n ; d p = input . p ; output . a = n . x ; output . b = n . y ; output . c = n . z ; output . d = n . x * p . x + n . y * p . y + n . z * p . z ; return output ; }	Converts a plane in normal form into a general equation.
public static d convert ( d input , d output ) { if ( output == null ) output = new d ( ) ;	Converts a plane in tangent form into a plane in normal form.
public static d convert ( se3 f64 plane to world , d output ) { if ( output == null ) output = new d ( ) ;	Defines a plane using a 3D rigid body transform.
public static void point2 dto3 d ( d origin , d axis x , d axis y , d a , d output ) { output . x = origin . x + axis x . x * a . x + axis y . y * a . y ; output . y = origin . y + axis x . y * a . x + axis y . y * a . y ; output . z = origin . z + axis x . z * a . x + axis y . y * a . y ; }	Given a point on the plane's 2D coordinate system, convert it back into a 3D point.
public static se3 f64 plane to world ( d plane , se3 f64 plane to world ) { if ( plane to world == null ) plane to world = new se3 f64 ( ) ; d axis z = new d ( plane . a , plane . b , plane . c ) ; axis z . normalize ( ) ; d axis x = new d ( ) ; d axis y = new d ( ) ; d . select axis2 d ( axis z , axis x , axis y ) ; return plane to world ( plane , axis x , axis y , axis z , plane to world ) ; }	Creates a transform from the plane's reference frame into world's reference frame.
public boolean is identical ( t t , double tol ) { if ( t . get dimension ( ) != get dimension ( ) ) return bool ; int n = get dimension ( ) ; for ( int i = num ; i < n ; i ++ ) { double diff = math . abs ( get idx ( i ) - t . get idx ( i ) ) ; if ( diff > tol ) return bool ; } return bool ; }	Checks to see if the two GeoTuple have values which are nearly the same.
@ override public t copy ( ) { t ret = create new instance ( ) ; int n = get dimension ( ) ; for ( int i = num ; i < n ; i ++ ) { ret . set idx ( i , get idx ( i ) ) ; } return ret ; }	Generic copy routine. It is recommended that this be overridden with a faster implementation.
public double norm sq ( ) { double total = num ; int n = get dimension ( ) ; for ( int i = num ; i < n ; i ++ ) { double a = get idx ( i ) ; total += a * a ; } return total ; }	Computes the square of the Euclidean norm.
public static double compute t ( d line , d point on line ) { double dx = point on line . x - line . p . x ; double dy = point on line . y - line . p . y ; double dz = point on line . z - line . p . z ; double adx = math . abs ( dx ) ; double ady = math . abs ( dy ) ; double adz = math . abs ( dz ) ; double t ; if ( adx > ady ) { if ( adx > adz ) { t = dx / line . slope . x ; } else { t = dz / line . slope . z ; } } else if ( ady > adz ) { t = dy / line . slope . y ; } else { t = dz / line . slope . z ; } return t ; }	Computes the value of T for a point on the parametric line.
public boolean has uncountable ( ) { return util ejml . is uncountable ( a ) || util ejml . is uncountable ( c ) || util ejml . is uncountable ( d ) || util ejml . is uncountable ( e ) || util ejml . is uncountable ( f ) ; }	Returns true if any of its parameters have an uncountable number.
public boolean is equivalent ( parabola general f64 parabola , double tol ) { double scale = relative scale ( parabola ) ; if ( math . abs ( a * scale - parabola . a ) > tol ) return bool ; if ( math . abs ( c * scale - parabola . c ) > tol ) return bool ; if ( math . abs ( d * scale - parabola . d ) > tol ) return bool ; if ( math . abs ( e * scale - parabola . e ) > tol ) return bool ; if ( math . abs ( f * scale - parabola . f ) > tol ) return bool ; return bool ; }	Determines if they are equivalent up to a scale factor.
public d center ( d storage ) { if ( storage == null ) storage = new d ( ) ; storage . x = ( p0 . x + p1 . x ) / num ; storage . y = ( p0 . y + p1 . y ) / num ; storage . z = ( p0 . z + p1 . z ) / num ; return storage ; }	Computes and return the center of the cube.
public static double acute angle ( d line0 , d line1 ) { int dx0 = line0 . b . x - line0 . a . x ; int dy0 = line0 . b . y - line0 . a . y ; int dx1 = line1 . b . x - line1 . a . x ; int dy1 = line1 . b . y - line1 . a . y ; double bottom = math . sqrt ( dx0 * dx0 + dy0 * dy0 ) * math . sqrt ( dx1 * dx1 + dy1 * dy1 ) ; return math . acos ( ( dx0 * dx1 + dy0 * dy1 ) / bottom ) ; }	Computes the acute angle between the two lines. Does not check for intersection.
public static boolean is infinite h ( d p , double tol ) { double n = math . sqrt ( p . x * p . x + p . y * p . y + p . z * p . z ) ; return math . abs ( p . w ) <= n * tol ; }	Checks to see if the homogenous 3D point lies on the plane at infinity.
public static list < d > random n ( d center , double w , double stdev , int num , random rand ) { list < d > ret = new array list < > ( ) ; for ( int i = num ; i < num ; i ++ ) { d p = new d ( ) ; p . x = center . x + rand . next gaussian ( ) * stdev ; p . y = center . y + rand . next gaussian ( ) * stdev ; p . z = center . z + rand . next gaussian ( ) * stdev ; p . w = w ; ret . add ( p ) ; } return ret ; }	Normally distributed homogenous 3D point. w is fixed.
public static d h to e ( d p ) { d out = new d ( ) ; h to e ( p , out ) ; return out ; }	Converts a point from homogenous coordinates into Euclidean.
public static d minus ( d a , d b , d output ) { if ( output == null ) output = new d ( ) ; output . x = a . x - b . x ; output . y = a . y - b . y ; return output ; }	Sets the vector equal to 'a' - 'b'.
public static boolean identical sign ( double xa , double ya , double xb , double yb , double tol ) { double dx0 = xb - xa ; double dy0 = yb - ya ; double dx1 = xb + xa ; double dy1 = yb + ya ; double error0 = dx0 * dx0 + dy0 * dy0 ; double error1 = dx1 * dx1 + dy1 * dy1 ; if ( error0 < error1 ) { return error0 <= tol * tol ; } else { return error1 <= tol * tol ; } }	Tests to see if the two vectors are identical up to a sign difference.
public void set ( d r ) { this . x0 = r . x0 ; this . y0 = r . y0 ; this . width = r . width ; this . height = r . height ; }	Sets this rectangle to be equal to the passed in rectangle.
public static ellipse quadratic f64 convert ( ellipse rotated f64 input , ellipse quadratic f64 output ) { if ( output == null ) output = new ellipse quadratic f64 ( ) ; double x0 = input . center . x ; double y0 = input . center . y ; double a = input . a ; double b = input . b ; double phi = input . phi ; double cphi = math . cos ( phi ) ; double sphi = math . sin ( phi ) ; double cphi2 = cphi * cphi ; double sphi2 = sphi * sphi ; double a2 = a * a ; double b2 = b * b ; double x02 = x0 * x0 ; double y02 = y0 * y0 ;	Convert from rotated to quadratic.
public static d compute point ( double t , ellipse rotated f64 ellipse , d output ) { if ( output == null ) output = new d ( ) ; double ct = math . cos ( t ) ; double st = math . sin ( t ) ; double cphi = math . cos ( ellipse . phi ) ; double sphi = math . sin ( ellipse . phi ) ;	Computes the point on the ellipse at location 't', where t is an angle in radians.
public static double compute angle ( d p , ellipse rotated f64 ellipse ) {	Computes the value of 't' used to specify a point's location.
public static d compute tangent ( double t , ellipse rotated f64 ellipse , d output ) { if ( output == null ) output = new d ( ) ; double ct = math . cos ( t ) ; double st = math . sin ( t ) ; double cphi = math . cos ( ellipse . phi ) ; double sphi = math . sin ( ellipse . phi ) ;	Computes the tangent to the ellipse at the specified location.
boolean select tangent ( d a , d previous tangent , ellipse rotated f64 ellipse , d tangent , boolean cross ) { if ( ! tangent lines ( a , ellipse , temp0 , temp1 ) ) return bool ; temp line . a = a ; temp line . b = temp0 ; boolean crossed0 = d . intersection ( center line , temp line , junk ) != null ; temp line . b = temp1 ; boolean crossed1 = d . intersection ( center line , temp line , junk ) != null ; if ( crossed0 == crossed1 ) throw new runtime exception ( str ) ; if ( cross == crossed0 ) { sum difference += previous tangent . distance2 ( temp0 ) ; tangent . set ( temp0 ) ; } else { sum difference += previous tangent . distance2 ( temp1 ) ; tangent . set ( temp1 ) ; } return bool ; }	Selects a tangent point on the ellipse which is closest to the original source point of A.
public d get corner ( int index , d corner ) { if ( corner == null ) corner = new d ( ) ; corner . set ( p ) ; if ( ( index & num ) != num ) { corner . x += length x ; } if ( ( index & num ) != num ) { corner . y += length y ; } if ( ( index & num ) != num ) { corner . z += length z ; } return corner ; }	Used to retrieve the corners of the box.
public static double distance ( d l0 , d l1 ) { double x = l0 . p . x - l1 . p . x ; double y = l0 . p . y - l1 . p . y ; double z = l0 . p . z - l1 . p . z ;	Distance of the closest point between two lines.
public static double distance ( d l , d p ) { double x = l . p . x - p . x ; double y = l . p . y - p . y ; double z = l . p . z - p . z ; double cc = x * x + y * y + z * z ;	Distance from the point to the closest point on the line.
public static double distance ( d l , d p ) { double dx = p . x - l . a . x ; double dy = p . y - l . a . y ; double dz = p . z - l . a . z ; double cc = dx * dx + dy * dy + dz * dz ; double slope x = l . b . x - l . a . x ; double slope y = l . b . y - l . a . y ; double slope z = l . b . z - l . a . z ; double n = ( double ) math . sqrt ( slope x * slope x + slope y * slope y + slope z * slope z ) ; double d = ( slope x * dx + slope y * dy + slope z * dz ) / n ;	Distance from the point to the closest point on the line segment.
public static double distance ( d plane , d point ) { double top = plane . a * point . x + plane . b * point . y + plane . c * point . z - plane . d ; return top / math . sqrt ( plane . a * plane . a + plane . b * plane . b + plane . c * plane . c ) ; }	Distance between a plane and a point.
public static double distance ( d cylinder , d point ) { double r = d . distance ( cylinder . line , point ) ; return r - cylinder . radius ; }	Returns the signed distance a point is from the cylinder's surface.
public static double distance ( d segment a , d segment b ) { return math . sqrt ( distance sq ( segment a , segment b ) ) ; }	Finds the distance between the two line segments.
public static double distance sq ( d segment a , d segment b ) {	Finds the distance squared between the two line segments.
public static double distance ( quadrilateral f64 quad , d p ) { return math . sqrt ( distance sq ( quad , p ) ) ; }	Returns the Euclidean distance of the closest point on the quadrilateral to the provided point.
public static double distance sq ( quadrilateral f64 quad , d p ) { d seg = d . wrap ( quad . a , quad . b ) ; double a = distance sq ( seg , p ) ; seg . a = quad . b ; seg . b = quad . c ; a = math . min ( a , distance sq ( seg , p ) ) ; seg . a = quad . c ; seg . b = quad . d ; a = math . min ( a , distance sq ( seg , p ) ) ; seg . a = quad . d ; seg . b = quad . a ; return math . min ( a , distance sq ( seg , p ) ) ; }	Returns the Euclidean distance squared of the closest point on the quadrilateral to the provided point.
public static double distance ( d poly , d p ) { return math . sqrt ( distance sq ( poly , p , null ) ) ; }	Returns the Euclidean distance of the closest point on the Polygon to the provided point.
public static double distance sq ( d poly , d p , d storage ) { if ( storage == null ) storage = d . wrap ( null , null ) ; double minimum = double . max value ; for ( int i = num ; i < poly . size ( ) ; i ++ ) { int j = ( i + num ) % poly . size ( ) ; storage . a = poly . vertexes . data [ i ] ; storage . b = poly . vertexes . data [ j ] ; double d = distance sq ( storage , p ) ; if ( d < minimum ) minimum = d ; } return minimum ; }	Returns the Euclidean distance squared of the closest point on the Polygon to the provided point.
public static double distance origin ( d line ) { double top = line . slope . y * line . p . x - line . slope . x * line . p . y ; return math . abs ( top ) / line . slope . norm ( ) ; }	Returns the distance of the closest point on the line from the origin.
public static double distance ( ellipse rotated f64 ellipse , d p ) { return math . sqrt ( distance2 ( ellipse , p ) ) ; }	Euclidean distance of closest point on ellipse to point 'p'.
public static double distance2 ( ellipse rotated f64 ellipse , d p ) {	Euclidean distance squared of closest point on ellipse to point 'p'.
public void add transform ( boolean forward , t tran ) { path . add ( new node < t > ( tran , forward ) ) ; }	Adds the next transform in the sequence.
public static d closest point ( d line , d p , d output ) { if ( output == null ) output = new d ( ) ; double slope x = line . b . x - line . a . x ; double slope y = line . b . y - line . a . y ; double t = slope x * ( p . x - line . a . x ) + slope y * ( p . y - line . a . y ) ; t /= slope x * slope x + slope y * slope y ; if ( t < num ) t = num ; else if ( t > num ) t = num ; output . x = line . a . x + slope x * t ; output . y = line . a . y + slope y * t ; return output ; }	Finds the closest point on the line segment to the provided point 'p'.
public static d closest point ( ellipse rotated f64 ellipse , d p ) { closest point ellipse angle f64 alg = new closest point ellipse angle f64 ( grl constants . test , num ) ; alg . set ellipse ( ellipse ) ; alg . process ( p ) ; return alg . get closest ( ) ; }	Computes the closest point on an ellipse to the provided point.
public boolean process ( double [ ] data , int offset , int length , polynomial curve f64 output ) { int n = length / num ; int num coefs = output . size ( ) ; a . reshape ( n , num coefs ) ; b . reshape ( n , num ) ; x . reshape ( num coefs , num ) ; int end = offset + length ; for ( int i = offset , idx a = num ; i < end ; i += num ) { double x = data [ i ] ; double y = data [ i + num ] ; double pow = num ; for ( int j = num ; j < num coefs ; j ++ ) { a . data [ idx a ++ ] = pow ; pow *= x ; } b . data [ i / num ] = y ; } if ( ! solver . set a ( a ) ) return bool ; solver . solve ( b , x ) ; for ( int i = num ; i < num coefs ; i ++ ) { output . set ( i , x . data [ i ] ) ; } return bool ; }	Fits the polynomial curve to the data.
public static d create random ( double min , double max , random rand ) { double range = max - min ; d a = new d ( ) ; a . x = range * rand . next double ( ) + min ; a . y = range * rand . next double ( ) + min ; a . z = range * rand . next double ( ) + min ; return a ; }	Creates a random vector where each axis is selected from a uniform distribution.
public static d perpendicular canonical ( d a , d output ) { if ( output == null ) output = new d ( ) ;	Selects a vector which will be perpendicular.
public static boolean is identical ( d a , d b , double tol ) { if ( math . abs ( a . x - b . x ) > tol ) return bool ; if ( math . abs ( a . y - b . y ) > tol ) return bool ; return math . abs ( a . z - b . z ) <= tol ; }	Checks to see if the two vectors are identical to within tolerance.
public static void normalize ( d v ) { double a = v . norm ( ) ; v . x /= a ; v . y /= a ; v . z /= a ; }	Rescales the vector such that its normal is equal to one.
public static d r create matrix ( d r r , d ... v ) { if ( r == null ) { r = new d r ( num , v . length ) ; } for ( int i = num ; i < v . length ; i ++ ) { r . set ( num , i , v [ i ] . x ) ; r . set ( num , i , v [ i ] . y ) ; r . set ( num , i , v [ i ] . z ) ; } return r ; }	Creates a matrix from the set of column vectors.
public static d convert ( d r m ) { d v = new d ( ) ; v . x = ( double ) m . data [ num ] ; v . y = ( double ) m . data [ num ] ; v . z = ( double ) m . data [ num ] ; return v ; }	Converts matrices into vectors.
public double distance ( double x , double y ) { double dx = x - this . x ; double dy = y - this . y ; return math . sqrt ( dx * dx + dy * dy ) ; }	Euclidean distance from the point.
public void set ellipse ( ellipse rotated f64 ellipse ) { this . ellipse = ellipse ; ce = math . cos ( ellipse . phi ) ; se = math . sin ( ellipse . phi ) ; }	Specifies the ellipse which point distance is going to be found from.
public void normalize ( ) { double n = math . sqrt ( w * w + x * x + y * y + z * z ) ; w /= n ; x /= n ; y /= n ; z /= n ; }	Converts the quaternion into a unit quaternion.
public static double triangle ( d a , d b , d c ) { double inner = a . x * ( b . y - c . y ) + b . x * ( c . y - a . y ) + c . x * ( a . y - b . y ) ; return math . abs ( inner / num ) ; }	Computes the area of an arbitrary triangle from 3-vertices.area = | a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y) | / 2.
public static double quadrilateral ( quadrilateral f64 quad ) { double bx = quad . b . x - quad . a . x ; double by = quad . b . y - quad . a . y ; double cx = quad . c . x - quad . a . x ; double cy = quad . c . y - quad . a . y ; double dx = quad . d . x - quad . a . x ; double dy = quad . d . y - quad . a . y ; if ( ( bx * cy - by * cx >= num ) == ( cx * dy - cy * dx >= num ) ) { return triangle ( quad . a , quad . b , quad . c ) + triangle ( quad . a , quad . c , quad . d ) ; } else { return triangle ( quad . a , quad . b , quad . d ) + triangle ( quad . b , quad . c , quad . d ) ; } }	Area of a quadrilateral computed from two triangles.
public static double polygon simple ( d poly ) { double total = num ; d v0 = poly . get ( num ) ; d v1 = poly . get ( num ) ; for ( int i = num ; i < poly . size ( ) ; i ++ ) { d v2 = poly . get ( i ) ; total += v1 . x * ( v2 . y - v0 . y ) ; v0 = v1 ; v1 = v2 ; } d v2 = poly . get ( num ) ; total += v1 . x * ( v2 . y - v0 . y ) ; v0 = v1 ; v1 = v2 ; v2 = poly . get ( num ) ; total += v1 . x * ( v2 . y - v0 . y ) ; return math . abs ( total / num ) ; }	Area of a simple polygon. Meaning it can be concave or convex, but can't have self intersections.
public static d mean ( d [ ] list , int offset , int length , d mean ) { if ( mean == null ) mean = new d ( ) ; double x = num ; double y = num ; for ( int i = num ; i < length ; i ++ ) { d p = list [ offset + i ] ; x += p . get x ( ) ; y += p . get y ( ) ; } x /= length ; y /= length ; mean . set ( x , y ) ; return mean ; }	Finds the point which has the mean location of all the points in the array.
public static list < d > order ccw ( list < d > points ) { d center = mean ( points , null ) ; double angles [ ] = new double [ points . size ( ) ] ; for ( int i = num ; i < angles . length ; i ++ ) { d p = points . get ( i ) ; double dx = p . x - center . x ; double dy = p . y - center . y ; angles [ i ] = math . atan2 ( dy , dx ) ; } int order [ ] = new int [ points . size ( ) ] ; quick sort f64 sorter = new quick sort f64 ( ) ; sorter . sort ( angles , num , points . size ( ) , order ) ; list < d > out = new array list < d > ( points . size ( ) ) ; for ( int i = num ; i < points . size ( ) ; i ++ ) { out . add ( points . get ( order [ i ] ) ) ; } return out ; }	Puts the points into counter-clockwise order around their center.
public static void compute normal ( list < d > points , d mean , d covariance ) { if ( covariance . get num cols ( ) != num || covariance . get num rows ( ) != num ) { if ( covariance instanceof reshape matrix ) { ( ( reshape matrix ) covariance ) . reshape ( num , num ) ; } else { throw new illegal argument exception ( str ) ; } } mean ( points , mean ) ; double xx = num , xy = num , yy = num ; for ( int i = num ; i < points . size ( ) ; i ++ ) { d p = points . get ( i ) ; double dx = p . x - mean . x ; double dy = p . y - mean . y ; xx += dx * dx ; xy += dx * dy ; yy += dy * dy ; } xx /= points . size ( ) ; xy /= points . size ( ) ; yy /= points . size ( ) ; covariance . unsafe set ( num , num , xx ) ; covariance . unsafe set ( num , num , xy ) ; covariance . unsafe set ( num , num , xy ) ; covariance . unsafe set ( num , num , yy ) ; }	Computes the mean and covariance matrix from the set of points. This describes a normal distribution.
public static boolean is convex ( d poly ) {	Determines if the polugon is convex or concave.
public void times ip ( double scalar ) { x *= scalar ; y *= scalar ; z *= scalar ; w *= scalar ; }	In-place scalar multiplication.
public double max abs ( ) { double abs x = math . abs ( x ) ; double abs y = math . abs ( y ) ; double abs z = math . abs ( z ) ; double abs w = math . abs ( w ) ; double found = math . max ( abs x , abs y ) ; if ( found < abs z ) found = abs z ; if ( found < abs w ) found = abs w ; return found ; }	Returns the absolute value of the component with the largest absolute value.
public static double distance ( double x0 , double y0 , double z0 , double x1 , double y1 , double z1 ) { return norm ( x1 - x0 , y1 - y0 , z1 - z0 ) ; }	Euclidean distance between the two specified points.
public static double distance sq ( double x0 , double y0 , double z0 , double x1 , double y1 , double z1 ) { double dx = x1 - x0 ; double dy = y1 - y0 ; double dz = z1 - z0 ; return dx * dx + dy * dy + dz * dz ; }	Euclidean distance squared between the two specified points.
public static list < d > random ( d plane , double max , int num , random rand ) { list < d > ret = new array list < > ( ) ; d axis x = new d ( ) ; d axis y = new d ( ) ; d . select axis2 d ( plane . n , axis x , axis y ) ; for ( int i = num ; i < num ; i ++ ) { double x = num * max * ( rand . next double ( ) - num ) ; double y = num * max * ( rand . next double ( ) - num ) ; d p = new d ( ) ; p . x = plane . p . x + axis x . x * x + axis y . x * y ; p . y = plane . p . y + axis x . y * x + axis y . y * y ; p . z = plane . p . z + axis x . z * x + axis y . z * y ; ret . add ( p ) ; } return ret ; }	Randomly generates a set of points on the plane centered at the plane's originusing a uniform distribution.
public static list < d > random ( d mean , double min x , double max x , double min y , double max y , double min z , double max z , int num , random rand ) { list < d > ret = new array list < > ( ) ; for ( int i = num ; i < num ; i ++ ) { d p = new d ( ) ; p . x = mean . x + rand . next double ( ) * ( max x - min x ) + min x ; p . y = mean . y + rand . next double ( ) * ( max y - min y ) + min y ; p . z = mean . z + rand . next double ( ) * ( max z - min z ) + min z ; ret . add ( p ) ; } return ret ; }	Creates a list of random points from a uniform distribution along each axis.
public static list < d > random n ( d mean , double std x , double std y , double std z , int num , random rand ) { list < d > ret = new array list < > ( ) ; for ( int i = num ; i < num ; i ++ ) { d p = new d ( ) ; p . x = mean . x + rand . next gaussian ( ) * std x ; p . y = mean . y + rand . next gaussian ( ) * std y ; p . z = mean . z + rand . next gaussian ( ) * std z ; ret . add ( p ) ; } return ret ; }	Creates a list of random points from a normal distribution along each axis.
public static d mean ( list < d > points , d mean ) { if ( mean == null ) mean = new d ( ) ; double x = num , y = num , z = num ; for ( d p : points ) { x += p . x ; y += p . y ; z += p . z ; } mean . x = x / points . size ( ) ; mean . y = y / points . size ( ) ; mean . z = z / points . size ( ) ; return mean ; }	Computes the mean of the list of points.
public static d mean ( list < d > points , int num , d mean ) { if ( mean == null ) mean = new d ( ) ; double x = num , y = num , z = num ; for ( int i = num ; i < num ; i ++ ) { d p = points . get ( i ) ; x += p . x ; y += p . y ; z += p . z ; } mean . x = x / num ; mean . y = y / num ; mean . z = z / num ; return mean ; }	Computes the mean of the list of points up to element num.
public void invalidate all ( iterable < jwt context > credentials ) { credentials . for each ( context -> cache . invalidate ( context . get jwt ( ) ) ) ; }	Discards any cached principal for the given collection of credentials.
public void invalidate all ( predicate < ? super jwt context > predicate ) { cache . as map ( ) . entry set ( ) . stream ( ) . map ( entry -> entry . get value ( ) . get key ( ) ) . filter ( predicate :: test ) . map ( jwt context :: get jwt ) . for each ( cache :: invalidate ) ; }	Discards any cached principal for the collection of credentials satisfying the given predicate.
@ safe varargs public static set < string > combine to set ( collection < string > ... collections ) { set < string > result = new hash set < string > ( ) ; set < string > lowercase set = new hash set < string > ( ) ; for ( collection < string > collection : collections ) { if ( collection != null ) { for ( string value : collection ) { if ( ! lowercase set . contains ( value . to lower case ( ) ) ) { lowercase set . add ( value . to lower case ( ) ) ; result . add ( value ) ; } } } } return result ; }	Combine the given String collections into a set using case-insensitive matching.If there are multiple instances of the same string but with different capitalization,only the first one found will be included.
public set < string > get server features ( file server directory ) { set < string > result = get config dropins features ( null , server directory , str ) ; result = get server xml features ( result , new file ( server directory , str ) , null ) ;	Get the set of features defined in the server.xml.
private set < string > get config dropins features ( set < string > orig result , file server directory , string folder name ) { set < string > result = orig result ; file config dropins folder ; try { config dropins folder = new file ( new file ( server directory , str ) , folder name ) . get canonical file ( ) ; } catch ( io e ) {	Gets features from the configDropins's defaults or overrides directory.
private set < string > get server xml features ( set < string > orig result , file server file , list < file > parsed xmls ) { set < string > result = orig result ; list < file > updated parsed xmls = parsed xmls != null ? parsed xmls : new array list < file > ( ) ; file canonical server file ; try { canonical server file = server file . get canonical file ( ) ; } catch ( io e ) {	Adds features from the given server file into the origResult or a new setif origResult is null.
private set < string > parse include node ( set < string > orig result , file server file , element node , list < file > updated parsed xmls ) { set < string > result = orig result ; string include file name = node . get attribute ( str ) ; if ( include file name == null || include file name . trim ( ) . is empty ( ) ) { return result ; } file include file = null ; if ( is url ( include file name ) ) { try { file temp file = file . create temp file ( str , str ) ; file utils . copy url ( new url ( include file name ) , temp file , copy file timeout millis , copy file timeout millis ) ; include file = temp file ; } catch ( io e ) {	Parse features from an include node.
private static set < string > parse feature manager node ( element node ) { set < string > result = new hash set < string > ( ) ; node list features = node . get elements by tag name ( str ) ; if ( features != null ) { for ( int j = num ; j < features . get length ( ) ; j ++ ) { string content = features . item ( j ) . get text content ( ) ; if ( content != null ) { if ( content . contains ( str ) ) { string [ ] split = content . split ( str , num ) ; result . add ( split [ num ] . trim ( ) . to lower case ( ) ) ; } else { result . add ( content . trim ( ) . to lower case ( ) ) ; } } } } return result ; }	Parse feature elements from a featureManager node, trimming whitespaceand treating everything as lowercase.
private file download jsons ( string product id , string product version ) { string json group id = product id + str ; try { return download artifact ( json group id , str , str , product version ) ; } catch ( plugin execution exception e ) { debug ( str + product id + str + product version , e ) ; return null ; } }	Download the JSON file for the given product.
public static set < string > get open liberty feature set ( set < file > jsons ) throws plugin execution exception { set < string > liberty features = new hash set < string > ( ) ; for ( file file : jsons ) { scanner s = null ; try { s = new scanner ( file ) ;	Gets the set of all Open Liberty features by scanning the product JSONs.
private boolean is only open liberty features ( list < string > features to install ) throws plugin execution exception { boolean result = contains ignore case ( get open liberty feature set ( downloaded jsons ) , features to install ) ; debug ( str + result ) ; return result ; }	Returns true if all features in featuresToInstall are Open Liberty features.
public static boolean contains ignore case ( collection < string > reference , collection < string > target ) { return to lower case ( reference ) . contains all ( to lower case ( target ) ) ; }	Returns whether the reference collection contains all of the strings in the target collection, ignoring case.
public static string get next product version ( string version ) throws plugin execution exception { string result = null ; int version splitting index = version . last index of ( str ) + num ; if ( version splitting index == num ) { throw new plugin execution exception ( str + version + str ) ; } string quarter version = version . substring ( version splitting index ) ; int next quarter specifier ; try { next quarter specifier = integer . parse int ( quarter version ) + num ; } catch ( number format exception e ) { throw new plugin execution exception ( str + version + str , e ) ; } result = version . substring ( num , version splitting index ) + next quarter specifier ; return result ; }	Gets the next product version number.
public static string extract symbolic name ( file jar ) throws plugin execution exception { jar file jar file = null ; try { jar file = new jar file ( jar ) ; return jar file . get manifest ( ) . get main attributes ( ) . get value ( str ) ; } catch ( io e ) { throw new plugin execution exception ( str + jar . get absolute path ( ) , e ) ; } finally { if ( jar file != null ) { try { jar file . close ( ) ; } catch ( io e ) {	Extracts the bundle symbolic name from the jar manifest.
public static file get map based install kernel jar ( file dir ) { file [ ] install map jars = dir . list files ( new filename filter ( ) { @ override public boolean accept ( file dir , string name ) { return name . starts with ( install map prefix ) && name . ends with ( install map suffix ) ; } } ) ; file result = null ; if ( install map jars != null ) { for ( file jar : install map jars ) { if ( is replacement jar ( result , jar ) ) { result = jar ; } } } return result ; }	Find latest install map jar from specified directory.
private static boolean is replacement jar ( file file1 , file file2 ) { if ( file1 == null ) { return bool ; } else if ( file2 == null ) { return bool ; } else { string version1 = extract version ( file1 . get name ( ) ) ; string version2 = extract version ( file2 . get name ( ) ) ; return compare ( version1 , version2 ) < num ; } }	Returns whether file2 can replace file1 as the install map jar.
private static string extract version ( string file name ) { int start index = install map prefix . length ( ) + num ;	Returns the extracted version from fileName.
private static int compare ( string version1 , string version2 ) { if ( version1 == null && version2 == null ) { return num ; } else if ( version1 == null && version2 != null ) { return - num ; } else if ( version1 != null && version2 == null ) { return num ; } string [ ] components1 = version1 . split ( str ) ; string [ ] components2 = version2 . split ( str ) ; for ( int i = num ; i < components1 . length && i < components2 . length ; i ++ ) { int comparison ; try { comparison = new integer ( components1 [ i ] ) . compare to ( new integer ( components2 [ i ] ) ) ; } catch ( number format exception e ) { comparison = components1 [ i ] . compare to ( components2 [ i ] ) ; } if ( comparison != num ) { return comparison ; } } return components1 . length - components2 . length ; }	Performs pairwise comparison of version strings, including nulls and non-integer components.
public static string product info ( file install directory , string action ) throws plugin execution exception { process pr = null ; input stream is = null ; scanner s = null ; worker worker = null ; try { string command ; if ( os . is windows ( ) ) { command = install directory + str + action ; } else { command = install directory + str + action ; } pr = runtime . get runtime ( ) . exec ( command ) ; worker = new worker ( pr ) ; worker . start ( ) ; worker . join ( num ) ; if ( worker . exit == null ) { throw new plugin execution exception ( str ) ; } int exit value = pr . exit value ( ) ; if ( exit value != num ) { throw new plugin execution exception ( str + exit value ) ; } is = pr . get input stream ( ) ; s = new scanner ( is ) ;	Runs the productInfo command and returns the output.
public static boolean is spring boot uber jar ( file artifact ) { if ( artifact == null || ! artifact . exists ( ) || ! artifact . is file ( ) ) { return bool ; } try ( jar file jar file = new jar file ( artifact ) ) { manifest manifest = jar file . get manifest ( ) ; if ( manifest != null ) { attributes attributes = manifest . get main attributes ( ) ; if ( attributes . get value ( boot version attribute ) != null && attributes . get value ( boot start class attribute ) != null ) { return bool ; } else {	Check whether the given artifact is a Spring Boot Uber JAR.
private static i get arquillian property ( string key , class < ? > cls ) throws arquillian configuration exception { try { if ( cls == liberty managed object . liberty managed property . class ) { return liberty managed object . liberty managed property . value of ( key ) ; } else if ( cls == liberty remote object . liberty remote property . class ) { return liberty remote object . liberty remote property . value of ( key ) ; } } catch ( illegal argument exception e ) { throw new arquillian configuration exception ( str + key + str ) ; } throw new arquillian configuration exception ( str ) ; }	Check that the given key exists in ArquillianProperties.
@ override public boolean is working in this environment ( string for file ) { return ! graphics environment . is headless ( ) && generic diff reporter . is file extension valid ( for file , generic diff reporter . image file extensions ) ; }	We assume any environment that is not headless will have a web browser to display the image in a web page.
private static void move back to center ( double length ) { tortoise . set pen up ( ) ; tortoise . turn ( num ) ; tortoise . move ( length / num ) ; tortoise . turn ( num ) ; tortoise . move ( length / num ) ; tortoise . turn ( num ) ; tortoise . set pen down ( ) ;	Create the moveBackToCenter recipe.
public static boolean is equal ( object s1 , object s2 ) { return s1 == s2 || ( s1 != null ) && s1 . equals ( s2 ) ; }	A convenience function to check if two objects are equal.
public static int load ( string i , int default value , boolean strip non numeric ) { try { i = strip non numeric ? string utils . strip non numeric ( i , bool , bool ) : i ; default value = integer . parse int ( i ) ; } catch ( exception ignored ) { } return default value ; }	Loads an int from a String.
private tortoise [ ] throw pizza party ( ) { tortoise karai = new tortoise ( ) ; tortoise cecil = new tortoise ( ) ; tortoise michealangelo = new tortoise ( ) ; tortoise fred = new tortoise ( ) ; return new tortoise [ ] { karai , cecil , michealangelo , fred } ; }	Ignore the following, It's needed to run the deep dive.
public static void verify ( ) { try { approvals . verify ( turtle . get image ( ) ) ; } catch ( exception e ) { throw object utils . throw as error ( e ) ; } finally { tortoise utils . reset turtle ( ) ; } }	Captures an image of the result of your program and displays it to you.
public puzzle swap blank ( int target ) { int [ ] copy = arrays . copy of ( cells , cells . length ) ; int x = copy [ target ] ; copy [ get blank index ( ) ] = x ; copy [ target ] = num ; return new puzzle ( copy ) ; }	Create a copy of the puzzle where the blank swapped with the value in the target position.
public int get distance to goal ( ) { int distance = num ; for ( int i = num ; i < cells . length ; i ++ ) { distance += get distance ( i , cells [ i ] ) ; } return distance ; }	Calculate the distance between the goal by summing the distance between each cell and its goal.
public static void printf ( string format , object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }	Prints a formatted string to standard output, using the specified formatstring and arguments, and then flushes standard output.
public static void printf ( locale locale , string format , object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }	Prints a formatted string to standard output, using the locale andthe specified format string and arguments; then flushes standard output.
public static void make a ( int number of fish ) {	recipe for makeAFishyDecision with the numberOfFish.
public synchronized static void variable ( string name , object value ) { if ( ! variable ) { return ; } system . out . println ( time stamp ( ) + str + name + str + ( value == null ? null : value . to string ( ) ) + str ) ; }	Prints to screen any variable information to be viewed.
public static int uniform ( int a , int b ) { if ( b <= a ) throw new illegal argument exception ( str ) ; if ( ( long ) b - a >= integer . max value ) throw new illegal argument exception ( str ) ; return a + uniform ( b - a ) ; }	Returns a random integer uniformly in [a, b).
public static double uniform ( double a , double b ) { if ( ! ( a < b ) ) throw new illegal argument exception ( str ) ; return a + uniform ( ) * ( b - a ) ; }	Returns a random real number uniformly in [a, b).
public static int poisson ( double lambda ) { if ( ! ( lambda > num ) ) throw new illegal argument exception ( str ) ; if ( double . is infinite ( lambda ) ) throw new illegal argument exception ( str ) ;	Returns a random integer from a Poisson distribution with mean &lambda;.
public static int discrete ( double [ ] a ) { if ( a == null ) throw new null pointer exception ( str ) ; double epsilon = num ; double sum = num ; for ( int i = num ; i < a . length ; i ++ ) { if ( ! ( a [ i ] >= num ) ) throw new illegal argument exception ( str + i + str + a [ i ] ) ; sum = sum + a [ i ] ; } if ( sum > num + epsilon || sum < num - epsilon ) throw new illegal argument exception ( str + sum ) ;	Returns a random integer from the specified discrete distribution.
public static final string capitalize first char ( string word ) { return character . to upper case ( word . char at ( num ) ) + word . substring ( num ) ; }	Capitalizes the first character of the word given.It will convert i to I.
public static final string un capitalize first char ( string word ) { return character . to lower case ( word . char at ( num ) ) + word . substring ( num ) ; }	Un capitalizes the first character of the word given.It will convert i to I.
private string fix path ( string path ) { if ( ! path . is empty ( ) ) { if ( ! path . ends with ( str ) ) return path + str ; else return path ; } else return path ; }	Helps to fix path.
public static string join to string ( criteria join criteria join ) { string builder builder = new string builder ( str ) . append ( criteria join . get entity class ( ) . get name ( ) ) . append ( str ) . append ( criteria join . get alias ( ) ) . append ( str ) . append ( str ) ; if ( criteria join . get join relations ( ) . size ( ) == num ) { throw new runtime exception ( str + criteria join . get alias ( ) + str ) ; } string joiner joiner = new string joiner ( str ) ; list < join relation > relation list = criteria join . get join relations ( ) ; for ( join relation join relation : relation list ) { string builder relation builder = new string builder ( str ) . append ( join relation . get relation criteria ( ) . get alias ( ) ) . append ( str ) . append ( join relation . get relation field ( ) ) . append ( str ) . append ( join relation . get joined criteria ( ) . get alias ( ) ) . append ( str ) . append ( join relation . get joined field ( ) ) ; joiner . add ( relation builder . to string ( ) ) ; } if ( joiner . length ( ) > num ) { builder . append ( joiner . to string ( ) ) ; } return builder . to string ( ) ; }	Generates Join Query for the given JoinCriteria.
public static string get token sentence ( basic token token ) throws exception { if ( token == null ) return token key + str + cookie sentence ; string sentence = token key + str + token . get token string ( ) + cookie sentence ;	Combines the token and cookie sentence.
@ override public void filter ( container request context request context , container response context response context ) throws io { string auth token = extract auth token from cookie list ( request context . get headers ( ) . get first ( str ) ) ; if ( auth token != null && auth token . length ( ) != num ) { try { basic token token = new basic token ( auth token ) ; if ( token . is expired ( ) ) { logger . debug ( str + token . get expiration date ( ) . to string ( ) ) ; logger . debug ( str + date time . now ( ) . to date ( ) . to string ( ) ) ; response context . get headers ( ) . put single ( str , get token sentence ( null ) ) ; response context . set status info ( response . status . unauthorized ) ; response context . set entity ( str ) ; logger . info ( str ) ; } else { token . set expiration ( token . get max age ( ) ) ; if ( ! logout path . equals ( request context . get uri info ( ) . get path ( ) ) ) { string cookie = get token sentence ( token ) ; response context . get headers ( ) . put single ( str , cookie ) ; } } } catch ( exception e ) { logger . error ( str , e . get message ( ) ) ; response context . set status info ( response . status . unauthorized ) ; } } }	Checks the expiration date of token.Renews and puts at header of response.
private string extract auth token from cookie list ( string cookie list ) { if ( cookie list == null || cookie list . length ( ) == num ) { return null ; } string [ ] cookies = cookie list . split ( str ) ; for ( string cookie : cookies ) { if ( cookie . trim ( ) . starts with ( token key ) ) { return cookie . trim ( ) . substring ( token key . length ( ) + num ) ; } } return null ; }	Extracts the accesstoken from cookies.
public static void register guice bound ( injector injector , final jersey environment environment ) { while ( injector != null ) { for ( key < ? > key : injector . get bindings ( ) . key set ( ) ) { type type = key . get type literal ( ) . get type ( ) ; if ( type instanceof class ) { class < ? > c = ( class ) type ; if ( is provider class ( c ) ) { logger . info ( str , c . get name ( ) ) ; environment . register ( c ) ; } else if ( is root resource class ( c ) ) {	Registers any Guice-bound providers or root resources.
private void get all role permissions ( role entry parent , set < permission entry > role permissions ) { role permissions . add all ( permission store . find by role id ( parent . get id ( ) ) ) ; set < role group entry > role group entries = ( set < role group entry > ) role group store . find by group id ( parent . get id ( ) ) ; for ( role group entry entry : role group entries ) { optional < role entry > role = ( optional < role entry > ) role store . find by role id ( entry . get role id ( ) ) ; get all role permissions ( role . get ( ) , role permissions ) ; } }	Fill permission list with role and sub-role permissions recursively.
public projection list add ( projection projection , string alias ) { return add ( projections . alias ( projection , alias ) ) ; }	Adds a projection to this list of projections after wrapping it with an alias.
public static job detail convert2 job detail ( job info info ) { job key job key = job key . job key ( info . get name ( ) ) ; job detail job detail = new job ( info . get job class ( ) ) . with identity ( job key ) . build ( ) ; return job detail ; }	Creates an identical JobDetail instance from the given parameters.
public static trigger convert2 trigger ( trigger info trig , job info job ) { trigger builder < trigger > builder = new trigger ( ) ; builder . with identity ( trig . get name ( ) , trig . get group ( ) ) ; builder . for job ( job . get name ( ) , job . get group ( ) ) ; switch ( trig . get type ( ) ) { case cron : set start end time ( trig , builder ) ; if ( ! trig . get cron ( ) . is empty ( ) ) builder . with schedule ( cron schedule builder . cron schedule ( trig . get cron ( ) ) ) ; break ; case simple : set start end time ( trig , builder ) ; set count interval values ( trig , builder ) ; break ; } return builder . build ( ) ; }	Creates an identical Trigger instance from the given annotation.
private static void set count interval values ( trigger info dto , trigger builder < org . quartz . trigger > builder ) { simple schedule builder builder sc = simple schedule builder . simple schedule ( ) ; if ( dto . get repeat count ( ) != num ) builder sc . with repeat count ( dto . get repeat count ( ) ) ; if ( dto . get repeat interval ( ) > num ) builder sc . with interval in milliseconds ( dto . get repeat interval ( ) ) ; builder . with schedule ( builder sc ) ; }	Helps to set count and intervals.
private static void set start end time ( trigger info dto , trigger builder < org . quartz . trigger > builder ) { if ( dto . get start time ( ) > - num ) builder . start at ( new date ( dto . get start time ( ) ) ) ; else builder . start now ( ) ; if ( dto . get end time ( ) > - num ) builder . end at ( new date ( dto . get end time ( ) ) ) ; }	Helps to set start and end times.
public static boolean send mail ( mail item item ) { logger . debug ( str + item . to string ( ) ) ; boolean result = queue . add ( item ) ; logger . info ( str + queue . size ( ) ) ;	Takes the mail item into the queue and manages the mail sender thread.If thread is alive it will send the mail at the end of current thread queue.Else a new thread will be created and started.
@ override public void write ( output stream output ) throws io , web application exception {	Called to write the message body.
private void initialize scheduler ( properties properties ) throws scheduler exception { scheduler factory factory = new std scheduler factory ( properties ) ; scheduler scheduler = factory . get scheduler ( ) ; scheduler . start ( ) ; job manager . initialize ( scheduler ) ; }	Initialize scheduler and start JobManager.
protected final collection < field entry > get fields ( class clazz ) { linked list < field entry > field list = get all fields ( clazz ) ; collections . sort ( field list , new comparator < field entry > ( ) { public int compare ( field entry o1 , field entry o2 ) { return o1 . compare to ( o2 ) ; } } ) ; return field list ; }	Returns an ordered list of the fields which belongs to the given class.
protected final map < string , field > get field map ( class clazz ) { map < string , field > field list = new hash map < string , field > ( ) ; for ( field entry entry : get all fields ( clazz ) ) { field field = entry . get value ( ) ; field list . put ( field . get name ( ) , field ) ; } return field list ; }	Returns a map of the fields which belongs to the given class with field name as key.
public static void configure ( token based auth configuration configuration ) { encryptor . set pool size ( configuration . get pool size ( ) ) ;	Configure method for Token generation configurations and encryptor configure.
private void generate attributes hash ( map < string , string > attributes ) { string builder attr = new string builder ( ) ; attr . append ( attributes . get ( str ) ) ;	Generates attribute has with 'userAgent', 'remoteAddr' keys.Combines them and hashes with SHA256 and sets the variable.
private string generate token string ( ) throws exception {	Generates a tokenString with a new expiration date and assigns it.
public void send message ( mail item item ) throws messaging exception { check not null ( item . get receivers ( ) ) ; check not null ( item . get receivers ( ) . get ( num ) ) ; check not null ( item . get title ( ) ) ; check not null ( item . get body ( ) ) ;	Sends a mail with the given item.
public string generate strong password ( t user , string old password ) { string new password ; do { new password = generate strong password ( ) ;	Generate strong password that takes into account the user's information and old password.
public t get user ( string account name ) { optional < t > optional = ( optional < t > ) user store . find by username ( account name ) ; if ( optional . is present ( ) ) { return optional . get ( ) ; } else { return null ; } }	Returns the UserEntry matching the provided accountName.
public string hash password ( string password , string account name ) { return hashing . sha256 ( ) . hash string ( password , charset . for name ( str ) ) . to string ( ) ; }	Returns a string representation of the hashed password, using theaccountName as the salt.
public void verify account name strength ( string account name ) throws authentication exception { matcher matcher = pattern . matcher ( account name ) ; if ( ! matcher . matches ( ) ) { throw new authentication exception ( account name + str ) ; } }	Ensures that the account name passes site-specific complexity requirements, like minimum length.
private void success ( ) { org . hibernate . transaction txn = session . get transaction ( ) ; if ( txn != null && txn . get status ( ) . equals ( transaction status . active ) ) { txn . commit ( ) ; } }	If transaction is present and active then commit.
private void error ( ) { org . hibernate . transaction txn = session . get transaction ( ) ; if ( txn != null && txn . get status ( ) . equals ( transaction status . active ) ) { txn . rollback ( ) ; } }	If transaction is present and active then rollback.
private void start ( ) { try { before ( ) ; transaction wrapper . wrap ( ) ; success ( ) ; } catch ( exception e ) { error ( ) ; if ( exception handler != null ) { exception handler . on exception ( e ) ; } else { throw e ; } } finally { finish ( ) ; } }	Starts the progress.
private boolean is authorized ( basic token token , list < uri template > matched templates , string method ) { string builder path = new string builder ( ) ;	Merges all path patterns and and creates a single string value which will be equal with service methods pathannotation value and HTTP method type.
@ override public date parse ( object o , field field ) { if ( ! is valid ( o ) ) { return null ; } json format format ann = field . get annotation ( json format . class ) ; if ( format ann == null ) { throw new runtime exception ( str + field . get name ( ) ) ; } try { return new simple date format ( format ann . pattern ( ) , locale . get default ( ) ) . parse ( o . to string ( ) ) ; } catch ( parse exception e ) { throw new runtime exception ( str + field . get name ( ) + str + format ann . pattern ( ) ) ; } }	First it checks is there any annotation class for parsing operations,if it is, parses with given format, if there is a exception whileparsing with given format catches and tries with default values,If there is no given format, tries with static values.
public response get response ( ) { return response . status ( response . status . internal server error ) . entity ( builder . build ( ) ) . build ( ) ; }	Gets current response created with exception parameters.
public static restriction eq ( string name , object value ) { return new restriction ( operator . equals , name , value ) ; }	generates '=' equals.
public static restriction ne ( string name , object value ) { return new restriction ( operator . not equals , name , value ) ; }	'!=' not equals operator.
public static restriction lt ( string name , object object ) { return new restriction ( operator . less than , name , object ) ; }	'<' less than operator.
public static restriction le ( string name , object value ) { return new restriction ( operator . less or equals than , name , value ) ; }	'<=' less or equals than operator.
public static restriction gt ( string name , object value ) { return new restriction ( operator . greater than , name , value ) ; }	'>' greater than operator.
public static restriction ge ( string name , object value ) { return new restriction ( operator . greater or equals than , name , value ) ; }	'>=' greater or equals than operator.
public static restriction ilike ( string name , object value ) { return new restriction ( operator . contains , name , value ) ; }	'~=' contains than operator.
public static restriction in ( string name , object value ) { return new restriction ( operator . in , name , value ) ; }	'|=' in list operator.
public namespace manager with namespace ( string namespace , string href ) { if ( namespaces . contains key ( namespace ) ) { throw new representation exception ( format ( str , namespace ) ) ; } if ( ! href . contains ( str ) ) { throw new representation exception ( format ( str , namespace ) ) ; } return new namespace manager ( namespaces . put ( namespace , href ) ) ; }	Update the list of declared namespaces with a new namespace.
public resource representation < v > with content ( byte string content ) { return new resource representation < > ( option . of ( content ) , links , rels , namespace manager , value , resources ) ; }	Adds or replaces the content of the representation.
public resource representation < v > with rel ( rel rel ) { if ( rels . contains key ( rel . rel ( ) ) ) { throw new illegal state exception ( string . format ( str , rel . rel ( ) ) ) ; } final tree map < string , rel > updated rels = rels . put ( rel . rel ( ) , rel ) ; return new resource representation < > ( content , links , updated rels , namespace manager , value , resources ) ; }	Define rel semantics for this representation.
public < r > resource representation < r > with value ( r new value ) { return new resource representation < > ( option . none ( ) , links , rels , namespace manager , new value , resources ) ; }	Replace the value of this resource with a new value, optionally of a new type.
public resource representation < v > with namespace ( string namespace , string href ) { if ( ! rels . contains key ( str ) ) { rels = rels . put ( str , rels . collection ( str ) ) ; } final namespace manager updated namespace manager = namespace manager . with namespace ( namespace , href ) ; return new resource representation < > ( content , links , rels , updated namespace manager , value , resources ) ; }	Adds a new namespace.
public static boolean can decode ( byte [ ] input , int off , int len ) { try { decode ( input , off , len ) ; } catch ( illegal argument exception ex ) { return bool ; } return bool ; }	Returns whether the specified range in the given byte array representsvalid UTF-8 encoded characters.
public static byte [ ] encode ( string str , int off , int len ) { return encode ( str . substring ( off , off + len ) ) ; }	Returns the UTF-8 encoding of the specified character sequence.
public static boolean equal ( reader in1 , reader in2 ) throws io { if ( in1 == in2 ) { return bool ; } if ( in1 == null || in2 == null ) { return bool ; } in1 = buffer ( in1 ) ; in2 = buffer ( in2 ) ; int c1 = in1 . read ( ) ; int c2 = in2 . read ( ) ; while ( c1 != - num && c2 != - num && c1 == c2 ) { c1 = in1 . read ( ) ; c2 = in2 . read ( ) ; } return in1 . read ( ) == - num && in2 . read ( ) == - num ; }	Returns whether the given streams have the same content.
public static void mv ( file src , file dst ) throws io { parameters . check not null ( dst ) ; if ( ! src . equals ( dst ) ) { cp ( src , dst ) ; try { rm ( src ) ; } catch ( io e ) { rm ( dst ) ; throw new io ( str + src , e ) ; } } }	Moves a file from one path to another.
public static void touch ( file ... files ) throws io { long now = system . current time millis ( ) ; for ( file f : files ) { if ( ! f . create new file ( ) && ! f . set last modified ( now ) ) { throw new io ( str + f ) ; } } }	Creates empty files at the specified paths or updates the lastmodification time of the files at the specified paths.
public static string get base name ( file f ) { string file name = f . get name ( ) ; int index = file name . last index of ( str ) ; return index == - num ? file name : file name . substring ( num , index ) ; }	Returns the file name without its path or extension.
private void add padding ( ) { int len = block length - buffer len ; if ( len < num ) { len += block length ; } byte [ ] buf = new byte [ len ] ; buf [ num ] = ( byte ) num ; for ( int i = num ; i < len - num ; i ++ ) { buf [ i ] = ( byte ) num ; } counter = ( counter + ( long ) buffer len ) * num ; little endian . encode ( counter , buf , len - num ) ; update ( buf ) ; }	Adds the padding bits and the message length to the input data.
public static string get short name ( class < ? > c ) { string qname = get qualified name ( c ) ; int start = qname . last index of ( str ) ; if ( start == - num ) { start = qname . last index of ( str ) ; } return qname . substring ( start + num ) ; }	Returns only the name of the given class, that is, without itspackage name and without its eventual "outer" class name.
public static set < class < ? > > get super types ( class < ? > c ) { set < class < ? > > classes = new hash set < class < ? > > ( ) ; for ( class < ? > clazz : c . get interfaces ( ) ) { classes . add ( clazz ) ; classes . add all ( get super types ( clazz ) ) ; } class < ? > sup = c . get superclass ( ) ; if ( sup != null ) { classes . add ( sup ) ; classes . add all ( get super types ( sup ) ) ; } return collections . unmodifiable set ( classes ) ; }	Returns all the super types of the given class, that is, all theclasses in which any instance of the given class can be cast into.
public static boolean verify ( string password , byte [ ] hash ) { byte [ ] h = arrays . copy of ( hash , hash length + salt length + num ) ; int n = num << ( h [ hash length + salt length ] & num ) ; int r = h [ hash length + salt length + num ] & num ; int p = h [ hash length + salt length + num ] & num ; if ( n > n || n < n min || r > r || r < r min || p > p || p < p min ) { n = n ; r = r ; p = p ; } byte [ ] salt = new byte [ salt length ] ; system . arraycopy ( h , hash length , salt , num , salt length ) ; byte [ ] expected = hash ( password , salt , r , n , p ) ; int result = num ; for ( int i = num ; i < h . length ; i ++ ) { result |= h [ i ] ^ expected [ i ] ; } return result == num ; }	Verifies that the given password matches the hashed one.
public static string read string ( charset charset ) throws io { reader in = new input stream reader ( system . in , charset ) ; buffered reader reader = new buffered reader ( in ) ; try { return reader . read line ( ) ; } finally { reader . close ( ) ; } }	Reads the next line from the standard input using the given charset.
public byte buffer append ( byte b ) { int new count = count + num ; ensure capacity ( new count ) ; buf [ count ] = b ; count = new count ; return this ; }	Writes the given byte to this buffer.
public byte buffer append ( byte [ ] bytes , int off , int len ) { int new count = count + len ; ensure capacity ( new count ) ; system . arraycopy ( bytes , off , buf , count , len ) ; count = new count ; return this ; }	Writes the given data to this buffer.
public static < t > t [ ] copy of ( t [ ] original ) { return arrays . copy of ( original , original . length ) ; }	Returns a copy of the given array.
public fraction plus ( fraction f ) { return new fraction ( n . multiply ( f . d ) . add ( f . n . multiply ( d ) ) , d . multiply ( f . d ) ) . reduced ( ) ; }	Adds the given value to this one and returns the result in reducedform.
public fraction minus ( fraction f ) { return new fraction ( n . multiply ( f . d ) . subtract ( f . n . multiply ( d ) ) , d . multiply ( f . d ) ) . reduced ( ) ; }	Subtracts the given value from this one and returns the result inreduced form.
public fraction multiplied by ( fraction f ) { return new fraction ( n . multiply ( f . n ) , d . multiply ( f . d ) ) . reduced ( ) ; }	Multiplies this value by the given one and returns the result inreduced form.
public fraction divided by ( fraction f ) { if ( zero . equals ( f ) ) { throw new arithmetic exception ( str ) ; } return new fraction ( n . multiply ( f . d ) , d . multiply ( f . n ) ) . reduced ( ) ; }	Divides this value by the given one and returns the result in reducedform.
public static long max ( long ... values ) { parameters . check condition ( values . length > num ) ; long max = values [ num ] ; for ( int i = num ; i < values . length ; i ++ ) { max = math . max ( max , values [ i ] ) ; } return max ; }	Returns the maximum of the given values.
public static long min ( long ... values ) { parameters . check condition ( values . length > num ) ; long min = values [ num ] ; for ( int i = num ; i < values . length ; i ++ ) { min = math . min ( min , values [ i ] ) ; } return min ; }	Returns the minimum of the given values.
public static void check condition ( boolean condition , string msg , object ... args ) { if ( ! condition ) { throw new illegal argument exception ( format ( msg , args ) ) ; } }	Checks the truth of the given condition checking parameters validity.
public meteo data < location forecast > fetch content ( double longitude , double latitude , int altitude ) throws meteo exception { meteo response response = get meteo client ( ) . fetch content ( create service uri builder ( ) . add parameter ( param latitude , latitude ) . add parameter ( param longitude , longitude ) . add parameter ( param altitude , altitude ) . build ( ) ) ; return new meteo data < > ( parser . parse ( response . get data ( ) ) , response ) ; }	Fetch a LocationforecastLTS from the MET API, based on longitude, latitude and altitude.
public meteo data < sunrise > fetch content ( double longitude , double latitude , local date date ) throws meteo exception { meteo response response = get meteo client ( ) . fetch content ( create service uri builder ( ) . add parameter ( param latitude , latitude ) . add parameter ( param longitude , longitude ) . add parameter ( param date , zoned date time to yyyy m ( date ) ) . build ( ) ) ; return new meteo data < > ( parser . parse ( response . get data ( ) ) , response ) ; }	Fetch a Sunrise from the MET API based on a given longitude, latitude and date.
public meteo data < sunrise > fetch content ( double longitude , double latitude , local date from , local date to ) throws meteo exception { meteo response response = get meteo client ( ) . fetch content ( create service uri builder ( ) . add parameter ( param latitude , latitude ) . add parameter ( param longitude , longitude ) . add parameter ( param from , zoned date time to yyyy m ( from ) ) . add parameter ( param to , zoned date time to yyyy m ( to ) ) . build ( ) ) ; return new meteo data < > ( parser . parse ( response . get data ( ) ) , response ) ; }	Fetch a Sunrise from the MET API based on a given longitude, latitude and date range.
public list < meteo extras forecast > find hourly point forecasts from now ( int hours ahead ) { list < meteo extras forecast > point extras forecasts = new array list < > ( ) ; zoned date time now = get now ( ) ; for ( int i = num ; i < hours ahead ; i ++ ) { zoned date time ahead = now . plus hours ( i ) ; optional < point forecast > point forecast = get indexer ( ) . get point forecast ( ahead ) ; point forecast . if present ( pof -> { optional < period forecast > period forecast = get indexer ( ) . get tightest fit period forecast ( pof . get from ( ) ) ; period forecast . if present ( pef -> point extras forecasts . add ( new meteo extras forecast ( pof , pef ) ) ) ; } ) ; } return point extras forecasts ; }	Get all point forecasts from now and to the given hours ahead.
public optional < meteo extras forecast > find nearest forecast ( zoned date time date time ) { zoned date time dt = to zero msn ( date time . with zone same instant ( metzone ) ) ; point forecast chosen forecast = null ; for ( forecast forecast : get location forecast ( ) . get forecasts ( ) ) { if ( forecast instanceof point forecast ) { point forecast point forecast = ( point forecast ) forecast ; if ( is date match ( dt , clone zoned date time ( point forecast . get from ( ) ) ) ) { chosen forecast = point forecast ; break ; } else if ( chosen forecast == null ) { chosen forecast = point forecast ; } else if ( is nearer date ( point forecast . get from ( ) , dt , chosen forecast . get from ( ) ) ) { chosen forecast = point forecast ; } } } if ( chosen forecast == null ) { return optional . empty ( ) ; } return optional . of ( new meteo extras forecast ( chosen forecast , get indexer ( ) . get widest fit period forecast ( chosen forecast . get from ( ) ) . or else ( null ) ) ) ; }	Get the most accurate forecast for the given date.
public meteo data < weather > fetch content ( forecast query query ) throws meteo exception { meteo response response = get meteo client ( ) . fetch content ( create service uri builder ( ) . add parameter ( str , query . get name ( ) ) . add parameter ( str , query . get language ( ) . get value ( ) ) . build ( ) ) ; return new meteo data < > ( parser . parse ( response . get data ( ) ) , response ) ; }	Fetch a textforecast for a named forecast.
public meteo extras long term forecast create simple long term forecast ( ) throws meteo exception { list < meteo extras forecast day > forecast days = new array list < > ( ) ; zoned date time dt = get now ( ) ; for ( int i = num ; i <= num ; i ++ ) { zoned date time dti = dt . plus days ( i ) ; if ( get indexer ( ) . has forecasts for day ( dti ) ) { meteo extras forecast day mefd = create simple forcast for day ( dti ) ; if ( mefd != null && mefd . get forecasts ( ) . size ( ) > num ) { forecast days . add ( mefd ) ; } } } return new meteo extras long term forecast ( forecast days ) ; }	Create a longterm forecast, but only with a small subset of the weather data fields.
public meteo extras long term forecast create long term forecast ( ) { list < meteo extras forecast day > forecast days = new array list < > ( ) ; zoned date time dt = to zero hmsn ( get location forecast ( ) . get created ( ) . plus days ( num ) ) ; for ( int i = num ; i < series . get series ( ) . size ( ) ; i ++ ) { create long term forecast day ( dt . plus days ( i ) , series . get series ( ) . get ( i ) ) . if present ( forecast days :: add ) ; } return new meteo extras long term forecast ( forecast days ) ; }	Create a longterm forecast.
public static location from coordinates ( string coordinates ) { if ( coordinates == null ) { throw new illegal argument exception ( str ) ; } matcher m = p . matcher ( coordinates ) ; if ( ! m . matches ( ) ) { throw new illegal argument exception ( coordinates + str + p . pattern ( ) ) ; } try { double longitude = double . value of ( m . group ( num ) ) ; double latitude = double . value of ( m . group ( num ) ) ; integer altitude = num ; if ( m . group ( num ) != null ) { altitude = integer . value of ( m . group ( num ) . substring ( num ) ) ; } return new location ( longitude , latitude , altitude , str ) ; } catch ( number format exception e ) { throw new illegal argument exception ( coordinates + str + p . pattern ( ) ) ; } }	Create an untitled Location from coordinate string.
public meteo data < available > fetch content ( ) throws meteo exception { meteo response response = get meteo client ( ) . fetch content ( create service uri builder ( ) . add parameter ( str , null ) . skip question mark in url ( ) . build ( ) ) ; return new meteo data < > ( parser . parse ( response . get data ( ) ) , response ) ; }	Fetch a list of all available textforecasts.
public static optional < string > create wind symbol name ( point forecast point forecast ) { if ( point forecast == null || point forecast . get wind direction ( ) == null || point forecast . get wind speed ( ) == null ) { return optional . empty ( ) ; } return optional . of ( point forecast . get wind direction ( ) . get name ( ) . to lower case ( ) + id format . format ( point forecast . get wind speed ( ) . get beaufort ( ) ) ) ; }	Create name for a wind symbol.This will be created as a mix of the Beaufort wind speed id and the wind direction.
public static optional < beaufort level > find beaufort level ( point forecast point forecast ) { if ( point forecast == null || point forecast . get wind speed ( ) == null ) { return optional . empty ( ) ; } return optional . of nullable ( find unit by id ( point forecast . get wind speed ( ) . get beaufort ( ) ) ) ; }	Find matching Beaufort level for a given point forecast.This provides you with extra information about the wind speed specified in the forecast.
public static uri create uri ( string uri ) throws meteo exception { if ( uri == null ) { throw new meteo exception ( str ) ; } try { return new uri ( uri ) ; } catch ( uri e ) { throw new meteo exception ( e ) ; } }	Wrap the construction of URL's to avoid throwing of checked MalformedURLException.
public boolean is sun ( zoned date time current date ) { if ( get sun ( ) . get never rise ( ) ) { return bool ; } else if ( get sun ( ) . get never set ( ) ) { return bool ; } return time within period ( current date ) ; }	Check if the sun is shining for a given time.
optional < point forecast > get point forecast ( zoned date time date time ) { for ( forecast forecast : forecasts ) { if ( forecast instanceof point forecast ) { point forecast point forecast = ( point forecast ) forecast ; if ( create hour index key ( date time ) . equals ( create hour index key ( clone zoned date time ( point forecast . get from ( ) ) ) ) ) { return optional . of ( point forecast ) ; } } } return optional . empty ( ) ; }	Get the PointForecast that matches the given time.
optional < period forecast > get best fit period forecast ( zoned date time from , zoned date time to ) { if ( from == null || to == null ) { return optional . empty ( ) ; }	Find the period forecast that has the best fitted forecast for a given period.This means a forecast covering the requested period, with to and from time closest possible to that period.
public meteo data < text location weather > fetch content ( double longitude , double latitude ) throws meteo exception { return fetch content ( longitude , latitude , text location language . nb ) ; }	Fetch textforecasts and warnings for a geographical point or area, in Norwegian.
public meteo data < text location weather > fetch content ( double longitude , double latitude , text location language language ) throws meteo exception { meteo response response = get meteo client ( ) . fetch content ( create service uri builder ( ) . add parameter ( str , latitude ) . add parameter ( str , longitude ) . add parameter ( str , language . get value ( ) ) . build ( ) ) ; return new meteo data < > ( parser . parse ( response . get data ( ) ) , response ) ; }	Fetch textforecasts and warnings for a geographical point or area.
private void update db ( ) throws sql , liquibase exception { system . out . println ( str ) ; try ( basic data source data source = new basic data source ( ) ) { data source . set url ( full connection string ) ; data source . set username ( username ) ; data source . set password ( password ) ; try ( java . sql . connection c = data source . get connection ( ) ) { database database = database factory . get instance ( ) . find correct database implementation ( new jdbc connection ( c ) ) ;	Checks connection, retrieves appropriate changelog and performs database update.
private static string invoke string method ( final script engine js engine , final object thiz , final string name , final object ... args ) throws no such method exception , script exception { return ( string ) ( ( invocable ) js engine ) . invoke method ( thiz , name , args ) ; }	Calls a method on a script object compiled during a previous script execution, which is retained in the state of the ScriptEngine.
public synchronized t acquire ( final data source source ) throws data source exception { if ( object == null ) { if ( get reference ( ) == null ) { throw new illegal state exception ( str ) ; } else { object = source . get object ( get reference ( ) , object class ) ; } } return object ; }	Return the referenced object, potentially performing a remote DataStore lookup and deserialisation.
public static < t > referenced object < t > get referenced object ( final class < t > clazz , final string ref ) { return new referenced object < > ( clazz , ref , null ) ; }	Create a ReferencedObject that uses a remote reference to data present in an ObjectSource.
public static < t > referenced object < t > get wrapped object ( final class < t > clazz , final t obj ) { return new referenced object < > ( clazz , null , obj ) ; }	Create a ReferencedObject that directly wraps an object without a reference.
private < t > t get config ( final class < t > config class ) throws configuration exception { iterator < name > it = get service path ( ) . descending path iterator ( ) ; while ( it . has next ( ) ) { try ( input stream in = get configuration stream ( config class , it . next ( ) ) ) { return decoder . deserialise ( in , config class ) ; } catch ( final configuration exception e ) { log . trace ( str , e ) ; } catch ( final codec exception | io e ) { increment errors ( ) ; throw new configuration exception ( str + config class . get simple name ( ) , e ) ; } } increment errors ( ) ; throw new configuration exception ( str + config class . get simple name ( ) ) ; }	Acquire, decode and decrypt a configuration object from a data stream.
private static boolean get is substitutor enabled ( final bootstrap configuration bootstrap config ) { final string enable substitutor config key = str ; final boolean enable substitutor config default = bool ;	Checks whether the string substitution functionality should be enabled.
@ override public < t > iterator < class < t > > create class iterator ( final class < t > service , final string service name , final class loader loader , final boolean ignore on class not found ) { final iterator < class < t > > delegate class iterator = delegate . create class iterator ( service , service name , loader , ignore on class not found ) ; stream < class < t > > stream = stream support . stream ( spliterators . spliterator unknown size ( delegate class iterator , spliterator . ordered ) , bool ) ; return stream . filter ( t -> ! t . get package ( ) . get name ( ) . starts with ( str ) ) . collect ( collectors . to list ( ) ) . iterator ( ) ; }	Excludes all "com.sun.jersey" classes.
@ override public decoder get decoder ( final bootstrap configuration bootstrap , final decoder default decoder ) { final string decoder config key = str ; final string decoder ; try {	Returns the Decoder that should be used to interpret the configuration files.
public static < t > list < t > get services ( final class < t > intf ) { objects . require non null ( intf ) ; list < t > ret = new linked list < > ( ) ; for ( final t t : service loader . load ( intf ) ) { ret . add ( t ) ; } return ret ; }	Get all advertised service implementations of the specified interface.
public < t > t get module ( final class < t > interface implemented , final string module type ) throws null pointer exception {	Retrieves a module by its simple name, that implements a particular type T.
public synchronized input stream acquire ( final data source source ) throws data source exception { input stream ret ; if ( data == null ) { if ( get reference ( ) == null ) { throw new illegal state exception ( str ) ; } else { ret = source . get stream ( get reference ( ) ) ; } } else { ret = new byte array input stream ( data ) ; } return ret ; }	Return the referenced data as a stream, potentially performing a remote lookup.
public synchronized long size ( final data source source ) throws data source exception { if ( data == null ) { if ( get reference ( ) == null ) { throw new illegal state exception ( str ) ; } else { return source . get data size ( get reference ( ) ) ; } } else { return data . length ; } }	Determine the size of the data.
public static referenced data get wrapped data ( final string ref , final byte [ ] data ) { return new referenced data ( objects . require non null ( ref ) , data ) ; }	Create a ReferencedData instance that wraps data but also has a reference.
public string get index ( final int index ) { if ( index < num || index >= components . size ( ) ) { throw new illegal argument exception ( str ) ; } return components . get ( index ) ; }	Get the components of the Name at the specified numeric index.
public name get prefix ( final int upper index ) { if ( upper index < num || upper index > components . size ( ) ) { throw new illegal argument exception ( str ) ; } return new name ( components . sub list ( num , upper index ) ) ; }	Return a Name that consists of a subsection of the current Name.
boolean colored ( ) { return type == compiler . plain || type == compiler . ahead || type == compiler . behind ; }	is an arc colored, and hence on a color chain?.
boolean exec ( hsre pattern re , char sequence data , enum set < exec flags > exec flags ) throws regex exception { if ( num != ( re . guts . info & flags . reg uimpossible ) ) { throw new regex exception ( str ) ; } eflags = num ; for ( exec flags ef : exec flags ) { switch ( ef ) { case notbol : eflags |= flags . reg notbol ; break ; case noteol : eflags |= flags . reg noteol ; break ; case looking at : eflags |= flags . reg looking at ; break ; default : throw new runtime exception ( str ) ; } } this . re = re ; this . g = re . guts ; this . data = data ; this . data length = this . data . length ( ) ; if ( this . match != null ) { this . match . clear ( ) ; } else { this . match = lists . new array list ( ) ; } match . add ( null ) ;	exec - match regular expression.
private boolean cfindloop ( dfa d , dfa s , int [ ] coldp ) { int begin ; int end ; int cold ; int open ; int close ; int estart ; int estop ; boolean shorter = num != ( g . tree . flags & subre . shorter ) ; boolean hitend [ ] = new boolean [ num ] ; boolean looking at = num != ( eflags & flags . reg looking at ) ; assert d != null && s != null ; close = num ; do { int [ ] cold0 = new int [ num ] ; if ( looking at ) {	cfindloop - the heart of cfind.
private void subset ( runtime subexpression sub , int begin , int end ) { int n = sub . number ; assert n > num ; while ( match . size ( ) < ( n + num ) ) { match . add ( null ) ; } match . set ( n , new reg match ( begin , end ) ) ; }	subset - set any subexpression relevant to a successful subre.
private boolean cbrdissect ( runtime subexpression t , int begin , int end ) { int i ; int n = t . number ; int len ; int paren ; int p ; int stop ; int min = t . min ; int max = t . max ; assert t . op == str ; assert n >= num ;	cbrdissect - determine backref subexpression matches.
private void cloneouts ( nfa nfa , state old , state from , state to , int type ) { arc a ; assert old != from ; for ( a = old . outs ; a != null ; a = a . outchain ) { nfa . newarc ( type , a . co , from , to ) ; } }	cloneouts - copy out arcs of a state to another state pair, modifying type.
private void optst ( subre t ) { if ( t == null ) { return ; } if ( t . left != null ) { optst ( t . left ) ; } if ( t . right != null ) { optst ( t . right ) ; } }	optst - optimize a subRE subtree.
private void markst ( subre t ) { assert t != null ; t . flags |= subre . inuse ; if ( t . left != null ) { markst ( t . left ) ; } if ( t . right != null ) { markst ( t . right ) ; } }	markst - mark tree nodes as INUSE.
private long nfanode ( subre t ) throws regex exception { long ret ; assert t . begin != null ; if ( log . is debug enabled ( ) && is debug ) { log . debug ( string . format ( str , t . short id ( ) ) ) ; } nfa new nfa = new nfa ( nfa ) ; new nfa . dupnfa ( t . begin , t . end , new nfa . init , new nfa . final state ) ; new nfa . specialcolors ( ) ; ret = new nfa . optimize ( ) ; t . cnfa = new nfa . compact ( ) ;	nfanode - do one NFA for nfatree.
private subre parse ( int stopper , int type , state init state , state final state ) throws regex exception { state left ; state right ; subre branches ; subre branch ; subre t ; int firstbranch ; assert stopper == str || stopper == eos ; branches = new subre ( str , subre . longer , init state , final state ) ; branch = branches ; firstbranch = num ; do { if ( num == firstbranch ) { branch . right = new subre ( str , subre . longer , init state , final state ) ; branch = branch . right ; } firstbranch = num ; left = nfa . newstate ( ) ; right = nfa . newstate ( ) ; nfa . emptyarc ( init state , left ) ; nfa . emptyarc ( right , final state ) ; branch . left = parsebranch ( stopper , type , left , right , bool ) ; branch . flags |= up ( branch . flags | branch . left . flags ) ; if ( ( branch . flags & ~ branches . flags ) != num ) { for ( t = branches ; t != branch ; t = t . right ) { t . flags |= branch . flags ; } } } while ( eat ( str ) ) ; assert see ( stopper ) || see ( eos ) ; if ( ! see ( stopper ) ) { assert stopper == str && see ( eos ) ;	parse - parse an REThis is actually just the top level, which parses a bunch of branchestied together with '|'.
private void deltraverse ( nfa nfa , state leftend , state s ) { arc a ; state to ; if ( s . nouts == num ) { return ; } if ( s . tmp != null ) { return ; } s . tmp = s ; while ( ( a = s . outs ) != null ) { to = a . to ; deltraverse ( nfa , leftend , to ) ; assert to . nouts == num || to . tmp != null ; nfa . freearc ( a ) ; if ( to . nins == num && to . tmp == null ) { assert to . nouts == num ; nfa . freestate ( to ) ; } } assert s . no != state . freestate ; assert s == leftend || s . nins != num ; assert s . nouts == num ; s . tmp = null ; }	deltraverse - the recursive heart of delsubThis routine's basic job is to destroy all out-arcs of the state.
private void nonword ( int dir , state lp , state rp ) { int anchor = ( dir == ahead ) ? str : str ; assert dir == ahead || dir == behind ; nfa . newarc ( anchor , ( short ) num , lp , rp ) ; nfa . newarc ( anchor , ( short ) num , lp , rp ) ; cm . colorcomplement ( nfa , dir , wordchrs , lp , rp ) ; }	nonword - generate arcs for non-word-character ahead or behind.
private void word ( int dir , state lp , state rp ) { assert dir == ahead || dir == behind ; cloneouts ( nfa , wordchrs , lp , rp , dir ) ; }	word - generate arcs for word character ahead or behind.
private int scannum ( ) throws regex exception { int n = num ; while ( see ( digit ) && n < dupmax ) { n = n * num + nextvalue ; lex . next ( ) ; } if ( see ( digit ) || n > dupmax ) { throw new regex exception ( str ) ; } return n ; }	scannum - scan a number.
private void bracket ( state lp , state rp ) throws regex exception { assert see ( str ) ; lex . next ( ) ; while ( ! see ( str ) && ! see ( eos ) ) { brackpart ( lp , rp ) ; } assert see ( str ) ; cm . okcolors ( nfa ) ; }	bracket - handle non-complemented bracket expressionAlso called from cbracket for complemented bracket expressions.
private string scanplain ( ) throws regex exception { int startp = now ; int endp ; assert see ( collel ) || see ( eclass ) || see ( cclass ) ; lex . next ( ) ; endp = now ; while ( see ( plain ) ) { endp = now ; lex . next ( ) ; } string ret = new string ( pattern , startp , endp - startp ) ; assert see ( end ) ; lex . next ( ) ; return ret ; }	scanplain - scan PLAIN contents of [.
private int newlacon ( state begin , state end , int pos ) { if ( lacons . size ( ) == num ) {	newlacon - allocate a lookahead-constraint subRE.
private void onechr ( int c , state lp , state rp ) throws regex exception { if ( num == ( cflags & flags . reg icase ) ) { nfa . newarc ( plain , cm . subcolor ( c ) , lp , rp ) ; return ; } dovec ( locale . allcases ( c ) , lp , rp ) ; }	onechr - fill in arcs for a plain character, and possible case complementsThis is mostly a shortcut for efficient handling of the common case.
private void dovec ( unicode set set , state lp , state rp ) throws regex exception { int range count = set . get range count ( ) ; for ( int rx = num ; rx < range count ; rx ++ ) { int range start = set . get range start ( rx ) ; int range end = set . get range end ( rx ) ; if ( log . is debug enabled ( ) && is debug ) { log . debug ( string . format ( str , set , rx , range start , range end ) ) ; }	dovec - fill in arcs for each element of a cvecall kinds of MCCE complexity removed.
private short getcolor ( int c ) { try { return map . get ( c ) ; } catch ( null pointer exception npe ) { throw new regex runtime exception ( string . format ( str , c ) ) ; } }	Retrieve the color for a character.
short pseudocolor ( ) { short co = newcolor ( ) ; color desc cd = color descs . get ( co ) ; cd . set n ( num ) ; cd . mark pseudo ( ) ; return co ; }	pseudocolor - allocate a false color to be managed by other means.
void subrange ( int from , int to , state lp , state rp ) throws regex exception { map < range < integer > , short > cur colors = map . sub range map ( range . closed ( from , to ) ) . as map of ranges ( ) ; list < range < integer > > ranges = lists . new array list ( cur colors . key set ( ) ) ; for ( range < integer > range to process : ranges ) {	subrange - allocate new subcolors to this range of chars, fill in arcs.The range will overlap existing ranges; even in the simplest case,it will overlap the initial WHITE range.
void okcolors ( nfa nfa ) { color desc cd ; color desc scd ; arc a ; short sco ; for ( short co = num ; co < color descs . size ( ) ; co ++ ) { cd = color descs . get ( co ) ; if ( cd == null ) { continue ;	okcolors - promote subcolors to full colors.
void colorchain ( arc a ) { color desc cd = color descs . get ( a . co ) ; a . colorchain = cd . arcs ; cd . arcs = a ; }	colorchain - add this arc to the color chain of its color.
void uncolorchain ( arc a ) { color desc cd = color descs . get ( a . co ) ; arc aa ; aa = cd . arcs ; if ( aa == a ) { cd . arcs = a . colorchain ; } else { for ( ; aa != null && aa . colorchain != a ; aa = aa . colorchain ) {	uncolorchain - delete this arc from the color chain of its color.
void dumpcolors ( ) { for ( int co = num ; co < color descs . size ( ) ; co ++ ) { color desc cd = color descs . get ( co ) ; if ( cd != null ) { dumpcolor ( co , cd ) ; } } }	dumpcolors - debugging output.
void lexstart ( ) throws regex exception { prefixes ( ) ; if ( num != ( v . cflags & flags . reg quote ) ) { assert num == ( v . cflags & ( flags . reg advanced | flags . reg expanded | flags . reg newline ) ) ; intocon ( l q ) ; } else if ( num != ( v . cflags & flags . reg extended ) ) { assert num == ( v . cflags & flags . reg quote ) ; intocon ( l ere ) ; } else { assert num == ( v . cflags & ( flags . reg quote | flags . reg advf ) ) ; intocon ( l bre ) ; } v . nexttype = compiler . empty ; next ( ) ; }	lexstart - set up lexical stuff, scan leading options.
void lexnest ( char [ ] interpolated ) { assert v . savepattern == null ; v . savepattern = v . pattern ; v . savenow = v . now ; v . savestop = v . stop ; v . savenow = v . now ; v . pattern = interpolated ; v . now = num ; v . stop = v . pattern . length ; }	lexnest - "call a subroutine", interpolating string at the lexical levelNote, this is not a very general facility.
short getcolor ( int codepoint ) { try { return full map . get ( codepoint ) ; } catch ( null pointer exception npe ) { throw new runtime exception ( string . format ( str , codepoint ) ) ; } }	Retrieve the color for a full codepoint.
state set initialize ( int start ) {	Called at the start of a match.arguably we could just construct a new DFA each time.
int lastcold ( ) { int nopr = num ; for ( state set ss : state sets . values ( ) ) { if ( ss . noprogress && nopr < ss . get last seen ( ) ) { nopr = ss . get last seen ( ) ; } } return nopr ; }	lastcold - determine last point at which no progress had been made.
static unicode set eclass ( char c , boolean cases ) { if ( cases ) { return allcases ( c ) ; } else { unicode set set = new unicode set ( ) ; set . add ( c ) ; return set ; } }	eclass - Because we have no MCCE support, thisjust processing single characters.
public static unicode set cclass ( string cclass name , boolean casefold ) throws regex exception { try { if ( casefold ) { return known sets ci . get ( cclass name ) ; } else { return known sets cs . get ( cclass name ) ; } } catch ( execution exception e ) { throwables . propagate if instance of ( e . get cause ( ) , regex exception . class ) ; throw new regex runtime exception ( e . get cause ( ) ) ; } }	Return a UnicodeSet for a character class name.It appears that the names that TCL accepts are also acceptable to ICU.
void carcsort ( int first , int last ) { int p ; int q ; long tmp ; if ( last - first <= num ) { return ; } for ( p = first ; p <= last ; p ++ ) { for ( q = p ; q <= last ; q ++ ) { short pco = cnfa . carc color ( arcs [ p ] ) ; short qco = cnfa . carc color ( arcs [ q ] ) ; int pto = cnfa . carc target ( arcs [ p ] ) ; int qto = cnfa . carc target ( arcs [ q ] ) ; if ( pco > qco || ( pco == qco && pto > qto ) ) { assert p != q ; tmp = arcs [ p ] ; arcs [ p ] = arcs [ q ] ; arcs [ q ] = tmp ; } } } }	carcsort - sort compacted-NFA arcs by colorReally dumb algorithm, but if the list is long enough for that to matter,you're in real trouble anyway.
state newstate ( int flag ) { state new state = new state ( ) ; new state . no = nstates ++ ;	Factory method for new states.
void moveouts ( state old , state new state ) { arc a ; assert old != new state ; while ( ( a = old . outs ) != null ) { cparc ( a , new state , a . to ) ; freearc ( a ) ; } }	moveouts - move all out arcs of a state to another state.
void moveins ( state old , state new state ) { arc a ; assert old != new state ; while ( ( a = old . ins ) != null ) { cparc ( a , a . from , new state ) ; freearc ( a ) ; } assert old . nins == num ; assert old . ins == null ; }	moveins - move all in arcs of a state to another stateYou might think this could be done better by just updating theexisting arcs, and you would be right if it weren't for the desirefor duplicate suppression, which makes it easier to just make newones to exploit the suppression built into newarc.
void copyins ( state old , state new state ) { arc a ; assert old != new state ; for ( a = old . ins ; a != null ; a = a . inchain ) { cparc ( a , a . from , new state ) ; } }	copyins - copy all in arcs of a state to another state.
void copyouts ( state old , state new state ) { arc a ; assert old != new state ; for ( a = old . outs ; a != null ; a = a . outchain ) { cparc ( a , new state , a . to ) ; } }	copyouts - copy all out arcs of a state to another state.
void dropstate ( state s ) { arc a ; while ( ( a = s . ins ) != null ) { freearc ( a ) ; } while ( ( a = s . outs ) != null ) { freearc ( a ) ; } freestate ( s ) ; }	get rid of a state, releasing all its arcs.I'm not sure that all this is needed, as opposed to depending on the GC.
void freestate ( state s ) { assert s != null ; assert s . nins == num ; assert s . nouts == num ; if ( s . next != null ) { s . next . prev = s . prev ; } else { assert s == slast ; slast = s . prev ; } if ( s . prev != null ) { s . prev . next = s . next ; } else { assert s == states ; states = s . next ; } }	Unwire a state from the NFA.
void cparc ( arc oa , state from , state to ) { newarc ( oa . type , oa . co , from , to ) ; }	cparc - allocate a new arc within an NFA, copying details from old one.
void duptraverse ( state s , state stmp ) { arc a ; if ( s . tmp != null ) { return ; } s . tmp = ( stmp == null ) ? newstate ( ) : stmp ; if ( s . tmp == null ) { return ; } for ( a = s . outs ; a != null ; a = a . outchain ) { duptraverse ( a . to , null ) ; assert a . to . tmp != null ; cparc ( a , s . tmp , a . to . tmp ) ; } }	duptraverse - recursive heart of dupnfa.
void specialcolors ( ) { if ( parent == null ) { bos [ num ] = cm . pseudocolor ( ) ; bos [ num ] = cm . pseudocolor ( ) ; eos [ num ] = cm . pseudocolor ( ) ; eos [ num ] = cm . pseudocolor ( ) ; } else { assert parent . bos [ num ] != constants . colorless ; bos [ num ] = parent . bos [ num ] ; assert parent . bos [ num ] != constants . colorless ; bos [ num ] = parent . bos [ num ] ; assert parent . eos [ num ] != constants . colorless ; eos [ num ] = parent . eos [ num ] ; assert parent . eos [ num ] != constants . colorless ; eos [ num ] = parent . eos [ num ] ; } }	specialcolors - fill in special colors for an NFA.
void dumpnfa ( ) { if ( ! log . is debug enabled ( ) || ! is debug ) { return ; } log . debug ( str ) ; string builder sb = new string builder ( ) ; sb . append ( string . format ( str , pre . no , post . no , init . no , final state . no ) ) ; if ( bos [ num ] != constants . colorless ) { sb . append ( string . format ( str , bos [ num ] ) ) ; } if ( bos [ num ] != constants . colorless ) { sb . append ( string . format ( str , bos [ num ] ) ) ; } if ( eos [ num ] != constants . colorless ) { sb . append ( string . format ( str , eos [ num ] ) ) ; } if ( eos [ num ] != constants . colorless ) { sb . append ( string . format ( str , eos [ num ] ) ) ; } log . debug ( sb . to string ( ) ) ; for ( state s = states ; s != null ; s = s . next ) { dumpstate ( s ) ; } if ( parent == null ) { cm . dumpcolors ( ) ; } }	dumpnfa - dump an NFA in human-readable form.
void dumpstate ( state s ) { arc a ; if ( ! log . is debug enabled ( ) || ! is debug ) { return ; } string builder sb = new string builder ( ) ; sb . append ( string . format ( str , s . no , ( s . tmp != null ) ? str : str , ( s . flag != num ) ? ( char ) s . flag : str ) ) ; if ( s . prev != null && s . prev . next != s ) { sb . append ( string . format ( str ) ) ; } if ( s . nouts == num ) { sb . append ( str ) ; } else { dumparcs ( s , sb ) ; } log . debug ( sb . to string ( ) ) ; for ( a = s . ins ; a != null ; a = a . inchain ) { if ( a . to != s ) { log . debug ( string . format ( str , a . from . no , a . to . no , s . no ) ) ; } } }	dumpstate - dump an NFA state in human-readable form.
void dumparcs ( state s , string builder sb ) { int pos ; assert s . nouts > num ; pos = dumprarcs ( s . outs , s , num , sb ) ; if ( pos != num ) {	dumparcs - dump out-arcs in human-readable form.
int dumprarcs ( arc a , state s , int pos , string builder sb ) { if ( a . outchain != null ) { pos = dumprarcs ( a . outchain , s , pos , sb ) ; } dumparc ( a , s , sb ) ; if ( pos == num ) { sb . append ( str ) ; pos = num ; } else { pos ++ ; } return pos ; }	dumprarcs - dump remaining outarcs, recursively, in reverse order.
long optimize ( ) throws regex exception { log . debug ( str ) ; cleanup ( ) ; dumpnfa ( ) ; log . debug ( str ) ; fixempties ( ) ; log . debug ( str ) ; pullback ( ) ; pushfwd ( ) ; log . debug ( str ) ; cleanup ( ) ; return analyze ( ) ; }	optimize - optimize an NFA.
long analyze ( ) { arc a ; arc aa ; if ( pre . outs == null ) { return flags . reg uimpossible ; } for ( a = pre . outs ; a != null ; a = a . outchain ) { for ( aa = a . to . outs ; aa != null ; aa = aa . outchain ) { if ( aa . to == post ) { return flags . reg uemptymatch ; } } } return num ; }	analyze - ascertain potentially-useful facts about an optimized NFA.
int combine ( arc con , arc a ) throws regex exception {	combine - constraint lands on an arc, what happens?.
void cleanup ( ) { state s ; state nexts ; int n ; markreachable ( pre , null , pre ) ; markcanreach ( post , pre , post ) ; for ( s = states ; s != null ; s = nexts ) { nexts = s . next ; if ( s . tmp != post && num == s . flag ) { dropstate ( s ) ; } } assert post . nins == num || post . tmp == post ; cleartraverse ( pre ) ; assert post . nins == num || post . tmp == null ; n = num ; for ( s = states ; s != null ; s = s . next ) { s . no = n ++ ; } nstates = n ; }	cleanup - clean up NFA after optimizations.
void markreachable ( state s , state okay , state mark ) { arc a ; if ( s . tmp != okay ) { return ; } s . tmp = mark ; for ( a = s . outs ; a != null ; a = a . outchain ) { markreachable ( a . to , okay , mark ) ; } }	markreachable - recursive marking of reachable states.
void markcanreach ( state s , state okay , state mark ) { arc a ; if ( s . tmp != okay ) { return ; } s . tmp = mark ; for ( a = s . ins ; a != null ; a = a . inchain ) { markcanreach ( a . from , okay , mark ) ; } }	markcanreach - recursive marking of states which can reach here.
void fixempties ( ) { state s ; state nexts ; arc a ; arc nexta ; boolean progress ; do { progress = bool ; for ( s = states ; s != null ; s = nexts ) { nexts = s . next ; for ( a = s . outs ; a != null ; a = nexta ) { nexta = a . outchain ; if ( a . type == compiler . empty && unempty ( a ) ) { progress = bool ; } assert nexta == null || s . no != state . freestate ; } } if ( progress ) { dumpnfa ( ) ; } } while ( progress ) ; }	fixempties - get rid of EMPTY arcs.
boolean unempty ( arc a ) { state from = a . from ; state to = a . to ; boolean usefrom ; assert a . type == compiler . empty ; assert from != pre && to != post ; if ( from == to ) { freearc ( a ) ; return bool ; } usefrom = bool ; if ( from . nouts > to . nins ) { usefrom = bool ; } else if ( from . nouts == to . nins ) { if ( from . nins > to . nouts ) { usefrom = bool ; } } freearc ( a ) ; if ( usefrom ) { if ( from . nouts == num ) { moveins ( from , to ) ; freestate ( from ) ; } else { copyins ( from , to ) ; } } else { if ( to . nins == num ) { moveouts ( to , from ) ; freestate ( to ) ; } else { copyouts ( to , from ) ; } } return bool ; }	unempty - optimize out an EMPTY arc, if possibleActually, as it stands this function always succeeds, but the returnvalue is kept with an eye on possible future changes.
private map < string , string > get rule parameters ( ) throws cli execution exception { map < string , string > rule parameters ; if ( rule parameters file == null ) { rule parameters = collections . empty map ( ) ; } else { properties properties = new properties ( ) ; try { properties . load ( new file input stream ( rule parameters file ) ) ; } catch ( io e ) { throw new cli execution exception ( str + rule parameters file . get path ( ) + str ) ; } rule parameters = new tree map < > ( ) ; for ( string name : properties . string property names ( ) ) { rule parameters . put ( name , properties . get property ( name ) ) ; } } return rule parameters ; }	Reads the given rule parameters file.
private map < string , collection < rule interpreter plugin > > get rule interpreter plugins ( ) throws cli execution exception { try { return plugin repository . get rule interpreter plugin repository ( ) . get rule interpreter plugins ( collections . < string , object > empty map ( ) ) ; } catch ( plugin repository exception e ) { throw new cli execution exception ( str , e ) ; } }	Get all configured rule interpreter plugins.
private map < string , report plugin > get report plugins ( report context report context ) throws cli execution exception { report plugin repository report plugin repository ; try { report plugin repository = plugin repository . get report plugin repository ( ) ; return report plugin repository . get report plugins ( report context , plugin properties ) ; } catch ( plugin repository exception e ) { throw new cli execution exception ( str , e ) ; } }	Get all configured report plugins.
protected rule selection get rule selection ( rule set rule set ) { return rule selection . select ( rule set , group ids , constraint ids , concept ids ) ; }	Return the selection of rules.
public void run ( string [ ] args ) throws cli execution exception { options options = gather options ( task factory ) ; command line command line = get command line ( args , options ) ; interpret command line ( command line , options , task factory ) ; }	Run tasks according to the given arguments.
private static string get error message ( cli execution exception e ) { string buffer message builder = new string buffer ( ) ; throwable current = e ; do { message builder . append ( str ) ; message builder . append ( current . get message ( ) ) ; current = current . get cause ( ) ; } while ( current != null ) ; return message builder . to string ( ) ; }	Extract an error message from the given exception and its causes.
@ suppress warnings ( str ) private void gather standard options ( final options options ) { options . add option ( option builder . with arg name ( str ) . with description ( str ) . with long opt ( str ) . has arg ( ) . create ( str ) ) ; options . add option ( new option ( str , str ) ) ; }	Gathers the standard options shared by all tasks.
private void gather tasks options ( task factory task factory , options options ) { for ( task task : task factory . get tasks ( ) ) { for ( option option : task . get options ( ) ) { options . add option ( option ) ; } } }	Gathers the task specific options for all tasks.
private string gather task names ( task factory task factory ) { final string builder builder = new string builder ( ) ; for ( string task name : task factory . get task names ( ) ) { builder . append ( str ) . append ( task name ) . append ( str ) ; } return builder . to string ( ) . trim ( ) ; }	Returns a string containing the names of all supported tasks.
private void interpret command line ( command line command line , options options , task factory task factory ) throws cli execution exception { if ( command line . has option ( option help ) ) { print usage ( options , null ) ; system . exit ( num ) ; } list < string > task names = command line . get arg list ( ) ; if ( task names . is empty ( ) ) { print usage ( options , str + gather task names ( task factory ) ) ; system . exit ( num ) ; } list < task > tasks = new array list < > ( ) ; for ( string task name : task names ) { task task = task factory . from name ( task name ) ; if ( task == null ) { print usage ( options , str + task name ) ; } tasks . add ( task ) ; } map < string , object > properties = read properties ( command line ) ; plugin repository plugin repository = get plugin repository ( ) ; try { execute tasks ( tasks , options , command line , plugin repository , properties ) ; } catch ( plugin repository exception e ) { throw new cli execution exception ( str , e ) ; } }	Parse the command line and execute the requested task.
private command line get command line ( string [ ] args , options options ) { final command line parser parser = new basic parser ( ) ; command line command line = null ; try { command line = parser . parse ( options , args ) ; } catch ( parse exception e ) { print usage ( options , e . get message ( ) ) ; system . exit ( num ) ; } return command line ; }	Parse the command line.
private void execute task ( task task , options option , command line command line , plugin repository plugin repository , map < string , object > properties ) throws cli execution exception { try { task . with standard options ( command line ) ; task . with options ( command line ) ; } catch ( cli configuration exception e ) { print usage ( option , e . get message ( ) ) ; system . exit ( num ) ; } task . initialize ( plugin repository , properties ) ; task . run ( ) ; }	Executes a task.
private map < string , object > read properties ( command line command line ) throws cli configuration exception { final properties properties = new properties ( ) ; input stream properties stream ; if ( command line . has option ( str ) ) { file property file = new file ( command line . get option value ( str ) ) ; if ( ! property file . exists ( ) ) { throw new cli configuration exception ( str + property file . get absolute path ( ) ) ; } try { properties stream = new file input stream ( property file ) ; } catch ( file not found exception e ) { throw new cli configuration exception ( str , e ) ; } } else { properties stream = main . class . get resource as stream ( str ) ; } map < string , object > result = new hash map < > ( ) ; if ( properties stream != null ) { try { properties . load ( properties stream ) ; } catch ( io e ) { throw new cli configuration exception ( str , e ) ; } for ( string name : properties . string property names ( ) ) { result . put ( name , properties . get property ( name ) ) ; } } return result ; }	Read the plugin properties file if specified on the command line or if it exists on the class path.
private void print usage ( final options options , final string error message ) { if ( error message != null ) { system . out . println ( str + error message ) ; } final help formatter formatter = new help formatter ( ) ; formatter . print help ( main . class . get canonical name ( ) + str , options ) ; system . out . println ( str + gather task names ( task factory ) ) ; system . out . println ( str + main . class . get canonical name ( ) + str ) ; }	Print usage information.
private file get home directory ( ) { string dir name = system . getenv ( env jqassistant home ) ; if ( dir name != null ) { file dir = new file ( dir name ) ; if ( dir . exists ( ) ) { logger . debug ( str + dir . get absolute path ( ) + str ) ; return dir ; } else { logger . warn ( str + dir . get absolute path ( ) + str ) ; return null ; } } logger . warn ( str ) ; return null ; }	Determine the JQASSISTANT_HOME directory.
private class loader create plugin class loader ( ) throws cli execution exception { class loader parent class loader = task . class . get class loader ( ) ; file home directory = get home directory ( ) ; if ( home directory != null ) { file plugin directory = new file ( home directory , directory plugins ) ; if ( plugin directory . exists ( ) ) { final list < url > urls = new array list < > ( ) ; final path plugin directory path = plugin directory . to path ( ) ; simple file visitor < path > visitor = new simple file visitor < path > ( ) { @ override public file visit result visit file ( path file , basic file attributes attrs ) throws io { if ( file . to file ( ) . get name ( ) . ends with ( str ) ) { urls . add ( file . to file ( ) . to uri ( ) . to url ( ) ) ; } return file visit result . continue ; } } ; try { files . walk file tree ( plugin directory path , visitor ) ; } catch ( io e ) { throw new cli execution exception ( str , e ) ; } logger . debug ( str + urls ) ; return new com . buschmais . jqassistant . commandline . plugin class loader ( urls , parent class loader ) ; } } return parent class loader ; }	Create the class loader to be used for detecting and loading plugins.
public set < string > get containing ids ( double min longitude , double min latitude , double max longitude , double max latitude ) { set < string > ids = new hash set < > ( ) ; for cells in ( min longitude , min latitude , max longitude , max latitude , cell -> { if ( ids . is empty ( ) ) { ids . add all ( cell . get containing ids ( ) ) ; } else { ids . retain all ( cell . get containing ids ( ) ) ; } } ) ; return ids ; }	Identify which countries are guaranteed to contain the given bounding box fully.The given bounding box may wrap around the 180th longitude, i.e minLongitude = 170 andmaxLongitude = -170.
public set < string > get intersecting ids ( double min longitude , double min latitude , double max longitude , double max latitude ) { set < string > ids = new hash set < > ( ) ; for cells in ( min longitude , min latitude , max longitude , max latitude , cell -> { ids . add all ( cell . get all ids ( ) ) ; } ) ; return ids ; }	Identify which countries intersect with the given bounding box.
public string uri ( http method method , t target , object ... params ) { methodless router < t > router = ( method == null ) ? any method router : routers . get ( method ) ;	Given a target and params, this method tries to do the reverse routingand returns the URI.
public orderless router < t > add route ( string path pattern , t target ) { path pattern p = new path pattern ( path pattern ) ; if ( routes . contains key ( p ) ) { return this ; } routes . put ( p , target ) ; add reverse route ( target , p ) ; return this ; }	This method does nothing if the path pattern has already been added.A path pattern can only point to one target.
public int size ( ) { return first . routes ( ) . size ( ) + other . routes ( ) . size ( ) + last . routes ( ) . size ( ) ; }	Returns the number of routes in this router.
public methodless router < t > add route first ( string path pattern , t target ) { first . add route ( path pattern , target ) ; return this ; }	Adds route to the "first" section.
public methodless router < t > add route ( string path pattern , t target ) { other . add route ( path pattern , target ) ; return this ; }	Adds route to the "other" section.
public methodless router < t > add route last ( string path pattern , t target ) { last . add route ( path pattern , target ) ; return this ; }	Adds route to the "last" section.
public boolean any matched ( string [ ] request path tokens ) { return first . any matched ( request path tokens ) || other . any matched ( request path tokens ) || last . any matched ( request path tokens ) ; }	Checks if there's any matching route.
private criterion smart equal ( string property , object value ) { if ( value == null ) { return restrictions . is null ( property ) ; } else { return restrictions . eq ( property , value ) ; } }	There are two different Criterion for if a property is null or checking equality.
protected string get store file name ( string owner , string name ) { final string builder file name buff = new string builder ( ) ; file name buff . append ( owner != null ? str + owner : str ) ; file name buff . append ( str ) ; file name buff . append ( name != null ? str + name : str ) ; file name buff . append ( str ) ; return file name buff . to string ( ) ; }	Generates the file name String for an owner and book name.
protected int compare folders ( final entry e1 , final entry e2 ) { final boolean f1 = e1 instanceof folder ; final boolean f2 = e2 instanceof folder ; if ( f1 && ! f2 ) { return - num ; } else if ( ! f1 && f2 ) { return num ; } else { return num ; } }	Folders are always greater than non-Folders, if they are both Foldersor both not Folders they are equal.
protected int compare entries ( final entry e1 , final entry e2 ) { return new compare to builder ( ) . append ( e1 . get name ( ) , e2 . get name ( ) ) . append ( e1 . get note ( ) , e2 . get note ( ) ) . append ( e1 . get created ( ) , e2 . get created ( ) ) . append ( e1 . get modified ( ) , e2 . get modified ( ) ) . to comparison ( ) ; }	Compairs the entries by name, note, created and modified properties in thatorder.
protected int compare bookmarks ( final entry e1 , final entry e2 ) { if ( e1 instanceof bookmark && e2 instanceof bookmark ) { final bookmark b1 = ( bookmark ) e1 ; final bookmark b2 = ( bookmark ) e2 ; return new compare to builder ( ) . append ( b1 . get url ( ) , b2 . get url ( ) ) . append ( b1 . is new window ( ) , b2 . is new window ( ) ) . to comparison ( ) ; } else { return num ; } }	If both classes are not Bookmarks they are equal.
public void set servlet class last modified time ( long last modified ) { if ( this . servlet class last modified time < last modified ) { synchronized ( this ) { if ( this . servlet class last modified time < last modified ) { this . servlet class last modified time = last modified ; reload = bool ; } } } }	Sets the last-modified time of the servlet class file associated withthis JspServletWrapper.
public java . util . list < string > get dependants ( ) { try { object target ; if ( is tag file ) { if ( reload ) { tag handler class = ctxt . load ( ) ; } target = tag handler class . new instance ( ) ; } else { target = get servlet ( ) ; } if ( target != null && target instanceof jsp source dependent ) { return ( ( jsp source dependent ) target ) . get dependants ( ) ; } } catch ( throwable ex ) { } return null ; }	Get a list of files that the current page has source dependency on.
public class find class ( string class name ) throws class not found exception {	START OF IASRI 4709374.
public static string [ ] parse authorization ( final http servlet request request ) { final string auth = request . get header ( str ) ; logger . debug ( str , auth ) ; if ( auth == null || auth . is empty ( ) ) { return null ; } final string [ ] toks = auth . split ( str ) ; if ( toks . length < num ) { return null ; } if ( ! str . equals ignore case ( toks [ num ] ) ) { return null ; } final byte [ ] auth data = base64 . get decoder ( ) . decode ( toks [ num ] ) ; final string auth str = standard charsets . iso 8859 1 . decode ( byte buffer . wrap ( auth data ) ) . to string ( ) ; logger . debug ( str , auth str ) ; final string [ ] auth toks = auth str . split ( str , num ) ; logger . debug ( str , new object [ ] { auth toks } ) ; if ( auth toks . length != num ) { return null ; } return auth toks ; }	Parse the basic authentication header.
public static protected function mapper get instance ( ) { protected function mapper func mapper ; if ( security util . is package protection enabled ( ) ) { func mapper = access controller . do privileged ( new privileged action < protected function mapper > ( ) { public protected function mapper run ( ) { return new protected function mapper ( ) ; } } ) ; } else { func mapper = new protected function mapper ( ) ; } func mapper . fnmap = new java . util . hash map < string , method > ( ) ; return func mapper ; }	Generated Servlet and Tag Handler implementations call thismethod to retrieve an instance of the ProtectedFunctionMapper.This is necessary since generated code does not have access tocreate instances of classes in this package.
public void map function ( string fn q , final class < ? > c , final string method name , final class < ? > [ ] args ) { java . lang . reflect . method method ; if ( security util . is package protection enabled ( ) ) { try { method = access controller . do privileged ( new privileged exception action < method > ( ) { public method run ( ) throws exception { return c . get declared method ( method name , args ) ; } } ) ; } catch ( privileged action exception ex ) { throw new runtime exception ( str + ex . get exception ( ) . get message ( ) ) ; } } else { try { method = c . get declared method ( method name , args ) ; } catch ( no such method exception e ) { throw new runtime exception ( str + e . get message ( ) ) ; } } this . fnmap . put ( fn q , method ) ; }	Stores a mapping from the given EL function prefix and name tothe given Java method.
public static protected function mapper get map for function ( string fn q , final class < ? > c , final string method name , final class < ? > [ ] args ) { java . lang . reflect . method method ; protected function mapper func mapper ; if ( security util . is package protection enabled ( ) ) { func mapper = access controller . do privileged ( new privileged action < protected function mapper > ( ) { public protected function mapper run ( ) { return new protected function mapper ( ) ; } } ) ; try { method = access controller . do privileged ( new privileged exception action < method > ( ) { public method run ( ) throws exception { return c . get declared method ( method name , args ) ; } } ) ; } catch ( privileged action exception ex ) { throw new runtime exception ( str + ex . get exception ( ) . get message ( ) ) ; } } else { func mapper = new protected function mapper ( ) ; try { method = c . get declared method ( method name , args ) ; } catch ( no such method exception e ) { throw new runtime exception ( str + e . get message ( ) ) ; } } func mapper . the method = method ; return func mapper ; }	Creates an instance for this class, and stores the Method forthe given EL function prefix and name.
public method resolve function ( string prefix , string local name ) { if ( this . fnmap != null ) { return this . fnmap . get ( prefix + str + local name ) ; } return the method ; }	Resolves the specified local name and prefix into a Java.lang.Method.Returns null if the prefix and local name are not found.
public void set values ( char [ ] ch , int offset , int length ) { this . ch = ch ; this . offset = offset ; this . length = length ; }	Initializes the contents of the XMLString structure with thespecified values.
public object resolve variable ( string p name ) throws javax . servlet . jsp . el . el { el el context = page context . get el ( ) ; el el resolver = el context . get el ( ) ; try { return el resolver . get value ( el context , null , p name ) ; } catch ( javax . el . el ex ) { throw new javax . servlet . jsp . el . el ( ) ; } }	Resolves the specified variable within the given context.Returns null if the variable is not found.
public node . nodes parse ( string in file name ) throws file not found exception , jasper exception , io {	Parses a JSP page or tag file.
public node . nodes parse ( string in file name , node parent , url jar file url ) throws file not found exception , jasper exception , io {	Processes an include directive with the given path.
public node . nodes parse tag file directives ( string in file name ) throws file not found exception , jasper exception , io { boolean is tag file save = is tag file ; boolean directive only save = directive only ; is tag file = bool ; directive only = bool ; node . nodes page = do parse ( in file name , null , ( url ) ctxt . get tag file jar urls ( ) . get ( in file name ) ) ; directive only = directive only save ; is tag file = is tag file save ; return page ; }	Extracts tag file directive information from the tag file with thegiven name.This is invoked by the compiler.
public compiler create compiler ( boolean jspc mode ) throws jasper exception { if ( jsp compiler != null ) { return jsp compiler ; } jsp compiler = new compiler ( this , jsw , jspc mode ) ; return jsp compiler ; }	Create a "Compiler" object.
public java . io . input stream get resource as stream ( string res ) throws jasper exception { return context . get resource as stream ( canonical uri ( res ) ) ; }	Gets a resource as a stream, relative to the meanings of thiscontext's implementation.
private optional < instant > calc last mod ( ) { instant global last mod = null ; for ( final channel information ci : this . channel service . list ( ) ) { final optional < instant > last mod = of nullable ( ci . get state ( ) . get modification timestamp ( ) ) ; if ( global last mod == null || last mod . get ( ) . is after ( global last mod ) ) { global last mod = last mod . get ( ) ; } } return optional . of nullable ( global last mod ) ; }	Find the last modification timestamp of all channels.
array list basic find class loaders ( ) { class [ ] stack = context finder . get class context ( ) ; array list result = new array list ( num ) ; class loader previous loader = null ; for ( int i = num ; i < stack . length ; i ++ ) { class loader tmp = stack [ i ] . get class loader ( ) ; if ( check class ( stack [ i ] ) && tmp != null && tmp != this ) { if ( check class loader ( tmp ) ) { if ( previous loader != tmp ) { result . add ( tmp ) ; previous loader = tmp ; } }	We assume that the bootclassloader never uses the context classloader to find classes in itself.
private boolean check class loader ( class loader classloader ) { if ( classloader == null || classloader == get parent ( ) ) return bool ; for ( class loader parent = classloader . get parent ( ) ; parent != null ; parent = parent . get parent ( ) ) if ( parent == this ) return bool ; return bool ; }	not be used as a delegate, otherwise we endup in endless recursion.
private boolean start loading ( string name ) { set classes and resources = ( set ) cycle detector . get ( ) ; if ( classes and resources != null && classes and resources . contains ( name ) ) return bool ; if ( classes and resources == null ) { classes and resources = new hash set ( num ) ; cycle detector . set ( classes and resources ) ; } classes and resources . add ( name ) ; return bool ; }	False is returned when a cycle is being detected.
private static byte [ ] read stream header ( input stream in ) throws io { byte [ ] stream header = new byte [ decoder util . stream header size ] ; new data input stream ( in ) . read fully ( stream header ) ; return stream header ; }	Reads the Stream Header into a buffer.This is a helper function for the constructors.
public static < t > pagination result < t > paginate ( final integer start page , final int page size , final list < t > full data set ) { return paginate ( start page , page size , ( start , length ) -> { final int len = full data set . size ( ) ; if ( start > len ) { return collections . empty list ( ) ; } return full data set . sub list ( start , math . min ( start + length , len ) ) ; } ) ; }	Paginate from a full data set.
public static meta key from string ( final string string ) { final int idx = string . index of ( str ) ; if ( idx < num ) {	Convert a string to a MetaKey if possible.
private void fill requirements ( ) throws io { this . requirements . add ( new dependency ( str , str , rpm dependency flags . less , rpm dependency flags . equal , rpm dependency flags . rpmlib ) ) ; if ( ! this . options . get file digest algorithm ( ) . equals ( digest algorithm . m ) ) { this . requirements . add ( new dependency ( str , str , rpm dependency flags . less , rpm dependency flags . equal , rpm dependency flags . rpmlib ) ) ; } this . requirements . add ( new dependency ( str , str , rpm dependency flags . less , rpm dependency flags . equal , rpm dependency flags . rpmlib ) ) ; this . options . get payload coding ( ) . create provider ( ) . fill requirements ( this . requirements :: add ) ; }	Fill extra requirements the RPM file itself may have.
public tag file info get tag file ( string short name ) { tag file info tag file = super . get tag file ( short name ) ; if ( tag file == null ) { string path = tag file map . get ( short name ) ; if ( path == null ) { return null ; } tag info tag info = null ; try { tag info = tag file processor . parse tag file directives ( pc , short name , path , this ) ; } catch ( jasper exception je ) { throw new runtime exception ( je . to string ( ) ) ; } tag file = new tag file info ( short name , path , tag info ) ; vec . add ( tag file ) ; this . tag files = vec . to array ( new tag file info [ vec . size ( ) ] ) ; } return tag file ; }	Checks to see if the given tag name maps to a tag file path,and if so, parses the corresponding tag file.
private void parse implicit tld ( jsp compilation context ctxt , string path ) throws jasper exception { input stream is = null ; tree node tld = null ; try { url uri = ctxt . get resource ( path ) ; if ( uri == null ) {	Parses the JSP version and tlib-version from the implicit.tld at thegiven path.
public string get checksum ( final string file name , final string algorithm ) { if ( ! this . digests . contains ( algorithm ) ) { return null ; } final string result = this . checksums . get ( file name + str + algorithm ) ; if ( result == null ) { throw new illegal state exception ( string . format ( str , file name ) ) ; } return result ; }	Get the digest of a closed file.
public long get size ( final string file name ) { final long result = this . sizes . get ( file name ) ; if ( result == null ) { throw new illegal state exception ( string . format ( str , file name ) ) ; } return result ; }	Get the size of a closed file.
private static void validate channel name ( final string name , final validation context ctx ) { if ( name == null || name . is empty ( ) ) { return ; } final matcher m = channel service . name pattern . matcher ( name ) ; if ( ! m . matches ( ) ) { ctx . error ( str , string . format ( str , name , channel service . name pattern . pattern ( ) ) ) ; } }	Validate the name of the channel.
public void seek to block ( int block number ) throws io { if ( in == null ) throw new xzio ( str ) ; if ( block number < num || block number >= block count ) throw new xzio ( str + block number ) ;	Seeks to the beginning of the given XZ Block.
private void locate block by pos ( block info info , long pos ) { if ( pos < num || pos >= uncompressed size ) throw new index out of bounds exception ( str + pos ) ;	Locates the Block that contains the given uncompressed position.
protected static list < maven versioned artifact > get maven artifacts ( final string channel id , final supplier < collection < artifact information > > artifacts supplier , final string group id , final string artifact id , final boolean snapshot , final predicate < comparable version > version filter ) { final list < maven versioned artifact > arts = new array list < > ( ) ; for ( final artifact information ai : artifacts supplier . get ( ) ) { if ( ! is zip ( ai ) ) {	Get a list of all relevant maven artifacts.
private void update opt state and reps ( ) { int opt prev = opts [ opt cur ] . opt prev ; assert opt prev < opt cur ; if ( opts [ opt cur ] . prev1 is literal ) { -- opt prev ; if ( opts [ opt cur ] . has prev2 ) { opts [ opt cur ] . state . set ( opts [ opts [ opt cur ] . opt prev2 ] . state ) ; if ( opts [ opt cur ] . back prev2 < reps ) opts [ opt cur ] . state . update long rep ( ) ; else opts [ opt cur ] . state . update match ( ) ; } else { opts [ opt cur ] . state . set ( opts [ opt prev ] . state ) ; } opts [ opt cur ] . state . update literal ( ) ; } else { opts [ opt cur ] . state . set ( opts [ opt prev ] . state ) ; } if ( opt prev == opt cur - num ) {	Updates the state and reps for the current byte in the opts array.
private void calc1 byte prices ( int pos , int pos state , int avail , int any rep price ) {	Calculates prices of a literal, a short rep, and literal + rep0.
private int calc long rep prices ( int pos , int pos state , int avail , int any rep price ) { int start len = match len min ; int len limit = math . min ( avail , nice len ) ; for ( int rep = num ; rep < reps ; ++ rep ) { int len = lz . get match len ( opts [ opt cur ] . reps [ rep ] , len limit ) ; if ( len < match len min ) continue ; while ( opt end < opt cur + len ) opts [ ++ opt end ] . reset ( ) ; int long rep price = get long rep price ( any rep price , rep , opts [ opt cur ] . state , pos state ) ; for ( int i = len ; i >= match len min ; -- i ) { int price = long rep price + rep len encoder . get price ( i , pos state ) ; if ( price < opts [ opt cur + i ] . price ) opts [ opt cur + i ] . set1 ( price , opt cur , rep ) ; } if ( rep == num ) start len = len + num ; int len2 limit = math . min ( nice len , avail - len - num ) ; int len2 = lz . get match len ( len + num , opts [ opt cur ] . reps [ rep ] , len2 limit ) ; if ( len2 >= match len min ) {	Calculates prices of long rep and long rep + literal + rep0.
private void calc normal match prices ( int pos , int pos state , int avail , int any match price , int start len ) {	Calculates prices of a normal match and normal match + literal + rep0.
private void expected byte ( int position , int count ) throws utf { throw new utf ( localizer . get message ( str , integer . to string ( position ) , integer . to string ( count ) ) ) ; }	Throws an exception for expected byte.
private void invalid byte ( int position , int count , int c ) throws utf { throw new utf ( localizer . get message ( str , integer . to string ( position ) , integer . to string ( count ) ) ) ; }	Throws an exception for invalid byte.
private void scan tlds ( ) throws jasper exception { mappings = new hash map < string , string [ ] > ( ) ;	Scan the all the tlds accessible in the web app.For performance reasons, this is done in two stages.
private tld info scan tld ( string resource path , string entry name , input stream stream ) throws jasper exception { try {	Scan the given TLD for uri and listeners elements.
public void add wrapper ( string jsp uri , jsp servlet wrapper jsw ) { jsps . remove ( jsp uri ) ; jsps . put ( jsp uri , jsw ) ; }	Add a new JspServletWrapper.
public class loader get parent class loader ( ) { class loader parent class loader = thread . current thread ( ) . get context class loader ( ) ; if ( parent class loader == null ) { parent class loader = this . get class ( ) . get class loader ( ) ; } return parent class loader ; }	Get the parent class loader.
public void set bytecode ( string name , byte [ ] bytecode ) { if ( bytecode == null ) { bytecodes . remove ( name ) ; bytecode birth times . remove ( name ) ; return ; } bytecodes . put ( name , bytecode ) ; bytecode birth times . put ( name , long . value of ( system . current time millis ( ) ) ) ; }	Save the bytecode for the class in a map.
public long get bytecode birth time ( string name ) { long time = bytecode birth times . get ( name ) ; return ( time != null ? time . long value ( ) : num ) ; }	Retrieve the time the bytecode for a class was created.
public void save bytecode ( string class name , string class file name ) { byte [ ] bytecode = get bytecode ( class name ) ; if ( bytecode != null ) { try { file output stream fos = new file output stream ( class file name ) ; fos . write ( bytecode ) ; fos . close ( ) ; } catch ( io ex ) { context . log ( str + class name + str + class file name , ex ) ; } } }	Save the bytecode for a class to disk.
private void check compile ( ) { for ( jsp servlet wrapper jsw : jsps . values ( ) ) { if ( jsw . is tag file ( ) ) {	Method used by background thread to check the JSP dependenciesregistered with this class for JSP's.
private void init class path ( ) { string builder cpath = new string builder ( ) ; string sep = system . get property ( str ) ; cpath . append ( options . get scratch dir ( ) + sep ) ; string cp = ( string ) context . get attribute ( constants . servlet classpath ) ; if ( cp == null || cp . equals ( str ) ) { cp = options . get class path ( ) ; } if ( cp != null ) { classpath = cpath . to string ( ) + cp ; }	Method used to initialize classpath for compiles.
protected void thread start ( ) {	Start the background thread that will periodically check forchanges to compile time included files in a JSP.
protected void thread stop ( ) { if ( thread == null ) { return ; } thread done = bool ; thread . interrupt ( ) ; try { thread . join ( ) ; } catch ( interrupted exception e ) { ; } thread = null ; }	Stop the background thread that is periodically checking forchanges to compile time included files in a JSP.
public void run ( ) {	The background thread that checks for changes to filesincluded by a JSP and flags that a recompile is required.
private optional < channel instance > find by name ( final string name ) { if ( name == null ) { return empty ( ) ; } final string id = this . manager . access call ( key storage , channel service access . class , channels -> { return channels . map to id ( name ) ; } ) ; return find by id ( id ) ; }	Find a channel by name.
private channel instance find channel ( final by by ) { final optional < channel instance > channel ; try ( locked l = lock ( this . read lock ) ) { channel = find ( by ) ; } if ( ! channel . is present ( ) ) { throw new channel not found exception ( by . to string ( ) ) ; } return channel . get ( ) ; }	Find a channel.
private void update deploy group cache ( final channel service access model ) {	Update the channel to deploy group cache map.
public static long copy ( final input stream in , final output stream out ) throws io { objects . require non null ( in ) ; objects . require non null ( out ) ; final byte [ ] buffer = new byte [ copy buffer size ] ; long result = num ; int rc ; while ( ( rc = in . read ( buffer ) ) >= num ) { result += rc ; out . write ( buffer , num , rc ) ; } return result ; }	Copy the remaining content of one stream to the other.
public static node . nodes parse ( parser controller pc , string path , jsp reader reader , node parent , boolean is tag file , boolean directives only , url jar file url , string page enc , string jsp config page enc , boolean is default page encoding , boolean has bom ) throws jasper exception { parser parser = new parser ( pc , reader , is tag file , directives only , jar file url , has bom ) ; node . root root = new node . root ( reader . mark ( ) , parent , bool ) ; root . set page encoding ( page enc ) ; root . set jsp config page encoding ( jsp config page enc ) ; root . set is default page encoding ( is default page encoding ) ; root . set has bom ( has bom ) ; if ( has bom ) {	The main entry for Parser.
public static attributes parse attributes ( parser controller pc , jsp reader reader ) throws jasper exception { parser tmp parser = new parser ( pc , reader , bool , bool , null , bool ) ; return tmp parser . parse attributes ( ) ; }	Parse Attributes for a reader, provided for external use.
private void add include ( node parent , list files ) throws jasper exception { if ( files != null ) { iterator iter = files . iterator ( ) ; while ( iter . has next ( ) ) { string file = ( string ) iter . next ( ) ; attributes impl attrs = new attributes impl ( ) ; attrs . add attribute ( str , str , str , str , file ) ;	Add a list of files.
private boolean parse jsp attribute and body ( node parent , string tag , string body type ) throws jasper exception { boolean result = bool ; if ( reader . matches optional spaces followed by ( str ) ) {	Attempts to parse 'JspAttributeAndBody' production.
public void add attribute ( string name , string value ) { if ( attributes == null ) attributes = new hash map < string , string > ( ) ; attributes . put ( name , value ) ; }	Add an attribute to this node, replacing any existing attributewith the same name.
public void add child ( tree node node ) { if ( children == null ) children = new array list < tree node > ( ) ; children . add ( node ) ; }	Add a new child node to this node.
public iterator < string > find attributes ( ) { set < string > attrs ; if ( attributes == null ) attrs = collections . empty set ( ) ; else attrs = attributes . key set ( ) ; return attrs . iterator ( ) ; }	Return an Iterator of the attribute names of this node.
public iterator < tree node > find children ( ) { list < tree node > nodes ; if ( children == null ) nodes = collections . empty list ( ) ; else nodes = children ; return nodes . iterator ( ) ; }	Return an Iterator of all children of this node.
public iterator < tree node > find children ( string name ) { list < tree node > results ; if ( children == null ) results = collections . empty list ( ) ; else { results = new array list < tree node > ( ) ; for ( tree node item : children ) { if ( name . equals ( item . get name ( ) ) ) results . add ( item ) ; } } return results . iterator ( ) ; }	Return an Iterator over all children of this node that have thespecified name.
public maven coordinates to base ( ) { if ( this . classifier == null && this . extension == null ) { return this ; } return new maven coordinates ( this . group id , this . artifact id , this . version ) ; }	Create a new instance without classifier and extension.
private string find alias ( string var name ) { if ( aliases == null ) return var name ; string alias = aliases . get ( var name ) ; if ( alias == null ) { return var name ; } return alias ; }	Checks to see if the given variable name is used as an alias, and if so,returns the variable name for which it is used as an alias.
public static void set thread ( ) { byte array output stream baos = new byte array output stream ( ) ; data . set ( baos ) ; streams . set ( new print stream ( baos ) ) ; }	Start capturing thread's output.
public static string unset thread ( ) { byte array output stream baos = ( byte array output stream ) data . get ( ) ; if ( baos == null ) { return null ; } streams . set ( null ) ; data . set ( null ) ; return baos . to string ( ) ; }	Stop capturing thread's output and return captured data as a String.
protected print stream find stream ( ) { print stream ps = ( print stream ) streams . get ( ) ; if ( ps == null ) { ps = wrapped ; } return ps ; }	Find PrintStream to which the output must be written to.
protected static void write optional ( final string writer writer , final string field name , final string value ) { if ( value != null ) { write ( writer , field name , value ) ; } }	Write field only when the value is set.
protected static void write ( final string writer writer , final string field name , final string value ) { writer . write ( field name + str + value + str ) ; }	Write a field.
public static element add element ( final element parent , final string name ) { final element ele = parent . get owner document ( ) . create element ( name ) ; parent . append child ( ele ) ; return ele ; }	Create a new element and add it as the last child.
public static element add element first ( final element parent , final string name ) { final element ele = parent . get owner document ( ) . create element ( name ) ; parent . insert before ( ele , null ) ; return ele ; }	Create a new element and add it as the first child.
public void write out ( writer out ) throws io { if ( writer == null ) { out . write ( cb , num , next char ) ;	Write the contents of this BodyJspWriter into a Writer.Subclasses are likely to do interesting things with theimplementation so some things are extra efficient.
void set writer ( writer writer ) { this . writer = writer ; if ( writer != null ) {	Sets the writer to which all output is written.
private void re alloc buff ( int len ) { if ( buffer size + len <= cb . length ) { buffer size = cb . length ; return ; } if ( len < cb . length ) { len = cb . length ; } buffer size = cb . length + len ; char [ ] tmp = new char [ buffer size ] ; system . arraycopy ( cb , num , tmp , num , cb . length ) ; cb = tmp ; tmp = null ; }	Reallocates buffer since the spec requires it to be unbounded.
public static void map ( compiler compiler , node . nodes page ) throws jasper exception { el map = new el ( ) ; map . ds = new string builder ( ) ; map . ss = new string builder ( ) ; page . visit ( map . new el ( ) ) ;	Creates the functions mappers for all EL expressions in the JSP page.
private static state get same parent ( final state parent , final meta key key ) { state current = parent ; while ( current != null ) { if ( current . key . equals ( key ) ) { return current ; } current = current . parent ; } return null ; }	Traverse up from the provided parent and find the first which uses thesame key.
public storage registration register model ( final long lock priority , final meta key key , final storage model provider < ? , ? > storage provider ) throws model initialization exception { this . model lock . write lock ( ) . lock ( ) ; try { test closed ( ) ; if ( this . model key map . contains key ( key ) ) { throw new illegal argument exception ( string . format ( str , key ) ) ; } try { storage provider . start ( this . context ) ; } catch ( final exception e ) { throw new model initialization exception ( str + key , e ) ; } final long id = this . counter ++ ; final entry entry = new entry ( id , lock priority , key , storage provider ) ; this . model id map . put ( id , entry ) ; this . model key map . put ( key , entry ) ; return new storage registration ( ) { @ override public void unregister ( ) { unregister model ( id ) ; } } ; } finally { this . model lock . write lock ( ) . unlock ( ) ; } }	Register a new model with the storage manager.
public boolean stream ( final meta key key , final io < input stream > consumer ) throws io { return stream from ( this . data path , key , consumer ) ; }	Stream directly from the storage.
@ request mapping ( str ) public model and view monitor ( @ path variable ( str ) final string id ) { final job handle job = this . manager . get job ( id ) ; if ( job != null ) { logger . debug ( str , job . get id ( ) , job . get state ( ) ) ; } else { logger . debug ( str , id ) ; } final map < string , object > model = new hash map < > ( num ) ; model . put ( str , job ) ; return new model and view ( str , model ) ; }	Monitor the job, only produces an HTML fragment of the current job state.
protected boolean is authenticated ( final by by , final http servlet request request ) { final string [ ] auth toks = parse authorization ( request ) ; if ( auth toks == null ) { return bool ; }	Simply test if the request is authenticated against the channels deploykeys.
public void finish ( ) throws io { if ( ! this . finished ) { this . finished = bool ; write end ( ) ; } try { this . out . close ( ) ; } catch ( final xml e ) { throw new io ( e ) ; } }	Complete the document but don't close the underlying writer.
public static gson make gson ( final boolean pretty ) { final gson builder gb = new gson builder ( ) ; if ( pretty ) { gb . set pretty printing ( ) ; } gb . register type adapter ( node . class , new node adapter ( ) ) ; gb . register type adapter ( byte [ ] . class , new byte array adapter ( ) ) ; return gb . create ( ) ; }	Make an appropriate Gson parser to processing ChannelData instances.
public boolean encode for lzm ( ) {	Compresses for LZMA2.
public static map < meta key , string > union ( final map < meta key , string > provided meta data , final map < meta key , string > extracted meta data ) { final int size1 = provided meta data != null ? provided meta data . size ( ) : num ; final int size2 = extracted meta data != null ? extracted meta data . size ( ) : num ; if ( size1 + size2 == num ) { return collections . empty map ( ) ; } final map < meta key , string > result = new hash map < > ( size1 + size2 ) ; if ( extracted meta data != null ) { result . put all ( extracted meta data ) ; }	Return an unmodifiable map of provided and extracted meta data.
public static throwable get throwable ( servlet request request ) { throwable error = ( throwable ) request . get attribute ( servlet exception ) ; if ( error == null ) { error = ( throwable ) request . get attribute ( jsp exception ) ; if ( error != null ) { request . set attribute ( servlet exception , error ) ; } } return error ; }	Returns the value of the javax.servlet.error.exception requestattribute value, if present, otherwise the value of thejavax.servlet.jsp.jspException request attribute value.This method is called at the beginning of the generated servlet codefor a JSP error page, when the "exception" implicit scripting languagevariable is initialized.
private string is check sum ( final coordinates c ) { final string cext = c . get extension ( ) ; if ( cext == null ) { return null ; } for ( final string ext : this . options . get checksum extensions ( ) ) { if ( cext . ends with ( str + ext ) ) { return ext ; } } return null ; }	Check if the uploaded artifact is actually a checksum file.
public void finish ( ) throws io { if ( ! finished ) { if ( exception != null ) throw exception ; try { if ( expected uncompressed size != - num && expected uncompressed size != current uncompressed size ) throw new xzio ( str + expected uncompressed size + str + str + current uncompressed size + str ) ; lz . set finishing ( ) ; lzma . encode for lzm ( ) ; if ( use end marker ) lzma . encode lzm ( ) ; rc . finish ( ) ; } catch ( io e ) { exception = e ; throw e ; } finished = bool ; lzma . put arrays to cache ( array cache ) ; lzma = null ; lz = null ; } }	Finishes the stream without closing the underlying OutputStream.
public exception get exception ( ) { throwable t = jsp runtime library . get throwable ( request ) ;	Returns the exception associated with this page context, if any.Added wrapping for Throwables to avoid ClassCastException(see Bugzilla 31171 for details).
public static object evaluate expression ( final string expression , final class expected type , final page context page context , final protected function mapper function map ) throws el { object ret value ; if ( security util . is package protection enabled ( ) ) { try { ret value = access controller . do privileged ( new privileged exception action < object > ( ) { public object run ( ) throws exception { el el context = ( el ) page context . get el ( ) ; el context . set function mapper ( function map ) ; expression factory exp factory = get expression factory ( page context ) ; value expression expr = exp factory . create value expression ( el context , expression , expected type ) ; return expr . get value ( el context ) ; } } ) ; } catch ( privileged action exception ex ) { exception real ex = ex . get exception ( ) ; if ( real ex instanceof el ) { throw ( el ) real ex ; } else { throw new el ( real ex ) ; } } } else { el el context = ( el ) page context . get el ( ) ; el context . set function mapper ( function map ) ; expression factory exp factory = get expression factory ( page context ) ; value expression expr = exp factory . create value expression ( el context , expression , expected type ) ; ret value = expr . get value ( el context ) ; } return ret value ; }	Evaluates an EL expression.
protected string make prefix from osgi properties ( ) { final string port = system . get property ( str ) ; if ( port == null ) { return null ; } final string builder sb = new string builder ( ) ; sb . append ( str ) . append ( discover hostname ( ) ) ; if ( ! str . equals ( port ) ) { sb . append ( str ) . append ( port ) ; } return sb . to string ( ) ; }	Make the prefix by guessing the port from the OSGi settings.
public static boolean is xml ( final path path ) throws io { final xml tools factory xml = activator . get xml tools factory ( ) ; final xml xin = xml . new xml ( ) ; try ( input stream stream = new buffered input stream ( files . new input stream ( path ) ) ) { try { final xml reader = xin . create xml ( stream ) ; reader . next ( ) ; return bool ; } catch ( final xml e ) { return bool ; } } }	Test if this file is an XML file.
public static tag info parse tag file directives ( parser controller pc , string name , string path , tag library info tag lib info ) throws jasper exception { error dispatcher err = pc . get compiler ( ) . get error dispatcher ( ) ; node . nodes page = null ; try { page = pc . parse tag file directives ( path ) ; } catch ( file not found exception e ) { err . jsp error ( str , path ) ; } catch ( io e ) { err . jsp error ( str , path ) ; } tag file directive visitor tag file visitor = new tag file directive visitor ( pc . get compiler ( ) , tag lib info , name , path ) ; page . visit ( tag file visitor ) ; tag file visitor . post check ( ) ; return tag file visitor . get tag info ( ) ; }	Parses the tag file, and collects information on the directives includedin it.
private class load tag file ( compiler compiler , string tag file path , tag info tag info , page info parent page info ) throws jasper exception { jsp compilation context ctxt = compiler . get compilation context ( ) ; jsp runtime context rctxt = ctxt . get runtime context ( ) ; synchronized ( rctxt ) { jsp servlet wrapper wrapper = ( jsp servlet wrapper ) rctxt . get wrapper ( tag file path ) ; if ( wrapper == null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get options ( ) , tag file path , tag info , ctxt . get runtime context ( ) , ( url ) ctxt . get tag file jar urls ( ) . get ( tag file path ) ) ; rctxt . add wrapper ( tag file path , wrapper ) ;	Compiles and loads a tagfile.
public void remove proto type files ( string class file name ) { iterator < compiler > iter = temp vector . iterator ( ) ; while ( iter . has next ( ) ) { compiler c = iter . next ( ) ; if ( class file name == null ) { c . remove generated class files ( ) ; } else if ( class file name . equals ( c . get compilation context ( ) . get class file name ( ) ) ) { c . remove generated class files ( ) ; temp vector . remove ( c ) ; return ; } } }	Removed the java and class files for the tag prototypegenerated from the current compilation.
public void set uriroot ( string s ) { uri root = s ; if ( s != null ) { try { uri root = new file ( s ) . get canonical path ( ) ; } catch ( exception ex ) { uri root = s ; } } }	Base dir for the webapp. Used to generate class names and resolveincludes.
public void scan files ( file base ) throws jasper exception { stack < string > dirs = new stack < string > ( ) ; dirs . push ( base . to string ( ) ) ; if ( extensions == null ) { extensions = new array list < string > ( ) ; extensions . add ( str ) ; extensions . add ( str ) ; } while ( ! dirs . is empty ( ) ) { string s = dirs . pop ( ) ; file f = new file ( s ) ; if ( f . exists ( ) && f . is directory ( ) ) { string [ ] files = f . list ( ) ; string ext ; for ( int i = num ; ( files != null ) && i < files . length ; i ++ ) { file f2 = new file ( s , files [ i ] ) ; if ( f2 . is directory ( ) ) { dirs . push ( f2 . get path ( ) ) ; } else { string path = f2 . get path ( ) ; string uri = path . substring ( uri root . length ( ) ) ; ext = files [ i ] . substring ( files [ i ] . last index of ( str ) + num ) ; if ( extensions . contains ( ext ) || jsp config . is jsp page ( uri ) ) { pages . add ( path ) ; } } } } } }	Locate all jsp files in the webapp.
private void locate uri root ( file f ) { string t uri base = uri base ; if ( t uri base == null ) { t uri base = str ; } try { if ( f . exists ( ) ) { f = new file ( f . get canonical path ( ) ) ; while ( f != null ) { file g = new file ( f , str ) ; if ( g . exists ( ) && g . is directory ( ) ) { uri root = f . get canonical path ( ) ; uri base = t uri base ; if ( log . is loggable ( level . info ) ) { log . info ( localizer . get message ( str , uri root ) ) ; } break ; } if ( f . exists ( ) && f . is directory ( ) ) { t uri base = str + f . get name ( ) + str + t uri base ; } string f parent = f . get parent ( ) ; if ( f parent == null ) { break ; } else { f = new file ( f parent ) ; }	Find the WEB-INF dir by looking up in the directory tree.This is used if no explicit docbase is set, but only files.XXX Maybe we should require the docbase.
private int move pos ( ) { int avail = move pos ( num , num ) ; if ( avail != num ) { if ( ++ lz pos == integer . max value ) { int normalization offset = integer . max value - cyclic size ; hash . normalize ( normalization offset ) ; normalize ( chain , cyclic size , normalization offset ) ; lz pos -= normalization offset ; } if ( ++ cyclic pos == cyclic size ) cyclic pos = num ; } return avail ; }	Moves to the next byte, checks that there is enough available space,and possibly normalizes the hash tables and the hash chain.
boolean matches ( string string ) throws jasper exception { mark mark = mark ( ) ; int ch = num ; int i = num ; do { ch = next char ( ) ; if ( ( ( char ) ch ) != string . char at ( i ++ ) ) { reset ( mark ) ; return bool ; } } while ( i < string . length ( ) ) ; return bool ; }	search the stream for a match to a string.
boolean matches optional spaces followed by ( string s ) throws jasper exception { mark mark = mark ( ) ; skip spaces ( ) ; boolean result = matches ( s ) ; if ( ! result ) { reset ( mark ) ; } return result ; }	Looks ahead to see if there are optional spaces followed bythe given String.
mark skip until ( string limit ) throws jasper exception { mark ret = null ; int limlen = limit . length ( ) ; int ch ; skip : for ( ret = mark ( ) , ch = next char ( ) ; ch != - num ; ret = mark ( ) , ch = next char ( ) ) { if ( ch == limit . char at ( num ) ) { mark restart = mark ( ) ; for ( int i = num ; i < limlen ; i ++ ) { if ( peek char ( ) == limit . char at ( i ) ) next char ( ) ; else { reset ( restart ) ; continue skip ; } } return ret ; } } return null ; }	Skip until the given string is matched in the stream.When returned, the context is positioned past the end of the match.
mark skip until ignore esc ( string limit ) throws jasper exception { mark ret = null ; int limlen = limit . length ( ) ; int ch ; int prev = str ;	Skip until the given string is matched in the stream, but ignoringchars initially escaped by a '\'.When returned, the context is positioned past the end of the match.
mark skip until e ( string tag ) throws jasper exception { mark ret = skip until ( str + tag ) ; if ( ret != null ) { skip spaces ( ) ; if ( next char ( ) != str ) ret = null ; } return ret ; }	Skip until the given end tag is matched in the stream.When returned, the context is positioned past the end of the tag.
string parse token ( boolean quoted ) throws jasper exception { string builder string buffer = new string builder ( ) ; skip spaces ( ) ; string buffer . set length ( num ) ; if ( ! has more input ( ) ) { return str ; } int ch = peek char ( ) ; if ( quoted ) { if ( ch == str || ch == str ) { char end quote = ch == str ? str : str ;	Parse a space delimited token.If quoted the token will consume all characters up to a matching quote,otherwise, it consumes up to the first delimiter character.
private boolean pop file ( ) throws jasper exception {	Pop a file from the file stack.
public coordinates make unclassified ( ) { if ( this . classifier == null ) { return this ; } return new coordinates ( this . group id , this . artifact id , this . version , this . qualified version , null , this . extension ) ; }	Create an unclassified version of ourself.
public static list < aspect information > filter ids ( final list < aspect information > list , final predicate < string > predicate ) { if ( list == null ) { return null ; } return list . stream ( ) . filter ( ( i ) -> predicate . test ( i . get factory id ( ) ) ) . collect ( collectors . to list ( ) ) ; }	Filter the provided aspect lists by a predicate on the ID.
public string [ ] get missing ids ( final list < aspect information > assigned aspects ) { final set < aspect information > required = new hash set < > ( ) ; add required ( required , this , assigned aspects ) ; return required . stream ( ) . map ( aspect information :: get factory id ) . to array ( size -> new string [ size ] ) ; }	Get all aspect ids which are currently missing but required by thisaspect.
public static void set schema resource prefix ( string prefix ) { if ( prefix != null && prefix . starts with ( str ) ) { schema resource prefix = uencode ( prefix ) ; is schema resource prefix file url = bool ; } else { schema resource prefix = prefix ; is schema resource prefix file url = bool ; } for ( int i = num ; i < cached schema resource paths . length ; i ++ ) { string path = default schema resource paths [ i ] ; int index = path . last index of ( str ) ; if ( index != - num ) { cached schema resource paths [ i ] = schema resource prefix + path . substring ( index + num ) ; } } }	Sets the path prefix URL for .xsd resources.
public static void set dtd resource prefix ( string prefix ) { if ( prefix != null && prefix . starts with ( str ) ) { dtd resource prefix = uencode ( prefix ) ; is dtd resource prefix file url = bool ; } else { dtd resource prefix = prefix ; is dtd resource prefix file url = bool ; } for ( int i = num ; i < cached dtd resource paths . length ; i ++ ) { string path = default dtd resource paths [ i ] ; int index = path . last index of ( str ) ; if ( index != - num ) { cached dtd resource paths [ i ] = dtd resource prefix + path . substring ( index + num ) ; } } }	Sets the path prefix URL for .dtd resources.
protected tree node convert ( tree node parent , node node ) {	Create and return a TreeNode that corresponds to the specified Node,including processing all of the attributes and children nodes.
private static void merge errors ( final binding result binding result , final binding result result ) { if ( binding result == null ) { return ; } result . add errors ( binding result . get local errors ( ) ) ; for ( final map . entry < string , binding result > child : binding result . get children ( ) . entry set ( ) ) { merge errors ( child . get value ( ) , result . get child or add ( child . get key ( ) ) ) ; } }	Merge all errors of this binding into this result.
private void initialize binder ( final binder binder ) { for ( final method m : binder . get class ( ) . get methods ( ) ) { if ( ! m . is annotation present ( binder . initializer . class ) ) { continue ; } final call call = bind ( m , binder ) ; try { call . invoke ( ) ; } catch ( final exception e ) { throw new runtime exception ( string . format ( str , binder , m ) , e ) ; } } }	Initialize the binder with our current state.
public static map < string , channel aspect information > scan aspect informations ( final bundle context context ) { collection < service reference < channel aspect factory > > refs ; try { refs = context . get service references ( channel aspect factory . class , null ) ; } catch ( final invalid syntax exception e ) {	This actively scans for available aspects and returns their informationobjects.
private static string unqualify ( string path ) { path = path . replace ( str , str ) ; return path . substring ( path . last index of ( str ) + num ) ; }	Returns an unqualified version of the given file path.
private void invoke plugin ( node . custom tag n ) { tag plugin tag plugin = tag plugins . get ( n . get tag handler class ( ) . get name ( ) ) ; if ( tag plugin == null ) { return ; } tag plugin context tag plugin context = new tag plugin context impl ( n , page info ) ; n . set tag plugin context ( tag plugin context ) ; tag plugin . do tag ( tag plugin context ) ; }	Invoke tag plugin for the given custom tag, if a plugin exists forthe custom tag's tag handler.The given custom tag node will be manipulated by the plugin.
public byte [ ] get byte array ( int size , boolean fill with zeros ) { byte [ ] array = get array ( byte array cache , size ) ; if ( array == null ) array = new byte [ size ] ; else if ( fill with zeros ) arrays . fill ( array , ( byte ) num ) ; return array ; }	Allocates a new byte array, hopefully reusing an existingarray from the cache.
public int [ ] get int array ( int size , boolean fill with zeros ) { int [ ] array = get array ( int array cache , size ) ; if ( array == null ) array = new int [ size ] ; else if ( fill with zeros ) arrays . fill ( array , num ) ; return array ; }	This is like getByteArray but for int arrays.
public static aether result as result ( final collection < artifact result > results , final import configuration cfg , final optional < dependency result > dependency result ) { final aether result result = new aether result ( ) ;	Convert aether result list to AetherResult object.
private input stream get resource as stream ( string uri ) throws jasper exception { try {	the following is a workaround until these problems are resolved.
public validation message [ ] validate ( page data the page ) { tag library validator tlv = get tag library validator ( ) ; if ( tlv == null ) return null ; string uri = get uri ( ) ; if ( uri . starts with ( str ) ) { uri = urn jsptld + uri ; } validation message [ ] messages = tlv . validate ( get prefix string ( ) , uri , the page ) ; tlv . release ( ) ; return messages ; }	Translation-time validation of the XML documentassociated with the JSP page.This is a convenience method on the associatedTagLibraryValidator class.
public void push stream ( char [ ] in stream , int in fileid , string name , string in base dir , string in encoding ) {	Sets this mark's state to a new stream.It will store the current stream in it's includeStack.
public static object [ ] get encoding ( string fname , jar file jar file , jsp compilation context ctxt , error dispatcher err ) throws io , jasper exception { input stream in stream = jsp util . get input stream ( fname , jar file , ctxt , err ) ; xml detector = new xml ( ) ; object [ ] ret = detector . get encoding ( in stream , err ) ; in stream . close ( ) ; return ret ; }	Autodetects the encoding of the XML document supplied by the giveninput stream.Encoding autodetection is done according to the XML 1.0 specification,Appendix F.1: Detection Without External Encoding Information.
private void report fatal error ( string msg id , string arg ) throws jasper exception { err . jsp error ( msg id , arg ) ; }	Convenience function used in all XML scanners.
public string get real path ( string path ) { if ( ! my resource base url . get protocol ( ) . equals ( str ) ) return ( null ) ; if ( ! path . starts with ( str ) ) return ( null ) ; try { return ( get resource ( path ) . get file ( ) . replace ( str , file . separator char ) ) ; } catch ( throwable t ) { return ( null ) ; } }	Return the real path for the specified context-relativevirtual path.
public url get resource ( string path ) throws url { if ( ! path . starts with ( str ) ) throw new url ( str + path + str ) ; url url = new url ( my resource base url , path . substring ( num ) ) ; input stream is = null ; try { is = url . open stream ( ) ; } catch ( throwable t ) { url = null ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( throwable t2 ) {	Return a URL object of a resource that is mapped to thespecified context-relative path.
public input stream get resource as stream ( string path ) { try { return ( get resource ( path ) . open stream ( ) ) ; } catch ( throwable t ) { return ( null ) ; } }	Return an InputStream allowing access to the resource at thespecified context-relative path.
public set < string > get resource paths ( string path ) { set < string > the paths = new hash set < string > ( ) ; if ( ! path . ends with ( str ) ) path += str ; string base path = get real path ( path ) ; if ( base path == null ) return ( the paths ) ; file the base dir = new file ( base path ) ; if ( ! the base dir . exists ( ) || ! the base dir . is directory ( ) ) return ( the paths ) ; string the files [ ] = the base dir . list ( ) ; for ( int i = num ; i < the files . length ; i ++ ) { file test file = new file ( base path + file . separator + the files [ i ] ) ; if ( test file . is file ( ) ) the paths . add ( path + the files [ i ] ) ; else if ( test file . is directory ( ) ) the paths . add ( path + the files [ i ] + str ) ; } return ( the paths ) ; }	Return the set of resource paths for the "directory" at thespecified context path.
public void log ( string message , throwable exception ) { my log writer . println ( message ) ; exception . print stack trace ( my log writer ) ; }	Log the specified message and exception.
public void add filter ( string filter name , string description , string class name , map < string , string > init parameters ) {	Adds the filter with the given name, description, and class name tothis servlet context.
private static int get buf size ( int dict size , int extra size before , int extra size after , int match len max ) { int keep size before = extra size before + dict size ; int keep size after = extra size after + match len max ; int reserve size = math . min ( dict size / num + ( num << num ) , num << num ) ; return keep size before + keep size after + reserve size ; }	Gets the size of the LZ window buffer that needs to be allocated.
public static int get memory usage ( int dict size , int extra size before , int extra size after , int match len max , int mf ) {	Gets approximate memory usage of the LZEncoder base structure andthe match finder as kibibytes.
public void set preset dict ( int dict size , byte [ ] preset dict ) { assert ! is started ( ) ; assert write pos == num ; if ( preset dict != null ) {	Sets a preset dictionary.
private void move window ( ) {	Moves data from the end of the buffer to the beginning, discardingold data and making space for new input.
public int fill window ( byte [ ] in , int off , int len ) { assert ! finishing ;	Copies new data into the LZEncoder's buffer.
private void process pending bytes ( ) {	Process pending bytes remaining from preset dictionary initializationor encoder flush operation.
public int get match len ( int dist , int len limit ) { int back pos = read pos - dist - num ; int len = num ; while ( len < len limit && buf [ read pos + len ] == buf [ back pos + len ] ) ++ len ; return len ; }	Get the length of a match at the given distance.
public int get match len ( int forward , int dist , int len limit ) { int cur pos = read pos + forward ; int back pos = cur pos - dist - num ; int len = num ; while ( len < len limit && buf [ cur pos + len ] == buf [ back pos + len ] ) ++ len ; return len ; }	Get the length of a match at the given distance and forward offset.
public boolean verify matches ( matches matches ) { int len limit = math . min ( get avail ( ) , match len max ) ; for ( int i = num ; i < matches . count ; ++ i ) if ( get match len ( matches . dist [ i ] , len limit ) != matches . len [ i ] ) return bool ; return bool ; }	Verifies that the matches returned by the match finder are valid.This is meant to be used in an assert statement.
int move pos ( int required for flushing , int required for finishing ) { assert required for flushing >= required for finishing ; ++ read pos ; int avail = write pos - read pos ; if ( avail < required for flushing ) { if ( avail < required for finishing || ! finishing ) { ++ pending size ; avail = num ; } } return avail ; }	Moves to the next byte, checks if there is enough input available,and returns the amount of input available.
void recycle ( ) { flushed = bool ; closed = bool ; out = null ; byte out = null ; release char buffer ( ) ; response = null ; }	Package-level access.
protected final void flush buffer ( ) throws io { if ( buffer size == num ) return ; flushed = bool ; ensure open ( ) ; if ( buf . pos == buf . offset ) return ; init out ( ) ; out . write ( buf . buf , buf . offset , buf . pos - buf . offset ) ; buf . pos = buf . offset ; }	Flush the output buffer to the underlying character stream, withoutflushing the stream itself.
public final void clear ( ) throws io { if ( ( buffer size == num ) && ( out != null ) )	Discard the output buffer.
public void flush ( ) throws io { flush buffer ( ) ; if ( out != null ) { out . flush ( ) ; }	Flush the stream.
public void close ( ) throws io { if ( response == null || closed )	Close the stream.
public void write ( boolean bytes ok , byte buf [ ] , string str ) throws io { ensure open ( ) ; if ( buffer size == num && bytes ok ) { init byte out ( ) ; if ( implements byte writer ) { write ( buf , num , buf . length ) ; return ; } } write ( str ) ; }	Attempt to write a String pre-encoded with the page encoding.
public void javac error ( string error report , exception exception ) throws jasper exception { throw new jasper exception ( localizer . get message ( str ) , exception ) ; }	Processes the given javac error report and exception.
public list < string > make key ( final map < meta key , string > meta data , final boolean require all ) { final list < string > result = new array list < > ( this . fields . size ( ) ) ; for ( final meta key field : this . fields ) { final string value = meta data . get ( field ) ; if ( require all && value == null ) { return null ; } result . add ( value ) ; } return result ; }	Make a key from the aggregator fields.
private void generate class ( ) throws file not found exception , jasper exception , exception { long t1 = num ; if ( log . is loggable ( level . fine ) ) { t1 = system . current time millis ( ) ; } string java file name = ctxt . get servlet java file name ( ) ; set java compiler options ( ) ;	Compile the servlet from .java file to .class file.
public void compile ( boolean compile class ) throws file not found exception , jasper exception , exception { try {	Compile the jsp file from the current engine context.
private void init java compiler ( ) throws jasper exception { boolean disablejsr199 = boolean . true . to string ( ) . equals ( system . get property ( str ) ) ; double version = double . value of ( system . get property ( str ) ) ; if ( ! disablejsr199 && ( version >= num || get class for ( str ) != null ) ) {	Get an instance of JavaCompiler.If Running with JDK 6, use a Jsr199JavaCompiler that supports JSR199,else if eclipse's JDT compiler is available, use that.The default is to use javac from ant.
private boolean system jar in webinf ( string path ) { if ( path . index of ( str ) < num ) { return bool ; } boolean use my faces = ( boolean ) ctxt . get servlet context ( ) . get attribute ( str ) ; if ( use my faces == null || ! use my faces ) { for ( string jar : system jsf jars ) { if ( path . index of ( jar ) > num ) { return bool ; } } } for ( string jar : system jars ) { if ( path . index of ( jar ) > num ) { return bool ; } } return bool ; }	Return true if the path refers to a jar file in WEB-INF and is asystem jar.
static string quote ( char c ) { string builder b = new string builder ( ) ; b . append ( str ) ; if ( c == str ) b . append ( str ) . append ( str ) ; else if ( c == str ) b . append ( str ) . append ( str ) ; else if ( c == str ) b . append ( str ) . append ( str ) ; else if ( c == str ) b . append ( str ) . append ( str ) ; else b . append ( c ) ; b . append ( str ) ; return b . to string ( ) ; }	Single quote and escape a character.
private void generate declarations ( node . nodes page ) throws jasper exception { class declaration visitor extends node . visitor { private boolean get servlet info generated = bool ; public void visit ( node . page directive n ) throws jasper exception { if ( get servlet info generated ) { return ; } string info = n . get attribute value ( str ) ; if ( info == null ) return ; get servlet info generated = bool ; out . printil ( str ) ; out . push indent ( ) ; out . printin ( str ) ; out . print ( quote ( info ) ) ; out . println ( str ) ; out . pop indent ( ) ; out . printil ( str ) ; out . println ( ) ; } public void visit ( node . declaration n ) throws jasper exception { n . set begin java line ( out . get java line ( ) ) ; out . print multi ln ( n . get text ( ) ) ; out . println ( ) ; n . set end java line ( out . get java line ( ) ) ; }	Generates declarations. This includes "info" of the page directive,and scriptlet declarations.
private void compile tag handler pool list ( node . nodes page ) throws jasper exception { class tag handler pool visitor extends node . visitor { private set < string > names = new hash set < string > ( ) ; tag handler pool visitor ( set < string > v ) { names = v ; } public void visit ( node . custom tag n ) throws jasper exception { if ( ! n . implements simple tag ( ) ) { string name = create tag handler pool name ( n . get prefix ( ) , n . get local name ( ) , n . get attributes ( ) , n . has empty body ( ) ) ; n . set tag handler pool name ( name ) ; if ( ! names . contains ( name ) ) { names . add ( name ) ; } } visit body ( n ) ; } private string create tag handler pool name ( string prefix , string short name , attributes attrs , boolean has empty body ) { string pool name = null ; pool name = str + prefix + str + short name ; if ( attrs != null ) { string [ ] attr names = new string [ attrs . get length ( ) ] ; for ( int i = num ; i < attr names . length ; i ++ ) { attr names [ i ] = attrs . get q ( i ) ; } arrays . sort ( attr names , collections . reverse order ( ) ) ; for ( int i = num ; i < attr names . length ; i ++ ) { pool name = pool name + str + attr names [ i ] ; } } if ( has empty body ) { pool name = pool name + str ; } return jsp util . make xml java identifier ( pool name ) ; } } page . visit ( new tag handler pool visitor ( tag handler pool names ) ) ; }	Compiles list of tag handler pool names.
private void generate xml prolog ( node . nodes page ) { string omit xml decl = page info . get omit xml decl ( ) ; if ( ( omit xml decl != null && ! jsp util . boolean value ( omit xml decl ) ) || ( omit xml decl == null && page . get root ( ) . is xml syntax ( ) && ! page info . has jsp root ( ) && ! ctxt . is tag file ( ) ) ) { string c type = page info . get content type ( ) ; string char set = c type . substring ( c type . index of ( str ) + num ) ; out . printil ( str + char set + str ) ; } string doctype name = page info . get doctype name ( ) ; if ( doctype name != null ) { string doctype public = page info . get doctype public ( ) ; string doctype system = page info . get doctype system ( ) ; out . printin ( str ) ; out . print ( doctype name ) ; if ( doctype public == null ) { out . print ( str ) ; } else { out . print ( str ) ; out . print ( doctype public ) ; out . print ( str ) ; } out . print ( doctype system ) ; out . println ( str ) ; } }	Generates an XML Prolog, which includes an XML declaration andan XML doctype declaration.
private void gen common postamble ( ) {	Common part of postamble, shared by both servlets and tag files.
private void generate postamble ( node . nodes page ) { out . pop indent ( ) ; out . printil ( str ) ; out . push indent ( ) ; out . printil ( str ) ; out . push indent ( ) ; out . printil ( str ) ; out . printil ( str ) ; out . push indent ( ) ; out . printil ( str ) ; out . pop indent ( ) ; out . printil ( str ) ; out . printil ( str ) ; out . pop indent ( ) ; out . printil ( str ) ; out . pop indent ( ) ; out . printil ( str ) ; out . push indent ( ) ; out . printil ( str ) ; out . pop indent ( ) ; out . printil ( str ) ;	Generates the ending part of the static portion of the servlet.
public static void generate ( servlet writer out , compiler compiler , node . nodes page ) throws jasper exception { generator gen = new generator ( out , compiler ) ; if ( gen . is pooling enabled ) { gen . compile tag handler pool list ( page ) ; } if ( gen . ctxt . is tag file ( ) ) { jasper tag info tag info = ( jasper tag info ) gen . ctxt . get tag info ( ) ; gen . generate tag handler preamble ( tag info , page ) ; if ( gen . ctxt . is prototype mode ( ) ) { return ; } gen . generate xml prolog ( page ) ; gen . fragment helper class . generate preamble ( ) ; page . visit ( gen . new generate visitor ( gen . ctxt . is tag file ( ) , out , gen . methods buffered , gen . fragment helper class ) ) ; gen . generate tag handler postamble ( tag info ) ; } else { gen . generate preamble ( page ) ; gen . generate xml prolog ( page ) ; gen . fragment helper class . generate preamble ( ) ; page . visit ( gen . new generate visitor ( gen . ctxt . is tag file ( ) , out , gen . methods buffered , gen . fragment helper class ) ) ; gen . generate postamble ( page ) ; } }	The main entry for Generator.
private void generate tag handler attributes ( tag info tag info ) throws jasper exception { if ( tag info . has dynamic attributes ( ) ) { out . printil ( str ) ; }	Generates declarations for tag handler attributes, and defines thegetter and setter methods for each.
private map < meta key , string > read properties ( final input stream stream ) throws io { try {	Read in a map of properties.
private void export channel ( final by by , final output stream stream ) throws io { final zip output stream zos = new zip output stream ( stream ) ; init export file ( zos ) ; this . channel service . access run ( by , readable channel . class , channel -> { put data entry ( zos , str , make names ( channel . get id ( ) ) ) ; put data entry ( zos , str , channel . get id ( ) . get description ( ) ) ; put dir entry ( zos , str ) ; put properties ( zos , str , channel . get context ( ) . get provided meta data ( ) ) ; put aspects ( zos , channel . get context ( ) . get aspect states ( ) . key set ( ) ) ;	Export the content of a channel.
private static void validate xml view ( page data xml view , compiler compiler ) throws jasper exception { string builder err msg = null ; error dispatcher err disp = compiler . get error dispatcher ( ) ; for ( iterator < tag library info > iter = compiler . get page info ( ) . get taglibs ( ) . iterator ( ) ; iter . has next ( ) ; ) { tag library info o = iter . next ( ) ; if ( ! ( o instanceof tag library info impl ) ) continue ; tag library info impl tli = ( tag library info impl ) o ; validation message [ ] errors = tli . validate ( xml view ) ; if ( ( errors != null ) && ( errors . length != num ) ) { if ( err msg == null ) { err msg = new string builder ( ) ; } err msg . append ( str ) ; err msg . append ( localizer . get message ( str , tli . get short name ( ) ) ) ; err msg . append ( str ) ; for ( int i = num ; i < errors . length ; i ++ ) { if ( errors [ i ] != null ) { err msg . append ( str ) ; err msg . append ( errors [ i ] . get id ( ) ) ; err msg . append ( str ) ; err msg . append ( errors [ i ] . get message ( ) ) ; err msg . append ( str ) ; } } } } if ( err msg != null ) { err disp . jsp error ( err msg . to string ( ) ) ; } }	Validate XML view against the TagLibraryValidator classes of allimported tag libraries.
public < t extends jsp tag > jsp tag get ( class < t > handler class ) throws jsp exception { synchronized ( this ) { if ( current >= num ) { return handlers [ current -- ] ; } }	Gets the next available tag handler from this tag handler pool,instantiating one if this tag handler pool is empty.
public static el . nodes parse ( string expression ) { el parser = new el ( expression ) ; while ( parser . has next char ( ) ) { string text = parser . skip until el ( ) ; if ( text . length ( ) > num ) { parser . expr . add ( new el . text ( text ) ) ; } el . nodes elexpr = parser . parse el ( ) ; if ( ! elexpr . is empty ( ) ) { parser . expr . add ( new el . root ( elexpr , parser . is dollar expr ) ) ; } } return parser . expr ; }	Parse an EL expression.
private jsp property group select property ( jsp property group prev , jsp property group curr ) { if ( prev == null ) { return curr ; } if ( prev . get extension ( ) == null ) {	Select the property group that has more restrictive url-pattern.In case of tie, select the first.
public boolean is jsp page ( string uri ) throws jasper exception { init ( ) ; if ( jsp properties == null ) { return bool ; } string uri path = null ; int index = uri . last index of ( str ) ; if ( index >= num ) { uri path = uri . substring ( num , index + num ) ; } string uri extension = null ; index = uri . last index of ( str ) ; if ( index >= num ) { uri extension = uri . substring ( index + num ) ; } for ( jsp property group jpg : jsp properties ) { jsp property jp = jpg . get jsp property ( ) ; string extension = jpg . get extension ( ) ; string path = jpg . get path ( ) ; if ( extension == null ) { if ( uri . equals ( path ) ) {	To find out if an uri matches an url pattern in jsp config.
public void print comment ( mark start , mark stop , char [ ] chars ) { if ( start != null && stop != null ) { println ( str + start ) ; println ( str + stop ) ; } if ( chars != null ) for ( int i = num ; i < chars . length ; ) { printin ( ) ; print ( str ) ; while ( chars [ i ] != str && i < chars . length ) writer . print ( chars [ i ++ ] ) ; } }	Print a standard comment for echo outputed chunk.
public void printin ( string s ) { writer . print ( spaces . substring ( num , indent ) ) ; writer . print ( s ) ; }	Prints the current indention, followed by the given string.
public void printil ( string s ) { java line ++ ; writer . print ( spaces . substring ( num , indent ) ) ; writer . println ( s ) ; }	Prints the current indention, and then the string, and a '\n'.
public void print multi ln ( string s ) { int index = num ;	Prints the given string.If the string spans multiple lines, the line count will be adjustedaccordingly.
public static string get expr in xml ( string expression ) { string return string ; int length = expression . length ( ) ; if ( expression . starts with ( open expr ) && expression . ends with ( close expr ) ) { return string = expression . substring ( num , length - num ) ; } else { return string = expression ; } return escape xml ( return string ) ; }	Takes a potential expression and converts it into XML form.
public static void check scope ( string scope , node n , error dispatcher err ) throws jasper exception { if ( scope != null && ! scope . equals ( str ) && ! scope . equals ( str ) && ! scope . equals ( str ) && ! scope . equals ( str ) ) { err . jsp error ( n , str , scope ) ; } }	Checks to see if the given scope is valid.
public static string escape xml ( string s ) { if ( s == null ) return null ; string builder sb = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char c = s . char at ( i ) ; if ( c == str ) { sb . append ( str ) ; } else if ( c == str ) { sb . append ( str ) ; } else if ( c == str ) { sb . append ( str ) ; } else if ( c == str ) { sb . append ( str ) ; } else if ( c == str ) { sb . append ( str ) ; } else { sb . append ( c ) ; } } return sb . to string ( ) ; }	Escape the 5 entities defined by XML.
public static void validate expressions ( mark where , string expressions , function mapper function mapper , error dispatcher err ) throws jasper exception { try { el el context = new el ( null ) ; el context . set function mapper ( function mapper ) ; get expression factory ( ) . create value expression ( el context , expressions , object . class ) ; } catch ( el e ) { err . jsp error ( where , str , expressions , e . to string ( ) ) ; } }	Validates the syntax of all EL expressions within the given string.
public static string get tag handler class name ( string path , error dispatcher err ) throws jasper exception { string class name = null ; int begin = num ; int index ; index = path . last index of ( str ) ; if ( index == - num ) { err . jsp error ( str , path ) ; }	Gets the fully-qualified class name of the tag handler corresponding tothe given tag file path.
public static final string make java package ( string path ) { string class name components [ ] = split ( path , str ) ; string builder legal class names = new string builder ( ) ; for ( int i = num ; i < class name components . length ; i ++ ) { legal class names . append ( make java identifier ( class name components [ i ] ) ) ; if ( i < class name components . length - num ) { legal class names . append ( str ) ; } } return legal class names . to string ( ) ; }	Converts the given path to a Java package or fully-qualified class name.
private static final string [ ] split ( string path , string pat ) { array list < string > comps = new array list < string > ( ) ; int pos = path . index of ( pat ) ; int start = num ; while ( pos >= num ) { if ( pos > start ) { string comp = path . substring ( start , pos ) ; comps . add ( comp ) ; } start = pos + pat . length ( ) ; pos = path . index of ( pat , start ) ; } if ( start < path . length ( ) ) { comps . add ( path . substring ( start ) ) ; } string [ ] result = new string [ comps . size ( ) ] ; for ( int i = num ; i < comps . size ( ) ; i ++ ) { result [ i ] = comps . get ( i ) ; } return result ; }	Splits a string into it's components.
public static final string make java identifier ( string identifier ) { string builder modified identifier = new string builder ( identifier . length ( ) ) ; if ( ! character . is java identifier start ( identifier . char at ( num ) ) ) { modified identifier . append ( str ) ; } for ( int i = num ; i < identifier . length ( ) ; i ++ ) { char ch = identifier . char at ( i ) ; if ( character . is java identifier part ( ch ) && ch != str ) { modified identifier . append ( ch ) ; } else if ( ch == str ) { modified identifier . append ( str ) ; } else { modified identifier . append ( mangle char ( ch ) ) ; } } if ( is java keyword ( modified identifier . to string ( ) ) ) { modified identifier . append ( str ) ; } return modified identifier . to string ( ) ; }	Converts the given identifier to a legal Java identifier.
public static final string mangle char ( char ch ) { char [ ] result = new char [ num ] ; result [ num ] = str ; result [ num ] = character . for digit ( ( ch > > num ) & num , num ) ; result [ num ] = character . for digit ( ( ch > > num ) & num , num ) ; result [ num ] = character . for digit ( ( ch > > num ) & num , num ) ; result [ num ] = character . for digit ( ch & num , num ) ; return new string ( result ) ; }	Mangle the specified character to create a legal Java class name.
public static boolean is java keyword ( string key ) { int i = num ; int j = java keywords . length ; while ( i < j ) { int k = ( i + j ) / num ; int result = java keywords [ k ] . compare to ( key ) ; if ( result == num ) { return bool ; } if ( result < num ) { i = k + num ; } else { j = k ; } } return bool ; }	Test whether the argument is a Java keyword.
private static void add property ( final map < string , string > props , final string key , final string value ) { if ( value == null ) { return ; } props . put ( key , value ) ; }	Add property entry only of value is not null.
public static string modifier ( final string prefix , final modifier modifier ) { if ( modifier == null ) { return str ; } string value = null ; switch ( modifier ) { case default : value = str ; break ; case primary : value = str ; break ; case success : value = str ; break ; case info : value = str ; break ; case warning : value = str ; break ; case danger : value = str ; break ; case link : value = str ; break ; } if ( value != null && prefix != null ) { return prefix + value ; } else { return value != null ? value : str ; } }	Convert a modifier value to a bootstrap type modifier.
public static sorted set < string > metadata ( final map < meta key , string > metadata , string namespace , string key ) { final sorted set < string > result = new tree set < > ( ) ; if ( namespace . is empty ( ) ) { namespace = null ; } if ( key . is empty ( ) ) { key = null ; } for ( final map . entry < meta key , string > entry : metadata . entry set ( ) ) { if ( namespace != null && ! namespace . equals ( entry . get key ( ) . get namespace ( ) ) ) { continue ; } if ( key != null && ! key . equals ( entry . get key ( ) . get key ( ) ) ) { continue ; } result . add ( entry . get value ( ) ) ; } return result ; }	Get all meta data values which match namespace and key.
@ override public void run ( ) throws exception { this . storage manager . modify run ( model key , user write model . class , users -> { final date timeout = new date ( system . current time millis ( ) - get timeout ( ) ) ; final collection < user entity > updates = new linked list < > ( ) ; final collection < string > removals = new linked list < > ( ) ; for ( final user entity user : users . as collection ( ) ) { if ( user . get email token date ( ) == null || user . get email token date ( ) . after ( timeout ) ) { continue ; }	Clean up timed out user registrations.
public static string get basename ( final string name ) { if ( name == null ) { return null ; } final string [ ] toks = name . split ( str ) ; if ( toks . length < num ) { return name ; } return toks [ toks . length - num ] ; }	Get the last segment of a path, the filename.
public boolean put ( locator locator , string key , string value ) throws cache exception { if ( value == null ) return bool ; timer . context cache put timer context = metadata cache . cache put timer . time ( ) ; boolean db write = bool ; try { cache key cache key = new cache key ( locator , key ) ; string old value = cache . get if present ( cache key ) ;	returns true if updated.
private string database load ( locator locator , string key ) throws cache exception { try { cache key cache key = new cache key ( locator , key ) ; map < string , string > metadata = io . get all values ( locator ) ; if ( metadata == null || metadata . is empty ( ) ) { cache . put ( cache key , null ) ; return null ; } int metadata row size = num ;	implements the CacheLoader interface.
public static collection < i > build metrics collection ( aggregated payload payload ) { collection < i > metrics = new array list < i > ( ) ; metrics . add all ( preaggregate conversions . convert counters ( payload . get tenant id ( ) , payload . get timestamp ( ) , payload . get flush interval millis ( ) , payload . get counters ( ) ) ) ; metrics . add all ( preaggregate conversions . convert gauges ( payload . get tenant id ( ) , payload . get timestamp ( ) , payload . get gauges ( ) ) ) ; metrics . add all ( preaggregate conversions . convert sets ( payload . get tenant id ( ) , payload . get timestamp ( ) , payload . get sets ( ) ) ) ; metrics . add all ( preaggregate conversions . convert timers ( payload . get tenant id ( ) , payload . get timestamp ( ) , payload . get timers ( ) ) ) ; return metrics ; }	type comparisions we use to determine how to serialize a number.
public static number resolve number ( number n ) { if ( n instanceof lazily parsed number ) { try { return n . long value ( ) ; } catch ( number format exception ex ) { return n . double value ( ) ; } } else {	resolve a number to a Long or double.
private static void write to output stream ( object obj , coded output stream out ) throws io { out . write raw byte ( string ) ; out . write string no tag ( ( string ) obj ) ; }	writes object to CodedOutputStream.
protected int get ttl ( locator locator , rollup type rollup type , granularity granularity ) { return ( int ) ttl provider . get ttl ( locator . get tenant id ( ) , granularity , rollup type ) . get ( ) . to seconds ( ) ; }	Gets the TTL for a particular locator, rollupType and granularity.
private void create prepared statements ( ) {	Create all prepared statements use in this class for metrics_locator.
public void track delayed metrics tenant ( string tenantid , final list < metric > delayed metrics ) { if ( is tracking delayed metrics ) { string log message = string . format ( str , tenantid ) ; log . info ( log message ) ;	This method is used to log delayed metrics, if tracking delayed metricsis turned on for this Blueflood service.
public void track delayed aggregated metrics tenant ( string tenant id , long collection time ms , long delay time ms , list < string > delayed metric names ) { if ( is tracking delayed metrics ) { string log message = string . format ( str , tenant id ) ; log . info ( log message ) ;	This method logs the delayed aggregated metrics for a particular tenant,if tracking delayed metric is turned on for this Blueflood service.Aggregated metrics have one single timestamp for the group of metrics thatare sent in one request.
protected number get unversioned double or long ( coded input stream in ) throws io { byte type = in . read raw byte ( ) ; if ( type == constants . b double ) return in . read double ( ) ; else return in . read raw varint64 ( ) ; }	read out a type-specified number.
protected void put unversioned double or long ( number number , coded output stream out ) throws io { if ( number instanceof double ) { out . write raw byte ( constants . b double ) ; out . write double no tag ( number . double value ( ) ) ; } else { out . write raw byte ( constants . b ) ; out . write raw varint64 ( number . long value ( ) ) ; } }	put out a number prefaced only by a type.
public map < object , object > get all properties ( ) { map < object , object > map = new hash map < object , object > ( ) ; for ( object key : default props . key set ( ) ) { map . put ( key , default props . get property ( key . to string ( ) ) ) ; } for ( object key : props . key set ( ) ) { map . put ( key , props . get property ( key . to string ( ) ) ) ; } return collections . unmodifiable map ( map ) ; }	Convert the existing configuration values into a Map, including those specified in defaultProps.
private void create container ( ) { string container name = container date format . format ( new date ( ) ) ; blob store . create container in location ( null , container name ) ; last container created = container name ; }	idempotent other than when the month changes between two calls.
void schedule eligible slots ( long max age millis , long rollup delay for metrics with short delay , long rollup wait for metrics with long delay ) { long now = schedule time ; array list < integer > shard keys = new array list < integer > ( shard state manager . get managed shards ( ) ) ; collections . shuffle ( shard keys ) ; for ( int shard : shard keys ) { for ( granularity g : granularity . rollup granularities ( ) ) {	only one thread should be calling in this puppy.
void clear from running ( slot key slot key ) { synchronized ( running slots ) { running slots . remove ( slot key ) ; update stamp stamp = shard state manager . get update stamp ( slot key ) ; shard state manager . set all coarser slots dirty for slot ( slot key ) ;	Remove the given slot from the running group after it has beensuccessfully re-rolled.
public emitter on ( string event , listener fn ) { concurrent linked queue < listener > callbacks = this . callbacks . get ( event ) ; if ( callbacks == null ) { callbacks = new concurrent linked queue < listener > ( ) ; concurrent linked queue < listener > callbacks = this . callbacks . put if absent ( event , callbacks ) ; if ( callbacks != null ) { callbacks = callbacks ; } } callbacks . add ( fn ) ; return this ; }	Listens on the event.
public emitter once ( final string event , final listener < t > fn ) { listener on = new listener < t > ( ) { @ override public void call ( t ... args ) { emitter . this . off ( event , this ) ; fn . call ( args ) ; } } ; this . once callbacks . put ( fn , on ) ; this . on ( event , on ) ; return this ; }	Adds a one time listener for the event.
public emitter off ( string event ) { concurrent linked queue < listener > callbacks = this . callbacks . remove ( event ) ; if ( callbacks != null ) { for ( listener fn : callbacks ) { this . once callbacks . remove ( fn ) ; } } return this ; }	Removes all listeners of the specified event.
public future emit ( string event , t ... args ) { concurrent linked queue < listener > callbacks = this . callbacks . get ( event ) ; if ( callbacks != null ) { callbacks = new concurrent linked queue < listener > ( callbacks ) ; for ( listener fn : callbacks ) { fn . call ( args ) ; } } return null ; }	Executes each of listeners with the given args.
public list < listener > listeners ( string event ) { concurrent linked queue < listener > callbacks = this . callbacks . get ( event ) ; return callbacks != null ? new array list < listener > ( callbacks ) : new array list < listener > ( ) ; }	Returns a list of listeners for the specified event.
public string get remote name ( ) { date time = new date ( timestamp ) ; string formatted time = new simple date format ( str ) . format ( time ) ; return formatted time + system . current time millis ( ) + str + configuration . get instance ( ) . get string property ( cloudfiles config . cloudfiles host unique identifier ) ; }	Get the remote file name.
public void append ( rollup event rollup ) throws io { ensure open ( ) ; output stream . write ( serializer . to bytes ( rollup ) ) ; output stream . write ( str ) ; output stream . flush ( ) ; }	Serialize a Rollup Event and append it to the file.
private static long parse timestamp ( string file name ) throws number format exception { string number part = file name . substring ( num , file name . length ( ) - num ) ; return long . parse long ( number part ) ; }	Parse the timestamp from a filename.
public void start server ( ) throws interrupted exception { route matcher router = new route matcher ( ) ; router . get ( str , new default handler ( ) ) ; router . post ( str , new http multitenant metrics ingestion handler ( processor , timeout , enable per tenant metrics ) ) ; router . post ( str , new http metrics ingestion handler ( processor , timeout , enable per tenant metrics ) ) ; router . post ( str , new http aggregated ingestion handler ( processor , timeout , enable per tenant metrics ) ) ; router . get ( str , new default handler ( ) ) ; router . post ( str , new http multitenant metrics ingestion handler ( processor , timeout , enable per tenant metrics ) ) ; router . post ( str , new http metrics ingestion handler ( processor , timeout , enable per tenant metrics ) ) ; router . post ( str , new http aggregated ingestion handler ( processor , timeout , enable per tenant metrics ) ) ; router . post ( str , new http aggregated multi ingestion handler ( processor , timeout , enable per tenant metrics ) ) ; router . post ( str , get http events ingestion handler ( ) ) ; final route matcher final router = router ; log . info ( str , http ingest port ) ; server bootstrap server = new server bootstrap ( ) ; server . group ( acceptor group , worker group ) . channel ( nio server socket channel . class ) . child handler ( new channel initializer < socket channel > ( ) { @ override public void init channel ( socket channel channel ) throws exception { setup pipeline ( channel , final router ) ; } } ) ; channel channel = server . bind ( new inet socket address ( http ingest host , http ingest port ) ) . sync ( ) . channel ( ) ; all open channels . add ( channel ) ;	Starts the Ingest server.
public static rollup . type get rollup computer ( rollup type src type , granularity src gran ) { switch ( src type ) { case counter : return rollup . counter from counter ; case timer : return rollup . timer from timer ; case gauge : return rollup . gauge from gauge ; case bf basic : return src gran == granularity . full ? rollup . basic from raw : rollup . basic from basic ; case set : return rollup . set from set ; default : break ; } throw new illegal argument exception ( string . format ( str , src type . name ( ) , src gran . short name ( ) ) ) ; }	determine which DataType to use for serialization.
public static synchronized io from config ( ) { if ( from config instance == null ) { string driver = configuration . get string property ( core config . cassandra driver ) ; log . info ( string . format ( str , driver ) ) ; boolean is recording delayed metrics = configuration . get boolean property ( core config . record delayed metrics ) ; log . info ( string . format ( str , is recording delayed metrics ) ) ; boolean is dtx ingest batch enabled = configuration . get boolean property ( core config . enable dtx ingest batch ) ; log . info ( string . format ( str , is dtx ingest batch enabled ) ) ; from config instance = new io ( driver type . get driver type ( driver ) , is recording delayed metrics , is dtx ingest batch enabled ) ; } return from config instance ; }	Returns an instance of this class based on what configuration says ourdriver should be.
private boolean put ( immutable table . builder < granularity , rollup type , time value > ttl map builder , configuration config , granularity gran , rollup type rollup type , ttl config config key ) { int value ; try { value = config . get integer property ( config key ) ; if ( value < num ) return bool ; } catch ( number format exception ex ) { log . trace ( string . format ( str , gran . name ( ) , rollup type . name ( ) ) , ex ) ; return bool ; } ttl map builder . put ( gran , rollup type , new time value ( value , time unit . days ) ) ; return bool ; }	Helper function to build the ttl mapping.
public static int [ ] compute maximums ( string [ ] headers , output formatter ... outputs ) { int [ ] max = new int [ headers . length ] ; for ( int i = num ; i < headers . length ; i ++ ) max [ i ] = headers [ i ] . length ( ) ; for ( output formatter output : outputs ) { max [ num ] = math . max ( output . host . length ( ) , max [ num ] ) ; for ( int i = num ; i < headers . length ; i ++ ) max [ i ] = math . max ( output . results [ i - num ] . length ( ) , max [ i ] ) ; } return max ; }	compute the maximum width for each field across a collection of formatters.
public static string format header ( int [ ] maximums , string [ ] headers ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < headers . length ; i ++ ) sb = sb . append ( format in ( headers [ i ] , maximums [ i ] , bool ) ) . append ( gap ) ; return sb . to string ( ) ; }	formats a header row after maximums have been established.
public static string [ ] format ( int [ ] maximums , output formatter ... outputs ) { string [ ] formatted strings = new string [ outputs . length ] ; int pos = num ; for ( output formatter output : outputs ) { string builder sb = new string builder ( ) ; sb = sb . append ( format in ( output . host , maximums [ num ] , bool ) ) ; for ( int i = num ; i < output . results . length ; i ++ ) sb = sb . append ( gap ) . append ( format in ( output . results [ i ] , maximums [ i + num ] , bool ) ) ; formatted strings [ pos ++ ] = sb . to string ( ) ; } return formatted strings ; }	formats results and sets formattedStrings.
private void register metrics ( final object name name obj , metric registry reg ) { reg . register ( metric registry . name ( zk . class , str ) , new jmx attribute gauge ( name obj , str ) ) ; reg . register ( metric registry . name ( zk . class , str ) , new jmx attribute gauge ( name obj , str ) ) ; reg . register ( metric registry . name ( zk . class , str ) , new jmx attribute gauge ( name obj , str ) ) ; reg . register ( metric registry . name ( zk . class , str ) , new jmx attribute gauge ( name obj , str ) { @ override public object get value ( ) { object val = super . get value ( ) ; if ( val . equals ( str ) ) { return num ; } return num ; } } ) ; reg . register ( metric registry . name ( zk . class , str ) , new gauge < integer > ( ) { @ override public integer get value ( ) { return get held shards ( ) . size ( ) ; } } ) ; reg . register ( metric registry . name ( zk . class , str ) , new gauge < integer > ( ) { @ override public integer get value ( ) { return get unheld shards ( ) . size ( ) ; } } ) ; reg . register ( metric registry . name ( zk . class , str ) , new gauge < integer > ( ) { @ override public integer get value ( ) { return get error shards ( ) . size ( ) ; } } ) ; }	Registers the different ZooKeeper metrics.
public thread pool builder with name ( string name ) {	Set the threadpool name.
public void add ( string metric index , long doc count ) { final string [ ] tokens = metric index . split ( metric token separator regex ) ; switch ( tokens . length - base level ) { case num : if ( base level > num ) { metric names with next level set . add ( metric index . substring ( num , metric index . last index of ( str ) ) ) ; } else { metric names with next level set . add ( metric index . substring ( num , metric index . index of ( str ) ) ) ; }	For a given metricIndex and docCount, classifies the data with respect to baseLeveland stores it accordingly.
private set < string > get complete metric names ( map < string , metric index doc count > metric index map ) { set < string > complete metric names = new hash set < string > ( ) ; for ( map . entry < string , metric index doc count > entry : metric index map . entry set ( ) ) { metric index doc count metric index doc count = entry . get value ( ) ; if ( metric index doc count != null ) {	Compares actualDocCount and total docCount of its immediate children of an indexto determine if the metric index is a complete metric name or not.For the ES response shown in class description, for a baseLevel of 2,foo.bar.baz has actualDocCount of 2, but total doc count of all its children,which in this case is only foo.bar.baz, is 1.
public static list < token > get tokens ( locator locator ) { if ( string utils . is empty ( locator . get metric name ( ) ) || string utils . is empty ( locator . get tenant id ( ) ) ) return new array list < > ( ) ; string [ ] tokens = locator . get metric name ( ) . split ( locator . metric token separator regex ) ; return int stream . range ( num , tokens . length ) . map to obj ( index -> new token ( locator , tokens , index ) ) . collect ( to list ( ) ) ; }	This method return list of tokens with their parents for a current Discovery object.For example: A locator of 1111:a.b.c.d would generate the following tokensToken{token='a', parent='', isLeaf=false, id='111111:a', locator=111111.a.b.c.d}Token{token='b', parent='a', isLeaf=false, id='111111:a.b', locator=111111.a.b.c.d}Token{token='c', parent='a.b', isLeaf=false, id='111111:a.b.c', locator=111111.a.b.c.d}Token{token='d', parent='a.b.c', isLeaf=true, id='111111:a.b.c.d:$', locator=111111.a.b.c.d}.
public result set future put async ( locator locator , long collection time , rollup rollup , granularity granularity , int ttl ) { session session = io . get session ( ) ;	Asynchronously insert a rolled up metric to the appropriate column familyfor a particular granularity.
private static granularity granularity from points less than equal ( double requested duration , int points , long assumed interval millis ) { granularity gran = granularity from points linear ( requested duration , points , assumed interval millis ) ; if ( requested duration / gran . milliseconds ( ) > points ) { try { gran = gran . coarser ( ) ; } catch ( granularity exception e ) { } } return gran ; }	Find the granularity in the interval that will yield a number of data points that areclosest to the requested points but <= requested points.
public synchronized void set server time ( long millis ) { log . info ( str , millis , new java . util . date ( millis ) ) ; context . set current time millis ( millis ) ; }	set the server time in millis.
public set < string > get unique hosts ( ) { set < string > unique hosts = new hash set < string > ( ) ; collections . add all ( unique hosts , config . get string property ( core config . cassandra hosts ) . split ( str ) ) ; return unique hosts ; }	Retrieves the set of unique Cassandra hosts from configuration file.If a single host appears multiple times in the configuration, only one willbe listed.
public int get max conn per host ( int num hosts ) { int max conns = config . get integer property ( core config . max cassandra connections ) ; return max conns / num hosts + ( max conns % num hosts == num ? num : num ) ; }	Calculates the number of max connections per Cassandra hosts.
public static iterable < metric column family > get metric column families ( ) { return new iterable < metric column family > ( ) { @ override public iterator < metric column family > iterator ( ) { return new iterator < metric column family > ( ) { private int pos = num ; @ override public boolean has next ( ) { return pos < metric column familes . length ; } @ override public metric column family next ( ) { return metric column familes [ pos ++ ] ; } @ override public void remove ( ) { throw new no such method error ( str ) ; } } ; } } ; }	iterate over all column families that store metrics.
@ override public void insert metrics ( collection < i > metrics ) throws io { insert metrics ( metrics , granularity . full ) ; }	Inserts a collection of metrics to the metrics_preaggregated_full column family.
@ override public void insert metrics ( collection < i > metrics , granularity granularity ) throws io { try { astyanax writer . get instance ( ) . insert metrics ( metrics , cassandra model . get preaggregated column family ( granularity ) , is recording delayed metrics , clock ) ; } catch ( connection exception ex ) { throw new io ( ex ) ; } }	Inserts a collection of metrics to the correct column family based onthe specified granularity.
protected set < locator > get locators ( rollup execution context execution context , boolean is reroll , granularity delayed metrics reroll granularity , granularity delayed metrics storage granularity ) { set < locator > locators = new hash set < locator > ( ) ;	This methods gets locators to rollup a slot.During re-rolls, If the granularity of the slot is finer(or equal) to the configuredDELAYED_METRICS_REROLL_GRANULARITY, we re-roll only the delayed locator's correspondingto that slot.
protected string regex to grab current and next level ( final string query ) { if ( string utils . is empty ( query ) ) { throw new illegal argument exception ( str ) ; } string query regex = get regex ( query ) ; int total query tokens = get total tokens ( query ) ; if ( total query tokens == num ) {	Returns regex which could grab metric names from current level to the next levelfor a given query.(Some exceptions when query has only one level due to the nature of underlying data)for metrics : foo.bar.baz,foo.bar.baz.qux,for query=foo.bar.*, the regex which this method returns will capture the following metric token paths."foo.bar.baz" <- current level"foo.bar.baz.qux" <- next level.
public synchronized void start ( ) { if ( uploader thread != null ) { throw new runtime exception ( str ) ; } file uploader = new done file uploader ( ) ; uploader thread = new thread ( file uploader , str ) ; uploader thread . start ( ) ; }	Start background storage management and uploading tasks.
public synchronized void stop ( ) throws io { if ( uploader thread == null ) { throw new runtime exception ( str ) ; } uploader thread . interrupt ( ) ; uploader thread = null ; file uploader . shutdown ( ) ; }	Stop background storage management.
public synchronized boolean is locator current in batch layer ( locator loc ) { locator cache entry entry = inserted locators . get if present ( loc . to string ( ) ) ; return entry != null && entry . is batch current ( ) ; }	Checks if Locator is recently inserted in the batch layer.
public synchronized boolean is locator current in discovery layer ( locator loc ) { locator cache entry entry = inserted locators . get if present ( loc . to string ( ) ) ; return entry != null && entry . is discovery current ( ) ; }	Checks if Locator is recently inserted in the discovery layer.
public synchronized boolean is locator current in token discovery layer ( locator loc ) { locator cache entry entry = inserted locators . get if present ( loc . to string ( ) ) ; return entry != null && entry . is token discovery current ( ) ; }	Checks if Locator is recently inserted in the token discovery layer.
public synchronized boolean is delayed locator for a ( int slot , locator locator ) { return inserted delayed locators . get if present ( get locator slot key ( slot , locator ) ) != null ; }	Check if the delayed locator is recently inserted for a given slot.
public synchronized void set delayed locator for a ( int slot , locator locator ) { inserted delayed locators . put ( get locator slot key ( slot , locator ) , boolean . true ) ; }	Marks the delayed locator as recently inserted for a given slot.
public static map < range , iterable < range > > map finer ranges ( granularity g , range range ) throws granularity exception { if ( range . get start ( ) >= range . get stop ( ) ) throw new illegal argument exception ( str + range . get start ( ) + str + range . get stop ( ) ) ; final long snapped start millis = g . snap millis ( range . get start ( ) ) ; final long snapped stop millis = g . snap millis ( range . get stop ( ) + g . milliseconds ( ) ) ; hash map < range , iterable < range > > range map = new hash map < range , iterable < range > > ( ) ; long temp start millis = snapped start millis ; int number of millis = g . milliseconds ( ) ; while ( temp start millis <= ( snapped stop millis - number of millis ) ) { range slot range = new range ( temp start millis , temp start millis + number of millis ) ; range map . put ( slot range , new interval range iterator ( g . finer ( ) , slot range . start , slot range . stop ) ) ; temp start millis = temp start millis + number of millis ; } return range map ; }	Returns a mapping of ranges in the coarser granularity to the sub-ranges in finer granularityHere is an example: Given start/end (s,e), we need to return mapping between ranges in Y that will be mapped toa single range in X. From the example above, it will be mapping from A to all the sub-ranges in Y that get rolledto a single point in A.
public static iterable < range > ranges for interval ( granularity g , final long from , final long to ) { if ( g == granularity . full ) { return arrays . as list ( new range ( from , to ) ) ; } final long snapped start millis = g . snap millis ( from ) ; final long snapped stop millis = g . snap millis ( to + g . milliseconds ( ) ) ; return new interval range iterator ( g , snapped start millis , snapped stop millis ) ; }	return the Ranges for an interval at this granularity.
public void insert full ( collection < ? extends i > metrics , boolean is recording delayed metrics , clock clock ) throws connection exception { timer . context ctx = instrumentation . get write timer context ( cassandra model . cf metrics full name ) ; try { mutation batch mutation batch = keyspace . prepare mutation batch ( ) ; for ( i metric : metrics ) { final locator locator = metric . get locator ( ) ;	single column updates).
public void insert metrics ( collection < i > metrics , column family cf , boolean is recording delayed metrics , clock clock ) throws connection exception { timer . context ctx = instrumentation . get write timer context ( cf . get name ( ) ) ; multimap < locator , i > map = as multimap ( metrics ) ; mutation batch batch = keyspace . prepare mutation batch ( ) ; try { for ( locator locator : map . key set ( ) ) { column list mutation < long > mutation = batch . with row ( cf , locator ) ; for ( i metric : map . get ( locator ) ) { mutation . put column ( metric . get collection time ( ) , metric . get metric value ( ) , ( abstract serializer ) ( serializers . serializer for ( metric . get metric value ( ) . get class ( ) ) ) , metric . get ttl in seconds ( ) ) ; if ( cf . get name ( ) . equals ( cassandra model . cf metrics preaggregated full name ) ) { instrumentation . mark full res preaggregated metric written ( ) ; } if ( is recording delayed metrics ) {	generic IMetric insertion. All other metric insertion methods could use this one.
protected boolean is delayed ( i metric ) { long delay = clock . now ( ) . get millis ( ) - metric . get collection time ( ) ; return delay > max age allowed ; }	Determines if the metric is considered delayed or not.
protected bound statement get bound statement for metric if delayed ( i metric ) { locator locator = metric . get locator ( ) ; if ( is delayed ( metric ) ) { int slot = get delayed slot ( metric ) ; if ( ! locator cache . get instance ( ) . is delayed locator for a ( slot , locator ) ) { locator cache . get instance ( ) . set delayed locator for a ( slot , locator ) ; return delayed locator io . get bound statement for locator ( delayed metrics storage granularity , slot , locator ) ; } } return null ; }	Returns a BoundStatement if a metric needs to be inserted to the metrics_delayed_locatorColumn Family.
public map < string , string > get metadata values ( locator locator ) { timer . context ctx = instrumentation . get read timer context ( cassandra model . cf metrics metadata name ) ; try { final column list < string > results = keyspace . prepare query ( cassandra model . cf metrics metadata ) . get key ( locator ) . execute ( ) . get result ( ) ; return new hash map < string , string > ( ) { { for ( column < string > result : results ) { put ( result . get name ( ) , result . get value ( string metadata serializer . get ( ) ) ) ; } } } ; } catch ( not found exception ex ) { instrumentation . mark not found ( cassandra model . cf metrics metadata name ) ; return null ; } catch ( connection exception e ) { log . error ( str , e ) ; instrumentation . mark read error ( e ) ; throw new runtime exception ( e ) ; } finally { ctx . stop ( ) ; } }	Method that returns all metadata for a given locator as a map.
public boolean is content type valid ( http headers headers ) { string content type = headers . get ( http headers . names . content type ) ;	Checks the Content-Type header to see if clients specify the rightmedia type.
public boolean is accept valid ( http headers headers ) { string accept = headers . get ( http headers . names . accept ) ;	Checks the Accept header to see if clients accept the correctmedia type.
public void insert discovery ( list < i > batch ) throws io { batch histogram . update ( batch . size ( ) ) ; if ( batch . size ( ) == num ) { log . debug ( str ) ; return ; } timer . context ctx = write timer . time ( ) ; try { for ( object obj : batch ) { if ( ! ( obj instanceof i ) ) { class cast exception meter . mark ( ) ; continue ; } } elasticsearch rest helper . index metrics ( batch ) ; } finally { ctx . stop ( ) ; } }	REST call to index into ES.
@ assert true ( message = str ) private boolean is valid ( ) { boolean is gauge present = gauges != null && gauges . length > num ; boolean is counter present = counters != null && counters . length > num ; boolean is timer present = timers != null && timers . length > num ; boolean is set present = sets != null && sets . length > num ; return ( is gauge present || is counter present || is timer present || is set present ) ; }	This method is invoked by the validator automatically.
private void do check ( ) { if ( ! running ) return ; if ( file manager == null ) return ; if ( unexpected errors > max unexpected errors ) { log . info ( str ) ; terminate ( bool ) ; return ; } timer . context wait timer context = waiting timer . time ( ) ;	gets run by the thread.
public extractor get new instance ( ) { extractor extractor = new basic extractor ( config ) ; if ( config . should cached download ( ) ) { extractor = new cached extractor ( extractor , config ) ; } return extractor ; }	Returns an Extractor instance appropriate based on the given configuration.
private static boolean get os ( final string os name prefix , final string os version prefix ) { return is os ( os name , os version , os name prefix , os version prefix ) ; }	Decides if the operating system matches.
public void start ( ) throws erlang version exception , download exception , extraction exception , startup exception { if ( rabbit mq process != null ) { throw new illegal state exception ( str ) ; } check ( ) ; download ( ) ; extract ( ) ; run ( ) ; }	Starts the RabbitMQ server process and blocks the current thread until the initialization is completed.
public void stop ( ) throws shut down exception { if ( rabbit mq process == null ) { throw new illegal state exception ( str ) ; } new shutdown helper ( config , rabbit mq process ) . run ( ) ; rabbit mq process = null ; }	Submits the command to stop RabbitMQ and blocks the current thread until the shutdown is completed.
public static pn signaling params default instance ( ) { media constraints pc constraints = pn signaling params . default pc constraints ( ) ; media constraints video constraints = pn signaling params . default video constraints ( ) ; media constraints audio constraints = pn signaling params . default audio constraints ( ) ; list < peer connection . ice server > ice servers = pn signaling params . default ice servers ( ) ; return new pn signaling params ( ice servers , pc constraints , video constraints , audio constraints ) ; }	The default parameters for media constraints.
public void add ice servers ( list < peer connection . ice server > ice servers ) { if ( this . ice servers != null ) { ice servers . add all ( this . ice servers ) ; } this . ice servers = ice servers ; }	Append default servers to the end of given list and set as iceServers instance variable.
public void add ice servers ( peer connection . ice server ice servers ) { if ( this . ice servers == null ) { this . ice servers = new array list < peer connection . ice server > ( ) ; } this . ice servers . add ( num , ice servers ) ; }	Instantiate iceServers if they are not already, and add Ice Server to beginning of list.
public void transmit ( string user id , json message ) { json usr msg json = new json ( ) ; try { usr msg json . put ( rtc . json usermsg , message ) ; this . pc client . transmit message ( user id , usr msg json ) ; } catch ( json e ) { e . print stack trace ( ) ; } }	Send a custom JSONObject user message to a single peer.
public void transmit all ( json message ) { list < pn peer > peer list = this . pc client . get peers ( ) ; for ( pn peer p : peer list ) { transmit ( p . get id ( ) , message ) ; } }	Send a custom JSONObject user message to all peers.
@ generated ( value = str , date = str , comments = str ) public list < weitere adresse > get weitere adresse ( ) { if ( weitere adresse == null ) { weitere adresse = new array list < weitere adresse > ( ) ; } return this . weitere adresse ; }	Gets the value of the weitereAdresse property.
@ generated ( value = str , date = str , comments = str ) public list < user defined simplefield > get user defined simplefield ( ) { if ( user defined simplefield == null ) { user defined simplefield = new array list < user defined simplefield > ( ) ; } return this . user defined simplefield ; }	Gets the value of the userDefinedSimplefield property.
@ generated ( value = str , date = str , comments = str ) public list < user defined anyfield > get user defined anyfield ( ) { if ( user defined anyfield == null ) { user defined anyfield = new array list < user defined anyfield > ( ) ; } return this . user defined anyfield ; }	Gets the value of the userDefinedAnyfield property.
@ generated ( value = str , date = str , comments = str ) public void set api suchfelder ( jaxb < api suchfelder typ > value ) { this . api suchfelder = value ; }	Sets the value of the apiSuchfelder property.
@ generated ( value = str , date = str , comments = str ) public list < multimedia anhang typ > get multimedia anhang ( ) { if ( multimedia anhang == null ) { multimedia anhang = new array list < multimedia anhang typ > ( ) ; } return this . multimedia anhang ; }	Gets the value of the multimediaAnhang property.
@ generated ( value = str , date = str , comments = str ) public status typ get status vbm ( ) { if ( status vbm == null ) { return status typ . aktiv ; } else { return status vbm ; } }	Gets the value of the statusVBM property.
@ generated ( value = str , date = str , comments = str ) public status typ get status i ( ) { if ( status i == null ) { return status typ . aktiv ; } else { return status i ; } }	Gets the value of the statusIS24 property.
@ generated ( value = str , date = str , comments = str ) public status typ get status hp ( ) { if ( status hp == null ) { return status typ . aktiv ; } else { return status hp ; } }	Gets the value of the statusHP property.
@ generated ( value = str , date = str , comments = str ) public aktions typ get importmodus ( ) { if ( importmodus == null ) { return aktions typ . importieren ; } else { return importmodus ; } }	Gets the value of the importmodus property.
@ generated ( value = str , date = str , comments = str ) public boolean get adressdruck ( ) { if ( adressdruck == null ) { return bool ; } else { return adressdruck ; } }	Gets the value of the adressdruck property.
@ generated ( value = str , date = str , comments = str ) public waehrung typ get waehrung ( ) { if ( waehrung == null ) { return waehrung typ . eur ; } else { return waehrung ; } }	Gets the value of the waehrung property.
@ generated ( value = str , date = str , comments = str ) public bodenbelag typ get bodenbelag ( ) { if ( bodenbelag == null ) { return bodenbelag typ . keine angabe ; } else { return bodenbelag ; } }	Gets the value of the bodenbelag property.
@ generated ( value = str , date = str , comments = str ) public void set region ( java . lang . string value ) { this . region = value ; }	Sets the value of the region property.
@ generated ( value = str , date = str , comments = str ) public void set area ( java . lang . string value ) { this . area = value ; }	Sets the value of the area property.
@ generated ( value = str , date = str , comments = str ) public void set address ( java . lang . string value ) { this . address = value ; }	Sets the value of the address property.
@ generated ( value = str , date = str , comments = str ) public void set description ( java . lang . string value ) { this . description = value ; }	Sets the value of the description property.
@ generated ( value = str , date = str , comments = str ) public void set rent collection period ( overseas rental ad type . rent period value ) { this . rent collection period = value ; }	Sets the value of the rentCollectionPeriod property.
@ generated ( value = str , date = str , comments = str ) public void set furnished ( overseas rental ad type . furnished value ) { this . furnished = value ; }	Sets the value of the furnished property.
@ generated ( value = str , date = str , comments = str ) public void set phone1 ( java . lang . string value ) { this . phone1 = value ; }	Sets the value of the phone1 property.
@ generated ( value = str , date = str , comments = str ) public void set phone2 ( java . lang . string value ) { this . phone2 = value ; }	Sets the value of the phone2 property.
@ generated ( value = str , date = str , comments = str ) public void set contact name ( java . lang . string value ) { this . contact name = value ; }	Sets the value of the contactName property.
@ generated ( value = str , date = str , comments = str ) public void set phone info ( java . lang . string value ) { this . phone info = value ; }	Sets the value of the phoneInfo property.
@ generated ( value = str , date = str , comments = str ) public void set main email ( java . lang . string value ) { this . main email = value ; }	Sets the value of the mainEmail property.
@ generated ( value = str , date = str , comments = str ) public void set cc email ( java . lang . string value ) { this . cc email = value ; }	Sets the value of the ccEmail property.
@ generated ( value = str , date = str , comments = str ) public void set external id ( java . lang . string value ) { this . external id = value ; }	Sets the value of the externalId property.
@ generated ( value = str , date = str , comments = str ) public void set agent id ( java . lang . string value ) { this . agent id = value ; }	Sets the value of the agentId property.
@ generated ( value = str , date = str , comments = str ) public void set epart ( energiepass . epart value ) { this . epart = value ; }	Sets the value of the epart property.
@ generated ( value = str , date = str , comments = str ) public void set jahrgang ( energiepass . jahrgang value ) { this . jahrgang = value ; }	Sets the value of the jahrgang property.
@ generated ( value = str , date = str , comments = str ) public void set gebaeudeart ( energiepass . gebaeudeart value ) { this . gebaeudeart = value ; }	Sets the value of the gebaeudeart property.
@ generated ( value = str , date = str , comments = str ) public void set buero typ ( buero praxen . buero typ value ) { this . buero typ = value ; }	Sets the value of the bueroTyp property.
public static boolean is numeric ( string value , locale locale ) { if ( value == null ) return bool ; int start = num ; final decimal format symbols symbols = ( locale != null ) ? decimal format symbols . get instance ( locale ) : decimal format symbols . get instance ( ) ; if ( value . starts with ( str ) || value . starts with ( str ) ) start ++ ; boolean fraction = bool ; for ( int i = start ; i < value . length ( ) ; i ++ ) { final char c = value . char at ( i ) ; if ( c == symbols . get decimal separator ( ) && ! fraction ) { fraction = bool ; continue ; } if ( c == symbols . get grouping separator ( ) && ! fraction ) { continue ; } if ( ! character . is digit ( c ) ) { return bool ; } } return bool ; }	Test, if a string contains a parsable number.
@ generated ( value = str , date = str , comments = str ) public void set gebiete ( lage gebiet . gebiete value ) { this . gebiete = value ; }	Sets the value of the gebiete property.
@ generated ( value = str , date = str , comments = str ) public void set gruppe ( anhang . gruppe value ) { this . gruppe = value ; }	Sets the value of the gruppe property.
@ generated ( value = str , date = str , comments = str ) public void set agent ( root . agent value ) { this . agent = value ; }	Sets the value of the agent property.
@ generated ( value = str , date = str , comments = str ) public list < property type > get property ( ) { if ( property == null ) { property = new array list < property type > ( ) ; } return this . property ; }	Gets the value of the property property.
@ generated ( value = str , date = str , comments = str ) public void set stand ( verkaufstatus . stand value ) { this . stand = value ; }	Sets the value of the stand property.
@ generated ( value = str , date = str , comments = str ) public list < user defined extend > get user defined extend ( ) { if ( user defined extend == null ) { user defined extend = new array list < user defined extend > ( ) ; } return this . user defined extend ; }	Gets the value of the userDefinedExtend property.
@ generated ( value = str , date = str , comments = str ) public void set zeiteinheit ( preis zeiteinheit . zeiteinheit value ) { this . zeiteinheit = value ; }	Sets the value of the zeiteinheit property.
@ generated ( value = str , date = str , comments = str ) public list < zimmer > get zimmer ( ) { if ( zimmer == null ) { zimmer = new array list < zimmer > ( ) ; } return this . zimmer ; }	Gets the value of the zimmer property.
@ generated ( value = str , date = str , comments = str ) public list < haus > get haus ( ) { if ( haus == null ) { haus = new array list < haus > ( ) ; } return this . haus ; }	Gets the value of the haus property.
@ generated ( value = str , date = str , comments = str ) public list < buero praxen > get buero praxen ( ) { if ( buero praxen == null ) { buero praxen = new array list < buero praxen > ( ) ; } return this . buero praxen ; }	Gets the value of the bueroPraxen property.
@ generated ( value = str , date = str , comments = str ) public list < gastgewerbe > get gastgewerbe ( ) { if ( gastgewerbe == null ) { gastgewerbe = new array list < gastgewerbe > ( ) ; } return this . gastgewerbe ; }	Gets the value of the gastgewerbe property.
@ generated ( value = str , date = str , comments = str ) public list < land und forstwirtschaft > get land und forstwirtschaft ( ) { if ( land und forstwirtschaft == null ) { land und forstwirtschaft = new array list < land und forstwirtschaft > ( ) ; } return this . land und forstwirtschaft ; }	Gets the value of the landUndForstwirtschaft property.
@ generated ( value = str , date = str , comments = str ) public list < sonstige > get sonstige ( ) { if ( sonstige == null ) { sonstige = new array list < sonstige > ( ) ; } return this . sonstige ; }	Gets the value of the sonstige property.
@ generated ( value = str , date = str , comments = str ) public list < zinshaus renditeobjekt > get zinshaus renditeobjekt ( ) { if ( zinshaus renditeobjekt == null ) { zinshaus renditeobjekt = new array list < zinshaus renditeobjekt > ( ) ; } return this . zinshaus renditeobjekt ; }	Gets the value of the zinshausRenditeobjekt property.
@ generated ( value = str , date = str , comments = str ) public list < terrain type > get terrain ( ) { if ( terrain == null ) { terrain = new array list < terrain type > ( ) ; } return this . terrain ; }	Gets the value of the terrain property.
@ generated ( value = str , date = str , comments = str ) public void set umfang ( uebertragung . umfang value ) { this . umfang = value ; }	Sets the value of the umfang property.
@ generated ( value = str , date = str , comments = str ) public void set wohnungtyp ( wohnung . wohnungtyp value ) { this . wohnungtyp = value ; }	Sets the value of the wohnungtyp property.
public static string get country is ( string country ) { country = string utils . trim to null ( country ) ; if ( country == null ) return null ; if ( country . length ( ) == num ) return country ; string [ ] iso2 codes = locale . get iso ( ) ; if ( country . length ( ) == num ) { string iso2 code = locale utils . get country is is ( country ) ; if ( iso2 code != null ) return iso2 code ; } for ( string iso2 code : iso2 codes ) { locale country locale = new locale ( iso2 code , iso2 code ) ; for ( locale translation locale : locale utils . available locale list ( ) ) { string name = string utils . trim to null ( country locale . get display country ( translation locale ) ) ; if ( name != null && name . equals ignore case ( country ) ) return iso2 code ; } } return null ; }	Return an ISO-2 country code from a country name.
public static string get country is is ( string iso3 code ) { iso3 code = string utils . trim to null ( iso3 code ) ; if ( iso3 code == null ) return null ; if ( iso3 code . length ( ) == num ) { for ( string iso2 code : locale . get iso ( ) ) { locale country locale = new locale ( iso2 code , iso2 code ) ; string country is = string utils . trim to null ( country locale . get is ( ) ) ; if ( country is != null && country is . equals ignore case ( iso3 code ) ) { return iso2 code ; } } } return null ; }	Create an ISO-2 country code from an ISO-3 country code.
public static string get country is ( string country ) { country = string utils . trim to null ( country ) ; if ( country == null ) return null ; if ( country . length ( ) == num ) return country ; string [ ] iso2 codes = locale . get iso ( ) ; if ( country . length ( ) == num ) { string iso3code = locale utils . get country is is ( country ) ; if ( iso3code != null ) return iso3code ; } for ( string iso2 code : iso2 codes ) { locale country locale = new locale ( iso2 code , iso2 code ) ; string iso3 code = string utils . trim to null ( country locale . get is ( ) ) ; if ( iso3 code == null ) continue ; for ( locale translation locale : locale utils . available locale list ( ) ) { string name = string utils . trim to null ( country locale . get display country ( translation locale ) ) ; if ( name != null && name . equals ignore case ( country ) ) return iso3 code ; } } return null ; }	Return an ISO-3 country code from a country name.
public static string get country is is ( string iso2 code ) { iso2 code = string utils . trim to null ( iso2 code ) ; if ( iso2 code == null ) return null ; if ( iso2 code . length ( ) == num ) { locale country locale = new locale ( iso2 code , iso2 code ) ; string iso3 code = string utils . trim to null ( country locale . get is ( ) ) ; if ( iso3 code != null ) return iso3 code ; } return null ; }	Create an ISO-3 country code from an ISO-2 country code.
public static string get country name ( string country , locale language ) { country = string utils . trim to null ( country ) ; if ( country == null ) return null ; string iso2 code = locale utils . get country is ( country ) ; if ( iso2 code != null ) { string name = string utils . trim to null ( new locale ( iso2 code , iso2 code ) . get display country ( language ) ) ; if ( name != null ) return name ; } return null ; }	Return a country name in another language.
public static string translate country name ( string country , locale language ) { country = string utils . trim to null ( country ) ; if ( country == null ) return null ; for ( string iso2 code : locale . get iso ( ) ) { locale country locale = new locale ( iso2 code , iso2 code ) ; for ( locale translation locale : locale utils . available locale list ( ) ) { string name = string utils . trim to null ( country locale . get display country ( translation locale ) ) ; if ( name != null && name . equals ignore case ( country ) ) { name = string utils . trim to null ( country locale . get display country ( language ) ) ; if ( name != null ) return name ; } } } return null ; }	Translate a country name into another language.
@ generated ( value = str , date = str , comments = str ) public list < anbieter > get anbieter ( ) { if ( anbieter == null ) { anbieter = new array list < anbieter > ( ) ; } return this . anbieter ; }	Gets the value of the anbieter property.
@ generated ( value = str , date = str , comments = str ) public void set category ( business element . business element category value ) { this . category = value ; }	Sets the value of the category property.
@ generated ( value = str , date = str , comments = str ) public list < uri > get pdf ( ) { if ( pdf == null ) { pdf = new array list < uri > ( ) ; } return this . pdf ; }	Gets the value of the pdf property.
@ generated ( value = str , date = str , comments = str ) public void set aktionart ( aktion . aktion art value ) { this . aktionart = value ; }	Sets the value of the aktionart property.
@ generated ( value = str , date = str , comments = str ) public void set realestateitems ( container . realestateitems value ) { this . realestateitems = value ; }	Sets the value of the realestateitems property.
@ generated ( value = str , date = str , comments = str ) public void set pacht ( jaxb < vermarktung grundstueck wohnen miete typ . pacht > value ) { this . pacht = value ; }	Sets the value of the pacht property.
@ override public void upgrade from previous version ( open immo document doc ) { doc . set document version ( open immo version . 2 7 ) ; if ( doc instanceof open immo transfer document ) { try { this . upgrade summemietenetto elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . upgrade energiepass elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.2.6 to 1.2.7.
@ generated ( value = str , date = str , comments = str ) public list < object > get content ( ) { if ( content == null ) { content = new array list < object > ( ) ; } return this . content ; }	Gets the value of the content property.
public string [ ] get field names ( ) { list < string > names = new array list < > ( ) ; for ( meta data type . field field : this . fields ) { names . add ( field . get name ( ) ) ; } return names . to array ( new string [ num ] ) ; }	Returns the names of specified fields.
@ generated ( value = str , date = str , comments = str ) public void set blick ( ausblick . blick value ) { this . blick = value ; }	Sets the value of the blick property.
@ generated ( value = str , date = str , comments = str ) public void set pauschalmiete ( waz typ . pauschalmiete value ) { this . pauschalmiete = value ; }	Sets the value of the pauschalmiete property.
@ generated ( value = str , date = str , comments = str ) public void set monatsmiete ( waz typ . monatsmiete value ) { this . monatsmiete = value ; }	Sets the value of the monatsmiete property.
@ generated ( value = str , date = str , comments = str ) public stellplatz kategorie typ get parkplatz ( ) { if ( parkplatz == null ) { return stellplatz kategorie typ . keine angabe ; } else { return parkplatz ; } }	Gets the value of the parkplatz property.
@ generated ( value = str , date = str , comments = str ) public void set lastenaufzug ( jaxb < hebeanlage typ > value ) { this . lastenaufzug = value ; }	Sets the value of the lastenaufzug property.
@ generated ( value = str , date = str , comments = str ) public void set zustand art ( zustand . zustand art value ) { this . zustand art = value ; }	Sets the value of the zustandArt property.
@ generated ( value = str , date = str , comments = str ) public list < bewertung . feld > get feld ( ) { if ( feld == null ) { feld = new array list < bewertung . feld > ( ) ; } return this . feld ; }	Gets the value of the feld property.
public void dump ( writer writer , string line separator ) throws io { for ( int i = num ; i < this . get record lenth ( ) ; i ++ ) { string builder txt = new string builder ( ) ; try ( string reader reader = new string reader ( string utils . trim to empty ( this . get ( i ) ) ) ) { for ( string line : io . read lines ( reader ) ) { if ( txt . length ( ) > num ) txt . append ( line separator ) ; txt . append ( line ) ; } } writer . write ( i + str + txt . to string ( ) ) ; writer . write ( system . line separator ( ) ) ; } }	Write content of the record in a human readable form.
protected final string get ( int pos , string default value ) { string value = string utils . trim to null ( this . values . get ( pos ) ) ; return ( value != null ) ? value : default value ; }	Returns the value of the record at a certain index position.
protected iterable < string > print ( ) { final int length = this . get record lenth ( ) ; list < string > row = new array list < > ( ) ; for ( int i = num ; i < length ; i ++ ) { row . add ( this . get ( i ) ) ; } return row ; }	Returns a list of values for this record as they are written into CSV.
protected final void set ( int pos , string value ) { value = string utils . trim to null ( value ) ; if ( value != null ) this . values . put ( pos , value ) ; else if ( this . values . contains key ( pos ) ) this . values . remove ( pos ) ; }	Sets the value of this record at a certain index position.
@ generated ( value = str , date = str , comments = str ) public void set ctype ( check . ctype value ) { this . ctype = value ; }	Sets the value of the ctype property.
@ generated ( value = str , date = str , comments = str ) public void set haustyp ( haus . haustyp value ) { this . haustyp = value ; }	Sets the value of the haustyp property.
@ generated ( value = str , date = str , comments = str ) public list < energiepass > get energiepass ( ) { if ( energiepass == null ) { energiepass = new array list < energiepass > ( ) ; } return this . energiepass ; }	Gets the value of the energiepass property.
@ generated ( value = str , date = str , comments = str ) public void set keller ( unterkellert . keller value ) { this . keller = value ; }	Sets the value of the keller property.
@ generated ( value = str , date = str , comments = str ) public void set grundst typ ( grundstueck . grundst typ value ) { this . grundst typ = value ; }	Sets the value of the grundstTyp property.
@ generated ( value = str , date = str , comments = str ) public void set geschl attr ( geschlecht . geschl attr value ) { this . geschl attr = value ; }	Sets the value of the geschlAttr property.
@ generated ( value = str , date = str , comments = str ) public void set hallen typ ( hallen lager prod . hallen typ value ) { this . hallen typ = value ; }	Sets the value of the hallenTyp property.
@ generated ( value = str , date = str , comments = str ) public boolean get wiederholungstermin ( ) { if ( wiederholungstermin == null ) { return bool ; } else { return wiederholungstermin ; } }	Gets the value of the wiederholungstermin property.
@ generated ( value = str , date = str , comments = str ) public boolean get teilungsversteigerung ( ) { if ( teilungsversteigerung == null ) { return bool ; } else { return teilungsversteigerung ; } }	Gets the value of the teilungsversteigerung property.
@ override public void upgrade from previous version ( open immo document doc ) { doc . set document version ( open immo version . 2 3 ) ; if ( doc instanceof open immo transfer document ) { try { this . upgrade sonstige elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . upgrade zinshaus renditeobjekt elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.2.2 to 1.2.3.
@ generated ( value = str , date = str , comments = str ) public list < interessent . bevorzugt > get bevorzugt ( ) { if ( bevorzugt == null ) { bevorzugt = new array list < interessent . bevorzugt > ( ) ; } return this . bevorzugt ; }	Gets the value of the bevorzugt property.
@ generated ( value = str , date = str , comments = str ) public list < interessent . wunsch > get wunsch ( ) { if ( wunsch == null ) { wunsch = new array list < interessent . wunsch > ( ) ; } return this . wunsch ; }	Gets the value of the wunsch property.
@ generated ( value = str , date = str , comments = str ) public void set art ( uebertragung . art value ) { this . art = value ; }	Sets the value of the art property.
@ generated ( value = str , date = str , comments = str ) public void set modus ( uebertragung . modus value ) { this . modus = value ; }	Sets the value of the modus property.
@ generated ( value = str , date = str , comments = str ) public list < email sonstige > get email sonstige ( ) { if ( email sonstige == null ) { email sonstige = new array list < email sonstige > ( ) ; } return this . email sonstige ; }	Gets the value of the emailSonstige property.
@ generated ( value = str , date = str , comments = str ) public list < tel sonstige > get tel sonstige ( ) { if ( tel sonstige == null ) { tel sonstige = new array list < tel sonstige > ( ) ; } return this . tel sonstige ; }	Gets the value of the telSonstige property.
@ generated ( value = str , date = str , comments = str ) public void set handel typ ( einzelhandel . handel typ value ) { this . handel typ = value ; }	Sets the value of the handelTyp property.
@ generated ( value = str , date = str , comments = str ) public void set api suchfeld1 ( jaxb < string > value ) { this . api suchfeld1 = value ; }	Sets the value of the apiSuchfeld1 property.
@ generated ( value = str , date = str , comments = str ) public void set api suchfeld2 ( jaxb < string > value ) { this . api suchfeld2 = value ; }	Sets the value of the apiSuchfeld2 property.
@ generated ( value = str , date = str , comments = str ) public void set api suchfeld3 ( jaxb < string > value ) { this . api suchfeld3 = value ; }	Sets the value of the apiSuchfeld3 property.
@ generated ( value = str , date = str , comments = str ) public list < result set type . row > get row ( ) { if ( row == null ) { row = new array list < result set type . row > ( ) ; } return this . row ; }	Gets the value of the row property.
@ generated ( value = str , date = str , comments = str ) public void set distanz zu sport ( distanzen sport . distanz zu sport value ) { this . distanz zu sport = value ; }	Sets the value of the distanzZuSport property.
@ generated ( value = str , date = str , comments = str ) public list < anhang > get anhang ( ) { if ( anhang == null ) { anhang = new array list < anhang > ( ) ; } return this . anhang ; }	Gets the value of the anhang property.
@ generated ( value = str , date = str , comments = str ) public garagen kategorie typ get objekt kategorie2 ( ) { if ( objekt kategorie2 == null ) { return garagen kategorie typ . keine angabe ; } else { return objekt kategorie2 ; } }	Gets the value of the objektKategorie2 property.
@ generated ( value = str , date = str , comments = str ) public objekt zustand typ get objektzustand ( ) { if ( objektzustand == null ) { return objekt zustand typ . keine angabe ; } else { return objektzustand ; } }	Gets the value of the objektzustand property.
@ generated ( value = str , date = str , comments = str ) public haus kategorien typ get haus kategorie ( ) { if ( haus kategorie == null ) { return haus kategorien typ . keine angabe ; } else { return haus kategorie ; } }	Gets the value of the hausKategorie property.
@ generated ( value = str , date = str , comments = str ) public ausstattungsqualitaets typ get ausstattungsqualitaet ( ) { if ( ausstattungsqualitaet == null ) { return ausstattungsqualitaets typ . keine angabe ; } else { return ausstattungsqualitaet ; } }	Gets the value of the ausstattungsqualitaet property.
@ generated ( value = str , date = str , comments = str ) public list < string > get vermarktungsart ( ) { if ( vermarktungsart == null ) { vermarktungsart = new array list < string > ( ) ; } return this . vermarktungsart ; }	Gets the value of the vermarktungsart property.
@ generated ( value = str , date = str , comments = str ) public list < interessent > get interessent ( ) { if ( interessent == null ) { interessent = new array list < interessent > ( ) ; } return this . interessent ; }	Gets the value of the interessent property.
@ generated ( value = str , date = str , comments = str ) public void set wert ( provision teilen . wert value ) { this . wert = value ; }	Sets the value of the wert property.
@ generated ( value = str , date = str , comments = str ) public void set ackerland ( jaxb < object > value ) { this . ackerland = value ; }	Sets the value of the ackerland property.
@ generated ( value = str , date = str , comments = str ) public void set bauerwartungsland ( jaxb < object > value ) { this . bauerwartungsland = value ; }	Sets the value of the bauerwartungsland property.
@ generated ( value = str , date = str , comments = str ) public void set bootsstaende ( jaxb < object > value ) { this . bootsstaende = value ; }	Sets the value of the bootsstaende property.
@ generated ( value = str , date = str , comments = str ) public void set buero ( jaxb < object > value ) { this . buero = value ; }	Sets the value of the buero property.
@ generated ( value = str , date = str , comments = str ) public void set camping ( jaxb < object > value ) { this . camping = value ; }	Sets the value of the camping property.
@ generated ( value = str , date = str , comments = str ) public void set doppelhaus ( jaxb < object > value ) { this . doppelhaus = value ; }	Sets the value of the doppelhaus property.
@ generated ( value = str , date = str , comments = str ) public void set einfamilienhaus ( jaxb < object > value ) { this . einfamilienhaus = value ; }	Sets the value of the einfamilienhaus property.
@ generated ( value = str , date = str , comments = str ) public void set einzelhandel gross ( jaxb < object > value ) { this . einzelhandel gross = value ; }	Sets the value of the einzelhandelGross property.
@ generated ( value = str , date = str , comments = str ) public void set einzelhandel klein ( jaxb < object > value ) { this . einzelhandel klein = value ; }	Sets the value of the einzelhandelKlein property.
@ generated ( value = str , date = str , comments = str ) public void set garagen ( jaxb < object > value ) { this . garagen = value ; }	Sets the value of the garagen property.
@ generated ( value = str , date = str , comments = str ) public void set garten ( jaxb < object > value ) { this . garten = value ; }	Sets the value of the garten property.
@ generated ( value = str , date = str , comments = str ) public void set gastronomie ( jaxb < object > value ) { this . gastronomie = value ; }	Sets the value of the gastronomie property.
@ generated ( value = str , date = str , comments = str ) public void set gewerbe ( jaxb < object > value ) { this . gewerbe = value ; }	Sets the value of the gewerbe property.
@ generated ( value = str , date = str , comments = str ) public void set hotel ( jaxb < object > value ) { this . hotel = value ; }	Sets the value of the hotel property.
@ generated ( value = str , date = str , comments = str ) public void set industrie ( jaxb < object > value ) { this . industrie = value ; }	Sets the value of the industrie property.
@ generated ( value = str , date = str , comments = str ) public void set keine bebauung ( jaxb < object > value ) { this . keine bebauung = value ; }	Sets the value of the keineBebauung property.
@ generated ( value = str , date = str , comments = str ) public void set kleingewerbe ( jaxb < object > value ) { this . kleingewerbe = value ; }	Sets the value of the kleingewerbe property.
@ generated ( value = str , date = str , comments = str ) public void set lager ( jaxb < object > value ) { this . lager = value ; }	Sets the value of the lager property.
@ generated ( value = str , date = str , comments = str ) public void set mehrfamilienhaus ( jaxb < object > value ) { this . mehrfamilienhaus = value ; }	Sets the value of the mehrfamilienhaus property.
@ generated ( value = str , date = str , comments = str ) public void set obstpflanzung ( jaxb < object > value ) { this . obstpflanzung = value ; }	Sets the value of the obstpflanzung property.
@ generated ( value = str , date = str , comments = str ) public void set parkhaus ( jaxb < object > value ) { this . parkhaus = value ; }	Sets the value of the parkhaus property.
@ generated ( value = str , date = str , comments = str ) public void set produktion ( jaxb < object > value ) { this . produktion = value ; }	Sets the value of the produktion property.
@ generated ( value = str , date = str , comments = str ) public void set reihenhaus ( jaxb < object > value ) { this . reihenhaus = value ; }	Sets the value of the reihenhaus property.
@ generated ( value = str , date = str , comments = str ) public void set stellplaetze ( jaxb < object > value ) { this . stellplaetze = value ; }	Sets the value of the stellplaetze property.
@ generated ( value = str , date = str , comments = str ) public void set villa ( jaxb < object > value ) { this . villa = value ; }	Sets the value of the villa property.
@ generated ( value = str , date = str , comments = str ) public void set wald ( jaxb < object > value ) { this . wald = value ; }	Sets the value of the wald property.
@ generated ( value = str , date = str , comments = str ) public void set anbieter ( immobilien transfer typ . anbieter value ) { this . anbieter = value ; }	Sets the value of the anbieter property.
@ generated ( value = str , date = str , comments = str ) public list < wohnung > get wohnung ( ) { if ( wohnung == null ) { wohnung = new array list < wohnung > ( ) ; } return this . wohnung ; }	Gets the value of the wohnung property.
@ generated ( value = str , date = str , comments = str ) public list < grundstueck > get grundstueck ( ) { if ( grundstueck == null ) { grundstueck = new array list < grundstueck > ( ) ; } return this . grundstueck ; }	Gets the value of the grundstueck property.
@ generated ( value = str , date = str , comments = str ) public list < einzelhandel > get einzelhandel ( ) { if ( einzelhandel == null ) { einzelhandel = new array list < einzelhandel > ( ) ; } return this . einzelhandel ; }	Gets the value of the einzelhandel property.
@ generated ( value = str , date = str , comments = str ) public list < hallen lager prod > get hallen lager prod ( ) { if ( hallen lager prod == null ) { hallen lager prod = new array list < hallen lager prod > ( ) ; } return this . hallen lager prod ; }	Gets the value of the hallenLagerProd property.
@ generated ( value = str , date = str , comments = str ) public list < parken > get parken ( ) { if ( parken == null ) { parken = new array list < parken > ( ) ; } return this . parken ; }	Gets the value of the parken property.
@ generated ( value = str , date = str , comments = str ) public list < freizeitimmobilie gewerblich > get freizeitimmobilie gewerblich ( ) { if ( freizeitimmobilie gewerblich == null ) { freizeitimmobilie gewerblich = new array list < freizeitimmobilie gewerblich > ( ) ; } return this . freizeitimmobilie gewerblich ; }	Gets the value of the freizeitimmobilieGewerblich property.
@ generated ( value = str , date = str , comments = str ) public list < string > get objektart zusatz ( ) { if ( objektart zusatz == null ) { objektart zusatz = new array list < string > ( ) ; } return this . objektart zusatz ; }	Gets the value of the objektartZusatz property.
@ generated ( value = str , date = str , comments = str ) public list < stellplatzart > get stellplatzart ( ) { if ( stellplatzart == null ) { stellplatzart = new array list < stellplatzart > ( ) ; } return this . stellplatzart ; }	Gets the value of the stellplatzart property.
@ generated ( value = str , date = str , comments = str ) public void set max dauer ( max mietdauer . max dauer value ) { this . max dauer = value ; }	Sets the value of the maxDauer property.
@ generated ( value = str , date = str , comments = str ) public list < string > get feature ( ) { if ( feature == null ) { feature = new array list < string > ( ) ; } return this . feature ; }	Gets the value of the feature property.
@ generated ( value = str , date = str , comments = str ) public void set zimmertyp ( zimmer . zimmertyp value ) { this . zimmertyp = value ; }	Sets the value of the zimmertyp property.
@ override @ suppress warnings ( str ) public void upgrade from previous version ( open immo document doc ) { doc . set document version ( open immo version . 2 5 ) ; if ( doc instanceof open immo transfer document ) { try { this . upgrade energiepass elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.2.4 to 1.2.5.
@ generated ( value = str , date = str , comments = str ) public void set keine angabe ( jaxb < object > value ) { this . keine angabe = value ; }	Sets the value of the keineAngabe property.
@ generated ( value = str , date = str , comments = str ) public void set erdwaerme ( jaxb < object > value ) { this . erdwaerme = value ; }	Sets the value of the erdwaerme property.
@ generated ( value = str , date = str , comments = str ) public void set solarheizung ( jaxb < object > value ) { this . solarheizung = value ; }	Sets the value of the solarheizung property.
@ generated ( value = str , date = str , comments = str ) public void set pelletheizung ( jaxb < object > value ) { this . pelletheizung = value ; }	Sets the value of the pelletheizung property.
@ generated ( value = str , date = str , comments = str ) public void set gas ( jaxb < object > value ) { this . gas = value ; }	Sets the value of the gas property.
@ generated ( value = str , date = str , comments = str ) public void set oel ( jaxb < object > value ) { this . oel = value ; }	Sets the value of the oel property.
@ generated ( value = str , date = str , comments = str ) public void set fernwaerme ( jaxb < object > value ) { this . fernwaerme = value ; }	Sets the value of the fernwaerme property.
@ generated ( value = str , date = str , comments = str ) public void set strom ( jaxb < object > value ) { this . strom = value ; }	Sets the value of the strom property.
@ generated ( value = str , date = str , comments = str ) public void set kohle ( jaxb < object > value ) { this . kohle = value ; }	Sets the value of the kohle property.
public static string random ( int length ) { return new random string generator . builder ( ) . filtered by ( numbers , letters ) . build ( ) . generate ( length ) ; }	Generate a random string with ASCII letters and digits.
public static string random letters ( int length ) { return new random string generator . builder ( ) . filtered by ( letters ) . build ( ) . generate ( length ) ; }	Generate a random string with ASCII letters.
public static string random numeric ( int length ) { return new random string generator . builder ( ) . filtered by ( numbers ) . build ( ) . generate ( length ) ; }	Generate a random string with ASCII digits.
@ generated ( value = str , date = str , comments = str ) public wohnung kategorien typ get wohnung kategorie ( ) { if ( wohnung kategorie == null ) { return wohnung kategorien typ . keine angabe ; } else { return wohnung kategorie ; } }	Gets the value of the wohnungKategorie property.
@ generated ( value = str , date = str , comments = str ) public void set benutzer ( wis . benutzer value ) { this . benutzer = value ; }	Sets the value of the benutzer property.
@ generated ( value = str , date = str , comments = str ) public void set objekte ( wis . objekte value ) { this . objekte = value ; }	Sets the value of the objekte property.
@ generated ( value = str , date = str , comments = str ) public list < feedindex . feed > get feed ( ) { if ( feed == null ) { feed = new array list < feedindex . feed > ( ) ; } return this . feed ; }	Gets the value of the feed property.
@ generated ( value = str , date = str , comments = str ) public void set moeb ( moebliert . moeb value ) { this . moeb = value ; }	Sets the value of the moeb property.
@ generated ( value = str , date = str , comments = str ) public list < serviceleistungen > get serviceleistungen ( ) { if ( serviceleistungen == null ) { serviceleistungen = new array list < serviceleistungen > ( ) ; } return this . serviceleistungen ; }	Gets the value of the serviceleistungen property.
@ generated ( value = str , date = str , comments = str ) public void set sub administrative area ( location structure . sub administrative area value ) { this . sub administrative area = value ; }	Sets the value of the subAdministrativeArea property.
@ generated ( value = str , date = str , comments = str ) public void set city ( location structure . city value ) { this . city = value ; }	Sets the value of the city property.
@ generated ( value = str , date = str , comments = str ) public void set locality ( location structure . locality value ) { this . locality = value ; }	Sets the value of the locality property.
@ override public void downgrade to previous version ( open immo document doc ) { doc . set document version ( open immo version . 2 0 ) ; if ( doc instanceof open immo transfer document ) { try { this . remove objektart zusatz elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . downgrade energiepass elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . downgrade haus elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } } try { this . downgrade xml namespace ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } }	Downgrade an OpenImmo document from version 1.2.1 to 1.2.0.
@ override @ suppress warnings ( str ) public void upgrade from previous version ( open immo document doc ) { doc . set document version ( open immo version . 2 1 ) ; if ( doc instanceof open immo transfer document ) { try { this . upgrade energiepass elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } } try { this . upgrade xml namespace ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } }	Upgrade an OpenImmo document from version 1.2.0 to 1.2.1.
@ generated ( value = str , date = str , comments = str ) public void set land typ ( land und forstwirtschaft . land typ value ) { this . land typ = value ; }	Sets the value of the landTyp property.
@ generated ( value = str , date = str , comments = str ) public list < meta data type . field > get field ( ) { if ( field == null ) { field = new array list < meta data type . field > ( ) ; } return this . field ; }	Gets the value of the field property.
@ override public void upgrade from previous version ( open immo document doc ) { doc . set document version ( open immo version . 2 0 ) ; if ( doc instanceof open immo transfer document ) { try { this . upgrade mieteinnahmen elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.1 to 1.2.0.
@ generated ( value = str , date = str , comments = str ) public list < ad type > get ad ( ) { if ( ad == null ) { ad = new array list < ad type > ( ) ; } return this . ad ; }	Gets the value of the ad property.
@ generated ( value = str , date = str , comments = str ) public void set gastgew typ ( gastgewerbe . gastgew typ value ) { this . gastgew typ = value ; }	Sets the value of the gastgewTyp property.
@ generated ( value = str , date = str , comments = str ) public void set platzart ( stp sonstige . platzart value ) { this . platzart = value ; }	Sets the value of the platzart property.
@ generated ( value = str , date = str , comments = str ) public daten verkabelungs typ get daten verkabelung ( ) { if ( daten verkabelung == null ) { return daten verkabelungs typ . keine angabe ; } else { return daten verkabelung ; } }	Gets the value of the datenVerkabelung property.
@ generated ( value = str , date = str , comments = str ) public ja nein vereinbarung typ get klimaanlage ( ) { if ( klimaanlage == null ) { return ja nein vereinbarung typ . keine angabe ; } else { return klimaanlage ; } }	Gets the value of the klimaanlage property.
@ generated ( value = str , date = str , comments = str ) public list < images type . image > get image ( ) { if ( image == null ) { image = new array list < images type . image > ( ) ; } return this . image ; }	Gets the value of the image property.
@ generated ( value = str , date = str , comments = str ) public void set price type ( overseas sale ad type . price type value ) { this . price type = value ; }	Sets the value of the priceType property.
@ generated ( value = str , date = str , comments = str ) public void set new development availability ( java . lang . string value ) { this . new development availability = value ; }	Sets the value of the newDevelopmentAvailability property.
@ generated ( value = str , date = str , comments = str ) public void set directions ( java . lang . string value ) { this . directions = value ; }	Sets the value of the directions property.
@ generated ( value = str , date = str , comments = str ) public void set co2 rating ( java . lang . string value ) { this . co2 rating = value ; }	Sets the value of the co2Rating property.
@ generated ( value = str , date = str , comments = str ) public void set energy rating ( java . lang . string value ) { this . energy rating = value ; }	Sets the value of the energyRating property.
@ generated ( value = str , date = str , comments = str ) public void set viewing details ( java . lang . string value ) { this . viewing details = value ; }	Sets the value of the viewingDetails property.
@ generated ( value = str , date = str , comments = str ) public void set property status ( overseas sale ad type . property status value ) { this . property status = value ; }	Sets the value of the propertyStatus property.
@ generated ( value = str , date = str , comments = str ) public void set pictures ( ad type . pictures value ) { this . pictures = value ; }	Sets the value of the pictures property.
@ generated ( value = str , date = str , comments = str ) public void set bebaubar attr ( bebaubar nach . bebaubar attr value ) { this . bebaubar attr = value ; }	Sets the value of the bebaubarAttr property.
@ override public void upgrade from previous version ( open immo document doc ) { doc . set document version ( open immo version . 2 4 ) ; if ( doc instanceof open immo transfer document ) { try { this . upgrade anzahl balkon terrassen elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . upgrade anhang elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . upgrade sonstige elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } } }	Upgrade an OpenImmo document from version 1.2.3 to 1.2.4.
@ generated ( value = str , date = str , comments = str ) public void set parken typ ( parken . parken typ value ) { this . parken typ = value ; }	Sets the value of the parkenTyp property.
@ generated ( value = str , date = str , comments = str ) public void set alter attr ( alter . alter attr value ) { this . alter attr = value ; }	Sets the value of the alterAttr property.
@ generated ( value = str , date = str , comments = str ) public void set freizeit typ ( freizeitimmobilie gewerblich . freizeit typ value ) { this . freizeit typ = value ; }	Sets the value of the freizeitTyp property.
@ generated ( value = str , date = str , comments = str ) public void set telefonart ( tel sonstige . telefonart value ) { this . telefonart = value ; }	Sets the value of the telefonart property.
@ generated ( value = str , date = str , comments = str ) public void set emailart ( email sonstige . emailart value ) { this . emailart = value ; }	Sets the value of the emailart property.
@ generated ( value = str , date = str , comments = str ) public void set overseas sales ( daft . overseas sales value ) { this . overseas sales = value ; }	Sets the value of the overseasSales property.
@ generated ( value = str , date = str , comments = str ) public void set overseas rental ( daft . overseas rental value ) { this . overseas rental = value ; }	Sets the value of the overseasRental property.
@ suppress warnings ( str ) public static element create user defined simplefield ( document doc , string name , string value ) { element root = xml utils . get root element ( doc ) ; element node = doc . create element ns ( root . get namespace uri ( ) , str ) ; node . set attribute ( str , name ) ; node . set text content ( value ) ; return node ; }	Helper method to create a &lt;user_defined_simplefield&gt; element with a"feldname" attribute and a string value.
@ generated ( value = str , date = str , comments = str ) public list < fehlerliste . fehler > get fehler ( ) { if ( fehler == null ) { fehler = new array list < fehlerliste . fehler > ( ) ; } return this . fehler ; }	Gets the value of the fehler property.
@ generated ( value = str , date = str , comments = str ) public void set erbpacht ( jaxb < vermarktung grundstueck gewerbe typ . erbpacht > value ) { this . erbpacht = value ; }	Sets the value of the erbpacht property.
@ generated ( value = str , date = str , comments = str ) public list < stp sonstige > get stp sonstige ( ) { if ( stp sonstige == null ) { stp sonstige = new array list < stp sonstige > ( ) ; } return this . stp sonstige ; }	Gets the value of the stpSonstige property.
@ generated ( value = str , date = str , comments = str ) public list < value lists type . valuelist > get valuelist ( ) { if ( valuelist == null ) { valuelist = new array list < value lists type . valuelist > ( ) ; } return this . valuelist ; }	Gets the value of the valuelist property.
@ generated ( value = str , date = str , comments = str ) public void set min dauer ( min mietdauer . min dauer value ) { this . min dauer = value ; }	Sets the value of the minDauer property.
@ generated ( value = str , date = str , comments = str ) public void set zins typ ( zinshaus renditeobjekt . zins typ value ) { this . zins typ = value ; }	Sets the value of the zinsTyp property.
@ generated ( value = str , date = str , comments = str ) public list < uri > get photo ( ) { if ( photo == null ) { photo = new array list < uri > ( ) ; } return this . photo ; }	Gets the value of the photo property.
@ generated ( value = str , date = str , comments = str ) public void set metadata ( feed . metadata value ) { this . metadata = value ; }	Sets the value of the metadata property.
@ generated ( value = str , date = str , comments = str ) public void set projects ( feed . projects value ) { this . projects = value ; }	Sets the value of the projects property.
@ generated ( value = str , date = str , comments = str ) public void set properties ( feed . properties value ) { this . properties = value ; }	Sets the value of the properties property.
@ override public void upgrade from previous version ( kyero document doc ) { doc . set document version ( kyero version . v3 ) ; try { this . remove custom elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . upgrade new build elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . upgrade type elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . upgrade currency elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } try { this . upgrade url elements ( doc . get document ( ) ) ; } catch ( exception ex ) { logger . error ( str ) ; logger . error ( str + ex . get localized message ( ) , ex ) ; } }	Upgrade a Kyero document to version 3.
@ generated ( value = str , date = str , comments = str ) public list < immobilie > get immobilie ( ) { if ( immobilie == null ) { immobilie = new array list < immobilie > ( ) ; } return this . immobilie ; }	Gets the value of the immobilie property.
@ generated ( value = str , date = str , comments = str ) public list < objekt > get objekt ( ) { if ( objekt == null ) { objekt = new array list < objekt > ( ) ; } return this . objekt ; }	Gets the value of the objekt property.
@ generated ( value = str , date = str , comments = str ) public list < fehlerliste > get fehlerliste ( ) { if ( fehlerliste == null ) { fehlerliste = new array list < fehlerliste > ( ) ; } return this . fehlerliste ; }	Gets the value of the fehlerliste property.
@ generated ( value = str , date = str , comments = str ) public list < status > get status ( ) { if ( status == null ) { status = new array list < status > ( ) ; } return this . status ; }	Gets the value of the status property.
@ generated ( value = str , date = str , comments = str ) public void set sonstige typ ( sonstige . sonstige typ value ) { this . sonstige typ = value ; }	Sets the value of the sonstigeTyp property.
@ generated ( value = str , date = str , comments = str ) public void set distanz zu ( distanzen . distanz zu value ) { this . distanz zu = value ; }	Sets the value of the distanzZu property.
@ generated ( value = str , date = str , comments = str ) public list < distanzen > get distanzen ( ) { if ( distanzen == null ) { distanzen = new array list < distanzen > ( ) ; } return this . distanzen ; }	Gets the value of the distanzen property.
@ generated ( value = str , date = str , comments = str ) public list < distanzen sport > get distanzen sport ( ) { if ( distanzen sport == null ) { distanzen sport = new array list < distanzen sport > ( ) ; } return this . distanzen sport ; }	Gets the value of the distanzenSport property.
public static boolean is compatible with throws clause ( throwable ex , class < ? > [ ] declared exceptions ) { if ( ! is checked exception ( ex ) ) { return bool ; } if ( declared exceptions != null ) { int i = num ; while ( i < declared exceptions . length ) { if ( declared exceptions [ i ] . is assignable from ( ex . get class ( ) ) ) { return bool ; } i ++ ; } } return bool ; }	Check whether the given exception is compatible with the exceptionsdeclared in a throws clause.
public void set bindings ( map < string , string > bindings ) { for ( map . entry < string , string > entry : bindings . entry set ( ) ) { bind namespace uri ( entry . get key ( ) , entry . get value ( ) ) ; } }	Sets the bindings for this namespace context.
public void bind namespace uri ( string prefix , string namespace uri ) { assert . not null ( prefix , str ) ; assert . not null ( namespace uri , str ) ; if ( xml . default ns prefix . equals ( prefix ) ) { default namespace uri = namespace uri ; } else { prefix to namespace uri . put ( prefix , namespace uri ) ; get prefixes internal ( namespace uri ) . add ( prefix ) ; } }	Binds the given prefix to the given namespace.
public void remove binding ( string prefix ) { if ( xml . default ns prefix . equals ( prefix ) ) { default namespace uri = str ; } else { string namespace uri = prefix to namespace uri . remove ( prefix ) ; list < string > prefixes = get prefixes internal ( namespace uri ) ; prefixes . remove ( prefix ) ; } }	Removes the given prefix from this context.
private boolean has opening tag ( string content ) { if ( this . in comment ) { return bool ; } int open tag index = content . index of ( str ) ; return ( open tag index > - num && content . length ( ) > open tag index && character . is letter ( content . char at ( open tag index + num ) ) ) ; }	Does the supplied content contain an XML opening tag.
private string consume comment tokens ( string line ) { if ( line . index of ( start comment ) == - num && line . index of ( end comment ) == - num ) { return line ; } while ( ( line = consume ( line ) ) != null ) { if ( ! this . in comment && ! line . trim ( ) . starts with ( start comment ) ) { return line ; } } return line ; }	Consumes all the leading comment data in the given String and returns the remaining content, whichmay be empty since the supplied content might be all comment data.
private string consume ( string line ) { int index = ( this . in comment ? end comment ( line ) : start comment ( line ) ) ; return ( index == - num ? null : line . substring ( index ) ) ; }	Consume the next comment token, update the "inComment" flagand return the remaining content.
private int comment token ( string line , string token , boolean in comment if present ) { int index = line . index of ( token ) ; if ( index > - num ) { this . in comment = in comment if present ; } return ( index == - num ? index : index + token . length ( ) ) ; }	Try to consume the supplied token against the supplied content and update thein comment parse state to the supplied value.
public static void init logging ( string location ) throws file not found exception { string resolved location = system property utils . resolve placeholders ( location ) ; url url = resource utils . get url ( resolved location ) ; if ( resolved location . to lower case ( ) . ends with ( xml file extension ) ) { dom . configure ( url ) ; } else { property configurator . configure ( url ) ; } }	Initialize log4j from the given file location, with no config file refreshing.Assumes an XML file in case of a ".xml" file extension, and a properties fileotherwise.
@ override public final void start prefix mapping ( string prefix , string uri ) { namespace context . bind namespace uri ( prefix , uri ) ; namespace context changed = bool ; }	Binds the given prefix to the given namespaces.
public void add ( iterator < e > iterator ) { assert . state ( ! in use , str ) ; if ( iterators . contains ( iterator ) ) { throw new illegal argument exception ( str ) ; } iterators . add ( iterator ) ; }	Add given iterator to this composite.
public final option add option ( option opt ) { if ( opt . short form ( ) != null ) this . options . put ( str + opt . short form ( ) , opt ) ; this . options . put ( str + opt . long form ( ) , opt ) ; return opt ; }	Add the specified Option to the list of accepted options.
public final option add string option ( char short form , string long form ) { return add option ( new option . string option ( short form , long form ) ) ; }	Convenience method for adding a string option.
public final option add integer option ( char short form , string long form ) { return add option ( new option . integer option ( short form , long form ) ) ; }	Convenience method for adding an integer option.
public final option add long option ( char short form , string long form ) { return add option ( new option . long option ( short form , long form ) ) ; }	Convenience method for adding a long integer option.
public final option add double option ( char short form , string long form ) { return add option ( new option . double option ( short form , long form ) ) ; }	Convenience method for adding a double option.
public final option add boolean option ( char short form , string long form ) { return add option ( new option . boolean option ( short form , long form ) ) ; }	Convenience method for adding a boolean option.
public final void parse ( string [ ] argv , locale locale ) throws illegal option value exception , unknown option exception {	Extract the options and non-option arguments from the givenlist of command-line arguments.
public object new instance ( class c ) throws instantiation exception , illegal access exception { object ret = null ; method [ ] methods = c . get declared methods ( ) ; method m ; int modifiers ;	Dynamic instantiation of the given type with singleton retrieval support as described in this class description.
protected void after access ( ) { if ( this . concurrency limit >= num ) { synchronized ( this . monitor ) { this . concurrency count -- ; if ( logger . is debug enabled ( ) ) { logger . debug ( str + this . concurrency count ) ; } this . monitor . notify ( ) ; } } }	To be invoked after the main execution logic of concrete subclasses.
public void set target object ( object target object ) { this . target object = target object ; if ( target object != null ) { this . target class = target object . get class ( ) ; } }	Set the target object on which to call the target method.Only necessary when the target method is not static;else, a target class is sufficient.
public void prepare ( ) throws class not found exception , no such method exception { if ( this . static method != null ) { int last dot index = this . static method . last index of ( str ) ; if ( last dot index == - num || last dot index == this . static method . length ( ) ) { throw new illegal argument exception ( str + str ) ; } string class name = this . static method . substring ( num , last dot index ) ; string method name = this . static method . substring ( last dot index + num ) ; this . target class = resolve class name ( class name ) ; this . target method = method name ; } class < ? > target class = get target class ( ) ; string target method = get target method ( ) ; if ( target class == null ) { throw new illegal argument exception ( str ) ; } if ( target method == null ) { throw new illegal argument exception ( str ) ; } object [ ] arguments = get arguments ( ) ; class < ? > [ ] arg types = new class < ? > [ arguments . length ] ; for ( int i = num ; i < arguments . length ; ++ i ) { arg types [ i ] = ( arguments [ i ] != null ? arguments [ i ] . get class ( ) : object . class ) ; }	Prepare the specified method.The method can be invoked any number of times afterwards.
protected method find matching method ( ) { string target method = get target method ( ) ; object [ ] arguments = get arguments ( ) ; int arg count = arguments . length ; method [ ] candidates = reflection utils . get all declared methods ( get target class ( ) ) ; int min type diff weight = integer . max value ; method matching method = null ; for ( method candidate : candidates ) { if ( candidate . get name ( ) . equals ( target method ) ) { class < ? > [ ] param types = candidate . get parameter types ( ) ; if ( param types . length == arg count ) { int type diff weight = get type difference weight ( param types , arguments ) ; if ( type diff weight < min type diff weight ) { min type diff weight = type diff weight ; matching method = candidate ; } } } } return matching method ; }	Find a matching method with the specified name for the specified arguments.
private static string to unsigned string ( int i , int shift ) { char [ ] buf = new char [ num ] ; int char pos = num ; int radix = num << shift ; int mask = radix - num ; do { buf [ -- char pos ] = digits [ i & mask ] ; i >>>= shift ; } while ( i != num ) ; return new string ( buf , char pos , ( num - char pos ) ) ; }	Convert the integer to an unsigned number.
public static byte [ ] serialize ( object object ) { if ( object == null ) { return null ; } byte array output stream baos = new byte array output stream ( ) ; try { object output stream oos = new object output stream ( baos ) ; oos . write object ( object ) ; oos . flush ( ) ; } catch ( io ex ) { throw new illegal argument exception ( str + object . get class ( ) , ex ) ; } return baos . to byte array ( ) ; }	Serialize the given object to a byte array.
public static object deserialize ( byte [ ] bytes ) { if ( bytes == null ) { return null ; } try { object input stream ois = new object input stream ( new byte array input stream ( bytes ) ) ; return ois . read object ( ) ; } catch ( io ex ) { throw new illegal argument exception ( str , ex ) ; } catch ( class not found exception ex ) { throw new illegal state exception ( str , ex ) ; } }	Deserialize the byte array into an object.
public static element get child element by tag name ( element ele , string child ele name ) { assert . not null ( ele , str ) ; assert . not null ( child ele name , str ) ; node list nl = ele . get child nodes ( ) ; for ( int i = num ; i < nl . get length ( ) ; i ++ ) { node node = nl . item ( i ) ; if ( node instanceof element && node name match ( node , child ele name ) ) { return ( element ) node ; } } return null ; }	Utility method that returns the first child element identified by its name.
public static string get child element value by tag name ( element ele , string child ele name ) { element child = get child element by tag name ( ele , child ele name ) ; return ( child != null ? get text value ( child ) : null ) ; }	Utility method that returns the first child element value identified by its name.
public static list < element > get child elements ( element ele ) { assert . not null ( ele , str ) ; node list nl = ele . get child nodes ( ) ; list < element > child eles = new array list < element > ( ) ; for ( int i = num ; i < nl . get length ( ) ; i ++ ) { node node = nl . item ( i ) ; if ( node instanceof element ) { child eles . add ( ( element ) node ) ; } } return child eles ; }	Retrieves all child elements of the given DOM element.
private static boolean node name match ( node node , string desired name ) { return ( desired name . equals ( node . get node name ( ) ) || desired name . equals ( node . get local name ( ) ) ) ; }	Matches the given node's name and local name against the given desired name.
private static boolean node name match ( node node , collection < ? > desired names ) { return ( desired names . contains ( node . get node name ( ) ) || desired names . contains ( node . get local name ( ) ) ) ; }	Matches the given node's name and local name against the given desired names.
public static final string set size ( final string s , final int length ) { string result = s ; int oldlen = s . length ( ) ; if ( oldlen > length ) { system . err . println ( str + length + str + oldlen + str + s ) ; } else { int tofill = length - oldlen ; result = string util . append spaces ( s , tofill ) ; } return result ; }	Appends the necessary amount of spaces to the string until it has the givnlength.
public static void monitor ( object handle , release listener listener ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + handle + str + listener + str ) ; }	Start to monitor given handle object for becoming weakly reachable.When the handle isn't used anymore, the given listener will be called.
private static void add entry ( reference < ? > ref , release listener entry ) { synchronized ( weak reference monitor . class ) {	Add entry to internal map of tracked entries.Internal monitoring thread is started if not already running.
private static boolean keep monitoring thread alive ( ) { synchronized ( weak reference monitor . class ) { if ( ! tracked entries . is empty ( ) ) { return bool ; } else { logger . debug ( str ) ; monitoring thread = null ; return bool ; } } }	Check whether to keep the monitoring thread alive,i.e.
public static string calc mobile city ( string mobile number ) throws url { object mapper object mapper = new object mapper ( ) ; string json string = null ; string url string = str + mobile number ; string buffer sb = new string buffer ( ) ; buffered reader buffer ; url url = new url ( url string ) ; try { input stream in = url . open stream ( ) ;	Test the phone number from which the city is using Taobao API.
protected void start prefix mapping ( string prefix , string namespace ) throws sax { if ( get content handler ( ) != null ) { if ( prefix == null ) { prefix = str ; } if ( ! string utils . has length ( namespace ) ) { return ; } if ( ! namespace . equals ( namespaces . get ( prefix ) ) ) { get content handler ( ) . start prefix mapping ( prefix , namespace ) ; namespaces . put ( prefix , namespace ) ; } } }	Starts the prefix mapping for the given prefix.
protected void end prefix mapping ( string prefix ) throws sax { if ( get content handler ( ) != null ) { if ( namespaces . contains key ( prefix ) ) { get content handler ( ) . end prefix mapping ( prefix ) ; namespaces . remove ( prefix ) ; } } }	Ends the prefix mapping for the given prefix.
@ suppress warnings ( str ) public void add callback ( listenable future callback < ? super t > callback ) { assert . not null ( callback , str ) ; synchronized ( mutex ) { switch ( state ) { case new : callbacks . add ( callback ) ; break ; case success : callback . on success ( ( t ) result ) ; break ; case failure : callback . on failure ( ( throwable ) result ) ; break ; } } }	Adds the given callback to this registry.
private i parse tree ( ) { i root = new tree node unique children ( ) ; i newnode , oldnode ; enumeration entries = this . jar . entries ( ) ; string entry ; while ( entries . has more elements ( ) ) { newnode = root ; oldnode = root ; entry = ( ( jar entry ) entries . next element ( ) ) . get name ( ) ; system . out . println ( str + entry ) ; string tokenizer tokenizer = new string tokenizer ( entry , str ) ; while ( tokenizer . has more elements ( ) ) { string path = tokenizer . next token ( ) ; newnode = new tree node unique children ( path ) ; oldnode . add child node ( newnode ) ; oldnode = newnode ; } } return root ; }	Build a Tree from the entries.
private int get text color ( int item ) { int scroll x = get scroll x ( ) ;	Calculates text color for specified item based on its position and state.
public void set values ( char sequence [ ] values ) { if ( this . values != values ) { this . values = values ; if ( this . values != null ) { layouts = new boring layout [ this . values . length ] ; for ( int i = num ; i < layouts . length ; i ++ ) { layouts [ i ] = new boring layout ( this . values [ i ] , text paint , item width , layout . alignment . align center , num , num , boring metrics , bool , ellipsize , item width ) ; } } else { layouts = new boring layout [ num ] ; }	Sets values to choose from.
private int get color ( int scroll x , int position ) { int item with padding = ( int ) ( item width + divider size ) ; float proportion = math . abs ( ( ( num * scroll x % item with padding ) / num ) / ( item with padding / num ) ) ; if ( proportion > num ) { proportion = ( proportion - num ) ; } else { proportion = num - proportion ; } proportion *= num ; int default color ; int selected color ; if ( pressed item == position ) { default color = text color . get color for state ( new int [ ] { android . r . attr . state pressed } , text color . get default color ( ) ) ; selected color = text color . get color for state ( new int [ ] { android . r . attr . state pressed , android . r . attr . state selected } , default color ) ; } else { default color = text color . get default color ( ) ; selected color = text color . get color for state ( new int [ ] { android . r . attr . state selected } , default color ) ; } return ( integer ) new argb evaluator ( ) . evaluate ( proportion , selected color , default color ) ; }	Calculates color for specific position on time picker.
private void set text size ( float size ) { if ( size != text paint . get text size ( ) ) { text paint . set text size ( size ) ; request layout ( ) ; invalidate ( ) ; } }	Sets text size for items.
private int get in bounds x ( int x ) { if ( x < num ) { x = num ; } else if ( x > ( ( item width + ( int ) divider size ) * ( values . length - num ) ) ) { x = ( ( item width + ( int ) divider size ) * ( values . length - num ) ) ; } return x ; }	Calculates x scroll position that is still in range of view scroller.
private string get intro ( ) { try { input stream intro stream = my remote library . class . get resource as stream ( str ) ; string writer writer = new string writer ( ) ; io . copy ( intro stream , writer , charset . default charset ( ) ) ; return writer . to string ( ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	The introduction is stored in a text file resource because it is easier to edit than String constants.
public string [ ] get keyword names ( ) { try { string [ ] names = servlet . get library ( ) . get keyword names ( ) ; if ( names == null || names . length == num ) throw new runtime exception ( str ) ; string [ ] new names = arrays . copy of ( names , names . length + num ) ; new names [ names . length ] = str ; return new names ; } catch ( throwable e ) { log . warn ( str , e ) ; throw new runtime exception ( e ) ; } }	Get an array containing the names of the keywords that the libraryimplements.
public string [ ] get keyword arguments ( string keyword ) { if ( keyword . equals ignore case ( str ) ) { return new string [ num ] ; } try { string [ ] args = servlet . get library ( ) . get keyword arguments ( keyword ) ; return args == null ? new string [ num ] : args ; } catch ( throwable e ) { log . warn ( str , e ) ; throw new runtime exception ( e ) ; } }	Get an array of argument specifications for the given keyword.
public string get keyword documentation ( string keyword ) { if ( keyword . equals ignore case ( str ) ) { return str ; } try { string doc = servlet . get library ( ) . get keyword documentation ( keyword ) ; return doc == null ? str : doc ; } catch ( throwable e ) { log . warn ( str , e ) ; throw new runtime exception ( e ) ; } }	Get documentation for given keyword.
public static void main ( string [ ] args ) throws exception { configure logging ( ) ; command line helper helper = new command line helper ( args ) ; if ( helper . get help requested ( ) ) { system . out . print ( helper . get usage ( ) ) ; system . exit ( num ) ; } remote server remote server = new remote server ( ) ; string error = helper . get error ( ) ; if ( error == null ) { try { for ( string path : helper . get library map ( ) . key set ( ) ) remote server . put library ( path , helper . get library map ( ) . get ( path ) ) ; } catch ( illegal path exception e ) { error = e . get message ( ) ; } } if ( error != null ) { system . out . println ( str + error ) ; system . out . println ( ) ; system . out . println ( helper . get usage ( ) ) ; system . exit ( num ) ; } remote server . set port ( helper . get port ( ) ) ; remote server . set allow stop ( helper . get allow stop ( ) ) ; remote server . set host ( helper . get host ( ) ) ; remote server . start ( ) ; }	Main method for command line usage.
public void stop ( int timeout ms ) throws exception { log . info ( str ) ; if ( timeout ms > num ) { server . set graceful shutdown ( timeout ms ) ; thread stopper = new thread ( ) { @ override public void run ( ) { try { server . stop ( ) ; } catch ( throwable e ) { log . error ( string . format ( str , e . get message ( ) ) , e ) ; } } } ; stopper . start ( ) ; } else { server . stop ( ) ; } }	A non-blocking method for stopping the remote server that allows requeststo complete within the given timeout before shutting down the server.
public void start ( ) throws exception { log . info ( str ) ; server . start ( ) ; log . info ( string . format ( str , get local port ( ) ) ) ; }	Starts the remote server.
public string convert properties from file to json ( string path to file , string ... include domain keys ) throws read input exception , parse properties exception { return convert properties from file to json ( new file ( path to file ) , include domain keys ) ; }	Generate Json by given path to file with properties with only included domain keys.
public string convert properties from file to json ( file file , string ... include domain keys ) throws read input exception , parse properties exception { try { input stream target stream = new file input stream ( file ) ; return convert to json ( target stream , include domain keys ) ; } catch ( file not found exception e ) { throw new read input exception ( e ) ; } }	Generate Json by given file with properties with only included domain keys.
public string convert to json ( input stream input stream , string ... include domain keys ) throws read input exception , parse properties exception { return convert to json ( input stream to properties ( input stream ) , include domain keys ) ; }	generate Json by given InputStream and given filter.
public string convert to json ( properties properties ) throws parse properties exception { for ( map . entry < object , object > entry : properties . entry set ( ) ) { if ( ! ( entry . get key ( ) instanceof string ) ) { throw new parse properties exception ( format ( property key needs to be string type , entry . get key ( ) . get class ( ) , entry . get key ( ) == null ? str : entry . get key ( ) ) ) ; } } return convert from values as object map ( properties to map ( properties ) ) ; }	generate Json by given Java Properties.
public string convert to json ( map < string , string > properties ) throws parse properties exception { return convert from values as object map ( string value map to object value map ( properties ) ) ; }	generate Json by given Map&lt;String,String&gt;.
public string convert from values as object map ( map < string , object > properties ) throws parse properties exception { object json type core object json type = new object json type ( ) ; for ( string properties key : get all keys from properties ( properties ) ) { add fields to json object ( properties , core object json type , properties key ) ; } return prettify of json ( core object json type . to string json ( ) ) ; }	generate Json by given Map&lt;String,Object&gt;.
public string convert from values as object map ( map < string , object > properties , string ... include domain keys ) throws parse properties exception { map < string , object > filtered properties = new hash map < > ( ) ; for ( string key : properties . key set ( ) ) { for ( string required key : include domain keys ) { check key ( properties , filtered properties , key , required key ) ; } } return convert from values as object map ( filtered properties ) ; }	generate Json by given Map&lt;String,String&gt; and given filter.
public string convert to json ( properties properties , string ... include domain keys ) throws parse properties exception { return convert from values as object map ( properties to map ( properties ) , include domain keys ) ; }	generate Json by given Java Properties and given filter.
protected static int get shadow radius ( drawable shadow , drawable circle ) { int radius = num ; if ( shadow != null && circle != null ) { rect rect = new rect ( ) ; radius = ( circle . get intrinsic width ( ) + ( shadow . get padding ( rect ) ? rect . left + rect . right : num ) ) / num ; } return math . max ( num , radius ) ; }	Calculates required radius of shadow.
public static builder < ocsp fetcher > builder ( ) { return new builder < > ( new build handler < ocsp fetcher > ( ) { @ override public ocsp fetcher build ( properties properties ) { return new apache ocsp fetcher ( properties ) ; } } ) ; }	Builder to create an instance of OcspFetcher using Apache HttpClient for connectivity.
protected x509 certificate find intermediate ( x509 certificate certificate ) throws ocsp exception { for ( x509 certificate issuer : properties . get ( intermediates ) ) if ( issuer . get subject x500 principal ( ) . equals ( certificate . get issuer x500 principal ( ) ) ) return issuer ; throw new ocsp exception ( str , certificate . get issuer x500 principal ( ) . get name ( ) ) ; }	Method for finding issuer by provided issuers in properties given an issued certificate.
@ override public void execute ( ) throws mojo execution exception {	Execute the maven plugin.
@ suppress warnings ( str ) private boolean preprocess markdown files ( file input directory ) throws mojo execution exception { get log ( ) . debug ( str + input directory ) ; try { if ( ! input directory . exists ( ) ) { get log ( ) . info ( str ) ; return bool ; } int base depth = string utils . count matches ( input directory . get absolute path ( ) , file . separator ) ;	Read Markdown files from directory.
private string substitute variables ( string template , string pattern string , map < string , string > variables ) { pattern pattern = pattern . compile ( pattern string ) ; matcher matcher = pattern . matcher ( template ) ; string buffer buffer = new string buffer ( ) ; while ( matcher . find ( ) ) { if ( variables . contains key ( matcher . group ( num ) ) ) { string replacement = variables . get ( matcher . group ( num ) ) ;	Replace variables with given pattern.
private string get title ( list < string > raw ) { if ( raw == null ) { return default title ; } string previous line = str ; for ( string line : raw ) { line = line . trim ( ) ; if ( line . starts with ( str ) ) { line = line . replace ( str , str ) ; return line ; }	Get the first h1 for the title.
private string add title to html file ( string html , string title ) { if ( html == null ) { return html ; } if ( title != null ) { get log ( ) . debug ( str + title ) ; return html . replace first ( str , title ) ; } else { get log ( ) . debug ( str ) ; return html . replace first ( str , str ) ; } }	Adds the title to the html file.
private string replace variables ( string initial content , map < string , string > variables ) { string new content = initial content ;	Replace variables in the html file.
private string update relative paths ( string html , int folder depth ) { if ( html == null ) { return html ; } get log ( ) . debug ( str ) ; return html . replace all ( str , get site base prefix ( folder depth ) ) ; }	Update relative include paths corresponding to the markdown file's location in the folder structure.
private void copy files ( string from dir , string to dir ) throws mojo execution exception { get log ( ) . debug ( str + from dir + str + to dir ) ; try { file from dir file = new file ( from dir ) ; if ( from dir file . exists ( ) ) { iterator < file > files = file utils . iterate files ( new file ( from dir ) , null , bool ) ; while ( files . has next ( ) ) { file file = files . next ( ) ; if ( file . exists ( ) ) { file utils . copy file to directory ( file , new file ( to dir ) ) ; } else { get log ( ) . error ( str + file . get absolute path ( ) + str ) ; } } } } catch ( io e ) { throw new mojo execution exception ( str + e . get message ( ) , e ) ; } }	Copy files from one dir to another based on file extensions.
protected string check path ( string path ) { if ( path . to lower case ( ) . contains ( str ) && path . to lower case ( ) . contains ( str ) ) { int path length = this . host . get path ( ) . length ( ) ; return path . substring ( path length , path . length ( ) ) ; } return path ; }	When retrieving 'more' statements, LRS will return full path..the client will have part in the URI already so cut that off.
private view wrap slider content ( view child , int index ) {	this will wrap the view which is added to the slider into another layout so we can then overlap the small and large view.
public void fade up ( int duration ) {	animate to the large view.
public void fade down ( int duration ) {	animate to the small view.
private float calculate percentage ( int width ) { int absolute = m max width - m min width ; int current = width - m min width ; float percentage = num * current / absolute ;	calculate the percentage to how many percent the slide is already visible.
private void overlap views ( int width ) { if ( width == m width ) { return ; }	overlap the views and provide the crossfade effect.
protected < t extends activity > intent get launch intent ( string target package , class < t > activity class , bundle creator bundle creator ) { intent intent = new intent ( intent . action main ) ; intent . set class name ( target package , activity class . get name ( ) ) ; intent . put extras ( bundle creator . create bundle ( ) ) ; intent . add flags ( intent . flag activity new task ) ; return intent ; }	The intent to launch the Activity.
@ suppress warnings ( str ) private void launch activity ( ) { if ( activity != null && activity run mode . specification . equals ( activity run mode ) ) return ; string target package = instrumentation . get target context ( ) . get package name ( ) ; intent intent = get launch intent ( target package , activity class , bundle creator ) ; activity = instrumentation . start activity sync ( intent ) ; instrumentation . wait for idle sync ( ) ; }	Launch the activity if needed.
public fact sheet list response get fact sheets ( string type , string relation types , integer page size , string cursor , boolean permissions ) throws api exception { object local var post body = null ;	getFactSheetsRetrieves all Fact Sheets.
public file download file from response ( response response ) throws api exception { try { file file = prepare download file ( response ) ; files . copy ( response . read entity ( input stream . class ) , file . to path ( ) ) ; return file ; } catch ( io e ) { throw new api exception ( e ) ; } }	Download file from the given response.
private client build http client ( boolean debugging ) { final client config client config = new client config ( ) ; client config . register ( multi part feature . class ) ; client config . register ( json ) ; client config . register ( jackson feature . class ) ; if ( debugging ) { client config . register ( logging filter . class ) ; } return client builder . new client ( client config ) ; }	Build the Client used to make HTTP requests.
public access control entity response create access control entity ( access control entity body ) throws api exception { object local var post body = body ;	createAccessControlEntityCreates an access control entity.
public data model update response update data model ( data model body , boolean force , string workspace id ) throws api exception { object local var post body = body ;	updateDataModelUpdates the data model for a workspace.
public job response create full export ( string export type , string start date , string end date ) throws api exception { object local var post body = null ;	createFullExportCreates a full export of the workspace data, or an export of the changelog, depending on given type.
public api client builder with token provider host ( string host ) { with o ( uri . create ( string . format ( str , host ) ) ) ; return this ; }	Specifies all urls needed to get an access token based on given host name and common url naming convention.
public api client builder with client credentials ( string client id , string client secret ) { this . client id = client id ; this . client secret = client secret ; return this ; }	Sets your client Id and client Secret.
public ql process graph ql ( string graph ql , file file ) throws api exception { object local var post body = null ;	processGraphQLMultipartProcesses GraphQL requests, supporting multipart documents.
public bookmark list response get bookmarks ( string bookmark type , string group key , string sharing type ) throws api exception { object local var post body = null ;	getBookmarksRetrieves all stored bookmarks a user can read.
public void add permissions ( node graph name , graph permissions permissions ) { check is open ( ) ; client . merge graph permissions ( graph name . get uri ( ) , permissions ) ; }	Adds permissions to a graph.
public void write permissions ( node graph name , graph permissions permissions ) { check is open ( ) ; client . write graph permissions ( graph name . get uri ( ) , permissions ) ; }	Sets the permissions on a graph.
public mark logic dataset graph with rulesets ( sparql ... rulesets ) { if ( this . rulesets == null ) { this . rulesets = rulesets ; } else { collection < sparql > collection = new array list < sparql > ( ) ; collection . add all ( arrays . as list ( this . rulesets ) ) ; collection . add all ( arrays . as list ( rulesets ) ) ; this . rulesets = collection . to array ( new sparql [ ] { } ) ; } return this ; }	Fluent setter for rulesets.
public void close ( ) { if ( write buffer != null ) { write buffer . cancel ( ) ; } if ( timer != null ) { timer . cancel ( ) ; } client = null ; }	Close the connection and free resources.
public synchronized input stream handle execute select ( sparql qdef , input stream handle handle , long offset , long limit ) { if ( limit == null ) { this . sparql query manager . clear page length ( ) ; } else { this . sparql query manager . set page length ( limit ) ; } if ( offset != null ) { return this . sparql query manager . execute select ( qdef , handle , offset , current transaction ) ; } else { return this . sparql query manager . execute select ( qdef , handle , current transaction ) ; } }	synchronization needed because of setting of page length.
static public mark logic dataset graph create dataset graph ( string host , int port , string user , string password , authentication type ) { database client client = database client factory . new client ( host , port , user , password , type ) ; return mark logic dataset graph factory . create dataset graph ( client ) ; }	Creates MarkLogicDatasetGraph from access parameters to a REST MarkLogicserver.
public gm limit threads ( final int threads per process ) { final list < string > args = get cmd args ( ) ; args . add ( str ) ; args . add ( str ) ; args . add ( integer . to string ( threads per process ) ) ; return this ; }	Limits the number of threads used by the GraphicsMagick process during execution.
public gm resize ( final int width , final int height , final collection < geometry annotation > annotations ) { final list < string > args = get cmd args ( ) ; args . add ( str ) ; args . add ( resample ( width , height , annotations ) ) ; return this ; }	Resize source to desired target dimensions, using default resizing filter algorithm.
public gm rotate ( final double degrees , final rotation annotation annotation ) { if ( annotation == null ) { throw new illegal argument exception ( str ) ; } final list < string > args = get cmd args ( ) ; args . add ( str ) ; args . add ( string . format ( locale . english , str , degrees , annotation . as annotation ( ) ) ) ; return this ; }	Rotates the image, with empty triangles back-filled using default background color.
public gm gravity ( final gravity value ) { if ( value == null ) { throw new illegal argument exception ( str ) ; } gravity ( value . to string ( ) ) ; return this ; }	Defines the gravity for geometry-based operations.
public gm strip profiles ( ) { final list < string > args = get cmd args ( ) ; args . add ( str ) ; args . add ( str ) ; return this ; }	Strips out ICC profiles.
public gm font ( final string style , final int size , final string color ) { if ( is blank ( style ) ) { throw new illegal argument exception ( str ) ; } if ( is blank ( color ) ) { throw new illegal argument exception ( str ) ; } font ( style ) ; pointsize ( size ) ; fill ( color ) ; return this ; }	Defines font for text overlay.
public gm source ( final file file , @ check for null final integer width , @ check for null final integer height ) throws io { if ( file != null && ! file . exists ( ) ) { throw new io ( str + file + str ) ; } if ( ( width != null ) && ( height != null ) && ( width > num ) && ( height > num ) ) { size ( width , height ) ; } return add image ( file ) ; }	Specifies the source image to convert.
public gm add image ( final file file ) { if ( file == null ) { throw new illegal argument exception ( str ) ; } get cmd args ( ) . add ( file . get path ( ) ) ; return this ; }	Add image to operation.
public static list < string > parse ( object target , string [ ] args ) { list < string > arguments = new array list < string > ( ) ; arguments . add all ( arrays . as list ( args ) ) ; class < ? > clazz ; if ( target instanceof class ) { clazz = ( class ) target ; } else { clazz = target . get class ( ) ; try { bean info info = introspector . get bean info ( clazz ) ; for ( property descriptor pd : info . get property descriptors ( ) ) { process property ( target , pd , arguments ) ; } } catch ( introspection exception e ) {	Parse a set of arguments and populate the target with the appropriate values.
public static void usage ( print stream err stream , object target ) { class < ? > clazz ; if ( target instanceof class ) { clazz = ( class ) target ; } else { clazz = target . get class ( ) ; } err stream . println ( str + clazz . get name ( ) ) ; for ( class < ? > current clazz = clazz ; current clazz != null ; current clazz = current clazz . get superclass ( ) ) { for ( field field : current clazz . get declared fields ( ) ) { field usage ( err stream , target , field ) ; } } try { bean info info = introspector . get bean info ( clazz ) ; for ( property descriptor pd : info . get property descriptors ( ) ) { property usage ( err stream , target , pd ) ; } } catch ( introspection exception e ) {	Generate usage information based on the target annotations.
public static time unit extract time unit from string ( string time string ) { time string = time string . to lower case ( ) ; if ( time string . contains ( str ) ) { return time unit . minutes ; } else if ( time string . contains ( str ) ) { return time unit . microseconds ; } else if ( time string . contains ( str ) ) { return time unit . milliseconds ; } else if ( time string . contains ( str ) ) { return time unit . seconds ; } else if ( time string . contains ( str ) ) { return time unit . hours ; } else if ( time string . to lower case ( ) . contains ( str ) ) { return time unit . days ; } else return null ; }	Extracts and returns the time unit from a string.
public static void parse ( object target , properties arguments ) { class clazz ; if ( target instanceof class ) { clazz = ( class ) target ; } else { clazz = target . get class ( ) ; } for ( field field : clazz . get declared fields ( ) ) { process field ( target , field , arguments ) ; } try { bean info info = introspector . get bean info ( clazz ) ; for ( property descriptor pd : info . get property descriptors ( ) ) { process property ( target , pd , arguments ) ; } } catch ( introspection exception e ) {	Parse properties instead of String arguments.
static public void execute ( url url ) throws slide execution exception { check not null ( url ) ; screen region screen region = new desktop screen region ( ) ; context context = new context ( screen region ) ; execute ( url , context ) ; }	Execute a presentation file at a given url.
static public void execute ( file file ) throws slide execution exception { check not null ( file ) ; try { execute ( file . to uri ( ) . to url ( ) ) ; } catch ( url e ) { throw new slide execution exception ( e ) ; } }	Execute a presentation file.
public static list < action > interpret ( file file ) throws io { check not null ( file ) ; interpreter interpreter = new default interpreter ( ) ; slides reader reader = new pptx ( ) ; list < slide > slides ; slides = reader . read ( file ) ; list < action > actions = lists . new array list ( ) ; for ( slide slide : slides ) { action action = interpreter . interpret ( slide ) ; actions . add ( action ) ; logger . info ( str , action ) ; } return actions ; }	Interpret a presentation file as a list of executable actions.
static public list < rectangle > sort by size ( list < rectangle > list ) { list < rectangle > result = lists . new array list ( ) ; collections . sort ( list , new comparator < rectangle > ( ) { @ override public int compare ( rectangle r1 , rectangle r2 ) { return ( r1 . height * r1 . width ) - ( r2 . height * r2 . width ) ; } } ) ; return result ; }	sort a list of rectangles by their sizes in ascending order.
public string render ( string template text ) { check not null ( template text ) ; st st = new st ( template text ) ; for ( map . entry < string , object > e : parameters . entry set ( ) ) { st . add ( e . get key ( ) , e . get value ( ) ) ; } return st . render ( ) ; }	Render the given template string as a string based on the parameter valuesassociated with this context.
file get slide xml ( int slide number ) { string filename = string . format ( str , slide number ) ; return new file ( get relationships directory ( ) , filename ) ; }	Get the file of the slide rel for a slide number.
protected boolean in range ( native mouse event e ) { rectangle r = screen region . get bounds ( ) ; r . x += screen offset x ; r . y += screen offset y ; int x = e . get x ( ) ; int y = e . get y ( ) ; return r . contains ( x , y ) ; }	Check the mouse action is within the screen region range.
public selector overlap vertically with ( final slide element element , final float min overlap ratio ) { check not null ( element ) ; final rectangle r1 = element . get bounds ( ) ; r1 . x = num ; r1 . width = num ; elements = collections2 . filter ( elements , new predicate < slide element > ( ) { @ override public boolean apply ( slide element e ) { if ( e == element ) { return bool ; } if ( r1 . height == num ) { return bool ; } rectangle r2 = e . get bounds ( ) ; r2 . x = num ; r2 . width = num ; rectangle intersection = r1 . intersection ( r2 ) ; float y overlap ratio = num * intersection . height / r1 . height ; return y overlap ratio > min overlap ratio ; } } ) ; return this ; }	namely, if they have the same x range, they would intersect.
public object execute outbound operation ( final message < ? > message ) { try { string serialized message = message marshaller . serialize ( message ) ; if ( queue == null ) { send message request request = new send message request ( queue url , serialized message ) ; send message result result = sqs client . send message ( request ) ; log . debug ( str + result . get message id ( ) ) ; } else { queue . add ( serialized message ) ; } } catch ( message marshaller exception e ) { log . error ( e . get message ( ) , e ) ; throw new messaging exception ( e . get message ( ) , e . get cause ( ) ) ; } return message . get payload ( ) ; }	Executes the outbound Sqs Operation.
public object execute outbound operation ( final message < ? > message ) { try { string serialized message = message marshaller . serialize ( message ) ; if ( sns test proxy == null ) { publish request request = new publish request ( ) ; publish result result = client . publish ( request . with topic arn ( topic arn ) . with message ( serialized message ) ) ; log . debug ( str + result . get message id ( ) ) ; } else { sns test proxy . dispatch message ( serialized message ) ; } } catch ( message marshaller exception e ) { log . error ( e . get message ( ) , e ) ; throw new messaging exception ( e . get message ( ) , e . get cause ( ) ) ; } return message . get payload ( ) ; }	Executes the outbound Sns Operation.
synchronized static public file require file ( string name , options options ) throws io { file file = find file ( name , options ) ; if ( file == null ) { throw new resource not found exception ( str + name + str ) ; } return file ; }	Same as findFile but throws an exception if the file was not found.
static private file get or create temp directory ( boolean delete on exit ) throws extract exception {	Attempts to create a temporary directory that did not exist previously.
public static log value map of ( final string k1 , final object v1 ) { return builder ( ) . put ( k1 , v1 ) . build ( ) ; }	Construct an immutable map from one key-value pair.
public void trace ( @ nullable final string message ) { log ( log level . trace , default event , message , empty string array , empty object array , default throwable ) ; }	Log a message at the trace level.
public void trace ( @ nullable final string event , @ nullable final string message ) { log ( log level . trace , event , message , empty string array , empty object array , default throwable ) ; }	Log a message for a canonical event at the trace level.
public void debug ( @ nullable final string message ) { log ( log level . debug , default event , message , empty string array , empty object array , default throwable ) ; }	Log a message at the debug level.
public void debug ( @ nullable final string event , @ nullable final string message ) { log ( log level . debug , event , message , empty string array , empty object array , default throwable ) ; }	Log a message for a canonical event at the debug level.
public void info ( @ nullable final string message ) { log ( log level . info , default event , message , empty string array , empty object array , default throwable ) ; }	Log a message at the info level.
public void info ( @ nullable final string event , @ nullable final string message ) { log ( log level . info , event , message , empty string array , empty object array , default throwable ) ; }	Log a message for a canonical event at the info level.
public void info ( @ nullable final string event , @ nullable final string message , @ nullable final string data key1 , @ nullable final string data key2 , @ nullable final object data value1 , @ nullable final object data value2 ) { info ( event , message , data key1 , data key2 , data value1 , data value2 , default throwable ) ; }	Log a message for a canonical event with supporting key-value pairs atthe info level.
public void warn ( @ nullable final string message ) { log ( log level . warn , default event , message , empty string array , empty object array , default throwable ) ; }	Log a message at the warn level.
public void warn ( @ nullable final string event , @ nullable final string message ) { log ( log level . warn , event , message , empty string array , empty object array , default throwable ) ; }	Log a message for a canonical event at the warn level.
public void error ( @ nullable final string message ) { log ( log level . error , default event , message , empty string array , empty object array , default throwable ) ; }	Log a message at the error level.
public void error ( @ nullable final string event , @ nullable final string message ) { log ( log level . error , event , message , empty string array , empty object array , default throwable ) ; }	Log a message for a canonical event at the error level.
@ before ( str ) public void add to context line and method ( final join point join point ) { final source location source location = join point . get source location ( ) ; final log builder target log builder = ( log builder ) join point . get target ( ) ; target log builder . add context ( str , string . value of ( source location . get line ( ) ) ) ; target log builder . add context ( str , source location . get file name ( ) ) ; target log builder . add context ( str , source location . get within type ( ) ) ; }	Before outputting the message inject additional context.
public static void start steno wrapper ( final i event , final string event name , final json generator json generator , final object mapper object mapper ) throws io { final steno serialization helper . steno level level = steno serialization helper . steno level . find by logback level ( event . get level ( ) ) ; json generator . write start object ( ) ; json generator . write object field ( str , iso date time formatter . format ( instant . of epoch milli ( event . get time stamp ( ) ) ) ) ; json generator . write object field ( str , event name ) ; json generator . write object field ( str , level . name ( ) ) ; }	Start writing the Steno JSON wrapper.
public static void write key value pairs ( @ nullable final list < string > keys , @ nullable final list < object > values , final json generator json generator , final object mapper object mapper , final steno encoder encoder ) throws io { if ( keys != null ) { final int context values length = values == null ? num : values . size ( ) ; for ( int i = num ; i < keys . size ( ) ; ++ i ) { final string key = keys . get ( i ) ; if ( i >= context values length ) { json generator . write object field ( key , null ) ; } else { final object value = values . get ( i ) ; if ( is simple type ( value ) ) { json generator . write object field ( key , value ) ; } else { json generator . write field name ( key ) ; object mapper . write value ( json generator , value ) ; } } } } }	Write specified key-value pairs into the current block.
public static void serialize throwable ( final i throwable proxy , final json generator json generator , final object mapper object mapper ) throws io { json generator . write string field ( str , throwable proxy . get class name ( ) ) ; json generator . write string field ( str , throwable proxy . get message ( ) ) ; json generator . write array field start ( str ) ; for ( final stack trace element proxy ste : throwable proxy . get stack trace element proxy array ( ) ) { json generator . write string ( ste . to string ( ) ) ; } json generator . write end array ( ) ; json generator . write object field start ( str ) ; if ( throwable proxy instanceof throwable proxy ) { final json node json node = object mapper . value to tree ( ( ( throwable proxy ) throwable proxy ) . get throwable ( ) ) ; for ( final iterator < map . entry < string , json node > > iterator = json node . fields ( ) ; iterator . has next ( ) ; ) { final map . entry < string , json node > field = iterator . next ( ) ; json generator . write field name ( field . get key ( ) ) ; object mapper . write value ( json generator , field . get value ( ) ) ; } }	This function assumes the field object has already been started for this throwable, this only fills inthe fields in the 'exception' or equivalent object and does not create the field in the containing object.
@ log value public object to log value ( ) { return log value map factory . < string , object > builder ( ) . put ( str , log builder ) . put ( str , duration ) . put ( str , last log time ) . put ( str , skipped ) . build ( ) ; }	Generate a Steno log compatible representation.
protected stack trace element get caller data ( final i logging event ) { final stack trace element [ ] caller data = logging event . get caller data ( ) ; if ( caller data != null ) { for ( int i = num ; i < caller data . length ; ++ i ) { final string caller class name = caller data [ i ] . get class name ( ) ; if ( ! caller class name . starts with ( steno class name prefix ) ) { return caller data [ i ] ; } } } return null ; }	Retrieve the relevant caller data adjusted for Steno logger wrapping.
public void create database ( string database name ) throws t { hive meta store client client = new hive meta store client ( conf ( ) ) ; string database folder = new file ( temporary folder . get root ( ) , database name ) . to uri ( ) . to string ( ) ; try { client . create database ( new database ( database name , null , database folder , null ) ) ; } finally { client . close ( ) ; } }	Create a new database with the specified name.
protected void check mappings ( int array position ) { final int index = positions . index of value ( array position ) ; if ( index >= num ) { positions . remove at ( index ) ; } }	we should clear it.
public static string parse save attr ( final cell cell , final map < string , string > save comments map ) { if ( cell != null ) { string key = cell . get sheet ( ) . get sheet name ( ) + str + cell utility . get cell index number key ( cell . get column index ( ) , cell . get row index ( ) ) ; string save attr = null ; if ( save comments map != null ) { save attr = parser utility . get string between bracket ( save comments map . get ( key ) ) ; } if ( ( save attr == null ) && ( cell . get cell type enum ( ) == cell type . string ) ) { save attr = save attrs utility . parse save attr string ( cell . get string cell value ( ) ) ; } if ( ( save attr != null ) && ( ! save attr . is empty ( ) ) ) { return tie constants . cell addr pre fix + cell . get column index ( ) + str + save attr + str ; } } return str ; }	Parses the save attr.
public static void save data to object in context ( final map < string , object > context , final string save attr , final string str value , final expression engine engine ) { int index = save attr . last index of ( str ) ; if ( index > num ) { string str object = save attr . substring ( num , index ) ; string str method = save attr . substring ( index + num ) ; str object = tie constants . method prefix + str object + tie constants . method end ; object object = command utility . evaluate ( str object , context , engine ) ; cell controls utility . set object property ( object , str method , str value , bool ) ; } }	Save data to object in context.
public static void refresh sheet row from context ( final map < string , object > context , final string full save attr , final row row , final expression engine engine ) { if ( ! full save attr . starts with ( tie constants . cell addr pre fix ) ) { return ; } int ipos = full save attr . index of ( str ) ; if ( ipos > num ) { string column index = full save attr . substring ( num , ipos ) ; string save attr = full save attr . substring ( ipos + num ) ; cell cell = row . get cell ( integer . parse int ( column index ) ) ; if ( cell . get cell type enum ( ) != cell type . formula ) { command utility . evaluate normal cells ( cell , tie constants . method prefix + save attr + tie constants . method end , context , engine ) ; } } }	reload the data from context to websheet row.
public static string parse save attr string ( final string str value ) { if ( str value != null ) { int first = str value . index of ( tie constants . method prefix ) ; int last = str value . last index of ( tie constants . method prefix ) ; int end = str value . last index of ( tie constants . method end ) ; if ( ( first >= num ) && ( first == last ) && ( end > num ) ) { return str value . substring ( first + num , end ) ; } } return str ; }	Parses the save attr string.
public static string get save attr list from row ( final row row ) { if ( row != null ) { cell cell = row . get cell ( tie constants . hidden save objects column ) ; if ( cell != null ) { string str = cell . get string cell value ( ) ; if ( ( str != null ) && ( ! str . is empty ( ) ) ) { return str ; } } } return null ; }	Gets the save attr list from row.
public static string get save attr from list ( final int column index , final string save attrs ) { if ( ( save attrs != null ) && ( ! save attrs . is empty ( ) ) ) { string str = tie constants . cell addr pre fix + column index + str ; int istart = save attrs . index of ( str ) ; if ( istart >= num ) { int iend = save attrs . index of ( str , istart ) ; if ( iend > istart ) { return save attrs . substring ( istart + str . length ( ) , iend ) ; } } } return null ; }	Gets the save attr from list.
public static void set save objects in hidden column ( final row row , final string save attr ) { cell cell = row . get cell ( tie constants . hidden save objects column , missing cell policy . create null as blank ) ; cell . set cell value ( save attr ) ; }	Sets the save objects in hidden column.
public static void set save attrs for sheet ( final sheet sheet , final int min row num , final int max row num , final map < string , string > save comments map ) { for ( row row : sheet ) { int row index = row . get row num ( ) ; if ( ( row index >= min row num ) && ( row index <= max row num ) ) { set save attrs for row ( row , save comments map ) ; } } }	Sets the save attrs for sheet.
public static void set save attrs for row ( final row row , final map < string , string > save comments map ) { string builder save attr = new string builder ( ) ; for ( cell cell : row ) { string s attr = parse save attr ( cell , save comments map ) ; if ( ! s attr . is empty ( ) ) { save attr . append ( s attr ) ; } } if ( save attr . length ( ) > num ) { save attrs utility . set save objects in hidden column ( row , save attr . to string ( ) ) ; } }	Sets the save attrs for row.
public static string prepare context and attrs for cell ( cell poi cell , string full name , cell helper cell helper ) { if ( full name == null ) { return null ; } string save attr list = save attrs utility . get save attr list from row ( poi cell . get row ( ) ) ; if ( save attr list != null ) { string save attr = save attrs utility . get save attr from list ( poi cell . get column index ( ) , save attr list ) ; if ( save attr != null ) { cell helper . restore data context ( full name ) ; return save attr ; } } return null ; }	Prepare context and attrs for cell.
private string fmt number ( final double d ) { if ( double . compare ( d % num , num ) == num ) { return string . format ( str , ( int ) d ) ; } else { return string . format ( str , d ) ; } }	Fmt number.
public final void put shift attrs ( final string full name , final config range attrs attrs , final rows mapping unit rows mapping ) { attrs . set unit rows mapping ( unit rows mapping ) ; this . shift map . put ( full name , attrs ) ; }	Put shift attrs.
public void set wb ( final workbook p wb ) { this . get serial wb ( ) . set wb ( p wb ) ; this . wb wrapper = xssf . create ( ( xssf ) p wb ) ; }	Set up workbook. Also create evaluation wrapper.
public xssf get wb wrapper ( ) { if ( ( this . wb wrapper == null ) && ( this . get wb ( ) != null ) ) { this . wb wrapper = xssf . create ( ( xssf ) this . get wb ( ) ) ; } return wb wrapper ; }	Return evaluation wrapper if needed.
public formula evaluator get formula evaluator ( ) { if ( ( this . formula evaluator == null ) && ( this . get wb ( ) != null ) ) { this . formula evaluator = this . get wb ( ) . get creation helper ( ) . create formula evaluator ( ) ; } return formula evaluator ; }	get formulaevaluator.
public void re calc max col counts ( ) { if ( ( this . get sheet config map ( ) == null ) || ( this . get sheet config map ( ) . is empty ( ) ) ) { this . max col counts = num ; return ; } int max columns = num ; for ( sheet configuration sheet config : this . get sheet config map ( ) . values ( ) ) { int counts = sheet config . get header cell range ( ) . get right col ( ) - sheet config . get header cell range ( ) . get left col ( ) + num ; if ( max columns < counts ) { max columns = counts ; } } this . max col counts = max columns ; }	recalculate max coulumn count across sheets in the workbook.
public int load web sheet ( final input stream input stream , final map < string , object > p data context ) { return this . get helper ( ) . get web sheet loader ( ) . load workbook ( input stream , p data context ) ; }	load web sheet from inputStream file with data object.
public int load web sheet ( final workbook p wb , final map < string , object > p data context ) { return this . get helper ( ) . get web sheet loader ( ) . load workbook ( p wb , p data context ) ; }	load web sheet from giving workbook with data object.
public int load work sheet by tab name ( final string tab name ) { try { int sheet id = this . get helper ( ) . get web sheet loader ( ) . find tab index with name ( tab name ) ; if ( ( get sheet config map ( ) != null ) && ( sheet id < get sheet config map ( ) . size ( ) ) ) { this . get helper ( ) . get web sheet loader ( ) . load work sheet ( tab name ) ; set active tab index ( sheet id ) ; } return num ; } catch ( exception ex ) { log . log ( level . severe , str + ex . get message ( ) , ex ) ; } return - num ; }	load worksheet by tab name.
public void do export ( ) { try { string file name = this . get export file name ( ) ; byte array output stream out = new byte array output stream ( ) ; this . get wb ( ) . write ( out ) ; input stream stream = new buffered input stream ( new byte array input stream ( out . to byte array ( ) ) ) ; export file = new default streamed content ( stream , str , file name ) ; } catch ( exception e ) { log . log ( level . severe , str + e . get localized message ( ) , e ) ; } return ; }	download current workbook.
public void do save ( ) { this . set submit mde ( bool ) ; if ( ! this . get helper ( ) . get validation handler ( ) . pre validation ( ) ) { log . fine ( str ) ; return ; } process save ( ) ; this . get helper ( ) . get web sheet loader ( ) . set unsaved status ( request context . get current instance ( ) , bool ) ; }	Save the current workbooks.
public void do submit ( ) { this . set submit mde ( bool ) ;	Submit the current workbooks.
public void populate component ( final component system event event ) { ui component = event . get component ( ) ; int [ ] rowcol = cell utility . get row col from component attributes ( component ) ; int row = rowcol [ num ] ; int col = rowcol [ num ] ; faces cell fcell = cell utility . get faces cell from body row ( row , col , this . get body rows ( ) , this . get current ( ) . get current top row ( ) , this . get current ( ) . get current left column ( ) ) ; cell controls utility . populate attributes ( component , fcell , this . get cell default control ( ) ) ; }	populate component.
public sheet configuration get current sheet config ( ) { string current tab name = this . get current ( ) . get current tab name ( ) ; if ( current tab name == null ) { return null ; } return this . get sheet config map ( ) . get ( current tab name ) ; }	Gets the current sheet config.
private void read object ( final java . io . object input stream in ) throws io { try { in . default read object ( ) ; recover ( ) ; } catch ( encrypted document exception | class not found exception e ) { log . log ( level . severe , str + e . get localized message ( ) , e ) ; } }	load the bean from saving.
private locale get locale ( final faces context context , final ui component ) { string locale str = ( string ) component . get attributes ( ) . get ( tie constants . component attr locale ) ; if ( locale str == null ) { return context . get view root ( ) . get locale ( ) ; } return locale . for language tag ( locale str ) ; }	Gets the locale.
public streamed content get picture ( ) { faces context context = faces context . get current instance ( ) ; if ( context . get current phase id ( ) == phase id . render response ) {	Return picture to web front end.
public final cell helper get cell helper ( ) { if ( ( this . cell helper == null ) && ( this . parent != null ) ) { this . cell helper = new cell helper ( parent ) ; } return cell helper ; }	Gets the cell helper.
public final pictures helper get pic helper ( ) { if ( ( this . pic helper == null ) && ( this . parent != null ) ) { this . pic helper = new pictures helper ( parent ) ; } return pic helper ; }	Gets the pic helper.
public final validation handler get validation handler ( ) { if ( ( this . validation handler == null ) && ( this . parent != null ) ) { this . validation handler = new validation handler ( parent ) ; } return validation handler ; }	Gets the validation handler.
public final chart helper get chart helper ( ) { if ( ( this . chart helper == null ) && ( this . parent != null ) ) { this . chart helper = new chart helper ( parent ) ; } return chart helper ; }	Gets the chart helper.
public static ptg [ ] convert shared formulas ( final ptg [ ] ptgs , final shift formula ref shift formula ref ) { list < ptg > new ptg list = new array list < > ( ) ; object ptg ; for ( int k = num ; k < ptgs . length ; ++ k ) { ptg = ptgs [ k ] ; new ptg list . add all ( arrays . as list ( convert ptg ( ptgs , k , shift formula ref , ptg ) ) ) ; } return new ptg list . to array ( new ptg [ new ptg list . size ( ) ] ) ; }	Convert shared formulas.
private static ptg [ ] convert ptg ( final ptg [ ] ptgs , final int position , final shift formula ref shift formula ref , final object ptg ) { byte original operand class = - num ; if ( ! ( ( ptg ) ptg ) . is base token ( ) ) { original operand class = ( ( ptg ) ptg ) . get ptg class ( ) ; } int current row ; current row = get first supported row num from ptg ( ptg ) ; if ( ( current row >= num ) && shift formula ref . get watch list ( ) . contains ( current row ) ) { return convert ptg for watch list ( ptgs , position , shift formula ref , ptg , original operand class , current row ) ; }	Convert ptg.
private static ptg [ ] convert ptg for watch list ( final ptg [ ] ptgs , final int position , final shift formula ref shift formula ref , final object ptg , final byte original operand class , final int current row ) { list < serial row > rowlist = get rows list ( current row , shift formula ref . get current rows mapping list ( ) ) ; if ( ( rowlist == null ) || ( rowlist . is empty ( ) ) ) {	Convert ptg for watch list.
private static ptg [ ] single ptg ( final object ptg , final byte original operand class , final int formula changed ) { ptg [ ] new ptg = new ptg [ num ] ; if ( original operand class != ( - num ) ) { ( ( ptg ) ptg ) . set class ( original operand class ) ; } object ptg after = ptg ; if ( ptg instanceof func var ptg ) { func var ptg fptg = ( func var ptg ) ptg ; if ( ( formula changed > num ) && ( fptg . get number of operands ( ) != formula changed ) ) { ptg after = func var ptg . create ( ( ( func var ptg ) ptg ) . get name ( ) , formula changed ) ; } } new ptg [ num ] = ( ptg ) ptg after ; return new ptg ; }	Single ptg.
private static list < serial row > get rows list ( final int current row , final list < rows mapping > current rows mapping list ) { list < serial row > all = null ; int size = current rows mapping list . size ( ) ; for ( rows mapping rowsmapping : current rows mapping list ) { list < serial row > current = rowsmapping . get ( current row ) ; if ( current != null ) { if ( size == num ) { return current ; } all = assemble rows list from rows mapping ( all , current ) ; } } return all ; }	Gets the rows list.
private static list < serial row > assemble rows list from rows mapping ( final list < serial row > all , final list < serial row > current ) { list < serial row > list ; if ( all == null ) { list = new array list < > ( ) ; list . add all ( current ) ; } else { list = all ; for ( serial row row : current ) { if ( ! all . contains ( row ) ) { list . add ( row ) ; } } } return list ; }	assemble rowslist from rowsmapping.
private static void build dynamic row for ref ptg base ( final object ptg , final byte original operand class , final list < serial row > row list , final ptg [ ] new ptg , final boolean include parenthesis ) { ref ptg base ref ptg = ( ref ptg base ) ptg ; int unit size = num ; if ( include parenthesis ) { unit size = num ; } for ( int i = num ; i < row list . size ( ) ; i ++ ) { row row = row list . get ( i ) . get row ( ) ; if ( ref ptg instanceof d ) { d ref3d pxg = ( d ) ref ptg ; d new3dpxg = new d ( ref3d pxg . get external workbook number ( ) , new sheet identifier ( null , new name identifier ( ref3d pxg . get sheet name ( ) , bool ) ) , new cell reference ( row . get row num ( ) , ref3d pxg . get column ( ) ) ) ; new3dpxg . set class ( original operand class ) ; new3dpxg . set col relative ( ref3d pxg . is col relative ( ) ) ; new3dpxg . set row relative ( ref3d pxg . is row relative ( ) ) ; new3dpxg . set last sheet name ( ref3d pxg . get last sheet name ( ) ) ; new ptg [ i * unit size ] = new3dpxg ; } else { ref ptg base ref ptg base = ref ptg ; new ptg [ i * unit size ] = new ref ptg ( row . get row num ( ) , ref ptg base . get column ( ) , ref ptg base . is row relative ( ) , ref ptg base . is col relative ( ) ) ; } if ( ( unit size == num ) && ( i < ( row list . size ( ) - num ) ) ) { new ptg [ i * unit size + num ] = parenthesis ptg . instance ; } } }	Builds the dynamic row for ref ptg base.
public static x get bg color ( final ct ct plot , final themes table theme table ) { ct color fill = null ; try { color fill = ct plot . get sp pr ( ) . get solid fill ( ) ; } catch ( exception ex ) { log . log ( level . fine , str , ex ) ; } x xcolor = find automatic fill color ( theme table , color fill ) ; if ( xcolor != null ) { return xcolor ; } else { return new x ( new xssf ( color . white ) ) ; } }	retrieve background color for plot area.
public static x ge color from sp pr ( final int index , final ct ct sp pr , final themes table theme table , final boolean is line color ) { ct color fill = null ; try { if ( is line color ) { color fill = ct sp pr . get ln ( ) . get solid fill ( ) ; } else { color fill = ct sp pr . get solid fill ( ) ; } } catch ( exception ex ) { log . log ( level . fine , str , ex ) ; } x xcolor = find automatic fill color ( theme table , color fill ) ; if ( xcolor != null ) { return xcolor ; } else { return get x ( index , theme table ) ; } }	get line color of line chart from CTLineSer.
private static x find automatic fill color ( final themes table theme table , final ct color fill ) {	Find automatic fill color.
private static x get x ( final ct cts color , final themes table theme table ) { if ( cts color . get val ( ) != null ) { return get x ( cts color . get val ( ) . to string ( ) , num , cts color , theme table ) ; } return null ; }	retrieve xcolor from scheme color.
private static x get x ( final cts ctr color ) { xssf bcolor = null ; try { byte [ ] rgb = ctr color . get val ( ) ; bcolor = new xssf ( rgb ) ; } catch ( exception ex ) { log . log ( level . severe , str + ex . get localized message ( ) , ex ) ; return null ; } int lum off = num ; int lum mod = num ; int alpha str = num ; try { lum off = ctr color . get lum off array ( num ) . get val ( ) ; } catch ( exception ex ) { log . log ( level . fine , str , ex ) ; } try { lum mod = ctr color . get lum mod array ( num ) . get val ( ) ; } catch ( exception ex ) { log . log ( level . fine , str , ex ) ; } try { alpha str = ctr color . get alpha array ( num ) . get val ( ) ; } catch ( exception ex ) { log . log ( level . fine , str , ex ) ; } return assemble xcolor ( bcolor , num , lum off , lum mod , alpha str ) ; }	get xcolor from ctsRgbColor.
private static x get x ( final int index , final themes table theme table ) { int reminder = ( index + num ) % autocolorsize ; if ( reminder == num ) { reminder = autocolorsize ; } string schema = autocolorname + reminder ; double tint = get automatic tint ( index ) ; return get x ( schema , tint , null , theme table ) ; }	Get xcolor for automatic fill setting.
public static color xssf clr to clr ( final xssf xssf color ) { short [ ] rgb = get triplet from xssf ( xssf color ) ; return new color ( rgb [ num ] , rgb [ num ] , rgb [ num ] ) ; }	convert xssf color to color.
public static short [ ] get triplet from xssf ( final xssf xssf color ) { short [ ] rgbfix = { rg bits , rg bits , rg bits } ; if ( xssf color != null ) { byte [ ] rgb = xssf color . get rgb ( ) ; if ( rgb == null ) { rgb = xssf color . get rgb ( ) ; }	Convert xssfcolor to triple let numbers.
static string get bg color from cell ( final workbook wb , final cell poi cell , final cell style cell style ) { string style = str ; if ( poi cell instanceof hssf ) { int bk color index = cell style . get fill foreground color ( ) ; hssf color = hssf . get index hash ( ) . get ( bk color index ) ; if ( color != null ) {	Gets the bg color from cell.
private static string find component name from class ( final ui component ) { string cname = component . get class ( ) . get simple name ( ) ; if ( support components . contains ( cname ) ) { return cname ; } return null ; }	find component according it's class.
public static void populate attributes ( final ui component , final faces cell fcell , final map < string , map < string , string > > default control map ) { list < cell form attributes > input attrs = fcell . get input attrs ( ) ; string cname = find component name from class ( component ) ; if ( cname == null ) { return ; } map < string , string > default map = default control map . get ( cname ) ; if ( default map == null ) { default map = new hash map < > ( ) ; default control map . put ( cname , default map ) ; } for ( map . entry < string , string > entry : default map . entry set ( ) ) { set object property ( component , entry . get key ( ) , entry . get value ( ) , bool ) ; } for ( cell form attributes attr : input attrs ) { string property name = attr . get type ( ) ; string property value = attr . get value ( ) ; if ( ! default map . contains key ( property name ) ) { string default value = get object property value ( component , property name , bool ) ; default map . put ( property name , default value ) ; } set object property ( component , property name , property value , bool ) ; } }	populate attributes.
private static attributes type match para meter of method ( final object obj , final string method name ) { for ( attributes type attr : attributes type . values ( ) ) { try { obj . get class ( ) . get method ( method name , new class [ ] { attr . clazz } ) ; return attr ; } catch ( exception ex ) { log . log ( level . fine , str + ex . get localized message ( ) , ex ) ; } } return null ; }	match parameter of method.
public static void set object property ( final object obj , final string property name , final string property value , final boolean ignore non existing ) { try { string method name = str + character . to upper case ( property name . char at ( num ) ) + property name . substring ( num ) ; attributes type parameter type = match para meter of method ( obj , method name ) ; if ( parameter type != null ) { method method = obj . get class ( ) . get method ( method name , new class [ ] { parameter type . clazz } ) ; method . invoke ( obj , convert to object ( parameter type , property value ) ) ; } } catch ( exception e ) { string msg = str + property name + str + property value + str + obj ; if ( ignore non existing ) { log . log ( level . fine , msg , e ) ; } else { log . warning ( msg ) ; throw new illegal argument exception ( e ) ; } } }	set object property.
public static string get object property value ( final object obj , final string property name , final boolean ignore non existing ) { try { method method = obj . get class ( ) . get method ( str + character . to upper case ( property name . char at ( num ) ) + property name . substring ( num ) ) ; return ( string ) method . invoke ( obj ) ; } catch ( exception e ) { string msg = str + property name + str + obj ; if ( ignore non existing ) { log . log ( level . fine , msg , e ) ; } else { log . warning ( msg ) ; throw new illegal argument exception ( e ) ; } } return null ; }	get object property value.
public static void setup control attributes ( final int origin row index , final faces cell fcell , final cell poi cell , final sheet configuration sheet config , final cell attributes map cell attributes map ) { int row index = origin row index ; if ( row index < num ) { row index = poi cell . get row index ( ) ; } string skey = poi cell . get sheet ( ) . get sheet name ( ) + str + cell utility . get cell index number key ( poi cell . get column index ( ) , row index ) ; map < string , string > comment map = cell attributes map . get template comment map ( ) . get ( str ) ; if ( comment map != null ) { string comment = comment map . get ( skey ) ; if ( comment != null ) { command utility . create cell comment ( poi cell , comment , sheet config . get final comment map ( ) ) ; } } string widget type = cell attributes map . get cell input type ( ) . get ( skey ) ; if ( widget type != null ) { fcell . set control ( widget type . to lower case ( ) ) ; fcell . set input attrs ( cell attributes map . get cell input attributes ( ) . get ( skey ) ) ; fcell . set select item attrs ( cell attributes map . get cell select items attributes ( ) . get ( skey ) ) ; fcell . set date pattern ( cell attributes map . get cell date pattern ( ) . get ( skey ) ) ; } }	Setup control attributes.
public static list < cell form attributes > find cell validate attributes ( final map < string , list < cell form attributes > > validate maps , final int origin row index , final cell cell ) { string key = cell . get sheet ( ) . get sheet name ( ) + str + cell utility . get cell index number key ( cell . get column index ( ) , origin row index ) ; return validate maps . get ( key ) ; }	Find cell validate attributes.
public final void setup faces cell picture charts ( final sheet sheet1 , final faces cell fcell , final cell cell , final string f id ) { if ( parent . get pictures map ( ) != null ) { setup faces cell picture ( sheet1 , fcell , cell , f id ) ; } if ( parent . get chars data ( ) . get charts map ( ) != null ) { setup faces cell charts ( sheet1 , fcell , cell , f id ) ; } }	Setup faces cell picture charts.
private void setup faces cell charts ( final sheet sheet1 , final faces cell fcell , final cell cell , final string f id ) { try { string chart id = parent . get chars data ( ) . get chart position map ( ) . get ( f id ) ; if ( chart id != null ) { buffered image img = parent . get chars data ( ) . get charts map ( ) . get ( chart id ) ; if ( img != null ) { fcell . set contain chart ( bool ) ; fcell . set chart id ( chart id ) ; fcell . set chart style ( pictures utility . generate chart style ( sheet1 , fcell , cell , chart id , parent . get chars data ( ) . get chart anchors map ( ) ) ) ; } } } catch ( exception ex ) { log . log ( level . severe , str + ex . get message ( ) , ex ) ; } }	Setup faces cell charts.
private void setup faces cell picture ( final sheet sheet1 , final faces cell fcell , final cell cell , final string f id ) { try { picture pic = parent . get pictures map ( ) . get ( f id ) ; if ( pic != null ) { fcell . set contain pic ( bool ) ; fcell . set picture id ( f id ) ; fcell . set picture style ( pictures utility . generate picture style ( sheet1 , fcell , cell , pic ) ) ; } } catch ( exception ex ) { log . log ( level . severe , str + ex . get message ( ) , ex ) ; } }	Setup faces cell picture.
private void init charts map ( final workbook wb ) { try { if ( wb instanceof xssf ) { init xssf ( ( xssf ) wb , parent . get chars data ( ) ) ; } } catch ( exception e ) { log . log ( level . severe , str + e . get localized message ( ) , e ) ; } }	initial chart map for specified workbook.
private string get pie title ( final chart data chart data ) { for ( chart series chart series : chart data . get series list ( ) ) { if ( chart series != null ) { return get parsed cell value ( chart series . get series label ( ) ) ; } } return str ; }	return pie chart title from chartData.
public final void set series style ( final j chart , final int series index , final string style ) { if ( chart != null && style != null ) { basic stroke stroke = chart utility . to stroke ( style ) ; plot plot = chart . get plot ( ) ; if ( plot instanceof category plot ) { category plot category plot = chart . get category plot ( ) ; category item renderer cir = category plot . get renderer ( ) ; try { cir . set series stroke ( series index , stroke ) ;	Set color of series.
public j create pie3 d ( final chart data chart data ) {	create pie 3d chart.
private void setup bar style ( final j chart , final chart data chart data ) { setup style ( chart , chart data ) ; category plot plot = ( category plot ) chart . get plot ( ) ; bar renderer renderer = ( bar renderer ) plot . get renderer ( ) ; renderer . set bar painter ( new standard bar painter ( ) ) ; renderer . set item margin ( tie constants . default bar style item margin ) ; plot . set foreground alpha ( tie constants . default barstyle foreground alpha ) ; }	finalize the style for barchart.
private void init xssf ( final xssf wb , final charts data charts data ) { init anchors map ( wb , charts data ) ; map < string , client anchor > anchor map = charts data . get chart anchors map ( ) ; map < string , buffered image > chart map = charts data . get charts map ( ) ; map < string , chart data > chart data map = charts data . get chart data map ( ) ; chart map . clear ( ) ; chart data map . clear ( ) ; for ( int i = num ; i < wb . get number of sheets ( ) ; i ++ ) { xssf sheet = wb . get sheet at ( i ) ; xssf drawing = sheet . create drawing patriarch ( ) ; list < xssf > charts = drawing . get charts ( ) ; if ( ( charts != null ) && ( ! charts . is empty ( ) ) ) { for ( xssf chart : charts ) { generate single xssf ( chart , get chart id from parent ( chart , sheet . get sheet name ( ) ) , sheet , anchor map , chart map , chart data map ) ; } } } }	initial chart map for XSSF format file.
private string get chart id from parent ( final xssf chart , final string sheet name ) { if ( chart . get parent ( ) != null ) { for ( relation part rp : chart . get parent ( ) . get relation parts ( ) ) { if ( rp . get document part ( ) == chart ) { return sheet name + str + rp . get relationship ( ) . get id ( ) ; } } } return null ; }	Gets the chart id from parent.
private void init anchors map ( final workbook wb , final charts data charts data ) { try { if ( wb instanceof xssf ) { chart utility . init xssf ( ( xssf ) wb , charts data ) ; } } catch ( exception e ) { log . log ( level . severe , str + e . get localized message ( ) , e ) ; } }	initial anchors map for specified workbook.
private void generate single xssf ( final xssf chart , final string chart id , final xssf sheet , final map < string , client anchor > anchor map , final map < string , buffered image > chart map , final map < string , chart data > chart data map ) { client anchor anchor ; try { anchor = anchor map . get ( chart id ) ; if ( anchor != null ) { chart data chart data = chart utility . init chart data from xssf ( chart id , chart , ( xssf ) parent . get wb ( ) ) ; chart data map . put ( chart id , chart data ) ; j jchart = create chart ( chart data ) ; if ( jchart != null ) { anchor size anchor size = pictures utility . get anchor size ( sheet , null , null , anchor ) ; buffered image img = jchart . create buffered image ( anchor size . get width ( ) , anchor size . get height ( ) ) ; chart map . put ( chart id , img ) ; } } } catch ( exception ex ) { log . log ( level . severe , str + chart id + str + ex . get localized message ( ) , ex ) ; } }	Generate single XSSF chart.
@ suppress warnings ( str ) public static collection transform to collection object ( final expression engine engine , final string collection name , final map < string , object > context ) { object collection object = engine . evaluate ( collection name , context ) ; if ( ! ( collection object instanceof collection ) ) { throw new evaluation exception ( collection name + str ) ; } return ( collection ) collection object ; }	Transform to collection object.
public static string get full name from row ( final row row ) { if ( row != null ) { cell cell = row . get cell ( tie constants . hidden full name column ) ; if ( cell != null ) { return cell . get string cell value ( ) ; } } return null ; }	Gets the full name from row.
public static void re build upper level formula ( final config build ref config build ref , final string action full name ) { map < cell , string > cached map = config build ref . get cached cells ( ) ; map < string , list < rows mapping > > rows map = new hash map < > ( ) ; for ( map . entry < cell , string > entry : cached map . entry set ( ) ) { cell cell = entry . get key ( ) ; string origin formula = entry . get value ( ) ; if ( origin formula != null ) { setup upper level formula ( cell , origin formula , action full name , rows map , config build ref ) ; } } }	Re build upper level formula.
private static void setup upper level formula ( final cell cell , final string origin formula , final string action full name , final map < string , list < rows mapping > > rows map , final config build ref config build ref ) { string full name = get full name from row ( cell . get row ( ) ) ;	Setup upper level formula.
public static void build cell formula for shifted rows ( final sheet sheet , final xssf wb wrapper , final shift formula ref shift formula ref , final cell cell , final string origin formula ) {	Builds the cell formula for shifted rows.
public static list < rows mapping > gather rows mapping by full name ( final config build ref config build ref , final string full name ) { list < rows mapping > list = new array list < > ( ) ; map < string , config range attrs > shift map = config build ref . get shift map ( ) ; for ( map . entry < string , config range attrs > entry : shift map . entry set ( ) ) { string fname = entry . get key ( ) ; if ( fname . starts with ( full name + str ) || fname . equals ( full name ) ) { config range attrs attrs = entry . get value ( ) ; list . add ( attrs . get unit rows mapping ( ) ) ; } } return list ; }	Gather rows mapping by full name.
public static void change index number in shift map ( final map < string , config range attrs > shift map , final map < string , string > change map ) { for ( map . entry < string , string > entry : change map . entry set ( ) ) { string key = entry . get key ( ) ; string new key = entry . get value ( ) ; config range attrs attrs = shift map . get ( key ) ; if ( attrs != null ) { shift map . remove ( key ) ; shift map . put ( new key , attrs ) ; } } }	Increase index number in shift map.
public static void change upper level final length ( final map < string , config range attrs > shift map , final string added full name , final int increased length ) { string [ ] parts = added full name . split ( str ) ; string builder fname = new string builder ( ) ; for ( int i = num ; i < ( parts . length - num ) ; i ++ ) { if ( i == num ) { fname . append ( parts [ i ] ) ; } else { fname . append ( str ) . append ( parts [ i ] ) ; } string sname = fname . to string ( ) ; shift map . get ( sname ) . set final length ( shift map . get ( sname ) . get final length ( ) + increased length ) ; } }	Increase upper level final length.
public static void change index number in hidden column ( final config build ref config build ref , final int start row index , final string full name , final map < string , string > change map , final int steps ) { string search name = full name . substring ( num , full name . last index of ( str ) + num ) ; sheet sheet = config build ref . get sheet ( ) ; for ( int i = start row index ; i <= sheet . get last row num ( ) ; i ++ ) { row row = sheet . get row ( i ) ; string fname = get full name from row ( row ) ; if ( ( fname != null ) && ( fname . index of ( search name ) >= num ) ) { int sindex = fname . index of ( search name ) ; string snum = fname . substring ( sindex + search name . length ( ) ) ; int sufindex = snum . index of ( str ) ; string suffix = str ; if ( sufindex > num ) { snum = snum . substring ( num , sufindex ) ; suffix = str ; } int increase num = integer . parse int ( snum ) + steps ; string real full name = fname . substring ( sindex ) ; string change name = fname . replace ( search name + snum + suffix , search name + increase num + suffix ) ; if ( change map . get ( real full name ) == null ) { change map . put ( real full name , change name . substring ( sindex ) ) ; } set full name in hidden column ( row , change name ) ; } else { return ; } } }	Change index number in hidden column.
public static void set full name in hidden column ( final row row , final string full name ) { cell cell = row . get cell ( tie constants . hidden full name column , missing cell policy . create null as blank ) ; cell . set cell value ( full name ) ; }	Sets the full name in hidden column.
public static int get original row num in hidden column ( final row row ) { if ( row != null ) { cell cell = row . get cell ( tie constants . hidden origin row number column , missing cell policy . create null as blank ) ; string row num = cell . get string cell value ( ) ; try { if ( ( row num != null ) && ( ! row num . is empty ( ) ) && ( web sheet utility . is numeric ( row num ) ) ) { return integer . parse int ( row num ) ; } } catch ( exception ex ) { log . log ( level . severe , str + row num + str + ex . get localized message ( ) , ex ) ; } } return - num ; }	Gets the original row num in hidden column.
public static void set original row num in hidden column ( final row row , final int row num ) { cell cell = row . get cell ( tie constants . hidden origin row number column , missing cell policy . create null as blank ) ; cell . set cell value ( integer . to string ( row num ) ) ; cell . set cell type ( cell type . string ) ; }	Sets the original row num in hidden column.
public static list < rows mapping > find parent rows mapping from shift map ( final string [ ] parts , final map < string , config range attrs > shift map ) { string builder full name = new string builder ( ) ; list < rows mapping > rows mapping list = new array list < > ( ) ; for ( int i = num ; i < parts . length - num ; i ++ ) { string part = parts [ i ] ; if ( full name . length ( ) == num ) { full name . append ( part ) ; } else { full name . append ( str + part ) ; } if ( full name . length ( ) > num ) { config range attrs range attrs = shift map . get ( full name . to string ( ) ) ; if ( range attrs != null ) { rows mapping list . add ( range attrs . get unit rows mapping ( ) ) ; } } } return rows mapping list ; }	Find parent rows mapping from shift map.
public static list < rows mapping > find child rows mapping from shift map ( final string full name , final navigable map < string , config range attrs > shift map ) { list < rows mapping > rows mapping list = new array list < > ( ) ; navigable map < string , config range attrs > tailmap = shift map . tail map ( full name , bool ) ; for ( map . entry < string , config range attrs > entry : tailmap . entry set ( ) ) { string key = entry . get key ( ) ;	Find child rows mapping from shift map.
@ suppress warnings ( str ) public static object find item in collection ( final collection collection , final int index ) { if ( index >= num ) { if ( collection instanceof list ) { list list = ( list ) collection ; return list . get ( index ) ; } int i = num ; for ( object object : collection ) { if ( i == index ) { return object ; } i ++ ; } } return null ; }	Find item in collection.
public static config range build current range ( final config range source config range , final sheet sheet , final int insert position ) { config range current = new config range ( source config range ) ; int shift num = insert position - source config range . get first row addr ( ) . get row ( ) ; current . shift row ref ( sheet , shift num ) ; return current ; }	Builds the current range.
public static boolean is static row ( final config range source config range , final int row index ) { if ( source config range . get command list ( ) != null ) { for ( int i = num ; i < source config range . get command list ( ) . size ( ) ; i ++ ) { command command = source config range . get command list ( ) . get ( i ) ; if ( ( row index >= command . get config range ( ) . get first row addr ( ) . get row ( ) ) && ( row index < ( command . get config range ( ) . get last row plus addr ( ) . get row ( ) ) ) ) { return bool ; } } } return bool ; }	Whether the row is static.
public static boolean is static row ref ( final config range source config range , final row row ) { if ( source config range . get command list ( ) != null ) { for ( int i = num ; i < source config range . get command list ( ) . size ( ) ; i ++ ) { command command = source config range . get command list ( ) . get ( i ) ; int row index = row . get row num ( ) ; if ( ( row index >= command . get top row ( ) ) && ( row index < ( command . get top row ( ) + command . get final length ( ) ) ) ) { return bool ; } } } return bool ; }	Whether the row is static.This check row after shifted.
public static string replace expression with cell value ( final string attr value , final int row index , final sheet sheet ) { int ibegin = num ; int ifind ; int iname end ; string temp str ; string find str ; string replace str ; string return str = attr value ; while ( ( ifind = attr value . index of ( tie constants . cell addr pre fix , ibegin ) ) > num ) { iname end = parser utility . find first non cell name position ( attr value , ifind ) ; if ( iname end > num ) { find str = attr value . substring ( ifind , iname end ) ; } else { find str = attr value . substring ( ifind ) ; } if ( find str . index of ( tie constants . cell addr pre fix , num ) < num ) {	100 >= 80.
public static map < string , cell range address > index merged region ( final sheet sheet1 ) { int num regions = sheet1 . get num merged regions ( ) ; map < string , cell range address > cell range map = new hash map < > ( ) ; for ( int i = num ; i < num regions ; i ++ ) { cell range address caddress = sheet1 . get merged region ( i ) ; if ( caddress != null ) { cell range map . put ( cell utility . get cell index number key ( caddress . get first column ( ) , caddress . get first row ( ) ) , caddress ) ; } } return cell range map ; }	Index merged region.
public static list < string > skipped region cells ( final sheet sheet1 ) { int num regions = sheet1 . get num merged regions ( ) ; list < string > skip cell list = new array list < > ( ) ; for ( int i = num ; i < num regions ; i ++ ) { cell range address caddress = sheet1 . get merged region ( i ) ; if ( caddress != null ) { add skip cell to list in the region ( skip cell list , caddress ) ; } } return skip cell list ; }	Skipped region cells.
private static void add skip cell to list in the region ( final list < string > skip cell list , final cell range address caddress ) { for ( int col = caddress . get first column ( ) ; col <= caddress . get last column ( ) ; col ++ ) { for ( int row = caddress . get first row ( ) ; row <= caddress . get last row ( ) ; row ++ ) { if ( ( col == caddress . get first column ( ) ) && ( row == caddress . get first row ( ) ) ) { continue ; } skip cell list . add ( cell utility . get cell index number key ( col , row ) ) ; } } }	Add skipped cell into the list of a region.
public static void build sheet comment from alias ( sheet sheet , list < tie command alias > tie command alias list ) { if ( ( tie command alias list == null ) || ( tie command alias list . is empty ( ) ) ) { return ; } for ( row row : sheet ) { for ( cell cell : row ) { build cell comment fromalias ( tie command alias list , cell ) ; } } }	Build Sheet Comment From command alias.
private static void build cell comment fromalias ( list < tie command alias > tie command alias list , cell cell ) { string value = cell utility . get cell value without format ( cell ) ; if ( ( value != null ) && ( ! value . is empty ( ) ) ) { for ( tie command alias alias : tie command alias list ) { matcher matcher = alias . get pattern ( ) . matcher ( value ) ; if ( matcher . find ( ) ) { cell utility . create or insert comment ( cell , alias . get command ( ) ) ; if ( alias . is remove ( ) ) { cell utility . set cell value ( cell , parser utility . remove chars from string ( value , matcher . start ( ) , matcher . end ( ) ) ) ; } } } } }	Builds the cell comment fromalias.
public final map < string , sheet configuration > build configuration ( ) { map < string , sheet configuration > sheet config map = new linked hash map < > ( ) ;	Builds the configuration.
private sheet configuration get sheet configuration ( final sheet sheet , final string form name , final int sheet right col ) { sheet configuration sheet config = new sheet configuration ( ) ; sheet config . set form name ( form name ) ; sheet config . set sheet name ( sheet . get sheet name ( ) ) ; int left col = sheet . get left col ( ) ; int last row = sheet . get last row num ( ) ; int first row = sheet . get first row num ( ) ; int right col = num ; int max row = num ; for ( row row : sheet ) { if ( row . get row num ( ) > tie constants . tie web sheet max rows ) { break ; } max row = row . get row num ( ) ; int first cell num = row . get first cell num ( ) ; if ( first cell num >= num && first cell num < left col ) { left col = first cell num ; } if ( ( row . get last cell num ( ) - num ) > right col ) { int verifiedcol = verify last cell ( row , right col , sheet right col ) ; if ( verifiedcol > right col ) { right col = verifiedcol ; } } } if ( max row < last row ) { last row = max row ; }	Gets the sheet configuration.
private form command build form command from sheet config ( final sheet configuration sheet config , final sheet sheet ) { int first row = sheet config . get body cell range ( ) . get top row ( ) ; int left col = sheet config . get body cell range ( ) . get left col ( ) ; int right col = sheet config . get body cell range ( ) . get right col ( ) ; int last row = sheet config . get body cell range ( ) . get bottom row ( ) ; cell first cell = sheet . get row ( first row ) . get cell ( left col , missing cell policy . create null as blank ) ; form command fcommand = new form command ( ) ; fcommand . set command type name ( tie constants . command form ) ; if ( sheet config . is hidden ( ) ) { fcommand . set hidden ( tie constants . true string ) ; } else { fcommand . set hidden ( tie constants . false string ) ; } fcommand . set name ( sheet config . get form name ( ) ) ; fcommand . get config range ( ) . set first row ref ( first cell , bool ) ; fcommand . get config range ( ) . set last row plus ref ( sheet , right col , last row , bool ) ; fcommand . set header length ( str ) ; fcommand . set footer length ( str ) ; fcommand . set length ( integer . to string ( last row - first row + num ) ) ; return fcommand ; }	Builds the form command from sheet config.
private int verify last cell ( final row row , final int stoppoint , final int sheet right col ) { int last col = sheet right col ; int col ; for ( col = last col ; col >= stoppoint ; col -- ) { cell cell = row . get cell ( col ) ; if ( ( cell != null ) && ( cell . get cell type enum ( ) != cell type . blank ) ) { break ; } } return col ; }	check last column. if it's blank then treat it as null cell.
public final void build sheet ( final sheet sheet , final map < string , sheet configuration > sheet config map , final cell attributes map cell attributes map ) { if ( ( sheet . get last row num ( ) <= num ) && ( sheet . get row ( num ) == null ) ) {	build a sheet for configuration map.
private final void check and repair last row ( final sheet sheet ) {	check and repair the sheet's lastrow.
private list < config command > build command list from sheet comment ( final xssf sheet , final int sheet right col , final cell attributes map cell attributes map ) { list < config command > command list = new array list < > ( ) ;	build command list from comments.
private void set parent for child command ( final list < config command > command list , final int i , final config command child ) { int match index = - num ; config range match range = null ; for ( int j = num ; j < command list . size ( ) ; j ++ ) { if ( j != i ) { command command parent = command list . get ( j ) ; if ( ! command parent . get command type name ( ) . equals ignore case ( tie constants . command form ) && web sheet utility . inside range ( child . get config range ( ) , command parent . get config range ( ) ) && ( ( match range == null ) || ( web sheet utility . inside range ( command parent . get config range ( ) , match range ) ) ) ) { match range = command parent . get config range ( ) ; match index = j ; } } } if ( match index >= num ) { command list . get ( match index ) . get config range ( ) . add command ( child ) ; child . set parent found ( bool ) ; } }	Sets the parent for child command.
private boolean has each command in the list ( final list < config command > command list ) { if ( command list != null ) { for ( config command command : command list ) { if ( command . get command type name ( ) . equals ignore case ( tie constants . command each ) ) { return bool ; } } } return bool ; }	check whether contain each command in the list.
private void match command to sheet config form ( final map < string , sheet configuration > sheet config map , final list < string > form list , final config command command ) { for ( string formname : form list ) { sheet configuration sheet config = sheet config map . get ( formname ) ; if ( web sheet utility . inside range ( command . get config range ( ) , sheet config . get form command ( ) . get config range ( ) ) ) { sheet config . get form command ( ) . get config range ( ) . add command ( command ) ; break ; } } }	Match command to sheet config form.
private void copy template for tie commands ( final sheet sheet ) {	Copy the each command area to seperated sheet.
private list < config command > build command list ( final sheet sheet , final int sheet right col , final cell cell , final list < config command > c list , final cell attributes map cell attributes map ) { comment comment = cell . get cell comment ( ) ; string text = comment . get string ( ) . get string ( ) ; string [ ] comment lines = text . split ( str ) ; string builder new comment = new string builder ( ) ; boolean changed = bool ; for ( string comment line : comment lines ) { string line = comment line . trim ( ) ; if ( parser utility . is command string ( line ) ) { process command line ( sheet , cell , line , c list , sheet right col ) ; changed = bool ; } else if ( parser utility . is empty method string ( line ) || parser utility . is method string ( line ) ) { process method line ( cell , line , cell attributes map ) ; changed = bool ; } else { if ( new comment . length ( ) > num ) { new comment . append ( str + comment line ) ; } else { new comment . append ( comment line ) ; } } } if ( ! changed ) { move comment to map ( cell , text , cell attributes map . get template comment map ( ) , bool ) ; } else {	build command list from comment.
private void process method line ( final cell cell , final string line , final cell attributes map cell attributes map ) { if ( parser utility . is widget method string ( line ) ) { parser utility . parse widget attributes ( cell , line , cell attributes map ) ; } else if ( parser utility . is validate method string ( line ) ) { parser utility . parse validate attributes ( cell , line , cell attributes map ) ; } else { move comment to map ( cell , line , cell attributes map . get template comment map ( ) , bool ) ; } }	Process method line.
private void process command line ( final sheet sheet , final cell cell , final string line , final list < config command > c list , final int sheet right col ) { int name end index = line . index of ( tie constants . attr prefix , tie constants . command prefix . length ( ) ) ; if ( name end index < num ) { string err msg = str + line + str + tie constants . attr prefix + str ; log . severe ( err msg ) ; throw new illegal state exception ( err msg ) ; } string command name = line . substring ( tie constants . command prefix . length ( ) , name end index ) . trim ( ) ; map < string , string > attr map = build attr map ( line , name end index ) ; config command config command = create config command ( sheet , cell , sheet right col , command name , attr map ) ; if ( config command != null ) { c list . add ( config command ) ; } }	Process command line.
private void move comment to map ( final cell cell , final string new comment , final map < string , map < string , string > > sheet comment map , final boolean normal comment ) { string cell key = cell . get sheet ( ) . get sheet name ( ) + str + cell . get column index ( ) + str + cell . get row index ( ) ; parser utility . parse comment to map ( cell key , new comment , sheet comment map , normal comment ) ; }	change the comment.
private config command create config command ( final sheet sheet , final cell first cell , final int sheet right col , final string command name , final map < string , string > attr map ) { @ suppress warnings ( str ) class clas = command map . get ( command name ) ; if ( clas == null ) { log . log ( level . warning , str , command name ) ; return null ; } try { config command command = ( config command ) clas . new instance ( ) ; command . set command type name ( command name ) ; for ( map . entry < string , string > attr : attr map . entry set ( ) ) { web sheet utility . set object property ( command , attr . get key ( ) , attr . get value ( ) , bool ) ; } command . get config range ( ) . set first row ref ( first cell , bool ) ; command . get config range ( ) . set last row plus ref ( sheet , sheet right col , command . get last row ( ) , bool ) ; return command ; } catch ( exception e ) { log . log ( level . warning , str + clas . get name ( ) + str + command name , e ) ; return null ; } }	create configuration command.
private map < string , string > build attr map ( final string command line , final int name end index ) { int params end index = command line . last index of ( tie constants . attr suffix ) ; if ( params end index < num ) { string err msg = str + command line + str + tie constants . attr suffix + str ; throw new illegal argument exception ( err msg ) ; } string attr string = command line . substring ( name end index + num , params end index ) . trim ( ) ; return parser utility . parse command attributes ( attr string ) ; }	Build the attributes map.
private sheet configuration get sheet configuration from config command ( final sheet sheet , final form command fcommand , final int sheet right col ) { sheet configuration sheet config = new sheet configuration ( ) ; sheet config . set form name ( fcommand . get name ( ) ) ; sheet config . set sheet name ( sheet . get sheet name ( ) ) ; int left col = fcommand . get left col ( ) ; int last row = fcommand . get last row ( ) ; int right col = num ; int max row = num ; for ( row row : sheet ) { if ( row . get row num ( ) > tie constants . tie web sheet max rows ) { break ; } max row = row . get row num ( ) ; if ( ( row . get last cell num ( ) - num ) > right col ) { int verifiedcol = verify last cell ( row , right col , sheet right col ) ; if ( verifiedcol > right col ) { right col = verifiedcol ; } } } if ( max row < last row ) { last row = max row ; }	Create sheet configuration from form command.
private void set footer of sheet configuration ( final form command fcommand , final sheet configuration sheet config , final int left col , final int right col ) { string temp str ; if ( fcommand . calc footer length ( ) == num ) { temp str = cell utility . get cell index letter key ( left col , num ) + str + cell utility . get cell index letter key ( right col , num ) ; } else { temp str = cell utility . get cell index letter key ( left col , fcommand . get top row ( ) + fcommand . calc header length ( ) + fcommand . calc body length ( ) ) + str + cell utility . get cell index letter key ( right col , fcommand . get top row ( ) + fcommand . calc header length ( ) ) ; } sheet config . set form footer range ( temp str ) ; sheet config . set footer cell range ( new cell range ( temp str ) ) ; }	Sets the footer of sheet configuration.
private void set body of sheet configuration ( final form command fcommand , final sheet configuration sheet config , final int left col , final int last row , final int right col ) { string temp str ; temp str = cell utility . get cell index letter key ( left col , fcommand . get top row ( ) + fcommand . calc header length ( ) + num ) + str + cell utility . get cell index letter key ( right col , last row + num ) ; sheet config . set form body range ( temp str ) ; sheet config . set body cell range ( new cell range ( temp str ) ) ; sheet config . set form body type ( tie constants . form type free ) ; sheet config . set cell form attributes ( new hash map < string , list < cell form attributes > > ( ) ) ; }	Sets the body of sheet configuration.
private void set header of sheet configuration ( final form command fcommand , final sheet configuration sheet config , final int left col , final int right col ) { string temp str ; if ( fcommand . calc header length ( ) == num ) { temp str = cell utility . get cell index letter key ( left col , num ) + str + cell utility . get cell index letter key ( right col , num ) ; } else { temp str = cell utility . get cell index letter key ( left col , fcommand . get top row ( ) + num ) + str + cell utility . get cell index letter key ( right col , fcommand . get top row ( ) + fcommand . calc header length ( ) ) ; } sheet config . set form header range ( temp str ) ; sheet config . set header cell range ( new cell range ( temp str ) ) ; }	Sets the header of sheet configuration.
@ suppress warnings ( { str } ) public static int delete row ( final config build ref config build ref , final int row index , final map < string , object > data context , final sheet configuration sheet config , final list < faces row > body rows ) { string full name = configuration utility . get full name from row ( config build ref . get sheet ( ) . get row ( row index ) ) ; config build ref . get cell helper ( ) . restore data context ( full name ) ; collection object collect = config build ref . get cell helper ( ) . get last collect ( full name ) ; collection last collection = collect . get last collection ( ) ; int last collection index = collect . get last collection index ( ) ; each command each command = collect . get each command ( ) ; if ( last collection index < num ) {	Delete row.
private static void remove ranges from shift map ( final navigable map < string , config range attrs > shift map , final list < string > remove full name list ) { for ( string fname : remove full name list ) { shift map . remove ( fname ) ; } }	Removes the ranges from shift map.
private static list < string > find remove full name list ( final sheet sheet , final int start row , final int end row ) { list < string > list = new array list < > ( ) ; for ( int row index = start row ; row index <= end row ; row index ++ ) { string full name = configuration utility . get full name from row ( sheet . get row ( row index ) ) ; if ( ! list . contains ( full name ) ) { list . add ( full name ) ; } } return list ; }	Find remove full name list.
public static each command get each command from parts name ( final map < string , command > command index map , final string [ ] varparts ) { if ( varparts . length == tie constants . default command part length ) { return ( each command ) command index map . get ( tie constants . each command full name prefix + varparts [ num ] ) ; } return null ; }	Gets the each command from parts name.
@ suppress warnings ( { str , str } ) private static string insert empty object in context ( final string full name , final collection last collection , final each command each command , final int last collection index , final map < string , object > data context ) { if ( ! ( last collection instanceof list ) ) { throw new evaluation exception ( str ) ; } list collection list = ( list ) last collection ;	Insert empty object in context.
@ suppress warnings ( { str } ) private static void delete object in context ( final collection last collection , final each command each command , final int last collection index , final map < string , object > data context ) { if ( ! ( last collection instanceof list ) ) { throw new evaluation exception ( each command . get var ( ) + tie constants . each command invalid msg ) ; } list collection list = ( list ) last collection ;	Delete object in context.
@ suppress warnings ( str ) public static int prepare collection data in context ( final string [ ] varparts , final collection collection , final map < string , object > data context ) { if ( varparts . length == tie constants . default command part length ) { int collection index = integer . parse int ( varparts [ num ] ) ; object obj = configuration utility . find item in collection ( collection , collection index ) ; if ( obj != null ) { data context . put ( varparts [ num ] , obj ) ; return collection index ; } } return - num ; }	Prepare collection data in context.
public static void index command range ( final config range source config range , final map < string , command > index map ) { if ( source config range . get command list ( ) != null ) { for ( int i = num ; i < source config range . get command list ( ) . size ( ) ; i ++ ) { command command = source config range . get command list ( ) . get ( i ) ; index map . put ( command . get command name ( ) , command ) ; command . get config range ( ) . index command range ( index map ) ; } } }	Index command range.
public static boolean is row allow add ( final row row , final sheet configuration sheet config ) { string full name = configuration utility . get full name from row ( row ) ; if ( full name != null ) { config range attrs attrs = sheet config . get shift map ( ) . get ( full name ) ; if ( ( attrs != null ) && ( attrs . is allow add ( ) ) && ( row . get row num ( ) == attrs . get first row ref ( ) . get row index ( ) ) ) { return bool ; } } return bool ; }	Checks if is row allow add.
public static void insert each template ( final config range source config range , final config build ref config build ref , final int index , final int insert position , final rows mapping unit rows mapping ) { int src start row = source config range . get first row addr ( ) . get row ( ) ; int src end row = source config range . get last row plus addr ( ) . get row ( ) - num ; sheet sheet = config build ref . get sheet ( ) ; workbook wb = sheet . get workbook ( ) ;	Insert each template.
public static void evaluate normal cells ( final cell cell , final string str value , final map < string , object > context , final expression engine engine ) { if ( str value . contains ( tie constants . method prefix ) ) { object evaluation result = evaluate ( str value , context , engine ) ; if ( evaluation result == null ) { evaluation result = str ; } cell utility . set cell value ( cell , evaluation result . to string ( ) ) ; create tie cell ( cell , context , engine ) ; } }	Evaluate normal cells.
private static void evaluate user formula ( final cell cell , final string str value ) { string formula str = str value . substring ( num , str value . length ( ) - num ) ; if ( ( formula str != null ) && ( ! formula str . is empty ( ) ) ) { cell . set cell formula ( formula str ) ; } }	Evaluate user formula.
private static boolean is user formula ( final string str ) { return str . starts with ( tie constants . user formula prefix ) && str . ends with ( tie constants . user formula suffix ) ; }	Checks if is user formula.
public static void create cell comment ( final cell cell , final string new comment , final map < cell , string > final comment map ) {	Creates the cell comment.
public static boolean eval bool expression ( final expression engine exp engine , final string pscript ) { object result = null ; string script = str + pscript + str ; script = script . to upper case ( ) . replace ( str , str ) ; script = script . to upper case ( ) . replace ( str , str ) ; try { result = exp engine . evaluate ( script ) ; } catch ( exception e ) { log . log ( level . severe , str + script + str + e . get localized message ( ) , e ) ; } if ( result != null ) { return ( ( boolean ) result ) . boolean value ( ) ; } else { return bool ; } }	evaluate boolean express.
public static void remove rows in sheet ( final sheet sheet , final int row index start , final int row index end , final map < cell , string > cached map ) { for ( int irow = row index start ; irow <= row index end ; irow ++ ) { remove cached cell for row ( sheet , irow , cached map ) ; } int irows = row index end - row index start + num ; if ( ( irows < num ) || ( row index start < num ) ) { return ; } int last row num = sheet . get last row num ( ) ; if ( row index end < last row num ) { sheet . shift rows ( row index end + num , last row num , - irows ) ; } if ( row index end == last row num ) {	Remove the rows.
private static void remove single row in sheet ( final sheet sheet , final int row index start ) { row removing row = sheet . get row ( row index start ) ; if ( removing row != null ) { sheet . remove row ( removing row ) ; } }	Removes the single row in sheet.
private static void remove cached cell for row ( final sheet sheet , final int row index start , final map < cell , string > cached map ) { row removing row = sheet . get row ( row index start ) ; if ( removing row != null ) {	Removes the cached cell for row.
public static void remove rows in body ( final sheet configuration sheet config , final list < faces row > body rows , final int row index start , final int row index end ) { int top = sheet config . get body cell range ( ) . get top row ( ) ; if ( ( row index end < row index start ) || ( row index start < top ) ) { return ; } int irows = row index end - row index start + num ; for ( int row index = row index end ; row index >= row index start ; row index -- ) { body rows . remove ( row index - top ) ; } for ( int irow = row index start - top ; irow < body rows . size ( ) ; irow ++ ) { faces row facesrow = body rows . get ( irow ) ; facesrow . set row index ( facesrow . get row index ( ) - irows ) ; } }	Removes the rows in body.
private string load picture ( final int row index , final int col index ) { faces cell faces cell = parent . get cell helper ( ) . get faces cell with row col from current page ( row index , col index ) ; if ( faces cell != null && faces cell . is contain pic ( ) ) { faces context context = faces context . get current instance ( ) ; string picture id = faces cell . get picture id ( ) ; string picture view id = integer . to hex string ( system . identity hash code ( parent . get wb ( ) ) ) + picture id ; map < string , object > session map = context . get external context ( ) . get session map ( ) ; if ( session map . get ( picture view id ) == null ) { session map . put ( picture view id , parent . get pictures map ( ) . get ( picture id ) . get picture data ( ) ) ; } return picture view id ; } else { return null ; } }	Put picture image to session map and return the key to web.
private string load chart ( final int row index , final int col index ) { faces cell faces cell = parent . get cell helper ( ) . get faces cell with row col from current page ( row index , col index ) ; if ( faces cell != null && faces cell . is contain chart ( ) ) { faces context context = faces context . get current instance ( ) ; string chart id = faces cell . get chart id ( ) ; string chart view id = integer . to hex string ( system . identity hash code ( parent . get wb ( ) ) ) + chart id ; if ( context != null ) { map < string , object > session map = context . get external context ( ) . get session map ( ) ; if ( session map . get ( chart view id ) == null ) { session map . put ( chart view id , parent . get chars data ( ) . get charts map ( ) . get ( chart id ) ) ; } } return chart view id ; } else { return null ; } }	Put chart image to session map and return the key to web.
private string assemble new value ( final object value , final faces cell faces cell ) { string new value ; if ( value instanceof java . util . date ) { string date pattern = faces cell . get date pattern ( ) ; if ( date pattern == null || date pattern . is empty ( ) ) { date pattern = parent . get default date pattern ( ) ; } format formatter = new simple date format ( date pattern ) ; new value = formatter . format ( value ) ; } else { new value = ( string ) value ; } if ( str . equals ignore case ( faces cell . get input type ( ) ) && ( new value != null ) ) {	Assemble new value.
@ suppress warnings ( str ) public static string get cell value with format ( final cell poi cell , final formula evaluator formula evaluator , final data formatter data formatter ) { if ( poi cell == null ) { return null ; } string result ; try { cell type cell type = poi cell . get cell type enum ( ) ; if ( cell type == cell type . formula ) { cell type = formula evaluator . evaluate ( poi cell ) . get cell type enum ( ) ; } if ( cell type == cell type . error ) { result = str ; } else { result = data formatter . format cell value ( poi cell , formula evaluator ) ; } } catch ( exception e ) { log . log ( level . severe , str + poi cell . get row index ( ) + str + poi cell . get column index ( ) + str + e . get localized message ( ) + str , e ) ; result = str ; } return result ; }	return cell value with format.
@ suppress warnings ( str ) public static string get cell value without format ( final cell poi cell ) { if ( poi cell == null ) { return null ; } if ( poi cell . get cell type enum ( ) == cell type . formula ) { return get cell string value with type ( poi cell , poi cell . get cached formula result type enum ( ) ) ; } else { return get cell string value with type ( poi cell , poi cell . get cell type enum ( ) ) ; } }	get input cell value. none input return blank.
private static string get cell string value with type ( final cell poi cell , final cell type cell type ) { switch ( cell type ) { case boolean : return get cell string value with boolean type ( poi cell ) ; case numeric : return get cell string value with number type ( poi cell ) ; case string : return poi cell . get string cell value ( ) ; default : return str ; }	Get cell value as string but with giving type.
private static string get cell string value with number type ( final cell poi cell ) { string result ; if ( date util . is cell date formatted ( poi cell ) ) { result = poi cell . get date cell value ( ) . to string ( ) ; } else { result = big decimal . value of ( poi cell . get numeric cell value ( ) ) . to plain string ( ) ;	Gets the cell string value with number type.
@ suppress warnings ( str ) public static cell set cell value ( final cell c , final string value ) { try { if ( value . length ( ) == num ) { c . set cell type ( cell type . blank ) ; } else if ( web sheet utility . is numeric ( value ) ) { set cell value number ( c , value ) ; } else if ( web sheet utility . is date ( value ) ) { set cell value date ( c , value ) ; } else if ( c . get cell type enum ( ) == cell type . boolean ) { set cell value boolean ( c , value ) ; } else { set cell value string ( c , value ) ; } } catch ( exception e ) { log . log ( level . severe , str + e . get localized message ( ) , e ) ; set cell value string ( c , value ) ; } return c ; }	Set cell value with giving String value.
private static void set cell value string ( final cell c , final string value ) { c . set cell type ( cell type . string ) ; c . set cell value ( value ) ; }	Sets the cell value string.
private static void set cell value boolean ( final cell c , final string value ) { if ( str . equals ignore case ( value ) || str . equals ignore case ( value ) || str . equals ignore case ( value ) ) { c . set cell value ( bool ) ; } else { c . set cell value ( bool ) ; } }	Sets the cell value boolean.
private static void set cell value date ( final cell c , final string value ) { string date = web sheet utility . parse date ( value ) ; set cell value string ( c , date ) ; }	Sets the cell value date.
private static void set cell value number ( final cell c , final string value ) { double val = double . parse double ( value . replace ( character . to string ( str ) , str ) ) ; c . set cell type ( cell type . numeric ) ; c . set cell value ( val ) ; }	Sets the cell value number.
public static void copy rows ( final sheet src sheet , final sheet dest sheet , final int src row start , final int src row end , final int dest row , final boolean check lock , final boolean set hidden column ) { int length = src row end - src row start + num ; if ( length <= num ) { return ; } dest sheet . shift rows ( dest row , dest sheet . get last row num ( ) , length , bool , bool ) ; for ( int i = num ; i < length ; i ++ ) { copy single row ( src sheet , dest sheet , src row start + i , dest row + i , check lock , set hidden column ) ; }	Copy rows.
private static void copy single row ( final sheet src sheet , final sheet dest sheet , final int source row num , final int destination row num , final boolean check lock , final boolean set hidden column ) {	Copy single row.
public static cell copy cell ( final sheet dest sheet , final row source row , final row new row , final int cell index , final boolean check lock ) {	Copy cell.
@ suppress warnings ( str ) private static void copy cell set value ( final cell source cell , final cell new cell , final boolean check lock ) { cell style new cell style = new cell . get cell style ( ) ; string name = source cell . get cell type enum ( ) . to string ( ) ; cell value type e = enum . value of ( cell value type . class , name ) ; e . set cell value ( new cell , source cell , check lock , new cell style ) ; }	set cell value.
@ suppress warnings ( str ) private static void copy cell set style ( final sheet dest sheet , final cell source cell , final cell new cell ) { cell style new cell style = get cell style from source cell ( dest sheet , source cell ) ; new cell . set cell style ( new cell style ) ;	set up cell style.
public static void clone comment ( final cell source cell , final cell new cell ) { xssf sheet = ( xssf ) new cell . get sheet ( ) ; creation helper factory = sheet . get workbook ( ) . get creation helper ( ) ; drawing drawing = sheet . create drawing patriarch ( ) ; xssf source comment = ( xssf ) source cell . get cell comment ( ) ;	clone existing comments into new cell comment.
private static client anchor create comment anchor ( final cell new cell , creation helper factory ) { client anchor anchor = factory . create client anchor ( ) ; anchor . set col1 ( new cell . get column index ( ) ) ; anchor . set col2 ( new cell . get column index ( ) + num ) ; anchor . set row1 ( new cell . get row index ( ) ) ; anchor . set row2 ( new cell . get row index ( ) + num ) ; return anchor ; }	Creates the comment anchor.
public static void create or insert comment ( final cell cell , final string comment str ) { xssf sheet = ( xssf ) cell . get sheet ( ) ; creation helper factory = sheet . get workbook ( ) . get creation helper ( ) ; drawing drawing = sheet . create drawing patriarch ( ) ; comment comment = cell . get cell comment ( ) ; string origin str = str ; if ( comment == null ) {	Creates the or insert comment.
private static void match comment settings ( final cell new cell , final cell source cell ) { try { xssfvml source vml = get vml drawing from cell ( source cell ) ; xssfvml target vml = get vml drawing from cell ( new cell ) ; ct source ct shape = get ct shape from vml ( source cell , source vml ) ; ct target ct shape = get ct shape from vml ( new cell , target vml ) ; target ct shape . set type ( source ct shape . get type ( ) ) ; ct source client data = source ct shape . get client data array ( num ) ; ct target client data = target ct shape . get client data array ( num ) ; string [ ] anchor array = source client data . get anchor list ( ) . get ( num ) . split ( str ) ; int shift rows = new cell . get row index ( ) - source cell . get row index ( ) ; anchor array [ num ] = integer . to string ( integer . parse int ( anchor array [ num ] . trim ( ) ) + shift rows ) ; anchor array [ num ] = integer . to string ( integer . parse int ( anchor array [ num ] . trim ( ) ) + shift rows ) ; target client data . get anchor list ( ) . set ( num , faces utility . str join ( anchor array , str ) ) ; } catch ( exception e ) { log . log ( level . severe , str + e . get localized message ( ) , e ) ; } }	Use low level API to match the comments setting.
private static xssfvml get vml drawing from cell ( final cell cell ) { xssf source sheet = ( xssf ) cell . get sheet ( ) ; for ( poixml source part : source sheet . get relations ( ) ) { if ( ( source part != null ) && ( source part instanceof xssfvml ) ) { return ( xssfvml ) source part ; } } return null ; }	Find vmldrawing part according to cell.
@ suppress warnings ( str ) private static ct get ct shape from vml ( final cell source cell , xssfvml source vml ) throws reflective operation exception { method findshape ;	Find CtShape from vml object.
private static cell style get cell style from source cell ( final sheet dest sheet , final cell source cell ) { workbook wb = dest sheet . get workbook ( ) ;	create cell style from source cell.
public static void convert cell ( final sheet configuration sheet config , final faces cell fcell , final cell poi cell , final map < string , cell range address > cell range map , final int origin row index , final cell attributes map cell attributes map , final string save attrs ) { cell range address caddress ; string key = get cell index number key ( poi cell ) ; caddress = cell range map . get ( key ) ; if ( caddress != null ) {	set up facesCell's attribute from poiCell and others.
public static int [ ] get row col from component attributes ( final ui target ) { int row index = ( integer ) target . get attributes ( ) . get ( str ) ; int col index = ( integer ) target . get attributes ( ) . get ( str ) ; int [ ] list = new int [ num ] ; list [ num ] = row index ; list [ num ] = col index ; return list ; }	Gets the row col from component attributes.
public static int get init rows from config ( final sheet configuration sheet config ) { int init rows = num ; if ( str . equals ignore case ( sheet config . get form body type ( ) ) ) { init rows = sheet config . get body initial rows ( ) ; if ( init rows < num ) { init rows = num ; } } return init rows ; }	Gets the inits the rows from config.
public static faces row get faces row from body row ( final int row , final list < faces row > body rows , final int top row ) { faces row frow = null ; try { frow = body rows . get ( row - top row ) ; } catch ( exception e ) { log . log ( level . severe , str + row + str + top row + str + e . get localized message ( ) , e ) ; } return frow ; }	Gets the faces row from body row.
public static faces cell get faces cell from body row ( final int row , final int col , final list < faces row > body rows , final int top row , final int left col ) { faces cell cell = null ; try { cell = body rows . get ( row - top row ) . get cells ( ) . get ( col - left col ) ; } catch ( exception e ) { log . log ( level . severe , str + row + str + col + str + top row + str + left col + str + e . get localized message ( ) , e ) ; } return cell ; }	Gets the faces cell from body row.
public static cell get poi cell from sheet ( final int row index , final int col index , final sheet sheet1 ) { if ( ( sheet1 != null ) && ( sheet1 . get row ( row index ) != null ) ) { return sheet1 . get row ( row index ) . get cell ( col index ) ; } return null ; }	Gets the poi cell from sheet.
public static string get skey from poi cell ( final cell poi cell ) { return poi cell . get sheet ( ) . get sheet name ( ) + str + cell utility . get cell index number key ( poi cell . get column index ( ) , poi cell . get row index ( ) ) ; }	Gets the skey from poi cell.
public static tie cell get or add tie cell in map ( final cell poi cell , hash map < string , tie cell > tie cells ) { string skey = cell utility . get skey from poi cell ( poi cell ) ; tie cell tie cell = tie cells . get ( skey ) ; if ( tie cell == null ) { tie cell = new tie cell ( ) ; tie cell . set skey ( skey ) ; tie cells . put ( skey , tie cell ) ; } return tie cell ; }	Gets the or add tie cell in map.
public final string get current data context name ( ) { if ( current data context name == null ) { string builder sb = new string builder ( ) ; list < string > list = this . get current data context name list ( ) ; for ( int i = num ; i < list . size ( ) ; i ++ ) { if ( i > num ) { sb . append ( str + list . get ( i ) ) ; } else { sb . append ( list . get ( i ) ) ; } } this . set current data context name ( sb . to string ( ) ) ; } return current data context name ; }	Gets the current data context name.
public final object evaluate ( final string expression , final map < string , object > context ) { jexl context jexl context = new map context ( context ) ; try { jexl engine jexl = jexl local . get ( ) ; map < string , expression > exp map = jexl map local . get ( ) ; expression jexl expression = exp map . get ( expression ) ; if ( jexl expression == null ) { jexl expression = jexl . create expression ( expression ) ; exp map . put ( expression , jexl expression ) ; } return jexl expression . evaluate ( jexl context ) ; } catch ( exception e ) { throw new evaluation exception ( e ) ; } }	Evaluate the expression.
public final object evaluate ( final map < string , object > context ) { jexl context jexl context = new map context ( context ) ; try { return j expression . evaluate ( jexl context ) ; } catch ( exception e ) { throw new evaluation exception ( str + j expression . get expression ( ) , e ) ; } }	evaluate from giving context.
private void write object ( final java . io . object output stream out ) throws io { this . row index = this . get row ( ) . get row num ( ) ; out . default write object ( ) ; }	save the row before serialize.
public final void remove row ( final integer source row num , final row target row ) { list < serial row > map row list = rows map . get ( source row num ) ; if ( map row list != null ) { map row list . remove ( new serial row ( target row , - num ) ) ; rows map . put ( source row num , map row list ) ; } }	Removes the row.
public final void merge map ( final rows mapping add map ) { map < integer , list < serial row > > map = add map . get rows map ( ) ; for ( map . entry < integer , list < serial row > > entry : map . entry set ( ) ) { list < serial row > entry row list = entry . get value ( ) ; if ( ( entry row list != null ) && ( ! entry row list . is empty ( ) ) ) { for ( serial row row : entry row list ) { this . add row ( entry . get key ( ) , row . get row ( ) ) ; } } } }	Merge map.
public final void recover ( final sheet sheet ) { for ( map . entry < integer , list < serial row > > entry : this . get rows map ( ) . entry set ( ) ) { list < serial row > list row = entry . get value ( ) ; for ( serial row serial row : list row ) { serial row . recover ( sheet ) ; } } }	recover rows mapping by using it's address.
public static chart type get chart type ( final ct ct chart ) { ct plot area = ct chart . get plot area ( ) ; for ( chart type chart type : chart type . values ( ) ) { if ( chart type . is this type ( plot area ) ) { return chart type ; } } return null ; }	return chart type from CTChart object.
public static basic stroke to stroke ( final string style ) { basic stroke result = null ; if ( style != null ) { float line width = stroke default line width ; float [ ] dash = { stroke default dash width } ; float [ ] dot = { line width } ; if ( style . equals ignore case ( style line ) ) { result = new basic stroke ( line width ) ; } else if ( style . equals ignore case ( style dash ) ) { result = new basic stroke ( line width , basic stroke . cap butt , basic stroke . join miter , stroke miter limit style dash , dash , stroke default dashphase ) ; } else if ( style . equals ignore case ( style dot ) ) { result = new basic stroke ( line width , basic stroke . cap butt , basic stroke . join miter , stroke miter limit style dot , dot , stroke default dashphase ) ; } } return result ; }	Convert style string to stroke object.
public static chart data init chart data from xssf ( final string chart id , final xssf chart , final xssf wb ) { themes table theme table = wb . get styles source ( ) . get theme ( ) ; chart data chart data = new chart data ( ) ; xssf chart title = chart . get title ( ) ; if ( chart title != null ) { chart data . set title ( chart title . to string ( ) ) ; } ct ct chart = chart . get ct ( ) ; chart type chart type = chart utility . get chart type ( ct chart ) ; if ( chart type == null ) { throw new illegal chart exception ( str ) ; } chart data . set bg color ( color utility . get bg color ( ct chart . get plot area ( ) , theme table ) ) ; chart data . set id ( chart id ) ; chart data . set type ( chart type ) ; list < ct > ct cat ax list = ct chart . get plot area ( ) . get cat ax list ( ) ; if ( ( ct cat ax list != null ) && ( ! ct cat ax list . is empty ( ) ) ) { chart data . set cat ax ( new chart axis ( ct cat ax list . get ( num ) ) ) ; } list < ct > ct val ax list = ct chart . get plot area ( ) . get val ax list ( ) ; if ( ( ct val ax list != null ) && ( ! ct val ax list . is empty ( ) ) ) { chart data . set val ax ( new chart axis ( ct val ax list . get ( num ) ) ) ; } chart object ct obj = chart type . create chart object ( ) ; if ( ct obj == null ) { throw new illegal chart exception ( str ) ; } set up chart data ( chart data , ct chart , theme table , ct obj ) ; return chart data ; }	init chart data.
public static void set up chart data ( final chart data chart data , final ct ct chart , final themes table theme table , final chart object ct obj ) { object chart obj = null ; @ suppress warnings ( str ) list plot charts = ct obj . get chart list from ct chart ( ct chart ) ;	build chartData for line chart.
public static void init xssf ( final xssf wb , final charts data chars data ) { map < string , client anchor > anchort map = chars data . get chart anchors map ( ) ; map < string , string > position map = chars data . get chart position map ( ) ; anchort map . clear ( ) ; position map . clear ( ) ; for ( int i = num ; i < wb . get number of sheets ( ) ; i ++ ) { init xssf ( anchort map , position map , wb . get sheet at ( i ) ) ; } }	retrieve anchor information from draw.xml for all the charts in theworkbook.
private static void init xssf ( final map < string , client anchor > anchort map , final map < string , string > position map , final xssf sheet ) { xssf drawing = sheet . create drawing patriarch ( ) ; ct ct drawing = drawing . get ct ( ) ; if ( ct drawing . size of two cell anchor array ( ) <= num ) { return ; } list < ct > alist = ct drawing . get two cell anchor list ( ) ; for ( int j = num ; j < alist . size ( ) ; j ++ ) { ct ctanchor = alist . get ( j ) ; string single chart id = get anchor associate chart id ( ctanchor ) ; if ( single chart id != null ) { string chart id = sheet . get sheet name ( ) + str + single chart id ; int dx1 = ( int ) ctanchor . get from ( ) . get col off ( ) ; int dy1 = ( int ) ctanchor . get from ( ) . get row off ( ) ; int dx2 = ( int ) ctanchor . get to ( ) . get col off ( ) ; int dy2 = ( int ) ctanchor . get to ( ) . get row off ( ) ; int col1 = ctanchor . get from ( ) . get col ( ) ; int row1 = ctanchor . get from ( ) . get row ( ) ; int col2 = ctanchor . get to ( ) . get col ( ) ; int row2 = ctanchor . get to ( ) . get row ( ) ; anchort map . put ( chart id , new xssf ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; position map . put ( web sheet utility . get full cell ref name ( sheet . get sheet name ( ) , row1 , col1 ) , chart id ) ; } } }	Inits the XSSF anchors map for sheet.
private static string get anchor associate chart id ( final ct ctanchor ) { if ( ctanchor . get graphic frame ( ) == null ) { return null ; } node parent node = ctanchor . get graphic frame ( ) . get graphic ( ) . get graphic data ( ) . get dom node ( ) ; node list child nodes = parent node . get child nodes ( ) ; for ( int i = num ; i < child nodes . get length ( ) ; i ++ ) { node child node = child nodes . item ( i ) ; if ( ( child node != null ) && ( str . equals ignore case ( child node . get node name ( ) ) ) && ( child node . has attributes ( ) ) ) { string r id = get chart id from child node attributes ( child node . get attributes ( ) ) ; if ( r id != null ) { return r id ; } } } return null ; }	Gets the anchor associate chart id.
private static string get chart id from child node attributes ( final named node map attrs ) { for ( int j = num ; j < attrs . get length ( ) ; j ++ ) { attr attribute = ( attr ) attrs . item ( j ) ; if ( str . equals ignore case ( attribute . get name ( ) ) ) { return attribute . get value ( ) ; } } return null ; }	Gets the chart id from child node attributes.
@ suppress warnings ( str ) private int build each objects ( string full name , final config build ref config build ref , final int at row , final map < string , object > context , final list < rows mapping > current rows mapping list , final collection items collection , final string obj class name ) { int index = num ; int insert position = at row ; string this obj class name = obj class name ;	Builds the each objects.
public final void save data in context ( final cell poi cell , final string str value ) { string save attr = save attrs utility . prepare context and attrs for cell ( poi cell , configuration utility . get full name from row ( poi cell . get row ( ) ) , this ) ; if ( save attr != null ) { save attrs utility . save data to object in context ( parent . get serial data context ( ) . get data context ( ) , save attr , str value , parent . get exp engine ( ) ) ; parent . get helper ( ) . get web sheet loader ( ) . set unsaved status ( request context . get current instance ( ) , bool ) ; } }	Save data in context.
public final void re calc ( ) { parent . get formula evaluator ( ) . clear all cached result values ( ) ; try { parent . get formula evaluator ( ) . evaluate all ( ) ; } catch ( exception ex ) {	recalc whole workbook.
public final cell get poi cell with row col from tab ( final int row index , final int col index , final string tab name ) { if ( parent . get wb ( ) != null ) { return cell utility . get poi cell from sheet ( row index , col index , parent . get wb ( ) . get sheet ( parent . get sheet config map ( ) . get ( tab name ) . get sheet name ( ) ) ) ; } return null ; }	Gets the poi cell with row col from tab.
public final faces cell get faces cell with row col from current page ( final int row index , final int col index ) { if ( parent . get body rows ( ) != null ) { int top = parent . get current ( ) . get current top row ( ) ; int left = parent . get current ( ) . get current left column ( ) ; return parent . get body rows ( ) . get ( row index - top ) . get cells ( ) . get ( col index - left ) ; } return null ; }	Gets the faces cell with row col from current page.
public final void restore data context ( final string full name ) { string [ ] parts = full name . split ( str ) ; if ( ! is need restore ( full name , parts ) ) { return ; } boolean stop skip = bool ; list < string > list = parent . get current ( ) . get current data context name list ( ) ; int list size = list . size ( ) ;	Restore data context.
public final collection object get last collect ( final string full name ) { string [ ] parts = full name . split ( str ) ; string part = parts [ parts . length - num ] ; return start restore data context ( part ) ; }	Get last collect object from full name.Last collect contain each command, collection and index.
private boolean is need restore ( final string full name , final string [ ] parts ) { if ( full name == null ) { return bool ; } if ( ( parent . get current ( ) . get current data context name ( ) != null ) && ( parent . get current ( ) . get current data context name ( ) . to lower case ( ) . starts with ( full name . to lower case ( ) ) ) ) { return bool ; } return ( ( parts != null ) && ( parts . length > num ) ) ; }	Checks if is need restore.
private collection object start restore data context ( final string part ) { if ( part . starts with ( tie constants . each command full name prefix ) ) { string [ ] varparts = part . split ( str ) ; collection object collect = new collection object ( ) ; collect . set each command ( command utility . get each command from parts name ( parent . get current sheet config ( ) . get command index map ( ) , varparts ) ) ; collect . set last collection ( configuration utility . transform to collection object ( parent . get exp engine ( ) , collect . get each command ( ) . get items ( ) , parent . get serial data context ( ) . get data context ( ) ) ) ; collect . set last collection index ( command utility . prepare collection data in context ( varparts , collect . get last collection ( ) , parent . get serial data context ( ) . get data context ( ) ) ) ; return collect ; } return null ; }	Start restore data context.
public final void shift row ref ( final sheet sheet , final int shiftnum ) { try { this . set first row ref ( sheet . get row ( attrs . get first row addr ( ) . get row ( ) + shiftnum ) . get cell ( attrs . get first row addr ( ) . get column ( ) , missing cell policy . create null as blank ) , bool ) ; this . set last row plus ref ( sheet , attrs . get last row plus addr ( ) . get column ( ) , attrs . get last row plus addr ( ) . get row ( ) + shiftnum - num , bool ) ; if ( command list != null ) { for ( config command command : command list ) { command . shift row ref ( sheet , shiftnum ) ; } } } catch ( exception ex ) { log . log ( level . severe , str + ex . get localized message ( ) , ex ) ; } }	Shift row ref.
public final void set first row ref ( final cell p first row ref , final boolean also create addr ) { this . attrs . set first row ref ( p first row ref ) ; if ( also create addr ) { this . set first row addr ( new serial cell address ( p first row ref ) ) ; } }	set first cell also set static relative address firstCellAddress.
public final void set last row plus ref ( final sheet sheet , final int right col , final int last row , final boolean also set addr ) { if ( ( last row >= num ) && ( sheet != null ) && ( right col >= num ) ) { row row = sheet . get row ( last row + num ) ; if ( row == null ) { row = sheet . create row ( last row + num ) ; } cell cell = row . get cell ( right col ) ; if ( cell == null ) { cell = row . get cell ( right col , missing cell policy . create null as blank ) ; this . attrs . set last cell created ( bool ) ; } else { this . attrs . set last cell created ( bool ) ; } this . attrs . set last row plus ref ( cell ) ; if ( also set addr ) { this . set last row plus addr ( new serial cell address ( cell ) ) ; } } else { this . attrs . set last row plus ref ( null ) ; if ( also set addr ) { this . attrs . set last row plus addr ( null ) ; } } }	set last cell also set static relative address lastCellAddress.
private void build cells for row ( final row row , final string full name , final map < string , object > context , final config build ref config build ref , shift formula ref shift formula ref ) { if ( ( row == null ) || ! configuration utility . is static row ref ( this , row ) ) { return ; } for ( cell cell : row ) { build single cell ( cell , context , config build ref , shift formula ref ) ; } configuration utility . set full name in hidden column ( row , full name ) ; }	Builds the cells for row.
private void build single cell ( final cell cell , final map < string , object > context , final config build ref config build ref , final shift formula ref shift formula ref ) { try { command utility . evaluate ( context , cell , config build ref . get engine ( ) ) ; if ( cell . get cell type enum ( ) == cell type . formula ) {	Builds the single cell.
private void read object ( final java . io . object input stream in ) throws io { try { in . default read object ( ) ; gson obj gson = new gson builder ( ) . set pretty printing ( ) . create ( ) ; type list type = new type token < map < string , object > > ( ) { } . get type ( ) ; this . data context = obj gson . from json ( map to json , list type ) ; } catch ( encrypted document exception | class not found exception e ) { log . log ( level . severe , str + e . get localized message ( ) , e ) ; } }	load the workbook from saving.
public final void build category list ( final ct ct ax ds ) { list < parsed cell > cells = new array list < > ( ) ; try { string full range name = ct ax ds . get str ref ( ) . get f ( ) ; string sheet name = web sheet utility . get sheet name from full cell ref name ( full range name ) ; cell range address region = cell range address . value of ( web sheet utility . remove sheet name from full cell ref name ( full range name ) ) ; for ( int row = region . get first row ( ) ; row <= region . get last row ( ) ; row ++ ) { for ( int col = region . get first column ( ) ; col <= region . get last column ( ) ; col ++ ) { cells . add ( new parsed cell ( sheet name , row , col ) ) ; } } } catch ( exception ex ) { log . log ( level . fine , str , ex ) ; } this . set category list ( cells ) ; }	build categotry list.
@ suppress warnings ( str ) public final void build series list ( final list bsers , final themes table theme table , final chart object ct obj ) { list < chart series > lseries list = new array list < > ( ) ; try { for ( int index = num ; index < bsers . size ( ) ; index ++ ) { object ct obj ser = bsers . get ( index ) ; chart series ct ser = build chart series in list ( theme table , ct obj , ct obj ser , index ) ; lseries list . add ( ct ser ) ; } } catch ( exception ex ) { log . log ( level . fine , str , ex ) ; } this . set series list ( lseries list ) ; }	build series list.
private chart series build chart series in list ( final themes table theme table , final chart object ct obj , final object ct obj ser , final int index ) { chart series ct ser = new chart series ( ) ; ct ser . set series label ( new parsed cell ( ct obj . get series label from ct ( ct obj ser ) ) ) ; ct ser . set series color ( color utility . ge color from sp pr ( index , ct obj . get shape properties from ct ( ct obj ser ) , theme table , ct obj . is line color ( ) ) ) ; list < parsed cell > cells = new array list < > ( ) ; string full range name = ( ct obj . get ct ct ( ct obj ser ) ) . get num ref ( ) . get f ( ) ; string sheet name = web sheet utility . get sheet name from full cell ref name ( full range name ) ; cell range address region = cell range address . value of ( web sheet utility . remove sheet name from full cell ref name ( full range name ) ) ; for ( int row = region . get first row ( ) ; row <= region . get last row ( ) ; row ++ ) { for ( int col = region . get first column ( ) ; col <= region . get last column ( ) ; col ++ ) { cells . add ( new parsed cell ( sheet name , row , col ) ) ; } } ct ser . set value list ( cells ) ; ct ser . set value color list ( get color list from dpt ( ct obj . get d ct ( ct obj ser ) , cells , theme table , ct obj ) ) ; return ct ser ; }	Builds the chart series in list.
private list < x > get color list from dpt ( final list < ctd > dpt list , final list < parsed cell > cells , final themes table theme table , final chart object ct obj ) { list < x > colors = new array list < > ( ) ; if ( ( dpt list != null ) && ( cells != null ) ) { for ( int index = num ; index < cells . size ( ) ; index ++ ) { ctd dpt = get d ( dpt list , index ) ; ct ct sp pr = null ; if ( dpt != null ) { ct sp pr = dpt . get sp pr ( ) ; } colors . add ( color utility . ge color from sp pr ( index , ct sp pr , theme table , ct obj . is line color ( ) ) ) ; } } return colors ; }	get color list from dpt.
private ctd get d ( final list < ctd > dpt list , final int index ) { if ( dpt list != null ) { for ( ctd dpt : dpt list ) { if ( dpt . get idx ( ) . get val ( ) == index ) { return dpt ; } } } return null ; }	get dpt from list.
public final void set command index map ( final map < string , command > pcommand index map ) { if ( pcommand index map instanceof hash map ) { this . command index map = ( hash map < string , command > ) pcommand index map ; } else { this . command index map = new hash map < > ( ) ; this . command index map . put all ( pcommand index map ) ; } }	Sets the command index map.
public static void get pictrues map ( final workbook wb , final map < string , picture > pic map ) { if ( wb instanceof xssf ) { get xssf ( ( xssf ) wb , pic map ) ; } return ; }	Gets the pictrues map.
private static void get xssf ( final xssf wb , final map < string , picture > pic map ) { pic map . clear ( ) ; list < xssf > pictures = wb . get all pictures ( ) ; if ( pictures . is empty ( ) ) { return ; } for ( int i = num ; i < wb . get number of sheets ( ) ; i ++ ) { xssf sheet = wb . get sheet at ( i ) ; for ( poixml dr : sheet . get relations ( ) ) { try { index picture in map ( pic map , sheet , dr ) ; } catch ( exception ex ) { log . log ( level . severe , str + ex . get localized message ( ) , ex ) ; } } } return ; }	Gets the XSSF pictrues map.
private static void index picture in map ( final map < string , picture > pic map , final xssf sheet , final poixml dr ) { if ( dr instanceof xssf ) { xssf drawing = ( xssf ) dr ; list < xssf > shapes = drawing . get shapes ( ) ; for ( xssf shape : shapes ) { if ( shape instanceof xssf ) { xssf pic = ( xssf ) shape ; xssf anchor = pic . get preferred size ( ) ; ct ct marker = anchor . get from ( ) ; string pic index = web sheet utility . get full cell ref name ( sheet . get sheet name ( ) , ct marker . get row ( ) , ct marker . get col ( ) ) ; pic map . put ( pic index , pic ) ; } } } }	save pciture in map with index.
public static string generate picture style ( final sheet sheet1 , final faces cell fcell , final cell cell , final picture pic ) { client anchor anchor = pic . get client anchor ( ) ; if ( anchor != null ) { anchor size anchor size = get anchor size ( sheet1 , fcell , cell , anchor ) ; if ( anchor size != null ) { return str + string . format ( str , anchor size . get percent left ( ) ) + str + string . format ( str , anchor size . get percent top ( ) ) + str + string . format ( str , anchor size . get percent width ( ) ) + str ; } } return str ; }	Generate picture style.
public static string generate chart style ( final sheet sheet1 , final faces cell fcell , final cell cell , final string chart id , final map < string , client anchor > anchors map ) { client anchor anchor = anchors map . get ( chart id ) ; if ( anchor != null ) { anchor size anchor size = get anchor size ( sheet1 , fcell , cell , anchor ) ; if ( anchor size != null ) { return str + string . format ( str , anchor size . get percent left ( ) ) + str + string . format ( str , anchor size . get percent top ( ) ) + str + string . format ( str , anchor size . get percent width ( ) ) + str ; } } return str ; }	Generate chart style.
public pattern get pattern ( ) { if ( ( this . pattern == null ) && ( alias != null ) ) { this . pattern = pattern . compile ( str + parser utility . wildcard to regex ( alias ) ) ; } return pattern ; }	Gets the pattern.
public streamed content get chart ( ) throws io { faces context context = faces context . get current instance ( ) ; if ( context . get current phase id ( ) == phase id . render response ) {	Return real chart picture when browser requesting the image.
public final void recover ( final sheet sheet ) { if ( this . cell addr != null ) { this . set cell ( sheet . get row ( this . cell addr . get row ( ) ) . get cell ( this . cell addr . get column ( ) ) ) ; } }	recover cell by using it's address.
public static string get row style ( final workbook wb , final cell poi cell , final string input type , final float row height , final int rowspan ) { cell style cell style = poi cell . get cell style ( ) ; if ( ( cell style != null ) && ( rowspan == num ) ) { short font idx = cell style . get font index ( ) ; font font = wb . get font at ( font idx ) ; float max height = row height ; if ( ! input type . is empty ( ) ) { max height = math . min ( font . get font height in points ( ) + num , row height ) ; } return str + web sheet utility . points to pixels ( max height ) + str ; } return str ; }	Gets the row style.
public static string get cell font style ( final workbook wb , final cell poi cell ) { cell style cell style = poi cell . get cell style ( ) ; string builder web style = new string builder ( ) ; if ( cell style != null ) { short font idx = cell style . get font index ( ) ; font font = wb . get font at ( font idx ) ; if ( font . get italic ( ) ) { web style . append ( str ) ; } if ( font . get bold ( ) ) { web style . append ( str ) ; } web style . append ( str + font . get font height in points ( ) + str ) ; string decoration = get cell font decoration ( font ) ; if ( decoration . length ( ) > num ) { web style . append ( str + decoration + str ) ; } web style . append ( get cell font color ( font ) ) ; } return web style . to string ( ) ; }	Gets the cell font style.
private static string get cell font color ( final font font ) { short [ ] rgbfix = { tie constants . rgb max , tie constants . rgb max , tie constants . rgb max } ; if ( font instanceof xssf ) { xssf color = ( ( xssf ) font ) . get xssf ( ) ; if ( color != null ) { rgbfix = color utility . get triplet from xssf ( color ) ; } } if ( rgbfix [ num ] != tie constants . rgb max ) { return str + faces utility . str join ( rgbfix , str ) + str ; } return str ; }	get cell font color.
private static string get cell font decoration ( final font font ) { string builder decoration = new string builder ( ) ; if ( font . get underline ( ) != num ) { decoration . append ( str ) ; } if ( font . get strikeout ( ) ) { decoration . append ( str ) ; } return decoration . to string ( ) ; }	Get font decoration.
public static string get cell style ( final workbook wb , final cell poi cell , final string input type ) { cell style cell style = poi cell . get cell style ( ) ; string builder web style = new string builder ( ) ; if ( cell style != null ) { if ( ! input type . is empty ( ) ) { web style . append ( get alignment from cell ( poi cell , cell style ) ) ; web style . append ( get vertical alignment from cell ( cell style ) ) ; } web style . append ( color utility . get bg color from cell ( wb , poi cell , cell style ) ) ; } return web style . to string ( ) ; }	Gets the cell style.
public static string get column style ( final workbook wb , final faces cell fcell , final cell poi cell , final float row height ) { string input type = fcell . get input type ( ) ; cell style cell style = poi cell . get cell style ( ) ; string builder web style = new string builder ( ) ; if ( cell style != null ) { if ( fcell . is contain pic ( ) || fcell . is contain chart ( ) ) { web style . append ( str ) ; } else { web style . append ( get alignment from cell ( poi cell , cell style ) ) ; web style . append ( get vertical alignment from cell ( cell style ) ) ; } web style . append ( color utility . get bg color from cell ( wb , poi cell , cell style ) ) ; web style . append ( get row style ( wb , poi cell , input type , row height , fcell . get rowspan ( ) ) ) ; } else { web style . append ( get alignment from cell type ( poi cell ) ) ; } return web style . to string ( ) ; }	Gets the column style.
private static string get alignment from cell ( final cell poi cell , final cell style cell style ) { string style = str ; switch ( cell style . get alignment enum ( ) ) { case left : style = tie constants . text align left ; break ; case right : style = tie constants . text align right ; break ; case center : style = tie constants . text align center ; break ; case general : style = get alignment from cell type ( poi cell ) ; break ; default : break ; } return style ; }	Gets the alignment from cell.
private static string get vertical alignment from cell ( final cell style cell style ) { string style = str ; switch ( cell style . get vertical alignment enum ( ) ) { case top : style = tie constants . vertical align top ; break ; case center : style = tie constants . vertical align center ; break ; case bottom : style = tie constants . vertical align bottom ; break ; default : break ; } return style ; }	Gets the vertical alignment from cell.
public static int calc total height ( final sheet sheet1 , final int first row , final int last row , final int additional height ) { int total height = additional height ; for ( int i = first row ; i <= last row ; i ++ ) { total height += sheet1 . get row ( i ) . get height ( ) ; } return total height ; }	Calc total height.
public static void setup cell style ( final workbook wb , final faces cell fcell , final cell poi cell , final float row height ) { cell style cell style = poi cell . get cell style ( ) ; if ( ( cell style != null ) && ( ! cell style . get locked ( ) ) ) {	Setup cell style.
@ suppress warnings ( str ) private static string get input type from cell type ( final cell cell ) { string input type = tie constants . cell input type text ; if ( cell . get cell type enum ( ) == cell type . numeric ) { input type = tie constants . cell input type double ; } cell style style = cell . get cell style ( ) ; if ( style != null ) { int format index = style . get data format ( ) ; string format string = style . get data format string ( ) ; if ( date util . is a ( format index , format string ) ) { input type = tie constants . cell input type date ; } else { if ( is a ( format string ) ) { input type = tie constants . cell input type percentage ; } } } return input type ; }	Gets the input type from cell type.
public static set < string > get resource paths ( final faces context context , final string path ) { return context . get external context ( ) . get resource paths ( path ) ; }	return faces context resource path.
public static input stream get resource as stream ( final faces context context , final string path ) { return context . get external context ( ) . get resource as stream ( path ) ; }	get resource file as stream.
public static string remove prefix path ( final string prefix , final string resource ) { string normalized resource = resource ; if ( normalized resource . starts with ( prefix ) ) { normalized resource = normalized resource . substring ( prefix . length ( ) - num ) ; } return normalized resource ; }	remove prefix path of the full path.
public static boolean eval input type ( final string input , final string type ) { scanner scanner = new scanner ( input ) ; boolean ireturn = bool ; if ( str . equals ignore case ( type ) ) { ireturn = scanner . has next int ( ) ; } else if ( str . equals ignore case ( type ) ) { ireturn = scanner . has next double ( ) ; } else if ( str . equals ignore case ( type ) ) { ireturn = scanner . has next boolean ( ) ; } else if ( str . equals ignore case ( type ) ) { ireturn = scanner . has next byte ( ) ; } else if ( type . to lower case ( ) . starts with ( str ) ) { ireturn = bool ; } scanner . close ( ) ; return ireturn ; }	evaluate input type.
@ suppress warnings ( str ) public static < t > t find bean ( final string bean name ) { faces context context = faces context . get current instance ( ) ; return ( t ) context . get application ( ) . evaluate expression get ( context , tie constants . el start + bean name + tie constants . el end , object . class ) ; }	Find bean in context.
public static string str join ( final short [ ] a arr , final string s sep ) { string builder sb str = new string builder ( ) ; for ( int i = num , il = a arr . length ; i < il ; i ++ ) { if ( i > num ) { sb str . append ( s sep ) ; } sb str . append ( a arr [ i ] ) ; } return sb str . to string ( ) ; }	join string.
public static double round ( final double value , final int places ) { if ( places < num ) { throw new illegal argument exception ( ) ; } big decimal bd = big decimal . value of ( value ) ; bd = bd . set scale ( places , rounding mode . half up ) ; return bd . double value ( ) ; }	round number according to decimal places.
public string get tab type ( ) { int sheet id = web form tab view . get active index ( ) ; if ( ( sheet id >= num ) && ( tabs != null ) ) { if ( sheet id >= tabs . size ( ) ) { sheet id = num ; } tab type = tabs . get ( sheet id ) . type . to lower case ( ) ; } else { tab type = tie constants . tab type none ; } return tab type ; }	get tab type.
public string get tab style ( ) { string tab style = tie constants . tab style visible ; int sheet id = web form tab view . get active index ( ) ; if ( ( sheet id >= num ) && ( sheet id < tabs . size ( ) ) ) { tab style = tie constants . tab style invisible ; } return tab style ; }	get tab style.
public string get default date pattern ( ) { if ( default date pattern == null ) { date format formatter = date format . get date instance ( date format . short , locale . get default ( ) ) ; default date pattern = ( ( simple date format ) formatter ) . to localized pattern ( ) ; } return default date pattern ; }	Gets the default date pattern.
public string get decimal separator by default locale ( ) { final decimal format nf = ( decimal format ) decimal format . get instance ( get default locale ( ) ) ; return str + nf . get decimal format symbols ( ) . get decimal separator ( ) ; }	Gets the decimal separator by default locale.
public string get thousand separator by default locale ( ) { final decimal format nf = ( decimal format ) decimal format . get instance ( get default locale ( ) ) ; return str + nf . get decimal format symbols ( ) . get grouping separator ( ) ; }	Gets the thousand separator by default locale.
public void set tie command alias list ( string alias list json ) { gson gson = new gson ( ) ; type alias list type = new type token < array list < tie command alias > > ( ) { } . get type ( ) ; this . tie command alias list = gson . from json ( alias list json , alias list type ) ; }	Sets the tie command alias list.
private list < integer > build form watch list ( final xssf wb wrapper , final sheet sheet ) { list < integer > watch list = new array list < > ( ) ; config range c range = this . get config range ( ) ; list < config command > command list = c range . get command list ( ) ; if ( command list . is empty ( ) ) {	Watch list serve for formula changes.
private void build watch list for cell ( final xssf wb wrapper , final int sheet index , final cell cell , final list < integer > watch list , final int last static row ) { string formula = cell . get cell formula ( ) ; ptg [ ] ptgs = formula parser . parse ( formula , wb wrapper , formula type . cell , sheet index ) ; for ( int k = num ; k < ptgs . length ; k ++ ) { object ptg = ptgs [ k ] ;	Builds the watch list for cell.
private void add to watch list ( final int add row , final int last static row , final list < integer > watch list ) { if ( ( add row > last static row ) && ! ( watch list . contains ( add row ) ) ) { watch list . add ( add row ) ; } }	Only rows in dynamic area will be added to watch list.
public static boolean is command string ( final string str ) { if ( str == null ) { return bool ; } return str . starts with ( tie constants . command prefix ) ; }	check it's a command comment.
public static void parse widget attributes ( final cell cell , final string new comment , final cell attributes map cell attributes map ) { if ( ( new comment == null ) || ( new comment . is empty ( ) ) ) { return ; } int widget start = new comment . index of ( tie constants . method widget prefix ) ; int el start = new comment . index of ( tie constants . el start bracket ) ; if ( ( widget start < num ) || ( widget start >= el start ) ) { return ; } string type = new comment . substring ( widget start + tie constants . method widget prefix . length ( ) , el start ) ; string values = get string between bracket ( new comment ) ; if ( values == null ) { return ; }	Parses the widget attributes.
public static string get attribute key in map by cell ( final cell cell ) { if ( cell == null ) { return null ; }	get attribute key in map by cell.
public static void parse validate attributes ( final cell cell , final string new comment , final cell attributes map cell attributes map ) { if ( ( new comment == null ) || ( new comment . is empty ( ) ) ) { return ; } if ( ! new comment . starts with ( tie constants . method validate prefix ) ) { return ; } string values = get string between bracket ( new comment ) ; if ( values == null ) { return ; }	Parses the validate attributes.
private static int find pair bracket position ( final string str , final int start pos ) { int bracket num = num ; for ( int i = start pos ; i < str . length ( ) ; i ++ ) { char current = str . char at ( i ) ; if ( current == tie constants . el start bracket ) { bracket num ++ ; } else if ( current == tie constants . el end ) { bracket num -- ; if ( bracket num <= num ) { return i ; } } } return - num ; }	Find pair bracket position.
public static map < string , string > parse command attributes ( final string attr string ) { map < string , string > attr map = new linked hash map < > ( ) ; matcher attr matcher = tie constants . attr regex pattern . matcher ( attr string ) ; while ( attr matcher . find ( ) ) { string attr data = attr matcher . group ( ) ; int attr name end index = attr data . index of ( str ) ; string attr name = attr data . substring ( num , attr name end index ) . trim ( ) ; string attr value part = attr data . substring ( attr name end index + num ) . trim ( ) ; string attr value = attr value part . substring ( num , attr value part . length ( ) - num ) ; attr map . put ( attr name , attr value ) ; } return attr map ; }	Parse the attributes from string.
public static void parse input attributes ( final list < cell form attributes > clist , final string control attrs ) {	parse input attributes.
public static void parse validate attributes ( final list < cell form attributes > clist , final string control attrs ) {	parse validate attributes.
private static string [ ] split by eual sign ( final string attr data ) { int attr name end index = attr data . index of ( str ) ; if ( attr name end index < num ) { return new string [ num ] ; } string attr name = attr data . substring ( num , attr name end index ) . trim ( ) ; string attr value = attr data . substring ( attr name end index + num ) . trim ( ) ; string [ ] rlist = new string [ num ] ; rlist [ num ] = attr name ; rlist [ num ] = attr value ; return rlist ; }	split string by = sign.
public static void parse special attributes ( final string key , final string type , final list < cell form attributes > inputs , final cell attributes map cell attributes map ) { special attributes s attr = new special attributes ( ) ; for ( cell form attributes attr : inputs ) { gather special attributes ( type , s attr , attr ) ; } if ( s attr . select labels != null ) { process select item attributes ( key , cell attributes map , s attr ) ; } if ( type . equals ignore case ( tie constants . widget calendar ) ) { process calendar attributes ( key , cell attributes map , s attr ) ; } }	parse select item attributes.
private static void process calendar attributes ( final string key , final cell attributes map cell attributes map , final special attributes s attr ) { cell attributes map . get cell date pattern ( ) . put ( key , s attr . default date pattern ) ; }	Process calendar attributes.
private static void process select item attributes ( final string key , final cell attributes map cell attributes map , final special attributes s attr ) { if ( ( s attr . select values == null ) || ( s attr . select values . length != s attr . select labels . length ) ) { s attr . select values = s attr . select labels ; } map < string , string > smap = cell attributes map . get cell select items attributes ( ) . get ( key ) ; if ( smap == null ) { smap = new linked hash map < > ( ) ; } smap . clear ( ) ; if ( s attr . default select label != null ) { smap . put ( s attr . default select label , s attr . default select value ) ; } for ( int i = num ; i < s attr . select labels . length ; i ++ ) { smap . put ( s attr . select labels [ i ] , s attr . select values [ i ] ) ; } cell attributes map . get cell select items attributes ( ) . put ( key , smap ) ; }	Process select item attributes.
private static void gather special attributes ( final string type , final special attributes s attr , final cell form attributes attr ) { string attr key = attr . get type ( ) ; if ( attr key . equals ignore case ( tie constants . select item labels ) ) { s attr . select labels = attr . get value ( ) . split ( str ) ; } if ( attr key . equals ignore case ( tie constants . select item values ) ) { s attr . select values = attr . get value ( ) . split ( str ) ; } if ( attr key . equals ignore case ( tie constants . default select item label ) ) { s attr . default select label = attr . get value ( ) ; } if ( attr key . equals ignore case ( tie constants . default select item value ) ) { s attr . default select value = attr . get value ( ) ; } if ( type . equals ignore case ( tie constants . widget calendar ) && attr key . equals ignore case ( tie constants . widget attr pattern ) ) { s attr . default date pattern = attr . get value ( ) ; } }	Gather special attributes.
public static void parse comment to map ( final string cell key , final string new comment , final map < string , map < string , string > > sheet comment map , final boolean normal comment ) { if ( ( new comment != null ) && ( ! new comment . trim ( ) . is empty ( ) ) ) {	Parse Comment To MapNormal comment : key $$ Not Normal comment: key e.g.
public static int find first non cell name position ( string input , int start position ) { char c ; for ( int i = start position ; i < input . length ( ) ; i ++ ) { c = input . char at ( i ) ; if ( c != str && ! character . is letter or digit ( c ) ) { return i ; } } return - num ;	find first non letterordigit position from string.
public static string remove chars from string ( string input str , int start , int end ) { string builder sb = new string builder ( input str ) ; sb . delete ( start , end ) ;	Removes the chars from string.
public static string get excel column name ( final int pnumber ) { string builder converted = new string builder ( ) ;	Gets the excel column name.
public static int convert col to int ( final string col ) { string name = col . to upper case ( ) ; int number = num ; int pow = num ; for ( int i = name . length ( ) - num ; i >= num ; i -- ) { number += ( name . char at ( i ) - str + num ) * pow ; pow *= tie constants . excel letter numbers ; } return number - num ; }	Convert col to int.
public static cell get cell by reference ( final string cell ref , final sheet sheet ) { cell c = null ; try { cell reference ref = new cell reference ( cell ref ) ; row r = sheet . get row ( ref . get row ( ) ) ; if ( r != null ) { c = r . get cell ( ref . get col ( ) , missing cell policy . create null as blank ) ; } } catch ( exception ex ) {	Gets the cell by reference.
public static int height units2 pixel ( final short height units ) { int pixels = height units / excel row height factor ; int offset height units = height units % excel row height factor ; pixels += math . round ( ( float ) offset height units / ( ( float ) excel column width factor / unit offset length / num ) ) ; pixels += ( math . floor ( pixels / pixel height aspc adjust ) + num ) * num ; return pixels ; }	Height units 2 pixel.
public static boolean is date ( final string s ) { pattern pattern = pattern . compile ( date regex 4 digit year ) ; string [ ] terms = s . split ( str ) ; matcher matcher ; for ( string term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return bool ; } } pattern = pattern . compile ( date regex 2 digit year ) ; terms = s . split ( str ) ; for ( string term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return bool ; } } return bool ; }	Checks if is date.
public static string parse date ( final string entry ) { pattern pattern = pattern . compile ( date regex 4 digit year ) ; string [ ] terms = entry . split ( str ) ; matcher matcher ; for ( string term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return matcher . group ( ) ; } } pattern = pattern . compile ( date regex 2 digit year ) ; terms = entry . split ( str ) ; for ( string term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return matcher . group ( ) ; } } return str ; }	Parses the date.
public static boolean is numeric ( final string str ) { string s = str ; if ( s . starts with ( str ) ) { s = s . substring ( num ) ; } char c ; int i ; int s len = s . length ( ) ; should continue parameter s para = new should continue parameter ( bool , bool , num ) ; for ( i = num ; i < s len ; i ++ ) { c = s . char at ( i ) ; if ( c < str || c > str ) { if ( ! should continue ( c , s para ) ) { return bool ; } } else { if ( s para . is comma hit ( ) ) { s para . set since last comma ( s para . get since last comma ( ) + num ) ; } } } return bool ; }	Checks if is numeric.
private static boolean should continue ( final char c , final should continue parameter para ) { if ( c == str && ! para . is decimal hit ( ) ) { para . set decimal hit ( bool ) ; if ( para . is comma hit ( ) && para . get since last comma ( ) != num ) { return bool ; } return bool ; } else if ( c == str && ! para . is decimal hit ( ) ) { if ( para . is comma hit ( ) ) { if ( para . get since last comma ( ) != num ) { return bool ; } para . set since last comma ( num ) ; } para . set comma hit ( bool ) ; return bool ; } return bool ; }	Should continue.
public static void set object property ( final object obj , final string property name , final string property value , final boolean ignore non existing ) { try { method method = obj . get class ( ) . get method ( str + character . to upper case ( property name . char at ( num ) ) + property name . substring ( num ) , new class [ ] { string . class } ) ; method . invoke ( obj , property value ) ; } catch ( exception e ) { string msg = str + property name + str + property value + str + obj ; if ( ignore non existing ) { log . info ( msg ) ; } else { log . warning ( msg ) ; throw new illegal argument exception ( e ) ; } } }	Sets the object property.
public static int cell compare to ( final cell this cell , final cell other cell ) { int r = this cell . get row index ( ) - other cell . get row index ( ) ; if ( r != num ) { return r ; } r = this cell . get column index ( ) - other cell . get column index ( ) ; if ( r != num ) { return r ; } return num ; }	Cell compare to.
public static boolean inside range ( final config range child , final config range parent ) { return ( ( cell compare to ( child . get first row ref ( ) , parent . get first row ref ( ) ) >= num ) && ( cell compare to ( child . get last row plus ref ( ) , parent . get last row plus ref ( ) ) <= num ) ) ; }	Inside range.
public static void clear hidden columns ( final sheet sheet ) { for ( row row : sheet ) { if ( row . get last cell num ( ) > tie constants . max columns in sheet ) { delete hidden columns in row ( row ) ; } } }	Clear hidden columns.
private static void delete hidden columns in row ( final row row ) { delete cell from row ( row , tie constants . hidden save objects column ) ; delete cell from row ( row , tie constants . hidden origin row number column ) ; delete cell from row ( row , tie constants . hidden full name column ) ; }	Delete hidden columns in row.
private static void delete cell from row ( final row row , final int cell num ) { cell cell = row . get cell ( cell num ) ; if ( cell != null ) { row . remove cell ( cell ) ; } }	Delete cell from row.
@ override public final void process event ( final system event event ) { logger . log ( level . info , str , app utils . get build version ( ) ) ; }	process event.
private void refresh after status changed ( final boolean old status , final boolean new status , final int form row , final int form col , final faces cell cell , final boolean update gui ) { if ( ! new status ) { cell . set errormsg ( str ) ; } cell . set invalid ( new status ) ; if ( update gui && ( old status != new status ) && ( parent . get web form client id ( ) != null ) ) { request context . get current instance ( ) . update ( parent . get web form client id ( ) + str + ( form row ) + str + ( form col ) ) ; } }	Refresh after status changed.
public boolean validate with row col in current page ( final int row , final int col , boolean update gui ) {	Validate with row col in current page.
private boolean validate by tie web sheet validation bean ( final cell poi cell , final int top row , final int left col , final faces cell cell , final string value , boolean update gui ) { if ( parent . get tie web sheet validation bean ( ) != null ) { string errormsg = null ; string full name = configuration utility . get full name from row ( poi cell . get row ( ) ) ; string save attr = save attrs utility . prepare context and attrs for cell ( poi cell , full name , parent . get cell helper ( ) ) ; if ( save attr != null ) { int row = poi cell . get row index ( ) ; int col = poi cell . get column index ( ) ; errormsg = parent . get tie web sheet validation bean ( ) . validate ( parent . get serial data context ( ) . get data context ( ) , save attr , configuration utility . get full name from row ( poi cell . get row ( ) ) , poi cell . get sheet ( ) . get sheet name ( ) , row , col , value ) ; if ( ( errormsg != null ) && ( ! errormsg . is empty ( ) ) ) { cell . set errormsg ( errormsg ) ; refresh after status changed ( bool , bool , row - top row , col - left col , cell , update gui ) ; return bool ; } } } return bool ; }	Validate by tie web sheet validation bean.
private boolean check error message from object in context ( final int form row , final int form col , final faces cell cell , final cell poi cell , final string value , final sheet configuration sheet config , boolean update gui ) { @ suppress warnings ( str ) hash map < string , tie cell > tie cells = ( hash map < string , tie cell > ) parent . get serial data context ( ) . get data context ( ) . get ( str ) ; if ( tie cells != null ) { tie cell tie cell = tie cells . get ( cell utility . get skey from poi cell ( poi cell ) ) ; if ( tie cell != null && tie cell . get context object ( ) != null ) { string error method = tie cell . get method str ( ) + parent . get config advanced context ( ) . get error suffix ( ) ; string error message = cell controls utility . get object property value ( tie cell . get context object ( ) , error method , bool ) ; if ( error message != null && ! error message . is empty ( ) ) { cell . set errormsg ( error message ) ; log . log ( level . info , str , new object [ ] { poi cell . get sheet ( ) . get sheet name ( ) , poi cell . get row index ( ) , poi cell . get column index ( ) , error message } ) ; refresh after status changed ( bool , bool , form row , form col , cell , update gui ) ; return bool ; } } } return bool ; }	Check error message from object in context.
private boolean validate all rules for single cell ( final int form row , final int form col , final faces cell cell , final cell poi cell , final string value , final sheet configuration sheet config , final list < cell form attributes > cell attributes , boolean update gui ) { sheet sheet1 = parent . get wb ( ) . get sheet ( sheet config . get sheet name ( ) ) ; for ( cell form attributes attr : cell attributes ) { boolean pass = do validation ( value , attr , poi cell . get row index ( ) , poi cell . get column index ( ) , sheet1 ) ; if ( ! pass ) { string errmsg = attr . get message ( ) ; if ( errmsg == null ) { errmsg = tie constants . defalt msg invalid input ; } cell . set errormsg ( errmsg ) ; log . log ( level . info , str , new object [ ] { poi cell . get sheet ( ) . get sheet name ( ) , poi cell . get row index ( ) , poi cell . get column index ( ) , errmsg } ) ; refresh after status changed ( bool , bool , form row , form col , cell , update gui ) ; return bool ; } } return bool ; }	Validate all rules for single cell.
private boolean do validation ( final object value , final cell form attributes attr , final int row index , final int col index , final sheet sheet ) { boolean pass ; string attr value = attr . get value ( ) ; attr value = attr value . replace ( str , value . to string ( ) + str ) . replace ( str , row index + str ) . replace ( str , col index + str ) . replace ( str , sheet . get sheet name ( ) ) ; attr value = configuration utility . replace expression with cell value ( attr value , row index , sheet ) ; if ( attr value . contains ( tie constants . el start ) ) { object return obj = faces utility . evaluate expression ( attr value , object . class ) ; attr value = return obj . to string ( ) ; pass = boolean . parse boolean ( attr value ) ; } else { pass = parent . get cell helper ( ) . eval bool expression ( attr value ) ; } return pass ; }	Do validation.
public final boolean validate cell ( final ui target ) { int [ ] rowcol = cell utility . get row col from component attributes ( target ) ; int row = rowcol [ num ] ; int col = rowcol [ num ] ; return validate with row col in current page ( row , col , bool ) ; }	Validate cell.
public final boolean validate current page ( ) { boolean allpass = bool ; int top = parent . get current ( ) . get current top row ( ) ; for ( int irow = num ; irow < parent . get body rows ( ) . size ( ) ; irow ++ ) { if ( ! validate row in current page ( irow + top , bool ) ) { allpass = bool ; } } return allpass ; }	Validate current page.
public final boolean validate row in current page ( final int irow , final boolean update gui ) { sheet configuration sheet config = parent . get sheet config map ( ) . get ( parent . get current ( ) . get current tab name ( ) ) ; return this . validate row ( irow , sheet config , update gui ) ; }	Validate row in current page.
private boolean validate row ( final int irow , final sheet configuration sheet config , boolean update gui ) { boolean pass = bool ; if ( sheet config == null ) { return pass ; } int top = sheet config . get body cell range ( ) . get top row ( ) ; list < faces cell > cell row = parent . get body rows ( ) . get ( irow - top ) . get cells ( ) ; for ( int index = num ; index < cell row . size ( ) ; index ++ ) { faces cell fcell = cell row . get ( index ) ; if ( ( fcell != null ) && ( ! validate with row col in current page ( irow , fcell . get column index ( ) , update gui ) ) ) { pass = bool ; } } return pass ; }	Validate row.
private void refresh cached cells in current page ( final faces context faces context , final string tbl name ) {	Refresh cached cells in current page.
private void refresh cached cells in row ( final string tbl name , final int top , final int left , final int i ) { faces row data row = parent . get body rows ( ) . get ( i ) ; int isize = data row . get cells ( ) . size ( ) ; for ( int index = num ; index < isize ; index ++ ) { faces cell fcell = data row . get cells ( ) . get ( index ) ; cell poi cell = parent . get cell helper ( ) . get poi cell with row col from current page ( i + top , index + left ) ; if ( poi cell != null ) { parent . get helper ( ) . get web sheet loader ( ) . refresh cached cell ( tbl name , i , index , poi cell , fcell ) ; } } }	Refresh cached cells in row.
public void set submit mode in view ( final boolean fullflag ) { if ( faces context . get current instance ( ) != null ) { map < string , object > view map = faces context . get current instance ( ) . get view root ( ) . get view map ( ) ; if ( view map != null ) { boolean flag = ( boolean ) view map . get ( tie constants . submitmode ) ; if ( ( flag == null ) || ( ! flag . equals ( fullflag ) ) ) { view map . put ( tie constants . submitmode , fullflag ) ; } } } }	set submit mode flag with javascript for holding in client side.
public boolean pre validation ( ) { string current tab name = parent . get current ( ) . get current tab name ( ) ; string tab name = null ; string first invalid tab name = null ; boolean reload = bool ; for ( map . entry < string , sheet configuration > entry : parent . get sheet config map ( ) . entry set ( ) ) { tab name = entry . get key ( ) ;	triggered validation process before actions like save or submit.
public final void clear ( ) { if ( this . template comment map != null ) { this . template comment map . clear ( ) ; } if ( this . cell date pattern != null ) { this . cell date pattern . clear ( ) ; } if ( this . cell input attributes != null ) { this . cell input attributes . clear ( ) ; } if ( this . cell input type != null ) { this . cell input type . clear ( ) ; } if ( this . cell select items attributes != null ) { this . cell select items attributes . clear ( ) ; } }	clear all the related maps.
private void load header rows ( final sheet configuration sheet config , final map < string , cell range address > cell range map , final list < string > skipped region cells ) { int top = sheet config . get header cell range ( ) . get top row ( ) ; int bottom = sheet config . get header cell range ( ) . get bottom row ( ) ; int left = sheet config . get header cell range ( ) . get left col ( ) ; int right = sheet config . get header cell range ( ) . get right col ( ) ; string sheet name = sheet config . get sheet name ( ) ; sheet sheet1 = parent . get wb ( ) . get sheet ( sheet name ) ; int total width = cell style utility . calc total width ( sheet1 , left , right , web sheet utility . pixel2 width units ( parent . get line number column width ( ) + parent . get add row column width ( ) ) ) ; range build ref range build ref = new range build ref ( left , right , total width , sheet1 ) ; if ( sheet config . is fixed width style ( ) ) { parent . set table width style ( str + web sheet utility . width units2 pixel ( total width ) + str ) ; } parent . set line number column width style ( get width style ( web sheet utility . pixel2 width units ( parent . get line number column width ( ) ) , total width ) ) ; parent . set add row column width style ( str + parent . get add row column width ( ) + str ) ; parent . get header rows ( ) . clear ( ) ; if ( top < num ) {	Load header rows.
private list < header cell > load header row without configuration tab ( final range build ref range build ref , final boolean rendered ) { int first col = range build ref . get left ( ) ; int last col = range build ref . get right ( ) ; double total width = ( double ) range build ref . get total width ( ) ; sheet sheet1 = range build ref . get sheet ( ) ; list < header cell > headercells = new array list < > ( ) ; for ( int i = first col ; i <= last col ; i ++ ) { if ( ! sheet1 . is column hidden ( i ) ) { string style = get header column style ( parent . get wb ( ) , null , sheet1 . get column width ( i ) , total width ) ; headercells . add ( new header cell ( str , str , style , style , web sheet utility . get excel column name ( i ) , rendered , bool ) ) ; } } fill to max columns ( headercells ) ; return headercells ; }	Load header row without configuration tab.
private void fill to max columns ( final list < header cell > headercells ) { if ( headercells . size ( ) < parent . get max col counts ( ) ) { int fills = parent . get max col counts ( ) - headercells . size ( ) ; for ( int s = num ; s < fills ; s ++ ) { headercells . add ( new header cell ( str , str , str , str , str , bool , bool ) ) ; } } }	Fill to max columns.
private string get header column style ( final workbook wb , final cell cell , final double col width , final double total width ) { string columnstyle = str ; if ( cell != null ) { columnstyle += cell style utility . get cell style ( wb , cell , str ) + cell style utility . get cell font style ( wb , cell ) ;	Gets the header column style.
private string get width style ( final double col width , final double total width ) { double percentage = faces utility . round ( tie constants . cell format percentage value * col width / total width , num ) ; return str + percentage + tie constants . cell format percentage symbol + str ; }	Gets the width style.
private string get column width style ( final sheet sheet1 , final map < string , cell range address > cell range map , final string cellindex , final int cindex , final double total width ) { cell range address caddress = cell range map . get ( cellindex ) ; double col width ;	Gets the column width style.
private void init tabs ( ) { parent . set tabs ( new array list < tab model > ( ) ) ; if ( parent . get sheet config map ( ) != null ) { for ( string key : parent . get sheet config map ( ) . key set ( ) ) { parent . get tabs ( ) . add ( new tab model ( str + key , key , str ) ) ; } } }	Inits the tabs.
private void load data ( ) { if ( parent . get serial data context ( ) . get data context ( ) == null ) {	load data process. unfinished.
private void refresh data for row ( row row ) { if ( row == null ) { return ; } string save attr list = save attrs utility . get save attr list from row ( row ) ; if ( save attr list != null ) { string [ ] save attrs = save attr list . split ( str ) ; for ( string full save attr : save attrs ) { refresh data for cell ( row , full save attr ) ; } } }	Refresh data for row.
private void refresh data for cell ( row row , string full save attr ) { if ( full save attr != null ) { try { string full name = configuration utility . get full name from row ( row ) ; if ( full name != null ) { parent . get cell helper ( ) . restore data context ( full name ) ; save attrs utility . refresh sheet row from context ( parent . get serial data context ( ) . get data context ( ) , full save attr , row , parent . get exp engine ( ) ) ; } } catch ( exception ex ) { log . log ( level . severe , str + full save attr + str + ex . get message ( ) , ex ) ; } } }	refresh data for single cell.
public final int find tab index with name ( final string tabname ) { for ( int i = num ; i < parent . get tabs ( ) . size ( ) ; i ++ ) { if ( parent . get tabs ( ) . get ( i ) . get title ( ) . equals ignore case ( tabname ) ) { return i ; } } return - num ; }	Find tab index with name.
public final void load work sheet ( final string tab name ) { prepare work shee ( tab name ) ; parent . get validation handler ( ) . validate current page ( ) ; create dynamic columns ( tab name ) ;	Load work sheet.
public final void prepare work shee ( final string tab name ) { int tab index = find tab index with name ( tab name ) ; if ( parent . get web form tab view ( ) != null ) { parent . get web form tab view ( ) . set active index ( tab index ) ; } parent . get current ( ) . set current tab name ( tab name ) ; string sheet name = parent . get sheet config map ( ) . get ( tab name ) . get sheet name ( ) ; sheet sheet1 = parent . get wb ( ) . get sheet ( sheet name ) ; parent . get wb ( ) . set active sheet ( parent . get wb ( ) . get sheet index ( sheet1 ) ) ; sheet configuration sheet config = parent . get sheet config map ( ) . get ( tab name ) ; parent . set max rows per page ( parent . get sheet config map ( ) . get ( tab name ) . get max row per page ( ) ) ; parent . set body allow add rows ( parent . get sheet config map ( ) . get ( tab name ) . is body allow add rows ( ) ) ;	prepare worksheet for loading.this only load at backend without refresh gui.
private void set data table page ( final int first ) { if ( parent . get web form client id ( ) != null ) { final data table d = ( data table ) faces context . get current instance ( ) . get view root ( ) . find component ( parent . get web form client id ( ) ) ; if ( d != null ) { d . set first ( first ) ; } } }	Sets the data table page.
private void setup row info ( final faces row faces row , final sheet sheet1 , final row row , final int row index , final boolean allow add ) { faces row . set allow add ( allow add ) ; if ( row != null ) { faces row . set rendered ( ! row . get zero height ( ) ) ; faces row . set rowheight ( row . get height ( ) ) ; int row num = configuration utility . get original row num in hidden column ( row ) ; faces row . set origin row index ( row num ) ; } else { faces row . set rendered ( bool ) ; faces row . set rowheight ( sheet1 . get default row height ( ) ) ; faces row . set origin row index ( row index ) ; } }	Setup row info.
private void load body rows ( final sheet configuration sheet config , final map < string , cell range address > cell range map , final list < string > skipped region cells ) { int top = sheet config . get body cell range ( ) . get top row ( ) ; int bottom = cell utility . get body bottom from config ( sheet config ) ; int left = sheet config . get body cell range ( ) . get left col ( ) ; int right = sheet config . get body cell range ( ) . get right col ( ) ; string sheet name = sheet config . get sheet name ( ) ; sheet sheet1 = parent . get wb ( ) . get sheet ( sheet name ) ; parent . get body rows ( ) . clear ( ) ; clear cache ( ) ; for ( int i = top ; i <= bottom ; i ++ ) { parent . get body rows ( ) . add ( assemble faces body row ( i , sheet1 , left , right , sheet config , cell range map , skipped region cells ) ) ; } sheet config . set body populated ( bool ) ; parent . get current ( ) . set current top row ( top ) ; parent . get current ( ) . set current left column ( left ) ; }	Load body rows.
public final void refresh cached cell ( final string tbl name , final int i , final int index , final cell cell , final faces cell fcell ) { if ( ( cell != null ) && ( cell . get cell type enum ( ) == cell type . formula ) && ( tbl name != null ) ) { try { process refresh cell ( tbl name , i , index , cell , fcell ) ; } catch ( exception ex ) { log . log ( level . severe , str + ex . get localized message ( ) , ex ) ; } } }	Refresh cached cell.
private void process refresh cell ( final string tbl name , final int i , final int index , final cell cell , final faces cell fcell ) { string new value = cell utility . get cell value with format ( cell , parent . get formula evaluator ( ) , parent . get data formatter ( ) ) ; if ( parent . get cached cells ( ) . is value changed ( cell , new value ) ) { if ( fcell . is has save attr ( ) ) { parent . get cell helper ( ) . save data in context ( cell , new value ) ; } request context . get current instance ( ) . update ( tbl name + str + i + str + index ) ; parent . get cached cells ( ) . put ( cell , cell type . formula ) ; } }	Process refresh cell.
private void create dynamic columns ( final string tab name ) { sheet configuration sheet config = parent . get sheet config map ( ) . get ( tab name ) ; int left = sheet config . get body cell range ( ) . get left col ( ) ; int right = sheet config . get body cell range ( ) . get right col ( ) ; parent . get columns ( ) . clear ( ) ; for ( int i = left ; i <= right ; i ++ ) { parent . get columns ( ) . add ( str + ( i - left ) ) ; } }	Creates the dynamic columns.
public final void add repeat row ( final int row index ) { try { sheet configuration sheet config = parent . get sheet config map ( ) . get ( parent . get current ( ) . get current tab name ( ) ) ; sheet sheet = parent . get wb ( ) . get sheet ( sheet config . get sheet name ( ) ) ; config build ref config build ref = new config build ref ( parent . get wb wrapper ( ) , sheet , parent . get exp engine ( ) , parent . get cell helper ( ) , sheet config . get cached cells ( ) , parent . get cell attributes map ( ) , sheet config . get final comment map ( ) ) ;	Adds the repeat row.
private void refresh body rows in range ( final int insert position , final int length , final sheet sheet , final sheet configuration sheet config ) { map < string , cell range address > cell range map = configuration utility . index merged region ( sheet ) ; list < string > skipped region cells = configuration utility . skipped region cells ( sheet ) ; int top = sheet config . get body cell range ( ) . get top row ( ) ; int left = sheet config . get body cell range ( ) . get left col ( ) ; int right = sheet config . get body cell range ( ) . get right col ( ) ; for ( int irow = insert position ; irow < ( insert position + length ) ; irow ++ ) { parent . get body rows ( ) . add ( irow - top , assemble faces body row ( irow , sheet , left , right , sheet config , cell range map , skipped region cells ) ) ; } for ( int irow = insert position + length - top ; irow < parent . get body rows ( ) . size ( ) ; irow ++ ) { faces row facesrow = parent . get body rows ( ) . get ( irow ) ; facesrow . set row index ( facesrow . get row index ( ) + length ) ; } }	Refresh body rows in range.
public void set unsaved status ( final request context request context , final boolean status flag ) {	Sets the unsaved status.
public final boolean is unsaved status ( ) { map < string , object > view map = faces context . get current instance ( ) . get view root ( ) . get view map ( ) ; boolean flag = ( boolean ) view map . get ( tie constants . unsavedstate ) ; if ( flag == null ) { return bool ; } return flag ; }	Checks if is unsaved status.
public static < t > constructor < t > common constructor ( class < t > type ) throws no method for dependency { constructor < ? > [ ] cs = type . get declared constructors ( ) ; if ( cs . length == num ) throw new no method for dependency ( raw ( type ) ) ; constructor < ? > most params constructor = null ; for ( constructor < ? > c : cs ) { if ( ! array contains ( c . get parameter types ( ) , type , ( a , b ) -> a == b )	Returns the constructor with most visible visibility and longest argumentlist.
protected static void write input stream to output ( final context context , final input stream source , final output stream output ) throws io { buffers pool pool = beans manager . get ( context ) . get container ( ) . get bean ( buffers pool . class ) ; io utils . transfer ( source , output , pool ) ; }	Utility method for transferring input stream to output.
protected static void write long ( final writer writer , final long value ) throws io { writer . write ( new string builder ( ) . append ( value ) . append ( str ) . to string ( ) ) ; }	Write next line as a long.
protected final void write string ( final writer writer , final string line ) throws io { if ( line != null ) { writer . write ( line + str ) ; } else { writer . write ( str ) ; } }	Write next line to the output.
protected void set converted traffic stats tag ( final string tag ) { result . stats tag = utils . get traffic stats tag ( tag ) ; if ( config . is debug rest ( ) ) { log . d ( tag , str + tag + str + integer . to hex string ( result . stats tag ) ) ; } }	Set network stats tag.
protected void add bitmap ( final string name , final bitmap bitmap , final string file name ) { final bitmap binary data bdata = new bitmap binary data ( ) ; bdata . set name ( name ) ; bdata . set content name ( file name ) ; bdata . set bitmap ( bitmap ) ; result . add binary data ( bdata ) ; }	Setup binary content with the bitmap.
protected void add file descriptor ( final string name , final asset file descriptor fd , final string content type , final string file name ) { final asset fd binary data bdata = new asset fd binary data ( ) ; bdata . set file descriptor ( file name , fd ) ; bdata . set name ( name ) ; bdata . set content type ( content type ) ; result . add binary data ( bdata ) ; }	Setup binary content with the file descriptor.
protected parameter remove parameter ( final string name ) { if ( name == null ) { throw new illegal argument exception ( str ) ; } final iterator < parameter > iter = result . simple parameters . get children ( ) . iterator ( ) ; while ( iter . has next ( ) ) { final parameter p = iter . next ( ) ; if ( name . equals ( p . name ) ) { iter . remove ( ) ; return p ; } } return null ; }	Remove parameter with the specified name from request description.
protected base request builder < mt > add header ( final string name , final string value ) { result . add header ( name , value ) ; return this ; }	Add header to request description.
public void clear ( ) { final request description result = this . result ; result . simple parameters . children . clear ( ) ; result . clear binary data ( ) ; result . content type = null ; result . clear headers ( ) ; }	Clear the builder.
protected void call play ( final uri uri , final int volume , final bundle params ) { playing = bool ; paused = bool ; context . start service ( create play intent ( ) . set data ( uri ) . put extra ( streaming playback service . extra volume , volume ) . put extra ( streaming playback service . extra track info , params ) ) ; bind ( ) ; on playing changed ( ) ; preparing = bool ; on preparing changed ( ) ; }	Play the track.
protected final void bind ( ) { if ( bind requested ) { return ; } final boolean result = context . bind service ( create bind intent ( ) , service connection , num ) ; if ( debug ) { log . v ( tag , str + result ) ; } bind requested = result ; on bind ( result ) ; }	Bind to the streaming service.
protected final void unbind ( ) { if ( streaming playback != null ) { drop listener ( ) ; } try { context . unbind service ( service connection ) ; } catch ( final runtime exception e ) { if ( debug ) { log . w ( tag , str , e ) ; } } bind requested = bool ; }	Unbind from the streaming service.
protected final void drop listener ( ) { if ( debug ) { log . v ( tag , str ) ; } if ( streaming playback != null ) { try { streaming playback . remove listener ( ) ; } catch ( final remote exception e ) { log . e ( tag , str , e ) ; } bind requested = bool ; } }	Drop streaming service listener.
public void store to disk ( ) throws io { if ( manager . is present on disk ( url ) ) { return ; } if ( ! has allowed size ( ) ) { io utils . consume stream ( get remote input stream ( ) , manager . get buffers pool ( ) ) ; return ; } image result result = decode stream ( get remote input stream ( ) , bool ) ; if ( result . get type ( ) == image source type . network && result . get bitmap ( ) != null ) {	Store image to the disk cache.If max allowed size is set image may be rescaled on disk.
public static string stream to string ( final input stream stream , final string charset , final buffers pool buffers pool ) throws io { byte array output stream output = new byte array output stream ( ) ; transfer ( stream , output , buffers pool ) ; return new string ( output . to byte array ( ) , charset ) ; }	Read all the bytes from input stream and convert them to a string.Input stream is closed after this method invocation.
public static string stream to string ( final input stream stream , final buffers pool buffers pool ) throws io { return stream to string ( stream , utf 8 name , buffers pool ) ; }	Read all the bytes from input stream and convert them to a string using UTF-8 charset.Input stream is closed after this method invocation.
@ override protected void send data ( final output stream out ) throws io { if ( debug ) { log . v ( tag , str ) ; } out . write ( get content ( ) ) ; }	Writes the data to the given OutputStream.
@ override public synchronized int available ( ) throws io { final input stream local in = in ;	Returns the number of bytes that are available before this stream willblock.
@ override public void close ( ) throws io { final byte [ ] local buf = buf ; buf = null ; final input stream local in = in ; in = null ; pool . release ( local buf ) ; if ( local in != null ) { local in . close ( ) ; } }	Closes this stream. The source stream is closed and any resourcesassociated with it are released.
@ override public synchronized int read ( ) throws io {	Reads a single byte from this stream and returns it as an integer in therange from 0 to 255.
@ override public synchronized void reset ( ) throws io {	Resets this stream to the last marked location.
protected void send start ( final output stream out ) throws io { if ( debug ) { log . v ( tag , str ) ; } out . write ( extra bytes ) ; out . write ( get part boundary ( ) ) ; out . write ( crlf bytes ) ; }	Write the start to the specified output stream.
protected void send disposition header ( final output stream out ) throws io { if ( debug ) { log . v ( tag , str ) ; } out . write ( content disposition bytes ) ; out . write ( quote bytes ) ; out . write ( encoding utils . get ascii bytes ( get name ( ) ) ) ; out . write ( quote bytes ) ; }	Write the content disposition header to the specified output stream.
protected void send content type header ( final output stream out ) throws io { if ( debug ) { log . v ( tag , str ) ; } final string content type = get content type ( ) ; if ( content type != null ) { out . write ( crlf bytes ) ; out . write ( content type bytes ) ; out . write ( encoding utils . get ascii bytes ( content type ) ) ; final string char set = get char set ( ) ; if ( char set != null ) { out . write ( charset bytes ) ; out . write ( encoding utils . get ascii bytes ( char set ) ) ; } } }	Write the content type header to the specified output stream.
protected void send transfer encoding header ( final output stream out ) throws io { if ( debug ) { log . v ( tag , str ) ; } final string transfer encoding = get transfer encoding ( ) ; if ( transfer encoding != null ) { out . write ( crlf bytes ) ; out . write ( content transfer encoding bytes ) ; out . write ( encoding utils . get ascii bytes ( transfer encoding ) ) ; } }	Write the content transfer encoding header to the specifiedoutput stream.
protected void send end of header ( final output stream out ) throws io { if ( debug ) { log . v ( tag , str ) ; } out . write ( crlf bytes ) ; out . write ( crlf bytes ) ; }	Write the end of the header to the output stream.
protected void send end ( final output stream out ) throws io { if ( debug ) { log . v ( tag , str ) ; } out . write ( crlf bytes ) ; }	Write the end data to the output stream.
public static void send parts ( final output stream out , final part [ ] parts , final byte [ ] part boundary ) throws io { if ( parts == null ) { throw new illegal argument exception ( str ) ; } if ( part boundary == null || part boundary . length == num ) { throw new illegal argument exception ( str ) ; } for ( int i = num ; i < parts . length ; i ++ ) {	Write all parts and the last boundary to the specified output stream.
public static long get length of parts ( final part [ ] parts , final byte [ ] part boundary ) throws io { if ( debug ) { log . v ( tag , str ) ; } if ( parts == null ) { throw new illegal argument exception ( str ) ; } long total = num ; for ( int i = num ; i < parts . length ; i ++ ) {	Gets the length of the multipart message including the given parts.
private string is redirect ( string uri ) throws uri , url {	if it is, it returns the url parameter.
private void send not modified ( channel handler context ctx ) { http response response = new default http response ( http 1 1 , http response status . not modified ) ; set date header ( response ) ;	When file timestamp is the same as what the browser is sending up, send a "304 Not Modified".
private void set date header ( http response response ) { simple date format date formatter = new simple date format ( http date format , locale . us ) ; date formatter . set time zone ( time zone . get time zone ( http date gmt timezone ) ) ; calendar time = new gregorian calendar ( ) ; response . set header ( http headers . names . date , date formatter . format ( time . get time ( ) ) ) ; }	Sets the Date header for the HTTP response.
private void set date and cache headers ( http response response , file file to cache ) { simple date format date formatter = new simple date format ( http date format , locale . us ) ; date formatter . set time zone ( time zone . get time zone ( http date gmt timezone ) ) ;	Sets the Date and Cache headers for the HTTP Response.
private void set content type header ( http response response , file file ) { mimetypes file type map mime types map = new mimetypes file type map ( ) ; response . set header ( http headers . names . content type , mime types map . get content type ( file . get path ( ) ) ) ; }	Sets the content type header for the HTTP Response.
static void close on flush ( channel ch ) { if ( ch . is connected ( ) ) { ch . write ( channel buffers . empty buffer ) . add listener ( channel future listener . close ) ; } }	Closes the specified channel after all queued write requests are flushed.
@ override protected void send disposition header ( final output stream out ) throws io { if ( debug ) { log . v ( str , str ) ; } super . send disposition header ( out ) ; final string filename = this . source . get file name ( ) ; if ( filename != null ) { out . write ( file name bytes ) ; out . write ( quote bytes ) ; out . write ( encoding utils . get ascii bytes ( filename ) ) ; out . write ( quote bytes ) ; } }	Write the disposition header to the output stream.
@ override protected void send data ( final output stream out ) throws io { if ( debug ) { log . v ( tag , str ) ; } if ( length of data ( ) == num ) {	Write the data in "source" to the specified stream.
protected void install ( final int version ) throws io { if ( buffers pool == null ) { throw new illegal state exception ( str ) ; } disk cache = disk lru cache . open ( ensure working directory ( ) , version , entries count , get max size ( ) ) ; on cache installed ( ) ; }	Setup cache. This operation causes disk reads.
private synchronized file ensure working directory ( ) throws io { file directory = get working directory ( ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new io ( str + directory + str ) ; } } else { if ( ! directory . is directory ( ) ) { if ( ! directory . delete ( ) ) { throw new io ( directory + str ) ; } if ( ! directory . mkdirs ( ) ) { throw new io ( str + directory + str ) ; } } } return directory ; }	this method is synchronized in order to avoid concurrent calls to mkdir.
protected cache response get ( final cache entry request info ) { if ( ! check disk cache ( ) ) { return null ; } final cache entry entry = new cache entry ( ) ; final disk lru cache . snapshot snapshot = read cache info ( request info , entry ) ; if ( snapshot == null ) { return null ; } if ( ! entry . matches ( request info ) || ! entry . can be used ( ) ) { snapshot . close ( ) ; return null ; } hit count . increment and get ( ) ; final input stream body = new body input stream ( snapshot ) ; return entry . new cache response ( body ) ; }	Read cache for the specified cache entry.
private input stream new body input stream ( final disk lru cache . snapshot snapshot ) { return new filter input stream ( snapshot . get input stream ( entry body ) ) { @ override public void close ( ) throws io { snapshot . close ( ) ; super . close ( ) ; } } ; }	Returns an input stream that reads the body of a snapshot, closing thesnapshot when the stream is closed.
protected void reset ( final int width , final int height ) { bitmap bitmap = this . bitmap ;	Prepare for new width and hight.
public static websockify ssl context get instance ( string keystore , string password , string key password ) { websockify ssl context context = singleton holder . instance map . get ( keystore ) ; if ( context == null ) { context = new websockify ssl context ( keystore , password , key password ) ; singleton holder . instance map . put ( keystore , context ) ; } return context ; }	Returns the singleton instance for this class.
public static void validate keystore ( string keystore , string password , string key password ) throws key management exception , unrecoverable key exception , io , no such algorithm exception , certificate exception , key store exception { get ssl ( keystore , password , key password ) ; }	Validates that a keystore with the given parameters exists and can be used for an SSL context.
public scale type replace scale type ( final scale type type ) { block layout requests = bool ; final scale type result = get scale type ( ) ; set scale type ( type ) ; block layout requests = bool ; return result ; }	This method replaces the scale type of an image view without call to layout requests.
public pending intent get pending intent ( final request builder < ? > request builder , final int flags ) { return pending intent . get service ( context , num , get intent ( request builder ) , flags ) ; }	Construct a pending intent that can be used for starting request processing.Note that after this method is executed executor of the request builder is always null.
protected void disconnect ( final url connection ) { final url http = url connection wrapper . unwrap ( connection ) ; if ( http instanceof url ) { ( ( url ) http ) . disconnect ( ) ; } }	Perform disconnect actions.
public void bind ( ) { if ( service object != null ) { return ; } final context context = context ref . get ( ) ; if ( context == null ) { return ; }	Create the service connection.
public void unbind ( ) { if ( service object == null ) { return ; } service object = null ; final context context = context ref . get ( ) ; if ( debug ) { log . v ( tag , str + context + str + get interface class ( ) ) ; } if ( context == null ) { return ; } try { context . unbind service ( this ) ; } catch ( final exception e ) { if ( debug ) { log . e ( tag , str , e ) ; } } }	Destroy the service connection.
public void notify about view changes ( ) { final t view = this . view ; if ( view != null && view instanceof images load listener provider ) { this . listener = ( ( images load listener provider ) view ) . get images load listener ( ) ; } }	Method should be called when wrapped view gets changes related to this consumer.
@ override public void channel open ( final channel handler context ctx , final channel state event e ) throws exception { try {	The client won't send any message so connect directly on channel open.
protected response data < mt > on accept data ( final response data < mt > previous data , final response data < mt > response data ) { return response data ; }	Data loading has been successful, we are going to accept data.Here we can implement some accumulation logic.
@ override protected void on reset ( ) { if ( debug ) { log . v ( tag , str + this ) ; } super . on reset ( ) ; on stop loading ( ) ; if ( received response != null ) { on release data ( received response ) ; received response = null ; } }	request to completely reset the loader.
void wait for loader ( final long time ) { try { done . await ( time , time unit . milliseconds ) ; } catch ( final interrupted exception e ) { log . e ( tag , str , e ) ; } }	For testing only.
public static void set text or hide ( final text view view , final char sequence text , final int hvisibility ) { if ( text utils . is empty ( text ) ) { view . set visibility ( hvisibility ) ; } else { view . set text ( text ) ; view . set visibility ( view . visible ) ; } }	Set text view value or change its visibility in case of empty value.
public static void hide soft input ( final view text view ) { try { final input method manager imm = ( input method manager ) text view . get context ( ) . get system service ( context . input method service ) ; imm . hide soft input from window ( text view . get window token ( ) , num ) ; } catch ( final exception e ) { log . w ( tag , str , e ) ; } }	Hide soft keyboard.
public static void show soft input ( final view text view ) { try { final input method manager imm = ( input method manager ) text view . get context ( ) . get system service ( context . input method service ) ; imm . show soft input ( text view , input method manager . show forced ) ; } catch ( final exception e ) { log . w ( tag , str , e ) ; } }	Show soft keyboard.
public static void toggle soft input ( final view text view ) { try { final input method manager imm = ( input method manager ) text view . get context ( ) . get system service ( context . input method service ) ; imm . toggle soft input from window ( text view . get window token ( ) , num , num ) ; } catch ( final exception e ) { log . w ( tag , str , e ) ; } }	Toggles keyboard visibility.
public static int pixels width ( final display metrics display metrics , final int dip ) { final float scale = display metrics . density ; final float alpha = num ; return ( int ) ( dip * scale + alpha ) ; }	Converts device independent points to actual pixels.
@ override public void exception caught ( channel handler context ctx , exception event e ) throws exception { cancel direct connection timer ( ) ; logger . get logger ( port unification handler . class . get name ( ) ) . severe ( str + ctx . get channel ( ) . get remote address ( ) + str + e . get cause ( ) . get message ( ) ) ; }	cancel the timer if exception is caught - prevents useless stack traces.
public boolean clear cache ( final string url ) { mem cache . remove ( url ) ; try { return images response cache . delete get entry ( url ) ; } catch ( final io e ) { log . w ( tag , str + url , e ) ; return bool ; } }	Clear the cached entities.
public void populate image ( final view view , final string url ) { final object tag = view . get tag ( ) ; image consumer consumer = null ; if ( tag == null ) { consumer = create image consumer ( view ) ; view . set tag ( consumer ) ; } else { if ( ! ( tag instanceof image consumer ) ) { throw new illegal state exception ( str + tag + str ) ; } consumer = ( image consumer ) tag ; } populate image ( consumer , url ) ; }	Populate the requested image to the specified view.
public void cancel image loading ( final view view ) { check thread ( ) ; final object tag = view . get tag ( ) ; if ( tag != null && tag instanceof image consumer ) { cancel image loading ( ( image consumer ) tag ) ; } }	Cancel image loading for a view.
protected image consumer create image consumer ( final view view ) { if ( this . consumer factory == null ) { throw new illegal state exception ( str ) ; } return consumer factory . create consumer ( view ) ; }	Create an image holder instance for the defined view.
protected final void set result image ( final image consumer consumer , final image result result , final boolean animate ) { decorate result ( consumer , result ) ; consumer . set image ( create drawable ( result . get bitmap ( ) ) , animate ) ; consumer . reset ( ) ; }	It must be executed in the main thread.
private void set loading image ( final image consumer consumer ) { if ( ! consumer . skip loading image ( ) ) { drawable d = get loading drawable ( consumer ) ; if ( ! consumer . has undefined size ( ) || ( d . get intrinsic width ( ) != num && d . get intrinsic height ( ) != num ) ) { consumer . set loading image ( d ) ; } } }	Set preloader.
private void start image loader task ( final image consumer consumer , final image request request ) { final string key = request . get key ( ) ; if ( debug ) { log . d ( tag , str + key ) ; } image loader loader = current loads . get ( key ) ; if ( loader != null ) { final boolean added = loader . add target ( consumer ) ; if ( ! added ) { loader = null ; } } if ( loader == null ) { if ( debug ) { log . d ( tag , str ) ; } loader = new image loader ( request , this ) ; if ( ! loader . add target ( consumer ) ) { throw new illegal state exception ( str ) ; } current loads . put ( key , loader ) ; if ( debug ) { log . d ( tag , str + current loads . size ( ) ) ; } final executor executor = get image task executor ( ) ; executor . execute ( loader . future ) ; } else if ( debug ) { log . d ( tag , str + key ) ; } }	Executed in the main thread.
protected void mem cache image ( final string url , final bitmap bitmap ) { if ( debug ) { log . d ( tag , str + url ) ; } mem cache . put element ( url , bitmap ) ; }	Add image to memory cache.
public void release ( final byte [ ] buffer ) { if ( buffer == null ) { return ; } final int capacity = buffer . length ; if ( capacity == num ) { return ; } synchronized ( lock ) { list < object > b list = buffers . get ( capacity ) ; if ( b list == null ) { b list = new linked list < object > ( ) ; buffers . put ( capacity , b list ) ; } b list . add ( buffer ) ; used buffers count -- ; } }	Recycle the buffer.
protected void on url ( final context context , final url url connection ) { if ( content type != null ) { url connection . add request property ( str , content type ) ; } if ( content language != null ) { url connection . add request property ( str , content language ) ; } url connection . add request property ( str , io utils . encoding gzip ) ; url connection . add request property ( str , build user agent ( context ) ) ; if ( headers != null ) { for ( string name : headers . key set ( ) ) { url connection . add request property ( name , headers . get string ( name ) ) ; } } }	A good place to set custom request headers.
public simple request builder < mt > add param ( final string name , final string value ) { add simple parameter ( name , value ) ; return this ; }	Add string parameter.
private void connect with workaround ( ) throws io { if ( build . version . sdk int > build . version codes . gingerbread m ) { super . connect ( ) ; return ; } url core connection = url connection wrapper . unwrap ( get core ( ) ) ; if ( core connection instanceof url ) {	XXX on 2.3 we get NP exception in case of HTTPs connection and cache.
public static string get md5 ( final string text ) { try { final message digest md = message digest . get instance ( str ) ; final byte [ ] utf8 bytes = text . get bytes ( utf 8 name ) ; md . update ( utf8 bytes , num , utf8 bytes . length ) ; final byte [ ] md5hash = md . digest ( ) ; final int radix = num ; final int length = num ; final string builder result = new string builder ( length ) . append ( new big integer ( num , md5hash ) . to string ( radix ) ) ; final int zero begin len = length - result . length ( ) ; if ( zero begin len > num ) { final char [ ] zero begin = new char [ zero begin len ] ; arrays . fill ( zero begin , character . for digit ( num , radix ) ) ; result . insert ( num , zero begin ) ; } return result . to string ( ) ; } catch ( final no such algorithm exception | unsupported encoding exception e ) { throw new assertion error ( e ) ; } }	Calculate 32 bytes length MD5 digest.
public static string string for ( int n ) { switch ( n ) { case cublas gemm default : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm alg : return str ; case cublas gemm default tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; case cublas gemm alg tensor op : return str ; } return str + n ; }	Returns a string representation of the given constant.
public static string string for ( int n ) { switch ( n ) { case cublas status success : return str ; case cublas status not initialized : return str ; case cublas status alloc failed : return str ; case cublas status invalid value : return str ; case cublas status arch mismatch : return str ; case cublas status mapping error : return str ; case cublas status execution failed : return str ; case cublas status internal error : return str ; case cublas status not supported : return str ; case jcublas status internal error : return str ; } return str + n ; }	Returns the String identifying the given cublasStatus.
private static int check result ( int result ) { if ( exceptions enabled && result != cublas status . cublas status success ) { throw new cuda exception ( cublas status . string for ( result ) ) ; } return result ; }	If the given result is different to cublasStatus.CUBLAS_STATUS_SUCCESSand exceptions have been enabled, this method will throw aCudaException with an error message that corresponds to thegiven result code.
private static void check result blas ( ) { if ( exceptions enabled ) { last result = cublas get error native ( ) ; if ( last result != cublas status . cublas status success ) { throw new cuda exception ( cublas status . string for ( last result ) ) ; } } }	Obtain the current CUBLAS status by calling cublasGetErrorNative,and store the result as the lastResult.
public void add lexeme ( int lexeme id ) { int count = num ; if ( lexeme frequency . get ( lexeme id ) != null ) count = lexeme frequency . get ( lexeme id ) + num ; lexeme frequency . put ( lexeme id , count ) ; }	Add one occurrence of one lexeme.
public void add ending ( int ending id ) { int count = num ; if ( ending frequency . get ( ending id ) != null ) count = ending frequency . get ( ending id ) + num ; ending frequency . put ( ending id , count ) ; }	Add one occurrence of one ending.
public double get estimate ( attribute values wordform ) { double estimate = num ; string ending id str = wordform . get value ( attribute names . i id ) ; int ending id = ( ending id str == null ) ? - num : integer . parse int ( ending id str ) ; if ( ending frequency . get ( ending id ) != null ) estimate += ending frequency . get ( ending id ) ; string lexeme id str = wordform . get value ( attribute names . i id ) ; int lexeme id = ( lexeme id str == null ) ? - num : integer . parse int ( lexeme id str ) ; if ( lexeme frequency . get ( lexeme id ) != null ) estimate += lexeme frequency . get ( lexeme id ) * lexeme weight ; return estimate ; }	Cumulative frequency estimate for given wordform.
public void long description ( print stream out ) { out . println ( this . token + str ) ; for ( string s : this . attributes . key set ( ) ) { out . println ( s + str + attributes . get ( s ) ) ; } }	For debugging purposes only.
private static void verify and set kamols attribute ( attribute values avs , string builder tag , int index , char tag value , string attribute , string attribute value ) { if ( avs . is matching strong ( attribute , attribute value ) ) tag . set char at ( index , tag value ) ; }	Check if attribute-value structure has attribute matching givenattributeValue and if so then set corresponding position in the tag.
public static string remove kamols markup formating ( string tag ) { string result = str ; if ( ! tag . contains ( str ) ) return str ; int depth = num ; int commas = num ; for ( char c : tag . to char array ( ) ) { if ( c == str ) depth ++ ; if ( c == str ) depth -- ; if ( depth == num && c == str ) commas ++ ; if ( commas == num ) result = result + c ; } result = result . replace all ( str , str ) ; result = result . replace all ( str , str ) ; return result ; }	Remove formating from Kamols-style tag.
public list < metric data > get ( ) throws request exception , unauthorized exception { http response < string > response ; try { response = unirest . get ( this . appd url + str + app name + str ) . header ( str , str ) . basic auth ( this . appd username , this . appd password ) . query string ( get query string ( ) ) . query string ( str , str ) . as string ( ) ; } catch ( unirest exception e ) { throw new request exception ( str , e ) ; } if ( response == null ) { throw new request exception ( str ) ; } switch ( response . get status ( ) ) { case num : { return process ( new json node ( response . get body ( ) ) ) ; } case num : { throw new unauthorized exception ( str ) ; } default : { throw new request exception ( str + response . get status ( ) ) ; } } }	Perform retrieval of metrics from AppDynamics using specified parameters.
protected map < string , object > get query string ( ) { map < string , object > qs = new hash map < > ( ) ; if ( time params != null ) { qs . put ( str , time params . type ) ; if ( time params . duration > num ) { qs . put ( str , time params . duration ) ; } if ( time params . start time > num ) { qs . put ( str , time params . start time ) ; } if ( time params . end time > num ) { qs . put ( str , time params . end time ) ; } } qs . put ( str , bool ) ; if ( metric path != null ) { qs . put ( str , metric path ) ; } return qs ; }	Generate querystring for the request.
protected list < metric data > process ( json node node ) { json data array = node . get array ( ) ; list < metric data > list = new linked list < > ( ) ; for ( int i = num ; i < data array . length ( ) ; i ++ ) { json data = data array . get json ( i ) ; metric data metric data = new metric data ( data . get string ( str ) , data . get long ( str ) , data . get string ( str ) , data . get string ( str ) ) ; list . add ( metric data ) ; json value array = data . get json ( str ) ; for ( int j = num ; j < value array . length ( ) ; j ++ ) { json value = value array . get json ( j ) ; metric data . metric values . add ( new metric value ( value . get long ( str ) , value . get long ( str ) , value . get long ( str ) , value . get long ( str ) , value . get long ( str ) , value . get long ( str ) ) ) ; } } return list ; }	Process the JSON response from the request.
public static list < app info > parse info ( string json string ) throws io { object mapper mapper = new object mapper ( ) ; return mapper . read value ( json string , new type reference < list < app info > > ( ) { } ) ; }	Parse JSON String as configurations that the task should query from AppDynamics.
public static connection config get connection config ( ) { boolean is valid = bool ; string appd username = get property or env ( str , str ) ; if ( string utils . is empty ( appd username ) ) { log . error ( str ) ; is valid = bool ; } string appd password = get property or env ( str , str ) ; if ( string utils . is empty ( appd password ) ) { log . error ( str ) ; is valid = bool ; } string appd url = get property or env ( str , str ) ; if ( string utils . is empty ( appd url ) ) { log . error ( str ) ; is valid = bool ; } string fx token = get property or env ( str , str ) ; if ( string utils . is empty ( fx token ) ) { log . error ( str ) ; is valid = bool ; } if ( is valid ) { return new connection config ( appd username , appd password , appd url , fx token ) ; } else { return null ; } }	Retrieve configurations by looking up in property param first then environment variable.
public void perform ( list < app info > apps , metric data request . time params time params ) { list < signal fx protocol buffers . data point > data points = new linked list < > ( ) ; for ( app info app : apps ) { data request . set app name ( app . name ) ; for ( metric info metric info : app . metrics ) { data request . set time params ( time params ) ; data request . set metric path ( metric info . metric path query ) ; list < metric data > metric data list ; try { metric data list = data request . get ( ) ; } catch ( request exception e ) {	Perform reading and reporting of AppDynamics metrics to SignalFx.
@ nonnull public static genericode reader < com . helger . genericode . v04 . code list document > gc04 code list ( ) { return new genericode reader < > ( e . g code list , com . helger . genericode . v04 . code list document . class ) ; }	Create a reader builder for com.helger.genericode.v04.CodeListDocument.
@ nonnull public static genericode reader < com . helger . genericode . v04 . code list set document > gc04 code list set ( ) { return new genericode reader < > ( e . g code list set , com . helger . genericode . v04 . code list set document . class ) ; }	Create a reader builder for com.helger.genericode.v04.CodeListSetDocument.
@ nonnull public static genericode reader < com . helger . genericode . v04 . column set document > gc04 column set ( ) { return new genericode reader < > ( e . g column set , com . helger . genericode . v04 . column set document . class ) ; }	Create a reader builder for com.helger.genericode.v04.ColumnSetDocument.
@ nonnull public static genericode reader < com . helger . genericode . v10 . code list document > gc10 code list ( ) { return new genericode reader < > ( e . g code list , com . helger . genericode . v10 . code list document . class ) ; }	Create a reader builder for com.helger.genericode.v10.CodeListDocument.
@ nonnull public static genericode reader < com . helger . genericode . v10 . code list set document > gc10 code list set ( ) { return new genericode reader < > ( e . g code list set , com . helger . genericode . v10 . code list set document . class ) ; }	Create a reader builder for com.helger.genericode.v10.CodeListSetDocument.
@ nonnull public static genericode reader < com . helger . genericode . v10 . column set document > gc10 column set ( ) { return new genericode reader < > ( e . g column set , com . helger . genericode . v10 . column set document . class ) ; }	Create a reader builder for com.helger.genericode.v10.ColumnSetDocument.
@ nonnull public static string get column element id ( @ nonnull final object a column element ) { if ( a column element instanceof column ref ) return ( ( column ref ) a column element ) . get id ( ) ; if ( a column element instanceof column ) return ( ( column ) a column element ) . get id ( ) ; if ( a column element instanceof key ) { final list < key column ref > a key column refs = ( ( key ) a column element ) . get column ref ( ) ; final key column ref a key column ref = collection helper . get first element ( a key column refs ) ; if ( a key column ref == null ) throw new illegal argument exception ( str ) ; final object a ref = a key column ref . get ref ( ) ; if ( a ref instanceof column ) return ( ( column ) a ref ) . get id ( ) ; throw new illegal argument exception ( str + a ref + str + class helper . get safe class name ( a ref ) ) ; } throw new illegal argument exception ( str + a column element + str + class helper . get safe class name ( a column element ) ) ; }	Get the ID of the passed column element.
@ nullable public static string get row value ( @ nonnull final row a row , @ nonnull final string s column id ) { for ( final value a value : a row . get value ( ) ) { final string s id = get column element id ( a value . get column ref ( ) ) ; if ( s id . equals ( s column id ) ) { final simple value a simple value = a value . get simple value ( ) ; return a simple value != null ? a simple value . get value ( ) : null ; } } return null ; }	Get the value of a column identified by an ID within a specified row.
@ nullable public static column get column of id ( @ nonnull final column set a column set , @ nullable final string s id ) { if ( s id != null ) for ( final column a column : get all columns ( a column set ) ) if ( a column . get id ( ) . equals ( s id ) ) return a column ; return null ; }	Get the column with the specified ID.
public static void get all key i ( @ nonnull final column set a column set , @ nonnull final collection < string > a target ) { collection helper . find all ( a column set . get key choice ( ) , o -> o instanceof key , o -> a target . add ( ( ( key ) o ) . get id ( ) ) ) ; }	Get the IDs of all contained keys.
@ nullable public static key get key of id ( @ nonnull final column set a column set , @ nullable final string s id ) { if ( s id != null ) for ( final key a key : get all keys ( a column set ) ) if ( a key . get id ( ) . equals ( s id ) ) return a key ; return null ; }	Get the key with the specified ID.
public static boolean is key column ( @ nonnull final column set a column set , @ nullable final string s column id ) { if ( s column id != null ) for ( final key a key : get all keys ( a column set ) ) for ( final key column ref a column ref : a key . get column ref ( ) ) if ( a column ref . get ref ( ) instanceof column ) if ( ( ( column ) a column ref . get ref ( ) ) . get id ( ) . equals ( s column id ) ) return bool ; return bool ; }	Check if the passed column ID is a key column in the specified column set.
@ nonnull public static column create column ( @ nonnull @ nonempty final string s column id , @ nonnull final use type e use type , @ nonnull @ nonempty final string s short name , @ nullable final string s long name , @ nonnull @ nonempty final string s data type ) { value enforcer . not empty ( s column id , str ) ; value enforcer . not null ( e use type , str ) ; value enforcer . not empty ( s short name , str ) ; value enforcer . not empty ( s data type , str ) ; final column a column = s a factory . create column ( ) ; a column . set id ( s column id ) ; a column . set use ( e use type ) ; a column . set short name ( create short name ( s short name ) ) ; if ( string helper . has text ( s long name ) ) a column . get long name ( ) . add ( create long name ( s long name ) ) ; final data a data = s a factory . create data ( ) ; a data . set type ( s data type ) ; a column . set data ( a data ) ; return a column ; }	Create a new column to be added to a column set.
@ nonnull public static key create key ( @ nonnull @ nonempty final string s column id , @ nonnull @ nonempty final string s short name , @ nullable final string s long name , @ nonnull final column a column ) { value enforcer . not empty ( s column id , str ) ; value enforcer . not empty ( s short name , str ) ; value enforcer . not null ( a column , str ) ; final key a key = s a factory . create key ( ) ; a key . set id ( s column id ) ; a key . set short name ( create short name ( s short name ) ) ; if ( string helper . has text ( s long name ) ) a key . get long name ( ) . add ( create long name ( s long name ) ) ; a key . get column ref ( ) . add ( create key column ref ( a column ) ) ; return a key ; }	Create a new key to be added to a column set.
@ nonnull public excel read options < use type > set lines to skip ( @ nonnegative final int n lines to skip ) { value enforcer . is g ( n lines to skip , str ) ; m n lines to skip = n lines to skip ; return this ; }	Set the number of lines to skip before the header row starts.
@ nonnull public excel read options < use type > add column ( @ nonnegative final int n index , @ nonnull @ nonempty final string s column id , @ nonnull final use type e use type , @ nonnull @ nonempty final string s data type , final boolean b key column ) { value enforcer . is g ( n index , str ) ; final integer a index = integer . value of ( n index ) ; if ( m a columns . contains key ( a index ) ) throw new illegal argument exception ( str + n index + str ) ; m a columns . put ( a index , new excel read column < > ( n index , s column id , e use type , s data type , b key column ) ) ; return this ; }	Add a single column definition.
@ nonnull public static genericode writer < com . helger . genericode . v04 . code list document > gc04 code list ( ) { return new genericode writer < > ( e . g code list ) ; }	Create a writer builder for com.helger.genericode.v04.CodeListDocument.
@ nonnull public static genericode writer < com . helger . genericode . v04 . code list set document > gc04 code list set ( ) { return new genericode writer < > ( e . g code list set ) ; }	Create a writer builder for com.helger.genericode.v04.CodeListSetDocument.
@ nonnull public static genericode writer < com . helger . genericode . v04 . column set document > gc04 column set ( ) { return new genericode writer < > ( e . g column set ) ; }	Create a writer builder for com.helger.genericode.v04.ColumnSetDocument.
@ nonnull public static genericode writer < com . helger . genericode . v10 . code list document > gc10 code list ( ) { return new genericode writer < > ( e . g code list ) ; }	Create a writer builder for com.helger.genericode.v10.CodeListDocument.
@ nonnull public static genericode writer < com . helger . genericode . v10 . code list set document > gc10 code list set ( ) { return new genericode writer < > ( e . g code list set ) ; }	Create a writer builder for com.helger.genericode.v10.CodeListSetDocument.
@ nonnull public static genericode writer < com . helger . genericode . v10 . column set document > gc10 column set ( ) { return new genericode writer < > ( e . g column set ) ; }	Create a writer builder for com.helger.genericode.v10.ColumnSetDocument.
@ nonnull public static genericode validator < com . helger . genericode . v04 . code list document > gc04 code list ( ) { return new genericode validator < > ( e . g code list ) ; }	Create a validator builder for com.helger.genericode.v04.CodeListDocument.
@ nonnull public static genericode validator < com . helger . genericode . v04 . code list set document > gc04 code list set ( ) { return new genericode validator < > ( e . g code list set ) ; }	Create a validator builder forcom.helger.genericode.v04.CodeListSetDocument.
@ nonnull public static genericode validator < com . helger . genericode . v04 . column set document > gc04 column set ( ) { return new genericode validator < > ( e . g column set ) ; }	Create a validator builder for com.helger.genericode.v04.ColumnSetDocument.
@ nonnull public static genericode validator < com . helger . genericode . v10 . code list document > gc10 code list ( ) { return new genericode validator < > ( e . g code list ) ; }	Create a validator builder for com.helger.genericode.v10.CodeListDocument.
@ nonnull public static genericode validator < com . helger . genericode . v10 . code list set document > gc10 code list set ( ) { return new genericode validator < > ( e . g code list set ) ; }	Create a validator builder forcom.helger.genericode.v10.CodeListSetDocument.
@ nonnull public static genericode validator < com . helger . genericode . v10 . column set document > gc10 column set ( ) { return new genericode validator < > ( e . g column set ) ; }	Create a validator builder for com.helger.genericode.v10.ColumnSetDocument.
protected static void send logs to server ( boolean set sent time ) { long time sent = new date ( ) . get time ( ) ; string app feed back summary = utility . convert file to string ( str ) ; if ( str . equals ( app feed back summary ) || str . equals ( app feed back summary ) ) { return ; } else { try { json app feed backsummary json = new json ( app feed back summary ) ; json saved array = ( json ) app feed backsummary json . get ( str ) ; hash map < string , string > time sent map = new hash map < > ( ) ;	Send Logs to Server.
static public void set context ( final context context ) {	Context object must be set in order to use the Logger API.
static public logger . level get log level ( ) { final future < logger . level > task = thread pool work queue . submit ( new callable < logger . level > ( ) { @ override public logger . level call ( ) { return get level sync ( ) ; } } ) ; try { return task . get ( ) ; } catch ( exception e ) { return get level sync ( ) ; } }	Get the current Logger.LEVEL.
static public boolean get capture ( ) { final future < boolean > task = thread pool work queue . submit ( new callable < boolean > ( ) { @ override public boolean call ( ) { return get capture sync ( ) ; } } ) ; try { return task . get ( ) ; } catch ( exception e ) { return get capture sync ( ) ; } }	Get the current value of the capture flag, indicating that the Logger is recording log calls persistently.
static public void set max log store size ( final int bytes ) {	Set the maximum size of the local log file.
protected static string prepend metadata ( string message , json metadata ) { try { if ( null != metadata ) { string clazz = str ; string method = str ; string file = str ; string line = str ; if ( metadata . has ( str ) ) { clazz = metadata . get string ( str ) ; clazz = clazz . substring ( clazz . last index of ( str ) + num , clazz . length ( ) ) ; } if ( metadata . has ( str ) ) { method = metadata . get string ( str ) ; } if ( metadata . has ( str ) ) { file = metadata . get string ( str ) ; } if ( metadata . has ( str ) ) { line = metadata . get string ( str ) ; } if ( ! ( clazz + method + file + line ) . equals ( str ) ) {	if we have callstack metadata, prepend it to the message.
protected static json append stack metadata ( json additional metadata ) { json json metadata ; if ( additional metadata != null ) { json metadata = additional metadata ; } else { json metadata = new json ( ) ; } try {	Get stack trace caused by Logger exceptions.
private static json create json ( final logger . level level , final string pkg , final string message , long timestamp , final json json metadata , final throwable t ) { json json object = new json ( ) ; try { json object . put ( str , timestamp ) ; json object . put ( str , level . to string ( ) ) ; json object . put ( str , pkg ) ; json object . put ( str , message ) ; json object . put ( str , thread . current thread ( ) . get id ( ) ) ; if ( null != json metadata ) { json object . put ( str , json metadata ) ; } if ( null != t ) { json object . put ( str , append full stack trace ( json metadata , t ) ) ; } } catch ( json e ) { log . e ( log tag name , str , e ) ; } return json object ; }	Will create JSONObject with the passed parameters, and other relevant information.
private static void set user identity ( final string user , boolean is initial ctx ) { if ( ! is initial ctx && ! bms . has user context ) {	Specify current application user.
private byte [ ] get byte array from file ( final string file ) throws unsupported encoding exception { string ret = str ; file fl = new file ( context . get files dir ( ) , file ) ; if ( fl . exists ( ) ) { try { file input stream fin = new file input stream ( fl ) ; byte array output stream baos = new byte array output stream ( ( int ) fl . length ( ) ) ; copy stream ( fin , baos ) ; return baos . to byte array ( ) ; } catch ( io e ) { log . e ( log persister . log tag name , str + fl . to string ( ) , e ) ; } } return ret . get bytes ( str ) ; }	public for testing only.
protected void start location updates ( ) { if ( activity compat . check self permission ( context , manifest . permission . access fine location ) != package manager . permission granted && activity compat . check self permission ( context , manifest . permission . access coarse location ) != package manager . permission granted ) {	Starting the location updates.
public void size region ( region < ? , ? > region , int num entries ) { if ( region == null ) { throw new illegal argument exception ( str ) ; } if ( region instanceof partitioned region ) { size partitioned region ( region , num entries ) ; } else { size replicated or local region ( region , num entries ) ; } }	Calculates and logs the size of first numEntries in the region.
private void size partitioned region ( region < ? , ? > region , int num entries ) { region < ? , ? > primary data set = partition region helper . get local data ( region ) ; int region size = primary data set . size ( ) ; if ( num entries == num ) { num entries = primary data set . size ( ) ; } else if ( num entries > region size ) { num entries = region size ; } int count = num ; for ( iterator < ? > i = primary data set . entry set ( ) . iterator ( ) ; i . has next ( ) ; ) { if ( count == num entries ) { break ; } entry snapshot entry = ( entry snapshot ) i . next ( ) ; region entry re = entry . get region entry ( ) ; dump sizes ( entry , re ) ; } dump total and average sizes ( num entries ) ; clear totals ( ) ; }	Sizes numEntries of a partitioned region, or all the entries ifnumEntries is 0.
private void size replicated or local region ( region < ? , ? > region , int num entries ) { set < ? > entries = region . entry set ( ) ; int region size = entries . size ( ) ; if ( num entries == num ) { num entries = entries . size ( ) ; } else if ( num entries > region size ) { num entries = region size ; } int count = num ; for ( iterator < ? > i = entries . iterator ( ) ; i . has next ( ) ; ) { if ( count == num entries ) { break ; } local region . tx entry = ( local region . tx ) i . next ( ) ; region entry re = entry . get region entry ( ) ; dump sizes ( entry , re ) ; } dump total and average sizes ( num entries ) ; clear totals ( ) ; }	Sizes numEntries of a replicated or local region, or all the entries ifnumEntries is 0.
public snapshot record read snapshot record ( ) throws io , class not found exception { byte [ ] key = data serializer . read byte array ( dis ) ; if ( key == null ) { return null ; } byte [ ] value = data serializer . read byte array ( dis ) ; return new snapshot record ( key , value ) ; }	Reads a snapshot entry.
void dump ( print writer stream ) { stream . print ( str + count ) ; for ( int i = num ; i < count ; i ++ ) { if ( i != num ) { stream . print ( str ) ; stream . print ( time stamps [ i ] - time stamps [ i - num ] ) ; } else { stream . print ( str + time stamps [ i ] ) ; } } stream . println ( str ) ; }	elapsed millis from base.
double [ ] get time values since idx ( int idx ) { int result size = this . count - idx ; double [ ] result = new double [ result size ] ; for ( int i = num ; i < result size ; i ++ ) { result [ i ] = get milli time stamp ( idx + i ) ; } return result ; }	Returns an array of time stamp values the first of which has thespecified index.
public chart convert ( file file ) { if ( file == null ) return null ; try { if ( file . is directory ( ) ) {	Accepts a file or directory contain the statistics files.
public static synchronized pool get pool for server ( string server name , jmx jmx ) throws instance not found exception { pool pool = pool manager . find ( server name ) ; if ( pool != null ) return pool ; pool factory pool factory = pool manager . create factory ( ) ;	Dynamically create a GemFire pool with just the server.
public static synchronized pool get pool for locator ( jmx jmx ) { string locators pool name = jmx . get host ( ) + str + jmx . get port ( ) + str ; pool pool = pool manager . find ( locators pool name ) ; if ( pool != null ) return pool ; pool factory pool factory = pool manager . create factory ( ) ; try { int port = get locator port ( jmx ) ; pool factory = pool factory . add locator ( jmx . get host ( ) , port ) ; return pool factory . create ( locators pool name ) ; } catch ( exception e ) { throw new runtime exception ( str + jmx . get host ( ) + str + e . get message ( ) , e ) ; } }	This methods create a pool for connecting to a locator.
private static boolean is existing region on server ( string region name , jmx jmx ) { string region jmx pattern = string . format ( str , region name ) ;	Determine if a given region exists.
public static mx get member ( string name , jmx jmx ) { try { string pattern = str + name ; set < object name > object names = jmx . search object names ( pattern ) ; if ( object names == null || object names . is empty ( ) ) return null ; object name server name = new object name ( pattern ) ; return jmx . new bean ( mx . class , server name ) ; } catch ( malformed object name exception e ) { throw new runtime exception ( str + name + str + e . get message ( ) , e ) ; } }	Obtain a GemFire JMX client.
public static collection < string > list hosts ( jmx jmx ) { set < object name > object names = jmx . search object names ( str ) ; if ( object names == null || object names . is empty ( ) ) { return null ; } hash set < string > host lists = new hash set < string > ( object names . size ( ) ) ; mx member mx = null ; for ( object name object name : object names ) { member mx = jmx . new bean ( mx . class , object name ) ; host lists . add ( member mx . get host ( ) ) ; } return host lists ; }	Determines the unique set of the host names for the distributed system.
static synchronized string lookup network host ( string host ) { try { if ( bundle == null ) { url url = gem fire jmx client . class . get resource ( host prop file name ) ; string file path = null ; if ( url == null ) file path = host prop file name ; else file path = url . to string ( ) ; system . out . println ( new string builder ( str ) . append ( file path ) . to string ( ) ) ; bundle = resource bundle . get bundle ( str ) ; } system . out . println ( new string builder ( str ) . append ( host ) . append ( str ) . append ( host prop file name ) . to string ( ) ) ; string new host = bundle . get string ( host ) ; system . out . println ( new string builder ( host ) . append ( str ) . append ( new host ) . to string ( ) ) ; return new host ; } catch ( runtime exception e ) { system . out . println ( str + host ) ; return host ; } }	Supports resolving host network lookup issues.
public static boolean is error and send exception ( result sender < object > result sender , object data ) { if ( data instanceof throwable ) { throwable e = ( throwable ) data ; result sender . send exception ( e ) ; return bool ; } return bool ; }	Determine if the data should be sent.
@ suppress warnings ( str ) public static < t > collection < t > exe with results ( execution < ? , ? , ? > execution , function < ? > function ) throws exception { result collector < ? , ? > result collector ; try { result collector = execution . execute ( function ) ; } catch ( function exception e ) { if ( e . get cause ( ) instanceof null pointer exception ) throw new runtime exception ( str + function . get id ( ) + str + str + str + str , e ) ; else throw e ; } object results object = result collector . get result ( ) ;	Execute a function with the given execution settings.
@ suppress warnings ( str ) public static < t > void flatten ( collection < object > input , collection < object > flatten output ) throws exception { if ( input == null || input . is empty ( ) || flatten output == null ) return ; for ( object input obj : input ) { if ( input obj instanceof exception ) throw ( exception ) input obj ; if ( input obj == null ) continue ; if ( input obj instanceof collection ) flatten ( ( collection < object > ) input obj , flatten output ) ; else flatten output . add ( input obj ) ; } }	Used to flatten results from multiple servers.
@ suppress warnings ( str ) public static < return type > collection < return type > query ( query query obj , region function context rfc , object ... params ) throws function domain exception , type mismatch exception , name resolution exception , query invocation target exception { select results < return type > select results ;	Select results for OQL.
public static < k , v > cache listener bridge < k , v > for after put ( consumer < entry event < k , v > > consumer ) { return new cache listener bridge < k , v > ( consumer , null ) ; }	Factory method for put events registration.
public static < k , v > cache listener bridge < k , v > for after delete ( consumer < entry event < k , v > > consumer ) { return new cache listener bridge < k , v > ( null , consumer ) ; }	Factory method for delete events registration.
@ exception handler ( exception . class ) private data error handle exception ( http servlet request request , http servlet response response , exception e ) { return fault agent . handle exception ( request , response , e ) ; }	Handling exceptions in general for REST responses.
public on region filter key facts [ ] get on region filter key facts ( ) { if ( on region filter key facts == null ) return null ; return arrays . copy of ( on region filter key facts , on region filter key facts . length ) ; }	On region filter facts determine how to parse the inputs typically for CICS to grid calls.
@ override public void execute ( function context < object > function context ) { result sender < object > sender = function context . get result sender ( ) ; cache cache = cache factory . get any instance ( ) ; logger log writer = log manager . get logger ( get class ( ) ) ; try {	This function will use the JsonExportFunction functionto export json data and read the results to be returned to callers.
public static set < string > list hosts ( jmx jmx ) { set < object name > member objects = jmx . search object names ( str ) ; if ( member objects == null || member objects . is empty ( ) ) { return null ; } hash set < string > host list = new hash set < string > ( member objects . size ( ) ) ; mx bean = null ; for ( object name object name : member objects ) { bean = jmx . new bean ( mx . class , object name ) ; try { host list . add ( bean . get host ( ) ) ; } catch ( undeclared throwable exception e ) {	List the unique set of host name.
@ suppress warnings ( { str , str } ) @ override public void execute ( function context function context ) { cache cache = cache factory . get any instance ( ) ; try {	Execute the search on Region.
public static string get app name ( resource inst [ ] resources ) { if ( resources == null || resources . length == num ) return null ; resource type rt = null ; for ( resource inst resource inst : resources ) { if ( resource inst == null ) continue ; rt = resource inst . get type ( ) ; if ( rt == null ) continue ; if ( ! str . equals ( rt . get name ( ) ) ) continue ; return resource inst . get name ( ) ; } return null ; }	Current supports get cache server nameDetermine the logic name of app.
protected static void construct security ( properties props ) throws io { props . set property ( str , geode config auth initialize . class . get name ( ) + str ) ;	Initialize security properties.
@ suppress warnings ( str ) public < k , v > region < k , v > get region ( string region name ) { if ( region name == null || region name . length ( ) == num ) return null ; region < k , v > region = ( region < k , v > ) client cache . get region ( region name ) ; if ( region != null ) return ( region < k , v > ) region ; region = ( region < k , v > ) this . create region ( region name ) ;	This is an example to get or create a region.
@ suppress warnings ( str ) public static < k , v > region < k , v > get region ( client cache client cache , string region name ) { if ( region name == null || region name . length ( ) == num ) return null ; region < k , v > region = ( region < k , v > ) client cache . get region ( region name ) ; if ( region != null ) return ( region < k , v > ) region ; region = ( region < k , v > ) client cache . create client region factory ( client region shortcut . proxy ) . create ( region name ) ; return region ; }	Create a proxy region.
public void construct comparison ( map < ? , big integer > source checksum map , map < ? , big integer > target map ) { if ( source checksum map == null ) { if ( target map != null && ! target map . is empty ( ) ) { this . keys removed from source . add all ( target map . key set ( ) ) ; } return ; } if ( target map == null ) { this . keys missing on target . add all ( source checksum map . key set ( ) ) ; return ; } big integer target bi = null ; big integer source bi = null ; for ( map . entry < ? , big integer > entry source : source checksum map . entry set ( ) ) { target bi = target map . get ( entry source . get key ( ) ) ; source bi = source checksum map . get ( entry source . get key ( ) ) ; if ( target bi == null ) { keys missing on target . add ( entry source . get key ( ) ) ; } else if ( ! target bi . equals ( source bi ) ) { keys different on target . add ( entry source . get key ( ) ) ; } }	Build the RegionSyncReport the given.
private static boolean must insert ( int next idx , long [ ] value time stamps , long ts at insert point ) { return ( next idx < value time stamps . length ) && ( value time stamps [ next idx ] <= ts at insert point ) ; }	Return true if the current ts must be inserted instead of being mapped tothe tsAtInsertPoint.
public void close ( ) throws io { if ( ! this . closed ) { this . closed = bool ; this . is . close ( ) ; this . data in . close ( ) ; this . is = null ; this . data in = null ; int type count = num ; if ( this . resource type table != null ) {	Closes the archive.
public static void to cvs files ( file directory ) throws io { set < file > stats files = io . list file recursive ( directory , str ) ; if ( stats files == null || stats files . is empty ( ) ) return ; for ( file archive file : stats files ) { gf stats reader reader = new gf stats reader ( archive file . get absolute path ( ) ) ; reader . dump csv files ( ) ; } }	Finds and converts all statistics files in a given directory to CSV.
public static void main ( string [ ] args ) { file archive file , csv file ; if ( args . length < num ) { system . err . println ( str + gf stats reader . class . get name ( ) + str ) ; return ; } try { archive file = paths . get ( args [ num ] ) . to file ( ) ; if ( archive file . is directory ( ) ) { to cvs files ( archive file ) ; return ; } if ( args . length < num ) { gf stats reader reader = new gf stats reader ( archive file . get absolute path ( ) ) ; reader . dump csv files ( ) ; return ; } string type name = args [ num ] ; csv file = paths . get ( args [ num ] ) . to file ( ) ; generic csv stats visitor visitor = null ; if ( args . length > num ) { string [ ] state names = arrays . copy of range ( args , num , args . length - num ) ; visitor = new generic csv stats visitor ( csv file , type name , state names ) ; } else visitor = new generic csv stats visitor ( csv file , type name ) ; system . out . println ( str ) ; gf stats reader reader = new gf stats reader ( archive file . get absolute path ( ) ) ; reader . accept ( visitor ) ; } catch ( io e ) {	Main method to extract GF Stats to file.
public synchronized static jmx reconnect ( ) { try { client cache cache = null ; cache = client cache factory . get any instance ( ) ; if ( cache != null && ! cache . is closed ( ) ) { cache . close ( ) ; } } catch ( exception e ) { system . out . println ( str ) ; } if ( jmx != null ) { jmx . dispose ( ) ; jmx = null ; } return get jmx ( ) ; }	Close and recreate the JMX connect.
public static int stop members on host ( string host name ) { jmx jmx = singleton gem fire jmx . get jmx ( ) ; string object name pattern = str ; query exp query exp = null ; value exp [ ] values = null ;	Stops all cache servers followed by locators on a given server.
public static void shut down member ( string name ) { try { object name server name = new object name ( str + name ) ; jmx jmx = singleton gem fire jmx . get jmx ( ) ; mx bean = jmx . new bean ( mx . class , server name ) ; bean . shut down member ( ) ;	Shut down a given member by its name.
public static string [ ] shut down ( jmx jmx ) { try { mx bean = to distribute system ( jmx ) ; return bean . shut down all members ( ) ; } catch ( exception e ) { throw new runtime exception ( str + e . get message ( ) , e ) ; } }	Does not stop locators.
public static void shut down redundancy zone ( string redundancy zone ) { if ( redundancy zone == null || redundancy zone . length ( ) == num ) throw new illegal argument exception ( str ) ; string object name pattern = str ; query exp exp = query . eq ( query . attr ( str ) , query . value ( redundancy zone ) ) ; collection < object name > member object names = singleton gem fire jmx . get jmx ( ) . search object names ( object name pattern , exp ) ; for ( object name object name : member object names ) { gem fire mgmt . shut down member ( object name . get key property ( str ) ) ; } }	Shut down each member in a given RedundancyZone.
@ suppress warnings ( { str , str } ) public < k , v > list < string > store pagination map ( string id , int page size , region < string , collection < k > > page keys region , list < map . entry < k , v > > results ) { if ( results == null || results . is empty ( ) ) return null ;	Store the pagination search result details.
public < k , v > map < k , v > read results by page ( text page criteria criteria , int page number , region < k , v > region , region < string , collection < ? > > page region ) { if ( page region == null ) return null ; collection < ? > region keys = page region . get ( criteria . to page key ( page number ) ) ; if ( region keys == null || region keys . is empty ( ) ) return null ; return region . get all ( region keys ) ; }	Read Results from region by keys in pageRegion.
private boolean import region ( region < object , object > region ) throws exception { file file = data ops secretary . determine file ( export file type . gfd , region . get name ( ) ) ; if ( ! file . exists ( ) ) return bool ; region . get snapshot service ( ) . load ( file , snapshot format . gemfire ) ; return bool ; }	Import exported data from a given.
public static boolean check remote locators and locators match ( string remote locators , string locators ) { if ( remote locators == null || remote locators . length ( ) == num ) return bool ; if ( remote locators . equals ignore case ( locators ) ) return bool ; string [ ] remote locators array = remote locators . split ( str ) ; if ( locators == null || locators . length ( ) == num ) return bool ; string [ ] locators array = locators . split ( str ) ; string remote locator host , locator host ; int remote locator port , locator port ; for ( string remote locator : remote locators array ) { if ( remote locator == null || remote locator . length ( ) == num ) continue ;	Parse the remote locators and locator and assert that they match.
@ override public void execute ( function context < object > function context ) { try { string [ ] args = ( string [ ] ) function context . get arguments ( ) ; if ( args == null || args . length == num ) throw new illegal argument exception ( str ) ; string region name = args [ num ] ; if ( region name == null || region name . length ( ) == num ) throw new illegal argument exception ( str ) ; region < serializable , object > region = cache factory . get any instance ( ) . get region ( region name ) ; if ( region == null ) throw new illegal argument exception ( str + region name + str ) ; function context . get result sender ( ) . last result ( build check sum map ( region ) ) ; } catch ( exception e ) { string stack = debugger . stack trace ( e ) ; log manager . get logger ( get class ( ) ) . error ( stack ) ; throw new function exception ( stack ) ; } }	This function gets HashMap key=Serializable value=BigInteger.
hash map < serializable , big integer > build check sum map ( region < serializable , object > region ) { if ( region . get attributes ( ) . get data policy ( ) . with partitioning ( ) ) { region = partition region helper . get local data ( region ) ; } set < serializable > key set = region . key set ( ) ; if ( key set == null || key set . is empty ( ) ) return null ; hash map < serializable , big integer > region check sum map = new hash map < serializable , big integer > ( key set . size ( ) ) ; object object = null ; object tmp = null ; for ( map . entry < serializable , object > entry : region . entry set ( ) ) { object = entry . get value ( ) ; if ( pdx instance . class . is assignable from ( object . get class ( ) ) ) { tmp = ( ( pdx instance ) object ) . get object ( ) ; if ( serializable . class . is assignable from ( tmp . get class ( ) ) ) { object = tmp ; }	Build check sum map.
private object value of ( string column name , object value ) { java . lang . reflect . field field ; try { field = table object . get declared field ( column name ) ; } catch ( no such field exception e ) { throw new runtime exception ( string . format ( str , column name , table object ) ) ; } return field . get type ( ) == string . class ? string . format ( str , value ) : value ; }	Forces the value to be wrapped with ' if it isEqualTo for a string field.
boolean is type of ( type mirror type mirror ) { if ( integer kinds . contains ( type mirror . get kind ( ) ) ) { return bool ; } if ( integer objects . contains ( type mirror . to string ( ) ) ) { return bool ; } return bool ; }	Checks if a TypeMirror is mapped to Sqlite Integer Type.
public static < t > byte [ ] serialize ( t object ) { try { byte array output stream byte array output stream = new byte array output stream ( ) ; object output stream object output stream = new object output stream ( byte array output stream ) ; object output stream . write object ( object ) ; return byte array output stream . to byte array ( ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	Takes an object and serializes it to a byte array.
public static < k > k deserialize ( byte [ ] bytes ) { try { byte array input stream byte array input stream = new byte array input stream ( bytes ) ; object input stream object input stream = new object input stream ( byte array input stream ) ; @ suppress warnings ( str ) final k k = ( k ) object input stream . read object ( ) ; return k ; } catch ( io e ) { throw new runtime exception ( e ) ; } catch ( class not found exception e ) { throw new runtime exception ( e ) ; } }	De-serialize a byte array back to it's original object.
@ suppress warnings ( str ) public static < t > t create instance ( class < t > clazz ) { if ( clazz . is interface ( ) ) { if ( clazz == list . class ) { return ( t ) new array list ( ) ; } else if ( clazz == map . class ) { return ( t ) new hash map ( ) ; } throw new unsupported operation exception ( str ) ; } object instantiator instantiator = objenesis . get instantiator of ( clazz ) ; return ( t ) instantiator . new instance ( ) ; }	Takes a class type and constructs it.
private void check for table id ( table object table object , element element ) {	Check if the element has the .
private void check for fields ( table object table object , element column element ) { column column annotation = column element . get annotation ( column . class ) ; if ( column annotation == null ) return ;	Check if the element has a .
private boolean check for super type ( element element , class type ) { list < ? extends type mirror > super types = type utils . direct supertypes ( element . as type ( ) ) ; for ( type mirror super type : super types ) { if ( super type . to string ( ) . equals ( type . get name ( ) ) ) { return bool ; } } return bool ; }	Checks for a supertype returns true if element has a supertype.
void brew java ( writer writer ) throws io { logger . d ( str ) ; java writer java writer = new java writer ( writer ) ; java writer . set compressing types ( bool ) ; java writer . emit single line comment ( str )	Create the java functions required for the internal class.
private void emit get id ( java writer java writer ) throws io { logger . d ( str ) ; java writer . begin method ( str , get id function , enum set . of ( public , static ) , get target class ( ) , str ) . emit statement ( str , id column . get member name ( ) ) . end method ( ) ; }	Create a way to get an id for foreign keys.
public final observable < t > to observable ( ) { if ( ! has rx java ) { throw new runtime exception ( str ) ; } return shillelagh . get observable ( table object , new cursor loader ( ) { @ override public cursor get cursor ( ) { return shillelagh . raw query ( query . to string ( ) ) ; } } ) ; }	Executes a query and returns the results wrapped in an observable.
final void check column name ( string column name ) { try { table object . get declared field ( column name ) ; } catch ( no such field exception e ) { throw new runtime exception ( string . format ( str , column name , table object ) ) ; } }	Check to ensure that the column name provided is valid.
static string value or default ( string string , string default string ) { return is blank ( string ) ? default string : string ; }	Checks if a string there, if not returns the default string.
static string capitalize ( string string ) { if ( is blank ( string ) ) { return str ; } char first = string . char at ( num ) ; if ( character . is upper case ( first ) ) { return string ; } else { return character . to upper case ( first ) + string . substring ( num ) ; } }	Capitalizes the first letter of the string passed in.
boolean is type of ( type mirror type mirror ) { if ( real kinds . contains ( type mirror . get kind ( ) ) ) { return bool ; } if ( real objects . contains ( type mirror . to string ( ) ) ) { return bool ; } return bool ; }	Checks if a TypeMirror is mapped to Sqlite Type.
public builder < t > descending ( ) { this . query . append ( str ) ; return new builder < t > ( shillelagh , table object , query ) ; }	Order the results in descending order.
public float read temperature ( ) throws io { byte [ ] encoded = files . read all bytes ( new file ( device file , str ) . to path ( ) ) ; string tmp = new string ( encoded ) ; int tmp index = tmp . index of ( str ) ; if ( tmp index < num ) { throw new io ( str ) ; } return integer . parse int ( tmp . substring ( tmp index + num ) . trim ( ) ) / num ; }	Read temperature from the sensors.
public static string get ( string type ) { final string return value = supported cursor methods . get ( type ) ; return return value != null ? return value : supported cursor methods . get ( blob ) ; }	Maps a type to the corresponding Cursor get function.
void e ( string message , object ... args ) { messenger . print message ( error , format string ( message , args ) ) ; }	Print out errors, this will stop the build from succeeding.
public static list < icon font > get icon fonts ( ) { list < icon font > list = new array list < > ( ) ; list . add ( google material design icons . get icon font ( ) ) ; list . add ( elusive . get icon font ( ) ) ; list . add ( entypo . get icon font ( ) ) ; list . add ( font awesome . get icon font ( ) ) ; list . add ( iconic . get icon font ( ) ) ; list . add ( typicons . get icon font ( ) ) ; return list ; }	Returns all icon fonts from bundle.
public static list < icon code > get icons ( ) { list < icon code > list = new array list < > ( ) ; for ( icon code icon : google material design icons . values ( ) ) { list . add ( icon ) ; } for ( icon code icon : elusive . values ( ) ) { list . add ( icon ) ; } for ( icon code icon : entypo . values ( ) ) { list . add ( icon ) ; } for ( icon code icon : font awesome . values ( ) ) { list . add ( icon ) ; } for ( icon code icon : iconic . values ( ) ) { list . add ( icon ) ; } for ( icon code icon : typicons . values ( ) ) { list . add ( icon ) ; } return list ; }	Returns all icons from bundle.
private html get background decoration ( ) {	Create background content decoration for the widget tab.
public static double raise ( final double px , final int pexponent ) { double x = px ; int exponent = pexponent ; if ( exponent < num ) return num / raise ( x , - exponent ) ; double power = num ;	Compute and return x^power.
protected void set ( final float values [ ] ) { this . m n rows = values . length ; this . m n cols = num ; this . m a values = new float [ m n rows ] [ num ] ; for ( int r = num ; r < m n rows ; ++ r ) { this . m a values [ r ] [ num ] = values [ r ] ; } }	Set this column vector from an array of values.
public static big decimal int power ( @ nonnull final big decimal px , final long pexponent , final int scale ) { big decimal x = px ; long exponent = pexponent ;	Compute x^exponent to a given scale.
public static big decimal int root ( @ nonnull final big decimal px , final long index , final int scale ) { big decimal x = px ;	Compute the integral root of x to a given scale, x &ge; 0.
private static big decimal exp taylor ( final big decimal x , final int scale ) { big decimal factorial = big decimal . one ; big decimal x power = x ; big decimal sum prev ;	Compute e^x to a given scale by the Taylor series.
public static big decimal ln ( @ nonnull final big decimal x , final int scale ) {	Compute the natural logarithm of x to a given scale, x &gt; 0.
private static big decimal ln newton ( @ nonnull final big decimal px , final int scale ) { big decimal x = px ; final int sp1 = scale + num ; final big decimal n = x ; big decimal term ;	Compute the natural logarithm of x to a given scale, x > 0.
public static big decimal arctan ( @ nonnull final big decimal x , final int scale ) {	Compute the arctangent of x to a given scale, |x| &lt; 1.
private static big decimal arctan taylor ( final big decimal x , final int scale ) { final int sp1 = scale + num ; int i = num ; boolean add flag = bool ; big decimal power = x ; big decimal sum = x ; big decimal term ;	Compute the arctangent of x to a given scale by the Taylor series, |x| < 1.
public static big decimal sqrt ( @ nonnull final big decimal x , final int scale ) {	Compute the square root of x to a given scale, x &ge; 0.
protected void print pi ( final string pi string ) { system . out . print ( str + pi string . substring ( num , num ) ) ; int index = num ; int line = num ; int group = num ; final int length = pi string . length ( ) ;	Print the string containing the digits of pi.
protected string timestamp ( final long time ) {	Return a timestamp string that contains the elapsed time period.
public void set limits ( final float r min , final float r max ) { this . m f min = r min ; this . m f max = r max ; this . m f width = ( r max - r min ) / m n ; }	Set the minimum and maximum random values.
public void put ( final float r ) {	Determine a random value's interval and count it.
public void print ( ) {	Print the counter values as a horizontal bar chart.
public complex add ( final complex z ) { return new complex ( m f real + z . real ( ) , m f imaginary + z . imaginary ( ) ) ; }	Add another complex number to this one.
public complex subtract ( final complex z ) { return new complex ( m f real - z . real ( ) , m f imaginary - z . imaginary ( ) ) ; }	Subtract another complex number from this one.
public complex multiply ( final complex z ) { return new complex ( m f real * z . real ( ) - m f imaginary * z . imaginary ( ) , m f real * z . imaginary ( ) + m f imaginary * z . real ( ) ) ; }	Multiply this complex number by another one.
public complex divide ( final complex z ) { final float denom = z . real ( ) * z . real ( ) + z . imaginary ( ) * z . imaginary ( ) ; final float qr = ( m f real * z . real ( ) + m f imaginary * z . imaginary ( ) ) / denom ; final float qi = ( m f imaginary * z . real ( ) - m f real * z . imaginary ( ) ) / denom ; return new complex ( qr , qi ) ; }	Divide this complex number by another one.
private void set ( final matrix m ) { m n rows = num ; m n cols = m . m n cols ; m a values = m . m a values ; }	Set this row vector from a matrix.
public row vector get row ( final int r ) throws matrix exception { if ( ( r < num ) || ( r >= m n rows ) ) { throw new matrix exception ( matrix exception . invalid index ) ; } final row vector rv = new row vector ( m n cols ) ; for ( int c = num ; c < m n cols ; ++ c ) { rv . m a values [ num ] [ c ] = m a values [ r ] [ c ] ; } return rv ; }	Get a row of this matrix.
public column vector get column ( final int c ) throws matrix exception { if ( ( c < num ) || ( c >= m n cols ) ) { throw new matrix exception ( matrix exception . invalid index ) ; } final column vector cv = new column vector ( m n rows ) ; for ( int r = num ; r < m n rows ; ++ r ) { cv . m a values [ r ] [ num ] = m a values [ r ] [ c ] ; } return cv ; }	Get a column of this matrix.
protected void set ( final float values [ ] [ ] ) { m n rows = values . length ; m n cols = values [ num ] . length ; m a values = values ; for ( int r = num ; r < m n rows ; ++ r ) { m n cols = math . min ( m n cols , values [ r ] . length ) ; } }	Set this matrix from a 2-d array of values.
public matrix transpose ( ) { final float tv [ ] [ ] = new float [ m n cols ] [ m n rows ] ;	Return the transpose of this matrix.
public matrix add ( final matrix m ) throws matrix exception {	Add another matrix to this matrix.
public matrix subtract ( final matrix m ) throws matrix exception {	Subtract another matrix from this matrix.
public matrix multiply ( final float k ) { final float pv [ ] [ ] = new float [ m n rows ] [ m n cols ] ;	Multiply this matrix by a constant.
public matrix multiply ( final matrix m ) throws matrix exception {	Multiply this matrix by another matrix.
public void print ( final int width , @ nonnull final print stream a ps ) { final system out align right ar = new system out align right ( a ps ) ; for ( int r = num ; r < m n rows ; ++ r ) { ar . print ( str , num ) ; ar . print ( r + num , num ) ; ar . print ( str , num ) ; for ( int c = num ; c < m n cols ; ++ c ) { ar . print ( m a values [ r ] [ c ] , width ) ; } ar . println ( ) ; } }	Print the matrix values.
public void set resource ( image resource image resource ) { image img = new image ( image resource ) ; dom . insert child ( get element ( ) , img . get element ( ) , num ) ; }	Attach an ImageResource to the button.
private void validate coefficients ( ) { if ( m b coefs valid ) return ; if ( m n data points >= num ) { final float x bar = ( float ) m d sum x / m n data points ; final float y bar = ( float ) m d sum y / m n data points ; m f a1 = ( float ) ( ( m n data points * m d sum xy - m d sum x * m d sum y ) / ( m n data points * m d sum xx - m d sum x * m d sum x ) ) ; m f a0 = y bar - m f a1 * x bar ; } else { m f a0 = m f a1 = float . n ; } m b coefs valid = bool ; }	Validate the coefficients.
@ override protected void compute next position ( ) { m f prev xn = m f xn ; m f xn = m f gn ; m f gn = m a function . at ( m f xn ) ; }	Compute the next position of xn.
public void clear ( ) { raw sld = new raw sld ( ) ; dirty = bool ; valid = bool ; template = null ; sld descriptor = null ; }	Does not clear templateNames.
public raw sld to xml ( styled layer descriptor info sldi ) throws sld exception { try { if ( sldi . get version ( ) == null ) { sldi . set version ( str ) ; } return parse sld i ( sldi ) ; } catch ( bx e ) { throw new sld exception ( str , e ) ; } }	Convert StyledLayerDescriptorInfo to raw xml.
public styled layer descriptor info to sld i ( raw sld sld ) throws sld exception { try { return parse xml ( sld . get name ( ) , sld . get xml ( ) ) ; } catch ( bx e ) { throw new sld exception ( str , e ) ; } }	Convert raw xml to StyledLayerDescriptorInfo.
public void validate ( styled layer descriptor info sld ) throws sld exception { try { parse sld i ( sld ) ; } catch ( bx e ) { throw new sld exception ( str , e ) ; } }	Test by marshalling.
public boolean validate ( raw sld sld ) throws sld exception { try { parse xml ( str , sld . get xml ( ) ) ; return bool ; } catch ( bx e ) { return bool ; } }	Test by unmarshalling.
private float area of ( final float x1 , final float h ) { final float x2 = x1 + h ;	Compute the area of the ith trapezoidal region.
private void set ( final matrix m ) { this . m n rows = this . m n cols = math . min ( m . m n rows , m . m n cols ) ; this . m a values = m . m a values ; }	Set this square matrix from another matrix.
@ override protected void set ( final float values [ ] [ ] ) { super . set ( values ) ; m n rows = m n cols = math . min ( m n rows , m n cols ) ; }	Set this square matrix from a 2-d array of values.
public invertible matrix inverse ( ) throws matrix exception { final invertible matrix inverse = new invertible matrix ( m n rows ) ; final identity matrix identity = new identity matrix ( m n rows ) ;	Compute the inverse of this matrix.
public float determinant ( ) throws matrix exception { decompose ( ) ;	Compute the determinant.
public float norm ( ) { float sum = num ; for ( int r = num ; r < m n rows ; ++ r ) { for ( int c = num ; c < m n cols ; ++ c ) { final float v = m a values [ r ] [ c ] ; sum += v * v ; } } return ( float ) math . sqrt ( sum ) ; }	Compute the Euclidean norm of this matrix.
public column vector solve ( final column vector b , final boolean improve ) throws matrix exception {	Solve Ax = b for x using the Gaussian elimination algorithm.
public void print decomposed ( final int width , @ nonnull final print stream a ps ) throws matrix exception { decompose ( ) ; final system out align right ar = new system out align right ( a ps ) ; for ( int r = num ; r < m n rows ; ++ r ) { final int pr = m a permutation [ r ] ;	Print the decomposed matrix LU.
private void forward elimination ( final float scales [ ] ) throws matrix exception {	Do forward elimination with scaled partial row pivoting.
private column vector forward substitution ( final column vector b ) throws matrix exception { final column vector y = new column vector ( m n rows ) ;	Solve Ly = b for y by forward substitution.
private column vector back substitution ( final column vector y ) throws matrix exception { final column vector x = new column vector ( m n rows ) ;	Solve Ux = y for x by back substitution.
private void improve ( final column vector b , final column vector x ) throws matrix exception {	Iteratively improve the solution x to machine accuracy.
public static void convert ( final square matrix sm ) { for ( int r = num ; r < sm . m n rows ; ++ r ) { for ( int c = num ; c < sm . m n cols ; ++ c ) { sm . m a values [ r ] [ c ] = ( r == c ) ? num : num ; } } }	Convert a square matrix into an identity matrix.
public float next von neumann ( ) { int n ; int k = num ; float u1 ;	Compute the next randomn value using the von Neumann algorithm.
@ override protected void do iteration procedure ( final int n ) { if ( n == num ) return ;	Do the regula falsi iteration procedure.
@ override protected void compute next position ( ) { m f prev x = m f x ; m f x = m f x - m f pos * ( m f x - m f x ) / ( m f neg - m f pos ) ; m f false = m a function . at ( m f x ) ; }	Compute the next position of x-false.
@ override protected void check position ( ) throws abstract root finder . position unchanged exception { if ( equals helper . equals ( m f x , m f prev x ) ) { throw new abstract root finder . position unchanged exception ( ) ; } }	Check the position of x-false.
@ override protected void compute next position ( ) { m f prev x = m f x ; m f prev f = m f false ; m f x = m f x - m f pos * ( m f x - m f x ) / ( m f neg - m f pos ) ; m f false = m a function . at ( m f x ) ; m b decrease pos = m b decrease neg = bool ;	Compute the next position of xFalse.
public void check interval ( final float x1 , final float x2 ) throws invalid interval exception { final float y1 = m a function . at ( x1 ) ; final float y2 = m a function . at ( x2 ) ;	Check the interval.
public void add ( final float addend ) {	Add the value of an addend to the running sum.
public static int multiply ( final int pa , final int pb , final int m ) { int a = pa ; int b = pb ; int product = num ;	Multiply two integer values a and b modulo m.
public static int raise ( final int pbase , final int pexponent , final int m ) { int base = pbase ; int exponent = pexponent ; int power = num ;	Raise a to the b power modulo m.
@ override protected void do iteration procedure ( final int n ) { if ( n == num ) return ;	Do the secant iteration procedure.
public sld manager get sld manager ( ) { if ( sld manager == null ) { sld manager = new sld manager impl ( get event bus ( ) , get sld editor service factory ( ) . create sld gwt service async ( ) ) ; } return sld manager ; }	Create an instance of the SldManager.
private static char [ ] to char bit array ( final long pvalue , final int size ) { long value = pvalue ; final char bits [ ] = new char [ size ] ;	Convert a long value into a character array of '0' and '1' that representsthe value in base 2.
private void decompose ( final char [ ] bits , final int bias , final int reserved , final int sign index , final int sign size , final int exponent index , final int exponent size , final int fraction index , final int fraction size ) { this . m n bias = bias ;	Decompose a floating-point value into its parts.
public void print ( @ nonnull final print stream a pw ) { a pw . println ( str ) ;	Print the decomposed parts of the value.
public static void validate float biased exponent ( final int biased ) throws iee { if ( ( biased < num ) || ( biased > iee . float exponent reserved ) ) { throw new iee ( str + str + iee . float exponent reserved + str ) ; } }	Validate the value of the float biased exponent value.
public static void validate float unbiased exponent ( final int unbiased ) throws iee { if ( ( unbiased < - iee . float exponent bias + num ) || ( unbiased > iee . float exponent bias ) ) { throw new iee ( str + - ( iee . float exponent bias - num ) + str + iee . float exponent bias + str ) ; } }	Validate the value of the float unbiased exponent value.
public static void validate double biased exponent ( final int biased ) throws iee { if ( ( biased < num ) || ( biased > iee . double exponent reserved ) ) { throw new iee ( str + str + iee . double exponent reserved + str ) ; } }	Validate the value of the double biased exponent value.
public static void validate double unbiased exponent ( final int unbiased ) throws iee { if ( ( unbiased < - iee . double exponent bias + num ) || ( unbiased > iee . double exponent bias ) ) { throw new iee ( str + - ( iee . double exponent bias - num ) + str + iee . double exponent bias + str ) ; } }	Validate the value of the double unbiased exponent value.
public float next central ( ) {	Compute the next random value using the Central Limit Theorem, which statesthat the averages of sets of uniformly-distributed random values arenormally distributed.
public float next polar ( ) {	Compute the next randomn value using the polar algorithm.
public float next ratio ( ) { float u , v , x , xx ; do {	Compute the next random value using the ratio algorithm.
public static boolean [ ] prime sieve ( final int n ) { final int half n = ( n + num ) > > num ; final boolean sieve [ ] = new boolean [ n + num ] ;	Compute the Sieve of Eratosthenes.
public static int [ ] factors of ( final int pn ) { int n = pn ; final boolean is prime [ ] = prime sieve ( n ) ;	Compute the prime factors of an integer value.
@ override protected void do iteration procedure ( final int n ) { if ( n == num ) return ;	Do the bisection iteration procedure.
@ override protected void compute next position ( ) { m f prev x = m f x ; m f x = ( m f x + m f x ) / num ; m f mid = m a function . at ( m f x ) ; }	Compute the next position of xMid.
@ override protected void check position ( ) throws abstract root finder . position unchanged exception { if ( equals helper . equals ( m f x , m f prev x ) ) { throw new abstract root finder . position unchanged exception ( ) ; } }	Check the position of xMid.
public static void set java fx application ( final cdi application java fx application ) { final count down latch latch = new count down latch ( num ) ; platform . run later ( ( ) -> { java fx application . set ( java fx application ) ; latch . count down ( ) ; } ) ; if ( ! platform . is fx application thread ( ) ) { try { latch . await ( ) ; } catch ( interrupted exception e ) { throw new illegal state exception ( e ) ; } } }	Sets the JavaFX application instance to be provided by the CDI BeanManager.
public void set configuration ( file config file ) { if ( config file == null ) next config = null ; else try { x config = new x ( str , bool ) ; next config = config . get processor ( ) . new document builder ( ) . build ( new sax ( new input source ( new file reader ( config file ) ) ) ) ; } catch ( file not found exception e ) { throw new illegal argument exception ( str , e ) ; } catch ( saxon api exception e ) { throw new runtime exception ( e ) ; } }	Settings from a custom calabash.xml.
public void set default configuration ( reader default config ) { x config = new x ( str , bool ) ; try { next default config = config . get processor ( ) . new document builder ( ) . build ( new sax ( new input source ( default config ) ) ) ; } catch ( saxon api exception e ) { throw new runtime exception ( e ) ; } }	Settings to be always applied.
static void initialize fxml ( final fxml fxml loader , final class < ? > target class , final string location , final string resources , final string charset ) { check and set location ( fxml loader , target class , location ) ; if ( charset != null && ! charset . equals ( charset unspecified ) ) { fxml loader . set charset ( charset . for name ( charset ) ) ; } if ( resources != null && ! resources . equals ( resources unspecified ) ) { fxml loader . set resources ( resource bundle . get bundle ( resources ) ) ; } }	Initializes the given FXMLLoader instance using the provided parameters.
public reverse geocode request builder latlng ( double lat , double lng ) { parameters . put ( str , lat + str + lng ) ; return this ; }	The location latitude and longitude.This parameter is required.
public static inet socket address get host port pair ( service svc ) { try { return new inet socket address ( svc . get metadata ( ) . get ( str ) , integer . parse int ( svc . get metadata ( ) . get ( str ) ) ) ; } catch ( exception e ) { logger . error ( str , svc , e ) ; return null ; } }	Safely get the information from our convention.
protected attribute definition get applicable attribute definition ( final uuid attribute definition uuid , final list < attribute definition > attribute definitions ) { if ( log . is trace enabled ( ) ) { log . entry ( attribute definition uuid , attribute definitions ) ; } attribute definition attribute definition = null ; for ( attribute definition an attribute definition : attribute definitions ) { if ( an attribute definition . get uuid ( ) . equals ( attribute definition uuid ) ) { attribute definition = an attribute definition ; break ; } } if ( log . is trace enabled ( ) ) { log . exit ( attribute definition ) ; } return attribute definition ; }	Find an attribute definition that applies to a particular attribute filter.
protected boolean evaluate ( final uuid attribute definition uuid , final attribute filter expression attribute filter , final map < uuid , string > event attributes , final list < attribute definition > attribute definitions ) throws parse exception { if ( log . is trace enabled ( ) ) { log . entry ( attribute definition uuid , attribute filter , event attributes , attribute definitions ) ; }	Evaluate single attribute filter.
public static string sanitize tag ( string s ) {	1..55 chars. anything goes.
public geocode request builder address ( string address ) { parameters . put ( str , address != null ? address . replace ( str , str ) : address ) ; return this ; }	The address that you want to geocode.
public collection < string > query for names ( ) throws exception { set < string > names = new hash set < string > ( ) ;	return all distinct names registered by this discovery type.
public collection < service instance < t > > query for instances ( string name ) throws exception { list < service instance < t > > service instances = new array list < service instance < t > > ( ) ; iterator < service > services = client . get services client ( ) . list ( new method options ( num , null ) ) ; while ( services . has next ( ) ) { service service = services . next ( ) ; if ( service . get tags ( ) . contains ( type tag ) && service . get metadata ( ) . get ( service tracker . name ) . equals ( name ) ) {	return all instances registered to this particular name for this discovery type.
public list < collaboration > get all to by logged in ( ) { collaboration listing collaboration listing = new collaboration listing ( ) ; if ( this . service ticket != null ) { collaboration listing . set service ticket ( this . service ticket ) ; } return new collaboration listing ( this . post json ( collaboration listing , ws . path . collaboration . version1 . get all to by logged in ( ) ) ) . get listing ( ) ; }	Retrieve all Collaboration items TO where logged in user.
protected string get meta data for decimal as ( string meta data prefix param , double min param , double max param , double step factor param , string prefix param ) { string buffer return buffer = new string buffer ( ) ; if ( meta data prefix param != null && ! meta data prefix param . is empty ( ) ) { return buffer . append ( meta data prefix param ) ; }	Construct the correct Meta-Data from parameters.
public user change password for logged in user ( string existing password param , string new password param , string confirm new password param ) { user to change password for = new user ( ) ; if ( this . service ticket != null ) { to change password for . set service ticket ( this . service ticket ) ; } string existing password = existing password param == null ? util global . empty : existing password param ; string new password = new password param == null ? util global . empty : new password param ; string confirm new password = confirm new password param == null ? util global . empty : confirm new password param ; json password clear = new json ( ) ; password clear . put ( str , existing password ) ; password clear . put ( str , new password ) ; password clear . put ( str , confirm new password ) ; to change password for . set password clear ( password clear . to string ( ) ) ; return new user ( this . post json ( to change password for , ws . path . user . version1 . change password ( ) ) ) ; }	Change the password for the currently logged in user.
public user listing get all users ( ) { user listing user to get info for = new user listing ( ) ; if ( this . service ticket != null ) { user to get info for . set service ticket ( this . service ticket ) ; } try { return new user listing ( this . post json ( user to get info for , ws . path . user . version1 . get all users ( ) ) ) ; }	Retrieves all user information.
public byte [ ] get gravatar for email ( string email address param , int size param ) { try { json gravatar json = this . get json ( ws . path . user . version1 . get gravatar by email ( email address param , size param ) ) ; string base64 text = gravatar json . opt string ( json tag data , str ) ; if ( base64 text == null || base64 text . is empty ( ) ) { return null ; } return util global . decode base64 ( base64 text ) ; }	Retrieve the gravatar bytes by email.
public byte [ ] get gravatar for user ( user user param , int size param ) { if ( user param == null ) { return null ; } try { json gravatar json = this . post json ( user param , ws . path . user . version1 . get gravatar by user ( size param ) ) ; string base64 text = gravatar json . opt string ( json tag data , str ) ; if ( base64 text == null || base64 text . is empty ( ) ) { return null ; } return util global . decode base64 ( base64 text ) ; }	Retrieve the gravatar bytes for Fluid user.
@ override @ xml transient public void populate from elastic search json ( json json object param , list < field > form fields param ) throws json { throw new fluid elastic search exception ( str ) ; }	Not allowed to call this method.
@ xml transient public string get elastic search field type ( ) { type field type = this . get type as enum ( ) ; if ( field type == null ) { return null ; }	Returns the ElasticSearch equivalent data field-type from the Fluid datatype.
public flow step create flow step ( flow step flow step param ) { if ( flow step param != null && this . service ticket != null ) { flow step param . set service ticket ( this . service ticket ) ; } return new flow step ( this . put json ( flow step param , ws . path . flow step . version1 . flow step create ( ) ) ) ; }	Creates a new Flow Step.
public flow step update flow step ( flow step flow step param ) { if ( flow step param != null && this . service ticket != null ) { flow step param . set service ticket ( this . service ticket ) ; } return new flow step ( this . post json ( flow step param , ws . path . flow step . version1 . flow step update ( ) ) ) ; }	Updates an existing Flow Step.
public flow step get flow step by id ( long flow step id param , string flow step type param ) { flow step flow step = new flow step ( flow step id param ) ; flow step . set flow step type ( flow step type param ) ; if ( this . service ticket != null ) { flow step . set service ticket ( this . service ticket ) ; } return new flow step ( this . post json ( flow step , ws . path . flow step . version1 . get by id ( ) ) ) ; }	Retrieves an existing Flow Step via Primary key.
public flow step get flow step by step ( flow step flow step param ) { if ( this . service ticket != null && flow step param != null ) { flow step param . set service ticket ( this . service ticket ) ; } return new flow step ( this . post json ( flow step param , ws . path . flow step . version1 . get by step ( ) ) ) ; }	Retrieves an existing Flow Step via Step.Lookup will include id, then;Name.
public flow step listing get steps by flow ( flow flow param ) { if ( this . service ticket != null && flow param != null ) { flow param . set service ticket ( this . service ticket ) ; } return new flow step listing ( this . post json ( flow param , ws . path . flow step . version1 . get all steps by flow ( ) ) ) ; }	Retrieves all Steps via Flow.
public flow step delete flow step ( flow step flow step param ) { if ( flow step param != null && this . service ticket != null ) { flow step param . set service ticket ( this . service ticket ) ; } return new flow step ( this . post json ( flow step param , ws . path . flow step . version1 . flow step delete ( ) ) ) ; }	Delete an existing Flow Step.
public flow step force delete flow step ( flow step flow step param ) { if ( flow step param != null && this . service ticket != null ) { flow step param . set service ticket ( this . service ticket ) ; } return new flow step ( this . post json ( flow step param , ws . path . flow step . version1 . flow step delete ( bool ) ) ) ; }	Forcefully delete an existing Flow Step.Only 'admin' can forcefully delete a step.
protected final list < form > populate table fields ( boolean add all table records for return param , boolean include field data param , list < field > form fields param ) { if ( form fields param == null || form fields param . is empty ( ) ) { return null ; } list < form > all table records from all fields = add all table records for return param ? new array list ( ) : null ;	Populate all the Table Field values from the Table index.
@ override public void close connection ( ) { close connection runnable close connection runnable = new close connection runnable ( this ) ; thread close conn thread = new thread ( close connection runnable , str ) ; close conn thread . start ( ) ; }	Close the SQL and ElasticSearch Connection.
@ override public void handle message ( object object to process ) {	'Handles' the message.If there was an error, the object will be ErrorIf there was no error, the object will be JSONObject.
@ override public void connection closed ( ) { this . is connection closed = bool ; if ( this . completable future != null ) {	Event for when connection is closed.
private list < string > get echo messages from return value ( ) { list < string > return listing = new array list ( ) ; if ( this . return value == null ) { return return listing ; } iterator < t > iter for return val = this . return value . iterator ( ) ;	Gets a list of echo messages of the current return values.
public list < fluid item > get personal inventory items ( ) { user logged in user = new user ( ) ; if ( this . service ticket != null ) { logged in user . set service ticket ( this . service ticket ) ; } try { return new fluid item listing ( this . post json ( logged in user , ws . path . personal inventory . version1 . get all by logged in user ( ) ) ) . get listing ( ) ; }	Retrieves all Personal Inventory items for the logged in user.
public table record create table record ( table record table record param ) { if ( table record param != null && this . service ticket != null ) { table record param . set service ticket ( this . service ticket ) ; } return new table record ( this . put json ( table record param , ws . path . form container table record . version1 . form container table record create ( ) ) ) ; }	Create a new Table Record.
public form delete form container ( form form container param ) { if ( form container param != null && this . service ticket != null ) { form container param . set service ticket ( this . service ticket ) ; } return new form ( this . post json ( form container param , ws . path . form container . version1 . form container delete ( ) ) ) ; }	Deletes the Form Container provided.Id must be set on the Form Container.
public list < form flow historic data > get form flow historic data ( form form param ) { if ( form param != null && this . service ticket != null ) { form param . set service ticket ( this . service ticket ) ; } return new form flow historic data listing ( this . post json ( form param , ws . path . flow item history . version1 . get by form container ( ) ) ) . get listing ( ) ; }	Retrieves Electronic Form Workflow historic information.The Form Id must be provided.
public list < form historic data > get form and field historic data ( form form param , boolean include current param ) { if ( form param != null && this . service ticket != null ) { form param . set service ticket ( this . service ticket ) ; } return new form historic data listing ( this . post json ( form param , ws . path . form history . version1 . get by form container ( include current param ) ) ) . get listing ( ) ; }	Retrieves Electronic Form and Field historic information.The Form Id must be provided.
public form historic data get most recent form and field historic data ( form form param ) { if ( form param != null && this . service ticket != null ) { form param . set service ticket ( this . service ticket ) ; } return new form historic data ( this . post json ( form param , ws . path . form history . version1 . get by most recent by form container ( ) ) ) ; }	Retrieves Electronic Form and Field historic information forthe most recent modification.The Form Id must be provided.
public form lock form container ( form form param , job view job view param ) { return this . lock form container ( form param , job view param , null ) ; }	Lock the provided form container for logged in user.
public form un lock form container ( form form param , boolean unlock async param ) { return this . un lock form container ( form param , null , unlock async param , bool ) ; }	Unlock the provided form container from the logged in user.Item will not be removed from users Personal Inventory.
public form un lock form container ( form form param , user user to un lock as param , boolean unlock async param , boolean remove from personal inventory param ) { if ( this . service ticket != null && form param != null ) { form param . set service ticket ( this . service ticket ) ; } long un lock as user id = ( user to un lock as param == null ) ? null : user to un lock as param . get id ( ) ; try { return new form ( this . post json ( form param , ws . path . form container . version1 . un lock form container ( un lock as user id , unlock async param , remove from personal inventory param ) ) ) ; }	Unlock the provided form container from the logged in user.
private form map form container to ( map < long , string > definition and title param , result set result set param ) throws sql { long form id = result set param . get long ( sql . 01 form id ) ; string form type = definition and title param . get ( result set param . get long ( sql . 02 form type ) ) ; string title = result set param . get string ( sql . 03 title ) ; date created = result set param . get date ( sql . 04 created ) ; date last updated = result set param . get date ( sql . 05 last updated ) ; long current user id = result set param . get long ( sql . 06 current user id ) ; if ( form type == null ) { throw new sql ( str + result set param . get long ( sql . 02 form type ) + str ) ; } form to add = new form ( form type ) ; to add . set id ( form id ) ; to add . set title ( title ) ;	Maps the Form to the provided Definition-Id and Title.
@ xml transient public static list < role > convert to objects ( string role listing param ) { if ( role listing param == null || role listing param . trim ( ) . is empty ( ) ) { return null ; } string [ ] list of roles = role listing param . split ( util global . reg ex comma ) ; list < role > return val = new array list < > ( ) ; for ( string role name : list of roles ) { role role to add = new role ( ) ; role to add . set name ( role name . trim ( ) ) ; return val . add ( role to add ) ; } return return val ; }	Convert the comma separated list of roles as objects.
public form create form definition ( form form definition param ) { if ( form definition param != null && this . service ticket != null ) { form definition param . set service ticket ( this . service ticket ) ; } return new form ( this . put json ( form definition param , ws . path . form definition . version1 . form definition create ( ) ) ) ; }	Creates a new Form Definition with the Fields inside the definition.
public form update form definition ( form form definition param ) { if ( form definition param != null && this . service ticket != null ) { form definition param . set service ticket ( this . service ticket ) ; } return new form ( this . post json ( form definition param , ws . path . form definition . version1 . form definition update ( ) ) ) ; }	Updates an existing Form Definition with the Fields inside the definition.
public form get form definition by id ( long form definition id param ) { form form = new form ( form definition id param ) ; if ( this . service ticket != null ) { form . set service ticket ( this . service ticket ) ; } return new form ( this . post json ( form , ws . path . form definition . version1 . get by id ( ) ) ) ; }	Retrieves the Form Definition by Primary key.
public form get form definition by name ( string form definition name param ) { form form = new form ( form definition name param ) ; if ( this . service ticket != null ) { form . set service ticket ( this . service ticket ) ; } return new form ( this . post json ( form , ws . path . form definition . version1 . get by name ( ) ) ) ; }	Retrieves the Form Definition by Name.
public list < form > get all by logged in user ( boolean include table record types param ) { form form = new form ( ) ; if ( this . service ticket != null ) { form . set service ticket ( this . service ticket ) ; } if ( include table record types param ) { return new form listing ( this . post json ( form , ws . path . form definition . version1 . get all by logged in user include table types ( ) ) ) . get listing ( ) ; } else { return new form listing ( this . post json ( form , ws . path . form definition . version1 . get all by logged in user ( ) ) ) . get listing ( ) ; } }	Retrieves all Form Definitions by logged in user.
public form delete form definition ( form form definition param ) { if ( form definition param != null && this . service ticket != null ) { form definition param . set service ticket ( this . service ticket ) ; } return new form ( this . post json ( form definition param , ws . path . form definition . version1 . form definition delete ( ) ) ) ; }	Deletes the Form Definition provided.Id must be set on the Form Definition.
private string get storage key from ( long form def id param , long form cont id param , long form field id param ) { string builder string buff = new string builder ( ) ;	Generates the storage key the provided parameters.
private memcached client init x ( ) { if ( this . memcached client != null && ! this . memcached client . is shutdown ( ) ) { return this . memcached client ; } try { this . memcached client = new x ( this . cache host , this . cache port ) ; return this . memcached client ; }	Creates an instance of MemcachedClient.
public void shutdown ( ) { if ( this . memcached client != null && ! this . memcached client . is shutdown ( ) ) { try { this . memcached client . shutdown ( ) ; }	Closes the Memcached client connection.
protected long to long safe ( string to parse param ) { if ( to parse param == null || to parse param . trim ( ) . is empty ( ) ) { return - num ; } try { return long . parse long ( to parse param . trim ( ) ) ; } catch ( number format exception e ) { return - num ; } }	Returns -1 if there is a problem with conversion.
public file convert document to pdf ( file input document param ) { if ( input document param == null || ! input document param . exists ( ) ) { throw new util exception ( str , util exception . error code . command ) ; } if ( ! input document param . is file ( ) ) { throw new util exception ( str , util exception . error code . command ) ; } file parent folder = input document param . get parent file ( ) ; string input filename without ext = input document param . get name ( ) ; int index of dot = - num ; if ( ( index of dot = input filename without ext . index of ( str ) ) > - num ) { input filename without ext = input filename without ext . substring ( num , index of dot ) ; } file generated pdf file out = new file ( parent folder . get absolute path ( ) . concat ( file . separator ) . concat ( input filename without ext ) . concat ( str ) ) ; string complete output path = generated pdf file out . get absolute path ( ) ; try { command util . command result command result = this . command util . execute command ( command util . fluid cli , command convert doc to pdf , str , input document param . get absolute path ( ) , str , complete output path ) ;	Makes use of the Fluid Core to convert a document into a PDF file.
private list < field > get field values for form from cache ( long form id param , list < form field listing > listing return field vals populated param , form [ ] forms to fetch for local cache arr param ) { if ( form id param == null || form id param . long value ( ) < num ) { return null ; } if ( listing return field vals populated param == null || listing return field vals populated param . is empty ( ) ) { return null ; } if ( forms to fetch for local cache arr param == null || forms to fetch for local cache arr param . length == num ) { return null ; } for ( form form iter : forms to fetch for local cache arr param ) {	Populate the field values from the cache.
public flow step rule create flow step entry rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . put json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule entry create ( ) ) ) ; }	Create a new Flow Step Entry rule.
public flow step rule create flow step exit rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . put json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule exit create ( ) ) ) ; }	Create a new Flow Step Exit rule.
public flow step rule create flow step view rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . put json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule view create ( ) ) ) ; }	Create a new Flow Step View rule.
public flow step rule update flow step entry rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . post json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule update entry ( ) ) ) ; }	Update an existing Flow Step Entry rule.
public flow step rule update flow step exit rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . post json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule update exit ( ) ) ) ; }	Update an existing Flow Step Exit rule.
public flow step rule update flow step view rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . post json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule update view ( ) ) ) ; }	Update an existing Flow Step View rule.
public flow step rule move flow step entry rule up ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . post json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule move entry up ( ) ) ) ; }	Moves an entry rule order one up from the current location.
public flow step rule move flow step entry rule down ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . post json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule move entry down ( ) ) ) ; }	Moves an entry rule order one down from the current location.
public flow step rule delete flow step entry rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step rule ( this . post json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule delete entry ( ) ) ) ; }	Deletes an Step Entry rule.
public flow step delete flow step exit rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step ( this . post json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule delete exit ( ) ) ) ; }	Deletes an Step Exit rule.
public flow step delete flow step view rule ( flow step rule flow step rule param ) { if ( flow step rule param != null && this . service ticket != null ) { flow step rule param . set service ticket ( this . service ticket ) ; } return new flow step ( this . post json ( flow step rule param , ws . path . flow step rule . version1 . flow step rule delete view ( ) ) ) ; }	Deletes an Step View rule.
private auth encrypted data initialize session ( string password param , auth response auth response param ) {	Performs HMAC and encryption to initialize the session.
public user query listing get all user queries ( ) { user query user query to get info for = new user query ( ) ; if ( this . service ticket != null ) { user query to get info for . set service ticket ( this . service ticket ) ; } try { return new user query listing ( this . post json ( user query to get info for , ws . path . user query . version1 . get all user queries ( ) ) ) ; }	Retrieves all user query information.
public role listing get all roles ( ) { role listing role to get info for = new role listing ( ) ; if ( this . service ticket != null ) { role to get info for . set service ticket ( this . service ticket ) ; } try { return new role listing ( this . post json ( role to get info for , ws . path . role . version1 . get all roles ( ) ) ) ; }	Retrieves all role information.
public string get service ticket as hex upper ( ) { string service ticket = this . get service ticket ( ) ; if ( service ticket == null ) { return null ; } if ( service ticket . is empty ( ) ) { return service ticket ; } byte [ ] base64 bytes = base64 . get decoder ( ) . decode ( service ticket ) ; return this . bytes to hex ( base64 bytes ) ; }	Gets the Service Ticket associated with the Fluid session as HEX.
public field create field text masked ( field form field param , string mask value param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( mask value param == null || mask value param . trim ( ) . is empty ( ) ) { mask value param = str ; } if ( form field param != null ) { form field param . set type as enum ( field . type . text ) ; form field param . set type meta data ( field meta data . text . masked . concat ( mask value param ) ) ; } return new field ( this . put json ( form field param , ws . path . form field . version1 . form field create ( ) ) ) ; }	Create a new Text Masked field.
public field create field text barcode ( field form field param , string barcode type param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( barcode type param == null || barcode type param . trim ( ) . is empty ( ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . text ) ; form field param . set type meta data ( field meta data . text . barcode . concat ( barcode type param ) ) ; } return new field ( this . put json ( form field param , ws . path . form field . version1 . form field create ( ) ) ) ; }	Create a new Text Barcode field.
public field create field decimal spinner ( field form field param , double min param , double max param , double step factor param , string prefix param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . decimal ) ; form field param . set type meta data ( this . get meta data for decimal as ( field meta data . decimal . spinner , min param , max param , step factor param , prefix param ) ) ; } return new field ( this . put json ( form field param , ws . path . form field . version1 . form field create ( ) ) ) ; }	Create a new Decimal Spinner field.
public field create field decimal slider ( field form field param , double min param , double max param , double step factor param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . decimal ) ; form field param . set type meta data ( this . get meta data for decimal as ( field meta data . decimal . slider , min param , max param , step factor param , null ) ) ; } return new field ( this . put json ( form field param , ws . path . form field . version1 . form field create ( ) ) ) ; }	Create a new Decimal Slider field.
public field create field table ( field form field param , form form definition param , boolean sum decimals param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . table ) ; form field param . set type meta data ( this . get meta data for table field ( form definition param , sum decimals param ) ) ; } return new field ( this . put json ( form field param , ws . path . form field . version1 . form field create ( ) ) ) ; }	Creates a new Table Field.
public field update field text masked ( field form field param , string mask value param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( mask value param == null || mask value param . trim ( ) . is empty ( ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . text ) ; form field param . set type meta data ( field meta data . text . masked . concat ( mask value param ) ) ; } return new field ( this . post json ( form field param , ws . path . form field . version1 . form field update ( ) ) ) ; }	Update an existing Masked Text field.
public field update field text barcode ( field form field param , string barcode type param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( barcode type param == null || barcode type param . trim ( ) . is empty ( ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . text ) ; form field param . set type meta data ( field meta data . text . barcode . concat ( barcode type param ) ) ; } return new field ( this . post json ( form field param , ws . path . form field . version1 . form field update ( ) ) ) ; }	Update an existing Barcode Text field.
public field update field decimal spinner ( field form field param , double min param , double max param , double step factor param , string prefix param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . decimal ) ; form field param . set type meta data ( this . get meta data for decimal as ( field meta data . decimal . spinner , min param , max param , step factor param , prefix param ) ) ; } return new field ( this . post json ( form field param , ws . path . form field . version1 . form field update ( ) ) ) ; }	Updates the Decimal Spinner field.
public field update field decimal slider ( field form field param , double min param , double max param , double step factor param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . decimal ) ; form field param . set type meta data ( this . get meta data for decimal as ( field meta data . decimal . slider , min param , max param , step factor param , null ) ) ; } return new field ( this . post json ( form field param , ws . path . form field . version1 . form field update ( ) ) ) ; }	Updates the Decimal Slider field.
public field update field table ( field form field param , form form definition param , boolean sum decimals param ) { if ( form field param != null && this . service ticket != null ) { form field param . set service ticket ( this . service ticket ) ; } if ( form field param != null ) { form field param . set type as enum ( field . type . table ) ; form field param . set type meta data ( this . get meta data for table field ( form definition param , sum decimals param ) ) ; } return new field ( this . post json ( form field param , ws . path . form field . version1 . form field update ( ) ) ) ; }	Updates a Table Field.
public field get field by name ( string field name param ) { field field = new field ( ) ; field . set field name ( field name param ) ; if ( this . service ticket != null ) { field . set service ticket ( this . service ticket ) ; } return new field ( this . post json ( field , ws . path . form field . version1 . get by name ( ) ) ) ; }	Retrieve a Form Field via name.
public form field listing get fields by form name and logged in user ( string form name param , boolean edit only fields param ) { form form = new form ( ) ; form . set form type ( form name param ) ; if ( this . service ticket != null ) { form . set service ticket ( this . service ticket ) ; } return new form field listing ( this . post json ( form , ws . path . form field . version1 . get by form definition and logged in user ( edit only fields param ) ) ) ; }	Retrieve the Form Fields via Form Definition name.
public form field listing get fields by form type id and logged in user ( long form type id param , boolean edit only fields param ) { form form = new form ( ) ; form . set form type id ( form type id param ) ; if ( this . service ticket != null ) { form . set service ticket ( this . service ticket ) ; } return new form field listing ( this . post json ( form , ws . path . form field . version1 . get by form definition and logged in user ( edit only fields param ) ) ) ; }	Retrieve the Form Fields via Form Definition id.
public field delete field ( field field param ) { if ( field param != null && this . service ticket != null ) { field param . set service ticket ( this . service ticket ) ; } return new field ( this . post json ( field param , ws . path . form field . version1 . form field delete ( ) ) ) ; }	Deletes the provided field.Ensure that Id is set.
public field force delete field ( field field param ) { if ( field param != null && this . service ticket != null ) { field param . set service ticket ( this . service ticket ) ; } return new field ( this . post json ( field param , ws . path . form field . version1 . form field delete ( bool ) ) ) ; }	Forcefully deletes the provided field.Ensure that Id is set.Only 'admin' is able to forcefully delete a field.
private string get meta data for table field ( form form definition param , boolean sum decimals param ) { string builder return buffer = new string builder ( ) ; long definition id = ( form definition param == null ) ? - num : form definition param . get id ( ) ;	Generates the Meta Data for a table field.
public field update field value ( field user field value param ) { if ( user field value param != null && this . service ticket != null ) { user field value param . set service ticket ( this . service ticket ) ; } return new field ( this . post json ( user field value param , ws . path . user field . version1 . user field update value ( ) ) ) ; }	Update an existing User field value.
public get index response get or create index ( string index param ) { if ( this . does index exist ( index param ) ) { return this . client . admin ( ) . indices ( ) . prepare get index ( ) . get ( ) ; } else { create index request builder create index request builder = this . client . admin ( ) . indices ( ) . prepare create ( index param ) ; create index response mapping create response = create index request builder . execute ( ) . action get ( ) ; if ( ! mapping create response . is acknowledged ( ) ) { throw new fluid elastic search exception ( str + index param + str ) ; } return this . client . admin ( ) . indices ( ) . prepare get index ( ) . get ( ) ; } }	Creates a new index or fetches existing index.
public flow create flow ( flow flow param ) { if ( flow param != null && this . service ticket != null ) { flow param . set service ticket ( this . service ticket ) ; } return new flow ( this . put json ( flow param , ws . path . flow . version1 . flow create ( ) ) ) ; }	Creates a new Flow with an Introduction and Exit basic rule.
public flow update flow ( flow flow param ) { if ( flow param != null && this . service ticket != null ) { flow param . set service ticket ( this . service ticket ) ; } return new flow ( this . post json ( flow param , ws . path . flow . version1 . flow update ( ) ) ) ; }	Updates an existing Flow.
public flow get flow by id ( long flow id param ) { flow flow = new flow ( flow id param ) ; if ( this . service ticket != null ) { flow . set service ticket ( this . service ticket ) ; } return new flow ( this . post json ( flow , ws . path . flow . version1 . get by id ( ) ) ) ; }	Retrieves a Flow by Primary Key.
public flow get flow by name ( string flow name param ) { flow flow = new flow ( ) ; flow . set name ( flow name param ) ; if ( this . service ticket != null ) { flow . set service ticket ( this . service ticket ) ; } return new flow ( this . post json ( flow , ws . path . flow . version1 . get by name ( ) ) ) ; }	Retrieves a Flow by unique Name.
public flow delete flow ( flow flow param ) { if ( flow param != null && this . service ticket != null ) { flow param . set service ticket ( this . service ticket ) ; } return new flow ( this . post json ( flow param , ws . path . flow . version1 . flow delete ( ) ) ) ; }	Delete an existing Flow.
public flow force delete flow ( flow flow param ) { if ( flow param != null && this . service ticket != null ) { flow param . set service ticket ( this . service ticket ) ; } return new flow ( this . post json ( flow param , ws . path . flow . version1 . flow delete ( bool ) ) ) ; }	Forcefully Delete an existing Flow.Only 'admin' can forcefully delete a Flow.
public field update field value ( field global field value param ) { if ( global field value param != null && this . service ticket != null ) { global field value param . set service ticket ( this . service ticket ) ; } return new field ( this . post json ( global field value param , version1 . global field update value ( ) ) ) ; }	Update an existing Global field value.
public list < field > get all global field values ( ) { field field = new field ( ) ;	Retrieve all the Global field values.
public map < long , string > get form definition id and title ( ) {	Retrieves the Form Definition and Title mappingcurrently stored in Fluid.
public static byte [ ] decrypt init packet ( byte [ ] encrypted data param , string password param , string salt param , byte [ ] iv param , byte [ ] seed param ) {	Decrypts the encrypted data.
@ override public void close and clean ( ) { close connection runnable close connection runnable = new close connection runnable ( this ) ; thread close conn thread = new thread ( close connection runnable , str ) ; close conn thread . start ( ) ; }	If the HTTP Client is set, this willclose and clean any connections that needs to be closed.
public synchronized string init new request ( ) { string return val = uuid . random uuid ( ) . to string ( ) ; this . message handler . put ( return val , this . get new handler instance ( ) ) ; return return val ; }	Initiate a new request process.Synchronized.
protected string get exception message verbose ( string prefix param , string unique req id param , int number of sent items param ) { string builder form fields combined = new string builder ( ) ; int return val size = - num ; resp handler resp handler = this . get handler ( unique req id param ) ; if ( resp handler instanceof a ) { list < ? extends a json > return value = ( ( a ) resp handler ) . get return value ( ) ; if ( return value != null ) { return val size = return value . size ( ) ; return value . for each ( listing itm -> { if ( listing itm instanceof a ) { a casted to listing = ( a ) listing itm ; if ( casted to listing != null ) { casted to listing . get listing ( ) . for each ( form itm -> { form fields combined . append ( form itm . to string ( ) ) ; } ) ; } } else { form fields combined . append ( listing itm . to string ( ) ) ; } } ) ; } } return ( prefix param + str + str + return val size + str + ( time unit . milliseconds . to seconds ( this . get timeout in millis ( ) ) ) + str + unique req id param + str + number of sent items param + str + form fields combined . to string ( ) + str ) ; }	Generate a verbose Exception message.
public user create admin user ( string password param ) { user admin user create = new user ( ) ; admin user create . set password clear ( password param ) ; return new user ( this . put json ( admin user create , ws . path . user . version1 . user create admin ( ) ) ) ; }	Create a new administrator user for Fluid.This function only works if there are no pre-existing admin user.
public access token get access token ( string client id param , string client secret param , string code param , string redirect url param ) { if ( client id param == null || client id param . trim ( ) . is empty ( ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; } if ( client secret param == null || client secret param . trim ( ) . is empty ( ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; } if ( code param == null || code param . trim ( ) . is empty ( ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; } access token request token request = new access token request ( ) ; token request . set client id ( client id param ) ; token request . set client secret ( client secret param ) ; token request . set grant type ( authorization code ) ; token request . set code ( code param ) ; token request . set redirect uri ( redirect url param ) ; return new access token ( this . post json ( bool , token request , ws . path . auth0 . version1 . user token ( ) ) ) ; }	Gets a Access Token from Auth0.
public normalized user profile get user profile info ( access token access token param ) { if ( access token param == null || ( access token param . get access token ( ) == null || access token param . get access token ( ) . trim ( ) . is empty ( ) ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; } try { string access token = access token param . get access token ( ) ; list < header name value > header listing = new array list < header name value > ( ) ; header listing . add ( new header name value ( normalized user profile . header mapping . authorization , str + access token ) ) ; return new normalized user profile ( this . get json ( bool , ws . path . auth0 . version1 . user info ( ) , header listing ) ) ; }	Gets Auth0 Normalized User Profile info.
protected json execute json ( http method http method param , list < header name value > header name values param , boolean check connection valid param , a json base domain param , content type content type param , string postfix url param ) {	Submit a JSON based HTTP request body with JSON as a response.
protected json execute form ( http method http method param , list < header name value > header name values param , boolean check connection valid param , list < form name value > form name values param , content type content type param , string postfix url param ) {	Submit a HTML Form based HTTP request body with JSON as a response.
private response handler < string > get json response handler ( final string url called param ) {	Get a text based response handler used mainly for JSON.
public boolean is connection valid ( ) {	Performs a HTTP Get against the connection test Web Service toconfirm whether the connection is valid.
private closeable http client get client ( ) { if ( this . closeable http client != null ) { return this . closeable http client ; }	Creates a new Http client.If part of a test run, the Http client will acceptself signed certificates.See flag {.
private string get path to fluid specific trust store ( ) { string fluid system trust store = system . get property ( system prop fluid trust store ) ; if ( fluid system trust store == null || fluid system trust store . trim ( ) . is empty ( ) ) { return null ; } file cert file = new file ( fluid system trust store ) ; if ( cert file . exists ( ) && cert file . is file ( ) ) { return fluid system trust store ; } return null ; }	Retrieves the system property for the Fluid specific trust store.
public void close connection ( ) { if ( this . connection == null ) { return ; } try { if ( this . connection . is closed ( ) ) { return ; } this . connection . close ( ) ; } catch ( sql sql except ) { throw new sql ( sql except ) ; } }	Close the SQL Connection.
public fluid item listing get fluid items for view ( job view job view param , int query limit param , int offset param , string sort field param , string sort order param ) { if ( this . service ticket != null && job view param != null ) { job view param . set service ticket ( this . service ticket ) ; } try { return new fluid item listing ( this . post json ( job view param , ws . path . flow item . version1 . get by job view ( query limit param , offset param , sort field param , sort order param ) ) ) ; }	Retrieves items for the provided JobView.
public fluid item send form to flow ( form form to send to flow param , string flow param ) { fluid item item to send = new fluid item ( ) ; item to send . set form ( form to send to flow param ) ; item to send . set flow ( flow param ) ; if ( this . service ticket != null ) { item to send . set service ticket ( this . service ticket ) ; } try { return new fluid item ( this . post json ( item to send , ws . path . flow item . version1 . send flow item to flow ( ) ) ) ; } catch ( json e ) { throw new fluid client exception ( e . get message ( ) , e , fluid client exception . error code . json parsing ) ; } }	Send a form item to be part of a workflow.
@ on close public void on close ( session user session param , close reason reason param ) { this . user session = null ; if ( this . message handlers != null ) { this . message handlers . values ( ) . for each ( handle -> { handle . connection closed ( ) ; } ) ; } }	Callback hook for Connection close events.
@ on message public void on message ( string message param ) { boolean handler found for msg = bool ; for ( i handler : new array list < > ( this . message handlers . values ( ) ) ) { object qualify obj = handler . does handler qualify for processing ( message param ) ; if ( qualify obj instanceof error ) { handler . handle message ( qualify obj ) ; } else if ( qualify obj instanceof json ) { handler . handle message ( qualify obj ) ; handler found for msg = bool ; break ; } } if ( ! handler found for msg ) { throw new fluid client exception ( str + message param , fluid client exception . error code . io error ) ; } }	Callback hook for Message Events.
public void send message ( a json a base fluid json ) { if ( a base fluid json == null ) { throw new fluid client exception ( str , fluid client exception . error code . io error ) ; } else { this . send message ( a base fluid json . to json object ( ) . to string ( ) ) ; } }	Send a message.
public void send message ( string message to send param ) { if ( this . user session == null ) { throw new fluid client exception ( str , fluid client exception . error code . io error ) ; } remote endpoint . async async remote = null ; if ( ( async remote = this . user session . get async remote ( ) ) == null ) { throw new fluid client exception ( str , fluid client exception . error code . io error ) ; } async remote . send text ( message to send param ) ; }	Send a message as text.
public void close session ( ) { if ( this . user session == null ) { return ; } try { this . user session . close ( ) ; } catch ( io e ) { throw new fluid client exception ( str + e . get message ( ) , e , fluid client exception . error code . io error ) ; } }	Closes the Web Socket User session.
public list < sql > execute native sql ( sql native sql ) { if ( native sql == null ) { return null ; } if ( native sql . get datasource name ( ) == null || native sql . get datasource name ( ) . is empty ( ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; }	Executes a native SQL query on the remote Fluid instance.The relevant access must exist.
public string request license ( license request license request param ) { if ( license request param != null && this . service ticket != null ) { license request param . set service ticket ( this . service ticket ) ; } return this . execute txt receive txt ( http method . post , null , bool , ( license request param == null ) ? null : license request param . to json object ( ) . to string ( ) , content type . application json , version1 . license request ( ) ) ; }	Request a new license based on the license request input.It is important to set the following fields.{.
public license request apply license ( string license to apply param ) { license request lice req = new license request ( ) ; lice req . set license cipher text ( license to apply param ) ; if ( this . service ticket != null ) { lice req . set service ticket ( this . service ticket ) ; } return new license request ( this . post json ( lice req , version1 . license apply ( ) ) ) ; }	Applies a generated license for the server.
public field create field text plain ( field route field param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . text ) ; route field param . set type meta data ( field meta data . text . plain ) ; } return new field ( this . put json ( route field param , version1 . route field create ( ) ) ) ; }	Create a new Plain Text field.
public field create field paragraph text plain ( field route field param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . paragraph text ) ; route field param . set type meta data ( field meta data . paragraph text . plain ) ; } return new field ( this . put json ( route field param , version1 . route field create ( ) ) ) ; }	Create a new Paragraph Text field.
public field create field paragraph text html ( field route field param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . paragraph text ) ; route field param . set type meta data ( field meta data . paragraph text . html ) ; } return new field ( this . put json ( route field param , version1 . route field create ( ) ) ) ; }	Create a new Paragraph HTML field.
public field create field multi choice select many ( field route field param , list < string > multi choice values param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( multi choice values param == null || multi choice values param . is empty ( ) ) { throw new fluid client exception ( str , fluid client exception . error code . field validate ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . multiple choice ) ; route field param . set type meta data ( field meta data . multi choice . select many ) ; route field param . set field value ( new multi choice ( multi choice values param ) ) ; } return new field ( this . put json ( route field param , version1 . route field create ( ) ) ) ; }	Create a new Multi Choice select Many field.
public field create field date time date ( field route field param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . date time ) ; route field param . set type meta data ( field meta data . date time . date ) ; } return new field ( this . put json ( route field param , version1 . route field create ( ) ) ) ; }	Create a new Date only field.
public field update field text plain ( field route field param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . text ) ; route field param . set type meta data ( field meta data . text . plain ) ; } return new field ( this . post json ( route field param , version1 . route field update ( ) ) ) ; }	Update an existing Text field.
public field update field paragraph text html ( field route field param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . paragraph text ) ; route field param . set type meta data ( field meta data . paragraph text . html ) ; } return new field ( this . post json ( route field param , version1 . route field update ( ) ) ) ; }	Update an existing Paragraph HTML field.
public field update field date time date and time ( field route field param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . date time ) ; route field param . set type meta data ( field meta data . date time . date and time ) ; } return new field ( this . post json ( route field param , version1 . route field update ( ) ) ) ; }	Update an existing Date and Time field.
public field update field decimal plain ( field route field param ) { if ( route field param != null && this . service ticket != null ) { route field param . set service ticket ( this . service ticket ) ; } if ( route field param != null ) { route field param . set type as enum ( field . type . decimal ) ; route field param . set type meta data ( field meta data . decimal . plain ) ; } return new field ( this . post json ( route field param , version1 . route field update ( ) ) ) ; }	Update an existing Decimal field.
public field update field value ( field route field value param ) { if ( route field value param != null && this . service ticket != null ) { route field value param . set service ticket ( this . service ticket ) ; } return new field ( this . post json ( route field value param , version1 . route field update value ( ) ) ) ; }	Update an existing 'Route field' value.
public field create field value ( field route field value to create param , fluid item fluid item param ) { if ( route field value to create param != null && this . service ticket != null ) { route field value to create param . set service ticket ( this . service ticket ) ; } long fluid itm id = ( fluid item param == null ) ? null : fluid item param . get id ( ) ; return new field ( this . put json ( route field value to create param , version1 . route field create value ( fluid itm id ) ) ) ; }	Create an new 'Route field' value.
public configuration get configuration by key ( string configuration key param ) { configuration configuration = new configuration ( ) ; configuration . set key ( configuration key param ) ; if ( this . service ticket != null ) { configuration . set service ticket ( this . service ticket ) ; } return new configuration ( this . post json ( configuration , ws . path . configuration . version1 . get by key ( ) ) ) ; }	Retrieves a Configuration by Key.
public configuration listing get all configurations ( ) { configuration configuration = new configuration ( ) ; if ( this . service ticket != null ) { configuration . set service ticket ( this . service ticket ) ; } return new configuration listing ( this . post json ( configuration , ws . path . configuration . version1 . get all configurations ( ) ) ) ; }	Retrieves all Configurations.
public attachment create attachment ( attachment attachment param ) { if ( attachment param != null && this . service ticket != null ) { attachment param . set service ticket ( this . service ticket ) ; } return new attachment ( this . put json ( attachment param , ws . path . attachment . version1 . attachment create ( ) ) ) ; }	Uploads a new Attachment.If there is an existing attachment with the same name, a new version will beuploaded.
public attachment get attachment by id ( long attachment id param , boolean include attachment data param ) { attachment attachment = new attachment ( attachment id param ) ; if ( this . service ticket != null ) { attachment . set service ticket ( this . service ticket ) ; } return new attachment ( this . post json ( attachment , ws . path . attachment . version1 . get by id ( include attachment data param ) ) ) ; }	Retrieves a Attachment by Primary Key.
public attachment delete attachment ( attachment attachment param ) { if ( attachment param != null && this . service ticket != null ) { attachment param . set service ticket ( this . service ticket ) ; } return new attachment ( this . post json ( attachment param , ws . path . attachment . version1 . attachment delete ( ) ) ) ; }	Delete an existing Attachment.
public attachment force delete attachment ( attachment attachment param ) { if ( attachment param != null && this . service ticket != null ) { attachment param . set service ticket ( this . service ticket ) ; } return new attachment ( this . post json ( attachment param , ws . path . attachment . version1 . attachment delete ( bool ) ) ) ; }	Forcefully Delete an existing Attachment.Only 'admin' can forcefully delete a Attachment.
private void parse jar file ( input stream input stream ) {	Parses the XSD file represented by the received InputStream.
private void set class loader ( string jar path ) { if ( ! jar path . ends with ( str ) ) { throw new parsing exception ( str ) ; } class loader original cl = thread . current thread ( ) . get context class loader ( ) ; url url = original cl . get resource ( jar path ) ; if ( url == null ) { try { url = new url ( str + jar path ) ; } catch ( url e ) { throw new parsing exception ( str ) ; } }	Creates a new class loader, replacing the current one, having another path added to the classpath.
private void rule2 ( ) { if ( ! ( parent instanceof xsd schema ) && name != null ) { throw new parsing exception ( xsd tag + str + name tag + str + xsd tag + str + xsd schema . xsd tag + str ) ; } }	Asserts if the current object has the name attribute when not being a direct child of the XsdSchema element, which isnot allowed, throwing an exception in that case.
private void rule3 ( ) { if ( parent instanceof xsd schema && name == null ) { throw new parsing exception ( xsd tag + str + name tag + str + xsd tag + str + xsd schema . xsd tag + str ) ; } }	Asserts if the current has no value for its name attribute while being a direct child of the top level XsdSchema element,which is required.
private void rule3 ( ) { if ( attributes map . contains key ( ref tag ) && ( simple type != null || form != null || type != null ) ) { throw new parsing exception ( xsd tag + str + ref tag + str ) ; } }	Asserts if the current object has a ref attribute at the same time as either a simpleType as children, a form attribute or a type attribute.Throws an exception in that case.
private node get schema node ( string file path ) throws io , sax , parser configuration exception { document doc = document builder factory . new instance ( ) . new document builder ( ) . parse ( file path ) ; doc . get document element ( ) . normalize ( ) ; return doc . get first child ( ) ; }	This function uses DOM to obtain a list of nodes from a XSD file.
private void rule7 ( ) { if ( parent instanceof xsd schema && attributes map . contains key ( form tag ) ) { throw new parsing exception ( xsd tag + str + form tag + str + xsd element is xsd schema ) ; } }	Asserts if the current object has a form attribute while being a direct child of the top level XsdSchema element,which isn't allowed, throwing an exception in that case.
private void rule3 ( ) { if ( parent instanceof xsd schema && attributes map . contains key ( ref tag ) ) { throw new parsing exception ( xsd tag + str + ref tag + str + xsd element is xsd schema ) ; } }	Asserts if the current object has a ref attribute while being a direct child of the top level XsdSchema element, which isn't allowed,throwing an exception in that case.
@ override public t convert ( final object value ) { if ( value == null ) { return null ; } else if ( is iterable ( ) && iterable . class . is assignable from ( value . get class ( ) ) ) { return convert iterable ( value ) ; } else if ( reflected klass . assignable from object ( value ) ) { return ( t ) value ; } else if ( reflected klass . can be unboxed ( value . get class ( ) ) ) { return ( t ) value ; } else if ( reflected klass . can be boxed ( value . get class ( ) ) ) { return ( t ) value ; } fluent class < ? > klass to create ; if ( reflected klass . is primitive ( ) ) { klass to create = reflected klass . boxed type ( ) ; } else { klass to create = reflected klass ; } return ( t ) convert value to ( value , klass to create ) ; }	If T is assignable from value, then return the value.
public static < o > cli < o > create cli ( final class < o > klass ) throws invalid option specification exception { return new cli interface impl < o > ( klass ) ; }	Construct a Cli from an annotated interface definition.
public static < o > cli < o > create cli using instance ( final o options ) throws invalid option specification exception { return new cli instance impl < o > ( options ) ; }	Construct a Cli from an annotated class.
public static < o > o parse arguments ( final class < o > klass , final string ... arguments ) throws argument validation exception , invalid option specification exception { return create cli ( klass ) . parse arguments ( arguments ) ; }	Parse arguments from an annotated interface definition.
public static < o > o parse arguments using instance ( final o options , final string ... arguments ) throws argument validation exception , invalid option specification exception { return create cli using instance ( options ) . parse arguments ( arguments ) ; }	Parse arguments from an annotated class instance.
builder url builder ( string path ) { builder builder = base url builder ( ) . add path segment ( configuration . get api package ( ) ) . add path segment ( configuration . get api version ( ) ) . add path segment ( path ) ; if ( configuration . get path modifier ( ) != discovery api configuration . path modifier . none ) { builder . add path segment ( configuration . get path modifier ( ) . get modifier ( ) ) ; } return builder ; }	Package protected for testing purposess.
public boolean remove footer view ( view v ) { if ( m footer view infos . size ( ) > num ) { boolean result = bool ; if ( m adapter != null && ( ( footer view grid adapter ) m adapter ) . remove footer ( v ) ) { notifiy changed ( ) ; result = bool ; } remove fixed view info ( v , m footer view infos ) ; return result ; } return bool ; }	Removes a previously-added footer view.
public double get value ( double p ) { if ( module == null ) { throw new no module exception ( ) ; } double x = ( x1 - x0 ) * p + x0 ; double y = ( y1 - y0 ) * p + y0 ; double z = ( z1 - z0 ) * p + z0 ; double value = module . get value ( x , y , z ) ; if ( attenuate ) { return p * ( num - p ) * num * value ; } else { return value ; } }	Returns the output value from the noise module given the one-dimensional coordinate of the specified input value located on the line segment.
public static int int value noise3 d ( int x , int y , int z , int seed ) {	Generates an integer-noise value from the coordinates of a three-dimensional input value.
public static double value noise3 d ( int x , int y , int z , int seed ) { return int value noise3 d ( x , y , z , seed ) / num ; }	Generates a value-noise value from the coordinates of a three-dimensional input value.
public static double cubic interp ( double n0 , double n1 , double n2 , double n3 , double a ) { double p = ( n3 - n2 ) - ( n0 - n1 ) ; double q = ( n0 - n1 ) - p ; double r = n2 - n0 ; return p * a * a * a + q * a * a + r * a + n1 ; }	Performs cubic interpolation between two values bound between two other values.
public static double s curve5 ( double a ) { double a3 = a * a * a ; double a4 = a3 * a ; double a5 = a4 * a ; return ( num * a5 ) - ( num * a4 ) + ( num * a3 ) ; }	maps a value onto a quitnic S-Curve.
public void set bounds ( double current lower , double current upper , double new lower , double new upper ) { if ( current lower == current upper ) { throw new illegal argument exception ( str + current upper ) ; } if ( new lower == new upper ) { throw new illegal argument exception ( str + new upper ) ; } current lower bound = current lower ; current upper bound = current upper ; new lower bound = new lower ; new upper bound = new upper ; recalculate scale bias ( ) ; }	Configure bounds for range module.
protected void do process ( final cloud trail event event ) { for ( final fullstop plugin plugin : get plugins for event ( event ) ) { do process ( event , plugin ) ; } }	Processes an single event by looping available plugins.
protected void do process ( final cloud trail event event , final fullstop plugin plugin ) { try { plugin . process event ( event ) ; } catch ( hystrix runtime exception | http server error exception e ) { log . warn ( e . get message ( ) , e ) ; } catch ( final exception e ) { log . error ( e . get message ( ) , e ) ; } }	Processes a specific event on specified plugin.
public static string get account id ( final cloud trail event event ) { final cloud trail event data event data = get event data ( event ) ; final user identity user identity = check not null ( event data . get user identity ( ) , user identity should never be null ) ; final string value = of nullable ( user identity . get account id ( ) ) . or else ( event data . get recipient account id ( ) ) ; return check not null ( value , account id or recipient should never be null ) ; }	Extracts the 'accountId'.
@ override public boolean apply ( final rule entity rule entity , final violation entity violation entity ) { final list < predicate < violation entity > > predicates = new array list ( ) ; trim optional ( rule entity . get account id ( ) ) . map ( whitelist rules evaluator :: account is equal ) . if present ( predicates :: add ) ; trim optional ( rule entity . get region ( ) ) . map ( whitelist rules evaluator :: region is equal ) . if present ( predicates :: add ) ; trim optional ( rule entity . get violation type entity id ( ) ) . map ( whitelist rules evaluator :: violation type id is equal ) . if present ( predicates :: add ) ; trim optional ( rule entity . get image name ( ) ) . map ( whitelist rules evaluator :: image name matches ) . if present ( predicates :: add ) ; trim optional ( rule entity . get image owner ( ) ) . map ( whitelist rules evaluator :: image owner is equal ) . if present ( predicates :: add ) ; trim optional ( rule entity . get application id ( ) ) . map ( whitelist rules evaluator :: application id is equal ) . if present ( predicates :: add ) ; trim optional ( rule entity . get application version ( ) ) . map ( whitelist rules evaluator :: application version is equal ) . if present ( predicates :: add ) ; trim optional ( rule entity . get meta info json path ( ) ) . map ( this :: meta info json path exists ) . if present ( predicates :: add ) ; final optional < predicate < violation entity > > white list test = predicates . stream ( ) . reduce ( predicate :: and ) ; return white list test . is present ( ) && white list test . get ( ) . test ( violation entity ) ; }	true if rule matches a violation and should be whitelisted.
private event serializer get event serializer ( final gzip input stream , final cloud trail log ct log ) throws io { final event serializer serializer ; if ( is enable raw event info ) { final string log file content = new string ( library utils . to byte array ( input stream ) , standard charsets . utf 8 ) ; final json parser json parser = this . mapper . get factory ( ) . create parser ( log file content ) ; serializer = new raw log delivery event serializer ( log file content , ct log , json parser ) ; } else { final json parser json parser = this . mapper . get factory ( ) . create parser ( input stream ) ; serializer = new default event serializer ( ct log , json parser ) ; } return serializer ; }	Get the EventSerializer based on user's configuration.
public file create file ( string file name ) throws io { path path = paths . get ( root folder . get path ( ) , file name ) ; return files . create file ( path ) . to file ( ) ; }	Create a file within the temporary folder root.
public file create directory ( string directory name ) { path path = paths . get ( root folder . get path ( ) , directory name ) ; try { return files . create directory ( path ) . to file ( ) ; } catch ( io ex ) { throw new temporary folder exception ( string . format ( str , path . to string ( ) ) , ex ) ; } }	Create a directory within the temporary folder root.
public void restore ( ) { for ( string property name : property names ) { if ( restore properties . contains key ( property name ) ) {	Reverse the system property 'sets' performed on behalf of this restore context. For each entry in {.
private map < k , v > create implementation ( ) { if ( delegate instanceof hash map == bool ) return new hash map < k , v > ( delegate ) ; return delegate ; }	Create the map implementation.
public boolean add ( final object obj ) { maintain ( ) ; soft object soft = soft object . create ( obj , queue ) ; return collection . add ( soft ) ; }	Add an object to the collection.
public static string set ( string name , string value ) { return property manager . set property ( name , value ) ; }	Set a property.
public static string [ ] get array ( string base , string [ ] default values ) { return property manager . get array property ( base , default values ) ; }	Get an array style property.
public state next state ( string action name ) throws illegal transition exception { transition t = current state . get transition ( action name ) ; if ( t == null ) { string msg = str + action name + str + current state . get name ( ) + str ; throw new illegal transition exception ( msg ) ; } state next state = t . get target ( ) ; log . trace ( str + action name + str + next state ) ; current state = next state ; return current state ; }	Transition to the next state given the name of a valid transition.
private void process queue ( ) { comparable soft reference cr ; while ( ( cr = ( comparable soft reference ) gcqueue . poll ( ) ) != null ) { map . remove ( cr . get key ( ) ) ; } }	Iterate through the gcqueue for for any cleared reference, removethe associated value from the underlying set.
@ suppress warnings ( { str , str } ) public t get ( type type ) { if ( type == null ) throw new illegal argument exception ( str ) ; if ( type instanceof parameterized type ) return get parameterized type ( ( parameterized type ) type ) ; else if ( type instanceof class ) return get class ( ( class < ? > ) type ) ; else if ( type instanceof type variable )	Get the information for a type.
protected t get parameterized type ( parameterized type type ) {	Get the information for a parameterized type.
protected < d extends generic declaration > t get type variable ( type variable < d > type ) {	Get the information for a type variable.
public void print stack trace ( final print stream stream ) { if ( nested == null || nested throwable . parent trace enabled ) { super . print stack trace ( stream ) ; } nested throwable . util . print ( nested , stream ) ; }	Prints the composite message and the embedded stack trace to thespecified print stream.
public void print stack trace ( final print writer writer ) { if ( nested == null || nested throwable . parent trace enabled ) { super . print stack trace ( writer ) ; } nested throwable . util . print ( nested , writer ) ; }	Prints the composite message and the embedded stack trace to thespecified print writer.
protected object replace object ( object obj ) throws io { if ( ( obj instanceof remote ) && ! ( obj instanceof remote stub ) ) { remote remote = ( remote ) obj ; try { obj = remote object . to stub ( remote ) ; } catch ( io ignore ) {	Override replaceObject to check for Remote objects that arenot RemoteStubs.
public void run ( ) {	Called by the thread pool executor.
protected void set task ( task task ) { if ( task == null ) throw new illegal argument exception ( str ) ; this . task = task ; this . task string = task . to string ( ) ; this . start time = system . current time millis ( ) ; this . wait type = task . get wait type ( ) ; this . priority = task . get priority ( ) ; this . start timeout = task . get start timeout ( ) ; this . completion timeout = task . get completion timeout ( ) ; }	Set thetask for this wrapper.
protected boolean task accepted ( ) { try { task . accepted ( get elapsed time ( ) ) ; return bool ; } catch ( throwable t ) { log . warn ( str + task string , t ) ; return bool ; } }	Notify the task it has been accepted.
protected boolean task rejected ( runtime exception e ) { try { task . rejected ( get elapsed time ( ) , e ) ; return bool ; } catch ( throwable t ) { log . warn ( str + task string , t ) ; if ( e != null ) log . warn ( str + task string , e ) ; return bool ; } }	Notify the task it has been rejected.
protected boolean task started ( ) { try { task . started ( get elapsed time ( ) ) ; return bool ; } catch ( throwable t ) { log . warn ( str + task string , t ) ; return bool ; } }	Notify the task it has started.
protected boolean task completed ( throwable throwable ) { try { task . completed ( get elapsed time ( ) , throwable ) ; return bool ; } catch ( throwable t ) { log . warn ( str + task string , t ) ; if ( throwable != null ) log . warn ( str + task string , throwable ) ; return bool ; } }	Notify the task it has completed.
protected boolean task stop ( ) { try { task . stop ( ) ; return bool ; } catch ( throwable t ) { log . warn ( str + task string , t ) ; return bool ; } }	Stop the task.
protected executable get job impl ( ) throws interrupted exception {	Never call this method, only override in subclasses to performjob getting in a specific way, normally tied to the data structureholding the jobs.
protected void put job impl ( executable job ) { job item posted = new job item ( job ) ; if ( m current job == null ) {	Never call this method, only override in subclasses to performjob adding in a specific way, normally tied to the data structureholding the jobs.
public static final blocking mode to blocking mode ( string name ) { blocking mode mode = null ; if ( name == null ) { mode = null ; } else if ( name . equals ignore case ( str ) ) { mode = run ; } else if ( name . equals ignore case ( str ) ) { mode = wait ; } else if ( name . equals ignore case ( str ) ) { mode = discard ; } else if ( name . equals ignore case ( str ) ) { mode = discard oldest ; } else if ( name . equals ignore case ( str ) ) { mode = abort ; } return mode ; }	A utility method to convert a string name to a BlockingMode.
object read resolve ( ) throws object stream exception {	Overriden to return the indentity instance of BlockingMode based on thestream type int value.
protected void copy readers ( catalog new catalog ) {	Copies the reader list from the current Catalog to a new Catalog.
protected catalog new catalog ( ) { string catalog class = this . get class ( ) . get name ( ) ; try { catalog c = ( catalog ) ( class . for name ( catalog class ) . new instance ( ) ) ; c . set catalog manager ( catalog manager ) ; copy readers ( c ) ; return c ; } catch ( class not found exception cnfe ) { catalog manager . debug . message ( num , str + catalog class ) ; } catch ( illegal access exception iae ) { catalog manager . debug . message ( num , str + catalog class ) ; } catch ( instantiation exception ie ) { catalog manager . debug . message ( num , str + catalog class ) ; } catch ( class cast exception cce ) { catalog manager . debug . message ( num , str + catalog class ) ; } catch ( exception e ) { catalog manager . debug . message ( num , str + catalog class ) ; } catalog c = new catalog ( ) ; c . set catalog manager ( catalog manager ) ; copy readers ( c ) ; return c ; }	Create a new Catalog object.
public void load system catalogs ( ) throws url , io { vector catalogs = catalog manager . get catalog files ( ) ; if ( catalogs != null ) { for ( int count = num ; count < catalogs . size ( ) ; count ++ ) { catalog files . add element ( catalogs . element at ( count ) ) ; } } if ( catalog files . size ( ) > num ) {	Load the system catalog files.
public synchronized void parse catalog ( url a url ) throws io { catalog cwd = a url ; base = a url ; default override = catalog manager . get prefer public ( ) ; catalog manager . debug . message ( num , str + a url . to string ( ) ) ; data input stream in stream = null ; boolean parsed = bool ; for ( int count = num ; ! parsed && count < reader arr . size ( ) ; count ++ ) { catalog reader reader = ( catalog reader ) reader arr . get ( count ) ; try { in stream = new data input stream ( a url . open stream ( ) ) ; } catch ( file not found exception fnfe ) {	Parse a catalog document, augmenting internal data structures.
protected synchronized void parse pending catalogs ( ) throws url , io { if ( ! local catalog files . is empty ( ) ) {	Parse all of the pending catalogs.
protected synchronized void parse catalog file ( string file name ) throws url , io , catalog exception {	Parse a single catalog file, augmenting internal data structures.
public void unknown entry ( vector strings ) { if ( strings != null && strings . size ( ) > num ) { string keyword = ( string ) strings . element at ( num ) ; catalog manager . debug . message ( num , str , keyword ) ; } }	Handle unknown CatalogEntry types.
public string resolve doctype ( string entity name , string public id , string system id ) throws url , io { string resolved = null ; catalog manager . debug . message ( num , str + entity name + str + public id + str + system id + str ) ; system id = normalize uri ( system id ) ; if ( public id != null && public id . starts with ( str ) ) { public id = public id . decode urn ( public id ) ; } if ( system id != null && system id . starts with ( str ) ) { system id = public id . decode urn ( system id ) ; if ( public id != null && ! public id . equals ( system id ) ) { catalog manager . debug . message ( num , str ) ; system id = null ; } else { public id = system id ; system id = null ; } } if ( system id != null ) {	Return the applicable DOCTYPE system identifier.
public string resolve document ( ) throws url , io {	Return the applicable DOCUMENT entry.
public string resolve system ( string system id ) throws url , io { catalog manager . debug . message ( num , str + system id + str ) ; system id = normalize uri ( system id ) ; if ( system id != null && system id . starts with ( str ) ) { system id = public id . decode urn ( system id ) ; return resolve public ( system id , null ) ; }	Return the applicable SYSTEM system identifier.
protected string resolve local uri ( string uri ) throws url , io { enumeration enumt = catalog entries . elements ( ) ; while ( enumt . has more elements ( ) ) { catalog entry e = ( catalog entry ) enumt . next element ( ) ; if ( e . get entry type ( ) == uri && ( e . get entry arg ( num ) . equals ( uri ) ) ) { return e . get entry arg ( num ) ; } }	Return the applicable URI in this catalog.
protected string make absolute ( string sysid ) { url local = null ; sysid = fix slashes ( sysid ) ; try { local = new url ( base , sysid ) ; } catch ( url e ) { catalog manager . debug . message ( num , str , sysid ) ; } if ( local != null ) { return local . to string ( ) ; } else { return sysid ; } }	Construct an absolute URI from a relative one, using the currentbase URI.
protected string normalize uri ( string uriref ) { string new ref = str ; byte [ ] bytes ; if ( uriref == null ) { return null ; } try { bytes = uriref . get bytes ( str ) ; } catch ( unsupported encoding exception uee ) {	Perform character normalization on a URI reference.
protected string encoded byte ( int b ) { string hex = integer . to hex string ( b ) . to upper case ( ) ; if ( hex . length ( ) < num ) { return str + hex ; } else { return str + hex ; } }	Perform %-encoding on a single byte.
protected void add delegate ( catalog entry entry ) { int pos = num ; string partial = entry . get entry arg ( num ) ; enumeration local = local delegate . elements ( ) ; while ( local . has more elements ( ) ) { catalog entry dpe = ( catalog entry ) local . next element ( ) ; string dp = dpe . get entry arg ( num ) ; if ( dp . equals ( partial ) ) {	Add to the current list of delegated catalogs. This method always constructs the {.
static < k , v > soft value ref < k , v > create ( k key , v val , reference queue < v > q ) { if ( val == null ) return null ; else return new soft value ref < k , v > ( key , val , q ) ; }	Safely create a new SoftValueRef.
protected static void fire on throwable ( int type , throwable t ) { object [ ] list = listeners . to array ( ) ; for ( int i = num ; i < list . length ; i ++ ) { ( ( throwable listener ) list [ i ] ) . on throwable ( type , t ) ; } }	Fire onThrowable to all registered listeners.
public static void add ( int type , throwable t ) {	Add a throwable that is to be handled.
private list < t > create implementation ( ) { if ( delegate instanceof array list == bool ) return new array list < t > ( delegate ) ; return delegate ; }	Create the list implementation.
public int compare to ( object other ) { if ( other == this ) return num ; timer task t = ( timer task ) other ; long diff = get next execution time ( ) - t . get next execution time ( ) ; return ( int ) diff ; }	A TimerTask is less than another if it will be scheduled before.
public object get value ( ) { try { string text = get as text ( ) ; if ( text == null ) { return null ; } if ( text . starts with ( str ) ) {	Returns a InetAddress for the input object converted to a string.
private object get object ( final int index ) { object obj = list . get ( index ) ; return objects . deref ( obj ) ; }	Dereference the object at the given index.
public object set ( final int index , final object obj ) { maintain ( ) ; soft object soft = soft object . create ( obj , queue ) ; soft = ( soft object ) list . set ( index , soft ) ; return objects . deref ( soft ) ; }	Replaces the element at the specified position in this list with thespecified element.
private void maintain ( ) { soft object obj ; int count = num ; while ( ( obj = ( soft object ) queue . poll ( ) ) != null ) { count ++ ; list . remove ( obj ) ; } if ( count != num ) {	Maintains the collection by removing garbage collected objects.
public static int add entry type ( string name , int num args ) { entry types . put ( name , new integer ( next entry ) ) ; entry args . add ( next entry , new integer ( num args ) ) ; next entry ++ ; return next entry - num ; }	Adds a new catalog entry type.
public static int get entry type ( string name ) throws catalog exception { if ( ! entry types . contains key ( name ) ) { throw new catalog exception ( catalog exception . invalid entry type ) ; } integer i type = ( integer ) entry types . get ( name ) ; if ( i type == null ) { throw new catalog exception ( catalog exception . invalid entry type ) ; } return i type . int value ( ) ; }	Lookup an entry type.
public static int get entry arg count ( int type ) throws catalog exception { try { integer i args = ( integer ) entry args . get ( type ) ; return i args . int value ( ) ; } catch ( array index out of bounds exception e ) { throw new catalog exception ( catalog exception . invalid entry type ) ; } }	Find out how many arguments an entry is required to have.
public string get entry arg ( int arg num ) { try { string arg = ( string ) args . get ( arg num ) ; return arg ; } catch ( array index out of bounds exception e ) { return null ; } }	Get an entry argument.
public void set context class loader ( final thread thread , final class loader cl ) { access controller . do privileged ( new privileged action ( ) { public object run ( ) { thread . set context class loader ( cl ) ; return null ; } } ) ; }	Set the context classloader for the given thread.
private void swap ( int a , int b ) {	Swap two nodes in the tree.
private timeout ext impl remove node ( int index ) {	Remove a node from the tree and normalize.
private timeout ext impl cleanup timeout ext impl ( timeout ext impl timeout ) { if ( timeout != null ) timeout . target = null ; return null ; }	Recursive cleanup of a TimeoutImpl.
protected class < ? > load class ( string class name , boolean resolve ) throws class not found exception {	Load a class, by asking the parent.
@ suppress warnings ( str ) public static void preload ( ) { for ( int i = num ; i < protocols . length ; i ++ ) { try { url url = new url ( protocols [ i ] , str , - num , str ) ; log . trace ( str + protocols [ i ] ) ; } catch ( exception e ) { log . warn ( str + protocols [ i ] , e ) ; } } }	Preload the JBoss specific protocol handlers, so that URL knows aboutthem even if the handler factory is changed.
public url create url ( final string protocol ) {	Search the handlerPkgs for URLStreamHandler classes matching thepkg + protocol + ".Handler" naming convention.
private synchronized void check handler pkgs ( ) { string handler pkgs prop = system . get property ( str ) ; if ( handler pkgs prop != null && handler pkgs prop . equals ( last handler pkgs ) == bool ) {	See if the java.protocol.handler.pkgs system property has changedand if it has, parse it to update the handlerPkgs array.
public object get value ( ) { try { class loader loader = thread . current thread ( ) . get context class loader ( ) ; string classname = get as text ( ) ; class < ? > type = loader . load class ( classname ) ; return type ; } catch ( exception e ) { throw new nested runtime exception ( e ) ; } }	Returns a Class for the input object converted to a string.
private set < t > create implementation ( ) { if ( delegate instanceof hash set == bool ) return new hash set < t > ( delegate ) ; return delegate ; }	Create the set implementation.
public static long counter make synchronized ( final long counter counter ) { return new wrapper ( counter ) { private static final long serial version uid = num ; public synchronized long increment ( ) { return this . counter . increment ( ) ; } public synchronized long decrement ( ) { return this . counter . decrement ( ) ; } public synchronized long get count ( ) { return this . counter . get count ( ) ; } public synchronized void reset ( ) { this . counter . reset ( ) ; } public synchronized int hash code ( ) { return this . counter . hash code ( ) ; } public synchronized boolean equals ( final object obj ) { return this . counter . equals ( obj ) ; } public synchronized string to string ( ) { return this . counter . to string ( ) ; } public synchronized object clone ( ) { return this . counter . clone ( ) ; } } ; }	Return a synchronized counter.
public static long counter make directional ( final long counter counter , final boolean increasing ) { long counter temp ; if ( increasing ) { temp = new wrapper ( counter ) { private static final long serial version uid = - num ; public long decrement ( ) { throw new unsupported operation exception ( ) ; } public void reset ( ) { throw new unsupported operation exception ( ) ; } } ; } else { temp = new wrapper ( counter ) { private static final long serial version uid = num ; public long increment ( ) { throw new unsupported operation exception ( ) ; } } ; } return temp ; }	Returns a directional counter.
protected boolean in extension namespace ( ) { boolean in extension = bool ; enumeration elements = namespace stack . elements ( ) ; while ( ! in extension && elements . has more elements ( ) ) { string ns = ( string ) elements . next element ( ) ; if ( ns == null ) { in extension = bool ; } else { in extension = ( ! ns . equals ( tr9401 namespace name ) && ! ns . equals ( namespace name ) ) ; } } return in extension ; }	Are we in an extension namespace?.
public void check notification ( int result ) {	Checks whether a notification is required andnotifies as appropriate.
public object get object instance ( object obj , name name , context name ctx , hashtable env ) throws exception {	Transform the obj Reference bound into the JNDI namespace into theactual non-Serializable object.
public static string subst ( final string buffer buff , final string string , final map map , final string begin token , final string end token ) { int begin = num , range end = num ; range range ; while ( ( range = range of ( begin token , end token , string , range end ) ) != null ) {	Substitute sub-strings in side of a string.
public static string [ ] split ( final string string , final string delim , final int limit ) {	Split up a string into multiple strings based on a delimiter.
public static string join ( final byte array [ ] ) { byte bytes [ ] = new byte [ array . length ] ; for ( int i = num ; i < bytes . length ; i ++ ) { bytes [ i ] = new byte ( array [ i ] ) ; } return join ( bytes , null ) ; }	Convert and join an array of bytes into one string.
public static final void default to string ( j buffer , object object ) { if ( object == null ) buffer . append ( str ) ; else { buffer . append ( object . get class ( ) . get name ( ) ) ; buffer . append ( str ) ; buffer . append ( integer . to hex string ( system . identity hash code ( object ) ) ) ; } }	The default toString implementation of an object.
public object get value ( ) { string text = get as text ( ) ; blocking mode mode = blocking mode . to blocking mode ( text ) ; return mode ; }	Returns a BlockingMode for the input object converted to a string.
public void create ( ) { if ( thread safe ) entry map = collections . synchronized map ( new hash map ( ) ) ; else entry map = new hash map ( ) ; now = system . current time millis ( ) ; }	Initializes the cache for use.
public object get ( object key ) { timed entry entry = ( timed entry ) entry map . get ( key ) ; if ( entry == null ) return null ; if ( entry . is current ( now ) == bool ) {	Get the cache value for key if it has not expired.
public object peek ( object key ) { timed entry entry = ( timed entry ) entry map . get ( key ) ; object value = null ; if ( entry != null ) value = entry . get value ( ) ; return value ; }	Get the cache value for key.
public void remove ( object key ) { timed entry entry = ( timed entry ) entry map . remove ( key ) ; if ( entry != null ) entry . destroy ( ) ; }	Remove the entry associated with key and call destroy on the entryif found.
public void flush ( ) { map tmp map = null ; synchronized ( this ) { tmp map = entry map ; if ( thread safe ) entry map = collections . synchronized map ( new hash map ( ) ) ; else entry map = new hash map ( ) ; }	Remove all entries from the cache.
public list get valid keys ( ) { array list valid keys = new array list ( ) ; synchronized ( entry map ) { iterator iter = entry map . entry set ( ) . iterator ( ) ; while ( iter . has next ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; timed entry value = ( timed entry ) entry . get value ( ) ; if ( value . is current ( now ) == bool ) valid keys . add ( entry . get key ( ) ) ; } } return valid keys ; }	Get the list of keys for entries that are not expired.
public synchronized void set resolution ( int resolution ) { if ( resolution <= num ) resolution = num ; if ( resolution != this . resolution ) { this . resolution = resolution ; the timer . cancel ( ) ; the timer = new resolution timer ( ) ; resolution timer . schedule at fixed rate ( the timer , num , num * resolution ) ; } }	Set the cache timer resolution.
public timed entry peek entry ( object key ) { timed entry entry = ( timed entry ) entry map . get ( key ) ; return entry ; }	Get the raw TimedEntry for key without performing any expiration check.
public static iterator get children by tag name ( element element , string tag name ) { if ( element == null ) return null ;	Returns an iterator over the children of the given element withthe given tag name.
public static element get unique child ( element element , string tag name ) throws exception { iterator good children = get children by tag name ( element , tag name ) ; if ( good children != null && good children . has next ( ) ) { element child = ( element ) good children . next ( ) ; if ( good children . has next ( ) ) { throw new exception ( str + tag name + str ) ; } return child ; } else { throw new exception ( str + tag name + str ) ; } }	Gets the child of the specified element having the specified uniquename.
public static element get optional child ( element element , string tag name ) throws exception { return get optional child ( element , tag name , null ) ; }	Gets the child of the specified element having thespecified name.
public static string get element content ( element element , string default str ) throws exception { if ( element == null ) return default str ; node list children = element . get child nodes ( ) ; string result = str ; for ( int i = num ; i < children . get length ( ) ; i ++ ) { if ( children . item ( i ) . get node type ( ) == node . text node || children . item ( i ) . get node type ( ) == node . cdata section node ) { result += children . item ( i ) . get node value ( ) ; } else if ( children . item ( i ) . get node type ( ) == node . comment node ) {	Get the content of the given element.
public static string get unique child content ( element element , string tag name ) throws exception { return get element content ( get unique child ( element , tag name ) ) ; }	Macro to get the content of a unique child element.
public static string get optional child content ( element element , string tag name ) throws exception { return get element content ( get optional child ( element , tag name ) ) ; }	Macro to get the content of an optional child element.
public void set maximum queue size ( int size ) {	This resets the work queue capacity.
public void set blocking mode ( string name ) { blocking mode = blocking mode . to blocking mode ( name ) ; if ( blocking mode == null ) blocking mode = blocking mode . abort ; }	For backward compatibility with the previous string based mode.
public void set blocking mode string ( string name ) { blocking mode = blocking mode . to blocking mode ( name ) ; if ( blocking mode == null ) blocking mode = blocking mode . abort ; }	For backward compatibility with the previous string based modeThis is needed for microcontainer as it gets confused with overloadedsetters.
protected void execute ( task wrapper wrapper ) { if ( trace ) log . trace ( str + wrapper ) ; try { executor . execute ( wrapper ) ; } catch ( throwable t ) { wrapper . reject task ( new thread pool full exception ( str + wrapper , t ) ) ; } }	Execute a task.
protected string resolve external system ( string system id , string resolver ) throws url , io { resolver r = query resolver ( resolver , str , system id , null ) ; if ( r != null ) { return r . resolve system ( system id ) ; } else { return null ; } }	Query an external RFC2483 resolver for a system identifier.
protected string resolve external public ( string public id , string resolver ) throws url , io { resolver r = query resolver ( resolver , str , public id , null ) ; if ( r != null ) { return r . resolve public ( public id , null ) ; } else { return null ; } }	Query an external RFC2483 resolver for a public identifier.
protected resolver query resolver ( string resolver , string command , string arg1 , string arg2 ) { string rf = resolver + str + command + str + arg1 + str + arg2 ; try { url url = new url ( rf ) ; url url con = url . open connection ( ) ; url con . set use caches ( bool ) ; resolver r = ( resolver ) new catalog ( ) ; string c type = url con . get content type ( ) ;	Query an external RFC2483 resolver.
private vector append vector ( vector vec , vector appvec ) { if ( appvec != null ) { for ( int count = num ; count < appvec . size ( ) ; count ++ ) { vec . add element ( appvec . element at ( count ) ) ; } } return vec ; }	Append two vectors, returning the result.
public vector resolve all system reverse ( string system id ) throws url , io { vector resolved = new vector ( ) ;	Find the URNs for a given system identifier in all catalogs.
public string resolve system reverse ( string system id ) throws url , io { vector resolved = resolve all system reverse ( system id ) ; if ( resolved != null && resolved . size ( ) > num ) { return ( string ) resolved . element at ( num ) ; } else { return null ; } }	Find the URN for a given system identifier.
private vector resolve all local system ( string system id ) { vector map = new vector ( ) ; string osname = system . get property ( str ) ; boolean windows = ( osname . index of ( str ) >= num ) ; enumeration enumt = catalog entries . elements ( ) ; while ( enumt . has more elements ( ) ) { catalog entry e = ( catalog entry ) enumt . next element ( ) ; if ( e . get entry type ( ) == system && ( e . get entry arg ( num ) . equals ( system id ) || ( windows && e . get entry arg ( num ) . equals ignore case ( system id ) ) ) ) { map . add element ( e . get entry arg ( num ) ) ; } } if ( map . size ( ) == num ) { return null ; } else { return map ; } }	Return all applicable SYSTEM system identifiers in thiscatalog.
public void read catalog ( catalog catalog , string file url ) throws url , io , catalog exception { url url = null ; try { url = new url ( file url ) ; } catch ( url e ) { url = new url ( str + file url ) ; } debug = catalog . get catalog manager ( ) . debug ; try { url url con = url . open connection ( ) ; read catalog ( catalog , url con . get input stream ( ) ) ; } catch ( file not found exception e ) { catalog . get catalog manager ( ) . debug . message ( num , str , url . to string ( ) ) ; } }	Parse an XML Catalog file.
public void read catalog ( catalog catalog , input stream is ) throws io , catalog exception {	Parse an XML Catalog stream.
public void connect ( ) throws io { if ( connected ) return ; if ( ! file . exists ( ) ) { throw new file not found exception ( file . get path ( ) ) ; } connected = bool ; }	Checks if the underlying file for this connection exists.
public output stream get output stream ( ) throws io { connect ( ) ; security manager sm = system . get security manager ( ) ; if ( sm != null ) {	We should probably disallow this?.
void help delete ( node < k , v > b , node < k , v > f ) { if ( f == next && this == b . next ) { if ( f == null || f . value != f )	Helps out a deletion by appending marker or unlinking frompredecessor.
v get valid value ( ) { object v = value ; if ( v == this || v == base header ) return null ; return ( v ) v ; }	Return value if this node contains a valid key-value pair,else null.
snapshot entry < k , v > create snapshot ( ) { v v = get valid value ( ) ; if ( v == null ) return null ; return new snapshot entry ( key , v ) ; }	Create and return a new SnapshotEntry holding currentmapping if this node holds a valid value, else null.
private logger create log ( ) { class < ? > clazz = get class ( ) ; logger logger = loggers . get ( clazz ) ; if ( logger == null ) { logger = logger . get logger ( clazz ) ; loggers . put ( clazz , logger ) ; } return logger ; }	Create logger.
public static void list ( j buffer , collection objects ) { if ( objects == null ) return ; buffer . append ( str ) ; if ( objects . is empty ( ) == bool ) { for ( iterator i = objects . iterator ( ) ; i . has next ( ) ; ) { object object = i . next ( ) ; if ( object instanceof j ) ( ( j ) object ) . to short string ( buffer ) ; else buffer . append ( object . to string ( ) ) ; if ( i . has next ( ) ) buffer . append ( str ) ; } } buffer . append ( str ) ; }	List the set of JBossObjects.
public string get class short name ( ) { string long name = get class ( ) . get name ( ) ; int dot = long name . last index of ( str ) ; if ( dot != - num ) return long name . substring ( dot + num ) ; return long name ; }	Get the class short name.
protected string to string implementation ( ) { j buffer = new j ( ) ; buffer . append ( get class short name ( ) ) . append ( str ) ; buffer . append ( integer . to hex string ( system . identity hash code ( this ) ) ) ; buffer . append ( str ) ; to string ( buffer ) ; buffer . append ( str ) ; return buffer . to string ( ) ; }	Implementation of String.
public static iterator names ( ) { security manager sm = system . get security manager ( ) ; if ( sm != null ) sm . check properties access ( ) ; return props . names ( ) ; }	Return an iterator over all contained property names.
public static property group get property group ( final string basename ) { security manager sm = system . get security manager ( ) ; if ( sm != null ) sm . check properties access ( ) ; return props . get property group ( basename ) ; }	Get a property group for the given property base.
public static constructor get compatible constructor ( final class type , final class value type ) {	Get a compatible constructor for the given value type.
public static object copy ( final serializable obj ) throws io , class not found exception { object output stream out = null ; object input stream in = null ; object copy = null ; try {	Copy an serializable object deeply.
public static < t > t deref ( final object obj , class < t > expected ) { object result = deref ( obj ) ; if ( result == null ) return null ; return expected . cast ( result ) ; }	Dereference an object.
private void init ( ) { unbound listeners = collections . synchronized list ( new array list ( ) ) ; bound listeners = collections . synchronized map ( new hash map ( ) ) ; jndi map = new hash map ( ) ; privileged action action = new privileged action ( ) { public object run ( ) { object value = system . get property ( context . provider url ) ; if ( value == null ) value = null value ; jndi map . put ( context . provider url , value ) ; value = system . get property ( context . initial context factory ) ; if ( value == null ) value = null value ; jndi map . put ( context . initial context factory , value ) ; value = system . get property ( context . object factories ) ; if ( value == null ) value = null value ; jndi map . put ( context . object factories , value ) ; value = system . get property ( context . url pkg prefixes ) ; if ( value == null ) value = null value ; jndi map . put ( context . url pkg prefixes , value ) ; value = system . get property ( context . state factories ) ; if ( value == null ) value = null value ; jndi map . put ( context . state factories , value ) ; value = system . get property ( context . dns url ) ; if ( value == null ) value = null value ; jndi map . put ( context . dns url , value ) ; value = system . get property ( ldap context . control factories ) ; if ( value == null ) value = null value ; jndi map . put ( ldap context . control factories , value ) ; return null ; } } ; access controller . do privileged ( action ) ; }	Initialized listener lists and the JNDI properties cache map.
private void update jndi cache ( string name , string value ) { if ( name == null ) return ; boolean is jndi property = name . equals ( context . provider url ) || name . equals ( context . initial context factory ) || name . equals ( context . object factories ) || name . equals ( context . url pkg prefixes ) || name . equals ( context . state factories ) || name . equals ( context . dns url ) || name . equals ( ldap context . control factories ) ; if ( is jndi property == bool ) jndi map . put ( name , value ) ; }	Called by setProperty to update the jndiMap cache values.
public set key set ( final boolean include defaults ) { if ( include defaults ) { set set = new hash set ( ) ; set . add all ( defaults . key set ( ) ) ; set . add all ( super . key set ( ) ) ; return collections . synchronized set ( set ) ; } return super . key set ( ) ; }	Returns a set of keys for all entries in this group and optionallyall of the keys in the defaults map.
public set entry set ( final boolean include defaults ) { if ( include defaults ) { set set = new hash set ( ) ; set . add all ( defaults . entry set ( ) ) ; set . add all ( super . entry set ( ) ) ; return collections . synchronized set ( set ) ; } return super . entry set ( ) ; }	Returns a set of entrys for all entries in this group and optionallyall of the entrys in the defaults map.
public boolean remove property listener ( property listener listener ) { if ( listener == null ) throw new null argument exception ( str ) ; boolean removed = bool ; if ( listener instanceof bound property listener ) { removed = remove property listener ( ( bound property listener ) listener ) ; } else { removed = unbound listeners . remove ( listener ) ; } return removed ; }	Remove a property listener.
private void fire property added ( list list , property event event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = num ; i < size ; i ++ ) { property listener listener = ( property listener ) list . get ( i ) ; listener . property added ( event ) ; } }	Fire a property added event to the given list of listeners.
private void fire property removed ( list list , property event event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = num ; i < size ; i ++ ) { property listener listener = ( property listener ) list . get ( i ) ; listener . property removed ( event ) ; } }	Fire a property removed event to the given list of listeners.
private void fire property changed ( list list , property event event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = num ; i < size ; i ++ ) { property listener listener = ( property listener ) list . get ( i ) ; listener . property changed ( event ) ; } }	Fire a property changed event to the given list of listeners.
protected void fire property changed ( property event event ) {	Fire a property changed event to all listeners.
protected string make prefixed property name ( string base , string prefix ) { string name = base ; if ( prefix != null ) { string buffer buff = new string buffer ( base ) ; if ( prefix != null ) { buff . insert ( num , property name separator ) ; buff . insert ( num , prefix ) ; } return buff . to string ( ) ; } return name ; }	Make a optionaly prefixed property name.
public void load ( property reader reader ) throws property exception , io { if ( reader == null ) throw new null argument exception ( str ) ; load ( reader . read properties ( ) ) ; }	Load properties from a PropertyReader.
public void load ( string class name ) throws property exception , io { if ( class name == null ) throw new null argument exception ( str ) ; property reader reader = null ; try { class type = class . for name ( class name ) ; reader = ( property reader ) type . new instance ( ) ; } catch ( exception e ) { throw new property exception ( e ) ; }	Load properties from a PropertyReader specifed by the given class name.
public property group get property group ( string basename , int index ) { string name = make index property name ( basename , index ) ; return get property group ( name ) ; }	Get a property group for the given property base at the given index.
public boolean is entity resolved ( ) { boolean value = entity resolved . get ( ) ; return value != null ? value . boolean value ( ) : bool ; }	Returns the boolean value to inform id DTD was found in the XML file or not.
protected input source resolve system id ( string system id , boolean trace ) { if ( system id == null ) return null ; if ( trace ) log . trace ( str + system id ) ; input source input source = null ;	Attempt to use the systemId as a URL from which the schema can be read.
protected input source resolve system i url ( string system id , boolean trace ) { if ( system id == null ) return null ; if ( trace ) log . trace ( str + system id ) ; input source input source = null ;	Attempt to use the systemId as a URL from which the schema can be read.
protected input source resolve classpath name ( string system id , boolean trace ) { if ( system id == null ) return null ; if ( trace ) log . trace ( str + system id ) ; string filename = system id ;	Resolve the systemId as a classpath resource.
public void set as text ( string text ) { document d = get as document ( text ) ; set value ( d . get document element ( ) ) ; }	Sets as an Element created by a String.
public static string normalize ( string public id ) { string normal = public id . replace ( str , str ) ; normal = normal . replace ( str , str ) ; normal = normal . replace ( str , str ) ; normal = normal . trim ( ) ; int pos ; while ( ( pos = normal . index of ( str ) ) >= num ) { normal = normal . substring ( num , pos ) + normal . substring ( pos + num ) ; } return normal ; }	Normalize a public identifier.
public static string encode urn ( string public id ) { string urn = public id . normalize ( public id ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; urn = public id . string replace ( urn , str , str ) ; return str + urn ; }	Encode a public identifier as a "publicid" URN.
public static string decode urn ( string urn ) { string public id = str ; if ( urn . starts with ( str ) ) { public id = urn . substring ( num ) ; } else { return urn ; } public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; public id = public id . string replace ( public id , str , str ) ; return public id ; }	Decode a "publicid" URN into a public identifier.
private static string string replace ( string str , string old str , string new str ) { string result = str ; int pos = str . index of ( old str ) ;	Replace one string with another.
public void start ( final boolean reset ) { if ( ! running ) { if ( reset ) reset ( ) ; start = system . current time millis ( ) ; running = bool ; } }	Start the watch.
public long stop ( ) { long lap = num ; if ( running ) { count ++ ; stop = system . current time millis ( ) ; lap = stop - start ; total += lap ; running = bool ; } return lap ; }	Stop the watch.
public static stop watch make synchronized ( final stop watch watch ) { return new wrapper ( watch ) { private static final long serial version uid = - num ; public synchronized void start ( final boolean reset ) { this . watch . start ( reset ) ; } public synchronized void start ( ) { this . watch . start ( ) ; } public synchronized long stop ( ) { return this . watch . stop ( ) ; } public synchronized void reset ( ) { this . watch . reset ( ) ; } public synchronized long get lap time ( ) { return this . watch . get lap time ( ) ; } public synchronized long get average lap time ( ) { return this . watch . get average lap time ( ) ; } public synchronized int get lap count ( ) { return this . watch . get lap count ( ) ; } public synchronized long get time ( ) { return this . watch . get time ( ) ; } public synchronized boolean is running ( ) { return this . watch . is running ( ) ; } public synchronized string to string ( ) { return this . watch . to string ( ) ; } } ; }	Return a synchronized stop watch.
public int compare to ( final object obj ) throws class cast exception { hash code hash code = ( hash code ) obj ; return compare to ( hash code . value ) ; }	Compares this object with the specified object for order.
public static int generate ( final byte [ ] bytes ) { int hashcode = num ; for ( int i = num ; i < bytes . length ; i ++ ) { hashcode <<= num ; hashcode ^= bytes [ i ] ; } return hashcode ; }	Generate a hash code for a byte array.
public static int generate ( final object array [ ] , final boolean deep ) { int hashcode = num ; for ( int i = num ; i < array . length ; i ++ ) { if ( deep && ( array [ i ] instanceof object [ ] ) ) { hashcode ^= generate ( ( object [ ] ) array [ i ] , bool ) ; } else { hashcode ^= array [ i ] . hash code ( ) ; } } return hashcode ; }	Generate a hash code for an object array.
public void create ( ) { m map = create map ( ) ; m list = create list ( ) ; m list . m max capacity = m max capacity ; m list . m min capacity = m min capacity ; m list . m capacity = m max capacity ; }	Initializes the cache, creating all required objects and initializing theirvalues.
protected void set field value ( string value ) { try {	Coerce and set specified value to field.
protected string next token ( ) throws io { string token = str ; int ch , nextch ; if ( ! token stack . empty ( ) ) { return ( string ) token stack . pop ( ) ; }	Return the next token in the catalog file.
public static void initialize ( ) { privileged action action = new privileged action ( ) { public object run ( ) { string default format = system . get property ( str , str ) ; string default locale = system . get property ( str ) ; date format default date format ; if ( default locale == null || default locale . length ( ) == num ) { default date format = new simple date format ( default format ) ; } else { default date format = new simple date format ( default format , strings . parse locale string ( default locale ) ) ; } formats = new date format [ ] { default date format ,	Setup the parsing formats.
public boolean add vertex ( vertex < t > v ) { if ( verticies . contains value ( v ) == bool ) { verticies . put ( v . get name ( ) , v ) ; return bool ; } return bool ; }	Add a vertex to the graph.
public void set root vertex ( vertex < t > root ) { this . root vertex = root ; if ( verticies . contains value ( root ) == bool ) add vertex ( root ) ; }	Set a root vertex.
public boolean remove vertex ( vertex < t > v ) { if ( ! verticies . contains value ( v ) ) return bool ; verticies . remove ( v . get name ( ) ) ; if ( v == root vertex ) root vertex = null ;	Remove a vertex from the graph.
public void depth first search ( vertex < t > v , final visitor < t > visitor ) { ex < t , runtime exception > wrapper = new ex < t , runtime exception > ( ) { public void visit ( graph < t > g , vertex < t > v ) throws runtime exception { if ( visitor != null ) visitor . visit ( g , v ) ; } } ; this . depth first search ( v , wrapper ) ; }	Perform a depth first serach using recursion.
public void dfs spanning tree ( vertex < t > v , dfs < t > visitor ) { v . visit ( ) ; if ( visitor != null ) visitor . visit ( this , v ) ; for ( int i = num ; i < v . get outgoing edge count ( ) ; i ++ ) { edge < t > e = v . get outgoing edge ( i ) ; if ( ! e . get to ( ) . visited ( ) ) { if ( visitor != null ) visitor . visit ( this , v , e ) ; e . mark ( ) ; dfs spanning tree ( e . get to ( ) , visitor ) ; } } }	Find the spanning tree using a DFS starting from v.
public vertex < t > find vertex by data ( t data , comparator < t > compare ) { vertex < t > match = null ; for ( vertex < t > v : verticies . values ( ) ) { if ( compare . compare ( data , v . get data ( ) ) == num ) { match = v ; break ; } } return match ; }	Search the verticies for one with data.
public edge < t > [ ] find cycles ( ) { array list < edge < t > > cycle edges = new array list < edge < t > > ( ) ;	Search the graph for cycles.
public static string normalize ( string s , boolean canonical ) { string buffer str = new string buffer ( ) ; int len = ( s != null ) ? s . length ( ) : num ; for ( int i = num ; i < len ; i ++ ) { char ch = s . char at ( i ) ; switch ( ch ) { case str : { str . append ( str ) ; break ; } case str : { str . append ( str ) ; break ; } case str : { str . append ( str ) ; break ; } case str : { str . append ( str ) ; break ; } case str : { str . append ( str ) ; break ; } case str : case str : { if ( canonical ) { str . append ( str ) ; str . append ( integer . to string ( ch ) ) ; str . append ( str ) ; break ; }	Normalizes the given string.
public static element parse ( string xml string ) throws io { try { return parse ( new byte array input stream ( xml string . get bytes ( str ) ) ) ; } catch ( io e ) { log . error ( str + xml string ) ; throw e ; } }	Parse the given XML string and return the root Element.
public static element parse ( input stream xml stream ) throws io { try { document doc = get document builder ( ) . parse ( xml stream ) ; element root = doc . get document element ( ) ; return root ; } catch ( sax e ) { throw new io ( e . to string ( ) ) ; } }	Parse the given XML stream and return the root Element.
public static element parse ( input source source ) throws io { try { document doc = get document builder ( ) . parse ( source ) ; element root = doc . get document element ( ) ; return root ; } catch ( sax e ) { throw new io ( e . to string ( ) ) ; } }	Parse the given input source and return the root Element.
public static element create element ( string local part ) { document doc = get owner document ( ) ; log . trace ( str + local part ) ; return doc . create element ( local part ) ; }	Create an Element for a given name.
public static q resolve q ( element el , string qualified name ) { q qname ; string prefix = str ; string namespace uri = str ; string local part = qualified name ; int col index = qualified name . index of ( str ) ; if ( col index > num ) { prefix = qualified name . substring ( num , col index ) ; local part = qualified name . substring ( col index + num ) ; if ( str . equals ( prefix ) ) { namespace uri = str ; } else { element ns element = el ; while ( namespace uri . equals ( str ) && ns element != null ) { namespace uri = ns element . get attribute ( str + prefix ) ; if ( namespace uri . equals ( str ) ) ns element = get parent element ( ns element ) ; } } if ( namespace uri . equals ( str ) ) throw new illegal argument exception ( str + qualified name ) ; } qname = new q ( namespace uri , local part , prefix ) ; return qname ; }	Transform the giveen qualified name into a QName.
public static void copy attributes ( element dest element , element src element ) { named node map attribs = src element . get attributes ( ) ; for ( int i = num ; i < attribs . get length ( ) ; i ++ ) { attr attr = ( attr ) attribs . item ( i ) ; string uri = attr . get namespace uri ( ) ; string qname = attr . get name ( ) ; string value = attr . get node value ( ) ;	Copy attributes between elements.
public static boolean has child elements ( node node ) { node list nlist = node . get child nodes ( ) ; for ( int i = num ; i < nlist . get length ( ) ; i ++ ) { node child = nlist . item ( i ) ; if ( child . get node type ( ) == node . element node ) return bool ; } return bool ; }	True if the node has child elements.
public static iterator get child elements ( node node ) { array list list = new array list ( ) ; node list nlist = node . get child nodes ( ) ; for ( int i = num ; i < nlist . get length ( ) ; i ++ ) { node child = nlist . item ( i ) ; if ( child . get node type ( ) == node . element node ) list . add ( child ) ; } return list . iterator ( ) ; }	Gets child elements.
public static string get text content ( node node , boolean replace props ) { boolean has text content = bool ; string buffer buffer = new string buffer ( ) ; node list nlist = node . get child nodes ( ) ; for ( int i = num ; i < nlist . get length ( ) ; i ++ ) { node child = nlist . item ( i ) ; if ( child . get node type ( ) == node . text node ) { buffer . append ( child . get node value ( ) ) ; has text content = bool ; } } string text = ( has text content ? buffer . to string ( ) : null ) ; if ( text != null && replace props ) text = string property replacer . replace properties ( text ) ; return text ; }	Get the concatenated text content, or null.
public static iterator get child elements ( node node , string node name ) { return get child elements intern ( node , new q ( node name ) ) ; }	Gets the child elements for a given local name without namespace.
public static element get parent element ( node node ) { node parent = node . get parent node ( ) ; return ( parent instanceof element ? ( element ) parent : null ) ; }	Gets parent element or null if there is none.
public void add waiting ( object holder , resource resource ) { synchronized ( waiting ) { waiting . put ( holder , resource ) ; } }	Add a transaction waiting for a lock.
public void read catalog ( catalog catalog , string file url ) throws url , io , catalog exception { url url = new url ( file url ) ; url url con = url . open connection ( ) ; read catalog ( catalog , url con . get input stream ( ) ) ; }	Read the catalog behind the specified URL.
private static byte [ ] get host address ( ) { return ( byte [ ] ) access controller . do privileged ( new privileged action ( ) { public object run ( ) { try { return inet address . get local host ( ) . get address ( ) ; } catch ( exception e ) { return unknown host ; } } } ) ; }	Return the current host internet address.
public static throwable set system property class value ( string property , string class name ) {	Sets the system property to a class when the class is available.
public static void display class info ( class clazz , string buffer results ) {	Format a string buffer containing the Class, Interfaces, CodeSource,and ClassLoader information for the given object clazz.
public static void describe ( string buffer buffer , class clazz ) { if ( clazz == null ) buffer . append ( str ) ; else { buffer . append ( str ) . append ( clazz . get name ( ) ) ; class [ ] intfs = clazz . get interfaces ( ) ; if ( intfs . length > num ) { buffer . append ( str ) ; for ( int i = num ; i < intfs . length ; ++ i ) { buffer . append ( intfs [ i ] . get name ( ) ) ; if ( i < intfs . length - num ) buffer . append ( str ) ; } } buffer . append ( str ) ; } }	Describe the class.
public static string strip package name ( final string classname ) { int idx = classname . last index of ( package separator ) ; if ( idx != - num ) return classname . substring ( idx + num , classname . length ( ) ) ; return classname ; }	Get the short name of the specified class by striping off the packagename.
public static string get package name ( final string classname ) { if ( classname . length ( ) == num ) throw new empty string exception ( ) ; int index = classname . last index of ( package separator ) ; if ( index != - num ) return classname . substring ( num , index ) ; return str ; }	Get the package name of the specified class.
public static void force load ( final class type ) { if ( type == null ) throw new null argument exception ( str ) ;	Force the given class to be loaded fully.
public static class get primitive wrapper ( final class type ) { if ( ! type . is primitive ( ) ) { throw new illegal argument exception ( str ) ; } for ( int i = num ; i < primitive wrapper map . length ; i += num ) { if ( type . equals ( primitive wrapper map [ i ] ) ) return primitive wrapper map [ i + num ] ; }	Get the wrapper class for the given primitive type.
public static void get all interfaces ( list all ifaces , class c ) { while ( c != null ) { class [ ] ifaces = c . get interfaces ( ) ; for ( int n = num ; n < ifaces . length ; n ++ ) { all ifaces . add ( ifaces [ n ] ) ; } c = c . get superclass ( ) ; } }	Populates a list with all the interfaces implemented by the argumentclass c and all its superclasses.
public static class [ ] get all unique interfaces ( class c ) { set unique ifaces = new hash set ( ) ; while ( c != null ) { class [ ] ifaces = c . get interfaces ( ) ; for ( int n = num ; n < ifaces . length ; n ++ ) { unique ifaces . add ( ifaces [ n ] ) ; } c = c . get superclass ( ) ; } return ( class [ ] ) unique ifaces . to array ( new class [ unique ifaces . size ( ) ] ) ; }	Returns an array containing all the unique interfaces implementedby the argument class c and all its superclasses.
public static boolean is primitive wrapper ( final class type ) { for ( int i = num ; i < primitive wrapper map . length ; i += num ) { if ( type . equals ( primitive wrapper map [ i + num ] ) ) { return bool ; } } return bool ; }	Check if the given class is a primitive wrapper class.
public static object instantiate ( class expected , string property , string default class name ) { string class name = get property ( property , default class name ) ; class clazz = null ; try { clazz = load class ( class name ) ; } catch ( class not found exception e ) { throw new nested runtime exception ( str + class name , e ) ; } object result = null ; try { result = clazz . new instance ( ) ; } catch ( instantiation exception e ) { throw new nested runtime exception ( str + class name , e ) ; } catch ( illegal access exception e ) { throw new nested runtime exception ( str + class name , e ) ; } if ( expected . is assignable from ( clazz ) == bool ) throw new nested runtime exception ( str + class name + str + clazz . get class loader ( ) + str + expected + str + expected . get class loader ( ) ) ; return result ; }	Instantiate a java class object.
public final static method get attribute getter ( class cls , string attr ) throws no such method exception { string buffer buf = new string buffer ( attr . length ( ) + num ) ; buf . append ( str ) ; if ( character . is lower case ( attr . char at ( num ) ) ) { buf . append ( character . to upper case ( attr . char at ( num ) ) ) . append ( attr . substring ( num ) ) ; } else { buf . append ( attr ) ; } try { return cls . get method ( buf . to string ( ) , ( class [ ] ) null ) ; } catch ( no such method exception e ) { buf . replace ( num , num , str ) ; return cls . get method ( buf . to string ( ) , ( class [ ] ) null ) ; } }	Returns attribute's getter method.
public final static method get attribute setter ( class cls , string attr , class type ) throws no such method exception { string buffer buf = new string buffer ( attr . length ( ) + num ) ; buf . append ( str ) ; if ( character . is lower case ( attr . char at ( num ) ) ) { buf . append ( character . to upper case ( attr . char at ( num ) ) ) . append ( attr . substring ( num ) ) ; } else { buf . append ( attr ) ; } return cls . get method ( buf . to string ( ) , new class [ ] { type } ) ; }	Returns attribute's setter method.
private final static class convert to java class ( string name , class loader cl ) throws class not found exception { int array size = num ; while ( name . ends with ( str ) ) { name = name . substring ( num , name . length ( ) - num ) ; array size ++ ; }	Convert a given String into the appropriate Class.
private static string get property ( final string name , final string default value ) { return ( string ) access controller . do privileged ( new privileged action ( ) { public object run ( ) { return system . get property ( name , default value ) ; } } ) ; }	Get a system property.
public static string [ ] get filenames ( final string property name ) throws property exception { string filenames [ ] ;	Get an array of filenames to load.
protected final void maintain ( ) { weak object weak ; while ( ( weak = ( weak object ) queue . poll ( ) ) != null ) { set . remove ( weak ) ; } }	Maintain the elements in the set.
public iterator iterator ( ) { return new iterator ( ) { iterator iter = set . iterator ( ) ; object unknown = new object ( ) ; object next = unknown ; public boolean has next ( ) { if ( next != unknown ) { return bool ; } while ( iter . has next ( ) ) { weak object weak = ( weak object ) iter . next ( ) ; object obj = null ; if ( weak != null && ( obj = weak . get ( ) ) == null ) {	Return an iteration over the elements in the set.
public url create url ( string protocol ) throws url { try { string class name = ( string ) classes . get ( protocol ) ; if ( class name == null ) { throw new url ( str + protocol ) ; } class < ? > clazz = thread . current thread ( ) . get context class loader ( ) . load class ( class name ) ; return ( url ) clazz . new instance ( ) ; } catch ( class not found exception e ) { throw new url ( e . get message ( ) ) ; } catch ( instantiation exception e ) { throw new url ( e . get message ( ) ) ; } catch ( illegal access exception e ) { throw new url ( e . get message ( ) ) ; } }	Create a URL lister for the supplied protocol.
@ suppress warnings ( str ) public set entry set ( ) { final set super set = super . entry set ( bool ) ; return new java . util . abstract set ( ) { private boolean is in group ( map . entry entry ) { string key = ( string ) entry . get key ( ) ; return key . starts with ( basename ) ; } public int size ( ) { iterator iter = super set . iterator ( ) ; int count = num ; while ( iter . has next ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; if ( is in group ( entry ) ) { count ++ ; } } return count ; } public iterator iterator ( ) { return new iterator ( ) { private iterator iter = super set . iterator ( ) ; private object next ; public boolean has next ( ) { if ( next != null ) return bool ; while ( next == null ) { if ( iter . has next ( ) ) { map . entry entry = ( map . entry ) iter . next ( ) ; if ( is in group ( entry ) ) { next = entry ; return bool ; } } else { break ; } } return bool ; } public object next ( ) { if ( next == null ) throw new java . util . no such element exception ( ) ; object obj = next ; next = null ; return obj ; } public void remove ( ) { iter . remove ( ) ; } } ; } } ; }	Returns an entry set for all properties in this group.
protected void add property listener ( final bound property listener listener ) {	Add a bound property listener.
protected boolean remove property listener ( final bound property listener listener ) {	Remove a bound property listener.
public static final boolean is null ( final string value , final boolean trim , final boolean empty ) {	Whether a string is interpreted as the null value.
public static property editor find editor ( final string type name ) throws class not found exception {	Locate a value editor for a given target type.
public static void register editor ( final string type name , final string editor type name ) throws class not found exception { class loader loader = thread . current thread ( ) . get context class loader ( ) ; class < ? > type = loader . load class ( type name ) ; class < ? > editor type = loader . load class ( editor type name ) ; property editor manager . register editor ( type , editor type ) ; }	Register an editor class to be used to editor values of a given target class.
public static object convert value ( string text , string type name ) throws class not found exception , introspection exception {	Convert a string value into the true value for typeName using thePropertyEditor associated with typeName.
public class loader get context class loader ( final thread thread ) { return ( class loader ) access controller . do privileged ( new privileged action ( ) { public object run ( ) { return thread . get context class loader ( ) ; } } ) ; }	Retrieve the context classloader for the given thread.
public static application deadlock exception is ade ( throwable t ) { while ( t != null ) { if ( t instanceof application deadlock exception ) { return ( application deadlock exception ) t ; } else { t = t . get cause ( ) ; } } return null ; }	Detects exception contains is or a ApplicationDeadlockException.
public timeout schedule ( long time , timeout target target ) { if ( cancelled . get ( ) ) throw new illegal state exception ( str ) ; if ( time < num ) throw new illegal argument exception ( str ) ; if ( target == null ) throw new illegal argument exception ( str ) ; return queue . offer ( time , target ) ; }	Schedules a new timeout.
private void do work ( ) { while ( cancelled . get ( ) == bool ) { timeout ext work = queue . take ( ) ;	Timeout worker method.
public static context create subcontext ( context ctx , string name ) throws naming exception { name n = ctx . get name parser ( str ) . parse ( name ) ; return create subcontext ( ctx , n ) ; }	Create a subcontext including any intermediate contexts.
public static object lookup ( string name , class < ? > clazz ) throws exception { initial context ctx = new initial context ( ) ; try { return lookup ( ctx , name , clazz ) ; } finally { ctx . close ( ) ; } }	Lookup an object in the default initial context.
protected static void check object ( context context , string name , object object , class clazz ) throws exception { class object class = object . get class ( ) ; if ( clazz . is assignable from ( object class ) == bool ) { string buffer buffer = new string buffer ( num ) ; buffer . append ( str ) . append ( name ) ; buffer . append ( str ) . append ( context . get environment ( ) ) ; buffer . append ( str ) ; append class info ( buffer , clazz ) ; buffer . append ( str ) ; append class info ( buffer , object . get class ( ) ) ; throw new class cast exception ( buffer . to string ( ) ) ; } }	Checks an object implements the given class.
protected static void append class info ( string buffer buffer , class clazz ) { buffer . append ( str ) . append ( clazz . get name ( ) ) ; buffer . append ( str ) . append ( clazz . get class loader ( ) ) ; buffer . append ( str ) ; class [ ] interfaces = clazz . get interfaces ( ) ; for ( int i = num ; i < interfaces . length ; ++ i ) { if ( i > num ) buffer . append ( str ) ; buffer . append ( str ) . append ( interfaces [ i ] . get name ( ) ) ; buffer . append ( str ) . append ( interfaces [ i ] . get class loader ( ) ) ; } buffer . append ( str ) ; }	Append Class Info.
public transition get transition ( string name ) { transition t = ( transition ) allowed transitions . get ( name ) ; return t ; }	Lookup an allowed transition given its name.
private synchronized void read properties ( ) { try { property file uri = catalog manager . class . get resource ( str + property file ) ; input stream in = catalog manager . class . get resource as stream ( str + property file ) ; if ( in == null ) { if ( ! ignore missing properties ) { system . err . println ( str + property file ) ;	Load the properties from the propertyFile and build theresources from it.
private int query verbosity ( ) { string verb str = system . get property ( p verbosity ) ; if ( verb str == null ) { if ( resources == null ) read properties ( ) ; if ( resources == null ) return default verbosity ; try { verb str = resources . get string ( str ) ; } catch ( missing resource exception e ) { return default verbosity ; } } try { int verb = integer . parse int ( verb str . trim ( ) ) ; return verb ; } catch ( exception e ) { system . err . println ( str + verb str + str ) ; return default verbosity ; } }	Obtain the verbosity setting from the properties.
private boolean query relative catalogs ( ) { if ( resources == null ) read properties ( ) ; if ( resources == null ) return default relative catalogs ; try { string allow = resources . get string ( str ) ; return ( allow . equals ignore case ( str ) || allow . equals ignore case ( str ) || allow . equals ignore case ( str ) ) ; } catch ( missing resource exception e ) { return default relative catalogs ; } }	Obtain the relativeCatalogs setting from the properties.
private string query catalog files ( ) { string catalog list = system . get property ( p files ) ; from properties file = bool ; if ( catalog list == null ) { if ( resources == null ) read properties ( ) ; if ( resources != null ) { try { catalog list = resources . get string ( str ) ; from properties file = bool ; } catch ( missing resource exception e ) { system . err . println ( property file + str ) ; catalog list = null ; } } } if ( catalog list == null ) { catalog list = default catalog files ; } return catalog list ; }	Obtain the list of catalog files from the properties.
public vector get catalog files ( ) { if ( catalog files == null ) { catalog files = query catalog files ( ) ; } string tokenizer files = new string tokenizer ( catalog files , str ) ; vector catalogs = new vector ( ) ; while ( files . has more tokens ( ) ) { string catalog file = files . next token ( ) ; url abs uri = null ; if ( from properties file && ! relative catalogs ( ) ) { try { abs uri = new url ( property file uri , catalog file ) ; catalog file = abs uri . to string ( ) ; } catch ( url mue ) { abs uri = null ; } } catalogs . add ( catalog file ) ; } return catalogs ; }	Return the current list of catalog files.
private boolean query prefer public ( ) { string prefer = system . get property ( p prefer ) ; if ( prefer == null ) { if ( resources == null ) read properties ( ) ; if ( resources == null ) return default prefer public ; try { prefer = resources . get string ( str ) ; } catch ( missing resource exception e ) { return default prefer public ; } } if ( prefer == null ) { return default prefer public ; } return ( prefer . equals ignore case ( str ) ) ; }	Obtain the preferPublic setting from the properties.
private boolean query use static catalog ( ) { string static catalog = system . get property ( p static ) ; if ( use static catalog == null ) { if ( resources == null ) read properties ( ) ; if ( resources == null ) return default use static catalog ; try { static catalog = resources . get string ( str ) ; } catch ( missing resource exception e ) { return default use static catalog ; } } if ( static catalog == null ) { return default use static catalog ; } return ( static catalog . equals ignore case ( str ) || static catalog . equals ignore case ( str ) || static catalog . equals ignore case ( str ) ) ; }	Obtain the static-catalog setting from the properties.
public input source resolve entity ( string public id , string system id ) { string resolved = null ; if ( system id != null && system map . contains key ( system id ) ) { resolved = ( string ) system map . get ( system id ) ; } else if ( public id != null && public map . contains key ( public id ) ) { resolved = ( string ) public map . get ( public id ) ; } if ( resolved != null ) { try { input source i source = new input source ( resolved ) ; i source . set public id ( public id ) ;	SAX resolveEntity API.
public source resolve ( string href , string base ) throws transformer exception { string uri = href ; int hash pos = href . index of ( str ) ; if ( hash pos >= num ) { uri = href . substring ( num , hash pos ) ; } string result = null ; if ( href != null && uri map . contains key ( href ) ) { result = ( string ) uri map . get ( href ) ; } if ( result == null ) { try { url url = null ; if ( base == null ) { url = new url ( uri ) ; result = url . to string ( ) ; } else { url base url = new url ( base ) ; url = ( href . length ( ) == num ? base url : new url ( base url , uri ) ) ; result = url . to string ( ) ; } } catch ( java . net . url mue ) {	Transformer resolve API.
private string make absolute ( string uri ) { if ( uri == null ) { uri = str ; } try { url url = new url ( uri ) ; return url . to string ( ) ; } catch ( url mue ) { string dir = system . get property ( str ) ; string file = str ; if ( dir . ends with ( str ) ) { file = str + dir + uri ; } else { file = str + dir + str + uri ; } try { url file url = new url ( file ) ; return file url . to string ( ) ; } catch ( url mue2 ) {	Attempt to construct an absolute URI.
protected class < ? > resolve class ( object stream class v ) throws io , class not found exception { class loader loader = thread . current thread ( ) . get context class loader ( ) ; string class name = v . get name ( ) ; try {	Use the thread context class loader to resolve the class.
protected void invoke setter ( string value ) { try {	Coerce and invoke the property setter method on the instance.
public static string get local name ( element element ) { string name = element . get tag name ( ) ; if ( name . index of ( str ) > num ) { name = name . substring ( name . index of ( str ) + num ) ; } return name ; }	Returns the "localname" part of a QName, which is the wholename if it has no prefix.
public static string get namespace uri ( node node , string prefix ) { if ( node == null || node . get node type ( ) != node . element node ) { return null ; } if ( prefix . equals ( str ) ) { if ( ( ( element ) node ) . has attribute ( str ) ) { return ( ( element ) node ) . get attribute ( str ) ; } } else { string nsattr = str + prefix ; if ( ( ( element ) node ) . has attribute ( nsattr ) ) { return ( ( element ) node ) . get attribute ( nsattr ) ; } } return get namespace uri ( node . get parent node ( ) , prefix ) ; }	Returns the namespace URI for the specified prefix at thespecified context node.
public static string get namespace uri ( element element ) { string prefix = get prefix ( element ) ; return get namespace uri ( element , prefix ) ; }	Returns the namespace URI for the namespace to which theelement belongs.
public static list list ( enumeration e ) { array list result = new array list ( ) ; while ( e . has more elements ( ) ) result . add ( e . next element ( ) ) ; return result ; }	Create a list from an enumeration.
protected input stream get input stream ( string filename ) throws io { file file = new file ( filename ) ; return new file input stream ( file ) ; }	Get an input stream for the given filename.
protected void load properties ( properties props , string filename ) throws io { if ( filename == null ) throw new null argument exception ( str ) ; if ( filename . equals ( str ) ) throw new illegal argument exception ( str ) ; input stream in = new buffered input stream ( get input stream ( filename ) ) ; props . load ( in ) ; in . close ( ) ; }	Load properties from a file into a properties map.
public map read properties ( ) throws property exception , io { properties props = new properties ( ) ;	Read properties from each specified filename.
public boolean add edge ( edge < t > e ) { if ( e . get from ( ) == this ) outgoing edges . add ( e ) ; else if ( e . get to ( ) == this ) incoming edges . add ( e ) ; else return bool ; return bool ; }	Add an edge to the vertex.
public void add outgoing edge ( vertex < t > to , int cost ) { edge < t > out = new edge < t > ( this , to , cost ) ; outgoing edges . add ( out ) ; }	Add an outgoing edge ending at to.
public void add incoming edge ( vertex < t > from , int cost ) { edge < t > out = new edge < t > ( this , from , cost ) ; incoming edges . add ( out ) ; }	Add an incoming edge starting at from.
public boolean has edge ( edge < t > e ) { if ( e . get from ( ) == this ) return outgoing edges . contains ( e ) ; else if ( e . get to ( ) == this ) return incoming edges . contains ( e ) ; else return bool ; }	Check the vertex for either an incoming or outgoing edgemathcing e.
public boolean remove ( edge < t > e ) { if ( e . get from ( ) == this ) outgoing edges . remove ( e ) ; else if ( e . get to ( ) == this ) incoming edges . remove ( e ) ; else return bool ; return bool ; }	Remove an edge from this vertex.
public edge < t > find edge ( vertex < t > dest ) { for ( edge < t > e : outgoing edges ) { if ( e . get to ( ) == dest ) return e ; } return null ; }	Search the outgoing edges looking for an edge whose'sedge.to == dest.
public edge < t > find edge ( edge < t > e ) { if ( outgoing edges . contains ( e ) ) return e ; else return null ; }	Search the outgoing edges for a match to e.
public int cost ( vertex < t > dest ) { if ( dest == this ) return num ; edge < t > e = find edge ( dest ) ; int cost = integer . max value ; if ( e != null ) cost = e . get cost ( ) ; return cost ; }	What is the cost from this vertext to the dest vertex.
private static void jar ( file src , string prefix , jar info info ) throws io { jar output stream jout = info . out ; if ( src . is directory ( ) ) {	This recursive method writes all matching files and directories tothe jar output stream.
public boolean has next ( ) { for ( ; index < iters . length ; index ++ ) { if ( iters [ index ] != null && iters [ index ] . has next ( ) ) { return bool ; } } return bool ; }	Check if there are more elements.
public void fire event ( object event ) { if ( event == null ) { throw new illegal argument exception ( str ) ; } m task queue . offer ( task . obtain task ( task . code fire event , event , - num ) ) ; if ( ! m queue processed ) process task queue ( ) ; }	Forwards an event into state machine.
private void internal install jvm type provider ( xtext resource set resource set , file tmp class directory , boolean skip index lookup ) { iterable < string > class path entries = concat ( get class path entries ( ) , get source path directories ( ) , as list ( tmp class directory . to string ( ) ) ) ; class path entries = filter ( class path entries , new predicate < string > ( ) { public boolean apply ( string input ) { return ! strings . is empty ( input . trim ( ) ) ; } } ) ; function < string , url > to url = new function < string , url > ( ) { public url apply ( string from ) { try { return new file ( from ) . to uri ( ) . to url ( ) ; } catch ( url e ) { throw new runtime exception ( e ) ; } } } ; iterable < url > class path urls = iterables . transform ( class path entries , to url ) ; log . debug ( str + class path urls ) ; class loader parent class loader ; if ( use current class loader as parent ) { parent class loader = current class loader ; } else { if ( is empty ( boot class path ) ) { parent class loader = class loader . get system class loader ( ) . get parent ( ) ; } else { iterable < url > boot class path urls = iterables . transform ( get boot class path entries ( ) , to url ) ; parent class loader = new boot class loader ( to array ( boot class path urls , url . class ) ) ; } } class loader url class loader = new url ( to array ( class path urls , url . class ) , parent class loader ) ; new classpath type provider ( url class loader , resource set , skip index lookup ? null : indexed jvm type access ) ; resource set . set classpath uri ( url class loader ) ;	Performs the actual installation of the JvmTypeProvider.
public void dispatch on fx thread ( action action ) { if ( platform . is fx application thread ( ) ) { action stream . push ( action ) ; } else { platform . run later ( ( ) -> action stream . push ( action ) ) ; } }	Dispatch the given action.
@ suppress warnings ( str ) < t extends action > event stream < t > get action stream ( class < t > action type ) { return dispatcher . get instance ( ) . get action stream ( ) . filter ( action -> action . get class ( ) . equals ( action type ) ) . map ( action -> ( t ) action ) ; }	A filtered event-stream of actions of the given type.
public stream < t2 < l , r > > strict many to one ( collection < ? extends r > rights ) { return strict many to one ( rights . stream ( ) ) ; }	Strict many to one.
public stream < t2 < l , r > > strict one to one ( collection < ? extends r > rights ) { return strict one to one ( rights . stream ( ) ) ; }	Strict one to one.
@ override public boolean get allow robots ( servlet context servlet context , http servlet request request , http servlet response response , page page ) throws servlet exception , io { return page utils . find allow robots ( servlet context , request , response , page ) ; }	Uses the page settings.
@ then ( str ) public void the instruction generated should be ( string command ) throws throwable { verify ( context . get drink maker ( ) ) . execute command ( eq ( command ) ) ; }	Assert that the generated command matches the specified command.
public int get sum degree ( ) { if ( sum degree < num ) { int sum = num ; for ( word word : words ) { if ( word != null && word . get degree ( ) > - num ) { sum += word . get degree ( ) ; } } sum degree = sum ; } return sum degree ; }	Sum of Degree of Morphemic Freedom of One-Character.
private static map < string , string > superclass args ( map < string , string > args ) { map < string , string > result = new hash map < > ( ) ;	Returns a map which contains only those arguments that the superclass understands.
@ override public void inform ( resource loader loader ) throws io { super . inform ( new jdbc resource loader ( loader , reader , standard charsets . utf 8 ) ) ; }	Load words from jdbc.
protected final void check datasource ( ) {	Check if the datasource is able to provide connections.
@ non null public static < t > list < t > list of ( class < t > clazz ) { assert is not parameterized ( clazz , msg ( str ) ) ; return io . vavr . collection . list . of all ( any . list of ( clazz ) ) ; }	todo add generics checks.
@ suppress warnings ( str ) public boolean connect jdbc on with url and driver and username and password ( string data base id , string url , string driver class name , string username , string password ) throws reflective operation exception { simple driver data source data source = new simple driver data source ( ) ; data source . set url ( url ) ; data source . set driver class ( ( class < driver > ) class . for name ( driver class name ) ) ; data source . set username ( username ) ; data source . set password ( password ) ; this . template map . put ( data base id , new jdbc template ( data source ) ) ; return bool ; }	Registers a database to further execute SQL commands | connect jdbc on | database | with url | url | and driver | driver | and username | username | and | password | .
public boolean run in the sql ( string database , final string sql ) { get database jdbc template ( database ) . update ( sql ) ; return bool ; }	Simply runs a SQL command, used for udpates, inserts which the result doesn't matter. | run in | database | the sql | sql | .
public string query in with sql ( string database , string sql ) { jdbc template template = get database jdbc template ( database ) ; if ( sql != null && ! sql . trim ( ) . to upper case ( ) . starts with ( jdbc fixture . select command prefix ) ) { return objects . to string ( template . update ( sql ) ) ; } list < string > results = template . query for list ( sql , string . class ) ; if ( results == null || results . is empty ( ) ) { return null ; } return results . get ( num ) ; }	Used generally when the result is assigned to a variable | $variable= | query in | database | with sql | sql | .
public query < t > by example ( t obj ) { if ( obj != null ) { return dao . get table helper ( ) . build filter ( this , obj ) ; } return this ; }	Executes a query which returns all rows in the entity tablethat match the fields of the example object having values otherthan the defaults.Calling method MUST close the {.
protected void on upgrade ( final sq db , final int old version , final int new version ) { db . exec sql ( upgrade sql ( old version , new version ) ) ; }	Upgrades the table that represents the associated entity.
public boolean backup ( sq db , context ctx , string suffix ) { try { new csv table writer ( this ) . dump to csv ( ctx , db , suffix ) ; } catch ( sql e ) { if ( e . get message ( ) . contains ( str ) ) { log . w ( tag , str + this . get table name ( ) + str ) ; } } catch ( file not found exception e ) { e . print stack trace ( ) ; return bool ; } return bool ; }	Backs up the current table to a CSV file.
public void restore ( sq db , context ctx , string suffix ) { new csv table reader ( this ) . import from csv ( ctx , db , suffix ) ; }	Restores a table from a text file.
public void set empty text ( char sequence empty text ) { if ( m list view != null ) { view empty view = m list view . get empty view ( ) ; if ( empty text instanceof text view ) { ( ( text view ) empty view ) . set text ( empty text ) ; } } }	The default content for this Activity has a TextView that is shown whenthe list is empty.
public int dump to csv ( context ctx , sq db , string suffix ) throws file not found exception { int num rows written = num ; cursor c ; string filename = get csv filename ( db . get path ( ) , db . get version ( ) , suffix ) ; c = db . query ( th . get table name ( ) , null , null , null , null , null , null ) ; file output stream fos ; fos = ctx . open file output ( filename , num ) ; print writer print writer = new print writer ( fos ) ; string header row = build header row ( ) ; print writer . println ( header row ) ; for ( boolean has item = c . move to first ( ) ; has item ; has item = c . move to next ( ) ) { string csv = build csv row ( c ) ; print writer . println ( csv ) ; num rows written ++ ; } print writer . flush ( ) ; print writer . close ( ) ; return num rows written ; }	Dumps a database table to a CSV file in the default location.Returns the number of rows written to the file.
public static string unescape csv ( string str ) { if ( str == null ) return null ; if ( ! ( str . char at ( num ) == quote && str . char at ( str . length ( ) - num ) == quote ) ) return str ; string quoteless = str . substring ( num , str . length ( ) - num ) ; return quoteless . replace ( quote str + quote str , quote str ) ; }	Removes enclosing quotes and unescapes double quotes.
public static list < string > get values ( string csv row ) { list < string > values = new array list < string > ( ) ; string reader in = new string reader ( csv row ) ; string value ; try { value = next value ( in ) ; while ( bool ) { values . add ( value ) ; value = next value ( in ) ; } } catch ( io e ) {	Returns values from a CSV String.
public static map < string , string > get as map ( string csv pairs ) { map < string , string > map = new hash map < string , string > ( ) ; string [ ] pairs = csv pairs . split ( str ) ; for ( string pair : pairs ) { string [ ] split = pair . split ( str ) ; map . put ( split [ num ] , split [ num ] ) ; } return map ; }	Parses a CSV row containing name=value pairs.
public static string map to csv ( map < string , string > map ) { string builder sb = new string builder ( ) ; for ( string key : map . key set ( ) ) { sb . append ( str ) ; string val = map . get ( key ) ; sb . append ( key + str + val ) ; } return sb . to string ( ) . substring ( num ) ; }	Returns a String containing a comma-separated listof name=value pairs from a map.
public static string join ( final list < string > list ) {	Joins items of a text list, separating items by comma.
public static string join ( final string [ ] list ) {	Joins items of a text array, separating items by comma.
public static database model read from index ( buffered reader reader , processor logger logger ) throws io { string db info = reader . read line ( ) ; logger . info ( db info ) ; map < string , string > props = csv utils . get as map ( db info ) ; string db name = props . get ( str ) ; int db version = integer . parse int ( props . get ( str ) ) ; string helper class = props . get ( str ) ; database model db model = new database model ( db name , db version , helper class ) ;	Populate the model of a database and its associated tables froma file in support of incremental compilation.
public void write to index ( print writer out ) { out . println ( storm environment . begin database ) ; map < string , string > db map = new hash map < string , string > ( ) ; db map . put ( str , this . get db name ( ) ) ; db map . put ( str , string . value of ( this . get db version ( ) ) ) ; db map . put ( str , this . get qualified class name ( ) ) ; string db info = csv utils . map to csv ( db map ) ; out . println ( db info ) ;	Write the database info and associated tables to a filein support of incremental compilation.
private void inspect id ( ) { if ( entity model . get id field ( ) == null ) {	Verifies that the entity has exactly one id field of type long.
private static base dao model get base dao class ( entity entity ) { string qualified name = sq . class . get name ( ) ; type mirror type mirror = get base dao type mirror ( entity ) ; if ( type mirror != null ) qualified name = type mirror . to string ( ) ; return new base dao model ( qualified name ) ; }	Builds a BaseDaoModel from the class passed as attribute baseDaoClass of the annotation Entity.
public string get bind type ( ) { string bind type = get converter ( ) . get bind type ( ) . name ( ) ; return bind type . char at ( num ) + bind type . to lower case ( ) . substring ( num ) ; }	Morph bind type like INT ==> Int so it can be used in a Cursor getXxxmethod name.
public int import from csv ( context ctx , sq db , string suffix ) { string filename = get csv filename ( db . get path ( ) , db . get version ( ) , suffix ) ; file input stream file input stream ; try { file input stream = ctx . open file input ( filename ) ; return import from csv ( db , file input stream ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; return - num ; } }	Attempts to import a database table from a CSV file in the defaultlocation.
public boolean backup all tables to csv ( context ctx , sq db , string suffix ) { boolean all succeeded = bool ; for ( table helper table : get table helpers ( ) ) { all succeeded &= table . backup ( db , ctx , suffix ) ; } return all succeeded ; }	Backup all tables to CSV files, one per table.
public void restore all tables from csv ( context ctx , sq db , string suffix ) { for ( table helper table : get table helpers ( ) ) { table . restore ( db , ctx , suffix ) ; } }	Restore all tables from CSV files, one per table.
void write index ( filer filer ) { standard location location = standard location . source output ; file object index file ; try { index file = filer . create resource ( location , str , env file ) ; output stream fos = index file . open output stream ( ) ; print writer out = new print writer ( fos ) ;	Write the current model state to a file in support of incrementalcompilation.
public query create query ( final entity manager manager ) { if ( manager == null ) { throw new null pointer exception ( str ) ; } final query query = manager . create query ( render ( ) ) ; for ( parameter < ? > parameter : parameters ) { parameter . apply ( query ) ; } return query ; }	Returns a JPA Query with all previously specified parameters added.
public < t > typed query < t > create query ( final entity manager manager , class < t > type ) { if ( manager == null ) { throw new null pointer exception ( str ) ; } typed query < t > result = manager . create query ( render ( ) , type ) ; for ( parameter < ? > parameter : parameters ) { parameter . apply ( result ) ; } return result ; }	Returns a JPA TypedQuery with all previously specified parameters added.
public string render ( ) { string builder query = new string builder ( ) ; if ( ! select . is empty ( ) ) { query . append ( str ) ; query . append ( string utils . join ( select . items ) ) ; } if ( ! delete from . is empty ( ) ) { query . append ( str ) ; query . append ( delete from . item ) ; } if ( ! update . is empty ( ) ) { query . append ( str ) ; query . append ( update . item ) ; if ( ! set . is empty ( ) ) { query . append ( str ) ; query . append ( string utils . join ( set . items ) ) ; } } if ( ! from . is empty ( ) ) { query . append ( str ) ; query . append ( string utils . join ( from . items ) ) ; } if ( ! where . is empty ( ) ) { query . append ( str ) ; query . append ( where . render ( ) ) ; } if ( ! group . is empty ( ) ) { query . append ( str ) ; query . append ( string utils . join ( group . items ) ) ; } if ( order . is empty ( ) == bool ) { query . append ( str ) ; query . append ( string utils . join ( order . items ) ) ; } return query . to string ( ) ; }	Renders this object as JPQL query string.
public int delete ( long id ) { if ( id != null ) { return get writable db ( ) . delete ( th . get table name ( ) , th . get id col ( ) + str , new string [ ] { id . to string ( ) } ) ; } return num ; }	Deletes a single row by ID.
public long save ( t obj ) { if ( th . get id ( obj ) == num ) { return insert ( obj ) ; } long updated = update ( obj ) ; if ( updated == num ) { return num ; } return - num ; }	Insert or update.
public long update ( t obj ) { content values cv = th . get editable values ( obj ) ; long id = th . get id ( obj ) ; int num rows updated = get writable db ( ) . update ( th . get table name ( ) , cv , th . get id col ( ) + str , new string [ ] { id . to string ( ) } ) ; return num rows updated ; }	Update all columns for the row having the ID matchingthe provided entity's ID.
public < v extends object > where items not in ( final string expression , final v ... array ) { items . add ( new where in ( builder ( ) , expression , bool , array ) ) ; return this ; }	Adds a "NOT IN" predicate.
public query builder subquery ( final string lhs predicate ) { final where subquery subquery = new where subquery ( builder ( ) , lhs predicate ) ; items . add ( subquery ) ; return subquery . get query builder ( ) ; }	Adds a sub-query predicate.
stack255 next active stack ( ) { active stack = ( active stack + num ) % stacks . size ( ) ; return ( stack255 ) stacks . get ( active stack ) ; }	Makes the next intentions stack active using a round robin scheme.
stack255 get empty intention stack ( ) {	Returns an empty intentions stack.Creates a new intentions stack and adds it to the list of stacks if needed.
public void add ( plan plan , set < belief > plan bindings ) { if ( plan == null ) { return ; }	Add the set of bindings for a given plan to this store.
public plan select plan ( plan selection policy policy ) { plan plan = null ; int index = num ; switch ( policy ) { case first : case last : plan [ ] plans = bindings . key set ( ) . to array ( new plan [ num ] ) ; plan = ( policy == plan selection policy . first ) ? plans [ num ] : plans [ plans . length - num ] ; index = ( policy == plan selection policy . first ) ? num : plans . length - num ; set plan variables ( plan . get agent ( ) , plan , bindings . get ( plan ) , index ) ; break ; case random : plan = select plan at random ( ) ; break ; default :	Selects a plan instance from the set of plan bindings, using the given policy.
private plan select plan at random ( ) { plan plan = null ; set < belief > vars = null ; int index = rand . next int ( size ( ) ) ; int idx = num ; boolean bindings exist = bool ; for ( plan p : bindings . key set ( ) ) { vars = bindings . get ( p ) ; bindings exist = ( vars != null && ! vars . is empty ( ) ) ; idx += bindings exist ? vars . size ( ) : num ; if ( idx > index ) { plan = p ; if ( bindings exist ) { index = index - ( idx - vars . size ( ) ) ; set plan variables ( plan . get agent ( ) , plan , vars , index ) ; } break ; } } return plan ; }	Selects a plan instance at random from the set of plan bindings.
private final void set plan variables ( agent agent , plan plan instance , set < belief > results , int choice ) { if ( agent == null || plan instance == null ) { return ; } belief belief = get result at index ( results , choice ) ; if ( belief == null ) { return ; } object [ ] tuple = belief . get tuple ( ) ; if ( tuple == null ) { return ; } int index = num ; hash map < string , object > vars = new hash map < string , object > ( ) ; for ( object o : belief . get tuple ( ) ) { try { string fieldname = a . get field name ( agent . get id ( ) , belief . get beliefset ( ) , index ) ; vars . put ( fieldname , o ) ; } catch ( belief base exception e ) { log . error ( str + agent . get id ( ) + str + e . get message ( ) ) ; } index ++ ; } plan instance . set plan variables ( vars ) ; }	Sets the plan instance variables using the given results set.
private belief get result at index ( set < belief > results , int index ) { belief belief = null ; if ( ! ( results == null || index < num || index >= results . size ( ) ) ) { int idx = num ; for ( belief b : results ) { if ( idx == index ) { belief = b ; break ; } idx ++ ; } } return belief ; }	Gets the result at the given index from the results set.
public byte [ ] get parents ( ) { if ( parents == null ) { return null ; } byte [ ] arr = new byte [ parents . length ] ; system . arraycopy ( parents , num , arr , num , arr . length ) ; return arr ; }	Gets the parents of this object in the Goal-Plan tree.
public byte [ ] get children ( ) { if ( children == null ) { return null ; } byte [ ] arr = new byte [ children . length ] ; system . arraycopy ( children , num , arr , num , arr . length ) ; return arr ; }	Gets all the children of this object in the Goal-Plan tree.
public static byte [ ] grow ( byte [ ] bytes , int increment ) { if ( bytes == null ) { return new byte [ num ] ; } byte [ ] temp = new byte [ bytes . length + increment ] ; system . arraycopy ( bytes , num , temp , num , bytes . length ) ; return temp ; }	Grows the given array by the given size.
public static logger create logger ( string name , level level , string file ) { logger context lc = ( logger context ) logger factory . get i ( ) ; pattern layout encoder ple = new pattern layout encoder ( ) ; ple . set pattern ( str ) ; ple . set context ( lc ) ; ple . start ( ) ; file appender < i > file appender = new file appender < i > ( ) ; file appender . set file ( file ) ; file appender . set encoder ( ple ) ; file appender . set append ( bool ) ; file appender . set context ( lc ) ; file appender . start ( ) ; logger = ( logger ) logger factory . get logger ( name ) ; logger . detach and stop all appenders ( ) ;	Creates a new logger.
public void step ( ) { if ( body == null || body . length == num || index < num || index >= body . length ) { return ; } body [ index ++ ] . step ( ) ; }	Performs a single step of this plan, i.e., progresses this intention.
public void set goals ( byte [ ] arr ) { if ( arr == null ) { goals = null ; return ; } goals = new byte [ arr . length ] ; system . arraycopy ( arr , num , goals , num , goals . length ) ; }	Sets the list of goals for this agent.
static void pause for user input ( ) { system . out . println ( str ) ; scanner in = new scanner ( system . in ) ; in . next line ( ) ; in . close ( ) ; }	Waits for user to press a key before continuing. Useful for connecting to a profiler.
public static void init intention selection pools ( int nagents , int ncores ) { main . poolsize = ( nagents > ncores ) ? ( nagents / ncores ) : num ; main . npools = ( nagents > ncores ) ? ncores : nagents ; }	Initialises the intention selection pools.
static void init intention selection threads ( config config ) { int ncores = config . get num threads ( ) ; main . intention selectors = new intention selector [ ncores ] ; for ( int i = num ; i < main . npools ; i ++ ) { main . intention selectors [ i ] = new intention selector ( i , config . get random seed ( ) ) ; } }	Starts the intention selection threads that each handle a pool of agents.
static void start intention selection threads ( ) { for ( int i = num ; i < main . npools ; i ++ ) { thread thread = new thread ( main . intention selectors [ i ] ) ; thread . set name ( str + i ) ; thread . start ( ) ;	Starts the intention selection threads.
static void shutdown intention selection threads ( ) { for ( int i = num ; i < main . npools ; i ++ ) { main . intention selectors [ i ] . shutdown ( ) ; } }	Stops the intention selection threads.
public static void register extension ( jill extension extension ) { if ( extension != null ) { global state . event handlers . add ( extension ) ; main . logger . info ( str + extension ) ; } else { main . logger . warn ( str ) ; } }	Registers a new Jill extension.
public static void reset ( ) { agent types = new a ( str , num , num ) ; goal types = new a ( str , num , num ) ; plan types = new a ( str , num , num ) ; agents = null ; beliefbase = null ; event handlers = new hash set < jill extension > ( ) ; }	Resets the global state.
public static boolean load agent ( string class name , int num , a agents ) {	Creates a given number of agents of a given Class, and adds the newly created agents to thegiven store.
private static boolean process plans for goal ( goal type gtype , string [ ] plans ) { for ( int j = num ; j < plans . length ; j ++ ) {	Loads the given plan classes and sets up parent-child links with the given goal type.
private static void create agents in catalog ( a agents , agent type atype , class < ? > aclass , int num ) { int added = num ; try { for ( int i = num ; i < num ; i ++ ) {	Creates the specified number of agent instances of the given type and adds them to the catalog.
private static class < ? > load class ( string class name , class < ? > class type ) { class < ? > aclass = null ; try { aclass = class . for name ( class name ) ; } catch ( class not found exception e ) { logger . error ( str + class name , e ) ; return null ; } if ( ! class type . is assignable from ( aclass ) ) { logger . error ( str + class name + str + class type . get name ( ) ) ; return null ; } logger . info ( str + class name + str + class type . get name ( ) ) ; return aclass ; }	Loads the class of given name and type.
public static jill extension load extension ( string class name ) { jill extension extension = null ; class < ? > eclass ; try {	Loads a Jill extension.
public static boolean is name equal ( a obj1 , a obj2 ) {	Checks if two objects have the same name.
public static string usage ( ) { return global constant . app header + str + str + main . class . get name ( ) + str + str + str + str + str + str + str + str + global constant . exit on idle + str + str + str + str + global constant . plan selection policy + str + str + str + global constant . plan instances limit + str ; }	Returns a usage string for the Jill command line arguments.
public static void parse ( string [ ] args ) { for ( int i = num ; args != null && i < args . length ; i ++ ) {	Parses the given command line arguments.
private static void parse argument with option ( string arg , string opt ) { switch ( arg ) { case str : config = load config from string ( opt ) ; break ; case str : config = load config from file ( opt ) ; break ; case str : global constant . exit on idle = boolean . parse boolean ( opt ) ; break ; case str : try { global constant . plan selection policy = global constant . plan selection policy . value of ( opt ) ; } catch ( illegal argument exception e ) { abort ( str + opt + str ) ; } break ; case str : try { global constant . plan instances limit = integer . parse int ( opt ) ; } catch ( number format exception e ) { abort ( str + opt + str ) ; } break ; default :	Parses the given command line argument and associated option.
public static void do eval ( belief base bb , int agent id , string query ) throws belief base exception { final long t0 = system . current time millis ( ) ; bb . eval ( agent id , query ) ; final long t1 = system . current time millis ( ) ; log . info ( str + agent id + str + query + str + log . formatted duration ( t0 , t1 ) ) ; }	Evaluates the given query on the given belief base for the agent.
public a get ( int index ) { if ( index >= num && index < objects . length ) { return objects [ index ] ; } return null ; }	Gets the object at the given index of the catalog.
public a find ( string name ) { for ( int i = num ; i < nextid ; i ++ ) { if ( objects [ i ] . get name ( ) . equals ( name ) ) { return objects [ i ] ; } } return null ; }	Find an object by name.
public void push ( a obj ) { if ( obj == null || obj . get id ( ) != global constant . nullid ) { return ; }	Pushes a new object to the top of the catalog.
public object get ( int idx ) { int index = idx & num ; if ( is empty ( ) ) {	Gets the object at the given index in the catalog.
public boolean push ( object obj ) {	Pushes an object on to the top of the stack.
public object pop ( ) { if ( is empty ( ) ) { return null ; } size -- ; object obj = objects [ size ] ; objects [ size ] = null ; return obj ; }	Pops the Object at the top of the stack.
public static string get type ( object obj ) { if ( obj == null ) { return null ; } string type = null ; if ( obj instanceof string || obj instanceof integer || obj instanceof double || obj instanceof boolean ) { type = obj . get class ( ) . get name ( ) ; } return type ; }	Gets the type of the given object.
private static boolean match ( belief belief , a query ) { assert ( belief != null ) ; assert ( query != null ) ; if ( belief . get beliefset ( ) != query . get beliefset ( ) ) { return bool ; } switch ( query . get op ( ) ) { case eq : object lhs = belief . get tuple ( ) [ query . get field ( ) ] ; object rhs = query . get value ( ) ;	Checks if the given query run on the given belief returns a match.
public static void main ( string [ ] args ) throws belief base exception { belief base bb = new a ( num , num ) ; bb . eval ( num , str ) ; console console = system . console ( ) ; if ( console == null ) { system . err . println ( str ) ; system . exit ( num ) ; } while ( bool ) { pattern pattern = pattern . compile ( console . read line ( str ) ) ; matcher matcher = pattern . matcher ( console . read line ( str ) ) ; boolean found = bool ; while ( matcher . find ( ) ) { console . format ( str + str + str , matcher . group ( ) , matcher . start ( ) , matcher . end ( ) ) ; found = bool ; } if ( ! found ) { console . format ( str ) ; } } }	Sample program to test pattern matching.
public static byte [ ] to bytes ( string str ) { if ( str == null ) { return new byte [ num ] ; } byte [ ] val = null ; try { val = str . get bytes ( charset ) ; } catch ( unsupported encoding exception e ) {	Encodes the String str into a sequence of bytes using the character set specified in CHARSET,storing the result into a new byte array.
private void post ( stack255 stack , goal goal ) { synchronized ( stack ) { logger . debug ( str , log . log prefix ( get id ( ) ) , goal . get class ( ) . get simple name ( ) ) ; stack . push ( goal ) ; main . set agent idle ( get id ( ) , bool ) ; } main . flag message to ( main . poolid ( get id ( ) ) ) ; }	Push the given goal to the given stack.
public boolean send ( int id , goal msg ) { a obj = agents . get ( id ) ; if ( obj == null ) { logger . warn ( str , log . log prefix ( get id ( ) ) , id ) ; return bool ; } logger . debug ( str , log . log prefix ( get id ( ) ) , msg . get class ( ) . get simple name ( ) , id ) ; ( ( agent ) obj ) . post ( msg ) ; return bool ; }	Send a message to an agent.
public boolean send ( string name , goal msg ) { a obj = agents . find ( name ) ; if ( obj == null ) { logger . warn ( str , log . log prefix ( get id ( ) ) , name ) ; return bool ; } ( ( agent ) obj ) . post ( msg ) ; return bool ; }	Send a message to this agent.
public byte [ ] get goals ( ) { byte [ ] arr = new byte [ goals . length ] ; system . arraycopy ( goals , num , arr , num , arr . length ) ; return arr ; }	Returns this agent's top level goals.
public void create belief set ( string name , belief set field [ ] fields ) throws belief base exception { beliefbase . create belief set ( get id ( ) , name , fields ) ; }	Creates a new belief set with the given fields.
public void add belief ( string beliefset name , object ... tuple ) throws belief base exception { beliefbase . add belief ( get id ( ) , beliefset name , tuple ) ; }	Adds a new belief to the specified belief set.
public boolean eval ( string query ) throws belief base exception { boolean result = beliefbase . eval ( get id ( ) , query ) ; lastresult = ( result ) ? beliefbase . query ( get id ( ) , query ) : new hash set < belief > ( ) ; return result ; }	Evaluates the given query against this agent's belief base.
public void suspend ( boolean val ) { main . set agent idle ( get id ( ) , val ) ; main . flag message to ( main . poolid ( get id ( ) ) ) ; }	Forces this agent to enter an idle state irrespective of whether it has any active intentionsor not.
public belief set field get field by name ( string name ) { belief set field field = null ; for ( int i = num ; i < fields . length ; i ++ ) { if ( name . equals ( fields [ i ] . get name ( ) ) ) { field = fields [ i ] ; break ; } } return field ; }	Gets the field of this belief set that has the given name.
private void register neighbours ( random rand , int count ) throws belief base exception { int size = ( count < num ) ? num : count ; for ( int i = num ; i < size ; i ++ ) { boolean male = ( rand . next double ( ) < num ) ? bool : bool ; this . add belief ( beliefset , build name ( male ) , male ? str : str ) ; } }	Helper function to add beliefs about neighbours.
private static string build name ( boolean male ) { string builder name = new string builder ( ) ; name . append ( male ? males [ rand . next int ( males . length ) ] : females [ rand . next int ( females . length ) ] ) . append ( str ) . append ( middle [ rand . next int ( middle . length ) ] ) . append ( str ) . append ( surnames [ rand . next int ( surnames . length ) ] ) ; return name . to string ( ) ; }	Builds a new name.
public void run ( ) { set < integer > to remove = new hash set < integer > ( ) ; do { boolean idle = bool ;	Runs this intentions selction thread.
private boolean is stack valid ( agent agent , stack255 agent execution stack ) { if ( agent execution stack == null ) { return bool ; } final int es size = agent execution stack . size ( ) ; logger . trace ( str , log . log prefix ( agent . get id ( ) ) , es size ) ; if ( es size == num ) { return bool ; } if ( es size >= num ) { logger . error ( str , log . log prefix ( agent . get id ( ) ) ) ; return bool ; } return bool ; }	Checks if this agent's execution stack is valid.
private void remove finished agents ( set < integer > to remove ) { if ( ! to remove . is empty ( ) ) { for ( int i : to remove ) { active agents . remove ( i ) ; } to remove . clear ( ) ; } }	Removes the given list of agents from the list of active agents.
private boolean manage goal ( int agent index , agent agent , stack255 agent execution stack , goal node ) {	Manages the goal at the top of the execution stack of an agent.
public void shutdown ( ) { synchronized ( lock ) { logger . debug ( str , poolid ) ; shutdown = bool ; has message = bool ; lock . notify ( ) ;	Terminates this intention selector thread.
public void set agent idle ( int agent id , boolean idle ) {	and this thread is still iterating over activeagents.
public boolean move ( int pin a , int pin b ) {	Move a disc from pin A to pin B.
public static boolean init ( config config ) {	Initialises the Jill engine.
public static void wait until idle ( ) {	Blocks until all agents have finished executing plans and have gone idle.
public static void finish ( ) {	Termiantes the Jill engine.
public static boolean are pools idle ( ) { boolean idle = bool ; for ( int i = num ; i < npools ; i ++ ) { idle &= ( intention selectors [ i ] == null ) || intention selectors [ i ] . is idle ( ) ; } return idle ; }	Checks if the system is idle, i.e., all the agents pools are idle.
public static int poolid ( int agentid ) { int poolid = agentid / poolsize ; if ( poolid + num > npools ) { poolid = npools - num ; } return poolid ; }	Gets the ID of the intention selection pool to which the given agent belongs.
@ suppress warnings ( str ) public < e > expression < e > pick expression ( ) { preconditions . check state ( this . expression != null , str ) ; expression < e > result = ( expression < e > ) this . expression ; expression = null ; return result ; }	Returns the expression currently active in the building context.
public < e > void set expression ( expression < e > expression ) { preconditions . check state ( this . expression == null , str ) ; this . expression = expression ; }	Sets the expression currently active in the building context.
public static expression < ? > join ( string attribute , from < ? , ? > from ) { expression < ? > path ; try { string [ ] properties = attribute . split ( str ) ; if ( properties . length > num ) { path = join recursively ( properties , find or create join ( properties [ num ] , from ) , num ) . get ( properties [ properties . length - num ] ) ; } else { path = from . get ( properties [ num ] ) ; } } catch ( illegal argument exception e ) { throw seed exception . wrap ( e , jpa error code . unable to create jpa join for specification ) . put ( str , attribute ) ; } return path ; }	Create a new join or find an existing join on the specified attribute.
private static join < ? , ? > join recursively ( string [ ] properties , join < ? , ? > join , int index ) { if ( index < properties . length - num ) { return join recursively ( properties , find or create join ( properties [ index ] , join ) , index + num ) ; } else { return join ; } }	Join recursively using the split property path.
private static join < ? , ? > find or create join ( string property , from < ? , ? > from ) { for ( join < ? , ? > root join : from . get joins ( ) ) { if ( root join . get attribute ( ) . get name ( ) . equals ( property ) ) { return root join ; } } return from . join ( property ) ; }	Find an existing join for the property or create a new join.
public boolean is end reached ( ) { if ( to == null || from == null ) {	Indicates whether the response reaches the end of the elements availableon the server.
private static upload stream get upload stream ( http servlet request http request , type [ ] formal parameters ) throws io { form iterator form = new form iterator impl ( http request ) ; if ( ! form . has next ( ) ) { throw new illegal argument exception ( str ) ; } part part = form . next ( ) ; if ( ! ( part instanceof upload stream ) ) { throw new illegal argument exception ( str , part . get name ( ) ) ; } return ( upload stream ) part ; }	Get upload stream from given HTTP request.
@ override protected void handle request ( request context context ) throws io { http servlet request http request = context . get request ( ) ; http servlet response http response = context . get response ( ) ; arguments reader arguments reader = null ; object value = null ; spi method = null ; try { method = rest methods . get ( key ( http request . get path info ( ) ) ) ; if ( method == null ) { throw new no such method exception ( ) ; } type [ ] formal parameters = method . get parameter types ( ) ; arguments reader = arguments reader factory . get arguments reader ( http request , formal parameters ) ; object [ ] arguments = arguments reader . read ( http request , formal parameters ) ; object instance = container . get instance ( method . get declaring class ( ) ) ; value = method . invoke ( instance , arguments ) ; } catch ( authorization exception e ) { send unauthorized ( context ) ; return ; } catch ( no such method exception e ) { send not found ( context , e ) ; return ; } catch ( illegal argument exception e ) {	Handle request for a REST resource.
public boolean has parameter ( string name , string value ) { params . not null or empty ( name , str ) ; params . not null or empty ( value , str ) ; return value . equals ( parameters . get ( name ) ) ; }	Test if content type has a parameter with requested name and value.
public string get parameter ( string name ) { params . not null or empty ( name , str ) ; return parameters . get ( name ) ; }	Get parameter value or null if parameter does not exist.
private static map < string , string > parse parameters ( string expression ) {	Parse content type parameters.
@ override public void config ( config config ) throws exception { log . trace ( str ) ; log . debug ( str , transaction manager . get class ( ) ) ; transaction manager . config ( config ) ; }	Configure underlying transaction manager.
protected final generated file get target file ( final string artifact name , final string filename , final string log info ) { final folder folder = get generator config ( ) . find target folder ( artifact name ) ; final file dir = folder . get canonical dir ( ) ; final file file = new file ( dir , filename ) ;	Returns the target file for a given artifact type and filename.
protected final void write ( @ not null final generated artifact artifact ) throws generate exception { contract . require arg not null ( str , artifact ) ; final generated file gen file = get target file ( artifact . get name ( ) , artifact . get path and name ( ) , null ) ; if ( gen file . is skip ( ) ) { log . debug ( str , gen file , artifact ) ; } else { log . debug ( str , gen file , artifact ) ; try { final output stream out = new buffered output stream ( new file output stream ( gen file . get tmp file ( ) ) ) ; try { out . write ( artifact . get data ( ) ) ; } finally { out . close ( ) ; } gen file . persist ( ) ; } catch ( final io ex ) { throw new generate exception ( str + artifact + str + artifact . get path and name ( ) + str , ex ) ; } } }	Writes a generated artifact to a file.
@ override public void post process instance ( spi managed class , object instance ) { config config = managed class . get config ( ) ; if ( config == null ) { return ; } list < config > fields = config . find children ( str ) ; if ( ! fields . is empty ( ) && ! instance type . pojo . equals ( managed class . get instance type ( ) ) ) { throw new bug error ( str , instance type . pojo ) ; } for ( config field : fields ) { classes . set field value ( instance , field . get attribute ( str ) , field . get attribute ( str ) ) ; } }	Initialize instance fields from managed class configuration object.
private static constructor < ? > get declared constructor ( class < ? > implementation class ) { if ( implementation class == null ) { return null ; } constructor < ? > [ ] declared constructors = ( constructor < ? > [ ] ) implementation class . get declared constructors ( ) ; if ( declared constructors . length == num ) { throw new bug error ( str , implementation class ) ; } constructor < ? > constructor = null ; for ( constructor < ? > declared constructor : declared constructors ) {	Get implementation class constructor.
private string build string representation ( config descriptor ) { string builder builder = new string builder ( ) ; builder . append ( descriptor . get name ( ) ) ; builder . append ( str ) ; if ( implementation class != null ) { builder . append ( implementation class . get name ( ) ) ; builder . append ( str ) ; } for ( class < ? > interface class : interface classes ) { builder . append ( interface class . get name ( ) ) ; builder . append ( str ) ; } builder . append ( instance type ) ; builder . append ( str ) ; builder . append ( instance scope ) ; builder . append ( str ) ; builder . append ( remotely accessible ? str : str ) ; if ( implementation url != null ) { builder . append ( str ) ; builder . append ( implementation url ) ; } return builder . to string ( ) ; }	Build and return this managed class string representation.
private static method get interface method ( method method ) { for ( class < ? > interface class : method . get declaring class ( ) . get interfaces ( ) ) { try { return interface class . get method ( method . get name ( ) , method . get parameter types ( ) ) ; } catch ( no such method exception unused ) { } } return method ; }	Get Java reflective method from interface.
private static class < ? > type ( field field ) { if ( types . is kind of ( field . get type ( ) , list . class ) ) {	Return field class or actual type argument if given field is a list.
@ suppress warnings ( str ) protected static object get dependency value ( spi host managed class , class < ? > type ) { stack < class < ? > > stack trace = dependencies stack . get ( ) ; if ( stack trace == null ) { stack trace = new stack < > ( ) ; dependencies stack . set ( stack trace ) ; } spi container = host managed class . get container ( ) ; if ( stack trace . contains ( type ) ) { try {	Get dependency value of requested type.
public final void persist ( ) { if ( persisted ) {	Compares the content of the temporary file with the possibly existing target file.
public final void set default link ( string rel , string ... hrefs ) { if ( hrefs == null || hrefs . length == num ) { default links . remove ( rel ) ; } else { default links . put ( rel , stream ( hrefs ) . map ( uri :: resolve ) . collect ( to set ( ) ) ) ; } }	Registers one or more default links for a specific relation type.
public final void set default link template ( string rel , string href ) { if ( href == null ) { default link templates . remove ( rel ) ; } else { default link templates . put ( rel , href ) ; } }	Registers a default link template for a specific relation type.
@ suppress warnings ( str ) private void handle links ( http response response ) { map < string , map < uri , string > > links = new hash map < > ( ) ; map < string , string > link templates = new hash map < > ( ) ; handle header links ( response , links , link templates ) ; http entity entity = response . get entity ( ) ; if ( entity != null ) { header content type = entity . get content type ( ) ; if ( ( content type != null ) && content type . get value ( ) . starts with ( str ) ) { try { handle body links ( serializer . read tree ( entity . get content ( ) ) , links , link templates ) ; } catch ( io ex ) { throw new runtime exception ( ) ;	Handles links embedded in an HTTP response.
protected void handle header links ( http response response , map < string , map < uri , string > > links , map < string , string > link templates ) { get link headers ( response ) . for each ( header -> { if ( header . get rel ( ) == null ) { return ; } if ( header . is templated ( ) ) { link templates . put ( header . get rel ( ) , header . get href ( ) ) ; } else { get or add ( links , header . get rel ( ) ) . put ( uri . resolve ( header . get href ( ) ) , header . get title ( ) ) ; } } ) ; }	Handles links embedded in HTTP response headers.
protected void handle body links ( json node json body , map < string , map < uri , string > > links , map < string , string > link templates ) { if ( json body . get node type ( ) != json node type . object ) { return ; } json node links node = json body . get ( str ) ; if ( links node == null ) { links node = json body . get ( str ) ; } if ( links node == null ) { return ; } links node . fields ( ) . for each remaining ( x -> { string rel = x . get key ( ) ; map < uri , string > links for rel = get or add ( links , rel ) ; switch ( x . get value ( ) . get node type ( ) ) { case array : x . get value ( ) . for each ( subobj -> { if ( subobj . get node type ( ) == json node type . object ) { parse link object ( rel , ( object node ) subobj , links for rel , link templates ) ; } } ) ; break ; case object : parse link object ( rel , ( object node ) x . get value ( ) , links for rel , link templates ) ; break ; } } ) ; }	Handles links embedded in JSON response bodies.
private void parse link object ( string rel , object node obj , map < uri , string > links for rel , map < string , string > link templates ) { json node href = obj . find value ( str ) ; if ( href == null ) { return ; } json node templated = obj . find value ( str ) ; if ( templated != null && templated . is boolean ( ) && templated . as boolean ( ) ) { link templates . put ( rel , href . as text ( ) ) ; } else { json node title = obj . find value ( str ) ; links for rel . put ( uri . resolve ( href . as text ( ) ) , ( title != null && title . get node type ( ) == json node type . string ) ? title . as text ( ) : null ) ; } }	Parses a JSON object for link information.
private static map < uri , string > get or add ( map < string , map < uri , string > > map , string key ) { map < uri , string > value = map . get ( key ) ; if ( value == null ) { map . put ( key , value = new hash map < > ( ) ) ; } return value ; }	Returns the element with the specified key from the map.
protected void handle capabilities ( http response response ) { allowed methods = unmodifiable set ( stream ( response . get headers ( str ) ) . filter ( x -> x . get name ( ) . equals ( str ) ) . flat map ( x -> stream ( x . get elements ( ) ) ) . map ( x -> x . get name ( ) ) . collect ( to set ( ) ) ) ; }	Handles allowed HTTP methods and other capabilities reported by theserver.
protected optional < boolean > is method allowed ( string method ) { if ( allowed methods . is empty ( ) ) { return optional . empty ( ) ; } return optional . of ( allowed methods . contains ( method ) ) ; }	Shows whether the server has indicated that a specific HTTP method iscurrently allowed.Uses cached data from last response.
protected void register instance processor ( ) { register instance processor ( new instance fields injection processor ( ) ) ; register instance processor ( new instance fields initialization processor ( ) ) ; register instance processor ( new configurable instance processor ( ) ) ; register instance processor ( new post construct instance processor ( ) ) ; register instance processor ( new cron methods processor ( cron manager ) ) ; register instance processor ( new logger instance processor ( ) ) ; }	Register all instance post-processors.
protected void register instance factory ( instance type instance type , instance factory instance factory ) { log . debug ( str , instance factory . get class ( ) , instance type ) ; if ( instance factories . put ( instance type , instance factory ) != null ) { throw new bug error ( str , instance type ) ; } }	Register instance factory to requested instance type.
protected void register instance processor ( instance processor instance processor ) { for ( instance processor existing instance processoor : instance processors ) { if ( existing instance processoor . get class ( ) . equals ( instance processor . get class ( ) ) ) { throw new bug error ( str , instance processor . get class ( ) ) ; } } log . debug ( str , instance processor . get class ( ) ) ; instance processors . add ( instance processor ) ; }	Register instance processor. Only a single instance per processor class is allowed.
protected void register class processor ( class processor class processor ) { for ( class processor existing class processoor : class processors ) { if ( existing class processoor . get class ( ) . equals ( class processor . get class ( ) ) ) { throw new bug error ( str , class processor . get class ( ) ) ; } } log . debug ( str , class processor . get class ( ) ) ; class processors . add ( class processor ) ; }	Register global processors for managed classes.
public final void add argument ( @ not null final argument argument ) { if ( arguments == null ) { arguments = new array list < argument > ( ) ; } arguments . add ( argument ) ; }	Adds an argument to the template.
public final list < target file > create target file list ( ) { if ( tfl producer config == null ) { log . info ( str , target files . size ( ) ) ; return target files ; } final target file list producer producer = tfl producer config . get target file list producer ( ) ; log . info ( str , producer . get class ( ) . get name ( ) ) ; return producer . create target files ( ) ; }	Returns the list of target files.
public final string to xml ( ) { try { final jaxb helper helper = new jaxb helper ( ) ; return helper . write ( this , create jaxb context ( ) ) ; } catch ( final marshal object exception ex ) { throw new runtime exception ( ex ) ; } }	Marshals the object to an XML String.
public final void init ( final j context , final map < string , string > vars ) { if ( template != null ) { template = j . replace vars ( template , vars ) ; } if ( arguments != null ) { for ( final argument argument : arguments ) { argument . init ( vars ) ; } } if ( target files != null ) { for ( final target file target file : target files ) { target file . init ( vars ) ; } } if ( tfl producer config != null ) { tfl producer config . init ( context , this , vars ) ; } }	Initializes the model.
public final boolean has reference to ( final file template dir , final file template file ) { final string p1 = j . get canonical path ( new file ( template dir , template ) ) ; final string p2 = j . get canonical path ( template file ) ; return p1 . equals ( p2 ) ; }	Checks if this model has a reference to the given template file.
public static parameterized template model create ( final reader reader ) { try { final jaxb helper helper = new jaxb helper ( ) ; final parameterized template model pc = helper . create ( reader , create jaxb context ( ) ) ; contract . require valid ( pc ) ; return pc ; } catch ( final unmarshal object exception ex ) { throw new runtime exception ( ex ) ; } }	Creates an instance by reading the XML from a reader.
public static parameterized template model create ( final file file ) { try { final jaxb helper helper = new jaxb helper ( ) ; final parameterized template model pc = helper . create ( file , create jaxb context ( ) ) ; pc . set file ( file ) ; contract . require valid ( pc ) ; return pc ; } catch ( final unmarshal object exception ex ) { throw new runtime exception ( ex ) ; } }	Creates an instance by reading the XML from a file.
void set request path ( string request path ) { this . request path = request path != null ? request path : strings . to dash case ( method . get name ( ) ) ; }	Set this method request URI path, that is, the path component by which this method is referred into request URI.
stoppable observable < t > get observable ( final long start index , scheduler scheduler ) { return run async ( scheduler , ( rx . observer < ? super t > observer , subscription subscription ) -> { long current start index = start index ; while ( ! subscription . is unsubscribed ( ) ) { partial response < t > response ; try { response = ( current start index >= num ) ? read range ( current start index , null ) : read range ( null , - current start index ) ; } catch ( illegal state exception ex ) {	Provides an observable stream of elements.
@ suppress warnings ( str ) @ override public < t > t as object ( string string , class < t > value type ) { return ( t ) new instance scope ( string ) ; }	Create a scope instance from its string value.
private void set field ( field field , string parameter name , object instance ) { final object value = context . get property ( parameter name , field . get type ( ) ) ; try { field . set ( instance , value ) ; } catch ( exception e ) { throw new bug error ( e ) ; } }	Initialize field from named context parameter.
public void add capture to logger ( final appender attachable logger , final string appender name ) { appender current appender = logger . get appender ( appender name ) ; appender capture appender = capture appender . new appender from ( current appender ) ; logger . add appender ( capture appender ) ; }	Adds a new CaptureAppender to an existing logger.
public void remove ( final appender attachable logger , final string appender name ) { logger . remove appender ( capture appender . get appender name for ( appender name ) ) ; }	Removes a CaptureAppender from a logger.
public void clear ( final appender attachable logger , final string appender name ) { ( ( capture appender ) logger . get appender ( capture appender . get appender name for ( appender name ) ) ) . clear ( ) ; }	Deletes all cached log entries.
protected final void parse model ( ) { if ( ( file extensions == null ) || ( file extensions . size ( ) == num ) ) { throw new illegal state exception ( str ) ; }	Parses all model files in the directories and all resources. y.
protected final void resolve proxies ( ) { final list < string > unresolved = new array list < string > ( ) ; if ( ! resolved all proxies ( unresolved , num ) ) { log . warn ( str , unresolved . size ( ) ) ; for ( final string ref : unresolved ) { log . warn ( str , ref ) ; } final iterator < notifier > it = resource set . get all contents ( ) ; while ( it . has next ( ) ) { final notifier next = it . next ( ) ; if ( next instanceof e ) { final e obj = ( e ) next ; if ( obj . e is proxy ( ) ) { try { it . remove ( ) ; } catch ( final unsupported operation exception ex ) { log . error ( str + obj , ex ) ; } } } } } }	Tries to resolve all proxies.
private file [ ] get files ( final file dir ) { final file [ ] files = dir . list files ( new file filter ( ) { @ override public boolean accept ( final file file ) { final boolean point file = file . get name ( ) . starts with ( str ) ; final string extension = filename utils . get extension ( file . get name ( ) ) ; return ( ! point file && file extensions . contains ( extension ) ) || file . is directory ( ) ; } } ) ; return files ; }	Returns files that end with java and all directories.
private void parse dir ( final file dir ) { log . debug ( str , dir ) ; final file [ ] files = get files ( dir ) ; if ( ( files == null ) || ( files . length == num ) ) { log . debug ( str , dir ) ; } else { for ( final file file : files ) { if ( file . is file ( ) ) { final resource resource = resource set . get resource ( uri . create file uri ( j . get canonical path ( file ) ) , bool ) ; final e < diagnostic > diagnostics = resource . get errors ( ) ; if ( diagnostics . size ( ) == num ) { log . debug ( str , file ) ; } else { error = bool ; log . error ( str , file , diagnostics ) ; } } else { parse dir ( file ) ; } } } }	Parse the directory and it's sub directory.
public boolean is model fully resolved ( ) { boolean resolved = bool ; final set < e > e objects = find all e ( resource set ) ; final iterator < e > it = e objects . iterator ( ) ; while ( it . has next ( ) ) { final e e obj = it . next ( ) ; if ( e obj instanceof e ) { final e i obj = ( e ) e obj ; for ( final e cross ref : i obj . e cross references ( ) ) { if ( cross ref . e is proxy ( ) ) { log . error ( str , cross ref ) ; resolved = bool ; } } } } return resolved ; }	Determines if all proxies in the model are resolved.
private static set < e > find all e ( final resource set resource set ) { final set < e > list = new hash set < e > ( ) ; for ( final iterator < notifier > i = resource set . get all contents ( ) ; i . has next ( ) ; ) { final notifier next = i . next ( ) ; if ( next instanceof e ) { list . add ( ( e ) next ) ; } } return list ; }	Returns a list of all objects.
protected final void set model dirs ( final file ... model dirs ) { if ( model dirs == null ) { this . model dirs = null ; } else { this . model dirs = new array list < file > ( ) ; this . model dirs . add all ( arrays . as list ( model dirs ) ) ; } }	Sets the model directories to parse.
protected final void set file extensions ( final string ... file extensions ) { if ( file extensions == null ) { this . file extensions = null ; } else { this . file extensions = new array list < string > ( ) ; this . file extensions . add all ( arrays . as list ( file extensions ) ) ; } }	Sets the list of file extensions.
protected final void set model resources ( final uri ... model resources ) { if ( model resources == null ) { this . model resources = null ; } else { this . model resources = new array list < uri > ( ) ; this . model resources . add all ( arrays . as list ( model resources ) ) ; } }	Sets the model resources to parse.
@ override public final boolean next record ( ) throws io { final string line = reader . read line ( ) ; if ( line == null ) { parts = null ; return bool ; } final list < string > new parts = split line ( line ) ; parts = new parts . to array ( new string [ new parts . size ( ) ] ) ; part index = num ; return bool ; }	Reads the next row.
public void set string array ( string parameter name , string ... values ) throws java . sql . sql { int array len = this . get sql ( ) . get array len ( parameter name ) ; assert utils . assert true ( values . length <= array len ) ; for ( int i = num ; i < array len ; i ++ ) { set string2 ( sql . to param name ( parameter name , i ) , ( i < values . length ) ? values [ i ] : null ) ; } }	type IN (.
@ suppress warnings ( str ) @ override public < t > t as object ( string string , class < t > value type ) throws illegal argument exception , converter exception { return ( t ) new instance type ( string ) ; }	Create an instance type from its string value.
protected final void merge ( final velocity context context , final string artifact name , final string template name , final string filename ) throws generate exception { final generated file gen file = get target file ( artifact name , filename , template name ) ; if ( gen file . is skip ( ) ) { log . debug ( str , gen file , template name ) ; } else { log . debug ( str , gen file , template name ) ;	Merges the template and context into a file.
public final file get model dir ( ) { if ( ( model dir == null ) && ( model path != null ) ) { model dir = j . get canonical file ( new file ( model path ) ) ; } return model dir ; }	Returns the model directory.
public final file get template dir ( ) { if ( ( template dir == null ) && ( template path != null ) ) { try { template dir = new file ( template path ) . get canonical file ( ) ; } catch ( final io ex ) { throw new runtime exception ( str + template path , ex ) ; } } return template dir ; }	Returns the template directory.
@ override public void write ( http servlet response http response , object value ) throws io { final document document = ( document ) value ; document . serialize ( new output stream writer ( http response . get output stream ( ) , str ) ) ; }	Serialize XML document to output stream of given HTTP response.
@ validate public void start ( ) { q . invoke later ( new runnable ( ) { public void run ( ) { configure application ( ) ; m logger . info ( str ) ; synchronized ( web view factory . this ) { m browser = new web window ( m url , web view factory . this ) ; configure window ( m browser ) ; m browser . show ( ) ; } m logger . info ( str ) ; } } ) ; }	Starts the browser and loads theset url in the web view.
private void configure window ( web window web ) { if ( m fullscreen ) {	Configures the browser window.
public void print ( q view ) { if ( m print ) { q printer = new q ( ) ; q print dialog = new q ( printer , view ) ; if ( print dialog . exec ( ) == q . dialog code . accepted . value ( ) ) {	Print callback.Checks if the print feature is enabled.
public static void write ( input stream in , output stream out ) throws io { byte [ ] b = new byte [ num ] ; for ( int n ; ( n = in . read ( b ) ) != - num ; ) { out . write ( b , num , n ) ; } in . close ( ) ; out . close ( ) ; }	Utility method to copy a stream to another stream.
@ override public object invoke ( object proxy , method method , object [ ] args ) throws throwable { t instance = app factory . get instance ( interface class ) ; return method . invoke ( instance , args ) ; }	Retrieve managed instance from application factory and invoke given method on that instance.
public void attach ( http servlet request http request , http servlet response http response ) {	Attach this instance to HTTP servlet request.
public void detach ( ) { attached = bool ; locale = null ; security domain = null ; cookies = null ; request path = null ; request url = null ; }	Detach request context instance from HTTP servlet request.
public cookies get cookies ( ) { assert attached ( ) ; if ( cookies == null ) { cookies = new cookies ( http request , http response ) ; } return cookies ; }	Get request cookies.
public void dump ( ) { if ( ! attached ) { return ; } string builder message = new string builder ( ) ; message . append ( str ) ; message . append ( http request . get request uri ( ) ) ; message . append ( str ) ; message . append ( system . line separator ( ) ) ; message . append ( str ) ; message . append ( http request . get remote host ( ) ) ; message . append ( system . line separator ( ) ) ; message . append ( str ) ; message . append ( http request . get method ( ) ) ; message . append ( system . line separator ( ) ) ; message . append ( str ) ; if ( http request . get query string ( ) != null ) { message . append ( http request . get query string ( ) ) ; } enumeration < string > header names = http request . get header names ( ) ; while ( header names . has more elements ( ) ) { message . append ( system . line separator ( ) ) ; string header name = header names . next element ( ) ; message . append ( str ) ; message . append ( header name ) ; message . append ( str ) ; message . append ( http request . get header ( header name ) ) ; } log . error ( message . to string ( ) ) ; }	Dump this request context state to error logger.
private static list < invocation meter > get meters ( ) { list < invocation meter > invocation meters = new array list < invocation meter > ( ) ; spi container = ( spi ) factory . get app factory ( ) ; for ( spi managed method : container . get managed methods ( ) ) { invocation meters . add ( ( ( managed method ) managed method ) . get meter ( ) ) ; } return invocation meters ; }	Collect invocation meters from application managed classes.
protected void config ( event stream config config ) { if ( config . has secret key ( ) ) { secret key = config . get secret key ( ) ; } if ( config . has keep alive period ( ) ) { keep alive period = config . get keep alive period ( ) ; } parameters = config . get parameters ( ) ; }	Configure events stream instance from configuration object.
protected void set remote host ( string remote host ) { if ( string == null ) { string = strings . concat ( str , stream id ++ , str , remote host ) ; } }	Set the host address for client connected to this event stream.
protected < t > t get parameter ( string name , class < t > type ) { if ( parameters == null ) { throw new bug error ( str , this ) ; } string value = parameters . get ( name ) ; if ( value == null ) { throw new bug error ( str , name , type ) ; } return converter registry . get converter ( ) . as object ( value , type ) ; }	Get named parameter throwing exception if not found.
public string remove prefix ( final string path , final string prefix ) { string path without prefix = path ; if ( path without prefix . starts with ( prefix ) ) { path without prefix = path without prefix . substring ( prefix . length ( ) ) ; while ( path without prefix . starts with ( str ) || path without prefix . starts with ( str ) ) { path without prefix = path without prefix . substring ( num ) ; } } return path without prefix ; }	Removes a prefix from a path.
public file get common dir ( final file dir1 , final file dir2 ) throws io { list < file > parts1 = get parent dirs ( dir1 ) ; list < file > parts2 = get parent dirs ( dir2 ) ; file matched = null ; final int max common size = math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; for ( int i = num ; i < max common size ; ++ i ) { if ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) { matched = parts1 . get ( i ) ; } else { break ; } } return matched ; }	Gets the longest common parent directory path of two paths.
public string abs2rel ( final string base path , final string abs path ) { if ( ! is absolute path ( abs path ) ) { return abs path ; } if ( is windows drive ( abs path ) && is windows drive ( base path ) && abs path . char at ( num ) != base path . char at ( num ) ) { return abs path ; } string builder result = new string builder ( ) ; string [ ] base parts = get parts ( base path ) ; string [ ] abs parts = get parts ( abs path ) ;	Converts an absolute path into a relative one.
public file rel2abs ( final string base path , final string rel path ) { string [ ] base parts = get parts ( base path ) ; string [ ] rel parts = get parts ( rel path ) ; if ( is absolute path ( rel path ) ) { return new file ( rel path ) ; } list < string > parts = new array list < > ( ) ; for ( int i = num ; i < base parts . length ; ++ i ) { if ( i > num || ! is windows drive ( base path ) ) { parts . add ( base parts [ i ] ) ; } } for ( string part : rel parts ) { if ( part . equals ( str ) && parts . size ( ) > num ) { parts . remove ( parts . size ( ) - num ) ; } else if ( ! part . equals ( str ) && ! part . equals ( str ) ) { parts . add ( part ) ; } } string builder result = new string builder ( ) ; if ( is windows drive ( base path ) ) { result . append ( base parts [ num ] ) ; } for ( string part : parts ) { result . append ( file . separator ) ; result . append ( part ) ; } return new file ( result . to string ( ) ) ; }	Converts an relative path into an absolute one.
public int dir depth ( final file path ) { final string string path = path . get path ( ) ; return string path . length ( ) - string path . replace all ( str , str ) . length ( ) ; }	Counts the number of directories in a given path.
protected static void dump error ( request context context , throwable throwable ) { log . dump ( str , throwable ) ; context . dump ( ) ; }	Dump throwable stack trace and request context to application logger.
protected static void send json object ( request context context , object object , int status code ) throws io { final http servlet response http response = context . get response ( ) ; if ( http response . is committed ( ) ) { log . fatal ( str ) ; return ; } log . trace ( str , object . to string ( ) ) ; json json = classes . load service ( json . class ) ; string buffer = json . stringify ( object ) ; byte [ ] bytes = buffer . get bytes ( str ) ; http response . set status ( status code ) ; http response . set content type ( content type . application json . get value ( ) ) ; http response . set content length ( bytes . length ) ; http response . set header ( str , context . get locale ( ) . to language tag ( ) ) ; http response . get output stream ( ) . write ( bytes ) ; http response . get output stream ( ) . flush ( ) ; }	Send object back to client encoded JSON with given HTTP status code.
public final void add param template ( final parameterized template model param template ) { if ( param templates == null ) { param templates = new array list < parameterized template model > ( ) ; } param templates . add ( param template ) ; }	Adds another template to the list.
public final void add param templates ( final list < parameterized template model > list ) { if ( list != null ) { for ( final parameterized template model template : list ) { add param template ( template ) ; } } }	Adds all templates to the list.
public final void init ( final j context , final map < string , string > vars ) { if ( param templates != null ) { for ( final parameterized template model param template : param templates ) { param template . init ( context , vars ) ; } } }	Initalizes the object.
public final list < parameterized template model > find references to ( final file template dir , final file template file ) { final list < parameterized template model > result = new array list < parameterized template model > ( ) ; if ( ( param templates != null ) && j . file inside directory ( template dir , template file ) ) { for ( final parameterized template model param template : param templates ) { if ( param template . has reference to ( template dir , template file ) ) { result . add ( param template ) ; } } } return result ; }	Returns a list that contains all models that reference the given template.
public void set save enabled ( boolean val ) { save button . set visible ( val ) ; set read only ( ! val ) ; entity form . set read only ( ! val ) ; }	Controls whether a save button is shown and fields are editable.
protected void delete ( ) { string question = str + get caption ( ) + str ; confirm dialog . show ( get ui ( ) , question , ( confirm dialog cd ) -> { if ( cd . is confirmed ( ) ) { try { on delete ( ) ; close ( ) ; } catch ( io | illegal argument exception | illegal access exception | illegal state exception ex ) { on error ( ex ) ; } catch ( runtime exception ex ) {	Deletes the element.
protected void on delete ( ) throws io , illegal argument exception , illegal access exception , file not found exception , illegal state exception { endpoint . delete ( ) ; event bus . post ( new element deleted event < > ( endpoint ) ) ; }	Handler for deleting the element.
@ suppress warnings ( str ) @ override public < t > t new instance ( spi managed class , object ... args ) { constructor < ? > constructor = managed class . get constructor ( ) ; if ( constructor == null ) { throw new bug error ( str , managed class ) ; } object instance = null ; try { instance = constructor . new instance ( args ) ; } catch ( illegal argument exception e ) { log . error ( str , constructor , strings . join ( classes . get parameter types ( args ) ) ) ; throw e ; } catch ( instantiation exception e ) {	Uses managed class constructor to create new instance with provided arguments.
public file [ ] get files ( ) { list < file > result = new array list < > ( ) ; for ( file count file count : results ) { result . add ( file count . get file ( ) ) ; } collections . sort ( result , new fit file comparator ( ) ) ; return result . to array ( new file [ result . size ( ) ] ) ; }	Returns all saved filenames.
public counts get summary ( ) { counts result = new counts ( ) ; for ( file count file count : results ) { if ( file count . get counts ( ) != null ) { result . tally ( file count . get counts ( ) ) ; } } return result ; }	Returns the sum of all results.
public string get summary row ( final file directory ) { string builder builder = new string builder ( ) ; counts counts = get summary ( ) ; builder . append ( str ) ; builder . append ( color ( counts ) ) ; builder . append ( str ) ; builder . append ( directory . get name ( ) ) ; builder . append ( str ) ; builder . append ( counts . to string ( ) ) ; builder . append ( str ) ; return builder . to string ( ) ; }	Returns a summary row for a whole test run.
public string get sub summary row ( final file path ) throws io { counts sum = sub dir sum ( path ) ; return string . format ( str , color ( sum ) , fit utils . html safe file ( dir helper . abs2rel ( new file ( str ) . get absolute path ( ) , path . get absolute path ( ) ) ) , sum . to string ( ) ) ; }	Generates a HTML summary row for a subdirectory.
@ suppress warnings ( str ) @ override public < i > i new instance ( spi managed class , object ... args ) { if ( args . length > num ) { throw new illegal argument exception ( str ) ; } class < ? > [ ] interface classes = managed class . get interface classes ( ) ; if ( interface classes == null ) { throw new bug error ( str ) ; } if ( interface classes . length != num ) { throw new bug error ( str ) ; } return ( i ) classes . load service ( interface classes [ num ] ) ; }	Load service defined by managed class interface and return service instance.
public final class < ? > get setup class ( ) { if ( setup class != null ) { return setup class ; } log . info ( str , setup class name ) ; try { setup class = class . for name ( setup class name , bool , context . get class loader ( ) ) ; } catch ( final class not found exception ex ) { throw new runtime exception ( str + setup class name , ex ) ; } return setup class ; }	Returns the setup class.
public final list < file > get model dirs ( ) { if ( ( model dirs == null ) && ( model path != null ) ) { model dirs = paths ( ) . stream ( ) . filter ( xtext parser config :: is file ) . map ( xtext parser config :: as file ) . collect ( collectors . to list ( ) ) ; } return model dirs ; }	Returns a list of model directories to parse.
public final list < uri > get model resources ( ) { if ( ( model resources == null ) && ( model path != null ) ) { model resources = new array list < > ( ) ; model resources = paths ( ) . stream ( ) . filter ( xtext parser config :: is resource ) . map ( xtext parser config :: as resource ) . collect ( collectors . to list ( ) ) ; } return model resources ; }	Returns a list of model resources to parse.
public void set candidates ( collection < t > candidates ) { twin col select . set container data source ( container = new bean item container < > ( entity type , candidates ) ) ; }	Sets a set of candidates for selection.
protected static void load xml ( input stream input stream , loader loader ) throws config exception { try { sax factory = sax . new instance ( ) ; sax parser = factory . new sax ( ) ; xml reader = parser . get xml ( ) ; reader . set content handler ( loader ) ; reader . parse ( new input source ( input stream ) ) ; } catch ( exception e ) { throw new config exception ( str , input stream , e ) ; } }	Load configuration document from file.
protected void on error ( exception ex ) { notification . show ( str , ex . get localized message ( ) , notification . type . error message ) ; }	Handler for errors reported by REST endpoints.
private static boolean is object ( type [ ] formal parameters ) { if ( formal parameters . length != num ) { return bool ; } final type type = formal parameters [ num ] ; if ( ! ( type instanceof class ) ) { return bool ; } if ( types . is primitive ( type ) ) { return bool ; } if ( types . is array like ( type ) ) { return bool ; } if ( types . is map ( type ) ) { return bool ; } if ( converter registry . has type ( type ) ) { return bool ; } return bool ; }	Test if method formal parameters designates a strict object, that is, is not primitive, array, collection or map.
@ override public object [ ] read ( http servlet request http request , type [ ] formal parameters ) throws io , illegal argument exception { json reader reader = new json reader ( http request . get input stream ( ) , expected start sequence ( formal parameters ) ) ; try { return json . parse ( reader , formal parameters ) ; } catch ( json exception e ) { throw new illegal argument exception ( e . get message ( ) ) ; } finally { reader . close ( ) ; } }	Uses JSON deserializer to parse method invocation arguments accordingly formal parameters list.
@ override public object read ( input stream input stream , type type ) throws io { try { return json . parse ( new input stream reader ( input stream , str ) , type ) ; } catch ( json exception | class cast exception | unsupported encoding exception e ) { throw new illegal argument exception ( e . get message ( ) ) ; } }	Parse JSON from input stream accordingly given type.
public static string extract cell parameter ( fit cell cell ) { final matcher matcher = parameter pattern . matcher ( cell . get fit value ( ) ) ; if ( matcher . matches ( ) ) { cell . set fit value ( matcher . group ( num ) ) ; return matcher . group ( num ) ; } else { return null ; } }	extracts and removes parameters from a cell.
@ override public java . util . map < java . lang . string , java . lang . object > get hints ( ) { return this . q . get hints ( ) ; }	javax.persistence.Query & javax.persistence.TypedQuery.
public static boolean is xhr ( http servlet request http request ) { string requested with = http request . get header ( x requested with ) ; return requested with != null ? requested with . equals ignore case ( xml http request ) : bool ; }	Test if given HTTP request is performed via XMLHttpRequest.
public static boolean is android ( http servlet request http request ) { string requested with = http request . get header ( x requested with ) ; return requested with != null ? requested with . equals ignore case ( android user agent ) : bool ; }	Test if HTTP request is from Android.
@ subscribe public void handle ( element event < t > message ) { if ( message . get endpoint ( ) . get entity type ( ) == this . endpoint . get entity type ( ) ) { refresh ( ) ; } }	Refresh when child elements are created or updated.
public static < t extends annotation > list < property descriptor > get properties with annotation ( class < ? > bean type , class < t > annotation type ) { linked list < property descriptor > result = new linked list < > ( ) ; get properties ( bean type ) . for each ( property -> { if ( property . get read method ( ) != null && property . get read method ( ) . get annotation ( annotation type ) != null || is field annotated ( bean type , property . get name ( ) , annotation type ) ) { result . add ( property ) ; } } ) ; return result ; }	Lists all properties on a bean type that have a specific annotation ontheir getter or backing field.
public static < t extends annotation > optional < t > get annotation ( class < ? > bean type , property descriptor property , class < t > annotation type ) { optional < t > annotation = stream ( property . get read method ( ) . get annotations by type ( annotation type ) ) . find any ( ) ; return annotation . is present ( ) ? annotation : get annotation on field ( bean type , property . get name ( ) , annotation type ) ; }	Returns an annotation of a specific type on a property's getter or itsbacking field.
private static string log ( string message , object ... args ) { message = string . format ( message , args ) ; java . util . logging . logger . get logger ( server . class . get canonical name ( ) ) . log ( java . util . logging . level . severe , message ) ; return message ; }	Log formatted message to Java logger since framework logger is not yet initialized.
public whois result lookup ( string domain , int timeout ) { container . put ( str , domain ) ; container . put ( str , timeout ) ; try { return ( whois result ) container . run scriptlet ( j . class . get resource as stream ( str ) , str ) ; } catch ( eval failed exception e ) { if ( e . get message ( ) . starts with ( str ) ) { throw new server not found exception ( e ) ; } if ( e . get message ( ) . starts with ( str ) ) { throw new web interface error exception ( e ) ; } throw e ; } }	Uses the Ruby Whois gem to perform a whois lookup.
public boolean has parser for whois host ( string whois host ) { container . put ( str , whois host ) ; return ( boolean ) container . run scriptlet ( j . class . get resource as stream ( str ) , str ) ; }	Check if Ruby Whois gem has a parser for a specific registrar.
private static spi get managed class ( spi container , string interface name , string request uri ) throws class not found exception { class < ? > interface class = classes . for optional name ( interface name ) ; if ( interface class == null ) { log . error ( str , interface name ) ; throw new class not found exception ( request uri ) ; } spi managed class = container . get managed class ( interface class ) ; if ( managed class == null ) { log . error ( str , interface name ) ; throw new class not found exception ( request uri ) ; } if ( ! managed class . is remotely accessible ( ) ) { log . error ( str , interface name ) ; throw new class not found exception ( request uri ) ; } return managed class ; }	Get remotely accessible managed class registered to a certain interface class.
private static spi get managed method ( spi managed class , string method name , string request uri ) throws no such method exception { spi managed method = managed class . get net method ( method name ) ; if ( managed method == null ) { log . error ( str , managed class . get interface class ( ) . get name ( ) , method name ) ; throw new no such method exception ( request uri ) ; } if ( ! managed method . is remotely accessible ( ) ) { log . error ( str , managed class . get interface class ( ) . get name ( ) , method name ) ; throw new no such method exception ( request uri ) ; } if ( types . is kind of ( managed method . get return type ( ) , resource . class ) ) { log . error ( str , managed class . get interface class ( ) . get name ( ) , method name ) ; throw new no such method exception ( request uri ) ; } return managed method ; }	Get managed method that is remotely accessible and has requested name.
public void process not contains exception ( map < string , string > parameters ) { logging event match = get message with exception ( parameters ) ; if ( match == null ) { cell . right ( ) ; } else { cell . wrong ( match . get throwable information ( ) . get throwable str rep ( ) [ num ] ) ; } }	Checks whether the log messages contain the expected exception.
public void process not contains ( map < string , string > parameters ) { logging event match = get message with string ( parameters ) ; if ( match == null ) { cell . right ( ) ; } else { cell . wrong ( match . get message ( ) . to string ( ) ) ; } }	Checks whether the log messages do not contain the expected text.
@ override public void serialize ( http servlet response http response ) throws io { http response . set header ( http header . cache control , http header . no cache ) ; http response . add header ( http header . cache control , http header . no store ) ; http response . set header ( http header . pragma , http header . no cache ) ; http response . set date header ( http header . expires , num ) ; http response . set content type ( get content type ( ) . get value ( ) ) ; serialize ( http response . get output stream ( ) ) ; }	Set common HTTP response headers and delegates actual serialization to subclass.
public string get ( string name ) { params . not null or empty ( name , str ) ; if ( cookies == null ) { return null ; } for ( cookie cookie : cookies ) { if ( name . equals ( cookie . get name ( ) ) ) { return cookie . get value ( ) ; } } return null ; }	Get value of the named cookie or null if cookie does not exist.
public void add ( string name , string value ) { params . not null or empty ( name , str ) ; params . not null ( value , str ) ; cookie cookie = new cookie ( name , value ) ; cookie . set path ( str ) ; http response . add cookie ( cookie ) ; }	Add cookie to HTTP response of the current request context.
public void remove ( string name ) { params . not null or empty ( name , str ) ; if ( cookies == null ) { return ; } for ( cookie cookie : cookies ) { if ( name . equals ( cookie . get name ( ) ) ) { cookie . set max age ( num ) ; cookie . set value ( str ) ; cookie . set path ( str ) ; http response . add cookie ( cookie ) ; break ; } } }	Remove cookie from HTTP response.
public iterator < cookie > iterator ( ) { if ( cookies == null ) { return collections . empty iterator ( ) ; } return arrays . as list ( cookies ) . iterator ( ) ; }	Get cookies iterator. Return empty iterator if not cookies on HTTP request.
public final target file list producer get target file list producer ( ) { if ( tfl producer != null ) { return tfl producer ; } final object obj = j . create instance ( class name ) ; if ( ! ( obj instanceof target file list producer ) ) { throw new illegal state exception ( str + target file list producer . class . get name ( ) + str + class name ) ; } tfl producer = ( target file list producer ) obj ; return tfl producer ; }	Returns an existing target file list producer instance or creates a new one if it's the first call to this method.
public void add ( final class < ? > type , final string name ) throws class not found exception { field gen fg ; if ( result != null ) { throw new illegal state exception ( str ) ; } fg = new field gen ( constants . acc public | constants . acc super , type . get type ( type ) , name , cg . get constant pool ( ) ) ; cg . add field ( fg . get field ( ) ) ; }	Adds a public field to the constructed class.
public final class < ? > compile ( ) { if ( result == null ) { loader . load java class ( cg . get class name ( ) , cg . get java class ( ) ) ; try { result = loader . load class ( cg . get class name ( ) ) ; } catch ( class not found exception e ) { throw new runtime exception ( e ) ; } } return result ; }	Compiles the class and returns a class object which contains alladded fields.
public boolean verify response ( string token ) throws null pointer exception { return value . equals ( get value ( tokened image files . get ( token ) ) ) ; }	Test that selected image identified by given token is the right response.
private static string get value ( file file ) throws null pointer exception { if ( file == null ) { return null ; } return file . get name ( ) . to lower case ( ) . replace all ( extension rex , str ) . replace all ( not letters rex , str ) ; }	Challenge value associated with image file.
@ sneaky throws public static uri ensure trailing slash ( uri uri ) { uri builder = new uri ( uri ) ; if ( ! builder . get path ( ) . ends with ( str ) ) { builder . set path ( builder . get path ( ) + str ) ; } return builder . build ( ) ; }	Adds a trailing slash to the URI if it does not already have one.
private http servlet request get http servlet request ( ) { request context context = get instance ( request context . class ) ; http servlet request request = context . get request ( ) ; if ( request == null ) { throw new bug error ( str ) ; } return request ; }	Get HTTP request from current request context.
@ override public object invoke ( object proxy , method method , object [ ] args ) throws throwable { final spi managed method = managed class . get managed method ( method ) ; log . trace ( str , managed method ) ; if ( ! managed method . is transactional ( ) ) {	Invocation handler implementation. Every method invocation on managed class interface is routed to this point. Hereactual container services are implemented and method is invoked against wrapped instance.
private object execute mutable transaction ( spi managed method , object [ ] args ) throws throwable {	Helper method for mutable transaction execution.
private object execute immutable transaction ( spi managed method , object [ ] args ) throws throwable { transaction transaction = transactional resource . create read only transaction ( ) ;	Helper method for immutable transaction execution.
public file [ ] get files ( ) { final file [ ] files = directory . list files ( filter ) ; if ( files == null ) { return new file [ num ] ; } else { return files ; } }	Returns a list of all matching files.
public file get last file ( ) throws file not found exception { file [ ] files = directory . list files ( filter ) ; if ( files == null || files . length == num ) { throw new file not found exception ( ) ; } return files [ files . length - num ] ; }	Returns the last matching file.
@ suppress warnings ( str ) protected final config type get concrete config ( final parser config config ) { final config < parser config > cfg = config . get config ( ) ; if ( cfg == null ) { throw new illegal state exception ( str + concrete config class . get name ( ) + str ) ; } else { if ( ! ( concrete config class . is assignable from ( cfg . get config ( ) . get class ( ) ) ) ) { throw new illegal state exception ( str + concrete config class . get name ( ) + str + cfg . get config ( ) . get class ( ) . get name ( ) + str ) ; } } return ( config type ) cfg . get config ( ) ; }	Returns the parser configuration.
private static boolean starts with ( string request path , string path component ) { if ( request path . char at ( num ) != str ) { return bool ; } int i = num ; for ( int j = num ; i < request path . length ( ) ; ++ i , ++ j ) { if ( request path . char at ( i ) == str ) { return j == path component . length ( ) ; } if ( j == path component . length ( ) ) { return bool ; } if ( character . to lower case ( request path . char at ( i ) ) != character . to lower case ( path component . char at ( j ) ) ) { return bool ; } } return bool ; }	Test if request path starts with path component.
@ suppress warnings ( str ) @ not null public final < model > list < artifact factory < model > > get factories ( final class < model > model type ) { final list < artifact factory < model > > list = new array list < artifact factory < model > > ( ) ; if ( factories == null ) { factories = new array list < artifact factory < ? > > ( ) ; if ( factory configs != null ) { for ( final artifact factory config factory config : factory configs ) { factories . add ( factory config . get factory ( ) ) ; } } } for ( final artifact factory < ? > factory : factories ) { if ( model type . is assignable from ( factory . get model type ( ) ) ) { list . add ( ( artifact factory < model > ) factory ) ; } } return list ; }	Returns a list of factories for the given model type.
private http session get session ( instance key instance key ) { request context request context = app factory . get instance ( request context . class ) ; http servlet request http request = request context . get request ( ) ; if ( http request == null ) { throw new bug error ( str , instance key ) ; }	Get HTTP session from current request, creating it if necessary.
@ override public void serialize ( http servlet response http response ) throws io { http response . set header ( http header . cache control , http header . no cache ) ; http response . add header ( http header . cache control , http header . no store ) ; http response . set header ( http header . pragma , http header . no cache ) ; http response . set date header ( http header . expires , num ) ; http response . set content type ( content type ) ; http response . set header ( http header . content length , long . to string ( file . length ( ) ) ) ; files . copy ( file , http response . get output stream ( ) ) ; }	Serialize this file resource to HTTP response.
public void read meta ( ) throws io , illegal argument exception , illegal access exception , file not found exception , illegal state exception { execute and handle ( request . get ( uri ) ) ; }	Fetches meta data such as links from the server.
@ override protected void handle request ( request context context ) throws servlet exception , io {	Handle request for a resource.
@ override public void tear down ( ) throws exception { if ( statement != null ) { statement . close ( ) ; statement = null ; } super . tear down ( ) ; }	Closes the SQL statement.
@ override public void pre destroy ( ) { if ( event streams . is empty ( ) ) { return ; }	Closes all event streams still opened when event stream manager is destroyed.
protected void handle allowed methods ( ) { endpoint . is download allowed ( ) . if present ( this :: set download enabled ) ; endpoint . is upload allowed ( ) . if present ( this :: set upload enabled ) ; endpoint . is delete allowed ( ) . if present ( this :: set delete enabled ) ; }	Enables or disabled buttons based on the "Allow" HTTP header.
protected void upload ( ) { try { on upload ( ) ; event bus . post ( new blob upload event ( endpoint ) ) ; notification . show ( str , str , notification . type . tray notification ) ; } catch ( io | illegal argument exception | illegal access exception | illegal state exception ex ) { on error ( ex ) ; } }	Called to upload new blob data to the server.
protected void delete ( ) { string question = str ; confirm dialog . show ( get ui ( ) , question , new confirm dialog . listener ( ) { @ override public void on close ( confirm dialog cd ) { if ( cd . is confirmed ( ) ) { try { endpoint . delete ( ) ; close ( ) ; } catch ( io | illegal argument exception | illegal access exception | illegal state exception ex ) { on error ( ex ) ; } catch ( runtime exception ex ) {	Deletes the blob.
protected string [ ] extract column parameters ( fit row row ) { final list < string > result = new array list < > ( ) ; for ( fit cell cell : row . cells ( ) ) { result . add ( fit utils . extract cell parameter ( cell ) ) ; } return result . to array ( new string [ result . size ( ) ] ) ; }	extracts and removes parameters from a row.
protected string [ ] get arg names ( ) { if ( args == null ) { return new string [ ] { } ; } return args . key set ( ) . to array ( new string [ args . key set ( ) . size ( ) ] ) ; }	Returns all argument names.
public synchronized void period ( final periodic task periodic task , long period ) { timer task task = new periodic task impl ( periodic task ) ; this . tasks . put ( periodic task , task ) ; this . timer . schedule ( task , num , period ) ; }	Schedule periodic task execution.
public synchronized void timeout ( final timeout task timeout task , long timeout ) { timer task task = this . tasks . get ( timeout task ) ; if ( task != null ) { task . cancel ( ) ; this . tasks . values ( ) . remove ( task ) ; } task = new timeout task impl ( timeout task ) ; this . tasks . put ( timeout task , task ) ; this . timer . schedule ( task , timeout ) ; }	Schedule timeout task, reseting timeout period if given timeout task is already pending.
@ override public void config ( config config ) throws config exception , io { for ( config repository section : config . find children ( str ) ) {	Create views meta pool from given managed view configuration object.
@ override public final file next ( ) { if ( files == null || file index >= files . length ) { if ( ! cache next ( ) ) { throw new no such element exception ( ) ; } } return files [ file index ++ ] ; }	Returns the next matching file.
private static void configure application ( ) {	Configures the application.
private static void print welcome banner ( ) { string buffer banner = new string buffer ( ) ; banner . append ( str ) ; banner . append ( str ) ; banner . append ( str ) ; banner . append ( str ) ; banner . append ( str ) ; banner . append ( str ) ; banner . append ( str ) ; system . out . println ( banner ) ; }	Prints Welcome Banner.
private static void print stopped banner ( ) { system . out . println ( str ) ; system . out . println ( str ) ; system . out . println ( str ) ; system . out . println ( str ) ; system . out . println ( str ) ; }	Prints Stopped Banner.
public static ria create chameleon ( string [ ] args ) throws exception { boolean debug = is debug mode enabled ( args ) ; string core = get core ( args ) ; string app = get app ( args ) ; string runtime = get runtime ( args ) ; string fileinstall = get deploy directory ( args ) ; string config = get props ( args ) ; if ( config == null || ! new file ( config ) . exists ( ) ) { return new ria ( core , debug , app , runtime , fileinstall , null ) ; } else { return new ria ( core , debug , app , runtime , fileinstall , config ) ; } }	Creates the Chameleon instance.The instance is not started.
private static void register shutdown hook ( final ria chameleon ) { runtime runtime = runtime . get runtime ( ) ; runnable hook = new runnable ( ) { public void run ( ) { try { if ( chameleon != null ) { chameleon . stop ( ) ; print stopped banner ( ) ; } } catch ( bundle exception e ) { system . err . println ( str + e . get message ( ) ) ; } catch ( interrupted exception e ) { system . err . println ( str + e . get message ( ) ) ;	Registers a shutdown hook to stop nicely the embedded framework.
public void trigger ( ) { try { on trigger ( ) ; notification . show ( get caption ( ) , str , notification . type . tray notification ) ; } catch ( io | illegal argument exception | illegal access exception | illegal state exception ex ) { on error ( ex ) ; } }	Triggers the action.
protected void on trigger ( ) throws io , illegal argument exception , illegal access exception , file not found exception , illegal state exception { endpoint . trigger ( ) ; event bus . post ( new trigger event ( endpoint ) ) ; }	Handler for triggering the action.
public void insert and replace ( final fit row row ) { if ( results . is empty ( ) ) { return ; } int index = row . get index ( ) ; fit table table = row . get table ( ) ; table . remove ( index ) ; add rows ( table , index ) ; }	Replaces a row with one or more results.
public counts get counts ( ) { counts counts = new counts ( ) ; for ( file count file count : results ) { counts . tally ( file count . get counts ( ) ) ; } return counts ; }	Gets the sum of all results.
public void set score ( double v ) { if ( summary type . feat ok tst && ( ( summary type ) jcas type ) . cas feat score == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set double value ( addr , ( ( summary type ) jcas type ) . cas feat code score , v ) ; }	setter for score - sets The score associated with the answer.
public string list get variants ( ) { if ( summary type . feat ok tst && ( ( summary type ) jcas type ) . cas feat variants == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( string list ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( summary type ) jcas type ) . cas feat code variants ) ) ) ; }	getter for variants - gets List of alternative answer summaries.
public void set variants ( string list v ) { if ( summary type . feat ok tst && ( ( summary type ) jcas type ) . cas feat variants == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( summary type ) jcas type ) . cas feat code variants , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for variants - sets List of alternative answer summaries.
public string get question type ( ) { if ( question type . feat ok tst && ( ( question type ) jcas type ) . cas feat question type == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( question type ) jcas type ) . cas feat code question type ) ; }	getter for questionType - gets The class of the question, determined by either an automatic question classification process or human judgment.
public void set question type ( string v ) { if ( question type . feat ok tst && ( ( question type ) jcas type ) . cas feat question type == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( question type ) jcas type ) . cas feat code question type , v ) ; }	setter for questionType - sets The class of the question, determined by either an automatic question classification process or human judgment.
public token get token ( ) { if ( focus type . feat ok tst && ( ( focus type ) jcas type ) . cas feat token == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( token ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( focus type ) jcas type ) . cas feat code token ) ) ) ; }	getter for token - gets The corresponding token for the focus.
public string get dep label ( ) { if ( token type . feat ok tst && ( ( token type ) jcas type ) . cas feat dep label == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( token type ) jcas type ) . cas feat code dep label ) ; }	getter for depLabel - gets The dependency label of the token with respect to its head.
public void set dep label ( string v ) { if ( token type . feat ok tst && ( ( token type ) jcas type ) . cas feat dep label == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( token type ) jcas type ) . cas feat code dep label , v ) ; }	setter for depLabel - sets The dependency label of the token with respect to its head.
public string get semantic type ( ) { if ( token type . feat ok tst && ( ( token type ) jcas type ) . cas feat semantic type == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( token type ) jcas type ) . cas feat code semantic type ) ; }	getter for semanticType - gets A semantic type, typically the name of an Entity Annotation type.
public void set semantic type ( string v ) { if ( token type . feat ok tst && ( ( token type ) jcas type ) . cas feat semantic type == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( token type ) jcas type ) . cas feat code semantic type , v ) ; }	setter for semanticType - sets A semantic type, typically the name of an Entity Annotation type.
public string array get sections ( ) { if ( document type . feat ok tst && ( ( document type ) jcas type ) . cas feat sections == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( string array ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( document type ) jcas type ) . cas feat code sections ) ) ) ; }	getter for sections - gets Content of sections in the document.
public void set sections ( string array v ) { if ( document type . feat ok tst && ( ( document type ) jcas type ) . cas feat sections == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( document type ) jcas type ) . cas feat code sections , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for sections - sets Content of sections in the document.
public string get sections ( int i ) { if ( document type . feat ok tst && ( ( document type ) jcas type ) . cas feat sections == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . jcas . check array bounds ( jcas type . ll cas . ll get ref value ( addr , ( ( document type ) jcas type ) . cas feat code sections ) , i ) ; return jcas type . ll cas . ll get string array value ( jcas type . ll cas . ll get ref value ( addr , ( ( document type ) jcas type ) . cas feat code sections ) , i ) ; }	indexed getter for sections - gets an indexed value - Content of sections in the document.
public void set sections ( int i , string v ) { if ( document type . feat ok tst && ( ( document type ) jcas type ) . cas feat sections == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . jcas . check array bounds ( jcas type . ll cas . ll get ref value ( addr , ( ( document type ) jcas type ) . cas feat code sections ) , i ) ; jcas type . ll cas . ll set string array value ( jcas type . ll cas . ll get ref value ( addr , ( ( document type ) jcas type ) . cas feat code sections ) , i , v ) ; }	indexed setter for sections - sets an indexed value - Content of sections in the document.
public string list get uris ( ) { if ( concept type . feat ok tst && ( ( concept type ) jcas type ) . cas feat uris == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( string list ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( concept type ) jcas type ) . cas feat code uris ) ) ) ; }	getter for uris - gets Array of uris that identify this named entity.
public void set uris ( string list v ) { if ( concept type . feat ok tst && ( ( concept type ) jcas type ) . cas feat uris == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( concept type ) jcas type ) . cas feat code uris , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for uris - sets Array of uris that identify this named entity.
public fs get types ( ) { if ( concept type . feat ok tst && ( ( concept type ) jcas type ) . cas feat types == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( fs ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( concept type ) jcas type ) . cas feat code types ) ) ) ; }	getter for types - gets A list of concept types that the concept belongs to.
public void set types ( fs v ) { if ( concept type . feat ok tst && ( ( concept type ) jcas type ) . cas feat types == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( concept type ) jcas type ) . cas feat code types , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for types - sets A list of concept types that the concept belongs to.
public annotation get target type ( ) { if ( answer type type . feat ok tst && ( ( answer type type ) jcas type ) . cas feat target type == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( annotation ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( answer type type ) jcas type ) . cas feat code target type ) ) ) ; }	getter for targetType - gets The actual target type annotation.
public void set target type ( annotation v ) { if ( answer type type . feat ok tst && ( ( answer type type ) jcas type ) . cas feat target type == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( answer type type ) jcas type ) . cas feat code target type , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for targetType - sets The actual target type annotation.
public int get rank ( ) { if ( search result type . feat ok tst && ( ( search result type ) jcas type ) . cas feat rank == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get int value ( addr , ( ( search result type ) jcas type ) . cas feat code rank ) ; }	getter for rank - gets Rank of this result in the original hit-list.
public void set rank ( int v ) { if ( search result type . feat ok tst && ( ( search result type ) jcas type ) . cas feat rank == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set int value ( addr , ( ( search result type ) jcas type ) . cas feat code rank , v ) ; }	setter for rank - sets Rank of this result in the original hit-list.
public string get query string ( ) { if ( search result type . feat ok tst && ( ( search result type ) jcas type ) . cas feat query string == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( search result type ) jcas type ) . cas feat code query string ) ; }	getter for queryString - gets The query string associated with the hit.
public void set query string ( string v ) { if ( search result type . feat ok tst && ( ( search result type ) jcas type ) . cas feat query string == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( search result type ) jcas type ) . cas feat code query string , v ) ; }	setter for queryString - sets The query string associated with the hit.
public fs get candidate answers ( ) { if ( search result type . feat ok tst && ( ( search result type ) jcas type ) . cas feat candidate answers == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( fs ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( search result type ) jcas type ) . cas feat code candidate answers ) ) ) ; }	getter for candidateAnswers - gets CandidateAnswerVariants generated from this SearchResult.
public void set candidate answers ( fs v ) { if ( search result type . feat ok tst && ( ( search result type ) jcas type ) . cas feat candidate answers == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( search result type ) jcas type ) . cas feat code candidate answers , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for candidateAnswers - sets CandidateAnswerVariants generated from this SearchResult.
public candidate answer variant get candidate answers ( int i ) { if ( search result type . feat ok tst && ( ( search result type ) jcas type ) . cas feat candidate answers == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . jcas . check array bounds ( jcas type . ll cas . ll get ref value ( addr , ( ( search result type ) jcas type ) . cas feat code candidate answers ) , i ) ; return ( candidate answer variant ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref array value ( jcas type . ll cas . ll get ref value ( addr , ( ( search result type ) jcas type ) . cas feat code candidate answers ) , i ) ) ) ; }	indexed getter for candidateAnswers - gets an indexed value - CandidateAnswerVariants generated from this SearchResult.
public void set candidate answers ( int i , candidate answer variant v ) { if ( search result type . feat ok tst && ( ( search result type ) jcas type ) . cas feat candidate answers == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . jcas . check array bounds ( jcas type . ll cas . ll get ref value ( addr , ( ( search result type ) jcas type ) . cas feat code candidate answers ) , i ) ; jcas type . ll cas . ll set ref array value ( jcas type . ll cas . ll get ref value ( addr , ( ( search result type ) jcas type ) . cas feat code candidate answers ) , i , jcas type . ll cas . ll get fs ( v ) ) ; }	indexed setter for candidateAnswers - sets an indexed value - CandidateAnswerVariants generated from this SearchResult.
public string get query ( ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat query == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( search type ) jcas type ) . cas feat code query ) ; }	getter for query - gets The query in the native syntax of the corresponding search engine.
public void set query ( string v ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat query == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( search type ) jcas type ) . cas feat code query , v ) ; }	setter for query - sets The query in the native syntax of the corresponding search engine.
public fs get hit list ( ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat hit list == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( fs ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( search type ) jcas type ) . cas feat code hit list ) ) ) ; }	getter for hitList - gets Hit list of search results, sorted in descreasing order of relevance score.
public void set hit list ( fs v ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat hit list == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( search type ) jcas type ) . cas feat code hit list , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for hitList - sets Hit list of search results, sorted in descreasing order of relevance score.
public search result get hit list ( int i ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat hit list == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . jcas . check array bounds ( jcas type . ll cas . ll get ref value ( addr , ( ( search type ) jcas type ) . cas feat code hit list ) , i ) ; return ( search result ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref array value ( jcas type . ll cas . ll get ref value ( addr , ( ( search type ) jcas type ) . cas feat code hit list ) , i ) ) ) ; }	indexed getter for hitList - gets an indexed value - Hit list of search results, sorted in descreasing order of relevance score.
public void set hit list ( int i , search result v ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat hit list == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . jcas . check array bounds ( jcas type . ll cas . ll get ref value ( addr , ( ( search type ) jcas type ) . cas feat code hit list ) , i ) ; jcas type . ll cas . ll set ref array value ( jcas type . ll cas . ll get ref value ( addr , ( ( search type ) jcas type ) . cas feat code hit list ) , i , jcas type . ll cas . ll get fs ( v ) ) ; }	indexed setter for hitList - sets an indexed value - Hit list of search results, sorted in descreasing order of relevance score.
public abstract query get abstract query ( ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat abstract query == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( abstract query ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( search type ) jcas type ) . cas feat code abstract query ) ) ) ; }	getter for abstractQuery - gets The abstract query from which this actual query was generated.
public void set abstract query ( abstract query v ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat abstract query == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( search type ) jcas type ) . cas feat code abstract query , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for abstractQuery - sets The abstract query from which this actual query was generated.
public string get search id ( ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat search id == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( search type ) jcas type ) . cas feat code search id ) ; }	getter for searchId - gets An identifier for this search result.
public void set search id ( string v ) { if ( search type . feat ok tst && ( ( search type ) jcas type ) . cas feat search id == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( search type ) jcas type ) . cas feat code search id , v ) ; }	setter for searchId - sets An identifier for this search result.
public void set doc id ( string v ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat doc id == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( passage type ) jcas type ) . cas feat code doc id , v ) ; }	setter for docId - sets A unique identifier for the document that conatins this passage.
public int get offset in begin section ( ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat offset in begin section == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get int value ( addr , ( ( passage type ) jcas type ) . cas feat code offset in begin section ) ; }	getter for offsetInBeginSection - gets Character offset of the start of this passage within the section that contains this passage.
public void set offset in begin section ( int v ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat offset in begin section == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set int value ( addr , ( ( passage type ) jcas type ) . cas feat code offset in begin section , v ) ; }	setter for offsetInBeginSection - sets Character offset of the start of this passage within the section that contains this passage.
public int get offset in end section ( ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat offset in end section == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get int value ( addr , ( ( passage type ) jcas type ) . cas feat code offset in end section ) ; }	getter for offsetInEndSection - gets Character offset of the end of this passage within the section that contains this passage.
public void set offset in end section ( int v ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat offset in end section == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set int value ( addr , ( ( passage type ) jcas type ) . cas feat code offset in end section , v ) ; }	setter for offsetInEndSection - sets Character offset of the end of this passage within the section that contains this passage.
public string get begin section ( ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat begin section == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( passage type ) jcas type ) . cas feat code begin section ) ; }	getter for beginSection - gets The start section of this passage within the document that contains this passage.
public void set begin section ( string v ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat begin section == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( passage type ) jcas type ) . cas feat code begin section , v ) ; }	setter for beginSection - sets The start section of this passage within the document that contains this passage.
public string get end section ( ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat end section == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( passage type ) jcas type ) . cas feat code end section ) ; }	getter for endSection - gets The end section of this passage within the document that contains this passage.
public void set end section ( string v ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat end section == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( passage type ) jcas type ) . cas feat code end section , v ) ; }	setter for endSection - sets The end section of this passage within the document that contains this passage.
public string get aspects ( ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat aspects == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( passage type ) jcas type ) . cas feat code aspects ) ; }	getter for aspects - gets Aspects of the gold standard passage.
public void set aspects ( string v ) { if ( passage type . feat ok tst && ( ( passage type ) jcas type ) . cas feat aspects == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( passage type ) jcas type ) . cas feat code aspects , v ) ; }	setter for aspects - sets Aspects of the gold standard passage.
public triple get triple ( ) { if ( triple search result type . feat ok tst && ( ( triple search result type ) jcas type ) . cas feat triple == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( triple ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( triple search result type ) jcas type ) . cas feat code triple ) ) ) ; }	getter for triple - gets The relevant triple searched in the RDF store.
public void set triple ( triple v ) { if ( triple search result type . feat ok tst && ( ( triple search result type ) jcas type ) . cas feat triple == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( triple search result type ) jcas type ) . cas feat code triple , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for triple - sets The relevant triple searched in the RDF store.
public triple get source relation ( ) { if ( passage from relation type . feat ok tst && ( ( passage from relation type ) jcas type ) . cas feat source relation == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( triple ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( passage from relation type ) jcas type ) . cas feat code source relation ) ) ) ; }	getter for sourceRelation - gets The triple from which the search result was generated.
public void set source relation ( triple v ) { if ( passage from relation type . feat ok tst && ( ( passage from relation type ) jcas type ) . cas feat source relation == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( passage from relation type ) jcas type ) . cas feat code source relation , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for sourceRelation - sets The triple from which the search result was generated.
public string get subject ( ) { if ( triple type . feat ok tst && ( ( triple type ) jcas type ) . cas feat subject == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( triple type ) jcas type ) . cas feat code subject ) ; }	getter for subject - gets The subject of the triple - always a URI.
public void set subject ( string v ) { if ( triple type . feat ok tst && ( ( triple type ) jcas type ) . cas feat subject == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( triple type ) jcas type ) . cas feat code subject , v ) ; }	setter for subject - sets The subject of the triple - always a URI.
public string get predicate ( ) { if ( triple type . feat ok tst && ( ( triple type ) jcas type ) . cas feat predicate == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( triple type ) jcas type ) . cas feat code predicate ) ; }	getter for predicate - gets The predicate of the triple - always a URI.
public void set predicate ( string v ) { if ( triple type . feat ok tst && ( ( triple type ) jcas type ) . cas feat predicate == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( triple type ) jcas type ) . cas feat code predicate , v ) ; }	setter for predicate - sets The predicate of the triple - always a URI.
public boolean get is obj uri ( ) { if ( triple type . feat ok tst && ( ( triple type ) jcas type ) . cas feat is obj uri == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get boolean value ( addr , ( ( triple type ) jcas type ) . cas feat code is obj uri ) ; }	getter for isObjUri - gets Boolean flag - true of object field is a URI, false otherwise.
public void set is obj uri ( boolean v ) { if ( triple type . feat ok tst && ( ( triple type ) jcas type ) . cas feat is obj uri == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set boolean value ( addr , ( ( triple type ) jcas type ) . cas feat code is obj uri , v ) ; }	setter for isObjUri - sets Boolean flag - true of object field is a URI, false otherwise.
public query operator get operator ( ) { if ( complex query concept type . feat ok tst && ( ( complex query concept type ) jcas type ) . cas feat operator == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( query operator ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( complex query concept type ) jcas type ) . cas feat code operator ) ) ) ; }	getter for operator - gets The operator associated with this concept.
public void set operator ( query operator v ) { if ( complex query concept type . feat ok tst && ( ( complex query concept type ) jcas type ) . cas feat operator == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( complex query concept type ) jcas type ) . cas feat code operator , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for operator - sets The operator associated with this concept.
public fs get operator args ( ) { if ( complex query concept type . feat ok tst && ( ( complex query concept type ) jcas type ) . cas feat operator args == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( fs ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( complex query concept type ) jcas type ) . cas feat code operator args ) ) ) ; }	getter for operatorArgs - gets The operator arguments in a complex query concept.
public void set operator args ( fs v ) { if ( complex query concept type . feat ok tst && ( ( complex query concept type ) jcas type ) . cas feat operator args == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( complex query concept type ) jcas type ) . cas feat code operator args , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for operatorArgs - sets The operator arguments in a complex query concept.
public concept get concept ( ) { if ( concept mention type . feat ok tst && ( ( concept mention type ) jcas type ) . cas feat concept == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( concept ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( concept mention type ) jcas type ) . cas feat code concept ) ) ) ; }	getter for concept - gets The abstract concept that the text span conveys.
public double get score ( ) { if ( concept mention type . feat ok tst && ( ( concept mention type ) jcas type ) . cas feat score == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get double value ( addr , ( ( concept mention type ) jcas type ) . cas feat code score ) ; }	getter for score - gets The confidence score that the concept mention matches the concept.
public string get text ( ) { if ( candidate answer occurrence type . feat ok tst && ( ( candidate answer occurrence type ) jcas type ) . cas feat text == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( candidate answer occurrence type ) jcas type ) . cas feat code text ) ; }	getter for text - gets The candidate answer string.
public void set text ( string v ) { if ( candidate answer occurrence type . feat ok tst && ( ( candidate answer occurrence type ) jcas type ) . cas feat text == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( candidate answer occurrence type ) jcas type ) . cas feat code text , v ) ; }	setter for text - sets The candidate answer string.
public string get id ( ) { if ( concept type type . feat ok tst && ( ( concept type type ) jcas type ) . cas feat id == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( concept type type ) jcas type ) . cas feat code id ) ; }	getter for id - gets The id of the concept type.
public void set id ( string v ) { if ( concept type type . feat ok tst && ( ( concept type type ) jcas type ) . cas feat id == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( concept type type ) jcas type ) . cas feat code id , v ) ; }	setter for id - sets The id of the concept type.
public string get name ( ) { if ( concept type type . feat ok tst && ( ( concept type type ) jcas type ) . cas feat name == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( concept type type ) jcas type ) . cas feat code name ) ; }	getter for name - gets A human readable concept label.
public string get abbreviation ( ) { if ( concept type type . feat ok tst && ( ( concept type type ) jcas type ) . cas feat abbreviation == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( concept type type ) jcas type ) . cas feat code abbreviation ) ; }	getter for abbreviation - gets The abbreviation of the name label.
public void set abbreviation ( string v ) { if ( concept type type . feat ok tst && ( ( concept type type ) jcas type ) . cas feat abbreviation == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( concept type type ) jcas type ) . cas feat code abbreviation , v ) ; }	setter for abbreviation - sets The abbreviation of the name label.
public void set concept ( concept v ) { if ( concept search result type . feat ok tst && ( ( concept search result type ) jcas type ) . cas feat concept == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( concept search result type ) jcas type ) . cas feat code concept , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for concept - sets The relevant concept searched in the ontology.
public fs get variants ( ) { if ( answer type . feat ok tst && ( ( answer type ) jcas type ) . cas feat variants == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( fs ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( answer type ) jcas type ) . cas feat code variants ) ) ) ; }	getter for variants - gets List of candidate answer variants that were merged into this final answer.
public void set variants ( fs v ) { if ( answer type . feat ok tst && ( ( answer type ) jcas type ) . cas feat variants == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( answer type ) jcas type ) . cas feat code variants , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for variants - sets List of candidate answer variants that were merged into this final answer.
public string list get named entity types ( ) { if ( query concept type . feat ok tst && ( ( query concept type ) jcas type ) . cas feat named entity types == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( string list ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( query concept type ) jcas type ) . cas feat code named entity types ) ) ) ; }	getter for namedEntityTypes - gets List of Named Entity types associated with this concept.
public void set named entity types ( string list v ) { if ( query concept type . feat ok tst && ( ( query concept type ) jcas type ) . cas feat named entity types == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( query concept type ) jcas type ) . cas feat code named entity types , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for namedEntityTypes - sets List of Named Entity types associated with this concept.
public string get concept type ( ) { if ( query concept type . feat ok tst && ( ( query concept type ) jcas type ) . cas feat concept type == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( query concept type ) jcas type ) . cas feat code concept type ) ; }	getter for conceptType - gets The type of this concept.
public void set concept type ( string v ) { if ( query concept type . feat ok tst && ( ( query concept type ) jcas type ) . cas feat concept type == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( query concept type ) jcas type ) . cas feat code concept type , v ) ; }	setter for conceptType - sets The type of this concept.
public fs get occurrences ( ) { if ( candidate answer variant type . feat ok tst && ( ( candidate answer variant type ) jcas type ) . cas feat occurrences == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( fs ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( candidate answer variant type ) jcas type ) . cas feat code occurrences ) ) ) ; }	getter for occurrences - gets The occurrences of this variant.
public void set occurrences ( fs v ) { if ( candidate answer variant type . feat ok tst && ( ( candidate answer variant type ) jcas type ) . cas feat occurrences == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( candidate answer variant type ) jcas type ) . cas feat code occurrences , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for occurrences - sets The occurrences of this variant.
public fs get concepts ( ) { if ( abstract query type . feat ok tst && ( ( abstract query type ) jcas type ) . cas feat concepts == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( fs ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( abstract query type ) jcas type ) . cas feat code concepts ) ) ) ; }	getter for concepts - gets The list of query concepts that make up this abstract query.
public void set concepts ( fs v ) { if ( abstract query type . feat ok tst && ( ( abstract query type ) jcas type ) . cas feat concepts == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( abstract query type ) jcas type ) . cas feat code concepts , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for concepts - sets The list of query concepts that make up this abstract query.
public string get original text ( ) { if ( atomic query concept type . feat ok tst && ( ( atomic query concept type ) jcas type ) . cas feat original text == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( atomic query concept type ) jcas type ) . cas feat code original text ) ; }	getter for originalText - gets The lexical string in the question.
public void set original text ( string v ) { if ( atomic query concept type . feat ok tst && ( ( atomic query concept type ) jcas type ) . cas feat original text == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( atomic query concept type ) jcas type ) . cas feat code original text , v ) ; }	setter for originalText - sets The lexical string in the question.
public string list get args ( ) { if ( query operator type . feat ok tst && ( ( query operator type ) jcas type ) . cas feat args == null ) jcas type . jcas . throw feat missing ( str , str ) ; return ( string list ) ( jcas type . ll cas . ll get fs ( jcas type . ll cas . ll get ref value ( addr , ( ( query operator type ) jcas type ) . cas feat code args ) ) ) ; }	getter for args - gets The arguments for the operator.
public void set args ( string list v ) { if ( query operator type . feat ok tst && ( ( query operator type ) jcas type ) . cas feat args == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set ref value ( addr , ( ( query operator type ) jcas type ) . cas feat code args , jcas type . ll cas . ll get fs ( v ) ) ; }	setter for args - sets The arguments for the operator.
public string get label ( ) { if ( semantic role type . feat ok tst && ( ( semantic role type ) jcas type ) . cas feat label == null ) jcas type . jcas . throw feat missing ( str , str ) ; return jcas type . ll cas . ll get string value ( addr , ( ( semantic role type ) jcas type ) . cas feat code label ) ; }	getter for label - gets The semantic role label.
public void set label ( string v ) { if ( semantic role type . feat ok tst && ( ( semantic role type ) jcas type ) . cas feat label == null ) jcas type . jcas . throw feat missing ( str , str ) ; jcas type . ll cas . ll set string value ( addr , ( ( semantic role type ) jcas type ) . cas feat code label , v ) ; }	setter for label - sets The semantic role label.
public int next clear bit ( int index ) { int i = index > > num ; if ( i >= wlen ) return - num ; int sub index = index & num ;	Find the next clear bit in the bit set.
public boolean set ( int index ) { int word num = index > > num ;	Thread safe set operation that will set the bit if and only if the bit wasnot previously set.
protected void free buffer ( final byte buffer buffer ) throws io { if ( buffer == null ) { return ; } if ( unmap supported ) { try { access controller . do privileged ( new privileged exception action < void > ( ) { @ override public void run ( ) throws exception { final method get cleaner method = buffer . get class ( ) . get method ( str ) ; get cleaner method . set accessible ( bool ) ; final object cleaner = get cleaner method . invoke ( buffer ) ; if ( cleaner != null ) { cleaner . get class ( ) . get method ( str ) . invoke ( cleaner ) ; } return null ; } } ) ; } catch ( privileged action exception e ) { final io ioe = new io ( str ) ; ioe . init cause ( e . get cause ( ) ) ; throw ioe ; } } }	This code was copied form MMAPDirectory in Lucene.
public cache value new instance ( cache directory directory , string file name ) { return new instance ( directory , file name , get cache block size ( directory , file name ) ) ; }	Creates a new instance of CacheValue, the cache capacity should be used forthe given file.
private static object [ ] rehash ( final object [ ] values , final int new size ) { object [ ] new array = new object [ new size ] ; for ( object value : values ) { if ( value == null ) { continue ; } new array [ predicted position ( new array , value , value . hash code ( ) ) ] = value ; } return new array ; }	Rebuild the backing array with a different size.
public string to hel ( ) { string builder notation = new string builder ( ) ; for ( int i = num ; i < list monomer notations . size ( ) ; i ++ ) { notation . append ( list monomer notations . get ( i ) . to hel ( ) + str ) ; } notation . set length ( notation . length ( ) - num ) ; return notation . to string ( ) ; }	method to generate a valid HELM2 of this object.
private boolean check brackets parenthesis ( ) { log . debug ( str ) ; if ( bracket counter open == bracket counter close && parenthesis counter open == parenthesis counter close && curly bracket counter open == curly bracket counter close ) { return bool ; } return bool ; }	method to check if all open brackets are closed.
private void add details ( string str ) throws notation exception { string [ ] parts = str . split ( str ) ; source unit = parts [ num ] . split ( str ) [ num ] . to upper case ( ) ; target unit = parts [ num ] . split ( str ) [ num ] . to upper case ( ) ; r group source = parts [ num ] . split ( str ) [ num ] ; r group target = parts [ num ] . split ( str ) [ num ] ; pattern r = pattern . compile ( str , pattern . case insensitive ) ; pattern pair = pattern . compile ( str , pattern . case insensitive ) ; matcher m r = r . matcher ( r group source ) ; matcher m pair = pair . matcher ( r group target ) ; if ( m r . matches ( ) ) { r group source = r group source . to upper case ( ) ; } else { r group source = r group source . to lower case ( ) ; } if ( m pair . matches ( ) ) { r group target = r group target . to lower case ( ) ; } else { r group target = r group target . to upper case ( ) ; } }	method to set the details of the current connection.
public string to hel ( ) { if ( is annotation true ( ) ) { return source id . get id ( ) + str + target id . get id ( ) + str + source unit + str + r group source + str + target unit + str + r group target + str + annotation + str ; } else { return source id . get id ( ) + str + target id . get id ( ) + str + source unit + str + r group source + str + target unit + str + r group target ; } }	method to get a valid HELM2 of the connection notation.
public void add element ( string str , string type , double one , double two , boolean interval , boolean is default ) throws notation exception { this . elements . add ( validation method . decide which monomer notation in group ( str , type , one , two , interval , is default ) ) ; }	method to add a single element to the group.
public boolean check polymer id ( string polymer id ) { log . debug ( str + polymer id ) ; string pattern = str ; pattern p = pattern . compile ( pattern , pattern . case insensitive ) ; matcher m = p . matcher ( polymer id ) ; if ( m . matches ( ) ) { log . debug ( str + polymer id ) ; return bool ; } log . debug ( str + polymer id ) ; return bool ; }	method to validate the polymer id in the simple polymer section the id canbe peptide, rna, chem or blob.
public boolean check polymerid connection ( string polymer id ) { log . debug ( str ) ; string ratio = str ; string id = str ; string pattern = str + id + ratio + str + id + ratio + str + ratio + str + id + ratio + str ; pattern p = pattern . compile ( pattern , pattern . case insensitive ) ; matcher m = p . matcher ( polymer id ) ; if ( m . matches ( ) ) { log . debug ( str ) ; return bool ; } log . debug ( str + polymer id ) ; return bool ; }	method to validate the polymer id in the connection section the id can bepeptide, rna, chem or blob the ratio + range was also included, theambiguity is also proven.
public boolean check details connections ( string d ) { log . debug ( str ) ; string group = str ; string part one = str + group + str ; string part two = str ; string element = part one + str + part two ; string pattern connection = element + str + element ; string hydrogen bond partner = part one + str ; string hydrogen bond pattern = hydrogen bond partner + str + hydrogen bond partner ; pattern p connection = pattern . compile ( pattern connection , pattern . case insensitive ) ; matcher m connection = p connection . matcher ( d ) ; pattern p hydrogen = pattern . compile ( hydrogen bond pattern , pattern . case insensitive ) ; matcher m hydrogen = p hydrogen . matcher ( d ) ; if ( m connection . matches ( ) || m hydrogen . matches ( ) ) { log . debug ( str ) ; return bool ; } log . debug ( str + d ) ; return bool ; }	method to validate the details about the connections; hydrogen bonds arehere included.
public boolean check group id ( string d ) { pattern p = pattern . compile ( str , pattern . case insensitive ) ; matcher m = p . matcher ( d ) ; log . debug ( str ) ; if ( m . matches ( ) ) { log . debug ( str ) ; return bool ; } log . debug ( str ) ; return bool ; }	method to validate the group id.
public boolean check repeating ( string str ) { string pattern = str ; if ( str . matches ( pattern ) ) { return bool ; } return bool ; }	method to validate the repeating section it can be a single number or arange.
public boolean is peptide or rna ( ) throws simple polymer section exception { if ( polymer elements . size ( ) >= num ) { if ( polymer elements . get ( polymer elements . size ( ) - num ) . matches ( str ) ) { return bool ; } return bool ; } else { throw new simple polymer section exception ( str ) ; } }	method to check if the last added polymer element is a peptide or a rna.
protected string to json ( ) { object mapper mapper = new object mapper ( ) ; try { string json in = mapper . write value as string ( notation container ) ; json in = mapper . writer with default pretty printer ( ) . write value as string ( notation container ) ; return json in ; } catch ( exception e ) { e . print stack trace ( ) ; } return null ; }	method to generate a JSON-Object from the NotationContainer.
public polymer notation get simple polymer ( string string ) { for ( polymer notation polymer : list of polymers ) { if ( polymer . get polymer id ( ) . get id ( ) . equals ( string ) ) { return polymer ; } } return null ; }	method to get the simple polymer type.
@ json ignore public grouping notation get current grouping notation ( ) { if ( list of groupings . size ( ) == num ) { return null ; } return list of groupings . get ( list of groupings . size ( ) - num ) ; }	method to get the current grouping notation.
public string to hel ( ) { string output = str ; output += polymer to hel ( ) + str ; output += connection to hel ( ) + str ; output += grouping to hel ( ) + str ; output += annotation to hel ( ) + str ; output += str ; return output ; }	method to generate for all sections a HELM2 string.
public string polymer to hel ( ) { string builder notation = new string builder ( ) ; for ( int i = num ; i < list of polymers . size ( ) ; i ++ ) { if ( list of polymers . get ( i ) . is annotation here ( ) ) { notation . append ( list of polymers . get ( i ) . get polymer id ( ) + str + list of polymers . get ( i ) . to hel ( ) + str + list of polymers . get ( i ) . get annotation ( ) + str ) ; } else { notation . append ( list of polymers . get ( i ) . get polymer id ( ) + str + list of polymers . get ( i ) . to hel ( ) + str + str ) ; } } notation . set length ( notation . length ( ) - num ) ; return notation . to string ( ) ; }	method to generate a valid HELM2 string for the first section.
public string connection to hel ( ) { if ( list of connections . size ( ) == num ) { return str ; } string builder notation = new string builder ( ) ; for ( int i = num ; i < list of connections . size ( ) ; i ++ ) { notation . append ( list of connections . get ( i ) . to hel ( ) + str ) ; } notation . set length ( notation . length ( ) - num ) ; return notation . to string ( ) ; }	method to generate a valid HELM2 string for the second section.
public string grouping to hel ( ) { if ( list of groupings . size ( ) == num ) { return str ; } string builder notation = new string builder ( ) ; for ( int i = num ; i < list of groupings . size ( ) ; i ++ ) { notation . append ( list of groupings . get ( i ) . to hel ( ) + str ) ; } notation . set length ( notation . length ( ) - num ) ; return notation . to string ( ) ; }	method to generate a valid HELM2 string for the third section.
public string annotation to hel ( ) { if ( ! ( annotation section . is empty ( ) ) ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < annotation section . size ( ) ; i ++ ) { sb . append ( annotation section . get ( i ) . to hel ( ) + str ) ; } sb . set length ( sb . length ( ) - num ) ; return sb . to string ( ) ; } return str ; }	method to generate a valid HELM2 string for the fourth section.
@ json ignore public list < string > get polymer and grouping i ( ) { list < string > list of i = new array list < string > ( ) ; for ( polymer notation polymer : list of polymers ) { list of i . add ( polymer . get polymer id ( ) . get id ( ) ) ; } for ( grouping notation grouping : list of groupings ) { list of i . add ( grouping . get group id ( ) . get id ( ) ) ; } return list of i ; }	method to get the ID's from all polymers and groups.
@ json ignore public polymer notation get polymer notation ( string id ) { for ( polymer notation polymer : list of polymers ) { if ( polymer . get polymer id ( ) . get id ( ) . equals ( id ) ) { return polymer ; } } return null ; }	method to get a specific polymer by its id.
private void set polymer elements ( ) { if ( polymer id instanceof rna || polymer id instanceof peptide entity ) { this . polymer elements = new polymer list elements ( polymer id ) ; } else { this . polymer elements = new polymer single elements ( polymer id ) ; } }	method to generate the right PolymerElements, in the case of Chem and Blobonly one Monomer is allowed.
public string do convert ( string str ) {	method to convert the given string into the HELM2 format.
public void set annotation ( string str ) { if ( str != null ) { annotation = str ; is annotation here = bool ; } else { annotation = null ; is annotation here = bool ; } }	method to add annotation to this monomer.
public void set count ( string str ) { is default = bool ; if ( str . equals ( str ) ) { is default = bool ; } count = str ; }	method to change the default count of one to the user-defined.
public static monomer notation decide which monomer notation ( string str , string type ) throws notation exception { monomer notation mon ; if ( str . starts with ( str ) && str . ends with ( str ) ) { string str2 = str . substring ( num , str . length ( ) - num ) ; pattern pattern and = pattern . compile ( str ) ; pattern pattern or = pattern . compile ( str ) ; if ( pattern and . matcher ( str ) . find ( ) ) { mon = new monomer notation group mixture ( str2 , type ) ; } else if ( pattern or . matcher ( str ) . find ( ) ) { mon = new monomer notation group or ( str2 , type ) ; } else { if ( str . contains ( str ) ) { mon = new monomer notation list ( str2 , type ) ; } else { if ( type == str ) { mon = new rna ( str2 , type ) ; } else { if ( str2 . length ( ) > num ) { if ( ! ( str2 . starts with ( str ) && str2 . ends with ( str ) ) ) { throw new notation exception ( str + str ) ; } } mon = new monomer notation unit ( str2 , type ) ; } } } } else { if ( type == str ) {	method to decide which of the MonomerNotation classes should beinitialized.
public static monomer notation group element decide which monomer notation in group ( string str , string type , double one , double two , boolean interval , boolean is default ) throws notation exception { monomer notation element ; element = decide which monomer notation ( str , type ) ; if ( interval ) { return new monomer notation group element ( element , one , two ) ; } else { return new monomer notation group element ( element , one , is default ) ; } }	method to decide which of the two Constructors ofMonomerNotationGroupElement should be called.
public static helm decide which entity ( string str ) throws notation exception { helm item ; if ( str . to upper case ( ) . matches ( str ) ) { item = new peptide entity ( str . to upper case ( ) ) ; } else if ( str . to upper case ( ) . matches ( str ) ) { item = new rna ( str . to upper case ( ) ) ; } else if ( str . to upper case ( ) . matches ( str ) ) { item = new blob entity ( str . to upper case ( ) ) ; } else if ( str . to upper case ( ) . matches ( str ) ) { item = new chem entity ( str . to upper case ( ) ) ; } else if ( str . to upper case ( ) . matches ( str ) ) { item = new group entity ( str . to upper case ( ) ) ; } else { throw new notation exception ( str + str ) ; } return item ; }	method to decide which of the Entities classes should be initialized.
public list < double > get value ( ) { if ( this . is interval ) { return new array list < double > ( arrays . as list ( number one , number two ) ) ; } else { return new array list < double > ( arrays . as list ( number one ) ) ; } }	method to get the ratio or the interval of this group, in the case of aninterval it returns a list of two values.
public void parse ( string test ) throws exception state { parser = new state machine parser ( ) ; test = test . trim ( ) ; if ( test . substring ( test . length ( ) - num ) . matches ( str ) || test . substring ( test . length ( ) - num ) . matches ( str ) ) { for ( int i = num ; i < test . length ( ) - num ; i ++ ) { parser . do action ( test . char at ( i ) ) ; } if ( ! ( parser . get state ( ) instanceof final state ) ) { log . error ( str ) ; throw new final state exception ( str ) ; } } else { log . error ( str ) ; throw new hel ( str ) ; } }	method to parse the given HELM2 string in the case of an invalid HELM2 notation exception is thrown.
private void set rna ( string str ) throws notation exception { string [ ] list ;	method to set for each nucleotide the sugar, the base and the phosphat.
private void define ambiguity ( string a ) throws notation exception { pattern pattern and = pattern . compile ( str ) ; matcher m = pattern and . matcher ( a ) ; if ( m . find ( ) ) { set ambiguity ( new grouping mixture ( a ) ) ; } else { set ambiguity ( new grouping or ( a ) ) ; } }	method to add ambiguity to the group.
a get statistics ( ) { return new a ( get state ( ) , get id ( ) , stat num tasks executed , stat num shared tasks executed , stat num steals , stat num exceptions , stat num parks , stat num false alarm unparks , stat num shared queue switches , stat num local submits , local queue . approximate size ( ) ) ; }	This method returns an approximation of this thread's execution statistics for the entire period since the thread was started.
public static < n , e extends a < n > > a < n , e > create ( collection < e > edges ) { final set < n > result = new hash set < > ( ) ; for ( e edge : edges ) { result . add ( edge . get from ( ) ) ; result . add ( edge . get to ( ) ) ; } return create ( result , edges ) ; }	This is a convenience factory method that extracts the list of nodes from the edges.
public static < n , e extends a < n > > a < n , e > create ( collection < n > nodes , collection < e > edges ) { final object [ ] node arr = new object [ nodes . size ( ) ] ; final a [ ] edge arr = new a [ edges . size ( ) ] ; int idx = num ; for ( n node : nodes ) { node arr [ idx ] = node ; idx += num ; } idx = num ; for ( e edge : edges ) { edge arr [ idx ] = edge ; idx += num ; } return new a < n , e > ( node arr , edge arr ) ; }	This factory method creates a graph with the given nodes and edges.
private void init paths internal ( ) { synchronized ( lock ) { if ( incoming paths internal == null ) { a < n , a < a < n , e > > > incoming paths = a . empty ( ) ;	This method does the reachability analysis in a way that is useful for many other methods.
public list < n > sorted nodes by reachability ( ) throws a { if ( has cycles ( ) ) { throw new a ( ) ; } final object [ ] result = new object [ nodes . length ] ; int next idx = num ; final set < n > unprocessed = new hash set < > ( ) ; for ( object node : nodes ) {	A directed graph defines a partial order through 'reachability', and this method sorts the graph's nodes based on thatpartial order.
public void subscribe ( final string pattern , final class < ? > clazz , final string method name ) throws no such method exception { this . subscribe ( pattern , new function object9 ( this , clazz , method name ) ) ; }	Subscribes a static method to a service name pattern.
public int subscribe count ( final string pattern ) throws invalid input exception , terminate exception { otp output stream subscribe count = new otp output stream ( ) ; subscribe count . write ( otp external . version tag ) ; final otp erlang object [ ] tuple = { new otp erlang atom ( str ) , new otp erlang string ( pattern ) } ; subscribe count . write any ( new otp erlang tuple ( tuple ) ) ; send ( subscribe count ) ; try { return ( integer ) poll request ( null , bool ) ; } catch ( message decoding exception e ) { e . print stack trace ( api . err ) ; return - num ; } }	Determine how may service name pattern subscriptions have occurred.
public void unsubscribe ( final string pattern ) throws invalid input exception { final string s = this . prefix + pattern ; linked list < function interface9 > callback list = this . callbacks . get ( s ) ; if ( callback list == null ) { throw new invalid input exception ( ) ; } else { callback list . remove first ( ) ; if ( callback list . is empty ( ) ) { this . callbacks . remove ( s ) ; } } otp output stream unsubscribe = new otp output stream ( ) ; unsubscribe . write ( otp external . version tag ) ; final otp erlang object [ ] tuple = { new otp erlang atom ( str ) , new otp erlang string ( pattern ) } ; unsubscribe . write any ( new otp erlang tuple ( tuple ) ) ; send ( unsubscribe ) ; }	Unsubscribes from a service name pattern.
public void return ( final integer request type , final string name , final string pattern , final byte [ ] response info , final byte [ ] response , final integer timeout , final byte [ ] trans id , final otp erlang pid pid ) throws return async exception , return sync exception , invalid input exception { if ( request type == api . async ) return async ( name , pattern , response info , response , timeout , trans id , pid ) ; else if ( request type == api . sync ) return sync ( name , pattern , response info , response , timeout , trans id , pid ) ; else throw new invalid input exception ( ) ; }	Returns a response from a service request.
public void return sync ( final string name , final string pattern , byte [ ] response info , byte [ ] response , integer timeout , final byte [ ] trans id , final otp erlang pid pid ) throws return sync exception { try { otp output stream return sync = new otp output stream ( ) ; return sync . write ( otp external . version tag ) ; final otp erlang object [ ] tuple = { new otp erlang atom ( str ) , new otp erlang string ( name ) , new otp erlang string ( pattern ) , new otp erlang binary ( response info ) , new otp erlang binary ( response ) , new u ( timeout ) , new otp erlang binary ( trans id ) , pid } ; return sync . write any ( new otp erlang tuple ( tuple ) ) ; send ( return sync ) ; } catch ( otp erlang range exception e ) { e . print stack trace ( api . err ) ; return ; } throw new return sync exception ( ) ; }	Synchronously returns a response from a service request.
public boolean poll ( final int timeout ) throws invalid input exception , message decoding exception , terminate exception { if ( boolean . true == poll request ( timeout , bool ) ) return bool ; return bool ; }	Blocks to process incoming CloudI service requests.
public void shutdown ( final string reason ) { otp output stream shutdown = new otp output stream ( ) ; shutdown . write ( otp external . version tag ) ; final otp erlang object [ ] tuple = { new otp erlang atom ( str ) , new otp erlang string ( reason ) } ; shutdown . write any ( new otp erlang tuple ( tuple ) ) ; send ( shutdown ) ; }	Shutdown the service successfully.
public static < t extends throwable > t for local handling ( t th ) { if ( requires non local handling ( th ) ) { a . throw unchecked ( th ) ; } return th ; }	This method checks if a given Throwable is fit for local handling, returning it if it is andthrowing it otherwise.
private void unlock run state ( int old run state , int new run state ) { if ( ! u . compare and swap int ( this , runstate , old run state , new run state ) ) { object lock = steal counter ; run state = new run state ;	Unlocks and sets runState to newRunState.
private boolean create worker ( ) { fork join worker thread factory fac = factory ; throwable ex = null ; fork join worker thread wt = null ; try { if ( fac != null && ( wt = fac . new thread ( this ) ) != null ) { wt . start ( ) ; return bool ; } } catch ( throwable rex ) { ex = rex ; } deregister worker ( wt , ex ) ; return bool ; }	Tries to construct and start one worker.
private void try add worker ( long c ) { boolean add = bool ; do { long nc = ( ( ac mask & ( c + ac unit ) ) | ( tc mask & ( c + tc unit ) ) ) ; if ( ctl == c ) { int rs , stop ;	Tries to add one worker, incrementing ctl counts before doingso, relying on createWorker to back out on failure.
final work queue register worker ( fork join worker thread wt ) { uncaught exception handler handler ; wt . set daemon ( bool ) ;	Callback from ForkJoinWorkerThread constructor to establish andrecord its WorkQueue.
final void deregister worker ( fork join worker thread wt , throwable ex ) { work queue w = null ; if ( wt != null && ( w = wt . work queue ) != null ) { work queue [ ] ws ;	Final callback from terminating worker, as well as upon failureto construct or start a worker.
final void signal work ( work queue [ ] ws , work queue q ) { long c ; int sp , i ; work queue v ; thread p ; while ( ( c = ctl ) < num ) {	Tries to create or activate a worker if too few are active.
final void run worker ( work queue w ) { w . grow array ( ) ;	Top-level runloop for workers, called by ForkJoinWorkerThread.run.
private boolean await work ( work queue w , int r ) { if ( w == null || w . qlock < num )	Possibly blocks worker w waiting for a task to steal, orreturns false if the worker should terminate.
static work queue common submitter queue ( ) { fork join pool p = common ; int r = thread local random helper . get probe ( ) ; work queue [ ] ws ; int m ; return ( p != null && ( ws = p . work queues ) != null && ( m = ws . length - num ) >= num ) ? ws [ m & r & sqmask ] : null ; }	Returns common pool queue for an external thread.
final int external help complete ( counted completer < ? > task , int max tasks ) { work queue [ ] ws ; int n ; int r = thread local random helper . get probe ( ) ; return ( ( ws = work queues ) == null || ( n = ws . length ) == num ) ? num : help complete ( ws [ ( n - num ) & r & sqmask ] , task , max tasks ) ; }	Performs helpComplete for an external submitter.
public < t > fork join task < t > submit ( fork join task < t > task ) { if ( task == null ) throw new null pointer exception ( ) ; external push ( task ) ; return task ; }	Submits a ForkJoinTask for execution.
private static fork join pool make common pool ( ) { int parallelism = - num ; fork join worker thread factory factory = null ; uncaught exception handler handler = null ; try {	Creates and returns the common pool, respecting user settingsspecified via system properties.
public final v get ( long timeout , time unit unit ) throws interrupted exception , execution exception , timeout exception { int s ; long nanos = unit . to nanos ( timeout ) ; if ( thread . interrupted ( ) ) throw new interrupted exception ( ) ; if ( ( s = status ) >= num && nanos > num ) { long d = system . nano time ( ) + nanos ; long deadline = ( d == num ) ? num : d ;	Waits if necessary for at most the given time for the computationto complete, and then retrieves its result, if available.
public static < e extends throwable > string build string ( a < a , e > code ) throws e { final byte array output stream baos = new byte array output stream ( ) ; code . apply ( new a ( baos ) ) ; return new string ( baos . to byte array ( ) , utf 8 ) ; }	This is a convenience method for building simple JSON strings.
@ override public a get statistics ( ) { final a [ ] worker stats = new a [ local queues . length ] ; for ( int i = num ; i < local queues . length ; i ++ ) {	This method returns an approximation of statistical data for all worker threads since the pool was started.
@ safe varargs public static < t > a < t > create ( t ... elements ) { return create ( arrays . as list ( elements ) ) ; }	Creates an AList from a given list of elements.
public a < t > reverse ( ) { a < t > remaining = this ; a < t > result = nil ( ) ; while ( ! remaining . is empty ( ) ) { result = result . cons ( remaining . head ( ) ) ; remaining = remaining . tail ( ) ; } return result ; }	Returns a copy of this AList with elements in reversed order.
public static < t , e extends throwable > boolean for all ( iterable < t > coll , a < ? super t , e > pred ) throws e { for ( t o : coll ) { if ( ! pred . apply ( o ) ) { return bool ; } } return bool ; }	Matches a predicate against collection elements, and returns true iff it matches them all.
public static < t , r , e extends throwable > r fold left ( iterable < t > coll , r start value , a < r , ? super t , r , e > f ) throws e { r result = start value ; for ( t e : coll ) { result = f . apply ( result , e ) ; } return result ; }	Applies a binary operator to a start value and all elements of this sequence, going left to right.
public static < t , r , e extends throwable > r fold right ( list < t > coll , r start value , a < r , ? super t , r , e > f ) throws e { r result = start value ; list iterator < t > i = coll . list iterator ( coll . size ( ) ) ; while ( i . has previous ( ) ) { result = f . apply ( result , i . previous ( ) ) ; } return result ; }	Applies a binary operator to a start value and all elements of this list, going left to right.
void push ( runnable task ) { final long base = unsafe . get long volatile ( this , offs base ) ;	Add a new task to the top of the localQueue, incrementing 'top'.
public static < t > a < t > from nullable ( t nullable ) { return nullable != null ? some ( nullable ) : a . < t > none ( ) ; }	This is a convenience method that creates an AOption based on Java conventions.
public static < v > a < v > from keys and values ( iterable < ? extends number > keys , iterable < v > values ) { final iterator < ? extends number > ki = keys . iterator ( ) ; final iterator < v > vi = values . iterator ( ) ; a < v > result = a . empty ( ) ; while ( ki . has next ( ) ) { final number key = ki . next ( ) ; final v value = vi . next ( ) ; result = result . updated ( key . long value ( ) , value ) ; } return result ; }	Returns an ALongHashMap initialized from separate 'keys' and 'values' collections.
@ suppress warnings ( str ) public static < k , v > a < k , v > empty ( a equality ) { if ( equality == a . equals ) return ( a < k , v > ) empty equals ; if ( equality == a . identity ) return ( a < k , v > ) empty identity ; return new a < > ( equality ) ; }	Returns an empty AListMap instance with a given equalityForEquals.
public static < k , v > a < k , v > from keys and values ( a equality , iterable < a < k , v > > elements ) { a < k , v > result = empty ( equality ) ; for ( a < k , v > el : elements ) { result = result . updated ( el . 1 , el . 2 ) ; } return result ; }	Returns an AHashMap instance with a given equalityForEquals, initializing it from separate 'keys'and 'values' collections.
public static < k , v > a < k , v > from keys and values ( a equality , iterable < k > keys , iterable < v > values ) { final iterator < k > ki = keys . iterator ( ) ; final iterator < v > vi = values . iterator ( ) ; a < k , v > result = empty ( equality ) ; while ( ki . has next ( ) ) { final k key = ki . next ( ) ; final v value = vi . next ( ) ; result = result . updated ( key , value ) ; } return result ; }	Returns an AListMap instance with a given equalityForEquals, initializing it from separate 'keys'and 'values' collections.
@ override public set < k > key set ( ) { return new abstract set < k > ( ) { @ override public iterator < k > iterator ( ) { return new iterator < k > ( ) { final iterator < a < k , v > > it = inner . iterator ( ) ; @ override public boolean has next ( ) { return it . has next ( ) ; } @ override public k next ( ) { return it . next ( ) . get key ( ) ; } @ override public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; } @ override public int size ( ) { return inner . size ( ) ; } } ; }	There is usually a performance gain to be had by overriding this default implementation.
private string normalize resource name ( string name ) { if ( name . starts with ( str ) ) { return str + name ; } final int first protocol = name . index of ( str ) ; final int second protocol = name . index of ( str , first protocol + num ) ; final int protocol = second protocol < num ? first protocol : second protocol ; final int end of first = name . last index of ( str , protocol ) ; if ( end of first >= num ) { return name . substring ( end of first + num ) ; } return name ; }	-> hack to undo this.
@ override public string marshal ( bound type v ) throws exception { class < ? extends object > type = v . get class ( ) ; if ( ! types . is user defined value type ( type ) ) { throw new illegal argument exception ( str + type + str + str + str ) ; } converter converter = convert utils . lookup ( type ) ; if ( ( converter != null && converter instanceof abstract converter ) ) { string string = ( string ) convert utils . convert ( v , string . class ) ; if ( string != null ) { return string ; } } return v . to string ( ) ; }	Marshals the specified user-defined value type object to single XML valuestring representation.
public char sequence sub sequence ( int start , int end ) { int len = end - start ; return new string builder ( len ) . append ( to array ( start , len ) ) ; }	Returns sub sequence.
public static < t extends comparable > binary search < t > for list ( final list < t > list ) { return new binary search < t > ( ) { @ override @ suppress warnings ( { str } ) protected int compare ( int index , t element ) { return list . get ( index ) . compare to ( element ) ; } @ override protected int get last index ( ) { return list . size ( ) - num ; } } ; }	Creates binary search wrapper over a list of comparable elements.
public static < t > binary search < t > for list ( final list < t > list , final comparator < t > comparator ) { return new binary search < t > ( ) { @ override @ suppress warnings ( { str } ) protected int compare ( int index , t element ) { return comparator . compare ( list . get ( index ) , element ) ; } @ override protected int get last index ( ) { return list . size ( ) - num ; } } ; }	Creates binary search wrapper over a list with given comparator.
public static future < boolean > send message ( final email msg ) { if ( asynchronous send ) { return executor . submit ( new callable < boolean > ( ) { public boolean call ( ) { try { msg . set sent date ( new date ( ) ) ; msg . send ( ) ; return bool ; } catch ( throwable e ) { mail exception me = new mail exception ( str , e ) ; logger . error ( str , me ) ; return bool ; } } } ) ; } else { final string buffer result = new string buffer ( ) ; try { msg . set sent date ( new date ( ) ) ; msg . send ( ) ; } catch ( throwable e ) { mail exception me = new mail exception ( str , e ) ; logger . error ( str , me ) ; result . append ( str ) ; } return new future < boolean > ( ) { public boolean cancel ( boolean may interrupt if running ) { return bool ; } public boolean is cancelled ( ) { return bool ; } public boolean is done ( ) { return bool ; } public boolean get ( ) throws interrupted exception , execution exception { return result . length ( ) == num ; } public boolean get ( long timeout , time unit unit ) throws interrupted exception , execution exception , timeout exception { return result . length ( ) == num ; } } ; } }	Send a JavaMail message.
public void bind ( final route binding handler ) { final method method = handler . get method ( ) ; logger . info ( str , app accept id , default version ) ; list < string > versions = handler . get versions ( ) ; if ( versions == null || versions . is empty ( ) ) { versions = collections . singleton list ( default version ) ; } for ( final string version : versions ) { final set < method > methods = new hash set < > ( ) ; if ( method == method . any ) { for ( final method m : method . values ( ) ) { methods . add ( m ) ; } } else { methods . add ( method ) ; } for ( final method m : methods ) { final binding key key = new binding key ( m , version ) ; list < pattern route binding > b = route bindings . get ( key ) ; if ( b == null ) { b = new array list < > ( ) ; route bindings . put ( key , b ) ; } logger . info ( str , key , handler . get path ( ) , handler ) ; add pattern ( handler , b ) ; } } }	Specify a handler that will be called for all HTTP methods.
public void bind ( final filter binding handler ) { final method method = handler . get method ( ) ; final string path = handler . get path ( ) ; logger . info ( str , app accept id , default version ) ; list < string > versions = handler . get versions ( ) ; if ( versions == null || versions . is empty ( ) ) { versions = collections . singleton list ( default version ) ; } for ( final string version : versions ) { final set < method > methods = new hash set < > ( ) ; if ( method == method . any ) { for ( final method m : method . values ( ) ) { methods . add ( m ) ; } } else { methods . add ( method ) ; } for ( final method m : methods ) { final binding key key = new binding key ( m , version ) ; logger . info ( str , key , path , handler ) ; list < pattern filter binding > all filter bindings = this . filter bindings . get ( key ) ; if ( all filter bindings == null ) { all filter bindings = new array list < > ( ) ; this . filter bindings . put ( key , all filter bindings ) ; } boolean found = bool ; for ( final pattern filter binding binding : all filter bindings ) { if ( binding . get pattern ( ) . pattern ( ) . equals ( handler . get path ( ) ) ) { binding . add filter ( handler ) ; found = bool ; break ; } } if ( ! found ) { final pattern filter binding binding = new pattern filter binding ( handler . get path ( ) , handler ) ; all filter bindings . add ( binding ) ; } } } }	Specify a filter handler that will be used to wrap route executions.
@ override protected boolean show tag body ( string role name ) { boolean has any role = bool ; subject subject = get subject ( ) ; if ( subject != null ) {	Delimeter that separates role names in tag attribute.
public static int get int ( long l ) { return ( l == null || l > integer . max value ) ? num : l . int value ( ) ; }	Converts packing Long Int.
public static string [ ] remove duplicate strings ( string [ ] array ) { if ( object kit . is empty ( array ) ) { return array ; } set < string > set = new tree set < string > ( ) ; for ( string element : array ) { set . add ( element ) ; } return to string array ( set ) ; }	Remove duplicate Strings from the given array.Also sorts the array, as it uses a TreeSet.
public static string like ( string value ) { return string pool . percent + strings . null to empty ( value ) + string pool . percent ; }	Stitching LIKE SQL percent.
public void do run ( ) throws exception { if ( in progress . compare and set ( bool , bool ) ) { try { run ( ) ; } finally { in progress . set ( bool ) ; } } else { throw new illegal state exception ( str ) ; } }	Run from the web interface.
public static < t extends model > boolean login ( t user , string password , boolean remember , http servlet request request , http servlet response response ) { boolean matcher = security kit . check password ( user . get str ( str ) , user . get str ( str ) , password ) ; if ( matcher ) { security kit . set login member ( request , response , user , remember ) ; } return matcher ; }	Check the user's password, and execute the login request.
public static < t extends model > t get login user ( http servlet request req ) { return ( t ) req . get session ( ) . get attribute ( login session key ) ; }	Obtain user information from the Session.
public static boolean check password ( string salt , string password , string plain password ) { byte [ ] salt hex = encode kit . decode hex ( salt ) ; byte [ ] hash password = digests kit . sha1 ( plain password . get bytes ( ) , salt hex , encode kit . hash interations ) ; return string utils . equals ( encode kit . encode hex ( hash password ) , password ) ; }	Check Password , salt, password, planpassword.
public static < t extends model > void save member in cookie ( t user , boolean save , http servlet request request , http servlet response response ) { string new value = get login key ( user , requests . remote ip ( request ) , request . get header ( str ) ) ; int max age = save ? max age : - num ; requests . delete cookie ( request , response , cookie login , bool ) ; requests . set cookie ( request , response , cookie login , new value , max age , bool ) ; }	Store user information in a cookie logged in.
private static < t extends model > string get login key ( t user , string ip , string user agent ) { return encrypt ( string . value of ( user . get number ( string pool . pk column ) ) + str + user . get str ( str ) + str + ip + str + ( ( user agent == null ) ? num : user agent . hash code ( ) ) + str + system . current time millis ( ) ) ; }	Generating system user login ID string.
private static cookie user user for cookie ( string uuid , http servlet request request ) { if ( string utils . is blank ( uuid ) ) { return null ; } string ck = decrypt ( uuid ) ; final string [ ] items = string utils . split ( ck , str ) ; if ( items . length == num ) { string ua = request . get header ( str ) ; int ua code = ( ua == null ) ? num : ua . hash code ( ) ; int old ua code = integer . parse int ( items [ num ] ) ; if ( ua code == old ua code ) { return new cookie user ( number utils . to long ( items [ num ] , - num ) , items [ num ] , bool ) ; } } return null ; }	Obtain user information from the Cookie.
public void to ( web context context ) { http servlet request request = context . request ( ) ; http servlet response response = context . response ( ) ; try { request . get request dispatcher ( path ) . forward ( request , response ) ; } catch ( servlet exception e ) { throw new unchecked exception ( e ) ; } catch ( io e ) { throw new unchecked exception ( e ) ; } }	Forwards HTTP request to the specified path.
public static long param ( http servlet request request , string param , long default value ) { return number utils . to long ( request . get parameter ( param ) , default value ) ; }	Get shaping parameters submitted by the browser.
public static void debug ( string message , object ... args ) { if ( record caller ) { logger factory . get logger ( get caller class name ( ) ) . debug ( message , args ) ; } else { slf4j . debug ( message , args ) ; } }	Log with DEBUG level.
static call info get caller informations ( int level ) { stack trace element [ ] call stack = thread . current thread ( ) . get stack trace ( ) ; stack trace element caller = call stack [ level ] ; return new call info ( caller . get class name ( ) , caller . get method name ( ) ) ; }	Examine stack trace to get caller.
public static byte [ ] to simple byte array ( char [ ] carr ) { byte [ ] barr = new byte [ carr . length ] ; for ( int i = num ; i < carr . length ; i ++ ) { barr [ i ] = ( byte ) carr [ i ] ; } return barr ; }	Converts char array into byte array by stripping the high byte of each character.
public static byte [ ] to simple byte array ( char sequence char sequence ) { byte [ ] barr = new byte [ char sequence . length ( ) ] ; for ( int i = num ; i < barr . length ; i ++ ) { barr [ i ] = ( byte ) char sequence . char at ( i ) ; } return barr ; }	Converts char sequence into byte array.
public static char [ ] to simple char array ( byte [ ] barr ) { char [ ] carr = new char [ barr . length ] ; for ( int i = num ; i < barr . length ; i ++ ) { carr [ i ] = ( char ) ( barr [ i ] & num ) ; } return carr ; }	Converts byte array to char array by simply extending bytes to chars.
public static byte [ ] to ascii byte array ( char sequence char sequence ) { byte [ ] barr = new byte [ char sequence . length ( ) ] ; for ( int i = num ; i < barr . length ; i ++ ) { char c = char sequence . char at ( i ) ; barr [ i ] = ( byte ) ( ( int ) ( c <= num ? c : num ) ) ; } return barr ; }	Converts char sequence into ASCII byte array.
protected static locale data lookup locale data ( string code ) { locale data locale data = locales . get ( code ) ; if ( locale data == null ) { string [ ] data = decode locale code ( code ) ; locale data = new locale data ( new locale ( data [ num ] , data [ num ] , data [ num ] ) ) ; locales . put ( code , locale data ) ; } return locale data ; }	Lookups for locale data and creates new if it doesn't exist.
public promise < v > in ( int seconds ) { final promise < v > smart future = new promise < v > ( ) ; jobs plugin . executor . schedule ( get job calling callable ( smart future ) , seconds , time unit . seconds ) ; return smart future ; }	Start this job in several seconds.
public static void crop ( file original image , file to , int x1 , int y1 , int x2 , int y2 ) { try { buffered image source = io . read ( original image ) ; string mime type = str ; if ( to . get name ( ) . ends with ( str ) ) { mime type = str ; } if ( to . get name ( ) . ends with ( str ) ) { mime type = str ; } int width = x2 - x1 ; int height = y2 - y1 ;	Crop an image.
public static future < ? > invoke ( final invocation invocation , long millis ) { return executor . schedule ( invocation , millis , time unit . milliseconds ) ; }	Run the code in a new thread after a delay.
public static void invoke in thread ( direct invocation invocation ) { boolean retry = bool ; while ( retry ) { invocation . run ( ) ; if ( invocation . retry == null ) { retry = bool ; } else { try { if ( invocation . retry . task != null ) { invocation . retry . task . get ( ) ; } else { thread . sleep ( invocation . retry . timeout ) ; } } catch ( exception e ) { throw new unexpected exception ( e ) ; } retry = bool ; } } }	Run the code in the same thread than caller.
@ nonnull public rest operations get rest operations ( ) { final http client builder builder = http client builder . create ( ) ; init default http client builder ( builder ) ; http request factory = new http components client http request factory ( builder . build ( ) ) ; final rest template rest template = new rest template ( message converters ) ; rest template . set request factory ( http request factory ) ; return rest template ; }	Returns rest operations object, suitable for use with the specified credentials.
protected void render ajax error ( string error , exception e ) { render json ( ajax message . error ( error , e ) ) ; }	Rendering errors information, in Json format.
protected < t > void render ajax forbidden ( string message , t data ) { render json ( ajax message . forbidden ( message , data ) ) ; }	In the form of JSON rendering forbidden information.
protected string template ( string view ) { final enumeration < string > attrs = get attr names ( ) ; final map < string , object > root = maps . new hash map ( ) ; while ( attrs . has more elements ( ) ) { string attr name = attrs . next element ( ) ; root . put ( attr name , get attr ( attr name ) ) ; } return freemarkers . process string ( view , root ) ; }	Render view as a string.
protected string parse path ( string current action path , string url ) { if ( url . starts with ( slash ) ) { return url . split ( str ) [ num ] ; } else if ( ! url . contains ( slash ) ) { return slash + current action path . split ( slash ) [ num ] + slash + url . split ( str ) [ num ] ; } else if ( url . contains ( str ) || url . contains ( str ) ) { return null ; }	Based on the current path structure is going to jump full Action of the path.
protected void render data tables ( class < ? extends model > m cls ) { dt criterias = get criterias ( ) ; preconditions . check not null ( criterias , str ) ; dt response = criterias . response ( m cls ) ; render json ( response ) ; }	The source of data for rendering the jQuery Datatables.
protected void render empty data tables ( dt criterias ) { preconditions . check not null ( criterias , str ) ; dt response = dt . build ( criterias , collections . empty list , num , num ) ; render json ( response ) ; }	rendering the empty datasource.
public void set items ( list < v > items ) { final list < v > its = items == null ? immutable list . of ( ) : items ; this . items = its ; get combo box cell editor ( ) . set input ( items ) ; }	Sets the input items to the underlying ComboBoxCellEditor.
public void to ( web context context ) { http servlet response response = context . response ( ) ; if ( ! media type . is empty ( ) ) { response . set header ( str , media type ) ; } if ( status > num ) { response . set status ( status ) ; } try { response . send redirect ( response . encode redirect url ( url ) ) ; } catch ( io e ) { throw new unchecked exception ( e ) ; } }	Writes this HTTP response to the specified Web context.
public list < t > list ( injector injector ) { list < t > r = new array list < t > ( ) ; for ( injector i = injector ; i != null ; i = i . get parent ( ) ) { for ( entry < key < ? > , binding < ? > > e : i . get bindings ( ) . entry set ( ) ) { if ( e . get key ( ) . get type literal ( ) . equals ( type ) ) r . add ( ( t ) e . get value ( ) . get provider ( ) . get ( ) ) ; } } return r ; }	Returns all the extension implementations in the specified injector.
public static string current method ( ) { stack trace element [ ] ste = new exception ( ) . get stack trace ( ) ; int ndx = ( ste . length > num ) ? num : num ; return new exception ( ) . get stack trace ( ) [ ndx ] . to string ( ) ; }	Returns current method signature.
public static void compact memory ( ) { try { final byte [ ] [ ] unused = new byte [ num ] [ ] ; for ( int i = unused . length ; i -- != num ; ) { unused [ i ] = new byte [ num ] ; } } catch ( out of memory error ignore ) { } system . gc ( ) ; }	Compacts memory as much as possible by allocating huge memory blockand then forcing garbage collection.
@ nullable public static metrics collection propagate ( metrics metrics ) { final metrics collection metrics collection = get local metrics collection ( ) ; if ( metrics collection != null ) { metrics collection . add ( metrics ) ; } return metrics collection ; }	Propagates metrics entry to the thread local metrics collection, does nothing if local metrics collectionis missing.
public static string encode string ( string value ) { int estimated size = num ; final int len = value . length ( ) ;	Encodes a value, so that it won't contain spaces, commas and equal signs.
public static int copy ( input stream input , output stream output ) throws io { byte [ ] buffer = new byte [ io buffer size ] ; int count = num ; int read ; while ( bool ) { read = input . read ( buffer , num , io buffer size ) ; if ( read == - num ) { break ; } output . write ( buffer , num , read ) ; count += read ; } return count ; }	Copies input stream to output stream using buffer.
public static int copy ( input stream input , output stream output , int byte count ) throws io { byte buffer [ ] = new byte [ io buffer size ] ; int count = num ; int read ; while ( byte count > num ) { if ( byte count < io buffer size ) { read = input . read ( buffer , num , byte count ) ; } else { read = input . read ( buffer , num , io buffer size ) ; } if ( read == - num ) { break ; } byte count -= read ; count += read ; output . write ( buffer , num , read ) ; } return count ; }	Copies specified number of bytes from input stream to output stream using buffer.
public static void copy ( input stream input , writer output ) throws io { copy ( input , output , const . default encoding ) ; }	Copies input stream to writer using buffer.
public static int copy ( reader input , writer output ) throws io { char [ ] buffer = new char [ io buffer size ] ; int count = num ; int read ; while ( ( read = input . read ( buffer , num , io buffer size ) ) >= num ) { output . write ( buffer , num , read ) ; count += read ; } output . flush ( ) ; return count ; }	Copies reader to writer using buffer.Streams don't have to be wrapped to buffered, since copying is already optimized.
public static int copy ( reader input , writer output , int char count ) throws io { char buffer [ ] = new char [ io buffer size ] ; int count = num ; int read ; while ( char count > num ) { if ( char count < io buffer size ) { read = input . read ( buffer , num , char count ) ; } else { read = input . read ( buffer , num , io buffer size ) ; } if ( read == - num ) { break ; } char count -= read ; count += read ; output . write ( buffer , num , read ) ; } return count ; }	Copies specified number of characters from reader to writer using buffer.
public static void copy ( reader input , output stream output ) throws io { copy ( input , output , const . default encoding ) ; }	Copies reader to output stream using buffer.
public static void copy ( reader input , output stream output , string encoding ) throws io { writer out = new output stream writer ( output , encoding ) ; copy ( input , out ) ; out . flush ( ) ; }	Copies reader to output stream using buffer and specified encoding.
public static boolean compare ( input stream input1 , input stream input2 ) throws io { if ( ! ( input1 instanceof buffered input stream ) ) { input1 = new buffered input stream ( input1 ) ; } if ( ! ( input2 instanceof buffered input stream ) ) { input2 = new buffered input stream ( input2 ) ; } int ch = input1 . read ( ) ; while ( ch != - num ) { int ch2 = input2 . read ( ) ; if ( ch != ch2 ) { return bool ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ( ch2 == - num ) ; }	Compares the content of two byte streams.
public static boolean compare ( reader input1 , reader input2 ) throws io { if ( ! ( input1 instanceof buffered reader ) ) { input1 = new buffered reader ( input1 ) ; } if ( ! ( input2 instanceof buffered reader ) ) { input2 = new buffered reader ( input2 ) ; } int ch = input1 . read ( ) ; while ( ch != - num ) { int ch2 = input2 . read ( ) ; if ( ch != ch2 ) { return bool ; } ch = input1 . read ( ) ; } int ch2 = input2 . read ( ) ; return ( ch2 == - num ) ; }	Compares the content of two character streams.
@ suppress warnings ( str ) public t apply ( t io ) { logger . debug ( str ) ; try { for ( int i = num ; i < stages . size ( ) ; i ++ ) { object stage = stages . get ( i ) ; string name = names . get ( stage ) ; logger . debug ( str + i + ( ( name != null && ! name . is empty ( ) ) ? str + name + str : str ) + str ) ; if ( stage instanceof function ) { if ( ( io = ( ( function < t , t > ) stage ) . apply ( io ) ) == null ) { return io ; } } else if ( stage instanceof predicate ) { if ( ! ( ( predicate < t > ) stage ) . apply ( io ) ) { return io ; } } } return io ; } finally { logger . debug ( str ) ; } }	Starts pipeline with the specified stream object that flows through thispipeline.
public static string sql ( string group name andsql id ) { final sql node sql node = sql map . get ( group name andsql id ) ; return sql node == null ? string pool . empty : sql node . sql ; }	To obtain a configuration of SQL.
@ suppress warnings ( str ) public static < t > t unmarshal ( string src , class < t > clazz ) { t result = null ; try { unmarshaller avm = jaxb . new instance ( clazz ) . create unmarshaller ( ) ; result = ( t ) avm . unmarshal ( new string reader ( src ) ) ; } catch ( jaxb e ) { throwables . propagate ( e ) ; } return result ; }	string -> object.
public static void unzip ( file zip file , file dest dir , string ... patterns ) throws io { zip file zip = new zip file ( zip file ) ; enumeration zip entries = zip . entries ( ) ; while ( zip entries . has more elements ( ) ) { zip entry entry = ( zip entry ) zip entries . next element ( ) ; string entry name = entry . get name ( ) ; if ( patterns != null && patterns . length > num ) { if ( wildcard . match path one ( entry name , patterns ) == - num ) { continue ; } } file file = ( dest dir != null ) ? new file ( dest dir , entry name ) : new file ( entry name ) ; if ( entry . is directory ( ) ) { if ( ! file . mkdirs ( ) ) { if ( ! file . is directory ( ) ) { throw new io ( str + file ) ; } } } else { file parent = file . get parent file ( ) ; if ( parent != null && ! parent . exists ( ) ) { if ( ! parent . mkdirs ( ) ) { if ( ! file . is directory ( ) ) { throw new io ( str + parent ) ; } } } input stream in = zip . get input stream ( entry ) ; output stream out = null ; try { out = new file output stream ( file ) ; stream util . copy ( in , out ) ; } finally { stream util . close ( out ) ; stream util . close ( in ) ; } } } close ( zip ) ; }	Extracts zip file to the target directory.
public static permission dialog fragment get instance ( perm bean bean , int request code ) { if ( bean == null ) throw new null pointer exception ( str ) ; bundle extras = new bundle ( num ) ;	A static dialog fragment instance creator method.
@ override public void on resume ( ) { super . on resume ( ) ; get dialog ( ) . set on key listener ( new dialog interface . on key listener ( ) { @ override public boolean on key ( dialog interface dialog , int key code , key event key event ) { return key code != key event . action down ; } } ) ; }	Work around for dialog not to dismiss on back button press.
public static void add core value type ( class < ? > clazz , converter converter ) { convert utils . register ( converter , clazz ) ; values . add ( clazz ) ; }	Adds supported core value type.
public static boolean match ( string regex , string value ) { pattern pattern = pattern . compile ( regex ) ; return pattern . matcher ( value ) . find ( ) ; }	Matches the regular expression.
public static boolean is mobile ( string value ) { string check = str ; return match ( check , pattern . case insensitive , value ) ; }	Phone number verification.
public static boolean is phone ( string value ) { string telcheck = str ; string mobilecheck = str ; return match ( telcheck , pattern . case insensitive , value ) || match ( mobilecheck , pattern . case insensitive , value ) ; }	Telephone number, including mobile phones and landlines.
public static boolean is birth day ( string value ) { string check = str ; if ( match ( check , pattern . case insensitive , value ) ) { int year = integer . parse int ( value . substring ( num , num ) ) ; int month = integer . parse int ( value . substring ( num , num ) ) ; int day = integer . parse int ( value . substring ( num , num ) ) ; if ( month < num || month > num ) { return bool ; } if ( day < num || day > num ) { return bool ; } if ( ( month == num || month == num || month == num || month == num ) && day == num ) { return bool ; } if ( month == num ) { boolean isleap = ( year % num == num && ( year % num != num || year % num == num ) ) ; if ( day > num || ( day == num && ! isleap ) ) { return bool ; } } return bool ; } else { return bool ; } }	Judge whether it is birthday.
public static boolean is url ( string value ) { string check = str ; return match ( check , pattern . case insensitive , value ) ; }	Matches are linked.
public void do filter ( servlet request request , servlet response response , filter chain chain ) throws io , servlet exception { try { pipeline . apply ( new web context ( configuration , ( http servlet request ) request , ( http servlet response ) response , chain ) ) ; } catch ( exception e ) { logger . warn ( str , e ) ; ( ( http servlet response ) response ) . send error ( http servlet response . sc internal server error ) ; } }	Processes the Web request in Bootleg.
public static string encode bas ( string value ) { try { return new string ( base64 . encode base64 ( value . get bytes ( string pool . utf 8 ) ) ) ; } catch ( unsupported encoding exception ex ) { throw new unexpected exception ( ex ) ; } }	Encode a String to base64.
public static byte [ ] decode bas ( string value ) { try { return base64 . decode base64 ( value . get bytes ( string pool . utf 8 ) ) ; } catch ( unsupported encoding exception ex ) { throw new unexpected exception ( ex ) ; } }	Decode a base64 value.
public static byte [ ] hex string to byte ( string hex string ) { try { return hex . decode hex ( hex string . to char array ( ) ) ; } catch ( decoder exception e ) { throw new unexpected exception ( e ) ; } }	Transform an hexadecimal String to a byte array.
public static properties read utf8 properties ( input stream is ) { properties properties = new order safe properties ( ) ; try { properties . load ( is ) ; is . close ( ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } return properties ; }	Read a properties file with the utf-8 encoding.
public static string read content as string ( input stream is , string encoding ) { string res = null ; try { res = io . to string ( is , encoding ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } finally { try { is . close ( ) ; } catch ( exception e ) {	Read the Stream content as a string.
public static string read content as string ( file file , string encoding ) { input stream is = null ; try { is = new file input stream ( file ) ; string writer result = new string writer ( ) ; print writer out = new print writer ( result ) ; buffered reader reader = new buffered reader ( new input stream reader ( is , encoding ) ) ; string line = null ; while ( ( line = reader . read line ( ) ) != null ) { out . println ( line ) ; } return result . to string ( ) ; } catch ( io e ) { throw new unexpected exception ( e ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( exception e ) {	Read file content to a String.
public static void write ( byte [ ] data , file file ) { output stream os = null ; try { os = new file output stream ( file ) ; os . write ( data ) ; os . flush ( ) ; } catch ( io e ) { throw new unexpected exception ( e ) ; } finally { try { if ( os != null ) os . close ( ) ; } catch ( exception e ) {	Write binay data to a file.
public static void copy directory ( file source , file target ) { if ( source . is directory ( ) ) { if ( ! target . exists ( ) ) { target . mkdir ( ) ; } for ( string child : source . list ( ) ) { copy directory ( new file ( source , child ) , new file ( target , child ) ) ; } } else { try { write ( new file input stream ( source ) , new file output stream ( target ) ) ; } catch ( io e ) { throw new unexpected exception ( e ) ; } } }	If targetLocation does not exist, it will be created.
public static string serialize ( document document ) { string writer writer = new string writer ( ) ; try { transformer factory factory = transformer factory . new instance ( ) ; transformer transformer = factory . new transformer ( ) ; dom dom source = new dom ( document ) ; stream result stream result = new stream result ( writer ) ; transformer . transform ( dom source , stream result ) ; } catch ( transformer exception e ) { throw new runtime exception ( str , e ) ; } return writer . to string ( ) ; }	Serialize to XML String.
public static document get document ( file file ) { try { return new document builder ( ) . parse ( file ) ; } catch ( sax e ) { logger . warn ( str + file + str , e ) ; } catch ( io e ) { logger . warn ( str + file + str , e ) ; } return null ; }	Parse an XML file to DOM.
public static document get document ( string xml ) { input source source = new input source ( new string reader ( xml ) ) ; try { return new document builder ( ) . parse ( source ) ; } catch ( sax e ) { logger . warn ( str , e ) ; } catch ( io e ) { logger . warn ( str , e ) ; } return null ; }	Parse an XML string content to DOM.
public static document get document ( input stream stream ) { try { return new document builder ( ) . parse ( stream ) ; } catch ( sax e ) { logger . warn ( str , e ) ; } catch ( io e ) { logger . warn ( str , e ) ; } return null ; }	Parse an XML coming from an input stream to DOM.
public static boolean valid signature ( document document , key public key ) { node signature node = document . get elements by tag name ns ( xml . xmlns , str ) . item ( num ) ; key selector key selector = key selector . singleton key selector ( public key ) ; try { string provider name = system . get property ( str , str ) ; xml fac = xml . get instance ( str , ( provider ) class . for name ( provider name ) . new instance ( ) ) ; dom val context = new dom ( key selector , signature node ) ; xml signature = fac . unmarshal xml ( val context ) ; return signature . validate ( val context ) ; } catch ( exception e ) { logger . warn ( str , e ) ; return bool ; } }	Check the xmldsig signature of the XML document.
public static document sign ( document document , rsa public key , rsa private key ) { xml fac = xml . get instance ( str ) ; key info factory key info factory = fac . get key info factory ( ) ; try { reference ref = fac . new reference ( str , fac . new digest method ( digest method . sh , null ) , collections . singleton list ( fac . new transform ( transform . enveloped , ( transform parameter spec ) null ) ) , null , null ) ; signed info si = fac . new signed info ( fac . new canonicalization method ( canonicalization method . inclusive , ( n ) null ) , fac . new signature method ( signature method . rsa sh , null ) , collections . singleton list ( ref ) ) ; dom dsc = new dom ( private key , document . get document element ( ) ) ; key value key value = key info factory . new key value ( public key ) ; key info ki = key info factory . new key info ( collections . singleton list ( key value ) ) ; xml signature = fac . new xml ( si , ki ) ; signature . sign ( dsc ) ; } catch ( exception e ) { logger . warn ( str , e ) ; } return document ; }	Sign the XML document using xmldsig.
public static boolean is cache safe ( class < ? > clazz , class loader class loader ) { preconditions . check not null ( clazz , str ) ; try { class loader target = clazz . get class loader ( ) ; if ( target == null ) { return bool ; } class loader cur = class loader ; if ( cur == target ) { return bool ; } while ( cur != null ) { cur = cur . get parent ( ) ; if ( cur == target ) { return bool ; } } return bool ; } catch ( security exception ex ) {	Check whether the given class is cache-safe in the given context,i.e.
public static boolean is primitive array ( class < ? > clazz ) { preconditions . check not null ( clazz , str ) ; return ( clazz . is array ( ) && clazz . get component type ( ) . is primitive ( ) ) ; }	Check if the given class represents an array of primitives,i.e.
public static boolean is primitive wrapper array ( class < ? > clazz ) { preconditions . check not null ( clazz , str ) ; return ( clazz . is array ( ) && is primitive wrapper ( clazz . get component type ( ) ) ) ; }	Check if the given class represents an array of primitive wrappers,i.e.
public static class < ? > resolve primitive if necessary ( class < ? > clazz ) { preconditions . check not null ( clazz , str ) ; return ( clazz . is primitive ( ) && clazz != void . class ? primitive type to wrapper map . get ( clazz ) : clazz ) ; }	Resolve the given class if it is a primitive class,returning the corresponding primitive wrapper type instead.
public static boolean is assignable ( class < ? > lhs type , class < ? > rhs type ) { preconditions . check not null ( lhs type , str ) ; preconditions . check not null ( rhs type , str ) ; if ( lhs type . is assignable from ( rhs type ) ) { return bool ; } if ( lhs type . is primitive ( ) ) { class < ? > resolved primitive = primitive wrapper type map . get ( rhs type ) ; if ( resolved primitive != null && lhs type . equals ( resolved primitive ) ) { return bool ; } } else { class < ? > resolved wrapper = primitive type to wrapper map . get ( rhs type ) ; if ( resolved wrapper != null && lhs type . is assignable from ( resolved wrapper ) ) { return bool ; } } return bool ; }	Check if the right-hand side type may be assigned to the left-hand sidetype, assuming setting by reflection.
public static boolean is assignable value ( class < ? > type , object value ) { preconditions . check not null ( type , str ) ; return ( value != null ? is assignable ( type , value . get class ( ) ) : ! type . is primitive ( ) ) ; }	Determine if the given type is assignable from the given value,assuming setting by reflection.
public static class < ? > [ ] get all interfaces ( object instance ) { preconditions . check not null ( instance , str ) ; return get all interfaces for class ( instance . get class ( ) ) ; }	Return all interfaces that the given instance implements as array,including ones implemented by superclasses.
public static set < class < ? > > get all interfaces as set ( object instance ) { preconditions . check not null ( instance , str ) ; return get all interfaces for class as set ( instance . get class ( ) ) ; }	Return all interfaces that the given instance implements as Set,including ones implemented by superclasses.
public url write to temp file ( ) throws io { final file temp config file = file . create temp file ( str , str ) ; temp config file . delete on exit ( ) ;	Writes properties to the temporary file that will be deleted on process exit and returns file URL as a result.
public map < string , string > variables ( string uri ) { map < string , string > variables = new hash map < string , string > ( ) ; matcher matcher = pattern . matcher ( uri ) ; if ( matcher . matches ( ) ) { for ( int i = num ; i < matcher . group count ( ) ; i ++ ) { variables . put ( this . variables . get ( i ) , matcher . group ( i + num ) ) ; } } return variables ; }	Returns template variable name and value pairs extracted from thespecified actual URI.
public perm bean put ( permission permission , string message ) { if ( permission == null ) throw new illegal argument exception ( str ) ; m permissions . put ( permission , message ) ; return this ; }	Add permission and message one by one.
protected < t > void bind ( class < ? extends t > impl , class < t > extension point ) { extension loader module < t > lm = create loader module ( extension point ) ; lm . init ( impl , extension point ) ; install ( lm ) ; }	Allows the subtype to be selective about what to bind.
protected object builtin ( type type ) { class < ? > raw type = types . get raw type ( type ) ; if ( raw type . equals ( web context . class ) ) { return context ; } else if ( raw type . equals ( http servlet request . class ) ) { return context . request ( ) ; } else if ( raw type . equals ( http servlet response . class ) ) { return context . response ( ) ; } else if ( raw type . equals ( http session . class ) ) { return context . session ( ) ; } else if ( raw type . equals ( servlet context . class ) ) { return context . application ( ) ; } else {	Returns the value of built-in type.
protected object primitive ( type type ) { class < ? > raw type = types . get raw type ( type ) ; if ( raw type . equals ( boolean . type ) ) { return ( boolean ) bool ; } else if ( raw type . equals ( character . type ) ) { return ( char ) num ; } else if ( raw type . equals ( byte . type ) ) { return ( byte ) num ; } else if ( raw type . equals ( double . type ) ) { return ( double ) num ; } else if ( raw type . equals ( float . type ) ) { return ( float ) num ; } else if ( raw type . equals ( integer . type ) ) { return ( int ) num ; } else {	Returns the default value of the specified primitive type.
protected object convert ( object object , class < ? > type ) { try { return convert utils . convert ( object , type ) ; } catch ( exception e ) { logger . warn ( str + object + str + type + str , e ) ; return null ; } }	Converts the specified object to the specified type.This method is overridable.
protected object convert user defined value type ( object object , class < ? > type ) { if ( type . is assignable from ( object . get class ( ) ) ) { return object ; } else if ( object instanceof string ) { try { constructor < ? > constructor = type . get constructor ( string . class ) ; return constructor . new instance ( object ) ; } catch ( exception e ) { logger . debug ( str + type . get name ( ) + str + type + str , e ) ; } try { return type . get method ( str , string . class ) . invoke ( null , object ) ; } catch ( exception e1 ) { logger . debug ( str + type . get name ( ) + str + str + type + str , e1 ) ; } } else { logger . warn ( str + object + str + type + str ) ; } return null ; }	Converts the specified object to the specified user-defined value type.This method is overridable.
protected object query ( type type , string name ) { return parameter ( type , name , new function < string , object > ( ) { public object apply ( string name ) { return context . request ( ) . get parameter ( name ) ; } } , new function < string , collection < object > > ( ) { @ suppress warnings ( str ) public collection < object > apply ( string name ) { http servlet request request = context . request ( ) ; map < string , object > map = new tree map < string , object > ( ) ; for ( object object : collections . list ( request . get parameter names ( ) ) ) { string key = ( string ) object ; if ( key . starts with ( name + str ) ) { map . put ( key , request . get parameter ( key ) ) ; } } return ( map . is empty ( ) ) ? null : map . values ( ) ; } } ) ; }	Returns the Web endpoint method parameter from query string.
protected object cookie ( type type , string name ) { return parameter ( type , name , new function < string , object > ( ) { public object apply ( string name ) { cookie [ ] cookies = context . request ( ) . get cookies ( ) ; if ( cookies != null ) { for ( cookie cookie : cookies ) { if ( cookie . get name ( ) . equals ( name ) ) { return cookie . get value ( ) ; } } } return null ; } } , new function < string , collection < object > > ( ) { public collection < object > apply ( string name ) { http servlet request request = context . request ( ) ; map < string , object > map = new tree map < string , object > ( ) ; cookie [ ] cookies = request . get cookies ( ) ; if ( cookies != null ) { for ( cookie cookie : cookies ) { string key = cookie . get name ( ) ; if ( key . starts with ( name + str ) ) { map . put ( key , cookie . get value ( ) ) ; } } } return ( map . is empty ( ) ) ? null : map . values ( ) ; } } ) ; }	Returns the Web endpoint method parameter from cookie in the HTTP request.
protected object session ( type type , string name ) { return parameter ( type , name , new function < string , object > ( ) { public object apply ( string name ) { return context . session ( ) . get attribute ( name ) ; } } , new function < string , collection < object > > ( ) { @ suppress warnings ( str ) public collection < object > apply ( string name ) { http session session = context . session ( ) ; object attribute = session . get attribute ( name ) ; if ( attribute instanceof collection < ? > ) { return ( collection < object > ) attribute ; } map < string , object > map = new tree map < string , object > ( ) ; for ( object object : collections . list ( session . get attribute names ( ) ) ) { string key = ( string ) object ; if ( key . starts with ( name + str ) ) { map . put ( key , session . get attribute ( key ) ) ; } } return ( map . is empty ( ) ) ? null : map . values ( ) ; } } ) ; }	Returns the Web endpoint method parameter from HTTP session.
private void init data source ( final plugins plugins ) { final map < string , properties > db config = goja config . load db ( goja config . get config props ( ) ) ; for ( string db config : db config . key set ( ) ) { final properties db props = db config . get ( db config ) ; if ( db props != null && ! db props . is empty ( ) ) { druid db intializer . init ( db config , plugins , db props ) ; } } if ( goja config . get property to boolean ( goja prop const . db sqlinxml , bool ) ) { plugins . add ( new sql in xml plugin ( ) ) ; } }	init databases.
public void set param ( string field , condition condition , object value ) { this . params . add ( triple . of ( field , condition , value ) ) ; }	Adding custom query condition and value.
public void set param ( string field , object value ) { this . set param ( field , condition . eq , value ) ; }	Adding custom query equal value.
private void show dialog ( perm bean perm bean ) { permission dialog fragment fragment = permission dialog fragment . get instance ( perm bean , request code ) ; fragment . show ( m activity . get support fragment manager ( ) , tag ) ; }	Show dialog fragment to show dialogs before asking permission.Or you can set to show dialogs only when user denied permission earlier.
private static boolean all values granted ( object [ ] values , hash map < permission , result > result map ) { if ( values instanceof permission [ ] ) { set < permission > value set = new hash set < > ( arrays . as list ( ( permission [ ] ) values ) ) ; if ( result map . key set ( ) . contains all ( value set ) ) { for ( object value : values ) { if ( result . granted != result map . get ( ( permission ) value ) ) { m log . i ( tag , str + value . to string ( ) ) ; return bool ; } } return bool ; } } else if ( values instanceof string [ ] ) { set < string > value set = new hash set < > ( arrays . as list ( ( string [ ] ) values ) ) ; set < string > permission = new hash set < > ( ) ; for ( permission perm : result map . key set ( ) ) { permission . add ( perm . to string ( ) ) ; } if ( permission . contains all ( value set ) ) { for ( object value : values ) { if ( result . granted != result map . get ( permission . get ( string . value of ( value ) ) ) ) { m log . i ( tag , str + value ) ; return bool ; } } return bool ; } } return bool ; }	Check if annotated result permissions contains all values from annotated array.Then it also check if all permissions in annotated method value array are granted.
private static boolean any value denied ( object [ ] values , hash map < permission , result > result map ) { if ( values instanceof permission [ ] ) { set < permission > value set = new linked hash set < > ( arrays . as list ( ( permission [ ] ) values ) ) ; if ( result map . key set ( ) . contains all ( value set ) ) { for ( object value : values ) { if ( result . denied == result map . get ( ( permission ) value ) ) { m log . i ( tag , str + value . to string ( ) ) ; return bool ; } } } } else if ( values instanceof string [ ] ) { set < string > value set = new hash set < > ( arrays . as list ( ( string [ ] ) values ) ) ; set < string > permission set = new hash set < > ( ) ; for ( permission perm : result map . key set ( ) ) { permission set . add ( perm . to string ( ) ) ; } if ( permission set . contains all ( value set ) ) { for ( object value : values ) { if ( result . denied == result map . get ( permission . get ( ( string ) value ) ) ) { m log . i ( tag , str + value ) ; return bool ; } } } } return bool ; }	Check if annotated result permissions contains all values from annotated array.Then it also check if any permission in annotated method value array is denied.
public static list < record > find by ( sql select sql select ) { preconditions . check not null ( sql select , str ) ; return db . find ( sql select . to string ( ) , sql select . get params ( ) . to array ( ) ) ; }	Query the database record set.
public static record find one ( sql select sql select ) { preconditions . check not null ( sql select , str ) ; return db . find first ( sql select . to string ( ) , sql select . get params ( ) . to array ( ) ) ; }	Query a data record.
public static < m extends model > boolean is new ( m m , string pk column ) { final object val = m . get ( pk column ) ; return val == null || val instanceof number && ( ( number ) val ) . int value ( ) <= num ; }	According to the primary key and entity determine whether for the new entity.
public static boolean declares exception ( method method , class < ? > exception type ) { preconditions . check not null ( method , str ) ; class < ? > [ ] declared exceptions = method . get exception types ( ) ; for ( class < ? > declared exception : declared exceptions ) { if ( declared exception . is assignable from ( exception type ) ) { return bool ; } } return bool ; }	Determine whether the given method explicitly declares the givenexception or one of its superclasses, which means that an exception ofthat type can be propagated as-is within a reflective invocation.
private void process queue ( ) { soft value < ? , ? > sv ; while ( ( sv = ( soft value < ? , ? > ) queue . poll ( ) ) != null ) {	Traverses the ReferenceQueue and removes garbage-collected SoftValue objects from the backing mapby looking them up using the SoftValue.key data member.
@ override public v put ( k key , v value ) { process queue ( ) ;	Creates a new entry, but wraps the value in a SoftValue instance to enable auto garbage collection.
public static boolean match ( string string , string pattern ) { if ( string . equals ( pattern ) ) {	Checks whether a string matches a given wildcard pattern.
public static < a > a read arguments ( class < a > interface class , string [ ] args ) { a result = null ; try { final argument handler argument handler = new argument handler ( args ) ; result = argument handler . get instance ( interface class ) ; argument handler . process arguments ( new argument processor ( ) { @ override public void process ( list < string > remaining ) throws invalid arguments exception { if ( remaining . size ( ) > num ) { throw new invalid arguments exception ( str + remaining ) ; } } } ) ; } catch ( invalid arguments exception e ) { system . out . println ( e . get message ( ) ) ; show usage ( interface class ) ; result = null ; } if ( result instanceof arguments with help ) { if ( ( ( arguments with help ) result ) . get help ( ) ) { show usage ( interface class ) ; result = null ; } } return result ; }	Returns an instance of A if the arguments could be correctly parsedand A was not a subclass of ArgumentsWithHelp or no help was requested, nullotherwise.
public static final protobuf entity get protobuf entity ( class < ? > clazz ) { final protobuf entity proto buf entity = clazz . get annotation ( protobuf entity . class ) ; if ( proto buf entity != null ) { return proto buf entity ; } return null ; }	Return a ProtobufEntity annotation from any object sent, null if there is none.
public static final boolean is protbuf entity ( class < ? > clazz ) { final protobuf entity proto buf entity = get protobuf entity ( clazz ) ; if ( proto buf entity != null ) { return bool ; } return bool ; }	Returns true if there is a ProtobufEntity annotation on this class.
public static final map < field , protobuf attribute > get all protbuf fields ( class < ? extends object > from clazz ) { map < field , protobuf attribute > proto buf fields = class to field map cache . get ( from clazz . get canonical name ( ) ) ; if ( proto buf fields != null ) { return proto buf fields ; } else { proto buf fields = new hash map < > ( ) ; } final list < field > fields = j . get all fields ( new array list < field > ( ) , from clazz ) ; for ( field field : fields ) { final annotation annotation = field . get annotation ( protobuf attribute . class ) ; if ( annotation == null ) { continue ; } final protobuf attribute gpb annotation = ( protobuf attribute ) annotation ; proto buf fields . put ( field , gpb annotation ) ; }	Returns a full mapping of all Protobuf fields from the POJO class.Essentially, the only fields that will be returned if they havethe ProtobufAttribute annotation.
public static final string get protobuf getter ( protobuf attribute protobuf attribute , field field ) { final string field name = field . get name ( ) ; final string upper class name = field . get declaring class ( ) . get canonical name ( ) ;	Retrieve the getter against the Protobuf class; default is to is "get" plus upper case first character of the field name.
public static final string get pojo setter ( protobuf attribute protobuf attribute , field field ) { final string field name = field . get name ( ) ; final string upper class name = field . get declaring class ( ) . get canonical name ( ) ;	Retrieve the setter on the POJO class; default is to is "set" plus upper case first character of the field name.
public static object mapper get mapper ( ) { object mapper mapper = thread mapper . get ( ) ; if ( mapper == null ) { mapper = init mapper ( ) ; thread mapper . set ( mapper ) ; } return mapper ; }	return a ObjectMapper if exist,else new ObjectMapper.
public static json factory get json factory ( ) { json factory json factory = thread json factory . get ( ) ; if ( json factory == null ) { json factory = new json factory ( ) ;	return a JsonFactory if exist,else new JsonFactory.
public static < t > string to json ( t obj ) { string writer writer = new string writer ( ) ; string json str = str ; json generator gen = null ; try { gen = get json factory ( ) . create generator ( writer ) ; get mapper ( ) . write value ( gen , obj ) ; writer . flush ( ) ; json str = writer . to string ( ) ; } catch ( io e ) { log . error ( str , e . get message ( ) , e ) ; } finally { if ( gen != null ) { try { gen . close ( ) ; } catch ( io e ) { } } } return json str ; }	Bean to json string.
public void set borders ( int top , int right , int bottom , int left ) { set top border ( top ) ; set right border ( right ) ; set bottom border ( bottom ) ; set left border ( left ) ; }	Sets all the border values.
@ edu . umd . cs . findbugs . annotations . suppress warnings ( str ) private user record get user record ( final string domain , final string user name ) throws login exception { string user id ; string credential ; connection connection = null ; prepared statement statement = null ; result set result set = null ; try { connection = get database connection ( ) ; statement = connection . prepare statement ( db props . get ( ) . get sql user query ( ) ) ; statement . set string ( num , domain ) ; statement . set string ( num , user name ) ; result set = statement . execute query ( ) ; if ( result set . next ( ) ) { user id = result set . get string ( num ) ; credential = result set . get string ( num ) ; } else { final string error = str + user name + str ; log . warn ( error ) ; throw new login exception ( error ) ; } result set . close ( ) ; statement . close ( ) ; } catch ( sql e ) { final string error = str ; log . warn ( error , e ) ; throw util . new login exception ( error , e ) ; } finally { db util . close ( result set ) ; db util . close ( statement ) ; db util . close ( connection ) ; } return new user record ( domain , user name , user id , credential ) ; }	The SQL statement is retrieved from the configuration, and the admin is trusted.
public void copy out attributes ( object target , list < attribute > jmx attribute values , map < string , method > attribute setters , object name object name ) { this . copy out attributes ( target , jmx attribute values , attribute setters , str , object name ) ; }	For a JMX MBean idenfitied by an ObjectName, copy the values of the given attributes into the target objectusing the specified setter methods mapped by attribute name.
protected void copy out attributes ( object target , list < attribute > jmx attribute values , map < string , method > attribute setters , string identifier key , object identifier ) { for ( attribute one attribute : jmx attribute values ) { string attribute name = one attribute . get name ( ) ; method setter = attribute setters . get ( attribute name ) ; object value = one attribute . get value ( ) ; try {	Copy the values of the given attributes into the target object using the specified setter methods mapped byattribute name.
public j add app to frame ( ) { j frame = new j ( ) ; frame . set title ( this . get title ( ) ) ; frame . set background ( color . light gray ) ; frame . get content pane ( ) . set layout ( new border layout ( ) ) ; frame . get content pane ( ) . add ( this , border layout . center ) ; frame . add window listener ( new window adapter ( ) { public void window closing ( window event e ) { system . exit ( num ) ; } } ) ; frame . pack ( ) ; frame . set size ( frame . get preferred size ( ) . width , frame . get preferred size ( ) . height ) ; return frame ; }	Add this applet to a frame and initialize.
@ override public void save token ( token token ) { set ( access token token pref , token . get token ( ) ) ; set ( access token secret pref , token . get secret ( ) ) ; }	Save the token using java preferences.
@ override public token get token ( ) { string token = get ( access token token pref ) ; string secret = get ( access token secret pref ) ; return token != null ? new token ( token , secret ) : null ; }	Get the persisted token using java preferences.
public static class loader get default ( ) { class loader loader = null ; try { loader = thread . current thread ( ) . get context class loader ( ) ; } catch ( exception e ) { } if ( loader == null ) { loader = class loader utils . class . get class loader ( ) ; if ( loader == null ) { loader = class loader . get system class loader ( ) ; } } return loader ; }	Returns current thread's context class loader.
public static url get resource ( string name , class loader class loader ) { validate . not null ( name , str ) ; if ( name . starts with ( str ) ) { name = name . substring ( num ) ; } if ( class loader != null ) { url url = class loader . get resource ( name ) ; if ( url != null ) { return url ; } } class loader loader = thread . current thread ( ) . get context class loader ( ) ; if ( loader != null && loader != class loader ) { url url = loader . get resource ( name ) ; if ( url != null ) { return url ; } } return class loader . get system resource ( name ) ; }	Finds the resource with the given name.
public static input stream get resource as stream ( string name , class loader class loader ) throws io { url url = get resource ( name , class loader ) ; if ( url != null ) { return url . open stream ( ) ; } return null ; }	Returns an input stream for reading the specified resource.
public static input stream get class as stream ( class < ? > clazz ) throws io { return get resource as stream ( get class file name ( clazz ) , clazz . get class loader ( ) ) ; }	Returns an input stream for reading the specified class.
private void initialize ( uri p other ) { m scheme = p other . get scheme ( ) ; m userinfo = p other . get userinfo ( ) ; m host = p other . get host ( ) ; m port = p other . m port ; n port = p other . n port ; m path = p other . get path ( ) ; m query string = p other . get query string ( ) ; m fragment = p other . get fragment ( ) ; }	Initialize all fields of this URI from another URI.
private void initialize scheme ( string p uri spec ) throws uri { int uri spec len = p uri spec . length ( ) ; int index = p uri spec . index of ( str ) ; if ( index < num ) throw new uri ( str ) ; if ( index == uri spec len - num ) throw new uri ( str ) ; set scheme ( p uri spec . substring ( num , index ) ) ; }	Initialize the scheme for this URI from a URI string spec.
private void initialize path ( string p uri spec ) throws uri { if ( p uri spec == null ) { throw new uri ( str ) ; } int index = num ; int start = num ; int end = p uri spec . length ( ) ; char test char = str ;	Initialize the path for this URI from a URI string spec.
private void set scheme ( string p scheme ) throws uri { if ( p scheme == null ) { throw new uri ( str ) ; } if ( ! is conformant scheme name ( p scheme ) ) { throw new uri ( str ) ; } m scheme = p scheme ;	Set the scheme for this URI.
private void set userinfo ( string p userinfo ) throws uri { if ( p userinfo == null ) { m userinfo = null ; } else { if ( m host == null ) { throw new uri ( str ) ; }	Set the userinfo for this URI.
private void set host ( string p host ) throws uri { if ( p host == null || p host . length ( ) == num ) { m host = p host ; m userinfo = null ; m port = null ; n port = - num ; } else if ( ! is well formed address ( p host ) ) { throw new uri ( str ) ; } m host = p host ; }	Set the host for this URI.
private void set port ( int p port ) throws uri { if ( p port >= num && p port <= num ) { if ( m host == null ) { throw new uri ( str ) ; } } else if ( p port != - num ) { throw new uri ( str ) ; } n port = p port ; }	Set the port for this URI.
private void append path ( string p add to path ) throws uri { if ( p add to path == null || p add to path . length ( ) == num ) { return ; } if ( ! is uri ( p add to path ) ) { throw new uri ( str ) ; } if ( m path == null || m path . length ( ) == num ) { if ( p add to path . starts with ( str ) ) { m path = p add to path ; } else { m path = str + p add to path ; } } else if ( m path . ends with ( str ) ) { if ( p add to path . starts with ( str ) ) { m path = m path . concat ( p add to path . substring ( num ) ) ; } else { m path = m path . concat ( p add to path ) ; } } else { if ( p add to path . starts with ( str ) ) { m path = m path . concat ( p add to path ) ; } else { m path = m path . concat ( str + p add to path ) ; } } }	Append to the end of the path of this URI.
private void set query string ( string p query string ) throws uri { if ( p query string == null ) { m query string = null ; } else if ( ! is generic uri ( ) ) { throw new uri ( str ) ; } else if ( get path ( ) == null ) { throw new uri ( str ) ; } else if ( ! is uri ( p query string ) ) { throw new uri ( str ) ; } else { m query string = p query string ; } }	Set the query string for this URI.
public void set fragment ( string p fragment ) throws uri { if ( p fragment == null ) { m fragment = null ; } else if ( ! is generic uri ( ) ) { throw new uri ( str ) ; } else if ( get path ( ) == null ) { throw new uri ( str ) ; } else if ( ! is uri ( p fragment ) ) { throw new uri ( str ) ; } else { m fragment = p fragment ; } }	Set the fragment for this URI.
public string get uri ( ) { string buffer uri spec string = new string buffer ( ) ; if ( m scheme != null ) { uri spec string . append ( m scheme ) ; uri spec string . append ( str ) ; } uri spec string . append ( get scheme specific part ( ) ) ; return uri spec string . to string ( ) ; }	Get the URI as a string specification.
protected static prepared statement create by iterator ( connection conn , string sql , iterator < ? > parameters ) throws sql { prepared statement ps = conn . prepare statement ( sql ) ; if ( parameters != null ) { int index = num ; while ( parameters . has next ( ) ) { object parameter = parameters . next ( ) ; if ( parameter == null ) { ps . set object ( index , null ) ; } else { ps . set object ( index , parameter ) ; } index ++ ; } } return ps ; }	Support ? as parameter.
public void init ( object applet ) { try { m ps = ( persistence service ) service manager . lookup ( str ) ; m bs = ( basic service ) service manager . lookup ( str ) ; m str code base = m bs . get code base ( ) . to string ( ) ; } catch ( unavailable service exception e ) { m ps = null ; m bs = null ; } }	Creates new MuffinManager.
public string get muffin ( string str param ) { try { url url = new url ( m str code base + str param ) ; file contents fc = m ps . get ( url ) ; if ( fc == null ) return null ;	Get the current value for this muffin.
public void set muffin ( string str param , string str value ) { file contents fc = null ; url url = null ; try { url = new url ( m str code base + str param ) ; } catch ( exception ex ) { return ; } try { fc = m ps . get ( url ) ; fc . get max length ( ) ;	Set the current value for this muffin.
public transferable get clipboard contents ( ) { if ( ( clipboard read status & clipboard disabled ) == clipboard disabled ) return null ;	Get data from the system clipboard.
public boolean set clipboard contents ( transferable data ) { if ( data == null ) return bool ; if ( ( clipboard write status & clipboard disabled ) == clipboard disabled ) return bool ;	Set the global clipboard contents.
public static < t extends service > map < string , t > load services by type ( class < t > clazz ) { service loader < t > loader = service loader . load ( clazz ) ; iterator < t > it = loader . iterator ( ) ; map < string , t > ret = new hash map < string , t > ( ) ; while ( it . has next ( ) ) { t op = it . next ( ) ; ret . put ( op . get id ( ) , op ) ; if ( op instanceof parametrized operation ) add parametrized service ( op . get id ( ) , ( parametrized operation ) op ) ; if ( op instanceof script object ) add script object ( ( ( script object ) op ) . get var name ( ) , ( script object ) op ) ; } return ret ; }	Discovers the registered services of the given class.
public static void set service params ( parametrized operation op , map < string , object > params ) { if ( params != null ) { for ( map . entry < string , object > entry : params . entry set ( ) ) { op . set param ( entry . get key ( ) , entry . get value ( ) ) ; } } }	Sets the operation parametres based on a map of values.
public static map < string , object > get service params ( parametrized operation op ) { map < string , object > ret = new hash map < string , object > ( ) ; for ( parameter param : op . get params ( ) ) { ret . put ( param . get name ( ) , op . get param ( param . get name ( ) ) ) ; } return ret ; }	Obtains the values of all the parametres of the given operation.
public static parametrized operation find parmetrized service ( string id ) { if ( parametrized services == null ) return null ; else return parametrized services . get ( id ) ; }	Finds a parametrized service based on its ID.
public static < t > t find by class ( collection < ? > services , class < t > clazz ) { for ( object serv : services ) { if ( clazz . is instance ( serv ) ) return clazz . cast ( serv ) ; } return null ; }	Finds a service in a collection of services based on its class.
private < t > t parse query ( final string response , final class < t > response class ) { t query response ; try { query response = mapper . read value ( response , response class ) ; } catch ( json parse exception | json mapping exception e ) { try { final error response error = mapper . read value ( response , error response . class ) ; logger . error ( str , error ) ; return null ; } catch ( final io e1 ) { logger . error ( str , e1 ) ; } logger . error ( str , e ) ; return null ; } catch ( final io e ) { logger . error ( str , e ) ; return null ; } return query response ; }	Parses the results of a query and handles any errors.
@ override public iterator < e > iterator ( ) { return new iterator < e > ( ) { int iterator index ; int iterator buffer index ; int iterator offset ; @ override public boolean has next ( ) { return iterator index < size ; } @ override public e next ( ) { if ( iterator index >= size ) { throw new no such element exception ( ) ; } e [ ] buf = buffers [ iterator buffer index ] ; e result = buf [ iterator offset ] ;	Returns an iterator over buffer elements.
public static string get encoding ( string xml str ) { string result ; string xml = xml str . trim ( ) ; if ( xml . starts with ( str ) ) { int end = xml . index of ( str ) ; int enc index = xml . index of ( str ) ; if ( enc index != - num ) { string sub = xml . substring ( enc index + num , end ) ; result = comm util . substring between ( sub , str , str ) ; return result ; } } return null ; }	Obtain xml file encoding attribute.
public static connection get instance ( connection conn ) { invocation handler handler = new jdbc log connection ( conn ) ; class loader cl = connection . class . get class loader ( ) ; return ( connection ) proxy . new proxy instance ( cl , new class [ ] { connection . class } , handler ) ; }	Creates a logging version of a connection.
@ override public string get authorization ( string authorization url ) throws cube sensors exception { system . out . println ( str + authorization url ) ; system . out . print ( str ) ; try ( scanner in = new scanner ( system . in ) ) { string authorization = in . next line ( ) ; return authorization ; } }	Prints the authorizationUrl, the user will open the url and obtain anauthorization key.
public void visit package declaration ( package declaration d ) { d . accept ( pre ) ; for ( class declaration class decl : d . get classes ( ) ) { class decl . accept ( this ) ; } for ( interface declaration interface decl : d . get interfaces ( ) ) { interface decl . accept ( this ) ; } d . accept ( post ) ; }	Visits a package declaration.
public void visit class declaration ( class declaration d ) { d . accept ( pre ) ; for ( type parameter declaration tp decl : d . get formal type parameters ( ) ) { tp decl . accept ( this ) ; } for ( field declaration field decl : d . get fields ( ) ) { field decl . accept ( this ) ; } for ( method declaration method decl : d . get methods ( ) ) { method decl . accept ( this ) ; } for ( type declaration type decl : d . get nested types ( ) ) { type decl . accept ( this ) ; } for ( constructor declaration ctor decl : d . get constructors ( ) ) { ctor decl . accept ( this ) ; } d . accept ( post ) ; }	Visits a class declaration.
public void visit executable declaration ( executable declaration d ) { d . accept ( pre ) ; for ( type parameter declaration tp decl : d . get formal type parameters ( ) ) { tp decl . accept ( this ) ; } for ( parameter declaration p decl : d . get parameters ( ) ) { p decl . accept ( this ) ; } d . accept ( post ) ; }	Visits a method or constructor declaration.
@ suppress warnings ( str ) private static < t > t get option ( final string key , final map < string , ? > properties ) {	Return the value of a JAAS configuration parameter.
public static declaration filter get filter ( final collection < modifier > mods ) { return new declaration filter ( ) { public boolean matches ( declaration d ) { return d . get modifiers ( ) . contains all ( mods ) ; } } ; }	Returns a filter that selects declarations containing all of acollection of modifiers.
public static declaration filter get filter ( final class < ? extends declaration > kind ) { return new declaration filter ( ) { public boolean matches ( declaration d ) { return kind . is instance ( d ) ; } } ; }	Returns a filter that selects declarations of a particular kind.For example, there may be a filter that selects only classdeclarations, or only fields.The filter will select declarations of the specified kind,and also any subtypes of that kind; for example, a field filterwill also select enum constants.
public declaration filter and ( declaration filter f ) { final declaration filter f1 = this ; final declaration filter f2 = f ; return new declaration filter ( ) { public boolean matches ( declaration d ) { return f1 . matches ( d ) && f2 . matches ( d ) ; } } ; }	Returns a filter that selects those declarations selectedby both this filter and another.
public declaration filter or ( declaration filter f ) { final declaration filter f1 = this ; final declaration filter f2 = f ; return new declaration filter ( ) { public boolean matches ( declaration d ) { return f1 . matches ( d ) || f2 . matches ( d ) ; } } ; }	Returns a filter that selects those declarations selectedby either this filter or another.
protected map < string , v > get as map ( ) { map < string , v > result = map ; if ( result == null ) { synchronized ( this ) { result = map ; if ( result == null ) { map = ( result = initialize ( ) ) ; } } } return result ; }	double check for map.
public static < t > void make accessible ( final constructor < t > constructor ) { if ( ! modifier . is public ( constructor . get modifiers ( ) ) || ! modifier . is public ( constructor . get declaring class ( ) . get modifiers ( ) ) ) { constructor . set accessible ( bool ) ; } }	set constructor is accessible.
public object query info prepare object query ( object obj ) throws malformed object name exception { object query info result ;	Prepare to query the given object.
public static string replace slash with hyphen ( string origin ) { char [ ] resullt chars = origin . to char array ( ) ; for ( int i = num ; i < resullt chars . length - num ; i ++ ) { if ( resullt chars [ i ] == str ) { resullt chars [ i ] = str ; } } return new string ( resullt chars , num , resullt chars . length - num ) ; }	replaces slashes with hyphens and removes padding=.
public static string bytes2 hex string ( byte [ ] bytes ) { string buffer result buffer = new string buffer ( ) ; for ( int i = num ; i < bytes . length ; i ++ ) { result buffer . append ( byte2 hex ( bytes [ i ] ) ) ; } return result buffer . to string ( ) ; }	Converts an array of bytes to a string of two digits hex-representations.
private list < integer > get indexes ( string name ) { list < integer > indexes = name index map . get ( name ) ; if ( indexes == null ) { throw new illegal argument exception ( str + name ) ; } return indexes ; }	Returns the indexes for a parameter.
private static string parse named sql ( string sql , map < string , list < integer > > name index map ) {	Parses a sql with named parameters.
private static final object convert collection to protobufs ( collection < object > collection of non protobufs ) throws j { if ( collection of non protobufs . is empty ( ) ) { return collection of non protobufs ; } final object first = collection of non protobufs . to array ( ) [ num ] ; if ( ! protobuf serializer utils . is protbuf entity ( first ) ) { return collection of non protobufs ; } final collection < object > new collection values ; if ( collection of non protobufs instanceof set ) { new collection values = new hash set < > ( ) ; } else { new collection values = new array list < > ( ) ; } for ( object i protobuf gen obj : collection of non protobufs ) { new collection values . add ( serialize to protobuf entity ( i protobuf gen obj ) ) ; } return new collection values ; }	Loops through the collection of objects and serializes them, iff they have ProtobufEntity annotations.
private static final void set protobuf field value ( protobuf attribute protobuf attribute , builder proto obj builder , string setter , object field value ) throws no such method exception , security exception , protobuf annotation exception , instantiation exception , illegal access exception , illegal argument exception , invocation target exception { class < ? extends object > field value class = field value . get class ( ) ; class < ? extends object > gpb class = field value class ; final class < ? extends i > converter clazz = protobuf attribute . converter ( ) ; if ( converter clazz != null converter . class ) { final i proto buf converter = ( i ) converter clazz . new instance ( ) ; field value = proto buf converter . convert to protobuf ( field value ) ; gpb class = field value . get class ( ) ; field value class = gpb class ; }	This method does the actual "set" on the Protobuf builder.
private static final void set pojo field value ( object pojo , string setter , object protobuf value , protobuf attribute protobuf attribute ) throws instantiation exception , illegal access exception , j { final class < ? extends i > from proto buf converter = protobuf attribute . converter ( ) ; if ( from proto buf converter != null converter . class ) { final i converter = from proto buf converter . new instance ( ) ; protobuf value = converter . convert from protobuf ( protobuf value ) ; } class < ? extends object > arg clazz = protobuf value . get class ( ) ; j . run setter ( pojo , setter , protobuf value , arg clazz ) ; }	This method does the actual "set" on the POJO instance.
public boolean accept ( file pathname ) { string name = pathname . get name ( ) ; int i last dot = name . last index of ( str ) ; string str extension = str ; if ( ( i last dot != - num ) && ( i last dot != name . length ( ) - num ) ) str extension = name . substring ( i last dot + num ) ; if ( m rgstr include extensions != null ) { for ( int i = num ; i < m rgstr include extensions . length ; i ++ ) { if ( m rgstr include extensions [ i ] . equals ignore case ( str extension ) ) return bool ;	Tests whether or not the specified abstract pathname should beincluded in a pathname list.
public static result set get instance ( result set rs ) { invocation handler handler = new jdbc log result set ( rs ) ; class loader cl = result set . class . get class loader ( ) ; return ( result set ) proxy . new proxy instance ( cl , new class [ ] { result set . class } , handler ) ; }	Creates a logging version of a ResultSet.
private static map < expected labels , integer > map labels ( final list < string > labels ) { final map < expected labels , integer > map = new enum map < > ( expected labels . class ) ; final list < expected labels > unused labels = new array list < > ( arrays . as list ( expected labels . values ( ) ) ) ; for ( int index = num ; index < labels . size ( ) ; index ++ ) { final string next = labels . get ( index ) ; expected labels label value ; try { label value = expected labels . value of ( next ) ; unused labels . remove ( label value ) ; if ( map . contains key ( label value ) ) { logger . warn ( str , next , labels ) ; } map . put ( label value , index ) ; } catch ( final illegal argument exception e ) { logger . warn ( str , next ) ; } } for ( final expected labels label : unused labels ) { logger . warn ( str , label ) ; } return map ; }	Produces a mapping of label to index for use in parsing state values to the appropriate slot in the state object.
public static class < ? > get generic supertype ( class < ? > type , int index ) { return get component type ( type . get generic superclass ( ) , null , index ) ; }	Returns generic supertype for given class and 0-based index.
public void poll ( ) throws io { synchronized ( this ) {	Poll the configured objects now and store the results in the objects themselves.
protected boolean poll individually ( ) throws io { this . concurrency test hooks . on start poll individually ( ) ; list < scheduler process execution slip > process execution slip list = new linked list < > ( ) ; for ( final object one polled object : this . polled objects ) {	Poll all of the objects, one at a time.
public static field get declared field ( class < ? > clazz , string field name , boolean recursively ) { try { return clazz . get declared field ( field name ) ; } catch ( no such field exception e ) { class < ? > super class = clazz . get superclass ( ) ; if ( super class != null && recursively ) { return get declared field ( super class , field name , bool ) ; } } catch ( security exception e ) { log . error ( str , e . get message ( ) , e ) ; } return null ; }	obtain field If recursively is true, obtain fields from all classhierarchy.
public static method [ ] get declared methods ( class < ? > clazz , boolean recursively ) { list < method > methods = new linked list < method > ( ) ; method [ ] declared methods = clazz . get declared methods ( ) ; collections . add all ( methods , declared methods ) ; class < ? > super class = clazz . get superclass ( ) ; if ( super class != null && recursively ) { method [ ] declared methods of super = get declared methods ( super class , bool ) ; if ( declared methods of super . length > num ) collections . add all ( methods , declared methods of super ) ; } return methods . to array ( new method [ methods . size ( ) ] ) ; }	obtain methods list of specified class If recursively is true, obtainmethods from all class hierarchy.
public static method get declared method ( class < ? > clazz , boolean recursively , string method name , class < ? > ... parameter types ) { try { return clazz . get declared method ( method name , parameter types ) ; } catch ( no such method exception e ) { class < ? > super class = clazz . get superclass ( ) ; if ( super class != null && recursively ) { return get declared method ( super class , bool , method name , parameter types ) ; } } catch ( security exception e ) { log . error ( str , e . get message ( ) , e ) ; } return null ; }	obtain method list of specified class If recursively is true, obtainmethod from all class hierarchy.
public static method [ ] get annotated declared methods ( class < ? > clazz , class < ? extends annotation > annotation class , boolean recursively ) { method [ ] all methods = get declared methods ( clazz , recursively ) ; list < method > annotated methods = new linked list < method > ( ) ; for ( method method : all methods ) { if ( method . is annotation present ( annotation class ) ) annotated methods . add ( method ) ; } return annotated methods . to array ( new method [ annotated methods . size ( ) ] ) ; }	obtain methods list of specified class and which are annotated byincoming annotation class If recursively is true, obtain methods from allclass hierarchy.
public static constructor < ? > [ ] get annotated declared constructors ( class < ? > clazz , class < ? extends annotation > annotation class , boolean recursively ) { constructor < ? > [ ] all constructors = get declared constructors ( clazz , recursively ) ; list < constructor < ? > > annotated constructors = new linked list < constructor < ? > > ( ) ; for ( constructor < ? > field : all constructors ) { if ( field . is annotation present ( annotation class ) ) annotated constructors . add ( field ) ; } return annotated constructors . to array ( new constructor < ? > [ annotated constructors . size ( ) ] ) ; }	obtain constructors list of specified class and which are annotated byincoming annotation class If recursively is true, obtain constructorsfrom all class hierarchy.
protected void dump byte ( int b ) { if ( pass through == bool ) { system . out . print ( str ) ; } if ( b < num ) { b += num ; } if ( b < num ) { system . out . print ( str ) ; } system . out . print ( str ) ; system . out . print ( integer . to hex string ( b ) . to upper case ( ) ) ; }	Dumps single byte to output stream.
public static int index of ignore case ( string s , string substr , int start index , int end index ) { if ( start index < num ) { start index = num ; } int srclen = s . length ( ) ; if ( end index > srclen ) { end index = srclen ; } int sublen = substr . length ( ) ; if ( sublen == num ) { return start index > srclen ? srclen : start index ; } substr = substr . to lower case ( ) ; int total = end index - sublen + num ; char c = substr . char at ( num ) ; mainloop : for ( int i = start index ; i < total ; i ++ ) { if ( character . to lower case ( s . char at ( i ) ) != c ) { continue ; } int j = num ; int k = i + num ; while ( j < sublen ) { char source = character . to lower case ( s . char at ( k ) ) ; if ( substr . char at ( j ) != source ) { continue mainloop ; } j ++ ; k ++ ; } return i ; } return - num ; }	Finds first index of a substring in the given source string and range withignored case.
public static string remove chars ( string s , string chars ) { int i = s . length ( ) ; string builder sb = new string builder ( i ) ; for ( int j = num ; j < i ; j ++ ) { char c = s . char at ( j ) ; if ( chars . index of ( c ) == - num ) { sb . append ( c ) ; } } return sb . to string ( ) ; }	Removes all characters contained in provided string.
@ suppress warnings ( str ) private void clean state ( ) {	Clean up any state associated with the current login attempt.
@ suppress warnings ( str ) private void init audit ( final common properties common props ) { try { final string audit class name = common props . get audit class name ( ) ;	Initialize the instance-global audit object.
@ suppress warnings ( str ) private void init message queue ( final common properties common props ) { try { final string message class name = common props . get message queue class name ( ) ;	Initialize the instance-global message queue object.
private void init pw validator ( final common properties common props ) { try { final string validator class = common props . get password validator class name ( ) ; if ( validator class == null ) { final string error = str ; log . error ( error ) ; throw new illegal state exception ( error ) ; } else { if ( common props . is password validator singleton ( ) ) {	Initialize the instance-global password validator object.
private void init pw authenticator ( final common properties common props ) { try { final string auth nticator class = common props . get password authenticator class name ( ) ; if ( auth nticator class == null ) { final string error = str ; log . error ( error ) ; throw new illegal state exception ( error ) ; } else { if ( common props . is password authenticator singleton ( ) ) {	Initialize the instance-global password authenticator object.
public static string resolve locale code ( final locale locale ) { return resolve locale code ( locale . get language ( ) , locale . get country ( ) , locale . get variant ( ) ) ; }	Resolves locale code from locale.
protected static locale info lookup locale info ( final string code ) { locale info info = locales . get ( code ) ; if ( info == null ) { string [ ] data = decode locale code ( code ) ; info = new locale info ( new locale ( data [ num ] , data [ num ] , data [ num ] ) ) ; locales . put ( code , info ) ; } return info ; }	Lookups for locale info and creates new if it doesn't exist.
public static statement get instance ( statement stmt ) { invocation handler handler = new jdbc log statement ( stmt ) ; class loader cl = statement . class . get class loader ( ) ; return ( statement ) proxy . new proxy instance ( cl , new class [ ] { statement . class } , handler ) ; }	Creates a logging version of a Statement.
public void clear ( ) { int i = size ; object [ ] els = elements ; while ( i -- > num ) { els [ i ] = null ; } this . size = num ; }	Removes all of the elements from this stack.
@ suppress warnings ( str ) public t pop ( ) throws empty stack exception { int i ; if ( ( i = -- size ) >= num ) { t element = ( t ) elements [ i ] ; elements [ i ] = null ; return element ; } else { size = num ; throw new empty stack exception ( ) ; } }	Removes the object at the top of this stack and returns that object as the value of this function.
public input stream make in stream ( ) { if ( m != null ) return m ; try { return new file input stream ( m input file ) ; } catch ( file not found exception ex ) { system . out . println ( str + m input file . get path ( ) ) ;	If there is no input stream, use the file to create one.
public static properties parse args ( properties properties , string [ ] args ) { if ( properties == null ) properties = new properties ( ) ; if ( args == null ) return properties ; for ( int i = num ; i < args . length ; i ++ ) app utilities . add param ( properties , args [ i ] , bool ) ; return properties ; }	Parse this URL formatted string into properties.
protected static boolean match tokens ( string [ ] tokens , string [ ] patterns ) { int pat ndx start = num ; int pat ndx end = patterns . length - num ; int tok ndx start = num ; int tok ndx end = tokens . length - num ; while ( pat ndx start <= pat ndx end && tok ndx start <= tok ndx end ) {	Match tokenized string and pattern.
public void move ( int xofs , int yofs ) { x1 += xofs ; y1 += yofs ; x2 += xofs ; y2 += yofs ; }	Changes the rectangle coordinates by adding the specified X and Y offsets.
public boolean encloses ( rectangular other ) { return x1 <= other . x1 && y1 <= other . y1 && x2 >= other . x2 && y2 >= other . y2 ; }	Checks if this rectangle entirely contains another rectangle.
public boolean contains ( int x , int y ) { return x1 <= x && y1 <= y && x2 >= x && y2 >= y ; }	Checks if this rectangle contains a point.
public rectangular intersection ( rectangular other ) { if ( this . intersects ( other ) ) { return new rectangular ( math . max ( x1 , other . x1 ) , math . max ( y1 , other . y1 ) , math . min ( x2 , other . x2 ) , math . min ( y2 , other . y2 ) ) ; } else { return new rectangular ( ) ;	Computes the intersection of this rectangle with another one.
public rectangular union ( rectangular other ) { return new rectangular ( math . min ( x1 , other . x1 ) , math . min ( y1 , other . y1 ) , math . max ( x2 , other . x2 ) , math . max ( y2 , other . y2 ) ) ; }	Computes the union of this rectangle with another one.
public rectangular replace x ( rectangular other ) { rectangular ret = new rectangular ( this ) ; ret . x1 = other . x1 ; ret . x2 = other . x2 ; return ret ; }	Replaces the X coordinates of the rectangle with the X coordinates of another one.
public rectangular replace y ( rectangular other ) { rectangular ret = new rectangular ( this ) ; ret . y1 = other . y1 ; ret . y2 = other . y2 ; return ret ; }	Replaces the Y coordinates of the rectangle with the Y coordinates of another one.
public int get col ofs ( int col ) throws array index out of bounds exception { if ( col < width ) { int ofs = num ; for ( int i = num ; i < col ; i ++ ) ofs += cols [ i ] ; return ofs ; } else if ( col == width ) return abspos . get width ( ) ; else throw new array index out of bounds exception ( col + str + width ) ; }	Finds the offset of the specified column from the grid origin.
public int get row ofs ( int row ) throws array index out of bounds exception { if ( row < height ) { int ofs = num ; for ( int i = num ; i < row ; i ++ ) ofs += rows [ i ] ; return ofs ; } else if ( row == height ) return abspos . get height ( ) ; else throw new array index out of bounds exception ( row + str + height ) ; }	Finds the offset of the specified row from the grid origin.
public rectangular get cell bounds relative ( int x , int y ) { int x1 = get col ofs ( x ) ; int y1 = get row ofs ( y ) ; int x2 = ( x == width - num ) ? abspos . get width ( ) - num : x1 + cols [ x ] - num ; int y2 = ( y == height - num ) ? abspos . get height ( ) - num : y1 + rows [ y ] - num ; return new rectangular ( x1 , y1 , x2 , y2 ) ; }	Computes the coordinates of the specified grid cell relatively to the area top left corner.
private void calculate columns ( ) {	Goes through the child areas and creates a list of collumns.
private void calculate rows ( ) {	Goes through the child areas and creates a list of rows.
protected throwable unwrap throwable ( throwable t ) { throwable e = t ; while ( bool ) { if ( e instanceof invocation target exception ) { e = ( ( invocation target exception ) t ) . get target exception ( ) ; } else if ( t instanceof undeclared throwable exception ) { e = ( ( undeclared throwable exception ) t ) . get undeclared throwable ( ) ; } else { return e ; } } }	Examines a Throwable object and gets it's root cause.
public static void main ( string [ ] args ) { try { main main = new main ( ) ; main . start ( ) ; runtime . get runtime ( ) . add shutdown hook ( main . get shutdown hook ( ) ) ; main . await termination ( num , time unit . days ) ; } catch ( interrupted exception e ) { e = null ; thread . current thread ( ) . interrupt ( ) ; } }	Launches the debugger as a stand-alone Swing application.
public void on code update ( byte buffer code buffer , int start , int length , variable and functor interner interner , wam code view ) { log . fine ( str + start + str + length + str ) ;	Should be notified every time byte-code is added to the machine.
private void copy and resize code buffer ( byte buffer code buffer , int start , int length ) {	Copies code from the specified code buffer, into the internal one, resizing the internal code buffer if necessaryto make enough room.
public void init ( ) { log . fine ( str ) ;	Loads a properties file and stores it in the application context.
public query parameter partial copy ( final query parameter kind ... excluded elements ) { list < query parameter kind > excluded list = arrays . as list ( excluded elements ) ; query parameter return value = new query parameter ( ) ; if ( ! excluded list . contains ( query parameter kind . constraints ) ) { return value . raw constraints = this . raw constraints ; } if ( ! excluded list . contains ( query parameter kind . groups ) ) { return value . groups = this . groups ; } if ( ! excluded list . contains ( query parameter kind . orders ) ) { return value . orders = this . orders ; } if ( ! excluded list . contains ( query parameter kind . page ) ) { return value . page size = this . page size ; return value . page = this . page ; } if ( ! excluded list . contains ( query parameter kind . timezone ) ) { return value . timezone name = this . timezone name ; } return return value ; }	Return a QueryParameter which contains reference to the original elements except for those from the exception list.
public void add child ( tree < e > child ) { init children ( ) ;	Adds a child tree to the children of this point in the tree.
public void clear children ( ) {	Clears all the children of this point in the tree.
private e next internal ( ) {	Gets the next element from the sequence, the cached one if one has already been generated, or creating andcaching a new one if not.
public void add instructions ( functor body , sizeable list < wam > instructions ) { int old length ; if ( this . body == null ) { old length = num ; this . body = new functor [ num ] ; } else { old length = this . body . length ; this . body = arrays . copy of ( this . body , old length + num ) ; } this . body [ old length ] = body ; add instructions and this to parent ( instructions ) ; }	Adds a conjunctive body functor, or head functor, to this clause, along with the instructions that implement it.
private void add instructions and this to parent ( sizeable list < wam > instructions ) { if ( ! added to parent ) { parent . add instructions ( this , instructions ) ; added to parent = bool ; } else { parent . add instructions ( instructions ) ; } }	Adds some instructions to the parent predicate, and also adds this as a clause on the parent, if it has notalready been added.
public void property change ( property change event event ) {	Called when a property in the WorkPanelState is changed.
public void register work panel ( work panel panel ) {	Sets the specified work panel to listen to the button press events for all of the OK, Cancel and Apply buttons.Regisers this object to listen for changes to the work panels state.
private void update present component flags ( ) { has console = component map . contains key ( console ) ; has status bar = component map . contains key ( status bar ) ; has left bar = component map . contains key ( left vertical bar ) ; has left pane = component map . contains key ( left pane ) ; has right bar = component map . contains key ( right vertical bar ) ; has right pane = component map . contains key ( right pane ) ; }	Keeps the set of flags indicating which window components are present, up-to-date.
public static type create instance ( string name , int precision , int scale , string min , string max ) { synchronized ( decimal types ) {	Creates a new decimal type with the specified name, if it does not already exist.
public boolean evaluate ( term term ) { if ( term . is var ( ) && ( term instanceof variable ) ) { variable var = ( variable ) term ; return ! var . is bound ( ) && ! var . is anonymous ( ) ; } return bool ; }	Determine whether a term is a free variable.
private sizeable list < wam > optimize ( list < wam > instructions ) { state machine optimize constants = new optimize instructions ( symbol table , interner ) ; iterable < wam > matcher = new matcher < wam , wam > ( instructions . iterator ( ) , optimize constants ) ; sizeable list < wam > result = new sizeable linked list < wam > ( ) ; for ( wam instruction : matcher ) { result . add ( instruction ) ; } return result ; }	Performs an optimization pass for specialized instructions. The following instruction sequences can be optimized: unify_var Xi, get_struc a/0, Xi -> unify_const a/0get_struc a/0, Xi -> get_const a/0put_struc a/0, Xi, set_var Xi -> set_const a/0put_struc a/0, Xi -> put_const a/0 .
public int compare ( collection < t > c1 , collection < t > c2 ) {	Compares two collections using lexicographic ordering based on a comparator of their elements.
public void service ( http servlet request request , http servlet response response ) throws io { log . fine ( str ) ;	Processes the http request that is directed to this servlet.
public int do start tag ( ) throws jsp exception { log . fine ( str ) ; tag utils tag utils = tag utils . get instance ( ) ;	Renders the paging control.
private void render button ( boolean render , int page , int index , string open delim , string url , string text , boolean active ) throws jsp exception { log . fine ( str ) ; log . fine ( str + render ) ; log . fine ( str + page ) ; log . fine ( str + index ) ; log . fine ( str + open delim ) ; log . fine ( str + url ) ; log . fine ( str + text ) ; log . fine ( str + active ) ; tag utils tag utils = tag utils . get instance ( ) ; if ( render ) { tag utils . write ( page context , open delim ) ;	Renders a button control as a hyperlink for the page control.
public void reset ( ) { max steps = num ; machine to train = null ; input examples = new array list < state > ( ) ; input properties = new hash set < string > ( ) ; output properties = new hash set < string > ( ) ; input properties set = bool ; output properties set = bool ; }	Resets the learning method.
protected void initialize ( ) throws learning failure exception {	This should be called at the start of the learn method to initialize the input and output property sets.
public v get ( object key ) {	Returns the value to which this map maps the specified key.
public int get index of ( object key ) {	Returns the index to which this map maps the specified key.
public v set ( int index , v value ) throws index out of bounds exception {	Inserts the element at the specified index.
public v remove ( object key ) {	Removes the mapping for the specified key from this map if present.
public v remove ( int index ) throws index out of bounds exception {	Removes the specified index from the data structure.
public boolean has property ( string property ) {	Checks if the bean has a named property.
protected void set property ( object callee , string property , object value ) {	Sets the value of a property of the bean by name.
protected object get property ( object callee , string property ) {	Returns a single named property of the bean.
private boolean is assignable from primitive ( class wrapper type , class primitive type ) { boolean result = bool ; if ( primitive type . equals ( boolean . class ) && wrapper type . equals ( boolean . class ) ) { result = bool ; } else if ( primitive type . equals ( byte . class ) && wrapper type . equals ( byte . class ) ) { result = bool ; } else if ( primitive type . equals ( char . class ) && wrapper type . equals ( character . class ) ) { result = bool ; } else if ( primitive type . equals ( short . class ) && wrapper type . equals ( short . class ) ) { result = bool ; } else if ( primitive type . equals ( int . class ) && wrapper type . equals ( integer . class ) ) { result = bool ; } else if ( primitive type . equals ( long . class ) && wrapper type . equals ( long . class ) ) { result = bool ; } else if ( primitive type . equals ( float . class ) && wrapper type . equals ( float . class ) ) { result = bool ; } else if ( primitive type . equals ( double . class ) && wrapper type . equals ( double . class ) ) { result = bool ; } else { result = bool ; } return result ; }	Checks if a wrapper type is assignable from a primtive type.
private void initialize ( object callee ) {	Initialized this property introspector on a specified object, building the caches of getter and setter methods.
public decision tree decide ( state state ) {	Performs the actual decision based on a property of the state.
public void initialize lookups ( decision tree this node ) {	Initializes the lookup table for this decision node.
public list < variable > unify ( term query , term statement ) {	Unifies two terms and produces a list of bound variables that form the unification, when it it possible.
public boolean unify internal ( term left , term right , list < variable > left trail , list < variable > right trail ) { if ( left == right ) { return bool ; } if ( ! left . is var ( ) && ! right . is var ( ) && left . is constant ( ) && right . is constant ( ) && left . equals ( right ) ) { return bool ; } else if ( left . is var ( ) ) { return unify var ( ( variable ) left , right , left trail , right trail ) ; } else if ( right . is var ( ) ) { return unify var ( ( variable ) right , left , right trail , left trail ) ; } else if ( left . is functor ( ) && right . is functor ( ) ) { functor left functor = ( functor ) left ; functor right functor = ( functor ) right ;	Attempts to unify one term with another, against a background of already unified variables in both terms.
private void compile query ( clause clause ) throws source code exception {	Compiles a clause as a query.
private int find max arguments in clause ( clause clause ) { int result = num ; functor head = clause . get head ( ) ; if ( head != null ) { result = head . get arity ( ) ; } functor [ ] body = clause . get body ( ) ; if ( body != null ) { for ( int i = num ; i < body . length ; i ++ ) { int arity = body [ i ] . get arity ( ) ; result = ( arity > result ) ? arity : result ; } } return result ; }	Examines all top-level functors within a clause, including any head and body, and determines which functor hasthe highest number of arguments.
private void allocate permanent query registers ( term clause , map < byte , integer > var names ) {	Allocates stack slots to all free variables in a query clause.
private void gather position and occurrence info ( term clause ) { positional term traverser positional traverser = new positional term traverser impl ( ) ; position and occurrence visitor position and occurrence visitor = new position and occurrence visitor ( interner , symbol table , positional traverser ) ; positional traverser . set context change visitor ( position and occurrence visitor ) ; term walker walker = new term walker ( new depth first backtracking search < term , term > ( ) , positional traverser , position and occurrence visitor ) ; walker . walk ( clause ) ; }	Gather information about variable counts and positions of occurrence of constants and variable within a clause.
private void display compiled predicate ( term predicate ) {	Pretty prints a compiled predicate.
private void display compiled query ( term query ) {	Pretty prints a compiled query.
public static string as string ( byte buffer buffer , int length ) { char [ ] chars = new char [ length ] ; for ( int i = num ; i < length ; i ++ ) { chars [ i ] = ( char ) buffer . get ( i ) ; } return string . value of ( chars ) ; }	Returns the contents of a buffer as a string, converting ASCII characters in the buffer, into unicode stringcharacters.
public string get string value ( ) {	Gets the string value of a string attribute.
public void set string value ( string value ) throws illegal argument exception { byte b = attribute class . lookup byte . get ( value ) ;	Sets the specified string as the value of this attribute.
private void read ( term term ) { if ( term . is number ( ) ) { numeric type numeric type = ( numeric type ) term ; if ( numeric type . is integer ( ) ) { int literal jpl integer = ( int literal ) term ; get content handler ( ) . start integer term ( jpl integer . long value ( ) ) ; } else if ( numeric type . is float ( ) ) { float literal jpl float = ( float literal ) term ; get content handler ( ) . start float term ( jpl float . double value ( ) ) ; } } else if ( term . is var ( ) ) { variable var = ( variable ) term ; get content handler ( ) . start variable ( interner . get variable name ( var . get name ( ) ) ) ; } else if ( term . is atom ( ) ) { functor atom = ( functor ) term ; get content handler ( ) . start atom ( interner . get functor name ( atom . get name ( ) ) ) ; } else if ( term . is compound ( ) ) { functor functor = ( functor ) term ; get content handler ( ) . start compound ( ) ; get content handler ( ) . start atom ( interner . get functor name ( functor . get name ( ) ) ) ; for ( com . thesett . aima . logic . fol . term child : functor . get arguments ( ) ) { read ( child ) ; } get content handler ( ) . end compound ( ) ; } else { throw new illegal state exception ( str + term ) ; } }	Reads a Lojix term and invoked appropriate methods on the content handler to describe its structure and contentsto it.
public static boolean class exists and is loadable ( string class name ) { try { class . for name ( class name ) ; return bool ; } catch ( class not found exception e ) {	Checks if the named class exists and is loadable.
public static boolean is sub type of ( class parent , string class name ) { try { class cls = class . for name ( class name ) ; return parent . is assignable from ( cls ) ; } catch ( class not found exception e ) {	Checks if the named class exists and is loadable and is a sub-type of the specified class.
public static boolean is sub type of ( string parent , string child ) { try { return is sub type of ( class . for name ( parent ) , class . for name ( child ) ) ; } catch ( class not found exception e ) {	Checks that the named child class is the same type or a sub-type of the named parent class.
public static boolean is sub type of ( class parent class , class child class ) { try {	Checks that the child class is the same type or a sub-type of the parent class.
public static class < ? > for name ( string class name ) { try { return class . for name ( class name ) ; } catch ( class not found exception e ) { throw new reflection utils exception ( str + class name + str , e ) ; } }	Gets the Class object for a named class.
public static < t > t new instance ( class < t > cls ) { try { return cls . new instance ( ) ; } catch ( instantiation exception e ) { throw new reflection utils exception ( str , e ) ; } catch ( illegal access exception e ) { throw new reflection utils exception ( str , e ) ; } }	Creates an instance of a Class, instantiated through its no-args constructor.
public static < t > t new instance ( constructor < t > constructor , object [ ] args ) { try { return constructor . new instance ( args ) ; } catch ( instantiation exception e ) { throw new illegal state exception ( e ) ; } catch ( illegal access exception e ) { throw new illegal state exception ( e ) ; } catch ( invocation target exception e ) { throw new illegal state exception ( e ) ; } }	Calls a constuctor with the specified arguments.
public static object call method overriding illegal access ( object o , string method , object [ ] params , class [ ] param classes ) {	Calls a named method on an object with a specified set of parameters, any Java access modifier are overridden.
public static object call method ( object o , string method , object [ ] params ) {	Calls a named method on an object with a specified set of parameters.
public static object call static method ( method method , object [ ] params ) { try { return method . invoke ( null , params ) ; } catch ( illegal access exception e ) { throw new illegal state exception ( e ) ; } catch ( invocation target exception e ) { throw new illegal state exception ( e ) ; } }	Calls a named static method on a class with a specified set of parameters.
public static < t > constructor < t > get constructor ( class < t > cls , class [ ] args ) { try { return cls . get constructor ( args ) ; } catch ( no such method exception e ) { throw new illegal state exception ( e ) ; } }	Gets the constructor of a class that takes the specified set of arguments if any matches.
public static set < class > find matching setters ( class ob class , string property name ) { set < class > types = new hash set < class > ( ) ;	Finds the argument types of all setter methods on a bean for a given property name.
public static < e > queue < e > get transactional queue ( java . util . queue < e > queue ) { return new wrapper queue < e > ( queue , new linked list < e > ( ) , bool , bool , bool ) ; }	Provides a transactional queue, that delays all queue manipulation operations until the transaction is committed,or erases them if it is rolled back.
public static < e > queue < e > get transactional re queue ( java . util . queue < e > queue , collection < e > requeue ) { return new wrapper queue < e > ( queue , requeue , bool , bool , bool ) ; }	Provides a transactional requeue, that delays all queue manipulation operations until the transaction iscommitted, or erases them if it is rolled back.
public static type get type from object ( object o ) {	Gets the type of a specified object.
public void reset ( ) {	Resets the search, clearing out the queue and setting it to contain just the start state node.
public static type create instance ( string name , int min , int max ) {	Creates a new int range type with the specified name, if it does not already exist.
public void add supported tz ( string tz name ) { if ( ! string utils . is blank ( tz name ) && ! tz names aliases . contains key ( tz name . trim ( ) ) ) { tz names aliases . put ( tz name . trim ( ) , tz name . trim ( ) ) ; if ( log . is info enabled ( ) ) { log . info ( str + this . get end point name ( ) + str + tz name ) ; } } }	Add a new supported tz. Add one aliase with the same name.
public void add tz ( string orignal dimension name , dimension table alternate dimension , string tz name ) { add supported tz ( tz name ) ; if ( tz names aliases . contains value ( tz name ) ) { sql tables . put ( alternate dimension . get table name ( ) , alternate dimension ) ; alternate dimensions . put ( pair . of ( orignal dimension name . to upper case ( ) , tz name ) , alternate dimension ) ; } else { log . error ( str + tz name ) ; } }	Timezone is case sensitive.
public void add dimension ( dimension table table , boolean mandatory ) { sql tables . put ( table . get table name ( ) , table ) ; dimensions . put ( table . get dimension name ( ) . to upper case ( ) , table ) ; if ( mandatory ) { mandatory dimension names . add ( table . get dimension name ( ) . to upper case ( locale . english ) ) ; } }	Add a dimension as mandatory.Mandatory dimension names are stored in upper case.
public static set < variable > find free variables ( term query ) { queue based search method < term , term > free var search = new depth first search < term , term > ( ) ; free var search . reset ( ) ; free var search . add start state ( query ) ; free var search . set goal predicate ( new free variable predicate ( ) ) ; return ( set < variable > ) ( set ) searches . set of ( free var search ) ; }	Calculates the set of free variables in a term.
public static set < variable > find free non anonymous variables ( term query ) { queue based search method < term , term > free var search = new depth first search < term , term > ( ) ; free var search . reset ( ) ; free var search . add start state ( query ) ; free var search . set goal predicate ( new free non anonymous variable predicate ( ) ) ; return ( set < variable > ) ( set ) searches . set of ( free var search ) ; }	Calculates the set of free and non-anonymous variables in a term.
public int compare ( search node object1 , search node object2 ) { float h1 = ( ( heuristic search node ) object1 ) . get h ( ) ; float h2 = ( ( heuristic search node ) object2 ) . get h ( ) ; return ( h1 > h2 ) ? num : ( ( h1 < h2 ) ? - num : num ) ; }	Compares two heuristic search nodes by their heuristic values.
public static void write object to file ( string output file name , object to write , boolean append ) {	Writes an object, using its 'toString' method, to the named file.
private static string read stream as string ( buffered input stream is ) { try { byte [ ] data = new byte [ num ] ; string buffer in buffer = new string buffer ( ) ; int read ; while ( ( read = is . read ( data ) ) != - num ) { string s = new string ( data , num , read ) ; in buffer . append ( s ) ; } return in buffer . to string ( ) ; } catch ( io e ) { throw new illegal state exception ( e ) ; } }	Reads the contents of a reader, one line at a time until the end of stream is encountered, and returns alltogether as a string.
public search node < o , t > create search node ( t state ) { return new heuristic search node < o , t > ( state , heuristic ) ; }	Creates the correct type of search nodes for this search.
public string generate trace indent ( int delta ) { if ( ! use indent ) { return str ; } else { if ( delta >= num ) { indent stack . push ( delta ) ; } else if ( delta < num ) { indent stack . pop ( ) ; } string buffer result = new string buffer ( ) ; trace indent += ( delta < num ) ? delta : num ; for ( int i = num ; i < trace indent ; i ++ ) { result . append ( str ) ; } trace indent += ( delta > num ) ? delta : num ; return result . to string ( ) ; } }	Generates a sequence of spaces to indent debugging output with.
private boolean is last body term in arg position only ( term var , functor body ) { return body == symbol table . get ( var . get symbol key ( ) , symbol table keys . symkey var last arg functor ) ; }	Checks if a variable is appearing within the last body functor in which it occurs, and only does so withinargument position.
private string choose best property to decide on ( string output property , iterable < state > examples , iterable < string > input properties ) {	For a given set of examples, input properties and an output property this method chooses the input property thatprovides the largest information gain on the value of the output property.
public functor functor ( string name , term ... args ) { int interned name = interner . intern functor name ( name , args . length ) ; return new functor ( interned name , args ) ; }	Creates a functor.
public variable var ( string name ) { boolean is anonymous = name . starts with ( str ) ; int interned name = interner . intern variable name ( name ) ; return new variable ( interned name , null , is anonymous ) ; }	Creates a variable. If the variable name begins with an underscore "_", it will be anonymous, otherwise it willbe named.
public action forward execute with error handling ( action mapping mapping , action form form , http servlet request request , http servlet response response , action errors errors ) { log . fine ( str + str + str ) ; http session session = request . get session ( ) ; dyna bean dyna form = ( dyna action form ) form ;	Handles an HTTP request sent to this action by struts.
public list < e > get ( int index ) {	Extracts the sub-list at the specified page index.
public void set texture ( paint obj ) { if ( obj instanceof gradient paint ) { texture = new gradient paint ( num , num , color . white , get size ( ) . width * num , num , color . green ) ; } else { texture = obj ; } }	Sets the kind of paint to use. For the image background?.
public void paint immediately ( int x , int y , int w , int h ) { repaint manager repaint manager = null ; boolean save = bool ; if ( ! is double buffered ( ) ) { repaint manager = repaint manager . current manager ( this ) ; save = repaint manager . is double buffering enabled ( ) ; repaint manager . set double buffering enabled ( bool ) ; } super . paint immediately ( x , y , w , h ) ; if ( repaint manager != null ) { repaint manager . set double buffering enabled ( save ) ; } }	Immediately repaints the surface.
protected buffered image create buffered image ( int w , int h , int img type ) { buffered image bi = null ; if ( img type == num ) { bi = ( buffered image ) create image ( w , h ) ; } else if ( ( img type > num ) && ( img type < num ) ) { bi = new buffered image ( w , h , img type ) ; } else if ( img type == num ) { bi = create binary image ( w , h , num ) ; } else if ( img type == num ) { bi = create binary image ( w , h , num ) ; } else if ( img type == num ) { bi = create sgi ( w , h , num ) ; } else if ( img type == num ) { bi = create sgi ( w , h , num ) ; }	Generates a fresh buffered image of the appropriate type.
private buffered image create binary image ( int w , int h , int pixel bits ) { int bytes per row = w * pixel bits / num ; if ( ( w * pixel bits % num ) != num ) { bytes per row ++ ; } byte [ ] image data = new byte [ h * bytes per row ] ; index color model cm = null ; switch ( pixel bits ) { case num : { cm = new index color model ( pixel bits , lut1 arr . length , lut1 arr , lut1 arr , lut1 arr ) ; break ; } case num : { cm = new index color model ( pixel bits , lut2 arr . length , lut2 arr , lut2 arr , lut2 arr ) ; break ; } case num : { cm = new index color model ( pixel bits , lut4 arr . length , lut4 arr , lut4 arr , lut4 arr ) ; break ; } default : { new exception ( str ) . print stack trace ( ) ; } } data buffer db = new data buffer byte ( image data , image data . length ) ; writable raster r = raster . create packed raster ( db , w , h , pixel bits , null ) ; return new buffered image ( cm , r , bool , null ) ; }	Creates a custom grey-scale binary image format.
private buffered image create sgi ( int w , int h , int pixel bits ) { int r mask32 = num ; int r mask16 = num ; int g mask32 = num ; int g mask16 = num ; int b mask32 = num ; int b mask16 = num ; direct color model dcm = null ; data buffer db = null ; writable raster wr = null ; switch ( pixel bits ) { case num : { short [ ] image data u = new short [ w * h ] ; dcm = new direct color model ( num , r mask16 , g mask16 , b mask16 ) ; db = new u ( image data u , image data u . length ) ; wr = raster . create packed raster ( db , w , h , w , new int [ ] { r mask16 , g mask16 , b mask16 } , null ) ; break ; } case num : { int [ ] image data int = new int [ w * h ] ; dcm = new direct color model ( num , r mask32 , g mask32 , b mask32 ) ; db = new data buffer int ( image data int , image data int . length ) ; wr = raster . create packed raster ( db , w , h , w , new int [ ] { r mask32 , g mask32 , b mask32 } , null ) ; break ; } default : { new exception ( str ) . print stack trace ( ) ; } } return new buffered image ( dcm , wr , bool , null ) ; }	Creates a custom colour image format.
protected void set queue search algorithm ( queue search algorithm < o , t > algorithm ) { algorithm . set peek at head ( bool ) ; algorithm . set reverse enqueue order ( bool ) ; super . set queue search algorithm ( algorithm ) ; }	Allows different queue search algorithms to replace the default one.
public static void main ( string [ ] args ) { try { simple char stream input stream = new simple char stream ( system . in , null , num , num ) ; prolog parser token manager token manager = new prolog parser token manager ( input stream ) ; source < token > token source = new token source ( token manager ) ; prolog parser parser = new prolog parser ( token source , new variable and functor interner impl ( str , str ) ) ; while ( bool ) {	Parses statements and print the parse tree to the console for quick interactive testing of the parser.
public clause clause ( ) throws source code exception {	Parses a single sentence in first order logic.
public list < term > terms ( list < term > terms ) throws source code exception { term term ; token next token = token source . peek ( ) ; switch ( next token . kind ) { case functor : term = functor ( ) ; break ; case lsqparen : term = list functor ( ) ; break ; case var : term = variable ( ) ; break ; case integer literal : term = int literal ( ) ; break ; case floating point literal : term = double literal ( ) ; break ; case string literal : term = string literal ( ) ; break ; case atom : term = atom ( ) ; break ; case lparen : consume token ( lparen ) ; term = term ( ) ;	Recursively parses terms, which may be functors, atoms, variables, literals or operators, into a flat list in theorder in which they are encountered.
public term functor ( ) throws source code exception { token name = consume token ( functor ) ; term [ ] args = arglist ( ) ; consume token ( rparen ) ; int name id = interner . intern functor name ( ( args == null ) ? name . image : name . image . substring ( num , name . image . length ( ) - num ) , ( args == null ) ? num : args . length ) ; functor result = new functor ( name id , args ) ; source code position position = new source code position impl ( name . begin line , name . begin column , name . end line , name . end column ) ; result . set source code position ( position ) ; return result ; }	Parses a single functor in first order logic with its arguments.
public term variable ( ) throws source code exception { token name = consume token ( var ) ;	Parses a variable in first order logic.
public term int literal ( ) throws source code exception { token val token = consume token ( integer literal ) ; numeric type result = new int literal ( integer . parse int ( val token . image ) ) ;	Parses an integer literal.
public term double literal ( ) throws source code exception { token val token = consume token ( floating point literal ) ; numeric type result = new double literal ( double . parse double ( val token . image ) ) ;	Parses a real number literal.
public term string literal ( ) throws source code exception { token val token = consume token ( string literal ) ; string val with quotes = val token . image ; string literal result = new string literal ( val with quotes . substring ( num , val with quotes . length ( ) - num ) ) ;	Parses a string literal.
public directive peek and consume directive ( ) throws source code exception { if ( peek and consume trace ( ) ) { return directive . trace ; } if ( peek and consume info ( ) ) { return directive . info ; } if ( peek and consume user ( ) ) { return directive . user ; } return null ; }	Peeks and consumes the next interactive system directive.
public void intern operator ( string operator name , int priority , op symbol . associativity associativity ) { int arity ; if ( ( associativity == xfy ) | ( associativity == yfx ) | ( associativity == xfx ) ) { arity = num ; } else { arity = num ; } int name = interner . intern functor name ( operator name , arity ) ; operator table . set operator ( name , operator name , priority , associativity ) ; }	Interns an operators name as a functor of appropriate arity for the operators fixity, and sets the operator inthe operator table.
protected void initialize built ins ( ) {	Interns and inserts into the operator table all of the built in operators and functors in Prolog.
protected token consume token ( int kind ) throws source code exception { token next token = token source . peek ( ) ; if ( next token . kind != kind ) { throw new source code exception ( str + token image [ kind ] + str + token image [ next token . kind ] + str , null , null , null , new source code position impl ( next token . begin line , next token . begin column , next token . end line , next token . end column ) ) ; } else { next token = token source . poll ( ) ; return next token ; } }	Consumes a token of the expected kind from the token sequence.
private boolean peek and consume ( int kind ) { token next token = token source . peek ( ) ; if ( next token . kind == kind ) { try { consume token ( kind ) ; } catch ( source code exception e ) {	Peeks ahead for the given token type, and if one is foudn with that type, it is consumed.
public void bind ( ) {	Binds the session as a transactional context to the current thread, if it is not already bound.
public void rollback ( ) {	Forgets pending operations.
public static < t > collection < t > collect iterator ( iterator < t > iterator , collection < t > target collection ) { while ( iterator . has next ( ) ) { target collection . add ( iterator . next ( ) ) ; } return target collection ; }	Extracts all elements from an iterator, usually created from a filterator, and adds them into the targetcollection, returning that collection as the result.
public static long time of day to ticks ( int hour , int minute , int second , int millisecond ) { return millisecond + ( millis per second * second ) + ( millis per minute * minute ) + ( millis per hour * hour ) ; }	Converts a field by field time of day into millisecond ticks.
public static int ticks to years ( long ticks ) {	Extracts the years component of a time in millisecond ticks.
public static long ticks with hours set to ( long ticks , int hours ) { long old hours = ticks to hours ( ticks ) ; return ticks - ( old hours * millis per hour ) + ( hours * millis per hour ) ; }	Sets the component of the timestamp, returning the new timestamp with updated component.
public static long ticks with minutes set to ( long ticks , int minutes ) { long old minutes = ticks to minutes ( ticks ) ; return ticks - ( old minutes * millis per minute ) + ( minutes * millis per minute ) ; }	Sets the minutes component of the timestamp, returning the new timestamp with updated component.
public static long ticks with seconds set to ( long ticks , int seconds ) { long old seconds = ticks to seconds ( ticks ) ; return ticks - ( old seconds * millis per second ) + ( seconds * millis per second ) ; }	Sets the seconds component of the timestamp, returning the new timestamp with updated component.
public static long ticks with year set to ( long ticks , int year ) { int old year = ticks to years ( ticks ) ; return ticks - millis to year start ( old year ) + millis to year start ( year ) ; }	Sets the year component of the timestamp, returning the new timestamp with updated component.
public static long ticks with month set to ( long ticks , int month ) { int year = ticks to years ( ticks ) ; boolean is leap year = is leap year ( year ) ; int old month = ticks to months ( ticks ) ; return ticks - millis to start of month ( old month , is leap year ) + millis to start of month ( month , is leap year ) ; }	Sets the month component of the timestamp, returning the new timestamp with updated component.
public static long ticks with date set to ( long ticks , int date ) { int old days = ticks to date ( ticks ) ; return ticks - ( old days * millis per day ) + ( date * millis per day ) ; }	Sets the date component of the timestamp, returning the new timestamp with updated component.
public static long millis to year start ( int year ) {	Calculates the number of milliseconds to the start of the specified year, taking 1970 as zero.
public byte block read ( byte [ ] b ) throws io { int count = source . read ( b ) ; return new byte block ( b , count ) ; }	Reads some number of bytes from the input stream and stores them into the buffer array b.
private entry < k > entry for key ( k key ) { int key hash code = key . hash code ( ) ; int hash1 = hash1 ( key hash code ) ; entry < k > entry = hash table [ index for ( hash1 ) ] ; if ( ( entry != null ) && key . equals ( entry . key ) ) { return entry ; } int hash2 = hash2 ( hash1 , key hash code ) ; entry = hash table [ index for ( hash2 ) ] ; if ( ( entry != null ) && key . equals ( entry . key ) ) { return entry ; } return null ; }	Checks if the specified key can be found in the set, and returns its entry if so.
private entry < k > cuckoo ( entry < k > entry ) {	Adds a new entry to a hash table, using the cuckoo algorithm.
private void rehash ( ) {	Creates a new hashtable that is twice the size of the old one, then re-hashes everything from the old table intothe new table.
public void action performed ( action event event ) {	Listens for the button events Ok, Cancel and Apply.
public void set next available ( boolean avail ) {	Sets the state of the next available flag and notifies any listeners of this change.
public void set prev available ( boolean avail ) {	Sets the state of the previous available flag and notifies any listeners of this change.
public void set finished ( boolean avail ) {	Sets the state of the finished and notifies any listeners of this change.
public static wam get instance ( symbol table impl < integer , string , object > symbol table ) throws implementation unavailable exception { try { if ( ! library load attempted ) { library load attempted = bool ; system . load library ( str ) ; library found = bool ; } if ( library found ) { return new wam ( symbol table ) ; } else { throw new implementation unavailable exception ( str , null , null , null ) ; } } catch ( unsatisfied link error e ) { library found = bool ; throw new implementation unavailable exception ( str , e , null , null ) ; } }	Creates an instance of this machine, loading and checking for availability of the native implementation libraryas required.
public iterator < set < variable > > iterator ( ) { return new sequence iterator < set < variable > > ( ) { public set < variable > next in sequence ( ) { return resolve ( ) ; } } ; }	Provides an iterator that generates all solutions on demand as a sequence of variable bindings.
public static double expected i ( double [ ] probabilities ) { double result = num ;	For a given set of probabilities of the occurences of symbols this function calculates the expected informationcontent of a set of symbols given its probability distribution.
public static double [ ] p for distribution ( int [ ] counts ) { double [ ] probabilities = new double [ counts . length ] ; int total = num ;	Estimates probabilities given a set of counts of occurrences of symbols.
void set ticks ( long ticks ) { year = time utils . ticks to years ( ticks ) ; month = time utils . ticks to months ( ticks ) ; day = time utils . ticks to date ( ticks ) ; }	Sets this date from a milliseconds timestamp.
public action forward perform ( action mapping mapping , action form form , http servlet request request , http servlet response response ) throws io , servlet exception { log . fine ( str ) ;	Processes the action.
public static url new url ( string spec ) { try { return new url ( spec ) ; } catch ( url exception ) { throw new illegal argument exception ( str + spec ) ; } }	Creates a URL for the specified string representation.
public string get request info ( ) { map info = new tree map ( ) ; http servlet request req = ( http servlet request ) page context . get request ( ) ; info . put ( str , null to string ( req . get auth type ( ) ) ) ; info . put ( str , null to string ( req . get character encoding ( ) ) ) ; info . put ( str , integer . to string ( req . get content length ( ) ) ) ; info . put ( str , null to string ( req . get content type ( ) ) ) ; info . put ( str , null to string ( req . get context path ( ) ) ) ; info . put ( str , null to string ( req . get path info ( ) ) ) ; info . put ( str , null to string ( req . get protocol ( ) ) ) ; info . put ( str , null to string ( req . get query string ( ) ) ) ; info . put ( str , null to string ( req . get remote addr ( ) ) ) ; info . put ( str , null to string ( req . get remote host ( ) ) ) ; info . put ( str , null to string ( req . get remote user ( ) ) ) ; info . put ( str , null to string ( req . get request uri ( ) ) ) ; info . put ( str , null to string ( req . get scheme ( ) ) ) ; info . put ( str , null to string ( req . get server name ( ) ) ) ; info . put ( str , integer . to string ( req . get server port ( ) ) ) ; info . put ( str , null to string ( req . get servlet path ( ) ) ) ; return to html ( str , info ) ; }	Returns a String with all basic request information in an HTML table.
public string get headers ( ) { map info = new tree map ( ) ; http servlet request req = ( http servlet request ) page context . get request ( ) ; enumeration names = req . get header names ( ) ; while ( names . has more elements ( ) ) { string name = ( string ) names . next element ( ) ; enumeration values = req . get headers ( name ) ; string buffer sb = new string buffer ( ) ; boolean first = bool ; while ( values . has more elements ( ) ) { if ( ! first ) { sb . append ( str ) ; } first = bool ; sb . append ( values . next element ( ) ) ; } info . put ( name , sb . to string ( ) ) ; } return to html ( str , info ) ; }	Returns a String with all header information as an HTML table.
public string get cookies ( ) { map info = new tree map ( ) ; http servlet request req = ( http servlet request ) page context . get request ( ) ; cookie [ ] cookies = req . get cookies ( ) ;	Returns a String with all cookie information as an HTML table.
public string get parameters ( ) { map info = new tree map ( ) ; servlet request req = ( http servlet request ) page context . get request ( ) ; enumeration names = req . get parameter names ( ) ; while ( names . has more elements ( ) ) { string name = ( string ) names . next element ( ) ; string [ ] values = req . get parameter values ( name ) ; string buffer sb = new string buffer ( ) ; for ( int i = num ; i < values . length ; i ++ ) { if ( i != num ) { sb . append ( str ) ; } sb . append ( values [ i ] ) ; } info . put ( name , sb . to string ( ) ) ; } return to html ( str , info ) ; }	Returns a String with all request parameter information.
public string get request scope ( ) { map info = new tree map ( ) ; servlet request req = ( http servlet request ) page context . get request ( ) ; enumeration names = req . get attribute names ( ) ; while ( names . has more elements ( ) ) { string name = ( string ) names . next element ( ) ; object value = req . get attribute ( name ) ; info . put ( name , to string value ( value ) ) ; } return to html ( str , info ) ; }	Returns a String with all request scope variables.
public string get page scope ( ) { map info = new tree map ( ) ; enumeration names = page context . get attribute names in scope ( page context . page scope ) ; while ( names . has more elements ( ) ) { string name = ( string ) names . next element ( ) ; object value = page context . get attribute ( name ) ; info . put ( name , to string value ( value ) ) ; } return to html ( str , info ) ; }	Returns a String with all page scope variables.
public string get session scope ( ) { map info = new tree map ( ) ; http servlet request req = ( http servlet request ) page context . get request ( ) ; http session session = req . get session ( ) ; enumeration names = session . get attribute names ( ) ; while ( names . has more elements ( ) ) { string name = ( string ) names . next element ( ) ; object value = session . get attribute ( name ) ; info . put ( name , to string value ( value ) ) ; } return to html ( str , info ) ; }	Returns a String with all session scope variables.
public string get application scope ( ) { map info = new tree map ( ) ; servlet context context = page context . get servlet context ( ) ; enumeration names = context . get attribute names ( ) ; while ( names . has more elements ( ) ) { string name = ( string ) names . next element ( ) ; object value = context . get attribute ( name ) ; info . put ( name , to string value ( value ) ) ; } return to html ( str , info ) ; }	Returns a String with all application scope variables.
public string get user principal ( ) {	Returns the user principal name.
public int do start tag ( ) throws jsp exception { log . fine ( str ) ; try {	Renders the debugging message.
private string to html ( string prop name , map values ) { string buffer table sb = new string buffer ( ) ; table sb . append ( str ) . append ( prop name ) . append ( str ) ; for ( iterator it = values . key set ( ) . iterator ( ) ; it . has next ( ) ; ) { object o = it . next ( ) ; string key = ( string ) o ; table sb . append ( str ) . append ( key ) . append ( str ) . append ( values . get ( key ) ) . append ( str ) ; } return table sb . to string ( ) ; }	Returns an HTML table with all the values of the specified property.
public void set current screen state ( work flow screen state state ) { work flow screen state old state = current screen state ;	Sets the new current screen state and notifies all listeners of the change in screen state.
public void walk ( term term ) {	Walks over the supplied term.
public int compare ( search node object1 , search node object2 ) { float f1 = ( ( heuristic search node ) object1 ) . get f ( ) ; float f2 = ( ( heuristic search node ) object2 ) . get f ( ) ; return ( f1 > f2 ) ? num : ( ( f1 < f2 ) ? - num : num ) ; }	Compares two heuristic search nodes by their f values.
public void update registers ( wam registers ) { list < property change event > changes = delta ( this , registers ) ; ip = registers . ip ; hp = registers . hp ; hbp = registers . hbp ; sp = registers . sp ; up = registers . up ; ep = registers . ep ; bp = registers . bp ; b0 = registers . b0 ; trp = registers . trp ; write mode = registers . write mode ; notify changes ( changes ) ; }	Updates the register file, with a new set of registers.
private void notify changes ( iterable < property change event > changes ) { list < property change listener > active listeners = listeners . get active listeners ( ) ; if ( active listeners != null ) { for ( property change listener listener : active listeners ) { for ( property change event event : changes ) { listener . property change ( event ) ; } } } }	Fires off a list of property change events to any interested listeners.
protected void leave clause ( clause clause ) {	Upon leaving the clause, sets the nonArgPosition flag on any constants that need it.
private boolean in top level functor ( positional context context ) { positional context parent context = context . get parent context ( ) ; return parent context . is top level ( ) || is top level ( parent context ) ; }	Checks if the current position is immediately within a top-level functor.
public void set arguments ( term [ ] arguments ) {	Sets the arguments of this operator.
public fixity get fixity ( ) { switch ( associativity ) { case fx : case fy : return fixity . pre ; case xf : case yf : return fixity . post ; case xfx : case xfy : case yfx : return fixity . in ; default : throw new illegal state exception ( str ) ; } }	Provides the symbols fixity, derived from its associativity.
public boolean is infix ( ) { return ( ( associativity == associativity . xfy ) || ( associativity == associativity . yfx ) || ( associativity == associativity . xfx ) ) ; }	Reports whether this operator is an infix operator.
public int compare to ( object o ) { op symbol op symbol = ( op symbol ) o ; return ( priority < op symbol . priority ) ? - num : ( ( priority > op symbol . priority ) ? num : num ) ; }	Compares this object with the specified object for order, providing a negative integer, zero, or a positiveinteger as this symbols priority is less than, equal to, or greater than the comparator.
public void property change ( property change event event ) { object source = event . get source ( ) ; object old value = event . get old value ( ) ; string property name = event . get property name ( ) ;	Called when a property in the work flow state is changed.
public void register work flow controller ( work flow controller controller ) {	Registers the work flow button panel with the specified work flow controller.
public static enum attribute factory get factory for class ( class cls ) {	Generates a factory for building enum attributes of the specified enum class.
public static component factory create component factory ( string class name ) { return ( component factory ) reflection utils . new instance ( reflection utils . for name ( class name ) ) ; }	Creates an instance of the named component factory.
public variable get storage cell ( variable variable ) { variable binding context < variable > context = get binding context ( ) ; if ( context == null ) { return null ; } else { return context . get storage cell ( this ) ; } }	Provides the storage cell for the specified variable.
public boolean is bound ( ) { variable binding context < variable > context = get binding context ( ) ;	Reports whether or not this variable is bound to a value.
private void set column attribute ( attribute set attributes , int c ) { if ( c >= column attributes . size ( ) ) { for ( int i = column attributes . size ( ) ; i <= c ; i ++ ) { column attributes . add ( null ) ; } } column attributes . set ( c , attributes ) ; }	Sets a column attribute, adding padding to the underlying array as necessary to ensure it is large enough to holdthe attribute at the requested position.
private void set row attribute ( attribute set attributes , int r ) { if ( r >= row attributes . size ( ) ) { for ( int i = row attributes . size ( ) ; i <= r ; i ++ ) { row attributes . add ( null ) ; } } row attributes . set ( r , attributes ) ; }	Sets a row attribute, adding padding to the underlying array as necessary to ensure it is large enough to holdthe attribute at the requested position.
private attribute set get column attribute or null ( int c ) { if ( ( c >= num ) && ( c < column attributes . size ( ) ) ) { return column attributes . get ( c ) ; } else { return null ; } }	Gets a columns attribute if possible, without overflowing the underlying array.
private attribute set get row attribute or null ( int r ) { if ( ( r >= num ) && ( r < row attributes . size ( ) ) ) { return row attributes . get ( r ) ; } else { return null ; } }	Gets a rows attribute if possible, without overflowing the underlying array.
private void internal insert ( attribute set attributes , int c , int r ) { cell attributes . put ( ( long ) c , ( long ) r , attributes ) ; }	Inserts a set of attributes into the grid at the specified location.
public static type create instance ( string name , time only min , time only max ) {	Creates a new time range type with the specified name, if it does not already exist.
public static type create instance ( string name , int max length , string pattern ) { synchronized ( string pattern types ) { string pattern type new type = new string pattern type ( name , max length , pattern ) ;	Creates a new string pattern type with the specified name, if it does not already exist.
public boolean is instance ( char sequence value ) {	Checks a string value against this type to see if it is a valid instance of the type.
private void create initial context ( term term ) { if ( ! initial context created ) { positional context operator initial context = new positional context operator ( term , - num , bool , bool , bool , null , context stack . peek ( ) ) ; context stack . offer ( initial context ) ; term . set reversable ( initial context ) ; initial context created = bool ; } }	Sets up the initial context once, at the start of a traversal.
public void update registers ( wam layout ) { list < property change event > changes = delta ( this , layout ) ; reg base = layout . reg base ; reg size = layout . reg size ; heap base = layout . heap base ; heap size = layout . heap size ; stack base = layout . stack base ; stack size = layout . stack size ; trail base = layout . trail base ; trail size = layout . trail size ; pdl base = layout . pdl base ; pdl size = layout . pdl size ; notify changes ( changes ) ; }	Updates the layout register file, with a new set of layout registers.
public string get value ( ) { for ( scope node scope = node tree utils . get parent scope ( this ) ; scope != null ; scope = node tree utils . get parent scope ( scope ) ) { expression group node value = scope . get variable ( name ) ; if ( value == null ) { continue ; } return value . to string ( ) ; } return name ;	Search up the scope tree to locate the variable's value.
public search node < o , t > find goal path ( ) throws search not exhaustive exception {	Implementation of the general bi-dircetional search.
public list < t > cache block ( int block ) {	Fetches and caches the specified block.
public static synchronized properties get properties ( string resource name ) {	Static factory method that locates an existing instance or creates a new property reader for a named resource.
public void set rate ( float hertz ) {	Specifies the throttling rate in operations per second.
public int read ( byte [ ] b ) throws io { try { byte block block = source . read ( b ) ; system . arraycopy ( block . data , num , b , num , block . count ) ; return block . count ; } catch ( remote exception e ) { throw new io ( str , e ) ; } }	Reads some number of bytes from the input stream and stores them into the buffer array b.
public long skip ( long n ) throws io { try { return source . skip ( n ) ; } catch ( remote exception e ) { throw new io ( str , e ) ; } }	Skips over and discards n bytes of data from this input stream.
private void gather disjunctions ( disjunction disjunction , list < term > expressions ) {	Gathers the functors to compile as a sequence of choice points.
public static int get int from bytes ( byte [ ] buf , int offset ) { int result = num ; result += buf [ offset ++ ] & num ; result += ( ( buf [ offset ++ ] & num ) << num ) ; result += ( ( buf [ offset ++ ] & num ) << num ) ; result += ( ( buf [ offset ] ) << num ) ; return result ; }	Extracts an int from an array of bytes.
public static void write int to byte array ( byte [ ] buf , int offset , int value ) { buf [ offset ++ ] = ( byte ) ( value & num ) ; buf [ offset ++ ] = ( byte ) ( ( value & num ) > > num ) ; buf [ offset ++ ] = ( byte ) ( ( value & num ) > > num ) ; buf [ offset ] = ( byte ) ( ( value & num ) > > num ) ; }	Outputs an int into a byte array.
public static void write24 bit int to byte array ( byte [ ] buf , int offset , int value ) { buf [ offset ++ ] = ( byte ) ( value & num ) ; buf [ offset ++ ] = ( byte ) ( ( value & num ) > > num ) ; buf [ offset ] = ( byte ) ( ( value & num ) > > num ) ; }	Outputs an int into a byte array, copying only the bottom 24 bits of the integer.
public static int get24 bit int from bytes ( byte [ ] buf , int offset ) { int i = num ; offset ++ ; i += buf [ offset ++ ] & num ; i += ( ( buf [ offset ++ ] & num ) << num ) ; i += ( ( buf [ offset ] & num ) << num ) ; return i ; }	Extracts an int from an array of bytes.
public static short get short from bytes ( byte [ ] buf , int offset ) { short result = num ; result += buf [ offset ++ ] & num ; result += ( ( buf [ offset ] ) << num ) ; return result ; }	Extracts a short from an array of bytes.
public static void write short to byte array ( byte [ ] buf , int offset , short value ) { buf [ offset ++ ] = ( byte ) ( value & num ) ; buf [ offset ] = ( byte ) ( ( value & num ) > > num ) ; }	Outputs a short into a byte array.
public tree search state < e > get child state for operator ( operator < tree < e > > op ) {	Returns the state obtained by applying the specified operation.
public iterator < operator < tree < e > > > valid operators ( boolean reverse ) {	Gets all operators valid from this state.
public long get id ( ) {	Returns the integer id of the attribute.
public t get value ( ) {	Gets the object value of a object attribute.
public void set value ( t value ) throws illegal argument exception { integer b = attribute class . lookup int . get ( value ) ;	Sets the specified object as the value of this attribute.
public static string [ ] list to array ( string value , string delim ) { list < string > result = new array list < string > ( ) ; string tokenizer tokenizer = new string tokenizer ( value , delim ) ; while ( tokenizer . has more tokens ( ) ) { result . add ( tokenizer . next token ( ) ) ; } return result . to array ( new string [ result . size ( ) ] ) ; }	Converts a string listing sub-strings seperated by a delimeter into an array of strings.
public static string array to list ( string [ ] array , string delim ) { string result = str ; for ( int i = num ; i < array . length ; i ++ ) { result += array [ i ] + ( ( i == ( array . length - num ) ) ? str : delim ) ; } return result ; }	Converts an array of strings into a delimeter seperated string.
public static string to camel case ( string name ) { string [ ] parts = name . split ( str ) ; string result = parts [ num ] ; for ( int i = num ; i < parts . length ; i ++ ) { if ( parts [ i ] . length ( ) > num ) { result += upper first char ( parts [ i ] ) ; } } return result ; }	Converts a string to camel case.
private static string buffer list handlers ( handler [ ] handlers , string buffer buffer ) { for ( handler handler : handlers ) { class < ? extends handler > handler class = handler . get class ( ) ; formatter formatter = handler . get formatter ( ) ; buffer . append ( str ) . append ( handler class . get name ( ) ) . append ( str ) ; buffer . append ( str ) . append ( handler . get level ( ) . to string ( ) ) . append ( str ) ; if ( formatter != null ) { buffer . append ( str ) . append ( formatter . get class ( ) . get name ( ) ) . append ( str ) ; } } return buffer ; }	Lists information about logging handlers.
public wam resolve call point ( int functor name ) { wam result = ( wam ) symbol table . get ( functor name , symkey callpoints ) ; if ( result == null ) { result = new wam ( - num , num , functor name ) ; } return result ; }	Looks up the offset of the start of the code for the named functor.
protected wam set code address ( int functor name , int offset , int length ) { wam entry = new wam ( offset , length , functor name ) ; symbol table . put ( functor name , symkey callpoints , entry ) ;	Records the offset of the start of the code for the named functor.
public boolean is sub category ( hierarchy attribute comp ) {	Tests if another hierarchy attribute is strict a sub-category of this one.
public long get id ( ) {	Returns the long id of the attribute.
public string get value at level ( string level ) { int index = attribute class . levels . index of ( level ) ; if ( index == - num ) { throw new illegal argument exception ( str + level + str ) ; } return get value at level ( index ) ; }	Gets the label value at the named level of the hierarchy.
public string get last value ( ) { list < string > path value = get path value ( ) ; return path value . get ( path value . size ( ) - num ) ; }	Gets the label value at the last level of the hierarchy.
private void write object ( object output stream out ) throws io {	Serialized a hierarchy attribute.
private void read object ( object input stream in ) throws io , class not found exception {	Deserializes a hierarchy attribute.
public float compute h ( eight puzzle state state , heuristic search node search node ) {	Returns heuristic evaluation of an eight puzzle board position as the manhattan distance of all tiles from theircorrect positions.
private int mod ( long c , int bucket size ) { return ( int ) ( ( c < num ) ? ( ( bucket size + ( c % bucket size ) ) % bucket size ) : ( c % bucket size ) ) ; }	Calculates the modulo of a coordinate with the bucket size.
public void add error message ( string key , string user message ) { errors . add ( new user readable error impl ( key , user message ) ) ; }	Adds another user readable error message to this exception.
public void write ( string str , int off , int len ) throws io {	Writes a string of characters to the filtered writer.
public map < string , ordinal attribute > classify ( state state ) throws classifying failure exception {	Classifies a state using the decision tree.
public int compare ( t a , t b ) { boolean a rb = partial ordering . evaluate ( a , b ) ; if ( ! a rb ) { return - num ; } boolean b ra = partial ordering . evaluate ( b , a ) ; return ( a rb && b ra ) ? num : num ; }	Translates the partial order into the +1, 0, -1 convention needed by Comparators.
public iterator iterator ( ) { try { distributed iterator impl di ; di = new distributed iterator impl ( super . iterator ( ) ) ; return new client iterator ( di ) ; } catch ( remote exception e ) {	Returns a distriubuted iterator that can provide elements of the list on demand over a remote connection.
public static int int log base2 ( int value ) { int temp1 ; int temp2 = value > > num ; if ( temp2 > num ) { temp1 = temp2 > > num ; return ( temp1 > num ) ? ( num + log table 256 [ temp1 ] ) : ( num + log table 256 [ temp2 ] ) ; } else { temp1 = value > > num ; return ( temp1 > num ) ? ( num + log table 256 [ temp1 ] ) : log table 256 [ value ] ; } }	Calcalates the log base 2 of an integer.
public static int int log base2v2 ( int value ) { int temp ; if ( ( temp = value > > num ) > num ) { return num + log table 256 [ temp ] ; } else if ( ( temp = value > > num ) > num ) { return num + log table 256 [ temp ] ; } else if ( ( temp = value > > num ) > num ) { return num + log table 256 [ temp ] ; } else { return log table 256 [ value ] ; } }	Calcalates the log base 2 of an integer.
public static int int log base10v2 ( int value ) { return ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : num ) ) ) ) ) ) ) ) ; }	Calcalates the log base 10 of an integer.
public static int int log base10v3 ( int value ) { return ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : num ) ) ) ) ) ) ) ) ; }	Calcalates the log base 10 of an integer.
public static int int log base10 ( long value ) { return ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : ( ( value >= num ) ? num : num ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; }	Calcalates the log base 10 of an integer.
public static int int log base10v2 ( long value ) { return ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : ( ( value < num ) ? num : num ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; }	Calcalates the log base 10 of an integer.
public static int get character count int32 ( int value ) { if ( value >= num ) { return get character count u ( value ) ; } else if ( value == integer . min value ) { return get character count u ( integer . max value ) + num ; } else { return get character count u ( - value ) + num ; } }	Calculates the number of ASCII characters that will be needed to represent a specifed signed 32-bit integer.
public static int get character count int64 ( long value ) { if ( value >= num ) { return get character count u ( value ) ; } else if ( value == long . min value ) { return get character count u ( long . max value ) + num ; } else { return get character count u ( - value ) + num ; } }	Calculates the number of ASCII characters that will be needed to represent a specifed signed 64-bit integer.
public static int get character count decimal ( long integer value , int scale ) { boolean is neg = integer value < num ;	Calculates the number of ASCII characters that will be needed to represent a specified signed decimal number.
public void set head ( functor head , sizeable list < wam > instructions ) { this . head = head ; add instructions ( instructions ) ; }	Sets a compiled head functor to this clause.
public void emmit code ( byte buffer buffer , wam machine , wam call point ) throws linkage exception {	Emmits the binary byte code for the clause into a machine, writing into the specified byte array.
protected void set current screen ( work flow screen panel screen ) {	This is a helper method that controller implementations may find useful for moving to a new screen.
public boolean evaluate ( t t ) {	Evaluates a logical predicate.
protected iterator get key iterator ( final string base , final string modifier , final string key ) { return new iterator ( ) {	For a given environment, base, modifier and key and setting of the use of default environments feature thisgenerates an iterator that walks over the order in which to try and access properties. See the {.
protected void create array properties ( ) {	Scans all the properties in the parent Properties object and creates arrays for any array property definitions.
public void set rate ( float hertz ) {	Specifies the throttling rate in operations per second.
protected numeric type evaluate ( numeric type first number ) {	Evaluates the arithmetic operator on its numeric argument.
protected void find properties ( ) {	This methods attempts to load the properties from a file or URL referenced by the system property with the samename as the properties resource name, from a resource on the classpath with the same name as the propertiesresource name or from a properties file name relative to the current working directory.
protected properties get properties using system property ( ) {	Tries to load the properties from the file or URL named by the system property with name mathching the propertiesresource name.
protected properties get properties using classpath ( ) {	Tries to load the properties from the classpath using the classloader for this class.
protected properties get properties using cwd ( ) {	Tries to load the properties as a file or URL matching the properties resource name.
protected void leave functor ( functor functor ) { int pos = traverser . get position ( ) ; if ( ! traverser . is in head ( ) && ( pos >= num ) ) { functor transformed = built in transform . apply ( functor ) ; if ( functor != transformed ) { built in functor built in functor = ( built in functor ) transformed ; term parent term = traverser . get parent context ( ) . get term ( ) ; if ( parent term instanceof clause ) { clause parent clause = ( clause ) parent term ; parent clause . get body ( ) [ pos ] = built in functor ; } else if ( parent term instanceof functor ) { functor parent functor = ( functor ) parent term ; parent functor . get arguments ( ) [ pos ] = built in functor ; } } } }	Applies the built-in transform during a post-fix visit of a term.
public term get value ( ) { term result = this ; term assignment = this . substitution ;	Gets the actual value of a term, which is either the term itself, or in the case of variables, the value that iscurrently assigned to the variable.
public void set substitution ( term term ) { term term to bind to = term ;	Binds this variable to the specified value.
public queue < search node < o , t > > create queue ( ) { return new priority queue < search node < o , t > > ( num , new greedy comparator ( ) ) ; }	Creates the correct type of queue for this search.
public void clean up ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( io e ) { log log . error ( str , e ) ; } oos = null ; } if ( connector != null ) {	Drop the connection to the remote host and release the underlying connector thread if it has been created.
public void append ( logging event event ) { if ( event == null ) { return ; } if ( address == null ) { error handler . error ( str + this . name + str ) ; return ; } if ( oos != null ) { try { if ( location info ) { event . get location information ( ) ; } oos . write object ( event ) ;	Appends a logging event to the remote event reciever.
void fire connector ( ) { if ( connector == null ) { log log . debug ( str ) ; connector = new connector ( ) ; connector . set daemon ( bool ) ; connector . set priority ( thread . min priority ) ; connector . start ( ) ; } }	Starts a new connector thread to do?.
protected void initialize printers ( ) { int max columns = num ; printers . add ( new source clause printer ( interner , symbol table , traverser , max columns ++ , print table ) ) ; printers . add ( new position printer ( interner , symbol table , traverser , max columns ++ , print table ) ) ; printers . add ( new unoptimized label printer ( interner , symbol table , traverser , max columns ++ , print table ) ) ; printers . add ( new unoptimized byte code printer ( interner , symbol table , traverser , max columns ++ , print table ) ) ; printers . add ( new label printer ( interner , symbol table , traverser , max columns ++ , print table ) ) ; printers . add ( new byte code printer ( interner , symbol table , traverser , max columns ++ , print table ) ) ; }	Sets up the stack of column printers.
public void commit ( ) { tx id tx id = null ;	When operating in transactional mode causes any changes since the last commit to be made visible to the searchmethod.
public void rollback ( ) { tx id tx id = null ;	When operation in transactional mode causes any changes since the last commit to be dropped and never madevisible to the search method.
public void request write operation ( tx operation op ) {	Requests an operation that alters the transactional resource.
private void add cached operation ( tx id tx id , tx operation cached write operation ) { list < tx operation > write cache = tx writes . get ( tx id ) ; if ( write cache == null ) { write cache = new array list < tx operation > ( ) ; tx writes . put ( tx id , write cache ) ; } write cache . add ( cached write operation ) ; }	Adds a transactional operation to the transactional write-behind cache for the specified transaction.
private void acquire global write lock ( tx id tx id ) throws interrupted exception {	Waits until the global write lock can be acquired by the specified transaction.
private void release global write lock ( ) {	Releases the global write lock from being assigned to a transaction.
private void enlist with session ( ) { tx session session = tx session impl . get current session ( ) ;	Enlists this transactional resource with the current session.
@ override public boolean enter ( rule set node rule set node ) { scope node scope node = node tree utils . get first child ( rule set node , scope node . class ) ; selector group node selector group node = node tree utils . get first child ( rule set node , selector group node . class ) ; if ( selector group node == null ) { return bool ; } list < selector node > selector nodes = node tree utils . get children ( selector group node , selector node . class ) ; if ( selector nodes . size ( ) < num ) { return bool ; } list < media query node > media query nodes = node tree utils . get and remove children ( scope node , media query node . class ) ; for ( media query node media query node : media query nodes ) { scope node media scope node = node tree utils . get first child ( media query node , scope node . class ) ; list < rule set node > nested rule sets = node tree utils . get and remove children ( media scope node , rule set node . class ) ;	Locates nested MediaQueryNode inside RuleSetNode,separates RuleSetNode and MediaQueryNodeIf MediaQueryNode has nested RuleSetNodes than to everynested selectors will added selector of input RuleSetNodeIf MediaQueryNode has other nodes except WhiteSpaceCollectionNode andRuleSetNode than all of that will be wrapped with new RuleSetNode withthe same selectors as has input RuleSetNode.
public boolean offer ( e e , long timeout , time unit unit ) throws interrupted exception { if ( e == null ) { throw new illegal argument exception ( str ) ; } reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; long nanos = unit . to nanos ( timeout ) ; try { do { if ( insert ( e , bool ) ) { return bool ; } try { nanos = not full . await nanos ( nanos ) ; } catch ( interrupted exception ie ) {	Inserts the specified element into this queue, waiting if necessary up to the specified wait time for space tobecome available.
public e poll ( long timeout , time unit unit ) throws interrupted exception { reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; try { long nanos = unit . to nanos ( timeout ) ; do { if ( count != num ) { return extract ( bool , bool ) . get element ( ) ; } try { nanos = not empty . await nanos ( nanos ) ; } catch ( interrupted exception ie ) { not empty . signal ( ) ;	Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time if no elementsare present on this queue.
public void put ( e e ) throws interrupted exception { try { try put ( e ) ; } catch ( synch exception ex ) {	Adds the specified element to this queue, waiting if necessary for space to become available. This method delegated to {.
public object next ( ) { try { object ob = source . next ( ) ; return ob ; } catch ( remote exception e ) { throw new illegal state exception ( e ) ; } }	Fetches the next element from this iterator.
public boolean get property as boolean ( string prop name ) { string prop = get property ( prop name ) ; return ( prop != null ) && boolean . parse boolean ( prop ) ; }	Parses a property as a boolean.
public integer get property as integer ( string prop name ) { string prop = get property ( prop name ) ; return ( prop != null ) ? integer . value of ( prop ) : null ; }	Parses a property as an integer.
public long get property as long ( string prop name ) { string prop = get property ( prop name ) ; return ( prop != null ) ? long . value of ( prop ) : null ; }	Parses a property as a long.
public scope node call mixin ( string name , arguments node arguments ) { list < expression group node > argument list = ( arguments != null ) ? node tree utils . get children ( arguments , expression group node . class ) : collections . < expression group node > empty list ( ) ; if ( argument list . size ( ) > parameter definitions . size ( ) ) { throw new illegal mixin argument exception ( name , parameter definitions . size ( ) ) ; }	Creates a clone of this scope to be attached to the tree at the site of a mixin reference.
private void set addition visitor ( ) { set addition visitor ( new inclusive node visitor ( ) { @ override public boolean add ( parameters node node ) { for ( variable definition node variable : node tree utils . get children ( node , variable definition node . class ) ) { parameter definitions . add ( variable ) ; add ( variable ) ; } return super . add ( node ) ; } @ override public boolean add ( rule set node node ) { selector group node selector group = node tree utils . get first child ( node , selector group node . class ) ; for ( selector node selector node : node tree utils . get children ( selector group , selector node . class ) ) { string builder sb = new string builder ( ) ; for ( node selector child : selector node . get children ( ) ) { sb . append ( selector child . to string ( ) ) ; } string selector = sb . to string ( ) ;	Some nodes are captured in additional structures to aid later resolution.
protected void backtrack ( search node check node ) { while ( ( check node != null ) && ( check node . unexamined successor count == num ) ) { reversable undo state = ( re traversable ) check node . get state ( ) ; undo state . undo operator ( ) ; check node = check node . get parent ( ) ; } }	Back-tracks from the specified node, moving succesively upwards through the chain of parent nodes, until a nodeis encountered that has unexamined successors.
public byte [ ] retrieve code ( wam call point ) { byte [ ] result = new byte [ call point . length ] ; code buffer . get ( result , call point . entry point , call point . length ) ; return result ; }	Extracts the raw byte code from the machine for a given call table entry.
protected set < variable > execute and extract bindings ( wam query ) {	Runs a query, and for every non-anonymous variable in the query, decodes its binding value from the heap andreturns it in a set of variable bindings.
protected term decode heap ( int start , map < integer , variable > variable context ) {	Decodes a term from the raw byte representation on the machines heap, into an abstract syntax tree.
public void capture ( ) {	Captures an objects state in this memento.
public void restore ( object ob ) throws no such field exception {	Restores the values currently in this memento to the specified object.
public object get ( class cls , string attr ) { hash map map ;	Gets the value of the named field of the specified class.
public void put ( class cls , string attr , object val ) { hash map map ;	Places the specified value into the memento based on the field's declaring class and name.
public collection get all field names ( class cls ) {	Generates a list of all the fields of the object that this memento maps for a given class.
public void execute ( ) throws mojo execution exception , mojo failure exception {	Implementation of the prod-script goal.
public boolean offer ( e o ) {	Inserts the specified element onto the tail of this queue.
public search node < o , t > create search node ( t state ) { return new search node < o , t > ( state ) ; }	Creates the correct type of search nodes for this search.
public queue < search node < o , t > > create queue ( ) { return new priority queue < search node < o , t > > ( num , new uniform cost comparator ( ) ) ; }	Creates the correct type of queue for this search.
public static term walker simple walker ( term visitor visitor ) { depth first backtracking search < term , term > search = new depth first backtracking search < term , term > ( ) ; return new term walker ( search , new default traverser ( ) , visitor ) ; }	Provides a simple depth first walk over a term.
public static term walker goal walker ( unary predicate < term > unary predicate , term visitor visitor ) { term walker walker = simple walker ( visitor ) ; walker . set goal predicate ( unary predicate ) ; return walker ; }	Provides a depth first walk over a term, visiting only when a goal predicate matches.
public static term walker positional walker ( positional term visitor visitor ) { positional term traverser positional traverser = new positional term traverser impl ( ) ; positional traverser . set context change visitor ( visitor ) ; visitor . set positional traverser ( positional traverser ) ; return new term walker ( new depth first backtracking search < term , term > ( ) , positional traverser , visitor ) ; }	Provides a positional depth first walk over a term.
public static term walker positional goal walker ( unary predicate < term > unary predicate , positional term visitor visitor ) { term walker walker = positional walker ( visitor ) ; walker . set goal predicate ( unary predicate ) ; return walker ; }	Provides a positional depth first walk over a term, visiting only when a goal predicate matches.
public static term walker positional postfix walker ( positional term visitor visitor ) { positional term traverser positional traverser = new positional term traverser impl ( ) ; positional traverser . set context change visitor ( visitor ) ; visitor . set positional traverser ( positional traverser ) ; return new term walker ( new post fix search < term , term > ( ) , positional traverser , visitor ) ; }	Provides a positional postfix walk over a term.
public static properties get properties ( input stream is ) throws io {	Get properties from an input stream.
public static properties get properties ( file file ) throws io {	Get properties from a file.
public static properties get properties ( url url ) throws io {	Get properties from a url.
public static properties get properties ( string pathname ) throws io {	Get properties from a path name.
protected dimension compute grid size ( ) { int cols = model . get width ( ) ; int rows = model . get height ( ) ; int horiz separator size = num ; for ( int size : model . get horizontal separators ( ) . values ( ) ) { horiz separator size += size ; } int vert separator size = num ; for ( int size : model . get vertical separators ( ) . values ( ) ) { vert separator size += size ; } return new dimension ( vert separator size + col to x ( cols ) , horiz separator size + row to y ( rows ) ) ; }	Computes the rendered dimensions of the text grid model, on screen.
private void initialize font metrics ( ) { if ( ! font metrics initialized ) { font metrics font metrics = get font metrics ( get font ( ) ) ; char width = font metrics . char width ( str ) ; char height = font metrics . get height ( ) ; descent = font metrics . get descent ( ) ; font metrics initialized = bool ; } }	Sets up metrics relating to the size of the font used to display the text grid.
public void add property change listener ( property change listener l ) {	Adds a property changed listener to be notified of changes to the application state.
public void add property change listener ( string p , property change listener l ) {	Adds a property changed listener to be notified of changes to the named property.
public void remove property change listener ( string p , property change listener l ) { if ( listeners == null ) { return ; } synchronized ( listeners ) { listeners . remove ( l ) ; } }	Removes the specified property change listener from the list of active listeners.
protected void fire property change ( property change event evt ) {	Notifies all property change listeners of the given PropertyChangeEvent.
public static type create instance ( string name , double min , double max ) {	Creates a new double range type with the specified name, if it does not already exist.
public void do fade ( color delta target , string group name ) { fade state fade state = timers . get ( group name ) ;	Requests a color fade against the specified target, under a group name.
private void show horizontal bar ( ) {	Creates a horizontal grip-able bar for adjusting the console height.
private void show left bar ( ) {	Creates a vertical grip-able bar for adjusting the left panel width.
private void show right bar ( ) {	Creates a vertical grip-able bar for adjusting the right panel width.
private static void sanitize radio controls ( form element form ) { map < string , element > controls by name = new hash map < string , element > ( ) ; for ( element control : form . elements ( ) ) {	Ensures that radio controls are mutually exclusive within control groups.
public void await ( t t ) throws interrupted exception { synchronized ( monitor ) { long wait nanos = evaluate with wait time nanos ( t ) ;	Wait for the predicate to become true on the specified object.
public boolean await ( t t , long timeout , time unit unit ) throws interrupted exception { synchronized ( monitor ) {	Wait for up to a timeout limit for the predicate to become true on the specified object.
public void execute ( ) throws mojo execution exception , mojo failure exception {	Implementation of the script goal.
protected string append classpath ( string command line , boolean unix ) { string path seperator ; string seperator ; if ( unix ) { path seperator = str ; seperator = str ; } else { path seperator = str ; seperator = str ; } for ( iterator i = classpath elements . iterator ( ) ; i . has next ( ) ; ) { string cp path = ( string ) i . next ( ) ; cp path = cp path . replace ( str , path seperator ) ; command line += cp path + ( i . has next ( ) ? seperator : str ) ; } return command line ; }	Appends the classpath onto the command line.
public static type create instance ( string name , date only from , date only to ) {	Creates a new date range type with the specified name, if it does not already exist.
private void print introduction ( ) { system . out . println ( str ) ; system . out . println ( str ) ; system . out . println ( str ) ; system . out . println ( str ) ; system . out . println ( ) ; }	Prints a welcome message.
private console reader initialize command line reader ( ) throws io { console reader reader = new console reader ( ) ; reader . set bell enabled ( bool ) ; return reader ; }	Sets up the JLine console reader.
private void evaluate ( sentence < clause > sentence ) throws source code exception { clause clause = sentence . get t ( ) ; if ( clause . is query ( ) ) { engine . end scope ( ) ; engine . compile ( sentence ) ; evaluate query ( ) ; } else {	Evaluates a query against the resolver or adds a clause to the resolvers domain.
private void evaluate query ( ) {	Evaluates a query. In the case of queries, the interner is used to recover textual names for the resultingvariable bindings. The user is queried through the parser to if more than one solution is required.
public static multi type data get multi type data ( boolean b ) {	Converts a boolean into a multi type data object.
public static multi type data get multi type data ( byte b ) {	Converts a byte into a multi type data object.
public static multi type data get multi type data ( char c ) {	Converts a char into a multi type data object.
public static multi type data get multi type data ( short s ) {	Converts a short into a multi type data object.
public static multi type data get multi type data ( int i ) {	Converts a int into a multi type data object.
public static multi type data get multi type data ( long l ) {	Converts a long into a multi type data object.
public static multi type data get multi type data ( float f ) {	Converts a float into a multi type data object.
public static multi type data get multi type data ( double d ) {	Converts a double into a multi type data object.
public static multi type data get multi type data ( string s ) { multi type data result = new multi type data ( ) ;	Converts a String into a multi type data object.
public static multi type data get multi type data ( object o ) {	Converts a Object into a multi type data object.
public void put ( string name , object value ) { page context . set attribute ( name , value , scope ) ; }	Inserts an object into the scope.
public void clear up to ( int key ) { if ( ( ( start <= key ) && ( key < ( end - num ) ) ) ) {	Clears entries up to and including the specified key, from the map.
private void expand ( int key ) {	Expands the size of the storage to whichever is the larger of 1.5 times the old size, or an array large enough tohold the proposed key that caused the expansion, copying the old data into a new array.
private void internal insert ( char character , int c , int r ) { max column = ( c > max column ) ? c : max column ; max row = ( r > max row ) ? r : max row ; data . put ( ( long ) c , ( long ) r , character ) ; }	Inserts a single character into the grid at the specified location.
public int compare ( search node object1 , search node object2 ) { float cost1 = object1 . get path cost ( ) ; float cost2 = object2 . get path cost ( ) ; return ( cost1 > cost2 ) ? num : ( ( cost1 < cost2 ) ? - num : num ) ; }	Compares two search nodes by their path cost.
public term parse operators ( term [ ] terms ) throws source code exception {	Parses a flat list of terms, which are literals, variables, functors, or operators into a tree in such a way thatthe operators associativity and precendence is obeyed.
public enum map < op symbol . fixity , op symbol > get operators matching name by fixity ( string name ) { return operators . get ( name ) ; }	Checks the operator table for all possible operators matching a given name.
protected static op symbol check and resolve to fixity ( candidate op symbol candidate , op symbol . fixity ... fixities ) throws source code exception { op symbol result = null ; for ( op symbol . fixity fixity : fixities ) { result = candidate . get possible operators ( ) . get ( fixity ) ; if ( result != null ) { break ; } } if ( result == null ) { throw new source code exception ( str + candidate + str + arrays . to string ( fixities ) + str , null , null , null , candidate . get source code position ( ) ) ; } return result ; }	Checks if a candidate operator symbol can have one of the specified fixities, and resolve it to an oeprator withthat fixity if so.
public search node < o , t > make node ( successor successor ) throws search not exhaustive exception { search node new node ; try {	Makes a new node of the same type as this one from a Successor state.
public string get errors ( ) {	Lists all the parsing errors from the most recent parsing in a string.
public string get options in force ( ) {	Lists the properties set from the most recent parsing or an empty string if no parsing has been done yet.
public string get usage ( ) { string result = str ; int option width = num ; int argument width = num ;	Generates a usage string consisting of the name of each option and each options argument description and comment.
public void add trailing pairs to properties ( properties properties ) { if ( trailing properties != null ) { for ( object prop key : trailing properties . key set ( ) ) { string name = ( string ) prop key ; string value = trailing properties . get property ( name ) ; properties . set property ( name , value ) ; } } }	If a command line has been parsed, calling this method sets all of its free arguments that were name=value pairson the specified properties.
public void add options to properties ( properties properties ) { if ( parsed properties != null ) { for ( object prop key : parsed properties . key set ( ) ) { string name = ( string ) prop key ; string value = parsed properties . get property ( name ) ;	If a command line has been parsed, calling this method sets all of its options that were set to the specifiedproperties.
protected void add option ( string option , string comment , string argument , boolean mandatory , string format regexp ) {	Adds the option to list of available command line options.
private void check argument format ( command line option option info , char sequence matched arg ) {	Checks the format of an argument to an option against its specified regular expression format if one has beenset.
public static < t , u > string compare iterators ( iterator < u > iterator , iterator < t > expected iterator , function < u , t > mapping ) { string error message = str ; while ( iterator . has next ( ) ) { u next = iterator . next ( ) ; t next mapped = mapping . apply ( next ) ; t next expected = expected iterator . next ( ) ; if ( ! next mapped . equals ( next expected ) ) { error message += str + next expected + str + next mapped ; } } return error message ; }	Walks down two iterators, comparing them element by element, using the equals method.
public enumeration list options ( ) { vector < option > result ; string desc ; selected tag tag ; int i ; result = new vector < option > ( ) ; desc = str ; for ( i = num ; i < tags stemmers . length ; i ++ ) { tag = new selected tag ( tags stemmers [ i ] . get id ( ) , tags stemmers ) ; desc += str + tag . get selected tag ( ) . get id ( ) + str + tag . get selected tag ( ) . get readable ( ) + str ; } result . add element ( new option ( str + desc + str + new selected tag ( stemmer orengo , tags stemmers ) + str , str , num , str + tag . to option list ( tags stemmers ) ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; return result . elements ( ) ; }	Returns an enumeration describing the available options.
public string [ ] get options ( ) { vector < string > result ; result = new vector < string > ( ) ; result . add ( str ) ; result . add ( str + get stemmer ( ) ) ; result . add ( str ) ; result . add ( str + get named entities ( ) ) ; result . add ( str ) ; result . add ( str + get stopwords ( ) ) ; result . add ( str ) ; result . add ( str + get cache ( ) ) ; return result . to array ( new string [ result . size ( ) ] ) ; }	Gets the current settings of the classifier.
public void set stemmer ( selected tag value ) { if ( value . get tags ( ) == tags stemmers ) { m = value . get selected tag ( ) . get id ( ) ; invalidate ( ) ; } }	Sets the stemmer type to use.
protected synchronized ptstemmer . stemmer get actual stemmer ( ) throws pt { if ( m == null ) {	Returns the stemmer to use.
public string stem ( string word ) { string ret = null ; try { ret = get actual stemmer ( ) . get word stem ( word ) ; } catch ( pt e ) { e . print stack trace ( ) ; } return ret ; }	Returns the stemmed version of the given word.Word is converted to lower case before stemming.
public static void main ( string [ ] args ) { try { stemming . use stemmer ( new pt ( ) , args ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	Runs the stemmer with the given options.
public static type create instance ( string name , float min , float max ) {	Creates a new float range type with the specified name, if it does not already exist.
public void reset ( ) {	Resets the machine, to its initial state.
protected string trace env frame ( ) { return str + data . get ( ep ) + str + data . get ( ep + num ) + str + data . get ( ep + num ) + str ; }	Pretty prints the current environment frame, for debugging purposes.
protected string trace choice frame ( ) { if ( bp == num ) { return str ; } int n = data . get ( bp ) ; return str + data . get ( bp ) + str + data . get ( bp + n + num ) + str + data . get ( bp + n + num ) + str + data . get ( bp + n + num ) + str + data . get ( bp + n + num ) + str + data . get ( bp + n + num ) + str + data . get ( bp + n + num ) + str + data . get ( bp + n + num ) ; }	Pretty prints the current choice point frame, for debugging purposes.
private boolean call internal ( int function , int arity , int num perms ) { switch ( function ) { case call 1 id : return internal call 1 ( num perms ) ; case execute 1 id : return internal execute 1 ( ) ; default : throw new illegal state exception ( str + function ) ; } }	Invokes an internal function.
private int next stack frame ( ) {	Computes the start of the next stack frame.
private boolean backtrack ( ) {	Backtracks to the continuation label stored in the current choice point frame, if there is one.
private void trail ( int addr ) {	Records the address of a binding onto the 'trail'.
private void unwind trail ( int a1 , int a2 ) {	Undoes variable bindings that have been recorded on the 'trail'.
private void tidy trail ( ) { int i ;	Tidies trail when a choice point is being discarded, and a previous choice point it being made the current one.
private boolean unify ( int a1 , int a2 ) {	Attempts to unify structures or references on the heap, given two references to them.
private boolean unify const ( int fn , int addr ) { boolean success ; int deref = deref ( addr ) ; int tag = deref tag ; int val = deref val ;	A simplified unification algorithm, for unifying against a constant.
private string print slot ( int xi , int mode ) { return ( ( mode == stack addr ) ? str : str ) + ( ( mode == stack addr ) ? ( xi - ep - num ) : xi ) ; }	Pretty prints a variable allocation slot for tracing purposes.
public static eight puzzle state get random start state ( ) { eight puzzle state new state ;	Generates a random starting position.
public static boolean is solvable ( eight puzzle state state ) {	To check for solvability the empty tile is moved to its goal position and then the number of swaps needed to putthe other tiles in position is counted.
public eight puzzle state get child state for operator ( operator op ) {	Applies a move to generate a new board position.
public iterator < operator < string > > valid operators ( boolean reverse ) {	Supplies the valid moves for a board position.
public string pretty print ( ) { string result = str ; for ( int j = num ; j < num ; j ++ ) { result += new string ( board [ j ] ) + str ; } result = result . replace ( str , str ) ; return result ; }	Pretty prints the board as 3 lines of characters with a space for the empty square.
protected boolean swap tiles ( int x1 , int y1 , int x2 , int y2 ) {	Swaps the two tiles at the specified coordinates.
private static list < character > string to char list ( string board string ) {	Turns a string representation of the board into a list of characters.
private static eight puzzle state char list to state ( list < character > char list ) {	Turns a list of characters representation of the board into a proper state.
private string to log4j message ( log record record ) { string message = record . get message ( ) ;	Transforms a java.util.logging.LogRecord to a message printable on Log4J.
private org . apache . log4j . level to log4j ( level level ) { if ( level . severe == level ) { return org . apache . log4j . level . error ; } else if ( level . warning == level ) { return org . apache . log4j . level . warn ; } else if ( level . info == level ) { return org . apache . log4j . level . info ; } else if ( level . fine == level ) { return org . apache . log4j . level . debug ; } else if ( level . finer == level ) { return org . apache . log4j . level . trace ; } else if ( level . off == level ) { return org . apache . log4j . level . off ; } return org . apache . log4j . level . off ; }	Converts java.util.logging levels to Log4J logging levels.
private void requeue ( e element ) { requeue element wrapper < e > record = new requeue element wrapper < e > ( element ) ; requeue . add ( record ) ; requeued element map . put ( element , record ) ; }	Places an element onto the requeue buffer.
private requeue element wrapper < e > requeue ( e element , object owner , acquire state acquired ) { requeue element wrapper < e > record = new requeue element wrapper < e > ( element ) ; record . state = acquired ; record . owner = owner ; requeue . add ( record ) ; requeued element map . put ( element , record ) ; return record ; }	Places an element onto the requeue buffer, in the acquired state by the specified owner.
private void increment size and count ( e record ) {	Atomically adds to the size and count, if the queue is running in atomic counting mode, or sizeable mode and theelement is sizeable.
private void decrement size and count ( e record ) {	Atomically subtracts from the size and count, if the queue is running in atomic counting mode, or sizeable modeand the element is sizeable.
private void signal on size threshold crossing ( long old size , long new size ) { if ( signalable != null ) { if ( ( old size >= low water size threshold ) && ( new size < low water size threshold ) ) { signalable . signal all ( ) ; } else if ( ( old size >= high water size threshold ) && ( new size < high water size threshold ) ) { signalable . signal ( ) ; } } }	Signals the signallable resource if the size crosses a threshold boundary in a downward direction.
public naming enumeration list ( string name ) throws naming exception { if ( str . equals ( name ) ) {	Enumerates the names bound in the named context, along with the class names of objects bound to them.
public naming enumeration list bindings ( string name ) throws naming exception { if ( str . equals ( name ) ) {	Enumerates the names bound in the named context, along with the objects bound to them.
public object add to environment ( string prop name , object prop val ) { if ( my env == null ) { my env = new hashtable ( num , num ) ; } return my env . put ( prop name , prop val ) ; }	Adds a new environment property to the environment of this context.
public object remove from environment ( string prop name ) { if ( my env == null ) { return null ; } return my env . remove ( prop name ) ; }	Removes an environment property from the environment of this context.
private static void run gc ( ) {	Repeatedly runs the garbage collector and finalization method of the JVM runtime system until the used memorycount becomes stable or 500 iterations occur, whichever happens soonest.
rule literal ( ) { return sequence ( first of ( color ( ) , multi dimension ( ) , dimension ( ) , string ( ) ) , push ( new simple node ( match ( ) ) ) ) ; }	Tokens that don't need to evaluated.
boolean resolve mixin reference ( string name , arguments node arguments ) { if ( ! is parser translation enabled ( ) ) { return push ( new placeholder node ( new simple node ( name ) ) ) ; }	Locates the referenced mixin in one of the scope nodes on the stack.
boolean push variable reference ( string name ) { if ( ! is parser translation enabled ( ) ) { return push ( new simple node ( name ) ) ; }	Looks for a variable definition that matches the reference in the scope nodes on the stack.If found, a reference node that can repeat this lookup later is placed on the stack, not thecurrent value itself.
public void set max row height ( int row , int height ) { integer previous value = max row sizes . get ( row ) ; if ( previous value == null ) { max row sizes . put ( row , height ) ; } else if ( previous value < height ) { max row sizes . put ( row , height ) ; } }	Updates the maximum row height for a row of the data table.
private void update max column width ( int column , int width ) { integer previous value = max column sizes . get ( column ) ; if ( previous value == null ) { max column sizes . put ( column , width ) ; } else if ( previous value < width ) { max column sizes . put ( column , width ) ; } }	Updates the maximum column width for a column of the data table.
public heuristic search node < o , t > make node ( successor successor ) throws search not exhaustive exception { heuristic search node < o , t > node = ( heuristic search node < o , t > ) super . make node ( successor ) ;	Returns a new node based on a successor of this node.
public action forward execute ( action mapping mapping , action form form , http servlet request request , http servlet response response ) throws io , servlet exception { log . fine ( str ) ;	Processes the action providing default error handling.
private void substitute built ins ( term clause ) { term walker walk = term walkers . positional walker ( new built in transform visitor ( interner , symbol table , null , built in transform ) ) ; walk . walk ( clause ) ; }	Substitutes built-ins within a clause, with their built-in definitions.
private void initialise symbol table ( term clause ) {	Runs a symbol key traverser over the clause to be compiled, to ensure that all of its terms and sub-terms havetheir symbol keys initialised.
private void top level check ( term clause ) { term walker walk = term walkers . positional walker ( new top level check visitor ( interner , symbol table , null ) ) ; walk . walk ( clause ) ; }	Finds and marks all functors within the clause that are considered to be top-level.
private string list to string ( variable and functor interner interner , boolean is first , boolean print var name , boolean print bindings ) { string result = str ; if ( is first ) { result += str ; } result += arguments [ num ] . to string ( interner , print var name , print bindings ) ; term cons argument = arguments [ num ] . get value ( ) ; if ( cons argument instanceof cons ) { result += str + ( ( cons ) cons argument ) . list to string ( interner , bool , print var name , print bindings ) ; } if ( is first ) { result += str ; } return result ; }	Pretty prints a term relative to the symbol namings provided by the specified interner.
protected boolean evaluate ( numeric type first number , numeric type second number ) {	Evaluates the arithmetic comparison on its two numeric arguments.
public void running ( ) { try { state lock . write lock ( ) . lock ( ) ; if ( state == state . initial ) { state = state . running ; state change . signal all ( ) ; } } finally { state lock . write lock ( ) . unlock ( ) ; } }	Makes a transaction from the Initial state to the Running state, or no transition if the current state is notInitial.
public void terminating ( ) { try { state lock . write lock ( ) . lock ( ) ; if ( state == state . running ) { state = state . shutdown ; state change . signal all ( ) ; } } finally { state lock . write lock ( ) . unlock ( ) ; } }	Makes a transaction from the Running state to the Shutdown state, or no transition if the current state is notRunning.
public void terminated ( ) { try { state lock . write lock ( ) . lock ( ) ; if ( ( state == state . shutdown ) || ( state == state . running ) ) { state = state . terminated ; state change . signal all ( ) ; } } finally { state lock . write lock ( ) . unlock ( ) ; } }	Makes a transaction from the Running or Shutdown state to the Terminated state, or no transition if the currentstate is not Running or Shutdown.
public boolean offer ( e o ) {	Inserts the specified element into this heap.
private int compare ( node node1 , node node2 ) {	Compares two heap nodes.
private void insert nodes ( node node , node new node ) {	Inserts a single node or a circular doubly linked list of nodes into a list next to the specified node.
public void restart ( ) {	Restarts the sweep alogirithm.
public static < t > set < t > set of ( search method < t > method ) { set < t > result = new hash set < t > ( ) ; find all ( result , method ) ; return result ; }	Finds the set of all goals of a search.
public static < t > collection < t > bag of ( search method < t > method ) { collection < t > result = new array list < t > ( ) ; find all ( result , method ) ; return result ; }	Finds a bag of all goals of a search.
private static < t > void find all ( collection < t > result , search method < t > method ) { for ( iterator < t > i = all solutions ( method ) ; i . has next ( ) ; ) { t next soltn = i . next ( ) ; result . add ( next soltn ) ; } }	Finals all solutions to a search and inserts them into the specified collection.
public t next in sequence ( ) { t result = null ;	Generates the next element in the sequence.
public static void restore values ( object ob , map < string , object > values ) throws no such field exception {	Restores the properties currently in this memento to the specified object.
public object get ( class cls , string property ) throws no such field exception {	Gets the value of the named property of the specified class.
public void put ( class cls , string property , type converter . multi type data value ) {	Sets the value of the named property as a multi type object.
public void put ( class cls , string property , object value ) {	Places the specified value into the memento based on the property's declaring class and name.
private void capture ( boolean ignore null ) {	Captures the fields of the associated object.
public e pop ( ) { e ob ; if ( size ( ) == num ) { return null ; } ob = get ( num ) ; remove ( num ) ; return ob ; }	Pops the first object placed on the stack off of it and returns it.
private string modifiers to string ( int modifiers ) { string result = str ; if ( ( modifiers & input event . shift mask ) != num ) { result += str ; } if ( ( modifiers & input event . ctrl mask ) != num ) { result += str ; } if ( ( modifiers & input event . meta mask ) != num ) { result += str ; } if ( ( modifiers & input event . alt mask ) != num ) { result += str ; } if ( ( modifiers & input event . alt graph mask ) != num ) { result += str ; } return result ; }	Converts the modifiers to a specification string for KeyStroke.
public static int to integer ( string s ) { try { return integer . parse int ( s ) ; } catch ( number format exception e ) {	Converts a string to an integer.
public static date to date ( string s ) {	Converts a string to a date.
public static boolean is date ( string s ) {	Check that a string is a date in the format specified by dateFormat.
public static boolean is time ( string s ) {	Checks that a string is a time in the format specified by timeFormat.
public static boolean is date time ( string s ) { date format date formatter = new simple date format ( date time format ) ; try { date formatter . parse ( s ) ; return bool ; } catch ( parse exception e ) {	Checks that a string is a datetime in the format specified by dateTimeFormat.
public static token source get token source for string ( string string to tokenize ) { simple char stream input stream = new simple char stream ( new string reader ( string to tokenize ) , num , num ) ; prolog parser token manager token manager = new prolog parser token manager ( input stream ) ; return new token source ( token manager ) ; }	Creates a token source on a string.
public static token source get token source for file ( file file ) throws file not found exception {	Creates a token source on a file.
public static source get token source for input stream ( input stream in ) { simple char stream input stream = new simple char stream ( in , num , num ) ; prolog parser token manager token manager = new prolog parser token manager ( input stream ) ; return new token source ( token manager ) ; }	Creates a token source on an input stream.
public boolean is constant ( wam instruction ) { integer name = instruction . get functor name reg1 ( ) ; if ( name != null ) { functor name functor name = interner . get deinterned functor name ( name ) ; if ( functor name . get arity ( ) == num ) { return bool ; } } return bool ; }	Checks if the term argument to an instruction was a constant.
private boolean is void variable ( wam instruction ) { symbol key symbol key = instruction . get symbol key reg1 ( ) ; if ( symbol key != null ) { integer count = ( integer ) symbol table . get ( symbol key , symbol table keys . symkey var occurrence count ) ; boolean non arg position only = ( boolean ) symbol table . get ( symbol key , symbol table keys . symkey var non arg ) ; integer allocation = ( integer ) symbol table . get ( symbol key , symbol table keys . symkey allocation ) ; boolean singleton = ( count != null ) && count . equals ( num ) ; boolean non arg position = ( non arg position only != null ) && true . equals ( non arg position only ) ; boolean permanent = ( allocation != null ) && ( ( byte ) ( ( allocation & num ) > > num ) == wam . stack addr ) ; if ( singleton && non arg position && ! permanent ) { return bool ; } } return bool ; }	Checks if the term argument to an instruction was a singleton, non-argument position variable.
private boolean is non arg ( wam instruction ) { symbol key symbol key = instruction . get symbol key reg1 ( ) ; if ( symbol key != null ) { boolean non arg position only = ( boolean ) symbol table . get ( symbol key , symbol table keys . symkey functor non arg ) ; if ( true . equals ( non arg position only ) ) { return bool ; } } return bool ; }	Checks if the term argument to an instruction was in a non-argument position.
public iterator < operator < term > > get children ( boolean reverse ) { if ( ( traverser != null ) && ( traverser instanceof clause traverser ) ) { return ( ( clause traverser ) traverser ) . traverse ( this , reverse ) ; } else { linked list < operator < term > > result list = null ; if ( ! reverse ) { result list = new linked list < operator < term > > ( ) ; } else { result list = new stack queue < operator < term > > ( ) ; } if ( head != null ) { result list . add ( head ) ; } if ( body != null ) { for ( term body term : body ) { result list . add ( body term ) ; } } return result list . iterator ( ) ; } }	Provides an iterator over the child terms, if there are any.
public term get argument ( int index ) { if ( ( arguments == null ) || ( index > ( arguments . length - num ) ) ) { return null ; } else { return arguments [ index ] ; } }	Gets the argument within the functor with the specified index.
public iterator < operator < term > > get children ( boolean reverse ) { if ( ( traverser != null ) && ( traverser instanceof functor traverser ) ) { return ( ( functor traverser ) traverser ) . traverse ( this , reverse ) ; } else { if ( arguments == null ) { return new linked list < operator < term > > ( ) . iterator ( ) ; } else if ( ! reverse ) { return arrays . as list ( ( operator < term > [ ] ) arguments ) . iterator ( ) ; } else { list < operator < term > > arg list = new linked list < operator < term > > ( ) ; for ( int i = arity - num ; i >= num ; i -- ) { arg list . add ( arguments [ i ] ) ; } return arg list . iterator ( ) ; } } }	Provides an iterator over the child terms, if there are any.
protected string to string arguments ( ) { string result = str ; if ( arity > num ) { result += str ; for ( int i = num ; i < arity ; i ++ ) { term next arg = arguments [ i ] ; result += ( ( next arg != null ) ? next arg . to string ( ) : str ) + ( ( i < ( arity - num ) ) ? str : str ) ; } result += str ; } return result ; }	Creates a string representation of this functors arguments, mostly used for debugging purposes.
public < t extends measure appender > t retrieve summary ( schema definition schema definition , class < t > result clazz , query parameter query parameter ) throws novie runtime exception { final sql query builder < t > sql query builder = new sql query builder < t > ( schema definition , result clazz , query parameter . partial copy ( query parameter kind . groups , query parameter kind . page ) ) ; list < t > result = execute query ( sql query builder ) ; if ( result . is empty ( ) ) { throw new novie runtime exception ( str ) ; } if ( result . size ( ) > num ) { throw new novie runtime exception ( str ) ; } return result . get ( num ) ; }	Execute a query to retrieve the summary. This do not have any group by element.
public < t extends measure appender > list < t > retrieve records ( schema definition schema definition , class < t > result clazz , query parameter query parameter ) throws novie runtime exception { final sql query builder < t > sql query builder = new sql query builder < t > ( schema definition , result clazz , query parameter ) ; return execute query ( sql query builder ) ; }	Execute a query to retrieve the records.
private < t extends measure appender > list < t > execute query ( final sql query builder < t > sql query builder ) throws novie runtime exception { sql query builder . build query ( ) ; final string query string = sql query builder . get query string ( ) ; log . debug ( query string ) ; long before query = system . current time millis ( ) ; list < t > return value = jdbc template . query ( query string , sql query builder . get map sql parameter source ( ) , sql query builder ) ; if ( log . is info enabled ( ) ) { log . info ( str + ( system . current time millis ( ) - before query ) + str ) ; } if ( log . is debug enabled ( ) ) { string builder sb = new string builder ( ) ; for ( entry < string , object > e : sql query builder . get map sql parameter source ( ) . get values ( ) . entry set ( ) ) { if ( sb . length ( ) > num ) { sb . append ( str ) ; } sb . append ( e . get key ( ) ) ; sb . append ( str ) ; sb . append ( e . get value ( ) ) ; } sb . insert ( num , str ) ; sb . append ( str ) ; log . debug ( sb . to string ( ) ) ; } return return value ; }	Private methode called by the public ones to effectively run the query.
public void emmit code ( byte buffer code buffer , wam machine ) throws linkage exception { mnemonic . emmit code ( this , code buffer , machine ) ; }	Writes out the instruction plus arguments in the byte code format to the specified location within a code buffer.
private void set basic type ( class c ) { if ( boolean . class . equals ( c ) ) { type = basic types . boolean ; } else if ( character . class . equals ( c ) ) { type = basic types . character ; } else if ( byte . class . equals ( c ) ) { type = basic types . byte ; } else if ( short . class . equals ( c ) ) { type = basic types . short ; } else if ( integer . class . equals ( c ) ) { type = basic types . integer ; } else if ( long . class . equals ( c ) ) { type = basic types . long ; } else if ( float . class . equals ( c ) ) { type = basic types . float ; } else if ( double . class . equals ( c ) ) { type = basic types . double ; } else { type = basic types . other ; } }	Sets the basic type of this type depending on the class.
public void consult input stream ( input stream stream ) throws source code exception {	Consults an input stream, reading first order logic clauses from it, and inserting them into the resolversknowledge base.
public string print variable binding ( term var ) { return var . to string ( get interner ( ) , bool , bool ) + str + var . get value ( ) . to string ( get interner ( ) , bool , bool ) ; }	Prints a variable binding in the form 'Var = value'.
public iterable < map < string , variable > > expand result set to map ( iterator < set < variable > > solutions ) { return new filterator < set < variable > , map < string , variable > > ( solutions , new function < set < variable > , map < string , variable > > ( ) { public map < string , variable > apply ( set < variable > variables ) { map < string , variable > results = new hash map < string , variable > ( ) ; for ( variable var : variables ) { string var name = get interner ( ) . get variable name ( var . get name ( ) ) ; results . put ( var name , var ) ; } return results ; } } ) ; }	Transforms an iterator over sets of variable bindings, resulting from a query, to an iterator over a map from thestring name of variables to their bindings, for the same sequence of query solutions.
public void run ( ) { try { read stream ( ) ; } catch ( eof eof ) {	A dedicated thread loop for reading the stream and sending incomingpackets to the appropriate router.
private void read stream ( ) throws exception { while ( ! shutdown ) { element doc = reader . parse document ( ) . get root element ( ) ; if ( doc == null ) {	Read the incoming stream until it ends.
static long get time ( ) { if ( random == null ) initialize for type1 ( ) ; long new time = get uuid ( ) ; if ( new time <= last millis ) { increment sequence ( ) ; new time = get uuid ( ) ; } last millis = new time ; return new time ; }	package-visibility for testing.
private static long get uuid ( ) { if ( current millis != system . current time millis ( ) ) { current millis = system . current time millis ( ) ; counter = num ;	Gets the appropriately modified timestamep for the UUID.
@ suppress warnings ( str ) public void track info update ( playlist playlist , track info info ) { this . playlist = playlist ; update play info ( info ) ; }	call this method if the trackInfo object in the playlist was updated. Only the trackinfo object will be sent viaEvent.
@ suppress warnings ( str ) public void update play info ( playlist playlist , progress progress , volume volume ) { if ( playlist != null ) this . playlist = playlist ; if ( progress != null ) this . progress = progress ; if ( volume != null ) this . volume = volume ; update play info ( playlist , progress , null , volume ) ; }	updates the Info about the current song.
@ override public void render final output ( list < t > data , event model event model ) { if ( start music request . verify ( event model , capabilities , this , activators ) ) { if ( is output running ( ) ) { player error ( player error . error already playing , event model . get source ( ) ) ; } else { handle event request ( event model ) ; } } else if ( event model . get list resource container ( ) . provides resource ( collections . singleton list ( music usage resource . id ) ) ) { if ( is output running ( ) ) { event model . get list resource container ( ) . provide resource ( music usage resource . id ) . for each ( resource model -> player error ( player error . error already playing , resource model . get provider ( ) ) ) ; } else { handle resource request ( event model ) ; } } else { handle commands ( event model ) ; } }	method that uses the data from the OutputExtensions to generate a final output that will then be rendered.
private void handle resource request ( event model event model ) { if ( music usage resource . is permanent ( event model ) ) { resource model resource model = event model . get list resource container ( ) . provide resource ( music usage resource . id ) . stream ( ) . filter ( music usage resource :: is permanent ) . find any ( ) . or else ( null ) ;	handles the a request to start playing music via Resource.
private void handle event request ( event model event model ) { playing thread = submit ( ( runnable ) ( ) -> {	handles the a request to start playing music via Event.
protected void fire start music request ( event model event model ) { optional < playlist > playlist = playlist resource . get playlist ( event model ) ; optional < progress > progress = progress resource . get progress ( event model ) ; optional < track info > track info = track info resource . get track info ( event model ) ; optional < volume > volume = volume resource . get volume ( event model ) ; started sound ( playlist . or else ( null ) , progress . or else ( null ) , track info . or else ( null ) , volume . or else ( null ) , is using java ) ; }	this method will be called to create and fire the StartMusicRequest.
protected void init ( ) { done = bool ; connection id = null ; reader thread = new thread ( ) { public void run ( ) { parse packets ( this ) ; } } ; reader thread . set name ( str + connection . connection counter value + str ) ; reader thread . set daemon ( bool ) ;	Initializes the reader in order to be used.
synchronized public void startup ( ) throws xmpp { final list < exception > errors = new linked list < exception > ( ) ; abstract connection listener connection error listener = new abstract connection listener ( ) { @ override public void connection closed on error ( exception e ) { errors . add ( e ) ; } } ; connection . add connection listener ( connection error listener ) ; reader thread . start ( ) ;	Starts the packet reader thread and returns once a connection to theserver has been established.
public void shutdown ( ) {	Shuts the packet reader down.
private void reset parser ( ) { try { inner reader = new xpp ( ) ; inner reader . set xpp ( xml pull parser factory . new instance ( ) ) ; inner reader . get xpp ( ) . set input ( connection . reader ) ; reset = bool ; } catch ( exception xppe ) { logger . log ( level . warn , str , xppe ) ; } }	Resets the parser using the latest connection's reader.
private void parse packets ( thread thread ) { try { while ( ! done ) { if ( reset ) { start stream ( ) ; logger . debug ( str ) ; reset = bool ; continue ; } element doc = inner reader . parse document ( ) . get root element ( ) ; if ( doc == null ) { connection . disconnect ( ) ; logger . debug ( str ) ; continue ; } packet packet = null ; logger . debug ( str + doc . as xml ( ) ) ; packet = parse from plugins ( doc , packet ) ; if ( packet == null ) { packet = parse from core ( doc ) ; } if ( packet != null ) { process packet ( packet ) ; } } } catch ( exception e ) { if ( ! done && ! connection . is socket closed ( ) ) { connection . notify connection error ( e ) ; if ( ! connection . is connected ( ) ) { release connection id ( ) ; } } } }	Parse top-level packets in order to process them further.
private void process packet ( packet packet ) { if ( packet == null ) { return ; }	Processes a packet after it's been fully parsed by looping through theinstalled packet collectors and listeners and letting them examine thepacket to see if they are a match with the filter.
protected final void set cli option ( option option ) { if ( option != null ) { this . cli option = option ; } if ( this . cli option . get description ( ) != null ) { this . descr = this . cli option . get description ( ) ; } else { this . cli option . set description ( this . descr ) ; } }	Sets the CLI option.
public chat create chat ( string user jid , message listener listener ) { return create chat ( user jid , null , listener ) ; }	Creates a new chat and returns it.
void internalize ( content manager impl content manager , boolean read only ) { this . content manager = content manager ; updated = bool ; newcontent = bool ; this . read only = read only ; }	Convert a new content object to an internal version.
public void reset ( map < string , object > updated map ) { if ( ! read only ) { this . content = immutable map . copy of ( updated map ) ; updated content . clear ( ) ; updated = bool ; logger . debug ( str , updated map ) ; } }	Reset the object back to its last saved state.
public void set property ( string key , object value ) { if ( read only ) { return ; } if ( value == null ) { throw new illegal argument exception ( str ) ; } object o = content . get ( key ) ; if ( ! value . equals ( o ) ) { updated content . put ( key , value ) ; updated = bool ; } else if ( updated content . contains key ( key ) && ! value . equals ( updated content . get ( key ) ) ) { updated content . put ( key , value ) ; updated = bool ; } }	set a property, creating if it does not exist, overwriting if it does.
public void add filter ( packet filter filter ) { if ( filter == null ) { throw new illegal argument exception ( str ) ; }	Adds a filter to the filter list for the OR operation.
public void process request ( http servlet request request ) throws io , file upload exception , storage client exception , access denied exception { boolean debug = logger . is debug enabled ( ) ; if ( servlet file upload . is multipart content ( request ) ) { if ( debug ) { logger . debug ( str ) ; } feedback . add ( str ) ; servlet file upload upload = new servlet file upload ( ) ; file item iterator iterator = upload . get item iterator ( request ) ; while ( iterator . has next ( ) ) { file item stream item = iterator . next ( ) ; if ( debug ) { logger . debug ( str , item ) ; } string name = item . get field name ( ) ; input stream stream = item . open stream ( ) ; if ( item . is form field ( ) ) { parameter type pt = parameter type . type of request parameter ( name ) ; string property name = request utils . property name ( pt . get property name ( name ) ) ; request utils . accumulate ( stores . get ( pt ) , property name , request utils . to value ( name , streams . as string ( stream ) ) ) ; feedback . add ( pt . feedback ( property name ) ) ; } else { if ( stream processor != null ) { feedback . add all ( stream processor . process stream ( name , storage client utils . get object name ( item . get name ( ) ) , item . get content type ( ) , stream , this ) ) ; } } } if ( debug ) { logger . debug ( str ) ; } } else { if ( debug ) { logger . debug ( str ) ; }	Process the request in a stream.
public void reset properties ( ) { for ( entry < parameter type , map < string , object > > e : stores . entry set ( ) ) { e . get value ( ) . clear ( ) ; } }	Clear the current set of properties to add and remove.
protected void init ( ) { this . writer = connection . writer ; done = bool ; writer thread = new thread ( ) { public void run ( ) { write packets ( this ) ; } } ; writer thread . set name ( str + connection . connection counter value + str ) ; writer thread . set daemon ( bool ) ; }	Initializes the writer in order to be used.
public void send packet ( packet packet ) { if ( ! done ) {	Sends the specified packet to the server.
private packet next packet ( ) { packet packet = null ;	Returns the next available packet from the queue for writing.
void open stream ( ) throws io { string builder stream = new string builder ( ) ; stream . append ( str ) ; stream . append ( str ) . append ( connection . get service name ( ) ) . append ( str ) ; stream . append ( str ) ; stream . append ( str ) ; stream . append ( str ) ; writer . write ( stream . to string ( ) ) ; writer . flush ( ) ; }	Sends to the server a new stream element.
@ override public list < string > get all informations ( ) { array list < string > strings = new array list < > ( descriptors ) ; strings . add ( type ) ; return strings ; }	returns a List containing all the Descriptors and the type.
@ override public boolean contains descriptor ( string descriptor ) { return descriptors . contains ( descriptor ) || type . equals ( descriptor ) ; }	returns whether the event contains the specific descriptor.this method also checks whether it matches the type.
@ suppress warnings ( str ) public event add event life cycle listener ( event life cycle event life cycle , consumer < event life cycle > cycle callback ) { life cycle listeners . compute ( event life cycle , ( unused , list ) -> { if ( list == null ) list = new array list < > ( ) ; list . add ( cycle callback ) ; return list ; } ) ; return this ; }	adds the Consumer to the specified EventLifeCycle.In its current implementation the invocation of the Callback method is parallel, but the notificaton of the listners not.
public void shutdown ( ) { if ( executor != null ) { executor . shutdown now ( ) ; executor = null ; } if ( timer != null ) { timer . cancel ( ) ; timer = null ; } }	Shuts down the task engine service.
private boolean valid entry ( final entry < k , v > entry ) { if ( auto commit || entry == null ) return ( entry != null ) ; string id = get current thread id ( ) ; return ! ( ( entry . is ( entry . deleted , id ) ) || ( entry . is ( entry . added , null ) && entry . is ( entry . no change , id ) ) ) ; }	Checks that this entry is valid for the current thread.
@ suppress warnings ( str ) static < t > t mask null ( t key ) { return ( key == null ? ( t ) null key : key ) ; }	Returns internal representation for key.
static boolean eq ( object x , object y ) { return x == y || x . equals ( y ) ; }	Check for equality of non-null reference x and possibly-null y.
entry < k , v > get entry ( object key ) { object k = mask null ( key ) ; int hash = hash ( k ) ; int i = index for ( hash , table . length ) ; entry < k , v > e = table [ i ] ; while ( e != null && ! ( e . hash == hash && valid entry ( e ) && eq ( k , e . key ) ) ) e = e . next ; return e ; }	Returns the entry associated with the specified key in theHashMap.
@ suppress warnings ( str ) void resize ( int new capacity ) { entry < k , v > [ ] old table = table ; int old capacity = old table . length ; if ( old capacity == maximum capacity ) { threshold = integer . max value ; return ; } entry < k , v > [ ] new table = new entry [ new capacity ] ; transfer ( new table ) ; table = new table ; threshold = ( int ) ( new capacity * load factor ) ; }	Rehashes the contents of this map into a new array with alarger capacity.
@ override public void put all ( map < ? extends k , ? extends v > m ) { int num keys to be added = m . size ( ) ; if ( num keys to be added == num ) return ; if ( num keys to be added > threshold ) { int target capacity = ( int ) ( num keys to be added / load factor + num ) ; if ( target capacity > maximum capacity ) target capacity = maximum capacity ; int new capacity = table . length ; while ( new capacity < target capacity ) new capacity <<= num ; if ( new capacity > table . length ) resize ( new capacity ) ; } for ( iterator < ? extends map . entry < ? extends k , ? extends v > > i = m . entry set ( ) . iterator ( ) ; i . has next ( ) ; ) { map . entry < ? extends k , ? extends v > e = i . next ( ) ; put ( e . get key ( ) , e . get value ( ) ) ; } }	Copies all of the mappings from the specified map to this mapThese mappings will replace any mappings thatthis map had for any of the keys currently in the specified map.
@ override public v remove ( object key ) throws concurrent modification exception { entry < k , v > e = remove entry for key ( key ) ; return ( e == null ? null : e . value ) ; }	Removes the mapping for this key from this map if present.
entry < k , v > remove entry for key ( object key ) throws concurrent modification exception { object k = mask null ( key ) ; int hash = hash ( k ) ; int i = index for ( hash , table . length ) ; entry < k , v > prev = table [ i ] ; entry < k , v > e = prev ; while ( e != null ) { entry < k , v > next = e . next ; if ( e . hash == hash && valid entry ( e ) && eq ( k , e . key ) ) { if ( e . is ( entry . deleted , null ) && ! e . is ( entry . deleted , get current thread id ( ) ) ) throw new concurrent modification exception ( ) ; if ( auto commit ) { mod count ++ ; size -- ; if ( prev == e ) table [ i ] = next ; else prev . next = next ; return e ; } else e . set status ( entry . deleted , get current thread id ( ) ) ; } prev = e ; e = next ; } return e ; }	Removes and returns the entry associated with the specified keyin the HashMap.
@ suppress warnings ( str ) entry < k , v > remove mapping ( object o ) { if ( ! ( o instanceof map . entry ) ) return null ; map . entry < k , v > entry = ( map . entry < k , v > ) o ; object k = mask null ( entry . get key ( ) ) ; int hash = hash ( k ) ; int i = index for ( hash , table . length ) ; entry < k , v > prev = table [ i ] ; entry < k , v > e = prev ; while ( e != null ) { entry < k , v > next = e . next ; if ( e . hash == hash && valid entry ( e ) && e . equals ( entry ) ) { if ( auto commit ) { mod count ++ ; size -- ; if ( prev == e ) table [ i ] = next ; else prev . next = next ; } else e . set status ( entry . deleted , get current thread id ( ) ) ; return e ; } prev = e ; e = next ; } return e ; }	Special version of remove for EntrySet.
void add entry ( int hash , k key , v value , int bucket index ) { table [ bucket index ] = new entry < k , v > ( hash , key , value , table [ bucket index ] ) ; if ( ! auto commit ) table [ bucket index ] . set status ( entry . added , get current thread id ( ) ) ; if ( size ++ >= threshold ) resize ( num * table . length ) ; }	Add a new entry with the specified key, value and hash code tothe specified bucket.
private static < k , v > immutable map < k , v > create delegate ( final map < k , v > base , final set < ? extends k > keys , final function < k , v > augmentation ) { final immutable map . builder < k , v > builder = immutable map . builder ( ) ; builder . put all ( base ) ; keys . stream ( ) . filter ( key -> ! base . contains key ( key ) ) . for each ( key -> builder . put ( key , augmentation . apply ( key ) ) ) ; return builder . build ( ) ; }	Creates map delegate.
private static string xml attrib encode binary ( string value ) { string builder s = new string builder ( ) ; char buf [ ] = value . to char array ( ) ; for ( char c : buf ) { switch ( c ) { case str : s . append ( str ) ; break ; case str : s . append ( str ) ; break ; case str : s . append ( str ) ; break ; case str : s . append ( str ) ; break ; case str : s . append ( str ) ; break ; default : if ( c <= num || ( num <= c && c <= num ) ) {	Encodes a string for use in an XML attribute by escaping characters witha special meaning.
public static string encode hex ( byte [ ] bytes ) { string builder hex = new string builder ( bytes . length * num ) ; for ( byte a byte : bytes ) { if ( ( ( int ) a byte & num ) < num ) { hex . append ( str ) ; } hex . append ( integer . to string ( ( int ) a byte & num , num ) ) ; } return hex . to string ( ) ; }	Encodes an array of bytes as String representation of hexadecimal.
public static string encode base64 ( string data ) { byte [ ] bytes = null ; try { bytes = data . get bytes ( str ) ; } catch ( unsupported encoding exception uee ) { throw new illegal state exception ( uee ) ; } return encode base64 ( bytes ) ; }	Encodes a String as a base64 String.
public static string encode base64 ( byte [ ] data , int offset , int len , boolean line breaks ) { return base64 . encode bytes ( data , offset , len , ( line breaks ? base64 . no options : base64 . dont break lines ) ) ; }	Encodes a byte array into a bse64 String.
@ override public integer iterate ( final filterable collection < ? extends t > c ) { check used ( ) ;	Overridden to just get the count, and nothing else.
public void set track selector controller ( consumer < track info > controller ) { if ( controller == null ) return ; select track = controller ; capabilities . set able to select track ( bool ) ; }	adds the ability to select tracks.
public void set jump progress controller ( consumer < progress > controller ) { if ( controller == null ) return ; jump progress = controller ; capabilities . set able to jump ( bool ) ; }	adds the ability to jump to a specified position of the current track.
public void set playback changeable controller ( consumer < string > controller ) { if ( controller == null ) return ; change playback = controller ; capabilities . set playback changeable ( bool ) ; }	adds the ability to change the playback.
public void set volume changeable controller ( consumer < volume > controller ) { if ( controller == null ) return ; change volume = controller ; capabilities . set change volume ( bool ) ; }	adds the ability to change the volume from outside the player.
public void broadcast available playlists ( supplier < list < string > > available playlist , function < string , playlist > playlist for name function ) { if ( available playlist == null || playlist for name function == null ) return ; this . available playlist = available playlist ; this . playlist for name function = playlist for name function ; capabilities . set broadcasting ( bool ) ; }	adds the ability to return the available playlists on request.
public void handle command resources ( event model event model ) { list < resource model < string > > resource models = event model . get list resource container ( ) . provide resource ( command resource . id ) . stream ( ) . filter ( resource model -> resource model . get resource ( ) instanceof string ) . map ( resource model -> { try {	this method gets called when a new Command was found. It automatically fires the update Event or an error.
private void handle volume ( event model event model , resource model < string > resource model ) { optional < volume > volume resource = volume resource . get volume ( event model ) ; if ( ! volume resource . is present ( ) ) { music helper . player error ( player error . error illegal + str + resource model . get resource ( ) + str , resource model . get provider ( ) ) ; } change volume . accept ( volume resource . get ( ) ) ; }	handles the volume-command.
private void handle jump ( event model event model , resource model < string > resource model ) { optional < progress > progress = progress resource . get progress ( event model ) ; if ( ! progress . is present ( ) ) { music helper . player error ( player error . error illegal + str + resource model . get resource ( ) + str , resource model . get provider ( ) ) ; } jump progress . accept ( progress . get ( ) ) ; }	handles the jump-command.
private void handle select track ( event model event model , resource model < string > resource model ) { optional < track info > track info = track info resource . get track info ( event model ) ; if ( ! track info . is present ( ) ) { music helper . player error ( player error . error illegal + str + resource model . get resource ( ) + str , resource model . get provider ( ) ) ; } select track . accept ( track info . get ( ) ) ; }	handles the select Track command.
@ suppress warnings ( str ) private < v > cache < v > get thread cache ( string name ) { map < string , cache < ? > > thread cache map = thread cache map holder . get ( ) ; cache < v > thread cache = ( cache < v > ) thread cache map . get ( name ) ; if ( thread cache == null ) { thread cache = new map cache impl < v > ( ) ; thread cache map . put ( name , thread cache ) ; } return thread cache ; }	Generate a cache bound to the thread.
@ suppress warnings ( str ) private < v > cache < v > get request cache ( string name ) { map < string , cache < ? > > request cache map = request cache map holder . get ( ) ; cache < v > request cache = ( cache < v > ) request cache map . get ( name ) ; if ( request cache == null ) { request cache = new map cache impl < v > ( ) ; request cache map . put ( name , request cache ) ; } return request cache ; }	Generate a cache bound to the request.
public static string get alt field ( string field , string stream id ) { if ( stream id == null ) { return field ; } return field + str + stream id ; }	Get the name of an alternative field for an alternative stream.
public static string shard path ( string id ) { string hash = insecure hash ( id ) ; return hash . substring ( num , num ) + str + hash . substring ( num , num ) + str + hash . substring ( num , num ) + str + id ; }	For instance the SparsePrincipal uses it.
public static session adapt to session ( object source ) { if ( source instanceof session adaptable ) { return ( ( session adaptable ) source ) . get session ( ) ; } else {	Adapt an object to a session.
private static object safe method ( object target , string method name , object [ ] args , @ suppress warnings ( str ) class [ ] args types ) { if ( target != null ) { try { method m = target . get class ( ) . get method ( method name , args types ) ; if ( ! m . is accessible ( ) ) { m . set accessible ( bool ) ; } return m . invoke ( target , args ) ; } catch ( throwable e ) { logger . info ( str + method name + str + target , e ) ; } } return null ; }	Make the method on the target object accessible and then invoke it.
public static void delete tree ( content manager content manager , string path ) throws access denied exception , storage client exception { content content = content manager . get ( path ) ; if ( content != null ) { for ( string child path : content . list child paths ( ) ) { delete tree ( content manager , child path ) ; } } content manager . delete ( path ) ; }	Delete an entire tree starting from the deepest part of the tree andworking back up.
@ override public void update one ( e object , string ... properties ) { if ( object . get id ( ) == null ) { throw new runtime exception ( str ) ; } if ( properties == null || properties . length == num ) { entity manager . merge ( object ) ; return ; }	Only update specified properties of the Object.
public void set ping interval ( long new ping interval ) { if ( ping interval == new ping interval ) return ;	Sets the ping interval.
private synchronized void schedule ping server task ( ) { enable executor service ( ) ; stop ping server task ( ) ; if ( ping interval > num ) { periodic ping task = periodic ping executor service . schedule ( new runnable ( ) { @ override public void run ( ) { ping ping = new ping ( ) ; packet filter response filter = new id ( ping . get id ( ) ) ; connection connection = weak ref connection . get ( ) ; final packet collector response = ping failed listeners . is empty ( ) ? null : connection . create packet collector ( response filter ) ; connection . send packet ( ping ) ; if ( response != null ) {	Cancels any existing periodic ping task if there is one and schedules anew ping task if pingInterval is greater then zero.This is designed so only one executor is used for scheduling all pings onall connections.
public s add all options ( application option < ? > [ ] options ) { if ( options != null ) { for ( application option < ? > option : options ) { this . add option ( option ) ; } } return this ; }	Adds all given option ignoring null elements.
public boolean has option ( option option ) { if ( option == null ) { return bool ; } if ( this . used options . contains ( option . get opt ( ) ) ) { return bool ; } if ( this . used options . contains ( option . get long opt ( ) ) ) { return bool ; } return bool ; }	Tests if an option is already added to the parser.
public parse exception parse ( string [ ] args ) { parse exception ret = null ; command line parser parser = new default parser ( ) ; try { this . cmd line = parser . parse ( this . options , args ) ; } catch ( parse exception pe ) { ret = pe ; } return ret ; }	Parses command line arguments and fills set options.
public void usage ( string app name ) { help formatter formatter = new help formatter ( ) ; formatter . print help ( app name , null , this . options , null , bool ) ; }	Prints a usage screen based on set options.
static int do parse ( string [ ] args , s cli , string app name ) { exception err = cli . parse ( args ) ; if ( err != null ) { system . err . println ( app name + str + err . get message ( ) ) ; return - num ; } return num ; }	Parses command line arguments for a given CLI parser.
private void init connection ( ) throws xmpp { boolean is first initialization = packet reader == null || packet writer == null ; compression handler = null ; server ackd compression = bool ;	Initializes the connection by creating a packet reader and writer andopening a XMPP stream to the server.
void start tls ( boolean required ) { if ( required && config . get security mode ( ) == connection configuration . security mode . disabled ) { notify connection error ( new illegal state exception ( str ) ) ; return ; } if ( config . get security mode ( ) == connection configuration . security mode . disabled ) {	Notification message saying that the server supports TLS so confirm theserver that we want to secure the connection.
private xmpp maybe get compression handler ( ) { if ( compression methods != null ) { for ( xmpp handler : compression handlers ) { if ( ! handler . is supported ( ) ) continue ; string method = handler . get compression method ( ) ; if ( compression methods . contains ( method ) ) return handler ; } } return null ; }	Returns the compression handler that can be used for one compressionmethods offered by the server.
private void request stream compression ( string method ) { try { writer . write ( str ) ; writer . write ( str + method + str ) ; writer . flush ( ) ; } catch ( io e ) { notify connection error ( e ) ; } }	Request the server that we want to start using stream compression.
void start stream compression ( ) throws exception { server ackd compression = bool ;	Start using stream compression since the server has acknowledged streamcompression.
synchronized void notify connection error ( exception e ) {	Sends out a notification that there was an error with the connection andcloses the connection. Also prints the stack trace of the given exception.
protected void notify reconnection ( ) {	Sends a notification indicating that the connection was reconnectedsuccessfully.
public static void register sasl ( string name , class < ? extends sasl > m class ) { implemented mechanisms . put ( name , m class ) ; }	Registers a new SASL mechanism.
public static list < class < ? extends sasl > > get register sasl ( ) { list < class < ? extends sasl > > answer = new array list < class < ? extends sasl > > ( ) ; for ( string mechanisms preference : mechanisms preferences ) { answer . add ( implemented mechanisms . get ( mechanisms preference ) ) ; } return answer ; }	Returns the registerd SASLMechanism classes sorted by the level ofpreference.
@ override public hash map < integer , list < identification > > get output plugin behaviour ( list < identification > identifications ) { if ( output plugin behaviour == null ) return new hash map < > ( ) ; return output plugin behaviour . apply ( identifications ) ; }	generates the data to control the Event.
static void info ( string message , throwable t ) { log ( system . out , str , message , t ) ; }	emit an informational message to standard out.
static void error ( string message , throwable t ) { log ( system . err , str , message , t ) ; }	emit an error message to standard err.
private static void log ( print stream out , string prefix , string message , throwable t ) { final string builder line prefix builder = new string builder ( ) ; synchronized ( fmt ) { line prefix builder . append ( fmt . format ( new date ( ) ) ) ; } line prefix builder . append ( prefix ) ; line prefix builder . append ( str ) ; line prefix builder . append ( thread . current thread ( ) . get name ( ) ) ; line prefix builder . append ( str ) ; final string line prefix = line prefix builder . to string ( ) ; out . print ( line prefix ) ; out . println ( message ) ; if ( t != null ) { t . print stack trace ( new print stream ( out ) { @ override public void println ( string x ) { synchronized ( this ) { print ( line prefix ) ; super . println ( x ) ; flush ( ) ; } } } ) ; } }	the throwable if not-null is also prefixed line by line with the prefix.
public static optional < start event > create start event ( identification source ) { try { start event start request = new start event ( source ) ; return optional . of ( start request ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } }	creates a new StartEvent.Assumes the Output is using the java-sound output.
public static optional < start event > create start event ( identification source , boolean is using java ) { try { start event start event ; if ( is using java ) { start event = new start event ( source ) ; } else { start event = new start event ( source , is using non java output ) ; } return optional . of ( start event ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } }	creates a new StartEvent.
private void notify listeners ( string str ) { writer listener [ ] writer listeners = null ; synchronized ( listeners ) { writer listeners = new writer listener [ listeners . size ( ) ] ; listeners . to array ( writer listeners ) ; } for ( int i = num ; i < writer listeners . length ; i ++ ) { writer listeners [ i ] . write ( str ) ; } }	Notify that a new string has been written.
@ override public boolean provides resource ( resource model resource ) { return resources . stream ( ) . map ( resource model :: get resource id ) . any match ( resource s -> resource s . equals ( resource . get resource id ( ) ) ) ; }	checks whether it can provide the resource.
@ override public boolean contains resources from source ( string source id ) { return resources . stream ( ) . map ( resource model :: get resource id ) . any match ( source -> source . equals ( source id ) ) ; }	checks whether there are any resources registered from the source.
@ override public boolean provides resource ( list < string > resources i ) { return resources . stream ( ) . map ( resource model :: get resource id ) . any match ( resources i :: contains ) ; }	checks whether the ResourceContainer can provide at least ONE resource.
@ override public list < resource model > provide resource ( string [ ] resource i ) { return resources . stream ( ) . filter ( resource -> arrays . stream ( resource i ) . any match ( resource id -> resource id . equals ( resource . get resource id ( ) ) ) ) . collect ( collectors . to list ( ) ) ; }	returns all EXISTING resources for the ID.If there are no resources for the ID the ID will get skipped.
protected map < string , object > get cached ( string key space , string column family , string key ) throws storage client exception { map < string , object > m = null ; string cache key = get cache key ( key space , column family , key ) ; cache holder cache holder = get from cache internal ( cache key ) ; if ( cache holder != null ) { m = cache holder . get ( ) ; if ( m != null ) { logger . debug ( str , new object [ ] { cache key , cache holder , m } ) ; } } if ( m == null ) { m = client . get ( key space , column family , key ) ; if ( m != null ) { logger . debug ( str , cache key , m ) ; } put to cache internal ( cache key , new cache holder ( m ) , bool ) ; } return m ; }	Try to retrieve an object from the cache.
private string get cache key ( string key space , string column family , string key ) throws storage client exception { if ( client instanceof row hasher ) { return ( ( row hasher ) client ) . row hash ( key space , column family , key ) ; } return key space + str + column family + str + key ; }	Combine the parameters into a key suitable for storage and lookup in thecache.
protected void remove cached ( string key space , string column family , string key ) throws storage client exception { if ( shared cache != null ) {	Remove this object from the cache.
protected void put cached ( string key space , string column family , string key , map < string , object > encoded properties , boolean probably new ) throws storage client exception { string cache key = null ; if ( shared cache != null ) { cache key = get cache key ( key space , column family , key ) ; } if ( shared cache != null && ! probably new ) { cache holder ch = get from cache internal ( cache key ) ; if ( ch != null && ch . is locked ( this . manager id ) ) { logger . debug ( str , ch ) ; return ;	Put an object in the cache.
public map < uri , string > get cf locations ( ) { if ( this . needs re run == bool ) { this . location map . clear ( ) ; string path sep = system . get property ( str ) ; string classpath = system . get property ( str ) ; string tokenizer st = new string tokenizer ( classpath , path sep ) ; file file = null ; while ( st . has more tokens ( ) ) { string path = st . next token ( ) ; file = new file ( path ) ; this . include ( file ) ; } } this . needs re run = bool ; return this . location map ; }	Runs the locator and collects all locations using the filters if set.The method can be called multiple times and will only result in a new map if any of the filters have been changed.If no filter has been changed, the current map will be returned.
protected final void include ( string name , file file ) { if ( ! file . exists ( ) ) { return ; } if ( ! file . is directory ( ) ) { if ( this . jar filter . size ( ) > num ) { boolean ok = bool ; for ( string s : this . jar filter ) { if ( file . get name ( ) . starts with ( s ) ) { ok = bool ; } } if ( ok == bool ) { return ; } } this . include jar ( file ) ; return ; } if ( name == null ) { name = str ; } else { name += str ; } file [ ] dirs = file . list files ( cf . directories only ) ; for ( int i = num ; i < dirs . length ; i ++ ) { try { this . location map . put ( new uri ( str + dirs [ i ] . get canonical path ( ) ) , name + dirs [ i ] . get name ( ) ) ; } catch ( io ignore ) { return ; } catch ( uri ignore ) { return ; } this . include ( name + dirs [ i ] . get name ( ) , dirs [ i ] ) ; } }	Include a name and file.
private void include jar ( file file ) { if ( file . is directory ( ) ) { return ; } url jar url = null ; jar file jar = null ; try { jar url = new url ( str + new url ( str + file . get canonical path ( ) ) . to external form ( ) + str ) ; url conn = ( url ) jar url . open connection ( ) ; jar = conn . get jar file ( ) ; } catch ( url ignore ) { return ; } catch ( io ignore ) { return ; } if ( jar == null ) { return ; } try { this . location map . put ( jar url . to uri ( ) , str ) ; } catch ( uri ignore ) { } for ( enumeration < jar entry > e = jar . entries ( ) ; e . has more elements ( ) ; ) { jar entry entry = e . next element ( ) ; if ( this . pkg filter != null && entry . get name ( ) . starts with ( this . pkg filter ) ) { continue ; } if ( entry . is directory ( ) ) { if ( entry . get name ( ) . to upper case ( locale . english ) . equals ( str ) ) { continue ; } try { this . location map . put ( new uri ( jar url . to external form ( ) + entry . get name ( ) ) , cf . get pkg name ( entry ) ) ; } catch ( uri ignore ) { continue ; } } } }	Include from a jar file.
public static void add sasl mech ( string mech ) { initialize ( ) ; if ( ! default mechs . contains ( mech ) ) { default mechs . add ( mech ) ; } }	Add a SASL mechanism to the list to be used.
public static void add sasl mechs ( collection < string > mechs ) { initialize ( ) ; for ( string mech : mechs ) { add sasl mech ( mech ) ; } }	Add a Collection of SASL mechanisms to the list to be used.
private void create debug ( ) {	Creates the listeners that will print in the console when new activity isdetected.
protected void activate ( map < string , object > properties ) throws exception { config properties = properties ; string [ ] safe post processor names = ( string [ ] ) config properties . get ( safe postprocessors ) ; if ( safe post processor names == null ) { safe open processors . add ( str ) ; safe open processors . add ( str ) ; } else { for ( string pp : safe post processor names ) { safe open processors . add ( pp ) ; } }	Create resources used by this component.
private void register standard events ( ) { common events . descriptors . stop listener ( this ) . if present ( this :: register event listener ) ; common events . presence . general leaving listener ( this ) . if present ( this :: register event listener ) ; common events . presence . general listener ( this ) . if present ( this :: register event listener ) ; common events . presence . leaving listener ( this ) . if present ( this :: register event listener ) ; common events . presence . presence listener ( this ) . if present ( this :: register event listener ) ; common events . presence . strict leaving listener ( this ) . if present ( this :: register event listener ) ; common events . presence . strict listener ( this ) . if present ( this :: register event listener ) ; common events . response . full response listener ( this ) . if present ( this :: register event listener ) ; common events . response . major response listener ( this ) . if present ( this :: register event listener ) ; common events . response . minor response listener ( this ) . if present ( this :: register event listener ) ; common events . type . notification listener ( this ) . if present ( this :: register event listener ) ; common events . type . response listener ( this ) . if present ( this :: register event listener ) ; }	registers the standard-events.
public void register event listener ( event listener event listener ) { register event id ( event listener . get description ( ) , event listener . get descriptor id ( ) , event listener . get descriptor ( ) ) ; }	Registers or adds an event to the local_events.properties file with the informations found in the EventListener.
public void register event id ( string description , string key , string value ) { buffered writer buffered writer ; file output stream out = null ; try { out = new file output stream ( event properties path , bool ) ; buffered writer = new buffered writer ( new output stream writer ( out ) ) ; do with lock ( out . get channel ( ) , lock -> { unlocked reload file ( ) ; if ( get event id ( key ) != null ) { return ; } try { buffered writer . write ( str + key + str + description + str + key + str + value ) ; buffered writer . flush ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } ) ; } catch ( file not found exception e ) { error ( str , e ) ; } finally { try { if ( out != null ) { out . close ( ) ; } } catch ( io e ) { error ( str , e ) ; } } }	Registers or adds an event to the local_events.properties file.
private void do with lock ( file channel channel , consumer < file lock > consumer ) { file lock lock = null ; try { while ( lock == null ) { try { lock = channel . try lock ( ) ; } catch ( overlapping file lock exception e ) { thread . sleep ( num ) ; } } consumer . accept ( lock ) ; } catch ( io | interrupted exception e ) { error ( str , e ) ; } finally { try { if ( lock != null ) { lock . release ( ) ; } } catch ( io e ) { error ( str , e ) ; } } }	executes with a lock.
@ override public boolean can run ( event model event ) {	Checks if the outputExtension can execute with the current event.
public static dse session new dse session ( dse cluster cluster , string keyspace ) { return cluster . connect ( string utils . is blank ( keyspace ) ? null : keyspace ) ; }	Create a new session for a DSE cluster, initializes it and sets the keyspaceto the provided one.
public static optional < player error > create music player error ( identification source , string error ) { if ( error == null || error . is empty ( ) ) return optional . empty ( ) ; try { player error player error = new player error ( source ) ; player error . add resource ( new music error resource ( source , error ) ) ; return optional . of ( player error ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } }	creates a new MusicPlayerError.
public void start playing ( track info track info ) { optional < identification > own identification = m . get instance ( ) . get identification ( this ) ; optional < identification > player identification = m . get instance ( ) . get identification ( player ) ; if ( ! own identification . is present ( ) || ! player identification . is present ( ) ) { error ( str ) ; return ; } start music request . create start music request ( own identification . get ( ) , player identification . get ( ) , track info , player . is using java ) . if present ( event -> fire ( event , num ) ) ; }	starts the playing command.
public void stop playing ( ) { optional < identification > own identification = m . get instance ( ) . get identification ( this ) ; optional < identification > player identification = m . get instance ( ) . get identification ( player ) ; if ( ! own identification . is present ( ) || ! player identification . is present ( ) ) { error ( str ) ; return ; } stop music . create stop music ( own identification . get ( ) , player identification . get ( ) ) . if present ( event -> fire ( event , num ) ) ; }	stops the playing of the music.
public void command ( string command , playlist playlist , progress progress , track info track info , volume volume ) { optional < identification > own identification = m . get instance ( ) . get identification ( this ) ; optional < identification > player identification = m . get instance ( ) . get identification ( player ) ; if ( ! own identification . is present ( ) || ! player identification . is present ( ) ) { error ( str ) ; return ; } optional < player command > player command = player command . create player command ( own identification . get ( ) , player identification . get ( ) , command , player . get capabilities ( ) , get context ( ) ) ; if ( playlist != null ) { player command . get ( ) . add resource ( new playlist resource ( own identification . get ( ) , playlist ) ) ; } if ( progress != null ) { player command . get ( ) . add resource ( new progress resource ( own identification . get ( ) , progress ) ) ; } if ( track info != null ) { player command . get ( ) . add resource ( new track info resource ( own identification . get ( ) , track info ) ) ; } if ( volume != null ) { player command . get ( ) . add resource ( new volume resource ( own identification . get ( ) , volume ) ) ; } fire ( player command . get ( ) , num ) ; }	commands the player to fulfill the command.
public static broadcaster playlist create playlist request ( identification provider , string playlist name ) { hash map < string , object > hash map = new hash map < > ( ) ; hash map . put ( resource id , playlist name ) ; return new broadcaster playlist ( provider , hash map ) ; }	creates the Playlist-Request.
public static broadcaster playlist create playlist answer ( identification provider , playlist playlist ) { return new broadcaster playlist ( provider , playlist . export ( ) ) ; }	creates the Playlist-Answer.
public url builder append ( boolean encode , string ... post fix ) { for ( string part : post fix ) { if ( string utils . is not blank ( part ) ) { if ( url . char at ( url . length ( ) - num ) != str && ! part . starts with ( str ) ) { url . append ( str ) ; } if ( encode ) { try { url . append ( url . encode ( part , str ) ) ; } catch ( unsupported encoding exception e ) { throw new illegal state exception ( e ) ; } } else { url . append ( part ) ; } } } return this ; }	Appends one or more postfixes and separates them by slashes.
public url builder query param ( string name , boolean value ) { if ( value != null ) { return query param ( name , value . to string ( ) ) ; } else { return null ; } }	Create a query parameter with a boolean value.
public url builder query param ( string name , number value ) { if ( value != null ) { return query param ( name , value . to string ( ) ) ; } else { return null ; } }	Create a query parameter with a number value.
public url builder query param ( string name , string value ) { return query param ( name , value , bool ) ; }	Create a query parameter with a String value.
public url builder query param ( string name , string value , boolean encode ) { if ( string utils . is not empty ( value ) ) { if ( encode ) { try { value = url . encode ( value , str ) ; } catch ( unsupported encoding exception e ) { throw new illegal state exception ( e ) ; } } params . add ( new entry impl ( name , value ) ) ; } return this ; }	Create a query parameter with a String value.
public static optional < playlist > get playlist ( event model event model ) { if ( event model . get list resource container ( ) . contains resources from source ( id ) ) { return event model . get list resource container ( ) . provide resource ( id ) . stream ( ) . find any ( ) . flat map ( playlist :: import resource ) ; } else { return optional . empty ( ) ; } }	gets the first playlist if found in the EventModel.
private void launch button action performed ( java . awt . event . action event evt ) {	This is the launch button action method.
private void is startup finished ( ) { boolean started = bool ; try { while ( ! started ) { if ( exists ( localhost url ) ) started = bool ; thread . sleep ( num * num ) ; } } catch ( interrupted exception e ) { e . print stack trace ( ) ; } if ( started ) { status label . set text ( str ) ; status label . set foreground ( color . green ) ; launch button . set enabled ( bool ) ; browser button . set enabled ( bool ) ; } }	Pings the Apache Sling server URL every 5 seconds to see if it has finished booting.Once it receives an OK status, it enables the button to launch the browser anddisables the launch Nakamura button.
public static boolean exists ( string url ) { try { url . set follow redirects ( bool ) ;	Pings the Apache Sling server URL, looking for an OK status.
private void browser button action performed ( java . awt . event . action event evt ) { try { desktop . get desktop ( ) . browse ( new url ( localhost url ) . to uri ( ) ) ; } catch ( io e ) { system . err . println ( str + e . get message ( ) ) ; } catch ( uri e ) { system . err . println ( str + e . get message ( ) ) ; } }	Performs the action when the browser button is pressed, which is launch a web browserand browse to the server URL.
protected image icon create image icon ( string path , string description ) { java . net . url img url = get class ( ) . get resource ( path ) ; if ( img url != null ) { return new image icon ( img url , description ) ; } else { system . err . println ( str + path ) ; return null ; } }	Returns an ImageIcon, or null if the path was invalid.
public static void main ( string args [ ] ) { saved args = args ; java . awt . event queue . invoke later ( new runnable ( ) { public void run ( ) { new launch nakamura ( ) . set visible ( bool ) ; } } ) ; }	The Main method which executes the program.
public int array with ( int ... values ) { if ( values . length != this . length ) throw new illegal argument exception ( str ) ; value = values . clone ( ) ; return this ; }	Replace contents with given values.
public hash map < string , object > export ( ) { hash map < string , object > data = new hash map < > ( ) ; data . put ( level descriptor , level . name ( ) ) ; data . put ( present descriptor , present ) ; data . put ( strict descriptor , strict ) ; data . put ( known descriptor , known ) ; return data ; }	exports the Presence to a HashMap.
public json get ( int index ) { if ( value instanceof json ) { json array = ( json ) value ; object result = array . get ( index ) ; return new json ( result ) ; } else if ( value instanceof json ) { return get ( string . value of ( index ) ) ; } return new json ( null ) ; }	Advance current JSON value to specified element in JSON array.Set current JSON value to null otherwise.
public json get ( string key ) { if ( value instanceof json ) { json obj = ( json ) value ; object result = obj . get ( key ) ; return new json ( result ) ; } else if ( value instanceof json ) { try { int index = integer . parse int ( key ) ; return get ( index ) ; } catch ( number format exception e ) { throw create exception ( str + key + str ) ; } } return new json ( null ) ; }	Advance current JSON value to specified value of current JSON object.Set current JSON value to null otherwise.
public integer get int ( integer default value ) { if ( value instanceof number ) { return ( ( number ) value ) . int value ( ) ; } if ( value instanceof string ) { string s = ( string ) value ; return integer . parse int ( s ) ; } if ( value == null ) { return default value ; } throw create exception ( str ) ; }	Return an integer for current JSON value, parsing string values as required.
public double get double ( double default value ) { if ( value instanceof number ) { return ( ( number ) value ) . double value ( ) ; } if ( value instanceof string ) { string s = ( string ) value ; return double . parse double ( s ) ; } if ( value == null ) { return default value ; } throw create exception ( str ) ; }	Return a double number for current JSON value, parsing string values as required.
public string get string ( string default value ) { if ( value instanceof string || value instanceof number ) { return value . to string ( ) ; } if ( value == null ) { return null ; } if ( value instanceof json ) { return ( ( json ) value ) . to json ( ) ; } if ( value instanceof json ) { return ( ( json ) value ) . to json ( ) ; } if ( value == null ) { return default value ; } throw create exception ( str ) ; }	Return string value for current JSON value.
public static optional < command resource > create command resource ( identification provider , string command , capabilities capabilities , context context ) { command resource command resource = new command resource ( provider , command , capabilities ) ; if ( ! verify command ( command ) ) { context . get logger ( ) . error ( str ) ; return optional . empty ( ) ; } if ( ! verify capabilities ( command , capabilities ) ) { context . get logger ( ) . error ( str ) ; return optional . empty ( ) ; } return optional . of ( command resource ) ; }	creates a new Resource.
public static boolean verify command ( string command ) { return command . equals ( play ) || command . equals ( pause ) || command . equals ( stop ) || command . equals ( select track ) || command . equals ( next ) || command . equals ( previous ) || command . equals ( change playback ) || command . equals ( change volume ) ; }	verifies that an command is not malformed.
public static boolean verify capabilities ( string command , capabilities capabilities ) { switch ( command ) { case play : return capabilities . has play pause control ( ) ; case pause : return capabilities . has play pause control ( ) ; case select track : return capabilities . is able to select track ( ) ; case next : return capabilities . has next previous ( ) ; case previous : return capabilities . has next previous ( ) ; case jump : return capabilities . is able to jump ( ) ; case change playback : return capabilities . is playback changeable ( ) ; case change volume : return capabilities . can change volume ( ) ; case stop : return bool ; } return bool ; }	verifies that the player is capable of handling the command.
public static boolean verify ( string command , capabilities capabilities ) { return verify command ( command ) && verify capabilities ( command , capabilities ) ; }	verifies tha the command is legal and able to be executed.
public void execute batch async ( future callback < result set > callback , statement ... statements ) throws exceed max async jobs exception { if ( ! async semaphore . try acquire ( ) ) { if ( callback == null ) { throw new exceed max async jobs exception ( max sync jobs ) ; } else { callback . on failure ( new exceed max async jobs exception ( max sync jobs ) ) ; } } else { try { result set future rsf = cql utils . execute batch async ( get session ( ) , statements ) ; if ( callback != null ) { futures . add callback ( rsf , wrap callback result set ( callback ) , async executor ) ; } } catch ( exception e ) { async semaphore . release ( ) ; logger . error ( e . get message ( ) , e ) ; } } }	Async-execute a batch statement. The default session (obtained via {.
public set < class < ? > > get subclasses ( class < ? > clazz ) { set < class < ? > > ret = new hash set < class < ? > > ( ) ; set < class < ? > > w = null ; if ( clazz != null ) { this . clear ( ) ; map < uri , string > locations = this . locator . get cf locations ( ) ; for ( entry < uri , string > entry : locations . entry set ( ) ) { try { w = search ( clazz , entry . get key ( ) , locations . get ( entry . get key ( ) ) ) ; if ( w != null && ( w . size ( ) > num ) ) { ret . add all ( w ) ; } } catch ( url ex ) { } } } return ret ; }	Returns all subclasses found for the given class.
public set < class < ? > > get subclasses ( string fqcn ) { if ( fqcn == null ) { return new hash set < class < ? > > ( ) ; } else if ( string utils . starts with ( fqcn , str ) || string utils . ends with ( fqcn , str ) ) { return new hash set < class < ? > > ( ) ; } class < ? > clazz = null ; try { clazz = class . for name ( fqcn ) ; } catch ( class not found exception ex ) { this . clear ( ) ; this . errors . add ( ex ) ; return new hash set < class < ? > > ( ) ; } return get subclasses ( clazz ) ; }	Returns all subclasses found for the given fully qualified class name.
private final set < class < ? > > search ( class < ? > clazz , uri location , string package name ) throws url { if ( clazz == null || location == null ) { return new hash set < class < ? > > ( ) ; } file directory = new file ( location . to url ( ) . get file ( ) ) ; if ( directory . exists ( ) ) { return this . search directory ( clazz , directory , location , package name ) . key set ( ) ; } else { return this . search jar ( clazz , location ) . key set ( ) ; } }	Returns all known subclasses for a given class, location and package name.
protected final map < class < ? > , uri > search directory ( class < ? > clazz , file directory , uri location , string package name ) { map < class < ? > , uri > ret = new hash map < > ( ) ; string [ ] files = directory . list ( ) ; for ( int i = num ; i < files . length ; i ++ ) { if ( files [ i ] . ends with ( str ) ) { string classname = files [ i ] . substring ( num , files [ i ] . length ( ) - num ) ; try { class < ? > c = class . for name ( package name + str + classname ) ; if ( clazz . is assignable from ( c ) && ! clazz . get name ( ) . equals ( package name + str + classname ) ) { ret . put ( c , location ) ; } } catch ( exception ex ) { errors . add ( ex ) ; } } } return ret ; }	Returns all known subclasses found in a given directory.
public list < resource > to list ( ) { list < resource > resource list = new array list < > ( ) ; resource list . add ( this ) ; return resource list ; }	creates a list with this Element in it.
public int size ( ) { int result = num ;	Returns the accumulated size of all the bottom level maps.
protected void process packet ( packet packet ) { if ( packet == null ) { return ; } if ( packet filter == null || packet filter . accept ( packet ) ) { while ( ! result queue . offer ( packet ) ) {	Processes a packet to see if it meets the criteria for this packetcollector.
public static optional < volume > get volume ( event model event model ) { if ( event model . get list resource container ( ) . contains resources from source ( id ) ) { return event model . get list resource container ( ) . provide resource ( id ) . stream ( ) . map ( resource model :: get resource ) . filter ( ob -> ob instanceof integer ) . map ( ob -> ( integer ) ob ) . find any ( ) . flat map ( volume :: create volume ) ; } else { return optional . empty ( ) ; } }	gets the first Volume if found in the EventModel.
public static iq error rsm ( iq iq , logger logger ) { string rsm message = str ; logger . error ( rsm message + str + iq ) ; return xmpp . create error response ( iq , rsm message , condition . item not found , type . cancel ) ; }	Logs the RSM page not found error and returns an IQ error response.
public static iq create error response ( final iq request , final string message , condition condition , type type ) { final iq result = request . create copy ( ) ; result . set id ( request . get id ( ) ) ; result . set from ( request . get to ( ) ) ; result . set to ( request . get from ( ) ) ; packet error e = new packet error ( condition , type ) ; if ( message != null ) { e . set text ( message ) ; } result . set error ( e ) ; return result ; }	Creates an error response for a given IQ request.
public static optional < boolean > is target ( event model event model , identifiable identifiable ) { if ( event model . get list resource container ( ) . provides resource ( collections . singleton list ( selector resource . resource id ) ) ) { return optional . of ( event model . get list resource container ( ) . provide resource ( selector resource . resource id ) . stream ( ) . map ( resource model :: get resource ) . filter ( resource -> resource instanceof identification ) . map ( object -> ( identification ) object ) . any match ( identifiable :: is owner ) ) ; } else { return optional . empty ( ) ; } }	returns true if the identifiable is the target of the EventModel.
public void set login enabled ( long from , long to , boolean day , time zone time zone ) { string enabled setting = enabled period . get enable value ( from , to , day , time zone ) ; if ( enabled setting == null ) { remove property ( login enabled period field ) ; } else { set property ( login enabled period field , enabled setting ) ; } }	Sets the login enabled time.
public static < e > set < e > decorate ( set < e > set ) { return new synchronized set < e > ( set ) ; }	Factory method to create a synchronized set.
public void set name ( string name ) {	Sets the name associated with this entry.
void update state ( string name , subscription type , ask status ) { this . name = name ; this . subscription = type ; this . ask = status ; }	Updates the state of the entry with the new values.
public collection < roster group > get groups ( ) { list < roster group > results = new array list < roster group > ( ) ;	Returns an unmodifiable collection of the roster groups that this entrybelongs to.
public static void append rsm ( element query element , rsm rsm ) { element set element = query element . add element ( str , rsm . namespace ) ; if ( rsm . get first ( ) != null ) { element first element = set element . add element ( str ) ; first element . add attribute ( str , rsm . get index ( ) . to string ( ) ) ; first element . set text ( rsm . get first ( ) ) ; } if ( rsm . get last ( ) != null ) { element last element = set element . add element ( str ) ; last element . set text ( rsm . get last ( ) ) ; } set element . add element ( str ) . set text ( string . value of ( rsm . get count ( ) ) ) ; }	Appends RSM info to query response.
public static rsm parse rsm ( element query element ) { rsm rsm = new rsm ( ) ; element set element = query element . element ( str ) ; if ( set element == null ) { return rsm ; } element after = set element . element ( str ) ; if ( after != null ) { rsm . set after ( after . get text ( ) ) ; } element before = set element . element ( str ) ; if ( before != null ) { string before text = before . get text ( ) ; rsm . set before ( before text == null ? str : before text ) ; } element index = set element . element ( str ) ; if ( index != null ) { rsm . set index ( integer . parse int ( index . get text ( ) ) ) ; } element max = set element . element ( str ) ; if ( max != null ) { rsm . set max ( integer . parse int ( max . get text ( ) ) ) ; } return rsm ; }	Parses an RSM from a query XML element.
public static optional < leaving event > create leaving event ( identification source , boolean strict , list < string > descriptors ) { try { if ( strict ) { descriptors . add ( strict descriptor ) ; } else { descriptors . add ( general descriptor ) ; } descriptors . add ( id ) ; descriptors . add ( common events . descriptors . not interrupt ) ; leaving event stop request = new leaving event ( source , descriptors ) ; return optional . of ( stop request ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } }	creates a new LeavingEvent.
public void reload ( ) { if ( ! connection . is authenticated ( ) ) { throw new illegal state exception ( str ) ; } if ( connection . is anonymous ( ) ) { throw new illegal state exception ( str ) ; } roster packet = new roster ( ) ; if ( roster store != null && connection . is roster versioning supported ( ) ) { packet . get element ( ) . element ( str ) . add attribute ( str , roster store . get roster version ( ) ) ; packet filter filter = new id ( packet . get id ( ) ) ; connection . add packet listener ( new roster result listener ( ) , filter ) ; } connection . send packet ( packet ) ; }	Reloads the entire roster from the server.
public void create entry ( string user , string name , string [ ] groups ) throws xmpp { if ( ! connection . is authenticated ( ) ) { throw new illegal state exception ( str ) ; } if ( connection . is anonymous ( ) ) { throw new illegal state exception ( str ) ; }	Creates a new roster entry and presence subscription.
public collection < roster entry > get entries ( ) { set < roster entry > all entries = new hash set < roster entry > ( ) ;	Returns an unmodifiable collection of all entries in the roster,including entries that don't belong to any groups.
public presence get presence resource ( string user with resource ) { string key = get presence map key ( user with resource ) ; string resource = string utils . parse resource ( user with resource ) ; map < string , presence > user presences = presence map . get ( key ) ; if ( user presences == null ) { presence presence = new presence ( presence . type . unavailable ) ; presence . set from ( user with resource ) ; return presence ; } else { presence presence = user presences . get ( resource ) ; if ( presence == null ) { presence = new presence ( presence . type . unavailable ) ; presence . set from ( user with resource ) ; return presence ; } else { return presence ; } } }	Returns the presence info for a particular user's resource, orunavailable presence if the user is offline or if no presence informationis available, such as when you are not subscribed to the user's presenceupdates.
private void set offline presences ( ) { presence packet unavailable ; for ( string user : presence map . key set ( ) ) { map < string , presence > resources = presence map . get ( user ) ; if ( resources != null ) { for ( string resource : resources . key set ( ) ) { packet unavailable = new presence ( presence . type . unavailable ) ; packet unavailable . set from ( user + str + resource ) ; presence packet listener . process packet ( packet unavailable ) ; } } } }	Changes the presence of available contacts offline by simulating anunavailable presence sent from the server.
private void fire roster changed event ( collection < string > added entries , collection < string > updated entries , collection < string > deleted entries ) { for ( roster listener listener : roster listeners ) { if ( ! added entries . is empty ( ) ) { listener . entries added ( added entries ) ; } if ( ! updated entries . is empty ( ) ) { listener . entries updated ( updated entries ) ; } if ( ! deleted entries . is empty ( ) ) { listener . entries deleted ( deleted entries ) ; } } }	Fires roster changed event to roster listeners indicating that thespecified collections of contacts have been added, updated or deletedfrom the roster.
public void set digest ( string connection id , string password ) { set digest ( string utils . hash ( connection id + password ) ) ; }	Sets the digest value using a connection ID and password.
@ override public optional < ? extends resource model > generate resource ( resource model resource model , optional < event model > event ) { switch ( resource model . get resource id ( ) ) { case broadcaster available playlists . resource id : return create broadcaster available playlists ( ) ; case broadcaster playlist . resource id : return create broadcaster playlist ( resource model ) ; default : return music resource generator . super . generate resource ( resource model , event ) ; } }	generates the resources.
static player request create player request ( playlist playlist , boolean permanent , identification player , capabilities capabilities , context context , identifiable identifiable ) { return new player request ( null , playlist , permanent , player , capabilities , context , identifiable ) ; }	helper method for PlaylistSelector.
@ suppress warnings ( str ) public static optional < long > get time passed ( event model event model ) { if ( event model . get list resource container ( ) . contains resources from source ( id ) ) { return event model . get list resource container ( ) . provide resource ( id ) . stream ( ) . map ( resource model :: get resource ) . filter ( ob -> ob instanceof long ) . map ( ob -> ( long ) ob ) . find any ( ) ; } else { return optional . empty ( ) ; } }	returns the time passed if available.
public void register update listener ( consumer < properties assistant > listener ) { if ( listener != null ) listeners . add ( new weak reference < > ( listener ) ) ; }	the listener will always be called, when the Properties-file changes.
public void init properties ( ) { properties path = get context ( ) . get files ( ) . get properties location ( ) + file . separator + get context ( ) . get add ons ( ) . get add on ( ) . get id ( ) + str ; this . properties file = new file ( properties path ) ; if ( ! this . properties file . exists ( ) ) try { this . properties file . create new file ( ) ; } catch ( io e ) { error ( str , e ) ; } try { buffered reader in = new buffered reader ( new input stream reader ( new file input stream ( this . properties file ) , str ) ) ; try { properties . load ( in ) ; } catch ( io e ) { error ( str , e ) ; } } catch ( file not found exception | unsupported encoding exception e ) { error ( str , e ) ; } if ( default properties path != null && new file ( default properties path ) . exists ( ) ) { @ suppress warnings ( str ) enumeration < string > keys = ( enumeration < string > ) properties . property names ( ) ; if ( ! keys . has more elements ( ) ) { try { create default property file ( default properties path ) ; } catch ( io e ) { error ( str , e ) ; } if ( new file ( default properties path ) . exists ( ) && ! write to properties file ( default properties path ) ) return ; reload properties ( ) ; } } }	Initializes properties in the addOn.
private void reload properties ( ) { properties temp = new properties ( ) ; buffered reader buffered reader = null ; try { file properties = new file ( properties path ) ; buffered reader = new buffered reader ( new input stream reader ( new file input stream ( properties ) , str ) ) ; temp . load ( buffered reader ) ; this . properties = temp ; listeners . remove if ( weak reference -> weak reference . get ( ) == null ) ; listeners . for each ( weak reference -> { consumer < properties assistant > consumer = weak reference . get ( ) ; if ( consumer != null ) consumer . accept ( this ) ; } ) ; } catch ( io e ) { error ( str + properties path , e ) ; } finally { if ( buffered reader != null ) { try { buffered reader . close ( ) ; } catch ( io e ) { error ( str , e ) ; } } } }	reloads the propertiesFile into the properties object.
public static stream error parse stream error ( element el ) throws io , xml pull parser exception { string code = null ; element cond el = ( element ) el . elements ( ) . iterator ( ) . next ( ) ; if ( cond el . get namespace ( ) . get uri ( ) . equals ( stream error . namespace ) ) { code = cond el . get name ( ) ; } string text = cond el . element text ( str ) ; return new stream error ( code , text ) ; }	Parses stream error packets.
@ suppress warnings ( str ) public static collection < string > parse mechanisms ( element mechanisms el ) throws exception { list < element > mechanisms = mechanisms el . elements ( str ) ; list < string > mechanisms str = new linked list < string > ( ) ; for ( element mechanism el : mechanisms ) { mechanisms str . add ( mechanism el . get text ( ) ) ; } return mechanisms str ; }	Parse the available SASL mechanisms reported from the server.
@ suppress warnings ( str ) public static collection < string > parse compression methods ( element compression el ) throws io , xml pull parser exception { list < element > methods els = compression el . elements ( str ) ; list < string > methods str = new linked list < string > ( ) ; for ( element method el : methods els ) { methods str . add ( method el . get text ( ) ) ; } return methods str ; }	Parse the available compression methods reported from the server.
public static packet extension parse packet extension ( string element name , string namespace , xml pull parser parser ) throws exception { default packet extension extension = new default packet extension ( element name , namespace ) ; boolean done = bool ; while ( ! done ) { int event type = parser . next ( ) ; if ( event type == xml pull parser . start tag ) { string name = parser . get name ( ) ;	Parses a packet extension sub-packet.
private static object decode ( class < ? > type , string value ) throws exception { if ( type . get name ( ) . equals ( str ) ) { return value ; } if ( type . get name ( ) . equals ( str ) ) { return boolean . value of ( value ) ; } if ( type . get name ( ) . equals ( str ) ) { return integer . value of ( value ) ; } if ( type . get name ( ) . equals ( str ) ) { return long . value of ( value ) ; } if ( type . get name ( ) . equals ( str ) ) { return float . value of ( value ) ; } if ( type . get name ( ) . equals ( str ) ) { return double . value of ( value ) ; } if ( type . get name ( ) . equals ( str ) ) { return class . for name ( value ) ; } return null ; }	Decodes a String into an object of the specified type.
public static boolean verify ( event model event model , capabilities capabilities , identifiable player , list < identifiable > activators ) { if ( ! event model . contains descriptor ( start music request . id ) ) return bool ; if ( ! capabilities . handles play request from outside ( ) ) { if ( activators . stream ( ) . none match ( identifiable -> identifiable . is owner ( event model . get source ( ) ) ) ) return bool ; } if ( ! playlist resource . get playlist ( event model ) . map ( playlist -> playlist . verify ( capabilities ) ) . or else ( bool ) ) { return bool ; } return selector resource . is target ( event model , player ) . or else ( bool ) ; }	verifies that the StartMusicRequest is correct and checks whether the you are meant to react to it.
public static optional < playback state > get playback state from resource ( resource model x ) { if ( ! x . get resource id ( ) . equals ( id ) ) return optional . empty ( ) ; object resource = x . get resource ( ) ; if ( resource instanceof string ) { string state = ( string ) resource ; try { return optional . of ( playback state . value of ( state ) ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } } else { return optional . empty ( ) ; } }	returns the PlaybackState from the resource.
public string get secret key ( string subdomain ) {	Returns the secret key for a sub-domain.
public boolean is multiple allowed ( string subdomain ) { boolean allowed = allow multiple . get ( subdomain ) ; return allowed != null && allowed ; }	Returns if we want components to be able to connect multiple times to thesame JID.
public v put ( k key , v value ) { if ( key == null ) { throw new null pointer exception ( str ) ; } if ( value == null ) { throw new null pointer exception ( str ) ; } purge before write ( ) ; return super . put ( key , value ) ; }	Puts a key-value mapping into this map.
public set < k > key set ( ) { if ( key set == null ) { key set = new reference key set < k , v > ( this ) ; } return key set ; }	Returns a set view of this map's keys.
public collection < v > values ( ) { if ( values == null ) { values = new reference values < k , v > ( this ) ; } return values ; }	Returns a collection view of this map's values.
protected void purge ( reference ref ) {	Purges the specified reference.
protected hash entry < k , v > get entry ( object key ) { if ( key == null ) { return null ; } else { return super . get entry ( key ) ; } }	Gets the entry mapped to the key specified.
protected int hash entry ( object key , object value ) { return ( key == null ? num : key . hash code ( ) ) ^ ( value == null ? num : value . hash code ( ) ) ; }	Gets the hash code for a MapEntry.
public hash entry < k , v > create entry ( hash entry < k , v > next , int hash code , k key , v value ) { return new reference entry < k , v > ( this , ( reference entry < k , v > ) next , hash code , key , value ) ; }	Creates a ReferenceEntry instead of a HashEntry.
@ override public boolean control events ( event model event model ) { if ( level . compare to ( presence indicator level . weak ) >= num ) { return present ; } else	Controls whether the fired Event should be dispatched to all the listeners. This method should execute quickly.
public void set presence ( boolean present ) { if ( this . present == present ) return ; this . present = present ; update vague ( ) ; if ( present ) { fire presence ( bool ) ; } else { fire leaving ( ) ; } }	sets the presence.
private void update vague ( ) { generate resource ( presence resource . id ) . or else ( completable future . completed future ( new array list < > ( ) ) ) . then accept ( list -> most vague . set ( list . stream ( ) . map ( presence :: import presence ) . filter ( optional :: is present ) . map ( optional :: get ) . map ( presence :: get level ) . none match ( level -> level . compare to ( get level ( ) ) > num ) ) ) ; }	updates the boolean whether it is the mode vague.
void deliver ( message message ) {	Delivers a message directly to this chat, which will add the message tothe collector and deliver it to all listeners registered with the Chat.This is used by the Connection class to deliver messages without a threadID.
protected final st generate script ( string clazz , hash map < string , boolean > target map ) { st ret = this . stg . get instance of ( str ) ; ret . add ( str , target map ) ; ret . add ( str , this . application dir ) ; ret . add ( str , this . configuration . get ( prop run script name ) ) ; ret . add ( str , clazz ) ; return ret ; }	Generates a script.
protected final int init output dir ( ) { string parent = system . get property ( str ) ; string target = parent + file . separator + this . target ; file target dir = new file ( target ) ; file parent dir = target dir . get parent file ( ) ; if ( target dir . exists ( ) ) {	Tests and if necessary creates an output directory.The root path is the current directory as given by the system property "user.dir".The created output directory has the name of the specified target for the generator.The method fails if the output directory cannot be created or if it exists and is write protected.
protected final properties load properties ( string filename ) { properties ret = new properties ( ) ; url url = null ; file f = new file ( filename . to string ( ) ) ; if ( f . exists ( ) ) { try { url = f . to uri ( ) . to url ( ) ; } catch ( exception ignore ) { } } else { class loader loader = thread . current thread ( ) . get context class loader ( ) ; url = loader . get resource ( filename ) ; if ( url == null ) { loader = gen run scripts . class . get class loader ( ) ; url = loader . get resource ( filename ) ; } } try { ret . load ( url . open stream ( ) ) ; } catch ( io e ) { system . err . println ( this . get app name ( ) + str + filename + str + e + str ) ; } catch ( exception e ) { system . err . println ( this . get app name ( ) + str + filename + str + e + str ) ; } return ret ; }	Loads properties from a file.
protected final int write file ( string fn , st st ) { try { file writer fs = new file writer ( fn ) ; buffered writer bw = new buffered writer ( fs ) ; bw . write ( st . render ( ) ) ; bw . close ( ) ; } catch ( io e ) { e . print stack trace ( ) ; return - num ; } return num ; }	Writes an ST object to a file.
public static optional < progress > get progress ( event model event model ) { if ( event model . get list resource container ( ) . contains resources from source ( id ) ) { return event model . get list resource container ( ) . provide resource ( id ) . stream ( ) . find any ( ) . flat map ( progress :: import resource ) ; } else { return optional . empty ( ) ; } }	gets the first Progress if found in the EventModel.
public static < e > collection < e > decorate ( collection < e > coll ) { return new synchronized collection < e > ( coll ) ; }	Factory method to create a synchronized collection.
public static collection < service resolver > discover ( inet address start , int count , int ms timeout ) { collection < service resolver > result = new array list < service resolver > ( ) ; collection < inet address > hosts = i . scan range ( start , count , ms timeout ) ; for ( inet address host : hosts ) { service resolver resolver = new service resolver ( host ) ; logger . info ( str , host . get host address ( ) , host . get canonical host name ( ) ) ; json config = resolver . get config ( ) ; if ( config != null ) { result . add ( resolver ) ; } } return result ; }	Discover FireREST services located in a range of IPv4 InetAddresses.E.g., The range of 256 addresses that starts with 10.0.1.128 ends with 10.0.2.127.
public json get config ( ) { if ( attempts == num ) { try { resolve ( ) ; } catch ( exception e ) {	Return the cached service configuration, resolving the service if required.
@ override public org . intellimate . izou . sdk . specification . context . thread pool get thread pool ( ) { return thread pool ; }	returns the API used to manage the ThreadPool.
public static optional < stop music > create stop music ( identification source , identification target ) { if ( target == null || target . equals ( source ) ) return optional . empty ( ) ; try { stop music stop request = new stop music ( source ) ; stop request . add resource ( new selector resource ( source , target ) ) ; return optional . of ( stop request ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } }	creates a new StopRequest.
public static boolean verify ( event model event model , identifiable player ) { if ( ! event model . contains descriptor ( stop music . id ) ) return bool ; return selector resource . is target ( event model , player ) . or else ( bool ) ; }	verifies that the StopMusicRequest is correct and checks whether the you are meant to react to it.
public dse cluster get cluster ( string hosts and ports , string username , string password , string authorization id ) { return get cluster ( cluster identifier . get instance ( hosts and ports , username , password , authorization id ) ) ; }	Obtain a DSE cluster instance.
public void add connection listener ( connection listener connection listener ) { if ( connection listener == null ) { return ; } if ( ! connection listeners . contains ( connection listener ) ) { connection listeners . add ( connection listener ) ; } }	Adds a connection listener to this connection that will be notified whenthe connection closes or fails.
public void add packet listener ( packet listener packet listener , packet filter packet filter ) { if ( packet listener == null ) { throw new null pointer exception ( str ) ; } listener wrapper wrapper = new listener wrapper ( packet listener , packet filter ) ; recv listeners . put ( packet listener , wrapper ) ; }	Registers a packet listener with this connection.
public void add packet sending listener ( packet listener packet listener , packet filter packet filter ) { if ( packet listener == null ) { throw new null pointer exception ( str ) ; } listener wrapper wrapper = new listener wrapper ( packet listener , packet filter ) ; send listeners . put ( packet listener , wrapper ) ; }	Registers a packet listener with this connection.
protected void fire packet sending listeners ( packet packet ) {	Process all packet listeners for sending packets.
public void add packet interceptor ( packet interceptor packet interceptor , packet filter packet filter ) { if ( packet interceptor == null ) { throw new null pointer exception ( str ) ; } interceptors . put ( packet interceptor , new interceptor wrapper ( packet interceptor , packet filter ) ) ; }	Registers a packet interceptor with this connection.
protected void fire packet interceptors ( packet packet ) { if ( packet != null ) { for ( interceptor wrapper interceptor wrapper : interceptors . values ( ) ) { interceptor wrapper . notify listener ( packet ) ; } } }	Process interceptors. Interceptors may modify the packet that is about tobe sent. Since the thread that requested to send the packet will invokeall interceptors, it is important that interceptors perform their work assoon as possible so that the thread does not remain blocked for a longperiod.
public static object to value ( string name , object value ) { string [ ] parts = string utils . split ( name , str , num ) ; string field name = null ; string field type = str ; if ( parts . length == num ) { field type = parts [ num ] ; field name = parts [ num ] ; } else if ( parts . length == num ) { field name = parts [ num ] ; } else { throw new illegal argument exception ( str ) ; } try { int l = array . get length ( value ) ; request parameter type < ? > rpt = types . get ( field type ) ; if ( rpt == null ) { rpt = types . get ( request parameter type . string ) ; } if ( ! field name . ends with ( str ) && l == num ) { return rpt . new instance ( array . get ( value , num ) ) ; } class < ? > component type = rpt . get component type ( ) ; object [ ] a = ( object [ ] ) array . new instance ( component type , l ) ; for ( int i = num ; i < l ; i ++ ) { a [ i ] = rpt . new instance ( array . get ( value , i ) ) ; } return a ; } catch ( illegal argument exception e ) { request parameter type < ? > rpt = types . get ( field type ) ; if ( rpt == null ) { rpt = types . get ( request parameter type . string ) ; } return rpt . new instance ( value ) ; } }	Creates the most suitable type.
public void connection lost ( ) {	Notification message that the connection with the server was lostunexpectedly.
protected string get current thread id ( ) { string attach id = ( string ) thread session . get value ( get thread session key ( ) ) ; if ( attach id != null ) return attach id ; thread thread = thread . current thread ( ) ; return thread . to string ( ) + str + thread . hash code ( ) + str ; }	Retrieve the current thread id for use by thetransaction code.
private boolean valid node ( final node < k , v > node , final string thread id ) { if ( auto commit || node == null ) return ( node != null ) ; return ! ( ( node . is ( node . deleted , thread id ) ) || ( node . is ( node . added , null ) && node . is ( node . no change , thread id ) ) ) ; }	Checks that this node is valid for the current thread.
public k get key for value ( final object value ) throws class cast exception , null pointer exception { return ( k ) do get ( value , value ) ; }	Returns the key to which this map maps the specified value.Returns null if the map contains no mapping for this value.
private object do get ( final object o , final int index ) { check non null comparable ( o , index ) ; node < k , v > node = lookup valid ( o , index , get current thread id ( ) ) ; return ( node == null ) ? null : node . get data ( opposite index ( index ) ) ; }	common get logic, used to get by key or get by value.
private node < k , v > lookup valid ( final object data , final int index , final string thread id ) { return next equal valid ( get floor equal node ( lookup ( data , index ) , index ) , index , thread id ) ; }	do the actual lookup of a piece of valid data.
private node < k , v > lookup ( final object data , final int index ) { node < k , v > rval = null ; node < k , v > node = root node [ index ] ; while ( node != null ) { int cmp = compare ( node . no change , data , node . get status ( ) , node . get data ( index ) , index ) ; if ( cmp == num ) { rval = node ; break ; } else { node = ( cmp < num ) ? node . get left ( index ) : node . get right ( index ) ; } } return rval ; }	do the actual lookup of a piece of data.
private int compare ( final int o1 status , final object o1 , final int o2 status , final object o2 , final int index ) { if ( comparators [ index ] == null ) { if ( o1 instanceof transactional comparable ) return ( ( transactional comparable ) o1 ) . compare to ( o1 status , o2 , o2 status ) ; else return ( ( comparable ) o1 ) . compare to ( o2 ) ; } else { return comparators [ index ] . compare ( o1 , o2 ) ; } }	Compare two objects.
private node < k , v > least node ( final node < k , v > node , final int index ) { node < k , v > lval = node ; if ( lval != null ) { while ( lval . get left ( index ) != null ) { lval = lval . get left ( index ) ; } } return lval ; }	find the least node from a given node.
private node < k , v > most node ( final node < k , v > node , final int index ) { node < k , v > rval = node ; if ( rval != null ) { while ( rval . get right ( index ) != null ) { rval = rval . get right ( index ) ; } } return rval ; }	find the most node from a given node.
private node < k , v > next greater ( final node < k , v > node , final int index ) { node < k , v > rval ; if ( node == null ) { rval = null ; } else if ( node . get right ( index ) != null ) {	get the next larger node from the specified node.
private node < k , v > most valid node ( final node < k , v > node , final int index , final string thread id ) { node < k , v > rval = node ; while ( rval != null && ! valid node ( rval , thread id ) ) { rval = next greater ( rval , index ) ; } return rval ; }	get the most valid node from the specified node.
private node < k , v > least valid node ( final node < k , v > node , final int index , final string thread id ) { node < k , v > lval = node ; while ( lval != null && ! valid node ( lval , thread id ) ) { lval = next smaller ( lval , index ) ; } return lval ; }	find the least valid node from a given node.
private static < k , v > void copy color ( final node < k , v > from , final node < k , v > to , final int index ) { if ( to != null ) { if ( from == null ) {	copy the color from one node to another, dealing with the factthat one or both nodes may, in fact, be null.
private static < k , v > boolean is red ( final node < k , v > node , final int index ) { return ( ( node == null ) ? bool : node . is red ( index ) ) ; }	is the specified node red? if the node does not exist, no, it'sblack, thank you.
private static < k , v > boolean is black ( final node < k , v > node , final int index ) { return ( ( node == null ) ? bool : node . is black ( index ) ) ; }	is the specified black red? if the node does not exist, sure,it's black, thank you.
private static < k , v > node < k , v > get grand parent ( final node < k , v > node , final int index ) { return get parent ( get parent ( node , index ) , index ) ; }	get a node's grandparent.
private static < k , v > node < k , v > get parent ( final node < k , v > node , final int index ) { return ( ( node == null ) ? null : node . get parent ( index ) ) ; }	get a node's parent.
private static < k , v > node < k , v > get right child ( final node < k , v > node , final int index ) { return ( node == null ) ? null : node . get right ( index ) ; }	get a node's right child.
private static < k , v > node < k , v > get left child ( final node < k , v > node , final int index ) { return ( node == null ) ? null : node . get left ( index ) ; }	get a node's left child.
private void rotate left ( final node < k , v > node , final int index ) { node < k , v > right child = node . get right ( index ) ; node . set right ( right child . get left ( index ) , index ) ; if ( right child . get left ( index ) != null ) { right child . get left ( index ) . set parent ( node , index ) ; } right child . set parent ( node . get parent ( index ) , index ) ; if ( node . get parent ( index ) == null ) {	do a rotate left. standard fare in the world of balanced trees.
private void rotate right ( final node < k , v > node , final int index ) { node < k , v > left child = node . get left ( index ) ; node . set left ( left child . get right ( index ) , index ) ; if ( left child . get right ( index ) != null ) { left child . get right ( index ) . set parent ( node , index ) ; } left child . set parent ( node . get parent ( index ) , index ) ; if ( node . get parent ( index ) == null ) {	do a rotate right. standard fare in the world of balanced trees.
private void do red black insert ( final node < k , v > inserted node , final int index ) { node < k , v > current node = inserted node ; make red ( current node , index ) ; while ( ( current node != null ) && ( current node != root node [ index ] ) && ( is red ( current node . get parent ( index ) , index ) ) ) { if ( is left child ( get parent ( current node , index ) , index ) ) { node < k , v > y = get right child ( get grand parent ( current node , index ) , index ) ; if ( is red ( y , index ) ) { make black ( get parent ( current node , index ) , index ) ; make black ( y , index ) ; make red ( get grand parent ( current node , index ) , index ) ; current node = get grand parent ( current node , index ) ; } else { if ( is right child ( current node , index ) ) { current node = get parent ( current node , index ) ; rotate left ( current node , index ) ; } make black ( get parent ( current node , index ) , index ) ; make red ( get grand parent ( current node , index ) , index ) ; if ( get grand parent ( current node , index ) != null ) { rotate right ( get grand parent ( current node , index ) , index ) ; } } } else {	complicated red-black insert stuff. Based on Sun's TreeMapimplementation, though it's barely recognizable any more.
private void do red black delete ( final node < k , v > deleted node ) { for ( int index = first index ; index < number of indices ; index ++ ) {	complicated red-black delete stuff. Based on Sun's TreeMapimplementation, though it's barely recognizable any more.
private void check non null comparable ( final object o , final int index ) { if ( o == null ) { throw new null pointer exception ( data name [ index ] + str ) ; } if ( comparators [ index ] == null && ! ( o instanceof comparable ) ) { throw new class cast exception ( data name [ index ] + str ) ; } }	check if an object is fit to be proper input ..
private void insert value ( final node < k , v > new node , final string thread id ) throws illegal argument exception { node < k , v > node = root node [ value ] ; while ( bool ) { int cmp = compare ( node . added , new node . get data ( value ) , node . get status ( ) , node . get data ( value ) , value ) ; if ( cmp == num ) { if ( next equal valid ( get floor equal node ( node , value ) , value , thread id ) != null ) { string debug message = str + new node . get data ( value ) + str + node . get key ( ) ; log . debug ( debug message ) ; throw new illegal argument exception ( debug message ) ; } if ( node . is ( node . added , null ) ) throw new concurrent modification exception ( ) ; if ( node . get right ( value ) != null ) { node = node . get right ( value ) ; } else if ( node . get left ( value ) != null ) { node = node . get left ( value ) ; } else { node . set right ( new node , value ) ; new node . set parent ( node , value ) ; do red black insert ( new node , value ) ; break ; } } else if ( cmp < num ) { if ( node . get left ( value ) != null ) { node = node . get left ( value ) ; } else { node . set left ( new node , value ) ; new node . set parent ( node , value ) ; do red black insert ( new node , value ) ; break ; } } else {	insert a node by its value.
@ override public boolean contains key ( final object key ) throws class cast exception , null pointer exception { check key ( key ) ; return lookup valid ( key , key , get current thread id ( ) ) != null ; }	Returns true if this map contains a mapping for the specifiedkey.
@ override public boolean contains value ( final object value ) { check value ( value ) ; return lookup valid ( value , value , get current thread id ( ) ) != null ; }	Returns true if this map maps one or more keys to thespecified value.
@ override public v get ( final object key ) throws class cast exception , null pointer exception { check key ( key ) ; return ( v ) do get ( key , key ) ; }	Returns the value to which this map maps the specifiedkey.
@ override public v remove ( final object key ) throws concurrent modification exception { check key ( key ) ; return ( v ) do remove ( key , key ) ; }	Removes the mapping for this key from this map if present.
@ override public void clear ( ) { if ( auto commit ) { modify ( ) ; node count = num ; root node [ key ] = null ; root node [ value ] = null ; } else { string thread id = get current thread id ( ) ; array list < entry < k , v > > list = new array list < entry < k , v > > ( entry set ( ) ) ; for ( iterator < entry < k , v > > i = list . iterator ( ) ; i . has next ( ) ; ) { node < k , v > node = ( node < k , v > ) i . next ( ) ; if ( node . is ( node . added , thread id ) ) do red black delete ( node ) ; else { node . set status ( node . deleted , thread id ) ; } } } }	Removes all mappings from this map.
public final void copy entries ( transactional bidi tree map < k , v > new map ) { k key ; v val ; int transaction status ; string transaction id ; new map . set auto commit ( is auto commit ( ) ) ; if ( ! is auto commit ( ) ) {	Copy all entries including transaction statuses from this map into the supplied map.Do not use this method unless you know exactly what you are doing.
protected synchronized void delete expired entries ( ) {	Clears all entries out of cache where the entries are older than themaximum defined age.
protected synchronized void cull cache ( ) {	Removes the least recently used elements if the cache size is greaterthan or equal to the maximum allowed size until the cache is at least 10%empty.
protected void activate ( map < string , object > props ) {	When the bundle gets activated we retrieve the OSGi properties.
public optional < player request > get player request ( string playlist name , boolean permanent ) { return get playlist ( playlist name ) . map ( playlist -> player request . create player request ( playlist , permanent , player , capabilities , context , identifiable ) ) ; }	asks the player for more information about the specified playlist and creates a PlayerRequest with the answer.
public static default roster store init ( final file base dir ) { default roster store store = new default roster store ( base dir ) ; if ( store . set roster version ( str ) ) { return store ; } else { return null ; } }	Creates a new roster store on disk.
public static default roster store open ( final file base dir ) { default roster store store = new default roster store ( base dir ) ; string s = store . read file ( store . get version file ( ) ) ; if ( s != null && s . starts with ( store id + str ) ) { return store ; } else { return null ; } }	Opens a roster store.
public static collection < inet address > scan range ( inet address addr , int count , int ms timeout ) { collection < inet address > addresses = new array list < inet address > ( ) ; collection < inet address > result = new array list < inet address > ( ) ; if ( addr == null ) { try { addresses . add all ( localhost network addresses ( ) ) ; } catch ( exception e ) { throw new rest ( e ) ;	Scan a range of InetAddresses starting with the given address.
public static inet address subnet address0 ( inet address addr , int subnet bits ) { if ( subnet bits < num || num <= subnet bits ) { throw new rest ( str ) ; } long mask = num ; for ( int i = num ; i < num ; i ++ ) { mask <<= num ; mask |= i < subnet bits ? num : num ; } long host0 = as long address ( addr ) & mask ; try { return as inet address ( host0 ) ; } catch ( unknown host exception e ) { throw new rest ( e ) ; } }	Return first address on subnet containing given address.
public hash map < string , object > export ( ) { hash map < string , object > data = new hash map < > ( ) ; data . put ( name descriptor , name ) ; data . put ( artist descriptor , artist ) ; data . put ( album descriptor , album descriptor ) ; data . put ( album cover descriptor , album cover ) ; data . put ( album cover format descriptor , album cover format descriptor ) ; data . put ( data descriptor , this . data ) ; data . put ( year descriptor , this . year ) ; data . put ( genre descriptor , this . genre ) ; data . put ( duration descriptor , this . duration ) ; data . put ( bmp descriptor , this . bmp ) ; return data ; }	exports the TrackInfo to a Hashmap.
public static optional < track info > import from hash map ( hash map < string , object > hash map ) { try { string name = ( string ) hash map . get ( name descriptor ) ; string album = ( string ) hash map . get ( album descriptor ) ; string artist = ( string ) hash map . get ( artist descriptor ) ; byte [ ] album cover = ( byte [ ] ) hash map . get ( album cover descriptor ) ; string album cover format = ( string ) hash map . get ( album cover format descriptor ) ; string data = ( string ) hash map . get ( data descriptor ) ; string year = ( string ) hash map . get ( year descriptor ) ; string genre = ( string ) hash map . get ( genre descriptor ) ; long duration = ( long ) hash map . get ( duration descriptor ) ; string bmp = ( string ) hash map . get ( bmp descriptor ) ; return optional . of ( new track info ( name , artist , album , album cover , album cover format , data , year , genre , bmp , duration ) ) ; } catch ( class cast exception e ) { return optional . empty ( ) ; } }	returns the optional TrackInfo if the HashMap contains no malformed data.
protected final void add all applications ( set < class < ? > > set ) { for ( class < ? > cls : set ) { if ( ! cls . is interface ( ) && ! modifier . is abstract ( cls . get modifiers ( ) ) ) { if ( ! this . classmap . contains value ( cls ) ) { this . class names . add ( cls . get name ( ) ) ; } } } }	Adds a set of application at runtime, as in all found applications that can be executed.
protected int execute application ( object svc , string [ ] args , string orig ) { if ( svc != null && ( svc instanceof s ) ) { if ( svc instanceof gen run scripts ) {	Executes an application.
protected final void print list ( ) { st list = this . stg . get instance of ( str ) ; list . add ( str , this . app name ) ; if ( this . classmap . size ( ) > num ) { list < map < string , string > > l = new array list < > ( ) ; for ( string key : this . classmap . key set ( ) ) { map < string , string > m = new hash map < > ( ) ; m . put ( str , key ) ; m . put ( str , this . classmap . get ( key ) . get name ( ) ) ; l . add ( m ) ; } list . add ( str , l ) ; } list . add ( str , this . class names ) ; system . out . println ( list . render ( ) ) ; }	Prints a list of pre-registered and found applications.
protected final void print usage ( ) { st usage = this . stg . get instance of ( str ) ; usage . add ( str , this . app name ) ; usage . add ( str , this . package filter ) ; usage . add ( str , this . jar filter ) ; usage . add ( str , new tree set < > ( arrays . as list ( new cf ( ) . excluded names ) ) ) ; system . out . println ( usage . render ( ) ) ; }	Prints usage information to standard out.
public static void main ( string [ ] args ) { s run = new s ( ) ; int ret = run . execute ( args ) ; system . exit ( ret ) ; }	Public main to start the application executor.
public static optional < mute event > create mute event ( identification source , identification target ) { if ( target == null || target . equals ( source ) ) return optional . empty ( ) ; try { mute event mute request = new mute event ( source ) ; mute request . add resource ( new selector resource ( source , target ) ) ; return optional . of ( mute request ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } }	creates a new MuteEvent.
public static optional < mute event > create mute event ( identification source ) { if ( source == null ) return optional . empty ( ) ; try { mute event mute request = new mute event ( source ) ; return optional . of ( mute request ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } }	creates a new MuteEvent, will mute everything.
public goodwill schema get schema ( final string schema name ) { goodwill schema schema = known schemata . get ( schema name ) ; if ( schema == null ) { refresh schemata cache ( ) ; schema = known schemata . get ( schema name ) ; } return schema ; }	Given a schema name, get the associated GoodwillSchema.
public boolean write file ( file file , list < string > lines ) { if ( file . exists ( ) ) { file . delete ( ) ; } try { file writer out = new file writer ( file ) ; for ( string s : lines ) { out . write ( s ) ; out . write ( system . get property ( str ) ) ; } out . close ( ) ; file . set executable ( bool ) ; } catch ( io ex ) { system . err . println ( this . get app name ( ) + str + file + str + ex . get message ( ) ) ; return bool ; } return bool ; }	Writes the given lines to the given file, if possible.
protected boolean in exec jar ( ) { class < gen exec jar scripts > clazz = gen exec jar scripts . class ; string class name = clazz . get simple name ( ) + str ; string class path = clazz . get resource ( class name ) . to string ( ) ; if ( ! class path . starts with ( str ) ) { system . err . println ( this . get app name ( ) + str ) ; return bool ; } string manifest path = class path . substring ( num , class path . last index of ( str ) + num ) + str ; manifest manifest ; try { manifest = new manifest ( new url ( manifest path ) . open stream ( ) ) ; } catch ( io ex ) { system . err . println ( this . get app name ( ) + str + ex . get message ( ) ) ; return bool ; } attributes attr = manifest . get main attributes ( ) ; if ( string utils . is blank ( attr . get value ( str ) ) ) { system . err . println ( this . get app name ( ) + str ) ; return bool ; } return bool ; }	Tests if the class is run from an executable JAR.
protected void add option ( application option < ? > option ) { if ( option != null ) { this . get cli ( ) . add option ( option ) ; this . options . add ( option ) ; } }	Adds a new option to CLI parser and option list.
public array list < goodwill schema field > get schema ( ) { final array list < goodwill schema field > items = new array list < goodwill schema field > ( thrift items . values ( ) ) ; collections . sort ( items , new comparator < goodwill schema field > ( ) { @ override public int compare ( final goodwill schema field left , final goodwill schema field right ) { return short . value of ( left . get id ( ) ) . compare to ( right . get id ( ) ) ; } } ) ; return items ; }	Get the schema as a collection of fields.We guarantee the ordering by field id.
public goodwill schema field get field by name ( final string name ) { for ( final goodwill schema field field : thrift items . values ( ) ) { if ( field . get name ( ) . equals ( name ) ) { return field ; } } return null ; }	Given a name, return the field matching the name.
public final static string get pkg name ( jar entry entry ) { if ( entry == null ) { return str ; } string s = entry . get name ( ) ; if ( s == null ) { return str ; } if ( s . length ( ) == num ) { return s ; } if ( s . starts with ( str ) ) { s = s . substring ( num , s . length ( ) ) ; } if ( s . ends with ( str ) ) { s = s . substring ( num , s . length ( ) - num ) ; } return s . replace ( str , str ) ; }	Returns the package name for a jar entry.
private immutable map < c , v > map content to values ( final immutable map < k , v > base ) { final immutable map . builder < c , v > builder = immutable map . builder ( ) ; for ( final entry < k , v > entry : base . entry set ( ) ) { builder . put ( this . key ( entry . get key ( ) ) , entry . get value ( ) ) ; } return builder . build ( ) ; }	Maps the content of the base map to its values.
public static optional < event listener > create event listener ( string descriptor , string description , string descriptor id , identifiable identifiable ) throws illegal argument exception { if ( ! descriptor id . matches ( str ) ) throw new illegal argument exception ( str + descriptor id + str ) ; return m . get instance ( ) . get identification ( identifiable ) . flat map ( id -> event . create event ( common events . type . notification type , id , collections . singleton list ( descriptor ) ) ) . map ( event -> new event listener ( event , descriptor , description , descriptor id ) ) ; }	Create the EventListener.
public iterative state < t , r > set state ( iterative state < t , r > new state ) { iterative state < t , r > old state = this . state ; this . state = new state ; return old state ; }	Sets the supplied state for this IterativeCallback.
public r iterate ( final filterable collection < ? extends t > c ) { init state ( ) ; check used ( ) ;	public wrapper for the iteration.
private r do iteration ( iterator < ? extends t > it ) {	do the actual iteration.
public static optional < track info > get track info ( event model event model ) { if ( event model . get list resource container ( ) . contains resources from source ( resource id ) ) { return event model . get list resource container ( ) . provide resource ( resource id ) . stream ( ) . find any ( ) . flat map ( track info :: import from resource ) ; } else { return optional . empty ( ) ; } }	gets the first TrackInfo if found in the EventModel.
public hash map < string , long > export ( ) { hash map < string , long > data = new hash map < > ( ) ; data . put ( length descriptor , length ) ; data . put ( known position descriptor , known position ) ; data . put ( known millis time stamp descriptor , known millis time stamp ) ; return data ; }	exports the progress.
public static optional < progress > import resource ( resource model resource model ) { object resource = resource model . get resource ( ) ; try {	creates a Progress-object from the resourceModel.
public buffered image error image ( string ... lines ) { if ( image buffer == null || image buffer . get width ( ) != image width || image buffer . get height ( ) != image height ) { image buffer = new buffered image ( image width , image height , buffered image . type int rgb ) ; } d g = ( d ) image buffer . get graphics ( ) ; g . set background ( new color ( num , num , num ) ) ; g . set color ( new color ( num , num , num ) ) ; g . clear rect ( num , num , image width , image height ) ; int max len = num ; for ( string line : lines ) { if ( line != null ) { for ( string inner line : line . split ( str ) ) { max len = math . max ( inner line . length ( ) , max len ) ; } } } int padding = num ; float size for width = num * ( image width - padding - padding ) / max len ;	Return an red image with the given text auto-sized to fit the current imageWidthximageHeight.
public buffered image get image ( url url ) { string now = new date ( ) . to string ( ) ; if ( url == null ) { return error image ( now , str ) ; } try { url urlconn = ( url ) url . open connection ( ) ; urlconn . set read timeout ( ms timeout ) ; urlconn . set connect timeout ( ms timeout ) ; urlconn . set request method ( str ) ; urlconn . connect ( ) ; buffered image image = io . read ( urlconn . get input stream ( ) ) ; if ( image == null ) { return error image ( now , str ) ; } image width = image . get width ( ) ; image height = image . get height ( ) ; return image ; } catch ( socket timeout exception e ) { logger . warn ( str , url , e . get class ( ) . get canonical name ( ) , e . get message ( ) ) ; return error image ( now , ms timeout + str ) ; } catch ( exception e ) { logger . warn ( str , url , e . get class ( ) . get canonical name ( ) , e . get message ( ) ) ; return error image ( now , str , url . to string ( ) , e . get message ( ) ) ; } }	Return image from given URL.
public json get json ( url url ) { try { logger . debug ( str , url ) ; string builder text = new string builder ( ) ; string line ; url urlconn = ( url ) url . open connection ( ) ; urlconn . set read timeout ( ms timeout ) ; urlconn . set connect timeout ( ms timeout ) ; urlconn . set request method ( str ) ; urlconn . connect ( ) ; buffered reader br = new buffered reader ( new input stream reader ( urlconn . get input stream ( ) ) ) ; while ( ( line = br . read line ( ) ) != null ) { text . append ( line ) ; } return new json ( text . to string ( ) ) ; } catch ( throwable e ) { throw new rest ( url . to string ( ) , e ) ; } }	HTTP GET json from given URL resource.
public static < k , v > void reverse ( map < k , v > source , map < v , k > target ) { iterator < k > i = source . key set ( ) . iterator ( ) ; while ( i . has next ( ) ) { k key = i . next ( ) ; v value = source . get ( key ) ; target . put ( value , key ) ; } }	Take key and value pairs from source and create map from value to key in target.
private set < r > multiplication ( ) { final set < r > answer = new linked hash set < > ( this . one . size ( ) * this . two . size ( ) ) ; for ( final a left : this . one ) { for ( final b right : this . two ) { final r element = this . function . apply ( left , right ) ; if ( answer . contains ( element ) ) { throw new illegal state exception ( string . format ( str , element ) ) ; } answer . add ( element ) ; } } return immutable set . copy of ( answer ) ; }	Creates Cartesian product of two lists.
@ override public synchronized void start ( ) { if ( ! running && ! used ) { this . running = bool ; this . used = bool ; this . set daemon ( bool ) ; super . start ( ) ; } }	Sets the thread running.
private void return to pool ( ) { if ( pool != null ) { try { pool . return object ( this ) ; } catch ( exception e1 ) { log . error ( str , e1 ) ; } this . pool = null ; } }	Returns the thread to the pool.
public static optional < ended event > create ended event ( identification source ) { try { ended event stop request = new ended event ( source ) ; return optional . of ( stop request ) ; } catch ( illegal argument exception e ) { return optional . empty ( ) ; } }	creates a new EndedEvent.
public track info get current ( ) { track info track info = null ; try { track info = queue . get ( position ) ; } catch ( index out of bounds exception e ) { track info = null ; } return track info ; }	returns the current played track or null.
public playlist update ( track info old , track info new track info ) { list < track info > list = new array list < > ( queue ) ; list . set ( list . index of ( old ) , new track info ) ; return new playlist ( queue , name , playback modes , position ) ; }	updates the TrackInfo-Object.
public playlist shuffle ( ) { int position = get position ( ) ; long seed = system . nano time ( ) ; if ( position >= num && position < queue . size ( ) ) { list < track info > track infos = queue . sub list ( num , position ) ; list < track info > not played = queue . sub list ( position , queue . size ( ) ) ; list < track info > shuffled not played = new array list < > ( not played ) ; collections . shuffle ( shuffled not played , new random ( seed ) ) ; track infos . add all ( shuffled not played ) ; return new playlist ( track infos ) ; } else { list < track info > track infos = new array list < > ( queue ) ; collections . shuffle ( track infos , new random ( seed ) ) ; return new playlist ( track infos ) ; } }	Shuffles the playlist and returns the shuffled playlist, so the original stays intact.Only the part of the playlist after the current position is shuffled.
public boolean verify ( capabilities capabilities ) { for ( playback mode playback mode : playback modes ) { switch ( playback mode ) { case repeat : if ( ! capabilities . can repeat playback ( ) ) { return bool ; } else { break ; } case repeat song : if ( ! capabilities . can repeat playback of song ( ) ) { return bool ; } else { break ; } case shuffle : if ( ! capabilities . can shuffle playback ( ) ) { return bool ; } else { break ; } } } return bool ; }	returns true if all the active playbackModes are supported.
public hash map < string , object > export ( ) { hash map < string , object > data = new hash map < > ( ) ; for ( int i = num ; i < queue . size ( ) ; i ++ ) { data . put ( queue descriptor + i , queue . get ( i ) . export ( ) ) ; } for ( int i = num ; i < playback modes . size ( ) ; i ++ ) { data . put ( playback mode descriptor + i , playback modes . get ( i ) . name ( ) ) ; } data . put ( name descriptor , name ) ; data . put ( position descriptor , position ) ; data . put ( data descriptor , this . data ) ; return data ; }	exports the Playlist to a HashMap.
public static final string escape for xml ( string string ) { if ( string == null ) { return null ; } char ch ; int i = num ; int last = num ; char [ ] input = string . to char array ( ) ; int len = input . length ; string buffer out = new string buffer ( ( int ) ( len * num ) ) ; for ( ; i < len ; i ++ ) { ch = input [ i ] ; if ( ch > str ) { continue ; } else if ( ch == str ) { if ( i > last ) { out . append ( input , last , i - last ) ; } last = i + num ; out . append ( lt encode ) ; } else if ( ch == str ) { if ( i > last ) { out . append ( input , last , i - last ) ; } last = i + num ; out . append ( gt encode ) ; } else if ( ch == str ) { if ( i > last ) { out . append ( input , last , i - last ) ; }	Escapes all necessary characters in the String so that it can be used inan XML doc.
public void challenge received ( string challenge ) throws io { byte response [ ] ; if ( challenge != null ) { response = sc . evaluate challenge ( string utils . decode base64 ( challenge ) ) ; } else { response = sc . evaluate challenge ( new byte [ num ] ) ; } packet response stanza ; if ( response == null ) { response stanza = new response ( ) ; } else { response stanza = new response ( string utils . encode base64 ( response , bool ) ) ; }	The server is challenging the SASL mechanism for the stanza he just sent.Send a response to the server's challenge.
public byte array output stream to json ( ) throws io { final byte array output stream out = new byte array output stream ( ) ; mapper . write value ( out , this ) ; return out ; }	Create a JSON representation of the GoodwillSchemaField.
@ override public void run ( ) { while ( ! stop ) { event model event ; try { event = blocking queue handling ( ) ;	main method for outputPlugin, runs the data-conversion and output-rendererit will instruct the outputManager to let the outputExtensions generate the data.
public void handle event ( event event ) { string topic = event . get topic ( ) ; logger . debug ( str , event , handlers ) ; collection < indexing handler > content index handler = handlers . get ( topic ) ; if ( content index handler != null && content index handler . size ( ) > num ) { try { int ttl = utils . to int ( event . get property ( topic indexer . ttl ) , integer . max value ) ; for ( indexing handler indexing handler : content index handler ) { if ( indexing handler instanceof s ) { ttl = math . min ( ttl , utils . default max ( ( ( s ) indexing handler ) . get ttl ( event ) ) ) ; } } queue manager q = null ;	Handles an event from OSGi and places it in the appropriate queue.
protected void join all ( ) throws interrupted exception { if ( queues != null ) { for ( queue manager q : queues ) { q . get queue dispatcher ( ) . join ( ) ; } } }	used only for testing.
public void set property ( string name , object value ) { if ( ! read only && ! filter properties . contains ( name ) ) { object cv = authorizable map . get ( name ) ; if ( value == null ) { if ( cv != null && ! ( cv instanceof remove property ) ) { modified map . put ( name , new remove property ( ) ) ; } } else if ( ! value . equals ( cv ) ) { modified map . put ( name , value ) ; } else if ( modified map . contains key ( name ) && ! value . equals ( modified map . get ( name ) ) ) { modified map . put ( name , value ) ; } } }	Set a property. The property will only be set if writable. If the property or this athorizable is read only, nothing will happen.
public void remove property ( string key ) { if ( ! read only && ( authorizable map . contains key ( key ) || modified map . contains key ( key ) ) ) { modified map . put ( key , new remove property ( ) ) ; } }	remove the property.
public void add principal ( string principal ) { if ( ! read only && ! principals . contains ( principal ) ) { principals . add ( principal ) ; principals modified = bool ; } }	add a principal to this authorizable.
public void remove principal ( string principal ) { if ( ! read only && principals . contains ( principal ) ) { principals . remove ( principal ) ; principals modified = bool ; } }	remove a principal from this authorizable.
public void root window closing ( window event evt ) { connection . remove packet listener ( listener ) ; ( ( observable reader ) reader ) . remove reader listener ( reader listener ) ; ( ( observable writer ) writer ) . remove writer listener ( writer listener ) ; }	Notification that the root window is closing.
@ suppress warnings ( str ) public void user encountered ( ) { list < string > descriptors = new array list < > ( ) ; descriptors . add ( common events . descriptors . not interrupt ) ; boolean known = ! fire unknown if not present || present ; boolean first present = ( ! strict && ! present ) || ( strict && ! strict present ) ; long last seen = this . last seen . until ( local date time . now ( ) , chrono unit . seconds ) ; optional < event > presence event = m . get instance ( ) . get identification ( this ) . flat map ( id -> presence event . create presence event ( id , strict , known , first present , descriptors , last seen ) ) . map ( event -> event . add event life cycle listener ( event life cycle . approved , life cycle -> { if ( known ) { this . last seen = local date time . now ( ) ; if ( strict ) this . strict present = bool ; present = bool ; } } ) ) ; if ( ! presence event . is present ( ) ) { error ( str ) ; } else { fire ( presence event . get ( ) , num ) ; } }	call this method when you have encountered the user.
@ override public void event fired ( event model event ) { if ( event . contains descriptor ( leaving event . id ) || event . contains descriptor ( presence event . id ) ) { if ( event . contains descriptor ( leaving event . id ) ) { if ( event . contains descriptor ( leaving event . general descriptor ) ) { present = bool ; strict present = bool ; } else if ( event . contains descriptor ( leaving event . strict descriptor ) ) { non strict available ( ) . then accept ( available -> { if ( ! available ) present = bool ; strict present = bool ; } ) ; } } else { present = bool ; if ( event . contains descriptor ( presence event . strict descriptor ) ) strict present = bool ; } if ( event . contains descriptor ( presence event . strict descriptor ) ) last seen = local date time . now ( ) ; } }	Invoked when an activator-event occurs.
public static boolean is permanent ( resource model resource model ) { object resource = resource model . get resource ( ) ; try { return ( boolean ) resource ; } catch ( class cast exception e ) { return bool ; } }	returns true if the resource is true, otherwise returns false.
public void set name ( string name ) { synchronized ( entries ) { for ( roster entry entry : entries ) { roster packet = new roster ( ) ; packet . set type ( iq . type . set ) ; list < string > group names = new linked list < string > ( entry . get group names ( ) ) ; group names . remove ( this . name ) ; group names . add ( name ) ; packet . add item ( new jid ( entry . get user ( ) ) , entry . get name ( ) , entry . get ask ( ) , entry . get subscription ( ) , group names ) ; connection . send packet ( packet ) ; } } }	Sets the name of the group.
public boolean contains key ( object key ) { int hash code = hash ( ( key == null ) ? null : key ) ; hash entry entry = data [ hash index ( hash code , data . length ) ] ;	Checks whether the map contains the specified key.
public boolean contains value ( object value ) { if ( value == null ) { for ( int i = num , isize = data . length ; i < isize ; i ++ ) { hash entry entry = data [ i ] ; while ( entry != null ) { if ( entry . get value ( ) == null ) { return bool ; } entry = entry . next ; } } } else { for ( int i = num , isize = data . length ; i < isize ; i ++ ) { hash entry entry = data [ i ] ; while ( entry != null ) { if ( is equal value ( value , entry . get value ( ) ) ) { return bool ; } entry = entry . next ; } } } return bool ; }	Checks whether the map contains the specified value.
public v put ( k key , v value ) { int hash code = hash ( ( key == null ) ? null : key ) ; int index = hash index ( hash code , data . length ) ; hash entry < k , v > entry = data [ index ] ; while ( entry != null ) { if ( entry . hash code == hash code && is equal key ( key , entry . get key ( ) ) ) { v old value = entry . get value ( ) ; update entry ( entry , value ) ; return old value ; } entry = entry . next ; } add mapping ( index , hash code , key , value ) ; return null ; }	Puts a key-value mapping into this map.
public void clear ( ) { mod count ++ ; hash entry [ ] data = this . data ; for ( int i = data . length - num ; i >= num ; i -- ) { data [ i ] = null ; } size = num ; }	Clears the map, resetting the size to zero and nullifying references toavoid garbage collection issues.
protected int hash ( object key ) {	Gets the hash code for the key specified.
protected boolean is equal key ( object key1 , object key2 ) { return ( key1 == key2 || ( ( key1 != null ) && key1 . equals ( key2 ) ) ) ; }	Compares two keys, in internal converted form, to see if they are equal.This implementation uses the equals method.
protected boolean is equal value ( object value1 , object value2 ) { return ( value1 == value2 || value1 . equals ( value2 ) ) ; }	Compares two values, in external form, to see if they are equal.
protected void ensure capacity ( int new capacity ) { int old capacity = data . length ; if ( new capacity <= old capacity ) { return ; } if ( size == num ) { threshold = calculate threshold ( new capacity , load factor ) ; data = new hash entry [ new capacity ] ; } else { hash entry < k , v > old entries [ ] = data ; hash entry < k , v > new entries [ ] = new hash entry [ new capacity ] ; mod count ++ ; for ( int i = old capacity - num ; i >= num ; i -- ) { hash entry < k , v > entry = old entries [ i ] ; if ( entry != null ) { old entries [ i ] = null ;	Changes the size of the data structure to the capacity proposed.
protected int calculate new capacity ( int proposed capacity ) { int new capacity = num ; if ( proposed capacity > maximum capacity ) { new capacity = maximum capacity ; } else { while ( new capacity < proposed capacity ) { new capacity <<= num ;	Calculates the new capacity of the map.
protected iterator < map . entry < k , v > > create entry set iterator ( ) { if ( size ( ) == num ) { return empty iterator . instance ; } return new entry set iterator < k , v > ( this ) ; }	Creates an entry set iterator.
public static void load from stream ( string key , map < string , object > output , input stream binary stream , string type ) throws io { data input stream dis = new data input stream ( binary stream ) ; string ckey = dis . read utf ( ) ; if ( ! key . equals ( ckey ) ) { throw new io ( str ) ; } read map from stream ( output , dis ) ; string cftype = null ; try { cftype = dis . read utf ( ) ; } catch ( io e ) { logger . debug ( str ) ; } if ( cftype != null && ! cftype . equals ( type ) ) { throw new io ( str + type + str + cftype + str ) ; } logger . debug ( str ) ; dis . close ( ) ; binary stream . close ( ) ; }	Load a Map from binary stream.
@ override public void init add on ( org . intellimate . izou . system . context context ) { this . context = new context ( context ) ; }	Internal initiation of addOn - fake constructor, comes before prepare.
protected void notify reconnection failed ( exception exception ) { if ( is reconnection allowed ( ) ) { for ( connection listener listener : connection . connection listeners ) { listener . reconnection failed ( exception ) ; } } }	Fires listeners when a reconnection attempt has failed.
protected void notify attempt to reconnect in ( int seconds ) { if ( is reconnection allowed ( ) ) { for ( connection listener listener : connection . connection listeners ) { listener . reconnecting in ( seconds ) ; } } }	Fires listeners when The Connection will retry a reconnection.
