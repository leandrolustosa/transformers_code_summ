code	desc
@ canignorereturnvalue public long copyto ( charsink sink ) throws ioexception { checknotnull ( sink ) ; closer closer = closer . create ( ) ; try { reader reader = closer . register ( openstream ( ) ) ; writer writer = closer . register ( sink . openstream ( ) ) ; return charstreams . copy ( reader , writer ) ; } catch ( throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }	Copies the contents of this source to the given sink.
public string read ( ) throws ioexception { closer closer = closer . create ( ) ; try { reader reader = closer . register ( openstream ( ) ) ; return charstreams . tostring ( reader ) ; } catch ( throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }	Reads the contents of this source as a string.
@ override public int read ( byte [ ] b , int off , int len ) throws ioexception {	buffer when possible.
private static charbuffer grow ( charbuffer buf ) { char [ ] copy = arrays . copyof ( buf . array ( ) , buf . capacity ( ) * num_ ) ; charbuffer bigger = charbuffer . wrap ( copy ) ; bigger . position ( buf . position ( ) ) ; bigger . limit ( buf . limit ( ) ) ; return bigger ; }	Returns a new CharBuffer identical to buf, except twice the capacity.
private void readmorechars ( ) throws ioexception {	Handle the case of underflow caused by needing more input characters.
private void startdraining ( boolean overflow ) { bytebuffer . flip ( ) ; if ( overflow && bytebuffer . remaining ( ) == num_ ) { bytebuffer = bytebuffer . allocate ( bytebuffer . capacity ( ) * num_ ) ; } else { draining = bool_ ; } }	Flips the buffer output buffer so we can start reading bytes from it.
public static boolean isempty ( iterable < ? > iterable ) { if ( iterable instanceof collection ) { return ( ( collection < ? > ) iterable ) . isempty ( ) ; } return ! iterable . iterator ( ) . hasnext ( ) ; }	Determines if the given iterable contains no elements. There is no precise {.
static < t > function < iterable < ? extends t > , iterator < ? extends t > > toiterator ( ) { return new function < iterable < ? extends t > , iterator < ? extends t > > ( ) { @ override public iterator < ? extends t > apply ( iterable < ? extends t > iterable ) { return iterable . iterator ( ) ; } } ; }	Useful as a public method?.
private static < t > iterator < t > consumingforarray ( final t ... elements ) { return new unmodifiableiterator < t > ( ) { int index = num_ ; @ override public boolean hasnext ( ) { return index < elements . length ; } @ override public t next ( ) { if ( ! hasnext ( ) ) { throw new nosuchelementexception ( ) ; } t result = elements [ index ] ; elements [ index ] = null ; index ++ ; return result ; } } ; }	Returns an Iterator that walks the specified array, nulling out elements behind it.
static < t > iterator < t > concatnodefensivecopy ( iterator < ? extends t > ... inputs ) { for ( iterator < ? extends t > input : checknotnull ( inputs ) ) { checknotnull ( input ) ; } return concat ( consumingforarray ( inputs ) ) ; }	Concats a varargs array of iterators without making a defensive copy of the array.
static void clear ( iterator < ? > iterator ) { checknotnull ( iterator ) ; while ( iterator . hasnext ( ) ) { iterator . next ( ) ; iterator . remove ( ) ; } }	Clears the iterator using its remove method.
public void write ( byte [ ] bytes ) throws ioexception { checknotnull ( bytes ) ; closer closer = closer . create ( ) ; try { outputstream out = closer . register ( openstream ( ) ) ; out . write ( bytes ) ; out . flush ( ) ;	Writes all the given bytes to this sink.
public static cachebuilderspec parse ( string cachebuilderspecification ) { cachebuilderspec spec = new cachebuilderspec ( cachebuilderspecification ) ; if ( ! cachebuilderspecification . isempty ( ) ) { for ( string keyvaluepair : keys_splitter . split ( cachebuilderspecification ) ) { list < string > keyandvalue = immutablelist . copyof ( key_value_splitter . split ( keyvaluepair ) ) ; checkargument ( ! keyandvalue . isempty ( ) , str_ ) ; checkargument ( keyandvalue . size ( ) <= num_ , str_ , keyvaluepair ) ;	Creates a CacheBuilderSpec from a string.
cachebuilder < object , object > tocachebuilder ( ) { cachebuilder < object , object > builder = cachebuilder . newbuilder ( ) ; if ( initialcapacity != null ) { builder . initialcapacity ( initialcapacity ) ; } if ( maximumsize != null ) { builder . maximumsize ( maximumsize ) ; } if ( maximumweight != null ) { builder . maximumweight ( maximumweight ) ; } if ( concurrencylevel != null ) { builder . concurrencylevel ( concurrencylevel ) ; } if ( keystrength != null ) { switch ( keystrength ) { case weak : builder . weakkeys ( ) ; break ; default : throw new assertionerror ( ) ; } } if ( valuestrength != null ) { switch ( valuestrength ) { case soft : builder . softvalues ( ) ; break ; case weak : builder . weakvalues ( ) ; break ; default : throw new assertionerror ( ) ; } } if ( recordstats != null && recordstats ) { builder . recordstats ( ) ; } if ( writeexpirationtimeunit != null ) { builder . expireafterwrite ( writeexpirationduration , writeexpirationtimeunit ) ; } if ( accessexpirationtimeunit != null ) { builder . expireafteraccess ( accessexpirationduration , accessexpirationtimeunit ) ; } if ( refreshtimeunit != null ) { builder . refreshafterwrite ( refreshduration , refreshtimeunit ) ; } return builder ; }	Returns a CacheBuilder configured according to this instance's specification.
public joiner skipnulls ( ) { return new joiner ( this ) { @ override public < a extends appendable > a appendto ( a appendable , iterator < ? > parts ) throws ioexception { checknotnull ( appendable , str_ ) ; checknotnull ( parts , str_ ) ; while ( parts . hasnext ( ) ) { object part = parts . next ( ) ; if ( part != null ) { appendable . append ( joiner . this . tostring ( part ) ) ; break ; } } while ( parts . hasnext ( ) ) { object part = parts . next ( ) ; if ( part != null ) { appendable . append ( separator ) ; appendable . append ( joiner . this . tostring ( part ) ) ; } } return appendable ; } @ override public joiner usefornull ( string nulltext ) { throw new unsupportedoperationexception ( str_ ) ; } @ override public mapjoiner withkeyvalueseparator ( string kvs ) { throw new unsupportedoperationexception ( str_ ) ; } } ; }	Returns a joiner with the same behavior as this joiner, except automatically skipping over anyprovided null elements.
public static immutableintarray of ( int first , int ... rest ) { checkargument ( rest . length <= integer . max_value - num_ , str_ ) ; int [ ] array = new int [ rest . length + num_ ] ; array [ num_ ] = first ; system . arraycopy ( rest , num_ , array , num_ , rest . length ) ; return new immutableintarray ( array ) ; }	okay since we have to copy the just-created array anyway.
public immutableintarray subarray ( int startindex , int endindex ) { preconditions . checkpositionindexes ( startindex , endindex , length ( ) ) ; return startindex == endindex ? empty : new immutableintarray ( array , start + startindex , start + endindex ) ; }	Returns a new immutable array containing the values in the specified range.
@ override @ canignorereturnvalue public int read ( ) throws ioexception { int b = in . read ( ) ; if ( b != - num_ ) { hasher . putbyte ( ( byte ) b ) ; } return b ; }	Reads the next byte of data from the underlying input stream and updates the hasher with thebyte read.
@ override @ canignorereturnvalue public int read ( byte [ ] bytes , int off , int len ) throws ioexception { int numofbytesread = in . read ( bytes , off , len ) ; if ( numofbytesread != - num_ ) { hasher . putbytes ( bytes , off , numofbytesread ) ; } return numofbytesread ; }	Reads the specified bytes of data from the underlying input stream and updates the hasher withthe bytes read.
static < k , v > void writemap ( map < k , v > map , objectoutputstream stream ) throws ioexception { stream . writeint ( map . size ( ) ) ; for ( map . entry < k , v > entry : map . entryset ( ) ) { stream . writeobject ( entry . getkey ( ) ) ; stream . writeobject ( entry . getvalue ( ) ) ; } }	Stores the contents of a map in an output stream, as part of serialization.
static < e > void writemultiset ( multiset < e > multiset , objectoutputstream stream ) throws ioexception { int entrycount = multiset . entryset ( ) . size ( ) ; stream . writeint ( entrycount ) ; for ( multiset . entry < e > entry : multiset . entryset ( ) ) { stream . writeobject ( entry . getelement ( ) ) ; stream . writeint ( entry . getcount ( ) ) ; } }	Stores the contents of a multiset in an output stream, as part of serialization.
static < t > fieldsetter < t > getfieldsetter ( final class < t > clazz , string fieldname ) { try { field field = clazz . getdeclaredfield ( fieldname ) ; return new fieldsetter < t > ( field ) ; } catch ( nosuchfieldexception e ) { throw new assertionerror ( e ) ;	Secret sauce for setting final fields; don't make it public.
@ canignorereturnvalue public stopwatch start ( ) { checkstate ( ! isrunning , str_ ) ; isrunning = bool_ ; starttick = ticker . read ( ) ; return this ; }	Starts the stopwatch.
@ canignorereturnvalue @ override public int add ( e element , int occurrences ) { checknotnull ( element ) ; if ( occurrences == num_ ) { return count ( element ) ; } collectpreconditions . checkpositive ( occurrences , str_ ) ; while ( bool_ ) { atomicinteger existingcounter = maps . safeget ( countmap , element ) ; if ( existingcounter == null ) { existingcounter = countmap . putifabsent ( element , new atomicinteger ( occurrences ) ) ; if ( existingcounter == null ) { return num_ ; }	Adds a number of occurrences of the specified element to this multiset.
private void resizememaybe ( int newsize ) { int entriessize = entries . length ; if ( newsize > entriessize ) { int newcapacity = entriessize + math . max ( num_ , entriessize > > > num_ ) ; if ( newcapacity < num_ ) { newcapacity = integer . max_value ; } if ( newcapacity != entriessize ) { resizeentries ( newcapacity ) ; } } }	Resizes the entries storage if necessary.
private static inetaddress bytestoinetaddress ( byte [ ] addr ) { try { return inetaddress . getbyaddress ( addr ) ; } catch ( unknownhostexception e ) { throw new assertionerror ( e ) ; } }	Convert a byte array into an InetAddress. {.
private static void compresslongestrunofzeroes ( int [ ] hextets ) { int bestrunstart = - num_ ; int bestrunlength = - num_ ; int runstart = - num_ ; for ( int i = num_ ; i < hextets . length + num_ ; i ++ ) { if ( i < hextets . length && hextets [ i ] == num_ ) { if ( runstart < num_ ) { runstart = i ; } } else if ( runstart >= num_ ) { int runlength = i - runstart ; if ( runlength > bestrunlength ) { bestrunstart = runstart ; bestrunlength = runlength ; } runstart = - num_ ; } } if ( bestrunlength >= num_ ) { arrays . fill ( hextets , bestrunstart , bestrunstart + bestrunlength , - num_ ) ; } }	Identify and mark the longest run of zeroes in an IPv6 address.
private static string hextetstoipv6string ( int [ ] hextets ) {	Convert a list of hextets into a human-readable IPv6 address.
public static inetaddress foruristring ( string hostaddr ) { inetaddress addr = foruristringnothrow ( hostaddr ) ; if ( addr == null ) { throw formatillegalargumentexception ( str_ , hostaddr ) ; } return addr ; }	Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded inthe format specified by RFC 3986 section 3.2.2.
public static inet4address getcompatipv4address ( inet6address ip ) { checkargument ( iscompatipv4address ( ip ) , str_ , toaddrstring ( ip ) ) ; return getinet4address ( arrays . copyofrange ( ip . getaddress ( ) , num_ , num_ ) ) ; }	Returns the IPv4 address embedded in an IPv4 compatible address.
public static boolean isteredoaddress ( inet6address ip ) { byte [ ] bytes = ip . getaddress ( ) ; return ( bytes [ num_ ] == ( byte ) num_ ) && ( bytes [ num_ ] == ( byte ) num_ ) && ( bytes [ num_ ] == num_ ) && ( bytes [ num_ ] == num_ ) ; }	Evaluates whether the argument is a Teredo address. Teredo addresses begin with the {.
public static boolean isisatapaddress ( inet6address ip ) {	Evaluates whether the argument is an ISATAP address.
public static inet4address getisatapipv4address ( inet6address ip ) { checkargument ( isisatapaddress ( ip ) , str_ , toaddrstring ( ip ) ) ; return getinet4address ( arrays . copyofrange ( ip . getaddress ( ) , num_ , num_ ) ) ; }	Returns the IPv4 address embedded in an ISATAP address.
public static inet4address getembeddedipv4clientaddress ( inet6address ip ) { if ( iscompatipv4address ( ip ) ) { return getcompatipv4address ( ip ) ; } if ( is6to4address ( ip ) ) { return get6to4ipv4address ( ip ) ; } if ( isteredoaddress ( ip ) ) { return getteredoinfo ( ip ) . getclient ( ) ; } throw formatillegalargumentexception ( str_ , toaddrstring ( ip ) ) ; }	Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is anIPv6 address of one of the specified address types that contain an embedded IPv4 address.
public static inetaddress decrement ( inetaddress address ) { byte [ ] addr = address . getaddress ( ) ; int i = addr . length - num_ ; while ( i >= num_ && addr [ i ] == ( byte ) num_ ) { addr [ i ] = ( byte ) num_ ; i -- ; } checkargument ( i >= num_ , str_ , address ) ; addr [ i ] -- ; return bytestoinetaddress ( addr ) ; }	Returns a new InetAddress that is one less than the passed in address.
@ beta public static bufferedreader newreader ( file file , charset charset ) throws filenotfoundexception { checknotnull ( file ) ; checknotnull ( charset ) ; return new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , charset ) ) ; }	Returns a buffered reader that reads from a file using the given character set. {.
@ beta public static void write ( byte [ ] from , file to ) throws ioexception { asbytesink ( to ) . write ( from ) ; }	Overwrites a file with the contents of a byte array. {.
@ beta public static void copy ( file from , outputstream to ) throws ioexception { asbytesource ( from ) . copyto ( to ) ; }	Copies all bytes from a file to an output stream. {.
@ beta @ suppresswarnings ( str_ )	Creates an empty file or updates the last updated timestamp on the same as the unix command ofthe same name.
@ beta @ deprecated public static string readfirstline ( file file , charset charset ) throws ioexception { return ascharsource ( file , charset ) . readfirstline ( ) ; }	Reads the first line from a file.
@ beta public static < k , v > builder < k , v > builderwithexpectedsize ( int expectedsize ) { checknonnegative ( expectedsize , str_ ) ; return new builder < > ( expectedsize ) ; }	Returns a new builder, expecting the specified number of entries to be added. If {.
@ canignorereturnvalue @ deprecated @ override public v forceput ( k key , v value ) { throw new unsupportedoperationexception ( ) ; }	Guaranteed to throw an exception and leave the bimap unmodified.
public static < e extends comparable < e > > minmaxpriorityqueue < e > create ( iterable < ? extends e > initialcontents ) { return new builder < e > ( ordering . < e > natural ( ) ) . create ( initialcontents ) ; }	Creates a new min-max priority queue using natural order, no maximum size, and initiallycontaining the given elements.
private int calculatenewcapacity ( ) { int oldcapacity = queue . length ; int newcapacity = ( oldcapacity < num_ ) ? ( oldcapacity + num_ ) * num_ : intmath . checkedmultiply ( oldcapacity / num_ , num_ ) ; return capatmaximumsize ( newcapacity , maximumsize ) ; }	Returns ~2x the old capacity if small; ~1.5x otherwise.
private static hashcode fmix ( int h1 , int length ) { h1 ^= length ; h1 ^= h1 > > > num_ ; h1 *= num_ ; h1 ^= h1 > > > num_ ; h1 *= num_ ; h1 ^= h1 > > > num_ ; return hashcode . fromint ( h1 ) ; }	Finalization mix - force all bits of a hash block to avalanche.
public static < s extends comparable < ? super s > > elementorder < s > natural ( ) { return new elementorder < s > ( type . sorted , ordering . < s > natural ( ) ) ; }	Returns an instance which specifies that the natural ordering of the elements is guaranteed.
@ suppresswarnings ( str_ )	Enters this monitor. Blocks at most the given time.
@ suppresswarnings ( str_ )	Enters this monitor. Blocks at most the given time, and may be interrupted.
public void enterwhen ( guard guard ) throws interruptedexception { if ( guard . monitor != this ) { throw new illegalmonitorstateexception ( ) ; } final reentrantlock lock = this . lock ; boolean signalbeforewaiting = lock . isheldbycurrentthread ( ) ; lock . lockinterruptibly ( ) ; boolean satisfied = bool_ ; try { if ( ! guard . issatisfied ( ) ) { await ( guard , signalbeforewaiting ) ; } satisfied = bool_ ; } finally { if ( ! satisfied ) { leave ( ) ; } } }	Enters this monitor when the guard is satisfied.
@ suppresswarnings ( str_ )	Enters this monitor when the guard is satisfied.
public void enterwhenuninterruptibly ( guard guard ) { if ( guard . monitor != this ) { throw new illegalmonitorstateexception ( ) ; } final reentrantlock lock = this . lock ; boolean signalbeforewaiting = lock . isheldbycurrentthread ( ) ; lock . lock ( ) ; boolean satisfied = bool_ ; try { if ( ! guard . issatisfied ( ) ) { awaituninterruptibly ( guard , signalbeforewaiting ) ; } satisfied = bool_ ; } finally { if ( ! satisfied ) { leave ( ) ; } } }	Enters this monitor when the guard is satisfied.
public boolean enterif ( guard guard ) { if ( guard . monitor != this ) { throw new illegalmonitorstateexception ( ) ; } final reentrantlock lock = this . lock ; lock . lock ( ) ; boolean satisfied = bool_ ; try { return satisfied = guard . issatisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } }	Enters this monitor if the guard is satisfied.
@ suppresswarnings ( str_ )	Enters this monitor if the guard is satisfied.
public boolean enterifinterruptibly ( guard guard ) throws interruptedexception { if ( guard . monitor != this ) { throw new illegalmonitorstateexception ( ) ; } final reentrantlock lock = this . lock ; lock . lockinterruptibly ( ) ; boolean satisfied = bool_ ; try { return satisfied = guard . issatisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } }	Enters this monitor if the guard is satisfied.
public boolean tryenterif ( guard guard ) { if ( guard . monitor != this ) { throw new illegalmonitorstateexception ( ) ; } final reentrantlock lock = this . lock ; if ( ! lock . trylock ( ) ) { return bool_ ; } boolean satisfied = bool_ ; try { return satisfied = guard . issatisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } }	Enters this monitor if it is possible to do so immediately and the guard is satisfied.
public void waitfor ( guard guard ) throws interruptedexception { if ( ! ( ( guard . monitor == this ) & lock . isheldbycurrentthread ( ) ) ) { throw new illegalmonitorstateexception ( ) ; } if ( ! guard . issatisfied ( ) ) { await ( guard , bool_ ) ; } }	Waits for the guard to be satisfied.
public void waitforuninterruptibly ( guard guard ) { if ( ! ( ( guard . monitor == this ) & lock . isheldbycurrentthread ( ) ) ) { throw new illegalmonitorstateexception ( ) ; } if ( ! guard . issatisfied ( ) ) { awaituninterruptibly ( guard , bool_ ) ; } }	Waits for the guard to be satisfied.
@ suppresswarnings ( str_ )	Waits for the guard to be satisfied.
public int getwaitqueuelength ( guard guard ) { if ( guard . monitor != this ) { throw new illegalmonitorstateexception ( ) ; } lock . lock ( ) ; try { return guard . waitercount ; } finally { lock . unlock ( ) ; } }	Returns an estimate of the number of threads waiting for the given guard to become satisfied.Note that because timeouts and interrupts may occur at any time, the estimate serves only as anupper bound on the actual number of waiters.
@ guardedby ( str_ ) private void signalallwaiters ( ) { for ( guard guard = activeguards ; guard != null ; guard = guard . next ) { guard . condition . signalall ( ) ; } }	Signals all threads waiting on guards.
@ guardedby ( str_ ) private void beginwaitingfor ( guard guard ) { int waiters = guard . waitercount ++ ; if ( waiters == num_ ) {	Records that the current thread is about to wait on the specified guard.
@ guardedby ( str_ ) private void endwaitingfor ( guard guard ) { int waiters = -- guard . waitercount ; if ( waiters == num_ ) {	Records that the current thread is no longer waiting on the specified guard.
@ guardedby ( str_ ) private boolean awaitnanos ( guard guard , long nanos , boolean signalbeforewaiting ) throws interruptedexception { boolean firsttime = bool_ ; try { do { if ( nanos <= num_ ) { return bool_ ; } if ( firsttime ) { if ( signalbeforewaiting ) { signalnextwaiter ( ) ; } beginwaitingfor ( guard ) ; firsttime = bool_ ; } nanos = guard . condition . awaitnanos ( nanos ) ; } while ( ! guard . issatisfied ( ) ) ; return bool_ ; } finally { if ( ! firsttime ) { endwaitingfor ( guard ) ; } } }	Caller should check before calling that guard is not satisfied.
public void write ( charsequence charsequence ) throws ioexception { checknotnull ( charsequence ) ; closer closer = closer . create ( ) ; try { writer out = closer . register ( openstream ( ) ) ; out . append ( charsequence ) ; out . flush ( ) ;	Writes the given character sequence to this sink.
public void execute ( ) {	Runs this execution list, executing all existing pairs in the order they were added.
static long load64safely ( byte [ ] input , int offset , int length ) { long result = num_ ;	Similar to load64, but allows offset + 8 > input.length, padding the result with zeroes.
static void store64 ( byte [ ] sink , int offset , long value ) {	Store 8 bytes into the provided array at the indicated offset, using the value provided.
static int load32 ( byte [ ] source , int offset ) {	Load 4 bytes from the provided array at the indicated offset.
public static mediatype create ( string type , string subtype ) { mediatype mediatype = create ( type , subtype , immutablelistmultimap . < string , string > of ( ) ) ; mediatype . parsedcharset = optional . absent ( ) ; return mediatype ; }	Creates a new media type with the given type and subtype.
public static mediatype parse ( string input ) { checknotnull ( input ) ; tokenizer tokenizer = new tokenizer ( input ) ; try { string type = tokenizer . consumetoken ( token_matcher ) ; tokenizer . consumecharacter ( str_ ) ; string subtype = tokenizer . consumetoken ( token_matcher ) ; immutablelistmultimap . builder < string , string > parameters = immutablelistmultimap . builder ( ) ; while ( tokenizer . hasmore ( ) ) { tokenizer . consumetokenifpresent ( linear_white_space ) ; tokenizer . consumecharacter ( str_ ) ; tokenizer . consumetokenifpresent ( linear_white_space ) ; string attribute = tokenizer . consumetoken ( token_matcher ) ; tokenizer . consumecharacter ( str_ ) ; final string value ; if ( str_ == tokenizer . previewchar ( ) ) { tokenizer . consumecharacter ( str_ ) ; stringbuilder valuebuilder = new stringbuilder ( ) ; while ( str_ != tokenizer . previewchar ( ) ) { if ( str_ == tokenizer . previewchar ( ) ) { tokenizer . consumecharacter ( str_ ) ; valuebuilder . append ( tokenizer . consumecharacter ( ascii ( ) ) ) ; } else { valuebuilder . append ( tokenizer . consumetoken ( quoted_text_matcher ) ) ; } } value = valuebuilder . tostring ( ) ; tokenizer . consumecharacter ( str_ ) ; } else { value = tokenizer . consumetoken ( token_matcher ) ; } parameters . put ( attribute , value ) ; } return create ( type , subtype , parameters . build ( ) ) ; } catch ( illegalstateexception e ) { throw new illegalargumentexception ( str_ + input + str_ , e ) ; } }	Parses a media type from its string representation.
final type capture ( ) { type superclass = getclass ( ) . getgenericsuperclass ( ) ; checkargument ( superclass instanceof parameterizedtype , str_ , superclass ) ; return ( ( parameterizedtype ) superclass ) . getactualtypearguments ( ) [ num_ ] ; }	Returns the captured type.
static boolean removeallimpl ( set < ? > set , iterator < ? > iterator ) { boolean changed = bool_ ; while ( iterator . hasnext ( ) ) { changed |= set . remove ( iterator . next ( ) ) ; } return changed ; }	Remove each element in an iterable from a set.
@ override public string escape ( string string ) { checknotnull ( string ) ;	Returns the escaped form of a given literal string.
private static char [ ] growbuffer ( char [ ] dest , int index , int size ) { if ( size < num_ ) {	Helper method to grow the character buffer as needed, this only happens once in a while so it'sok if it's in a method call.
public < k1 extends k , v1 extends v > cache < k1 , v1 > build ( ) { checkweightwithweigher ( ) ; checknonloadingcache ( ) ; return new localcache . localmanualcache < > ( this ) ; }	Builds a cache which does not automatically load values when keys are requested. Consider {.
void allocarrays ( ) { preconditions . checkstate ( needsallocarrays ( ) , str_ ) ; int expectedsize = modcount ; int buckets = hashing . closedtablesize ( expectedsize , load_factor ) ; this . table = newtable ( buckets ) ; this . entries = newentries ( expectedsize ) ; this . keys = new object [ expectedsize ] ; this . values = new object [ expectedsize ] ; }	Handle lazy allocation of arrays.
public void add ( double value ) { if ( count == num_ ) { count = num_ ; mean = value ; min = value ; max = value ; if ( ! isfinite ( value ) ) { sumofsquaresofdeltas = nan ; } } else { count ++ ; if ( isfinite ( value ) && isfinite ( mean ) ) {	Adds the given value to the dataset.
static double calculatenewmeannonfinite ( double previousmean , double value ) { if ( isfinite ( previousmean ) ) {	Calculates the new value for the accumulated mean when a value is added, in the case where atleast one of the previous mean and the value is non-finite.
static object [ ] rebuildhashtable ( int newtablesize , object [ ] elements , int n ) { object [ ] hashtable = new object [ newtablesize ] ; int mask = hashtable . length - num_ ; for ( int i = num_ ; i < n ; i ++ ) { object e = elements [ i ] ; int j0 = hashing . smear ( e . hashcode ( ) ) ; for ( int j = j0 ; ; j ++ ) { int index = j & mask ; if ( hashtable [ index ] == null ) { hashtable [ index ] = e ; break ; } } } return hashtable ; }	Builds a new open-addressed hash table from the first n objects in elements.
@ visiblefortesting static int choosetablesize ( int setsize ) { setsize = math . max ( setsize , num_ ) ;	Returns an array size suitable for the backing array of a hash table that uses open addressingwith linear probing in its implementation.
@ suppresswarnings ( str_ ) public static < r , c , v > immutabletable < r , c , v > of ( ) { return ( immutabletable < r , c , v > ) sparseimmutabletable . empty ; }	Returns an empty immutable table.
public static < r , c , v > immutabletable < r , c , v > of ( r rowkey , c columnkey , v value ) { return new singletonimmutabletable < > ( rowkey , columnkey , value ) ; }	Returns an immutable table containing a single cell.
@ suppresswarnings ( str_ )	Returns a serializable converter that always converts or reverses an object to itself.
static < r , c , v > regularimmutabletable < r , c , v > fororderedcomponents ( immutablelist < cell < r , c , v > > celllist , immutableset < r > rowspace , immutableset < c > columnspace ) {	A factory that chooses the most space-efficient representation of the table.
public static < e extends comparable < ? super e > > immutablesortedmultiset < e > of ( e element ) { regularimmutablesortedset < e > elementset = ( regularimmutablesortedset < e > ) immutablesortedset . of ( element ) ; long [ ] cumulativecounts = { num_ , num_ } ; return new regularimmutablesortedmultiset < e > ( elementset , cumulativecounts , num_ , num_ ) ; }	Returns an immutable sorted multiset containing a single element.
public static < e extends comparable < ? > > builder < e > reverseorder ( ) { return new builder < e > ( ordering . natural ( ) . reverse ( ) ) ; }	Returns a builder that creates immutable sorted multisets whose elements are ordered by thereverse of their natural ordering. Note: the type parameter {.
private static < e > boolean retainoccurrencesimpl ( multiset < e > multisettomodify , multiset < ? > occurrencestoretain ) { checknotnull ( multisettomodify ) ; checknotnull ( occurrencestoretain ) ;	Delegate implementation which cares about the element type.
@ deprecated public final fluentiterable < t > preordertraversal ( final t root ) { checknotnull ( root ) ; return new fluentiterable < t > ( ) { @ override public unmodifiableiterator < t > iterator ( ) { return preorderiterator ( root ) ; } @ override public void foreach ( consumer < ? super t > action ) { checknotnull ( action ) ; new consumer < t > ( ) { @ override public void accept ( t t ) { action . accept ( t ) ; children ( t ) . foreach ( this ) ; } } . accept ( root ) ; } } ; }	Returns an unmodifiable iterable over the nodes in a tree structure, using pre-order traversal.That is, each node's subtrees are traversed after the node itself is returned.
static stringbuilder newstringbuilderforcollection ( int size ) { checknonnegative ( size , str_ ) ; return new stringbuilder ( ( int ) math . min ( size * num_ , ints . max_power_of_two ) ) ; }	Returns best-effort-sized StringBuilder based on the given collection size.
final void setmap ( map < k , collection < v > > map ) { this . map = map ; totalsize = num_ ; for ( collection < v > values : map . values ( ) ) { checkargument ( ! values . isempty ( ) ) ; totalsize += values . size ( ) ; } }	Used during deserialization only.
private void removevaluesforkey ( object key ) { collection < v > collection = maps . saferemove ( map , key ) ; if ( collection != null ) { int count = collection . size ( ) ; collection . clear ( ) ; totalsize -= count ; } }	Removes all values for the provided key.
private static < t > fluentiterable < t > concatnodefensivecopy ( final iterable < ? extends t > ... inputs ) { for ( iterable < ? extends t > input : inputs ) { checknotnull ( input ) ; } return new fluentiterable < t > ( ) { @ override public iterator < t > iterator ( ) { return iterators . concat ( new abstractindexedlistiterator < iterator < ? extends t > > ( inputs . length ) { @ override public iterator < ? extends t > get ( int i ) { return inputs [ i ] . iterator ( ) ; } } ) ; } } ; }	Concatenates a varargs array of iterables without making a defensive copy of the array.
@ beta public static < e > fluentiterable < e > of ( ) { return fluentiterable . from ( immutablelist . < e > of ( ) ) ; }	Returns a fluent iterable containing no elements. {.
public static < k , v > immutablemultimap < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { return immutablelistmultimap . of ( k1 , v1 , k2 , v2 ) ; }	Returns an immutable multimap containing the given entries, in order.
@ override public immutablecollection < entry < k , v > > entries ( ) { return ( immutablecollection < entry < k , v > > ) super . entries ( ) ; }	Returns an immutable collection of all key-value pairs in the multimap.
private long countbyskipping ( inputstream in ) throws ioexception { long count = num_ ; long skipped ; while ( ( skipped = skipupto ( in , integer . max_value ) ) > num_ ) { count += skipped ; } return count ; }	Counts the bytes in the given input stream using skip if possible.
public byte [ ] read ( ) throws ioexception { closer closer = closer . create ( ) ; try { inputstream in = closer . register ( openstream ( ) ) ; optional < long > size = sizeifknown ( ) ; return size . ispresent ( ) ? bytestreams . tobytearray ( in , size . get ( ) ) : bytestreams . tobytearray ( in ) ; } catch ( throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }	Reads the full contents of this byte source as a byte array.
public hashcode hash ( hashfunction hashfunction ) throws ioexception { hasher hasher = hashfunction . newhasher ( ) ; copyto ( funnels . asoutputstream ( hasher ) ) ; return hasher . hash ( ) ; }	Hashes the contents of this byte source using the given hash function.
public boolean contentequals ( bytesource other ) throws ioexception { checknotnull ( other ) ; byte [ ] buf1 = createbuffer ( ) ; byte [ ] buf2 = createbuffer ( ) ; closer closer = closer . create ( ) ; try { inputstream in1 = closer . register ( openstream ( ) ) ; inputstream in2 = closer . register ( other . openstream ( ) ) ; while ( bool_ ) { int read1 = bytestreams . read ( in1 , buf1 , num_ , buf1 . length ) ; int read2 = bytestreams . read ( in2 , buf2 , num_ , buf2 . length ) ; if ( read1 != read2 || ! arrays . equals ( buf1 , buf2 ) ) { return bool_ ; } else if ( read1 != buf1 . length ) { return bool_ ; } } } catch ( throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }	Checks that the contents of this byte source are equal to the contents of the given bytesource.
@ suppresswarnings ( str_ ) public static < k extends comparable < ? > , v > immutablerangemap < k , v > of ( ) { return ( immutablerangemap < k , v > ) empty ; }	Returns an empty immutable range map.
public static < k extends comparable < ? > , v > immutablerangemap < k , v > of ( range < k > range , v value ) { return new immutablerangemap < > ( immutablelist . of ( range ) , immutablelist . of ( value ) ) ; }	Returns an immutable range map mapping a single range to a single value.
public static hashfunction concatenating ( hashfunction first , hashfunction second , hashfunction ... rest ) {	Returns a hash function which computes its hash code by concatenating the hash codes of theunderlying hash functions together.
public static < e extends comparable < ? super e > > immutablesortedset < e > of ( e element ) { return new regularimmutablesortedset < e > ( immutablelist . of ( element ) , ordering . natural ( ) ) ; }	Returns an immutable sorted set containing a single element.
public valuegraphbuilder < n , v > expectednodecount ( int expectednodecount ) { this . expectednodecount = optional . of ( checknonnegative ( expectednodecount ) ) ; return this ; }	Specifies the expected number of nodes in the graph.
public static < t , s extends t > comparator < iterable < s > > lexicographical ( comparator < t > comparator ) { return new lexicographicalordering < s > ( checknotnull ( comparator ) ) ; }	think tip it over into being worthwhile.
public static void startfinalizer ( class < ? > finalizablereferenceclass , referencequeue < object > queue , phantomreference < object > frqreference ) { if ( ! finalizablereferenceclass . getname ( ) . equals ( finalizable_reference ) ) { throw new illegalargumentexception ( str_ + finalizable_reference + str_ ) ; } finalizer finalizer = new finalizer ( finalizablereferenceclass , queue , frqreference ) ; string threadname = finalizer . class . getname ( ) ; thread thread = null ; if ( bigthreadconstructor != null ) { try { boolean inheritthreadlocals = bool_ ; long defaultstacksize = num_ ; thread = bigthreadconstructor . newinstance ( ( threadgroup ) null , finalizer , threadname , defaultstacksize , inheritthreadlocals ) ; } catch ( throwable t ) { logger . log ( level . info , str_ , t ) ; } } if ( thread == null ) { thread = new thread ( ( threadgroup ) null , finalizer , threadname ) ; } thread . setdaemon ( bool_ ) ; try { if ( inheritablethreadlocals != null ) { inheritablethreadlocals . set ( thread , null ) ; } } catch ( throwable t ) { logger . log ( level . info , str_ , t ) ; } thread . start ( ) ; }	Starts the Finalizer thread.
@ suppresswarnings ( str_ )	Returns the empty sorted map.
public static < k extends comparable < ? super k > , v > immutablesortedmap < k , v > of ( k k1 , v v1 ) { return of ( ordering . natural ( ) , k1 , v1 ) ; }	Returns an immutable map containing a single entry.
@ suppresswarnings ( str_ ) public static < k extends comparable < ? super k > , v > immutablesortedmap < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { return ofentries ( entryof ( k1 , v1 ) , entryof ( k2 , v2 ) ) ; }	Returns an immutable sorted map containing the given entries, sorted by the natural ordering oftheir keys.
@ suppresswarnings ( str_ ) public static < k , v > immutablesortedmap < k , v > copyofsorted ( sortedmap < k , ? extends v > map ) { comparator < ? super k > comparator = map . comparator ( ) ; if ( comparator == null ) {	Returns an immutable map containing the same entries as the provided sorted map, with the sameordering.
private static void weakhashlength32withseeds ( byte [ ] bytes , int offset , long seeda , long seedb , long [ ] output ) { long part1 = load64 ( bytes , offset ) ; long part2 = load64 ( bytes , offset + num_ ) ; long part3 = load64 ( bytes , offset + num_ ) ; long part4 = load64 ( bytes , offset + num_ ) ; seeda += part1 ; seedb = rotateright ( seedb + seeda + part4 , num_ ) ; long c = seeda ; seeda += part2 ; seeda += part3 ; seedb += rotateright ( seeda , num_ ) ; output [ num_ ] = seeda + part4 ; output [ num_ ] = seedb + c ; }	Computes intermediate hash of 32 bytes of byte array from the given offset.
@ guardedby ( str_ ) private void checkcurrentstate ( state expected ) { state actual = state ( ) ; if ( actual != expected ) { if ( actual == failed ) {	Checks that the current state is equal to the expected state.
public static immutablelist < path > listfiles ( path dir ) throws ioexception { try ( directorystream < path > stream = files . newdirectorystream ( dir ) ) { return immutablelist . copyof ( stream ) ; } catch ( directoryiteratorexception e ) { throw e . getcause ( ) ; } }	Returns an immutable list of paths to the files contained in the given directory.
private static boolean isdirectory ( securedirectorystream < path > dir , path name , linkoption ... options ) throws ioexception { return dir . getfileattributeview ( name , basicfileattributeview . class , options ) . readattributes ( ) . isdirectory ( ) ; }	Returns whether or not the file with the given name in the given dir is a directory.
public static boolean equal ( path path1 , path path2 ) throws ioexception { checknotnull ( path1 ) ; checknotnull ( path2 ) ; if ( files . issamefile ( path1 , path2 ) ) { return bool_ ; } bytesource source1 = asbytesource ( path1 ) ; bytesource source2 = asbytesource ( path2 ) ; long len1 = source1 . sizeifknown ( ) . or ( num_ ) ; long len2 = source2 . sizeifknown ( ) . or ( num_ ) ; if ( len1 != num_ && len2 != num_ && len1 != len2 ) { return bool_ ; } return source1 . contentequals ( source2 ) ; }	Returns true if the files located by the given paths exist, are not directories, and containthe same bytes.
@ suppresswarnings ( str_ )	Like the unix command of the same name, creates an empty file or updates the last modifiedtimestamp of the existing file at the given path to the current system time.
private static @ nullable path getparentpath ( path path ) { path parent = path . getparent ( ) ;	Returns a path to the parent directory of the given path.
private static void checkallowsinsecure ( path path , recursivedeleteoption [ ] options ) throws insecurerecursivedeleteexception { if ( ! arrays . aslist ( options ) . contains ( recursivedeleteoption . allow_insecure ) ) { throw new insecurerecursivedeleteexception ( path . tostring ( ) ) ; } }	Checks that the given options allow an insecure delete, throwing an exception if not.
private static void throwdeletefailed ( path path , collection < ioexception > exceptions ) throws filesystemexception {	Throws an exception indicating that one or more files couldn't be deleted.
static int rehash ( int h ) {	Applies a supplemental hash function to a given hash code, which defends against poor qualityhash functions.
segment < k , v , e , s > segmentfor ( int hash ) {	Returns the segment that should be used for a key with the given hash.
static < e > immutablelist < e > unsafedelegatelist ( list < ? extends e > list ) { switch ( list . size ( ) ) { case num_ : return of ( ) ; case num_ : return of ( list . get ( num_ ) ) ; default : @ suppresswarnings ( str_ ) list < e > castedlist = ( list < e > ) list ; return new regularimmutablelist < e > ( castedlist ) ; } }	are guaranteed to be non-null.
private range < k > coalescedrange ( range < k > range , v value ) { range < k > coalescedrange = range ; entry < cut < k > , rangemapentry < k , v > > lowerentry = entriesbylowerbound . lowerentry ( range . lowerbound ) ; coalescedrange = coalesce ( coalescedrange , value , lowerentry ) ; entry < cut < k > , rangemapentry < k , v > > higherentry = entriesbylowerbound . floorentry ( range . upperbound ) ; coalescedrange = coalesce ( coalescedrange , value , higherentry ) ; return coalescedrange ; }	Computes the coalesced range for the given range+value - does not mutate the map.
void unregister ( object listener ) { multimap < class < ? > , subscriber > listenermethods = findallsubscribers ( listener ) ; for ( entry < class < ? > , collection < subscriber > > entry : listenermethods . asmap ( ) . entryset ( ) ) { class < ? > eventtype = entry . getkey ( ) ; collection < subscriber > listenermethodsfortype = entry . getvalue ( ) ; copyonwritearrayset < subscriber > currentsubscribers = subscribers . get ( eventtype ) ; if ( currentsubscribers == null || ! currentsubscribers . removeall ( listenermethodsfortype ) ) {	Unregisters all subscribers on the given listener object.
iterator < subscriber > getsubscribers ( object event ) { immutableset < class < ? > > eventtypes = flattenhierarchy ( event . getclass ( ) ) ; list < iterator < subscriber > > subscriberiterators = lists . newarraylistwithcapacity ( eventtypes . size ( ) ) ; for ( class < ? > eventtype : eventtypes ) { copyonwritearrayset < subscriber > eventsubscribers = subscribers . get ( eventtype ) ; if ( eventsubscribers != null ) {	Gets an iterator representing an immutable snapshot of all subscribers to the given event atthe time this method is called.
private multimap < class < ? > , subscriber > findallsubscribers ( object listener ) { multimap < class < ? > , subscriber > methodsinlistener = hashmultimap . create ( ) ; class < ? > clazz = listener . getclass ( ) ; for ( method method : getannotatedmethods ( clazz ) ) { class < ? > [ ] parametertypes = method . getparametertypes ( ) ; class < ? > eventtype = parametertypes [ num_ ] ; methodsinlistener . put ( eventtype , subscriber . create ( bus , listener , method ) ) ; } return methodsinlistener ; }	Returns all subscribers for the given listener grouped by the type of event they subscribe to.
static < e > immutablelist < e > asimmutablelist ( object [ ] elements ) { return asimmutablelist ( elements , elements . length ) ; }	Views the array as an immutable list.
static < e > immutablelist < e > asimmutablelist ( object [ ] elements , int length ) { if ( length == num_ ) { return of ( ) ; } return new regularimmutablelist < e > ( elements , length ) ; }	Views the array as an immutable list.
@ beta public static < e > builder < e > builderwithexpectedsize ( int expectedsize ) { checknonnegative ( expectedsize , str_ ) ; return new immutablelist . builder < e > ( expectedsize ) ; }	Returns a new builder, expecting the specified number of elements to be added. If {.
private static wildcardtype canonicalizewildcardtype ( typevariable < ? > declaration , wildcardtype type ) { type [ ] declared = declaration . getbounds ( ) ; list < type > upperbounds = new arraylist < > ( ) ; for ( type bound : type . getupperbounds ( ) ) { if ( ! any ( declared ) . issubtypeof ( bound ) ) { upperbounds . add ( canonicalizewildcardsintype ( bound ) ) ; } } return new types . wildcardtypeimpl ( type . getlowerbounds ( ) , upperbounds . toarray ( new type [ num_ ] ) ) ; }	Just don't ever let the user access it.
static < e > immutablelist < e > asimmutablelist ( object [ ] elements , int length ) { switch ( length ) { case num_ : return of ( ) ; case num_ : return of ( ( e ) elements [ num_ ] ) ; default : if ( length < elements . length ) { elements = arrays . copyof ( elements , length ) ; } return new regularimmutablelist < e > ( elements ) ; } }	Views the array as an immutable list.
@ deprecated public static < k , v > immutablesortedmap . builder < k , v > builderwithexpectedsize ( int expectedsize ) { throw new unsupportedoperationexception ( ) ; }	Not supported for ImmutableSortedMap.
@ override public immutableset < entry < k , v > > entryset ( ) { immutableset < entry < k , v > > result = entryset ; return ( result == null ) ? entryset = createentryset ( ) : result ; }	Returns an immutable set of the mappings in this map.
@ canignorereturnvalue private boolean finishline ( boolean sawnewline ) throws ioexception { string separator = sawreturn ? ( sawnewline ? str_ : str_ ) : ( sawnewline ? str_ : str_ ) ; handleline ( line . tostring ( ) , separator ) ; line = new stringbuilder ( ) ; sawreturn = bool_ ; return sawnewline ; }	Called when a line is complete.
static < k , v1 , v2 > entrytransformer < k , v1 , v2 > asentrytransformer ( final function < ? super v1 , v2 > function ) { checknotnull ( function ) ; return new entrytransformer < k , v1 , v2 > ( ) { @ override public v2 transformentry ( k key , v1 value ) { return function . apply ( value ) ; } } ; }	Views a function as an entry transformer that ignores the entry key.
static < v2 , k , v1 > entry < k , v2 > transformentry ( final entrytransformer < ? super k , ? super v1 , v2 > transformer , final entry < k , v1 > entry ) { checknotnull ( transformer ) ; checknotnull ( entry ) ; return new abstractmapentry < k , v2 > ( ) { @ override public k getkey ( ) { return entry . getkey ( ) ; } @ override public v2 getvalue ( ) { return transformer . transformentry ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } ; }	Returns a view of an entry transformed by the specified transformer.
static < k , v1 , v2 > function < entry < k , v1 > , entry < k , v2 > > asentrytoentryfunction ( final entrytransformer < ? super k , ? super v1 , v2 > transformer ) { checknotnull ( transformer ) ; return new function < entry < k , v1 > , entry < k , v2 > > ( ) { @ override public entry < k , v2 > apply ( final entry < k , v1 > entry ) { return transformentry ( transformer , entry ) ; } } ; }	Views an entry transformer as a function from entries to entries.
static < e > immutablemap < e , integer > indexmap ( collection < e > list ) { immutablemap . builder < e , integer > builder = new immutablemap . builder < > ( list . size ( ) ) ; int i = num_ ; for ( e e : list ) { builder . put ( e , i ++ ) ; } return builder . build ( ) ; }	Returns a map from the ith element of list to i.
protected @ nullable string pendingtostring ( ) { object localvalue = value ; if ( localvalue instanceof setfuture ) { return str_ + userobjecttostring ( ( ( setfuture ) localvalue ) . future ) + str_ ; } else if ( this instanceof scheduledfuture ) { return str_ + ( ( scheduledfuture ) this ) . getdelay ( timeunit . milliseconds ) + str_ ; } return null ; }	Provide a human-readable explanation of why this future has not yet completed.
protected void update ( bytebuffer b ) { if ( b . hasarray ( ) ) { update ( b . array ( ) , b . arrayoffset ( ) + b . position ( ) , b . remaining ( ) ) ; b . position ( b . limit ( ) ) ; } else { for ( int remaining = b . remaining ( ) ; remaining > num_ ; remaining -- ) { update ( b . get ( ) ) ; } } }	Updates this hasher with bytes from the given buffer.
static < e > immutablesortedset < e > unsafedelegatesortedset ( sortedset < e > delegate , boolean issubset ) { return delegate . isempty ( ) ? emptyset ( delegate . comparator ( ) ) : new regularimmutablesortedset < e > ( delegate , issubset ) ; }	Assumes that delegate doesn't have null elements and comparator.
@ suppresswarnings ( str_ ) public static immutablesetmultimap < object , object > instantiate ( serializationstreamreader reader ) throws serializationexception { comparator < object > valuecomparator = ( comparator < object > ) reader . readobject ( ) ; immutablesetmultimap . builder < object , object > builder = immutablesetmultimap . builder ( ) ; if ( valuecomparator != null ) { builder . ordervaluesby ( valuecomparator ) ; } return ( immutablesetmultimap < object , object > ) multimap_customfieldserializerbase . instantiate ( reader , builder ) ; }	Serialization type safety is at the caller's mercy.
public long sum ( ) { long sum = num_ ; for ( atomiclong value : map . values ( ) ) { sum = sum + value . get ( ) ; } return sum ; }	Returns the sum of all values in this map.
private static class < ? > loadfinalizer ( finalizerloader ... loaders ) { for ( finalizerloader loader : loaders ) { class < ? > finalizer = loader . loadfinalizer ( ) ; if ( finalizer != null ) { return finalizer ; } } throw new assertionerror ( ) ; }	Iterates through the given loaders until it finds one that can load Finalizer.
public void dispatch ( ) {	Dispatches all events enqueued prior to this call, serially and in order, for every listener. Note: this method is idempotent and safe to call from any thread.
public static void copy ( url from , outputstream to ) throws ioexception { asbytesource ( from ) . copyto ( to ) ; }	Copies all bytes from a URL to an output stream.
public void post ( object event ) { iterator < subscriber > eventsubscribers = subscribers . getsubscribers ( event ) ; if ( eventsubscribers . hasnext ( ) ) { dispatcher . dispatch ( event , eventsubscribers ) ; } else if ( ! ( event instanceof deadevent ) ) {	Posts an event to all registered subscribers.
void setdelegates ( map < k , v > forward , map < v , k > backward ) { checkstate ( delegate == null ) ; checkstate ( inverse == null ) ; checkargument ( forward . isempty ( ) ) ; checkargument ( backward . isempty ( ) ) ; checkargument ( forward != backward ) ; delegate = forward ; inverse = makeinverse ( backward ) ; }	Specifies the delegate maps going in each direction.
@ override public void execute ( final runnable task ) { checknotnull ( task ) ; final runnable submittedtask ; final long oldruncount ; synchronized ( queue ) {	Adds a task to the queue and makes sure a worker thread is running.
public static < e extends comparable > treemultiset < e > create ( iterable < ? extends e > elements ) { treemultiset < e > multiset = create ( ) ; iterables . addall ( multiset , elements ) ; return multiset ; }	Creates an empty multiset containing the given initial elements, sorted according to theelements' natural order. This implementation is highly efficient when {.
private static boolean addcausalchain ( set < throwable > seen , throwable t ) { for ( ; t != null ; t = t . getcause ( ) ) { boolean firsttimeseen = seen . add ( t ) ; if ( ! firsttimeseen ) { return bool_ ; } } return bool_ ; }	Adds the chain to the seen set, and returns whether all the chain was new to us.
public threadfactorybuilder setpriority ( int priority ) {	Sets the priority for new threads created with this ThreadFactory.
public static hostandport fromparts ( string host , int port ) { checkargument ( isvalidport ( port ) , str_ , port ) ; hostandport parsedhost = fromstring ( host ) ; checkargument ( ! parsedhost . hasport ( ) , str_ , host ) ; return new hostandport ( parsedhost . host , port , parsedhost . hasbracketlesscolons ) ; }	Build a HostAndPort instance from separate host and port values.
public static hostandport fromhost ( string host ) { hostandport parsedhost = fromstring ( host ) ; checkargument ( ! parsedhost . hasport ( ) , str_ , host ) ; return parsedhost ; }	Build a HostAndPort instance from a host only.
public static hostandport fromstring ( string hostportstring ) { checknotnull ( hostportstring ) ; string host ; string portstring = null ; boolean hasbracketlesscolons = bool_ ; if ( hostportstring . startswith ( str_ ) ) { string [ ] hostandport = gethostandportfrombracketedhost ( hostportstring ) ; host = hostandport [ num_ ] ; portstring = hostandport [ num_ ] ; } else { int colonpos = hostportstring . indexof ( str_ ) ; if ( colonpos >= num_ && hostportstring . indexof ( str_ , colonpos + num_ ) == - num_ ) {	Split a freeform string into a host and port, without strict validation.
private static string [ ] gethostandportfrombracketedhost ( string hostportstring ) { int colonindex = num_ ; int closebracketindex = num_ ; checkargument ( hostportstring . charat ( num_ ) == str_ , str_ , hostportstring ) ; colonindex = hostportstring . indexof ( str_ ) ; closebracketindex = hostportstring . lastindexof ( str_ ) ; checkargument ( colonindex > - num_ && closebracketindex > colonindex , str_ , hostportstring ) ; string host = hostportstring . substring ( num_ , closebracketindex ) ; if ( closebracketindex + num_ == hostportstring . length ( ) ) { return new string [ ] { host , str_ } ; } else { checkargument ( hostportstring . charat ( closebracketindex + num_ ) == str_ , str_ , hostportstring ) ; for ( int i = closebracketindex + num_ ; i < hostportstring . length ( ) ; ++ i ) { checkargument ( character . isdigit ( hostportstring . charat ( i ) ) , str_ , hostportstring ) ; } return new string [ ] { host , hostportstring . substring ( closebracketindex + num_ ) } ; } }	Parses a bracketed host-port string, throwing IllegalArgumentException if parsing fails.
static < t > generalrange < t > all ( comparator < ? super t > comparator ) { return new generalrange < t > ( comparator , bool_ , null , open , bool_ , null , open ) ; }	Returns the whole range relative to the specified comparator.
generalrange < t > reverse ( ) { generalrange < t > result = reverse ; if ( result == null ) { result = new generalrange < t > ( ordering . from ( comparator ) . reverse ( ) , hasupperbound , getupperendpoint ( ) , getupperboundtype ( ) , haslowerbound , getlowerendpoint ( ) , getlowerboundtype ( ) ) ; result . reverse = this ; return this . reverse = result ; } return result ; }	Returns the same range relative to the reversed comparator.
static < e > immutableset < e > unsafedelegate ( set < e > delegate ) { switch ( delegate . size ( ) ) { case num_ : return of ( ) ; case num_ : return new singletonimmutableset < e > ( delegate . iterator ( ) . next ( ) ) ; default : return new regularimmutableset < e > ( delegate ) ; } }	the elements are known to be non-null.
public static < b > immutabletypetoinstancemap < b > of ( ) { return new immutabletypetoinstancemap < b > ( immutablemap . < typetoken < ? extends b > , b > of ( ) ) ; }	Returns an empty type to instance map.
private void abouttoacquire ( cycledetectinglock lock ) { if ( ! lock . isacquiredbycurrentthread ( ) ) { arraylist < lockgraphnode > acquiredlocklist = acquiredlocks . get ( ) ; lockgraphnode node = lock . getlockgraphnode ( ) ; node . checkacquiredlocks ( policy , acquiredlocklist ) ; acquiredlocklist . add ( node ) ; } }	CycleDetectingLock implementations must call this method before attempting to acquire the lock.
@ override public immutablerangeset < c > subrangeset ( range < c > range ) { if ( ! isempty ( ) ) { range < c > span = span ( ) ; if ( range . encloses ( span ) ) { return this ; } else if ( range . isconnected ( span ) ) { return new immutablerangeset < c > ( intersectranges ( range ) ) ; } } return of ( ) ; }	Returns a view of the intersection of this range set with the given range.
static < k , v > immutablemapentry < k , v > makeimmutable ( entry < k , v > entry , k key , v value ) { boolean reusable = entry instanceof immutablemapentry && ( ( immutablemapentry < k , v > ) entry ) . isreusable ( ) ; return reusable ? ( immutablemapentry < k , v > ) entry : new immutablemapentry < k , v > ( key , value ) ; }	Makes an entry usable internally by a new ImmutableMap without rereading its contents.
static < k , v > immutablemapentry < k , v > makeimmutable ( entry < k , v > entry ) { return makeimmutable ( entry , entry . getkey ( ) , entry . getvalue ( ) ) ; }	Makes an entry usable internally by a new ImmutableMap.
private static unicodeescaper wrap ( final charescaper escaper ) { return new unicodeescaper ( ) { @ override protected char [ ] escape ( int cp ) {	Private helper to wrap a CharEscaper as a UnicodeEscaper.
public void add ( double x , double y ) {	Adds the given pair of values to the dataset.
public static < k , v > immutablebimap < k , v > of ( k k1 , v v1 ) { checkentrynotnull ( k1 , v1 ) ; return new regularimmutablebimap < > ( new object [ ] { k1 , v1 } , num_ ) ; }	Returns an immutable bimap containing a single entry.
@ beta public static < k , v > immutablebimap < k , v > copyof ( iterable < ? extends entry < ? extends k , ? extends v > > entries ) { int estimatedsize = ( entries instanceof collection ) ? ( ( collection < ? > ) entries ) . size ( ) : immutablecollection . builder . default_initial_capacity ; return new builder < k , v > ( estimatedsize ) . putall ( entries ) . build ( ) ; }	Returns an immutable bimap containing the given entries.
@ suppresswarnings ( str_ ) public static < e > function < e , e > identity ( ) { return ( function < e , e > ) identityfunction . instance ; }	implementation is "fully variant"; E has become a "pass-through" type.
public static < t > function < t , boolean > forpredicate ( predicate < t > predicate ) { return new predicatefunction < t > ( predicate ) ; }	Creates a function that returns the same boolean output as the given predicate for all inputs. The returned function is consistent with equals (as documented at {.
@ suppresswarnings ( str_ )	Singleton placeholder that indicates a value is being loaded.
boolean isexpired ( referenceentry < k , v > entry , long now ) { checknotnull ( entry ) ; if ( expiresafteraccess ( ) && ( now - entry . getaccesstime ( ) >= expireafteraccessnanos ) ) { return bool_ ; } if ( expiresafterwrite ( ) && ( now - entry . getwritetime ( ) >= expireafterwritenanos ) ) { return bool_ ; } return bool_ ; }	Returns true if the entry has expired.
final long reserveandgetwaitlength ( int permits , long nowmicros ) { long momentavailable = reserveearliestavailable ( permits , nowmicros ) ; return max ( momentavailable - nowmicros , num_ ) ; }	Reserves next ticket and returns the wait time that the caller must wait for.
private void ensurecapacity ( int mincapacity ) { if ( nextinbucketktov . length < mincapacity ) { int oldcapacity = nextinbucketktov . length ; int newcapacity = immutablecollection . builder . expandedcapacity ( oldcapacity , mincapacity ) ; keys = arrays . copyof ( keys , newcapacity ) ; values = arrays . copyof ( values , newcapacity ) ; nextinbucketktov = expandandfillwithabsent ( nextinbucketktov , newcapacity ) ; nextinbucketvtok = expandandfillwithabsent ( nextinbucketvtok , newcapacity ) ; previninsertionorder = expandandfillwithabsent ( previninsertionorder , newcapacity ) ; nextininsertionorder = expandandfillwithabsent ( nextininsertionorder , newcapacity ) ; } if ( hashtablektov . length < mincapacity ) { int newtablesize = hashing . closedtablesize ( mincapacity , num_ ) ; hashtablektov = createfilledwithabsent ( newtablesize ) ; hashtablevtok = createfilledwithabsent ( newtablesize ) ; for ( int entrytorehash = num_ ; entrytorehash < size ; entrytorehash ++ ) { int keyhash = hashing . smearedhash ( keys [ entrytorehash ] ) ; int keybucket = bucket ( keyhash ) ; nextinbucketktov [ entrytorehash ] = hashtablektov [ keybucket ] ; hashtablektov [ keybucket ] = entrytorehash ; int valuehash = hashing . smearedhash ( values [ entrytorehash ] ) ; int valuebucket = bucket ( valuehash ) ; nextinbucketvtok [ entrytorehash ] = hashtablevtok [ valuebucket ] ; hashtablevtok [ valuebucket ] = entrytorehash ; } } }	Ensures that all of the internal structures in the HashBiMap are ready for this many elements.
private void insertintotablektov ( int entry , int keyhash ) { checkargument ( entry != absent ) ; int keybucket = bucket ( keyhash ) ; nextinbucketktov [ entry ] = hashtablektov [ keybucket ] ; hashtablektov [ keybucket ] = entry ; }	Updates the K-to-V hash table to include the entry at the specified index, which is assumed tohave not yet been added.
private void insertintotablevtok ( int entry , int valuehash ) { checkargument ( entry != absent ) ; int valuebucket = bucket ( valuehash ) ; nextinbucketvtok [ entry ] = hashtablevtok [ valuebucket ] ; hashtablevtok [ valuebucket ] = entry ; }	Updates the V-to-K hash table to include the entry at the specified index, which is assumed tohave not yet been added.
private void deletefromtablektov ( int entry , int keyhash ) { checkargument ( entry != absent ) ; int keybucket = bucket ( keyhash ) ; if ( hashtablektov [ keybucket ] == entry ) { hashtablektov [ keybucket ] = nextinbucketktov [ entry ] ; nextinbucketktov [ entry ] = absent ; return ; } int previnbucket = hashtablektov [ keybucket ] ; for ( int entryinbucket = nextinbucketktov [ previnbucket ] ; entryinbucket != absent ; entryinbucket = nextinbucketktov [ entryinbucket ] ) { if ( entryinbucket == entry ) { nextinbucketktov [ previnbucket ] = nextinbucketktov [ entry ] ; nextinbucketktov [ entry ] = absent ; return ; } previnbucket = entryinbucket ; } throw new assertionerror ( str_ + keys [ entry ] ) ; }	Updates the K-to-V hash table to remove the entry at the specified index, which is assumed tobe present.
private void deletefromtablevtok ( int entry , int valuehash ) { checkargument ( entry != absent ) ; int valuebucket = bucket ( valuehash ) ; if ( hashtablevtok [ valuebucket ] == entry ) { hashtablevtok [ valuebucket ] = nextinbucketvtok [ entry ] ; nextinbucketvtok [ entry ] = absent ; return ; } int previnbucket = hashtablevtok [ valuebucket ] ; for ( int entryinbucket = nextinbucketvtok [ previnbucket ] ; entryinbucket != absent ; entryinbucket = nextinbucketvtok [ entryinbucket ] ) { if ( entryinbucket == entry ) { nextinbucketvtok [ previnbucket ] = nextinbucketvtok [ entry ] ; nextinbucketvtok [ entry ] = absent ; return ; } previnbucket = entryinbucket ; } throw new assertionerror ( str_ + values [ entry ] ) ; }	Updates the V-to-K hash table to remove the entry at the specified index, which is assumed tobe present.
private void removeentry ( int entry , int keyhash , int valuehash ) { checkargument ( entry != absent ) ; deletefromtablektov ( entry , keyhash ) ; deletefromtablevtok ( entry , valuehash ) ; int oldpredecessor = previninsertionorder [ entry ] ; int oldsuccessor = nextininsertionorder [ entry ] ; setsucceeds ( oldpredecessor , oldsuccessor ) ; moveentrytoindex ( size - num_ , entry ) ; keys [ size - num_ ] = null ; values [ size - num_ ] = null ; size -- ; modcount ++ ; }	Removes the entry at the specified index, given the hash of its key and value.
void removeentrykeyhashknown ( int entry , int keyhash ) { removeentry ( entry , keyhash , hashing . smearedhash ( values [ entry ] ) ) ; }	Removes the entry at the specified index, given the hash of its key.
void removeentryvaluehashknown ( int entry , int valuehash ) { removeentry ( entry , hashing . smearedhash ( keys [ entry ] ) , valuehash ) ; }	Removes the entry at the specified index, given the hash of its value.
public networkbuilder < n , e > expectednodecount ( int expectednodecount ) { this . expectednodecount = optional . of ( checknonnegative ( expectednodecount ) ) ; return this ; }	Specifies the expected number of nodes in the network.
public networkbuilder < n , e > expectededgecount ( int expectededgecount ) { this . expectededgecount = optional . of ( checknonnegative ( expectededgecount ) ) ; return this ; }	Specifies the expected number of edges in the network.
@ override public string getsqlwithvalues ( ) { if ( namedparametervalues . size ( ) == num_ ) { return super . getsqlwithvalues ( ) ; } final stringbuilder result = new stringbuilder ( ) ; final string statementquery = getstatementquery ( ) ;	Generates the query for the callable statement with all parameter placeholdersreplaced with the actual parameter values.
public void setparametervalue ( final string name , final object value ) { namedparametervalues . put ( name , new value ( value ) ) ; }	Records the value of a parameter.
public static byte [ ] objecttoblob ( object o ) { try { return serializercontext . getinstance ( ) . serialize ( o ) ; } catch ( serializerexception e ) { throw new runtimeexception ( e ) ; } }	java Object to bytes.
public static < t > t blobtoobject ( byte [ ] blob , class < t > type ) { try { return serializercontext . getinstance ( ) . deserialize ( blob , type ) ; } catch ( serializerexception e ) { throw new illegalstateexception ( e ) ; } }	bytes to java object.
@ bean @ conditionalonclass ( name = str_ ) public redistemplate < string , object > functiondomainredistemplate ( redisconnectionfactory redisconnectionfactory ) { jdkserializationredisserializer serializationredisserializer = new jdkserializationredisserializer ( ) ; stringredisserializer stringredisserializer = new stringredisserializer ( ) ; redistemplate < string , object > redistemplate = new redistemplate < > ( ) ; redistemplate . setkeyserializer ( stringredisserializer ) ; redistemplate . sethashkeyserializer ( stringredisserializer ) ; redistemplate . sethashvalueserializer ( serializationredisserializer ) ; redistemplate . setvalueserializer ( serializationredisserializer ) ; redistemplate . setconnectionfactory ( redisconnectionfactory ) ; return redistemplate ; }	default configuration redis template when have RedisConnectionFactory.
public string appmapstring ( ) { if ( hasgroup ( ) ) { string appmap = optional . ofnullable ( this . fields . get ( tracingconstants . app_map ) ) . orelse ( str_ ) ; log . debug ( str_ , appmap ) ; return appmap ; } raisenongroupexception ( ) ; return str_ ; }	String Type App map.
public static url locateonclasspath ( string filename ) { url result ;	Locates a file on the classpath.
public static connectioninformation fromconnection ( connection connection ) { final connectioninformation connectioninformation = new connectioninformation ( ) ; connectioninformation . connection = connection ; return connectioninformation ; }	This method should only be used in test scenarios.
public integer mapthrowable ( final throwable throwable ) { throwable throwabletocheck = throwable ; int depthtogo = num_ ; while ( bool_ ) { integer resid = mapthrowableflat ( throwabletocheck ) ; if ( resid != null ) { return resid ; } else { throwabletocheck = throwabletocheck . getcause ( ) ; depthtogo -- ; if ( depthtogo <= num_ || throwabletocheck == throwable || throwabletocheck == null ) { log . d ( str_ , str_ + throwable ) ;	Looks at the exception and its causes trying to find an ID.
public static eventbus getdefault ( ) { eventbus instance = defaultinstance ; if ( instance == null ) { synchronized ( eventbus . class ) { instance = eventbus . defaultinstance ; if ( instance == null ) { instance = eventbus . defaultinstance = new eventbus ( ) ; } } } return instance ; }	Convenience singleton for apps using a process-wide EventBus instance.
private void subscribe ( object subscriber , subscribermethod subscribermethod ) { class < ? > eventtype = subscribermethod . eventtype ; subscription newsubscription = new subscription ( subscriber , subscribermethod ) ; copyonwritearraylist < subscription > subscriptions = subscriptionsbyeventtype . get ( eventtype ) ; if ( subscriptions == null ) { subscriptions = new copyonwritearraylist < > ( ) ; subscriptionsbyeventtype . put ( eventtype , subscriptions ) ; } else { if ( subscriptions . contains ( newsubscription ) ) { throw new eventbusexception ( str_ + subscriber . getclass ( ) + str_ + eventtype ) ; } } int size = subscriptions . size ( ) ; for ( int i = num_ ; i <= size ; i ++ ) { if ( i == size || subscribermethod . priority > subscriptions . get ( i ) . subscribermethod . priority ) { subscriptions . add ( i , newsubscription ) ; break ; } } list < class < ? > > subscribedevents = typesbysubscriber . get ( subscriber ) ; if ( subscribedevents == null ) { subscribedevents = new arraylist < > ( ) ; typesbysubscriber . put ( subscriber , subscribedevents ) ; } subscribedevents . add ( eventtype ) ; if ( subscribermethod . sticky ) { if ( eventinheritance ) {	Must be called in synchronized block.
private void unsubscribebyeventtype ( object subscriber , class < ? > eventtype ) { list < subscription > subscriptions = subscriptionsbyeventtype . get ( eventtype ) ; if ( subscriptions != null ) { int size = subscriptions . size ( ) ; for ( int i = num_ ; i < size ; i ++ ) { subscription subscription = subscriptions . get ( i ) ; if ( subscription . subscriber == subscriber ) { subscription . active = bool_ ; subscriptions . remove ( i ) ; i -- ; size -- ; } } } }	Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
public synchronized void unregister ( object subscriber ) { list < class < ? > > subscribedtypes = typesbysubscriber . get ( subscriber ) ; if ( subscribedtypes != null ) { for ( class < ? > eventtype : subscribedtypes ) { unsubscribebyeventtype ( subscriber , eventtype ) ; } typesbysubscriber . remove ( subscriber ) ; } else { logger . log ( level . warning , str_ + subscriber . getclass ( ) ) ; } }	Unregisters the given subscriber from all event classes.
public void post ( object event ) { postingthreadstate postingstate = currentpostingthreadstate . get ( ) ; list < object > eventqueue = postingstate . eventqueue ; eventqueue . add ( event ) ; if ( ! postingstate . isposting ) { postingstate . ismainthread = ismainthread ( ) ; postingstate . isposting = bool_ ; if ( postingstate . canceled ) { throw new eventbusexception ( str_ ) ; } try { while ( ! eventqueue . isempty ( ) ) { postsingleevent ( eventqueue . remove ( num_ ) , postingstate ) ; } } finally { postingstate . isposting = bool_ ; postingstate . ismainthread = bool_ ; } } }	Posts the given event to the event bus.
public < t > t getstickyevent ( class < t > eventtype ) { synchronized ( stickyevents ) { return eventtype . cast ( stickyevents . get ( eventtype ) ) ; } }	Gets the most recent sticky event for the given type.
public < t > t removestickyevent ( class < t > eventtype ) { synchronized ( stickyevents ) { return eventtype . cast ( stickyevents . remove ( eventtype ) ) ; } }	Remove and gets the recent sticky event for the given event type.
public boolean removestickyevent ( object event ) { synchronized ( stickyevents ) { class < ? > eventtype = event . getclass ( ) ; object existingevent = stickyevents . get ( eventtype ) ; if ( event . equals ( existingevent ) ) { stickyevents . remove ( eventtype ) ; return bool_ ; } else { return bool_ ; } } }	Removes the sticky event if it equals to the given event.
private static list < class < ? > > lookupalleventtypes ( class < ? > eventclass ) { synchronized ( eventtypescache ) { list < class < ? > > eventtypes = eventtypescache . get ( eventclass ) ; if ( eventtypes == null ) { eventtypes = new arraylist < > ( ) ; class < ? > clazz = eventclass ; while ( clazz != null ) { eventtypes . add ( clazz ) ; addinterfaces ( eventtypes , clazz . getinterfaces ( ) ) ; clazz = clazz . getsuperclass ( ) ; } eventtypescache . put ( eventclass , eventtypes ) ; } return eventtypes ; } }	Looks up all Class objects including super classes and interfaces.
static void addinterfaces ( list < class < ? > > eventtypes , class < ? > [ ] interfaces ) { for ( class < ? > interfaceclass : interfaces ) { if ( ! eventtypes . contains ( interfaceclass ) ) { eventtypes . add ( interfaceclass ) ; addinterfaces ( eventtypes , interfaceclass . getinterfaces ( ) ) ; } } }	Recurses through super interfaces.
public eventbusbuilder addindex ( subscriberinfoindex index ) { if ( subscriberinfoindexes == null ) { subscriberinfoindexes = new arraylist < > ( ) ; } subscriberinfoindexes . add ( index ) ; return this ; }	Adds an index generated by EventBus' annotation preprocessor.
public static void attachto ( activity activity , boolean finishafterdialog , bundle argumentsforerrordialog ) { object executionscope = activity . getclass ( ) ; attachto ( activity , executionscope , finishafterdialog , argumentsforerrordialog ) ; }	Scope is limited to the activity's class.
protected t prepareerrorfragment ( throwablefailureevent event , boolean finishafterdialog , bundle argumentsforerrordialog ) { if ( event . issuppresserrorui ( ) ) {	Prepares the fragment's arguments and creates the fragment.
protected string gettitlefor ( throwablefailureevent event , bundle arguments ) { return config . resources . getstring ( config . defaulttitleid ) ; }	May be overridden to provide custom error title.
protected string getmessagefor ( throwablefailureevent event , bundle arguments ) { int msgresid = config . getmessageidforthrowable ( event . throwable ) ; return config . resources . getstring ( msgresid ) ; }	May be overridden to provide custom error messages.
static < t , f > boolean postcompletedrain ( long n , subscriber < ? super t > actual , queue < t > queue , atomiclongfieldupdater < f > field , f instance , booleansupplier iscancelled ) {	Drains the queue either in a pre- or post-complete state.
@ nullable final t blockingget ( long timeout , timeunit unit ) { if ( schedulers . isinnonblockingthread ( ) ) { throw new illegalstateexception ( str_ + thread . currentthread ( ) . getname ( ) ) ; } if ( getcount ( ) != num_ ) { try { if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw new illegalstateexception ( str_ + timeout + str_ + unit ) ; } } catch ( interruptedexception ex ) { dispose ( ) ; runtimeexception re = exceptions . propagate ( ex ) ;	Block until the first value arrives and return it, otherwisereturn null for an empty source and rethrow any exception.
public final mono < t > elementat ( int index , t defaultvalue ) { return mono . onassembly ( new monoelementat < > ( this , index , defaultvalue ) ) ; }	Emit only the element at the given index position or fall back to adefault value if the sequence is shorter. .
public final flux < t > onerrorresume ( function < ? super throwable , ? extends publisher < ? extends t > > fallback ) { return onassembly ( new fluxonerrorresume < > ( this , fallback ) ) ; }	Subscribe to a returned fallback publisher when any error occurs, using a function tochoose the fallback depending on the error. .
public final flux < t > repeat ( long numrepeat , booleansupplier predicate ) { if ( numrepeat < num_ ) { throw new illegalargumentexception ( str_ ) ; } if ( numrepeat == num_ ) { return this ; } return defer ( ( ) -> repeat ( countingbooleansupplier ( predicate , numrepeat ) ) ) ; }	Repeatedly subscribe to the source if the predicate returns true after completion of the previoussubscription.
static < t > mono < t > converttomono ( callable < t > supplier ) { if ( supplier instanceof fuseable . scalarcallable ) { fuseable . scalarcallable < t > scalarcallable = ( fuseable . scalarcallable < t > ) supplier ; t v ; try { v = scalarcallable . call ( ) ; } catch ( exception e ) { return mono . error ( e ) ; } if ( v == null ) { return mono . empty ( ) ; } return mono . just ( v ) ; } return mono . onassembly ( new monocallable < > ( supplier ) ) ; }	Returns the appropriate Mono instance for a known Supplier Flux.
static long getandsub ( ringbuffer . sequence sequence , long tosub ) { long r , u ; do { r = sequence . getaslong ( ) ; if ( r == num_ || r == long . max_value ) { return r ; } u = operators . suborzero ( r , tosub ) ; } while ( ! sequence . compareandset ( r , u ) ) ; return r ; }	Concurrent subtraction bound to 0 and Long.MAX_VALUE.
@ suppresswarnings ( str_ ) @ nullable public static < t > queuesubscription < t > as ( subscription s ) { if ( s instanceof queuesubscription ) { return ( queuesubscription < t > ) s ; } return null ; }	Returns the subscription as QueueSubscription if possible or null.
public static void error ( subscriber < ? > s , throwable e ) { s . onsubscribe ( emptysubscription . instance ) ; s . onerror ( e ) ; }	Calls onSubscribe on the target Subscriber with the empty instance followed by a call to onError with thesupplied error.
public static < t > long produced ( atomiclongfieldupdater < t > updater , t instance , long tosub ) { long r , u ; do { r = updater . get ( instance ) ; if ( r == num_ || r == long . max_value ) { return r ; } u = suborzero ( r , tosub ) ; } while ( ! updater . compareandset ( instance , r , u ) ) ; return u ; }	Concurrent subtraction bound to 0, mostly used to decrement a request tracker bythe amount produced by the operator.
public static < t > subscription scalarsubscription ( coresubscriber < ? super t > subscriber , t value ) { return new scalarsubscription < > ( subscriber , value ) ; }	Represents a fuseable Subscription that emits a single constant value synchronouslyto a Subscriber or consumer.
< u > monoignorethen < u > shift ( mono < u > newlast ) { objects . requirenonnull ( newlast , str_ ) ; publisher < ? > [ ] a = ignore ; int n = a . length ; publisher < ? > [ ] b = new publisher [ n + num_ ] ; system . arraycopy ( a , num_ , b , num_ , n ) ; b [ n ] = last ; return new monoignorethen < > ( b , newlast ) ; }	Shifts the current last Mono into the ignore array and sets up a new last Mono instance.
public static waitstrategy phasedoffsleep ( long spintimeout , long yieldtimeout , timeunit units ) { return phasedoff ( spintimeout , yieldtimeout , units , parking ( num_ ) ) ; }	Block by parking in a loop.
public final mono < void > and ( publisher < ? > other ) { if ( this instanceof monowhen ) { @ suppresswarnings ( str_ ) monowhen o = ( monowhen ) this ; mono < void > result = o . whenadditionalsource ( other ) ; if ( result != null ) { return result ; } } return when ( this , other ) ; }	Join the termination signals from this mono and another source into the returnedvoid mono .
public final mono < t > defaultifempty ( t defaultv ) { if ( this instanceof fuseable . scalarcallable ) { try { t v = block ( ) ; if ( v == null ) { return mono . just ( defaultv ) ; } } catch ( throwable e ) {	Provide a default single value if this mono is completed without any data .
public final mono < t > or ( mono < ? extends t > other ) { if ( this instanceof monofirst ) { monofirst < t > a = ( monofirst < t > ) this ; mono < t > result = a . oradditionalsource ( other ) ; if ( result != null ) { return result ; } } return first ( this , other ) ; }	Emit the first available result from this mono or the other mono. .
public final mono < t > onerrorresume ( function < ? super throwable , ? extends mono < ? extends t > > fallback ) { return onassembly ( new monoonerrorresume < > ( this , fallback ) ) ; }	Subscribe to a fallback publisher when any error occurs, using a function tochoose the fallback depending on the error. .
static final map < string , function < ? super publisher < object > , ? extends publisher < object > > > getoneachoperatorhooks ( ) { return collections . unmodifiablemap ( oneachoperatorhooks ) ; }	Immutable views on hook trackers, for testing purpose.
@ suppresswarnings ( str_ ) monodelayuntil < t > copywithnewtriggergenerator ( boolean delayerror , function < ? super t , ? extends publisher < ? > > triggergenerator ) { objects . requirenonnull ( triggergenerator , str_ ) ; function < ? super t , ? extends publisher < ? > > [ ] oldtriggers = this . othergenerators ; function < ? super t , ? extends publisher < ? > > [ ] newtriggers = new function [ oldtriggers . length + num_ ] ; system . arraycopy ( oldtriggers , num_ , newtriggers , num_ , oldtriggers . length ) ; newtriggers [ oldtriggers . length ] = triggergenerator ; return new monodelayuntil < > ( this . source , newtriggers ) ; }	Add a trigger generator to wait for.
static < q , s > void drainmaxloop ( queue < q > q , subscriber < ? super s > a , boolean delayerror , disposable dispose , queuedrainsubscriber < ? , q , s > qd ) { int missed = num_ ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; q v = q . poll ( ) ; boolean empty = v == null ; if ( checkterminated ( d , empty , a , delayerror , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != num_ ) { if ( qd . accept ( a , v ) ) { if ( r != long . max_value ) { qd . produced ( num_ ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onerror ( exceptions . failwithoverflow ( str_ ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == num_ ) { break ; } } }	Drain the queue but give up with an error if there aren't enough requests.
public final < u > u as ( function < ? super parallelflux < t > , u > converter ) { return converter . apply ( this ) ; }	Perform a fluent transformation to a value via a converter function which receivesthis ParallelFlux.
public final < c > parallelflux < c > collect ( supplier < ? extends c > collectionsupplier , biconsumer < ? super c , ? super t > collector ) { return onassembly ( new parallelcollect < > ( this , collectionsupplier , collector ) ) ; }	Collect the elements in each rail into a collection supplied via acollectionSupplier and collected into with a collector action, emitting thecollection at the end.
public final < r > parallelflux < r > concatmap ( function < ? super t , ? extends publisher < ? extends r > > mapper ) { return concatmap ( mapper , num_ , errormode . immediate ) ; }	Generates and concatenates Publishers on each 'rail', signalling errors immediatelyand generating 2 publishers upfront.
public final parallelflux < t > dooncancel ( runnable oncancel ) { objects . requirenonnull ( oncancel , str_ ) ; return doonsignal ( this , null , null , null , null , null , null , null , oncancel ) ; }	Run the specified runnable when a 'rail' receives a cancellation.
public final parallelflux < t > dooncomplete ( runnable oncomplete ) { objects . requirenonnull ( oncomplete , str_ ) ; return doonsignal ( this , null , null , null , oncomplete , null , null , null , null ) ; }	Run the specified runnable when a 'rail' completes.
public final parallelflux < t > doonerror ( consumer < ? super throwable > onerror ) { objects . requirenonnull ( onerror , str_ ) ; return doonsignal ( this , null , null , onerror , null , null , null , null , null ) ; }	Call the specified consumer with the exception passing through any 'rail'.
public final parallelflux < t > doonrequest ( longconsumer onrequest ) { objects . requirenonnull ( onrequest , str_ ) ; return doonsignal ( this , null , null , null , null , null , null , onrequest , null ) ; }	Call the specified consumer with the request amount if any rail receives arequest.
public final < r > parallelflux < r > flatmap ( function < ? super t , ? extends publisher < ? extends r > > mapper , boolean delayerror , int maxconcurrency , int prefetch ) { return onassembly ( new parallelflatmap < > ( this , mapper , delayerror , maxconcurrency , queues . get ( maxconcurrency ) , prefetch , queues . get ( prefetch ) ) ) ; }	Generates and flattens Publishers on each 'rail', optionally delaying errors,having a total number of simultaneous subscriptions to the inner Publishers andusing the given prefetch amount for the inner Publishers.
public final flux < t > sequential ( int prefetch ) { return flux . onassembly ( new parallelmergesequential < > ( this , prefetch , queues . get ( prefetch ) ) ) ; }	Merges the values from each 'rail' in a round-robin or same-order fashion andexposes it as a regular Publisher sequence, running with a give prefetch value forthe rails.
protected final boolean validate ( subscriber < ? > [ ] subscribers ) { int p = parallelism ( ) ; if ( subscribers . length != p ) { illegalargumentexception iae = new illegalargumentexception ( str_ + str_ + p + str_ + subscribers . length ) ; for ( subscriber < ? > s : subscribers ) { operators . error ( s , iae ) ; } return bool_ ; } return bool_ ; }	Validates the number of subscribers and returns true if their number matches theparallelism level of this ParallelFlux.
final < r > parallelflux < r > concatmap ( function < ? super t , ? extends publisher < ? extends r > > mapper , int prefetch , errormode errormode ) { return onassembly ( new parallelconcatmap < > ( this , mapper , queues . get ( prefetch ) , prefetch , errormode ) ) ; }	Generates and concatenates Publishers on each 'rail', optionally delaying errorsand using the given prefetch amount for generating Publishers upfront.
final < r > parallelflux < r > concatmapdelayerror ( function < ? super t , ? extends publisher < ? extends r > > mapper , boolean delayuntilend , int prefetch ) { return concatmap ( mapper , prefetch , delayuntilend ? errormode . end : errormode . boundary ) ; }	Generates and concatenates Publishers on each 'rail', delaying errorsand using the given prefetch amount for generating Publishers upfront.
@ nullable public static < t > throwable terminate ( atomicreferencefieldupdater < t , throwable > field , t instance ) { throwable current = field . get ( instance ) ; if ( current != terminated ) { current = field . getandset ( instance , terminated ) ; } return current ; }	Atomic utility to safely mark a volatile throwable reference with a terminalmarker.
void log ( signaltype signaltype , object signalvalue ) { string line = fuseable ? log_template_fuseable : log_template ; if ( operatorline != null ) { line = line + str_ + operatorline ; } if ( level == level . finest ) { log . trace ( line , signaltype , signalvalue ) ; } else if ( level == level . fine ) { log . debug ( line , signaltype , signalvalue ) ; } else if ( level == level . info ) { log . info ( line , signaltype , signalvalue ) ; } else if ( level == level . warning ) { log . warn ( line , signaltype , signalvalue ) ; } else if ( level == level . severe ) { log . error ( line , signaltype , signalvalue ) ; } }	Structured logging with level adaptation and operator ascii graph if required.
public boolean start ( final filedownloadlistener listener , final boolean isserial ) { if ( listener == null ) { filedownloadlog . w ( this , str_ + str_ , isserial ) ; return bool_ ; } return isserial ? getqueueshandler ( ) . startqueueserial ( listener ) : getqueueshandler ( ) . startqueueparallel ( listener ) ; }	Start the download queue by the same listener.
public void pauseall ( ) { filedownloadtasklauncher . getimpl ( ) . expireall ( ) ; final basedownloadtask . irunningtask [ ] downloadlist = filedownloadlist . getimpl ( ) . copy ( ) ; for ( basedownloadtask . irunningtask task : downloadlist ) { task . getorigin ( ) . pause ( ) ; }	Pause all tasks running in FileDownloader.
public long getsofar ( final int downloadid ) { basedownloadtask . irunningtask task = filedownloadlist . getimpl ( ) . get ( downloadid ) ; if ( task == null ) { return filedownloadserviceproxy . getimpl ( ) . getsofar ( downloadid ) ; } return task . getorigin ( ) . getlargefilesofarbytes ( ) ; }	Get downloaded bytes so far by the downloadId.
public boolean unbindserviceifidle ( ) {	Unbind and stop the downloader service when there is no task running in the FileDownloader.
public boolean setmaxnetworkthreadcount ( final int count ) { if ( ! filedownloadlist . getimpl ( ) . isempty ( ) ) { filedownloadlog . w ( this , str_ + str_ + str_ + str_ ) ; return bool_ ; } return filedownloadserviceproxy . getimpl ( ) . setmaxnetworkthreadcount ( count ) ; }	Set the maximum count of the network thread, what is the number of simultaneous downloads inFileDownloader.
public void pauseall ( ) { list < integer > list = mthreadpool . getallexactrunningdownloadids ( ) ; if ( filedownloadlog . need_log ) { filedownloadlog . d ( this , str_ , list . size ( ) ) ; } for ( integer id : list ) { pause ( id ) ; } }	Pause all running task.
public void start ( ) { for ( basedownloadtask task : tasks ) { task . setlistener ( target ) ; if ( autoretrytimes != null ) { task . setautoretrytimes ( autoretrytimes ) ; } if ( synccallback != null ) { task . setsynccallback ( synccallback ) ; } if ( isforceredownload != null ) { task . setforceredownload ( isforceredownload ) ; } if ( callbackprogresstimes != null ) { task . setcallbackprogresstimes ( callbackprogresstimes ) ; } if ( callbackprogressminintervalmillis != null ) { task . setcallbackprogressmininterval ( callbackprogressminintervalmillis ) ; } if ( tag != null ) { task . settag ( tag ) ; } if ( taskfinishlistenerlist != null ) { for ( basedownloadtask . finishlistener finishlistener : taskfinishlistenerlist ) { task . addfinishlistener ( finishlistener ) ; } } if ( this . directory != null ) { task . setpath ( this . directory , bool_ ) ; } if ( this . iswifirequired != null ) { task . setwifirequired ( this . iswifirequired ) ; } task . asinqueuetask ( ) . enqueue ( ) ; } filedownloader . getimpl ( ) . start ( target , isserial ) ; }	Start tasks in a queue.
void divertandignoreduplicate ( @ suppresswarnings ( str_ ) final list < basedownloadtask . irunningtask > destination ) { synchronized ( mlist ) { for ( basedownloadtask . irunningtask irunningtask : mlist ) { if ( ! destination . contains ( irunningtask ) ) { destination . add ( irunningtask ) ; } } mlist . clear ( ) ; } }	Divert all data in list 2 destination list.
void addunchecked ( final basedownloadtask . irunningtask task ) { if ( task . ismarkedadded2list ( ) ) { return ; } synchronized ( mlist ) { if ( mlist . contains ( task ) ) { filedownloadlog . w ( this , str_ , task ) ; } else { task . markadded2list ( ) ; mlist . add ( task ) ; if ( filedownloadlog . need_log ) { filedownloadlog . v ( this , str_ , task , task . getorigin ( ) . getstatus ( ) , mlist . size ( ) ) ; } } } }	This method generally used for enqueuing the task which will be assembled by a queue.
public void pause ( ) { synchronized ( finishcallback ) { if ( paused ) { filedownloadlog . w ( this , str_ + str_ , mtasks . size ( ) ) ; return ; } paused = bool_ ; mtasks . drainto ( pausedlist ) ; if ( workingtask != null ) { workingtask . removefinishlistener ( finishcallback ) ; workingtask . pause ( ) ; } } }	Pause the queue.
public void resume ( ) { synchronized ( finishcallback ) { if ( ! paused ) { filedownloadlog . w ( this , str_ + str_ , mtasks . size ( ) ) ; return ; } paused = bool_ ; mtasks . addall ( pausedlist ) ; pausedlist . clear ( ) ; if ( workingtask == null ) { sendnext ( ) ; } else { workingtask . addfinishlistener ( finishcallback ) ; workingtask . start ( ) ; } } }	Resume the queue if the queue is paused.
public static boolean isacceptrange ( int responsecode , filedownloadconnection connection ) { if ( responsecode == httpurlconnection . http_partial || responsecode == filedownloadconnection . response_code_from_offset ) return bool_ ; final string acceptranges = connection . getresponseheaderfield ( str_ ) ; return str_ . equals ( acceptranges ) ; }	accept range is effect by response code and Accept-Ranges header field.
public static long findinstancelengthfortrial ( filedownloadconnection connection ) { long length = findinstancelengthfromcontentrange ( connection ) ; if ( length < num_ ) { length = total_value_in_chunked_resource ; filedownloadlog . w ( filedownloadutils . class , str_ + str_ ) ; }	content-length.
public void setanimated ( boolean animated ) { misanimated = animated ; mopenanimatorset . setduration ( animated ? animation_duration : num_ ) ; mcloseanimatorset . setduration ( animated ? animation_duration : num_ ) ; }	Sets whether open and close actions should be animated.
@ targetapi ( build . version_codes . lollipop ) public void setelevationcompat ( float elevation ) { mshadowcolor = num_ ; mshadowradius = math . round ( elevation / num_ ) ; mshadowxoffset = num_ ; mshadowyoffset = math . round ( mfabsize == size_normal ? elevation : elevation / num_ ) ; if ( util . haslollipop ( ) ) { super . setelevation ( elevation ) ; musingelevationcompat = bool_ ; mshowshadow = bool_ ; updatebackground ( ) ; viewgroup . layoutparams layoutparams = getlayoutparams ( ) ; if ( layoutparams != null ) { setlayoutparams ( layoutparams ) ; } } else { mshowshadow = bool_ ; updatebackground ( ) ; } }	Sets the shadow color and radius to mimic the native elevation.
public void setlabelcolors ( int colornormal , int colorpressed , int colorripple ) { label label = getlabelview ( ) ; int left = label . getpaddingleft ( ) ; int top = label . getpaddingtop ( ) ; int right = label . getpaddingright ( ) ; int bottom = label . getpaddingbottom ( ) ; label . setcolors ( colornormal , colorpressed , colorripple ) ; label . updatebackground ( ) ; label . setpadding ( left , top , right , bottom ) ; }	Set the label's background colors.
@ override public void addconfigurationproperties ( properties properties ) { suppressdate = istrue ( properties . getproperty ( propertyregistry . comment_generator_suppress_date ) ) ; suppressallcomments = istrue ( properties . getproperty ( propertyregistry . comment_generator_suppress_all_comments ) ) ; }	Adds properties for this instance from any properties configured in theCommentGenerator configuration.This method will be called before any of the other methods.
@ override public string getfullyqualifiedname ( ) { string fullyqualifiedname = super . getfullyqualifiedname ( ) ; string before = fullyqualifiedname . substring ( num_ , fullyqualifiedname . lastindexof ( str_ ) ) ; string end = fullyqualifiedname . substring ( fullyqualifiedname . lastindexof ( str_ ) ) ; return before + str_ + outertype + end ; }	This method returns the fully qualified name - including any generic type parameters.
public static element getselectkey ( introspectedcolumn introspectedcolumn , generatedkey generatedkey ) { return getselectkey ( introspectedcolumn , generatedkey , null ) ; }	This method should return an XmlElement for the select key used toautomatically generate keys.
public packageresourcetable newframeworkresourcetable ( resourcepath resourcepath ) { return perfstatscollector . getinstance ( ) . measure ( str_ , ( ) -> { packageresourcetable resourcetable = new packageresourcetable ( str_ ) ; if ( resourcepath . getrclass ( ) != null ) { addrclassvalues ( resourcetable , resourcepath . getrclass ( ) ) ; addmissingstyleableattributes ( resourcetable , resourcepath . getrclass ( ) ) ; } if ( resourcepath . getinternalrclass ( ) != null ) { addrclassvalues ( resourcetable , resourcepath . getinternalrclass ( ) ) ; addmissingstyleableattributes ( resourcetable , resourcepath . getinternalrclass ( ) ) ; } parseresourcefiles ( resourcepath , resourcetable ) ; return resourcetable ; } ) ; }	Builds an Android framework resource table in the "android" package space.
public packageresourcetable newresourcetable ( string packagename , resourcepath ... resourcepaths ) { return perfstatscollector . getinstance ( ) . measure ( str_ , ( ) -> { packageresourcetable resourcetable = new packageresourcetable ( packagename ) ; for ( resourcepath resourcepath : resourcepaths ) { if ( resourcepath . getrclass ( ) != null ) { addrclassvalues ( resourcetable , resourcepath . getrclass ( ) ) ; } } for ( resourcepath resourcepath : resourcepaths ) { parseresourcefiles ( resourcepath , resourcetable ) ; } return resourcetable ; } ) ; }	Creates an application resource table which can be constructed with multiple resources pathsrepresenting overlayed resource libraries.
private void addmissingstyleableattributes ( packageresourcetable resourcetable , class < ? > rclass ) { for ( class innerclass : rclass . getclasses ( ) ) { if ( innerclass . getsimplename ( ) . equals ( str_ ) ) { string styleablename = null ;	Check the stylable elements.
public static void setwifion ( boolean ison ) { settings . global . putint ( runtimeenvironment . application . getcontentresolver ( ) , settings . global . wifi_on , ison ? num_ : num_ ) ; settings . system . putint ( runtimeenvironment . application . getcontentresolver ( ) , settings . system . wifi_on , ison ? num_ : num_ ) ; }	Non-Android accessor that allows the value of the WIFI_ON setting to be set.
@ deprecated public static string addsmallestscreenwidth ( string qualifiers , int smallestscreenwidth ) { int qualifierssmallestscreenwidth = qualifiers . getsmallestscreenwidth ( qualifiers ) ; if ( qualifierssmallestscreenwidth == - num_ ) { if ( qualifiers . length ( ) > num_ ) { qualifiers += str_ ; } qualifiers += str_ + smallestscreenwidth + str_ ; } return qualifiers ; }	If the Config already has a `sw` qualifier, do nothing.
protected void instrumentnativemethod ( mutableclass mutableclass , methodnode method ) { method . access = method . access & ~ opcodes . acc_native ; robolectricgeneratoradapter generator = new robolectricgeneratoradapter ( method ) ; type returntype = generator . getreturntype ( ) ; generator . pushdefaultreturnvaluetostack ( returntype ) ; generator . returnvalue ( ) ; }	Creates native stub which returns the default return value.
private void rewritemethodbody ( mutableclass mutableclass , methodnode callingmethod ) { listiterator < abstractinsnnode > instructions = callingmethod . instructions . iterator ( ) ; while ( instructions . hasnext ( ) ) { abstractinsnnode node = instructions . next ( ) ; switch ( node . getopcode ( ) ) { case opcodes . new : typeinsnnode newinsnnode = ( typeinsnnode ) node ; newinsnnode . desc = mutableclass . config . mappedtypename ( newinsnnode . desc ) ; break ; case opcodes . getfield : case opcodes . putfield : case opcodes . getstatic : case opcodes . putstatic : fieldinsnnode fieldinsnnode = ( fieldinsnnode ) node ; fieldinsnnode . desc = mutableclass . config . mappedtypename ( fieldinsnnode . desc ) ;	Filters methods that might need special treatment because of various reasons.
private boolean isgregoriancalendarbooleanconstructor ( methodinsnnode targetmethod ) { return targetmethod . owner . equals ( str_ ) && targetmethod . name . equals ( str_ ) && targetmethod . desc . equals ( str_ ) ; }	Verifies if the .
private void makeclasspublic ( classnode clazz ) { clazz . access = ( clazz . access | opcodes . acc_public ) & ~ ( opcodes . acc_protected | opcodes . acc_private ) ; }	Replaces protected and private class modifiers with public.
protected void makemethodpublic ( methodnode method ) { method . access = ( method . access | opcodes . acc_public ) & ~ ( opcodes . acc_protected | opcodes . acc_private ) ; }	Replaces protected and private method modifiers with public.
protected void makemethodprivate ( methodnode method ) { method . access = ( method . access | opcodes . acc_private ) & ~ ( opcodes . acc_public | opcodes . acc_protected ) ; }	Replaces protected and public class modifiers with private.
public void settraversalafter ( accessibilitynodeinfo info ) { if ( this . traversalafter != null ) { this . traversalafter . recycle ( ) ; } this . traversalafter = obtain ( info ) ; }	Sets the view whose node is visited after this one in accessibility traversal.This may be useful for configuring traversal order in tests before the correspondingviews have been inflated.
public void settraversalbefore ( accessibilitynodeinfo info ) { if ( this . traversalbefore != null ) { this . traversalbefore . recycle ( ) ; } this . traversalbefore = obtain ( info ) ; }	Sets the view before whose node this one should be visited during traversal.This may be useful for configuring traversal order in tests before the correspondingviews have been inflated.
public void addchild ( accessibilitynodeinfo child ) { if ( children == null ) { children = new arraylist < > ( ) ; } children . add ( child ) ; shadowaccessibilitynodeinfo shadowaccessibilitynodeinfo = shadow . extract ( child ) ; shadowaccessibilitynodeinfo . parent = realaccessibilitynodeinfo ; }	Add a child node to this one.
public void pushdefaultreturnvaluetostack ( type type ) { if ( type . equals ( type . boolean_type ) ) { push ( bool_ ) ; } else if ( type . equals ( type . int_type ) || type . equals ( type . short_type ) || type . equals ( type . byte_type ) || type . equals ( type . char_type ) ) { push ( num_ ) ; } else if ( type . equals ( type . long_type ) ) { push ( num_ ) ; } else if ( type . equals ( type . float_type ) ) { push ( num_ ) ; } else if ( type . equals ( type . double_type ) ) { push ( num_ ) ; } else if ( type . getsort ( ) == array || type . getsort ( ) == object ) { loadnull ( ) ; } }	Forces a return of a default value, depending on the method's return type.
public static int getmode ( string path ) { if ( path == null ) { return num_ ; } file file = new file ( path ) ; if ( file . isdirectory ( ) ) { return s_ifdir_value ; } if ( file . isfile ( ) ) { return s_ifreg_value ; } if ( ! canonicalize ( path ) . equals ( path ) ) { return s_iflnk_value ; } return num_ ; }	Returns the st_mode for the path.
public activitycontroller < t > setup ( bundle savedinstancestate ) { return create ( savedinstancestate ) . start ( ) . restoreinstancestate ( savedinstancestate ) . postcreate ( savedinstancestate ) . resume ( ) . visible ( ) ; }	Calls the same lifecycle methods on the Activity called by Android when an Activity is restored from previously saved state.
public activitycontroller < t > configurationchange ( final configuration newconfiguration ) { final configuration currentconfig = component . getresources ( ) . getconfiguration ( ) ; final int changedbits = currentconfig . diff ( newconfiguration ) ; currentconfig . setto ( newconfiguration ) ;	Performs a configuration change on the Activity.If the activity is configured to handle changes without being recreated,{.
@ suppresswarnings ( str_ ) public activitycontroller < t > recreate ( ) { stage originalstage = activitylifecyclemonitorregistry . getinstance ( ) . getlifecyclestageof ( component ) ; switch ( originalstage ) { case pre_on_create : create ( ) ;	Recreates activity instance which is controlled by this ActivityController.NonConfigurationInstances and savedInstanceStateBundle are properly passed into a new instance.After the recreation, it brings back its lifecycle state to the original state.
public void setcallstate ( int callstate , string incomingphonenumber ) { if ( callstate != call_state_ringing ) { incomingphonenumber = null ; } this . callstate = callstate ; this . incomingphonenumber = incomingphonenumber ; for ( phonestatelistener listener : getlistenersforflags ( listen_call_state ) ) { listener . oncallstatechanged ( callstate , incomingphonenumber ) ; } }	Sets the current call state with the option to specify an incoming phone number for theCALL_STATE_RINGING state.
public void expectlogmessage ( int level , string tag , string message ) { checktag ( tag ) ; expectedlogs . add ( new logitem ( level , tag , message , null ) ) ; }	Adds an expected log statement.
public boolean isexported ( ) { boolean defaultvalue = ! intentfilters . isempty ( ) ; return ( attributes . containskey ( exported ) ? boolean . parseboolean ( attributes . get ( exported ) ) : defaultvalue ) ; }	Returns whether this service is exported by checking the XML attribute.
private static void getshapeendpoint ( int type , float [ ] coords , float [ ] point ) {	Returns the end point of a given segment.
private void getpointatlength ( int type , float [ ] coords , float lastx , float lasty , float t , float [ ] point ) { if ( type == pathiterator . seg_lineto ) { point [ num_ ] = lastx + ( coords [ num_ ] - lastx ) * t ; point [ num_ ] = lasty + ( coords [ num_ ] - lasty ) * t ;	Returns the estimated position along a path of the given length.
static restable_config createconfig ( bytebuffer buffer ) { int startposition = buffer . position ( ) ;	packed version of "tl".
public final boolean isdefault ( ) { return mcc == num_ && mnc == num_ && iszeroes ( language ) && iszeroes ( country ) && orientation == num_ && touchscreen == num_ && density == num_ && keyboard == num_ && navigation == num_ && inputflags == num_ && screenwidth == num_ && screenheight == num_ && sdkversion == num_ && minorversion == num_ && screenlayout == num_ && uimode == num_ && smallestscreenwidthdp == num_ && screenwidthdp == num_ && screenheightdp == num_ && iszeroes ( localescript ) && iszeroes ( localevariant ) && screenlayout2 == num_ && colormode == num_ ; }	Returns true if this is the default "any" configuration.
@ implementation ( minsdk = jelly_bean_mr2 ) protected bundle getapplicationrestrictions ( string packagename ) { bundle bundle = applicationrestrictions . get ( packagename ) ; return bundle != null ? bundle : new bundle ( ) ; }	Compared to real Android, there is no check that the package name matches the applicationpackage name and the method returns instantly.
public long adduserprofile ( userhandle userhandle ) { long serialnumber = nextuserserial ++ ; userprofiles . put ( userhandle , serialnumber ) ; return serialnumber ; }	Adds a profile associated for the user that the calling process is running on.The user is assigned an arbitrary unique serial number.
public userhandle adduser ( int id , string name , int flags ) { userhandle userhandle = id == userhandle . user_system ? process . myuserhandle ( ) : new userhandle ( id ) ; adduserprofile ( userhandle ) ; setserialnumberforuser ( userhandle , ( long ) id ) ; userinfomap . put ( id , new userinfo ( id , name , flags ) ) ; userpidmap . put ( id , id == userhandle . user_system ? process . myuid ( ) : id * userhandle . per_user_range + shadowprocess . getrandomapplicationuid ( ) ) ; return userhandle ; }	Creates a user with the specified name, userId and flags.
@ implementation protected void connect ( ) throws ioexception { if ( state == socketstate . closed ) { throw new ioexception ( str_ ) ; } state = socketstate . connected ; }	This method doesn't perform an actual connection and returns immediately.
private void interceptinvokevirtualmethodwithinvokedynamic ( listiterator < abstractinsnnode > instructions , methodinsnnode targetmethod ) { instructions . remove ( ) ;	Intercepts the method using the invokedynamic bytecode instruction available in Java 7+.Should be called through interceptInvokeVirtualMethod, not directly.
int addmappings ( final dynamicreftable other ) { if ( massignedpackageid != other . massignedpackageid ) { return unknown_error ; }	Adds mappings from the other DynamicRefTable.
int addmapping ( final string packagename , byte packageid ) { byte index = mentries . get ( packagename ) ; if ( index == null ) { return unknown_error ; } mlookuptable [ index ] = packageid ; return no_error ; }	the given package.
public void grantpermissions ( int pid , int uid , string ... permissions ) { getshadowinstrumentation ( ) . grantpermissions ( pid , uid , permissions ) ; }	Grant the given permissions for the given process and user.
public void denypermissions ( int pid , int uid , string ... permissions ) { getshadowinstrumentation ( ) . denypermissions ( pid , uid , permissions ) ; }	Revoke the given permissions for the given process and user.
@ override @ nonnull public list < sdk > selectsdks ( configuration configuration , usessdk usessdk ) { config config = configuration . get ( config . class ) ; set < sdk > sdks = new treeset < > ( configuredsdks ( config , usessdk ) ) ; if ( enabledsdks != null ) { sdks = sets . intersection ( sdks , enabledsdks ) ; } return lists . newarraylist ( sdks ) ; }	Enumerate the SDKs to be used for this test.
private static path getfilefromzip ( path path ) { byte [ ] buffer = new byte [ num_ ] ; try { path outputdir = new tempdirectory ( str_ ) . create ( str_ ) ; try ( inputstream zis = fs . getinputstream ( path ) ) { path filefromzip = outputdir . resolve ( path . getfilename ( ) . tostring ( ) ) ; try ( outputstream fos = files . newoutputstream ( filefromzip ) ) { int len ; while ( ( len = zis . read ( buffer ) ) > num_ ) { fos . write ( buffer , num_ , len ) ; } } return filefromzip ; } } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	Extract an asset from a zipped up assets provided by the build system, this is required becausethere is no way to get a FileDescriptor from a zip entry.
public static httprequest getnextsenthttprequest ( ) { httprequestinfo httprequestinfo = getfakehttplayer ( ) . getnextsenthttprequestinfo ( ) ; return httprequestinfo == null ? null : httprequestinfo . gethttprequest ( ) ; }	Accessor to obtain HTTP requests made during the current test in the order in which they were made.
public static void addhttpresponserule ( string method , string uri , httpresponse response ) { getfakehttplayer ( ) . addhttpresponserule ( method , uri , response ) ; }	Adds an HTTP response rule.
public static void addhttpresponserule ( requestmatcher requestmatcher , list < ? extends httpresponse > responses ) { getfakehttplayer ( ) . addhttpresponserule ( requestmatcher , responses ) ; }	Adds an HTTP response rule.
@ implementation protected static void nativestop ( long nativeobject ) { try {	Closes the FileOutputStream for the associated muxer.
public void addhttpresponserule ( requestmatcher requestmatcher , list < ? extends httpresponse > responses ) { addhttpresponserule ( new requestmatcherresponserule ( requestmatcher , responses ) ) ; }	Add a response rule.
public void addbluetoothroute ( ) { updatebluetoothaudioroute ( bluetooth_device_name ) ; if ( runtimeenvironment . getapilevel ( ) <= jelly_bean_mr1 ) { reflectionhelpers . callinstancemethod ( mediarouter . class , realobject , str_ , classparameter . from ( int . class , mediarouter . route_type_live_audio ) , classparameter . from ( routeinfo . class , getbluetootha2dproute ( ) ) ) ; } else { realobject . selectroute ( mediarouter . route_type_live_audio , getbluetootha2dproute ( ) ) ; } }	Adds the Bluetooth A2DP route and ensures it's the selected route, simulating connecting aBluetooth device.
@ implementation protected static final void setthreadpriority ( int tid , int priority ) { checkargument ( priority >= android . os . process . thread_priority_urgent_audio && priority <= android . os . process . thread_priority_lowest , str_ , priority ) ; if ( tid == num_ ) { tid = shadowprocess . mytid ( ) ; } synchronized ( threadprioritieslock ) { threadpriorities . put ( tid , priority ) ; } }	Stores priority for the given thread, but doesn't actually change it to not mess up with testrunner.
@ implementation protected static final int getthreadpriority ( int tid ) { if ( tid == num_ ) { tid = shadowprocess . mytid ( ) ; } synchronized ( threadprioritieslock ) { return threadpriorities . getordefault ( tid , num_ ) ; } }	Returns priority stored for the given thread.
int getindexofbit ( int n ) {	Gets the index of the specified bit in the set, which is the number of marked bits that appearbefore the specified bit.
public static int getcolor ( string value ) { if ( value != null ) { if ( value . startswith ( str_ ) == bool_ ) { throw new numberformatexception ( string . format ( str_ , value ) ) ; } value = value . substring ( num_ ) ;	Returns the color value represented by the given string value.
public static int getcolortype ( string value ) { if ( value != null && value . startswith ( str_ ) ) { switch ( value . length ( ) ) { case num_ : return typedvalue . type_int_color_rgb4 ; case num_ : return typedvalue . type_int_color_argb4 ; case num_ : return typedvalue . type_int_color_rgb8 ; case num_ : return typedvalue . type_int_color_argb8 ; } } return typedvalue . type_int_color_argb8 ; }	Returns the TypedValue color type represented by the given string value.
public static boolean parsefloatattribute ( string attribute , string value , typedvalue outvalue , boolean requireunit ) { assert requireunit == bool_ || attribute != null ;	Parse a float attribute and return the parsed value into a given TypedValue.
@ implementation protected static imagedecoder ncreate ( long asset , source source ) throws ioexception { return imagedecoder_ncreateasset ( asset , source ) ; }	native method implementations...
@ implementation protected static imagedecoder ncreate ( filedescriptor fd , source src ) throws ioexception { return imagedecoder_ncreatefd ( fd , src ) ; }	The fd must be seekable.
public boolean clickmenuitem ( int menuitemresid ) { final robomenuitem item = new robomenuitem ( menuitemresid ) ; return realactivity . onmenuitemselected ( window . feature_options_panel , item ) ; }	Perform a click on a menu item.
public void callonactivityresult ( int requestcode , int resultcode , intent resultdata ) { final activityinvoker invoker = new activityinvoker ( ) ; invoker . call ( str_ , integer . type , integer . type , intent . class ) . with ( requestcode , resultcode , resultdata ) ; }	For internal use only.
@ implementation ( minsdk = lollipop ) protected void startlocktask ( ) { shadow . < shadowactivitymanager > extract ( getactivitymanager ( ) ) . setlocktaskmodestate ( activitymanager . lock_task_mode_locked ) ; }	Starts a lock task. The status of the lock task can be verified using {.
@ implementation ( minsdk = lollipop ) protected void stoplocktask ( ) { shadow . < shadowactivitymanager > extract ( getactivitymanager ( ) ) . setlocktaskmodestate ( activitymanager . lock_task_mode_none ) ; }	Stops a lock task. The status of the lock task can be verified using {.
public synchronized void postdelayed ( runnable runnable , long delay , timeunit unit ) { long delaymillis = unit . tomillis ( delay ) ; if ( ( idlestate != constant_idle && ( ispaused ( ) || delaymillis > num_ ) ) || thread . currentthread ( ) != associatedthread ) { runnables . add ( new scheduledrunnable ( runnable , currenttime + delaymillis ) ) ; } else { runorqueuerunnable ( runnable , currenttime + delaymillis ) ; } }	Add a runnable to the queue to be run after a delay.
public synchronized void postatfrontofqueue ( runnable runnable ) { if ( ispaused ( ) || thread . currentthread ( ) != associatedthread ) { final long timedisambiguator ; if ( runnables . isempty ( ) ) { timedisambiguator = nexttimedisambiguator ++ ; } else { timedisambiguator = runnables . peek ( ) . timedisambiguator - num_ ; } runnables . add ( new scheduledrunnable ( runnable , num_ , timedisambiguator ) ) ; } else { runorqueuerunnable ( runnable , currenttime ) ; } }	Add a runnable to the head of the queue.
public synchronized void remove ( runnable runnable ) { iterator < scheduledrunnable > iterator = runnables . iterator ( ) ; while ( iterator . hasnext ( ) ) { if ( iterator . next ( ) . runnable == runnable ) { iterator . remove ( ) ; } } }	Remove a runnable from the queue.
public synchronized boolean advancetolastpostedrunnable ( ) { long currentmaxtime = currenttime ; for ( scheduledrunnable scheduled : runnables ) { if ( currentmaxtime < scheduled . scheduledtime ) { currentmaxtime = scheduled . scheduledtime ; } } return advanceto ( currentmaxtime ) ; }	Run all runnables in the queue, and any additional runnables they schedule that are scheduledbefore the latest scheduled runnable currently in the queue.
public synchronized boolean advanceby ( long amount , timeunit unit ) { long endingtime = currenttime + unit . tomillis ( amount ) ; return advanceto ( endingtime ) ; }	Run all runnables that are scheduled to run in the next time interval.
public synchronized boolean advanceto ( long endtime ) { if ( endtime < currenttime || runnables . isempty ( ) ) { currenttime = endtime ; return bool_ ; } int runcount = num_ ; while ( nexttaskisscheduledbefore ( endtime ) ) { runonetask ( ) ; ++ runcount ; } currenttime = endtime ; return runcount > num_ ; }	Run all runnables that are scheduled before the endTime.
public synchronized boolean runonetask ( ) { scheduledrunnable postedrunnable = runnables . poll ( ) ; if ( postedrunnable != null ) { if ( postedrunnable . scheduledtime > currenttime ) { currenttime = postedrunnable . scheduledtime ; } postedrunnable . run ( ) ; return bool_ ; } return bool_ ; }	Run the next runnable in the queue.
@ implementation ( minsdk = lollipop ) protected boolean bindserviceasuser ( intent intent , final serviceconnection serviceconnection , int i , userhandle userhandle ) { return getshadowinstrumentation ( ) . bindservice ( intent , serviceconnection , i ) ; }	Binds to a service but ignores the given UserHandle.
@ implementation protected static boolean setcurrenttimemillis ( long millis ) { if ( currenttimemillis > millis ) { return bool_ ; } currenttimemillis = millis ; for ( listener listener : listeners ) { listener . clockupdated ( currenttimemillis ) ; } return bool_ ; }	Sets the current wall time.
@ implementation ( minsdk = num_ ) public boolean isidle ( ) { if ( build . version . sdk_int >= m ) { return directlyon ( realqueue , messagequeue . class ) . isidle ( ) ; } else { reflectormessagequeue internalqueue = reflector ( reflectormessagequeue . class , realqueue ) ;	Exposes the API23+_isIdle method to older platforms.
@ override public void reset ( ) { reflectormessagequeue msgqueue = reflector ( reflectormessagequeue . class , realqueue ) ; msgqueue . setmessages ( null ) ; msgqueue . setidlehandlers ( new arraylist < > ( ) ) ; msgqueue . setnextbarriertoken ( num_ ) ; }	so it should be package private.
public static < t extends activity > activitycontroller < t > buildactivity ( class < t > activityclass ) { return buildactivity ( activityclass , null ) ; }	Creates a ActivityController for the given activity class. Consider using {.
public static < t extends activity > activitycontroller < t > buildactivity ( class < t > activityclass , intent intent ) { return activitycontroller . of ( reflectionhelpers . callconstructor ( activityclass ) , intent ) ; }	Creates a ActivityController for the given activity class with the intent.
@ deprecated public static < t extends activity > t setupactivity ( class < t > activityclass ) { return buildactivity ( activityclass ) . setup ( ) . get ( ) ; }	Simulates starting activity with the given class type and returns its reference. Use {.
@ deprecated public static < t extends fragment > fragmentcontroller < t > buildfragment ( class < t > fragmentclass ) { return fragmentcontroller . of ( reflectionhelpers . callconstructor ( fragmentclass ) ) ; }	Creates a FragmentController for the given fragment class.
@ implementation protected int speak ( final string text , final int queuemode , final hashmap < string , string > params ) { if ( runtimeenvironment . getapilevel ( ) >= lollipop ) { return shadow . directlyon ( tts , texttospeech . class ) . speak ( text , queuemode , params ) ; } return speak ( text , queuemode , null , params == null ? null : params . get ( engine . key_param_utterance_id ) ) ; }	Speaks the string using the specified queuing strategy and speech parameters.
@ implementation ( minsdk = o_mr1 ) public point getstabledisplaysize ( ) throws remoteexception { displayinfo defaultdisplayinfo = mdm . getdisplayinfo ( display . default_display ) ; return new point ( defaultdisplayinfo . getnaturalwidth ( ) , defaultdisplayinfo . getnaturalheight ( ) ) ; }	Returns the 'natural' dimensions of the default display.
private static filesystem getjarfs ( path jarfile ) throws ioexception { path key = jarfile . toabsolutepath ( ) ; synchronized ( zip_filesystems ) { fswrapper fs = zip_filesystems . get ( key ) ; if ( fs == null ) { fs = new fswrapper ( filesystems . newfilesystem ( key , null ) , key ) ; fs . incrrefcount ( ) ; zip_filesystems . put ( key , fs ) ; } else { fs . incrrefcount ( ) ; } return fs ; } }	Returns a reference-counted Jar FileSystem, possibly one that was previously returned.
public static list < logitem > getlogsfortag ( string tag ) { queue < logitem > logs = logsbytag . get ( tag ) ; return logs == null ? collections . emptylist ( ) : new arraylist < > ( logs ) ; }	Returns ordered list of all log items for a specific tag.
public list < androidmanifest > getallmanifests ( ) { set < androidmanifest > seenmanifests = new hashset < > ( ) ; list < androidmanifest > uniquemanifests = new arraylist < > ( ) ; addtransitivemanifests ( seenmanifests , uniquemanifests ) ; return uniquemanifests ; }	Returns all transitively reachable manifests, including this one, in order and withoutduplicates.
public @ nullable broadcastreceiverdata getbroadcastreceiver ( string classname ) { parseandroidmanifest ( ) ; for ( broadcastreceiverdata receiver : receivers ) { if ( receiver . getname ( ) . equals ( classname ) ) { return receiver ; } } return null ; }	Returns data for the broadcast receiver with the provided name from this manifest.
@ implementation ( minsdk = build . version_codes . o ) protected void deletenotificationchannelgroup ( string channelgroupid ) { if ( getnotificationchannelgroup ( channelgroupid ) != null ) {	Delete a notification channel group and all notification channels associated with the group.This method will not notify any NotificationListenerService of resulting changes tonotification channel groups nor to notification channels.
private static int getjavaversion ( ) { string version = system . getproperty ( str_ ) ; assert version != null ; if ( version . startswith ( str_ ) ) { version = version . substring ( num_ ) ; }	Returns the Java version as an int value.
@ implementation protected final void transform ( matrix matrix ) { checknotnull ( matrix ) ; nativeinput . motionevent event = getnativemotionevent ( ) ; shadowmatrix shadowmatrix = shadow . extract ( matrix ) ; float [ ] m = new float [ num_ ] ; shadowmatrix . getvalues ( m ) ; event . transform ( m ) ; }	shadow this directly as opposed to nativeTransform because need access to ShadowMatrix.
@ implementation @ nullable @ suppresswarnings ( str_ ) protected < t > t get ( key < t > key ) { return ( t ) resultskeytovalue . get ( key ) ; }	Obtain a property of the CaptureResult.
@ implementation @ hiddenapi protected final int loadresourcebagvalue ( int ident , int bagentryid , typedvalue outvalue , boolean resolve ) { cppassetmanager am = assetmanagerforjavaobject ( ) ; if ( am == null ) { return num_ ; } final restable res = am . getresources ( ) ; return loadresourcebagvalueinternal ( ident , bagentryid , outvalue , resolve , res ) ; }	Returns true if the resource was found, filling in mRetStringBlock andmRetData.
@ override @ deprecated public boolean post ( runnable runnable , long delaymillis ) { if ( ! quit ) { getscheduler ( ) . postdelayed ( runnable , delaymillis , timeunit . milliseconds ) ; return bool_ ; } else { return bool_ ; } }	Enqueue a task to be run later.
@ override @ deprecated public boolean postatfrontofqueue ( runnable runnable ) { if ( ! quit ) { getscheduler ( ) . postatfrontofqueue ( runnable ) ; return bool_ ; } else { return bool_ ; } }	Enqueue a task to be run ahead of all other delayed tasks.
public activityinfo addactivityifnotpresent ( componentname componentname ) { return addcomponent ( activityfilters , p -> p . activities , ( p , a ) -> p . activities = a , updatename ( componentname , new activityinfo ( ) ) , bool_ ) ; }	Makes sure that given activity exists.If the activity doesn't exist yet, it will be created with {.
public serviceinfo addserviceifnotpresent ( componentname componentname ) { return addcomponent ( servicefilters , p -> p . services , ( p , a ) -> p . services = a , updatename ( componentname , new serviceinfo ( ) ) , bool_ ) ; }	Makes sure that given service exists.If the service doesn't exist yet, it will be created with {.
public activityinfo addreceiverifnotpresent ( componentname componentname ) { return addcomponent ( receiverfilters , p -> p . receivers , ( p , a ) -> p . receivers = a , updatename ( componentname , new activityinfo ( ) ) , bool_ ) ; }	Makes sure that given receiver exists.If the receiver doesn't exist yet, it will be created with {.
public providerinfo addproviderifnotpresent ( componentname componentname ) { return addcomponent ( providerfilters , p -> p . providers , ( p , a ) -> p . providers = a , updatename ( componentname , new providerinfo ( ) ) , bool_ ) ; }	Makes sure that given provider exists.If the provider doesn't exist yet, it will be created with {.
public void addorupdateactivity ( activityinfo activityinfo ) { addcomponent ( activityfilters , p -> p . activities , ( p , a ) -> p . activities = a , new activityinfo ( activityinfo ) , bool_ ) ; }	Adds or updates given activity in the system.If activity with the same {.
public void addorupdateservice ( serviceinfo serviceinfo ) { addcomponent ( servicefilters , p -> p . services , ( p , a ) -> p . services = a , new serviceinfo ( serviceinfo ) , bool_ ) ; }	Adds or updates given service in the system.If service with the same {.
public void addorupdatereceiver ( activityinfo receiverinfo ) { addcomponent ( receiverfilters , p -> p . receivers , ( p , a ) -> p . receivers = a , new activityinfo ( receiverinfo ) , bool_ ) ; }	Adds or updates given broadcast receiver in the system.If broadcast receiver with the same {.
public void addorupdateprovider ( providerinfo providerinfo ) { addcomponent ( providerfilters , p -> p . providers , ( p , a ) -> p . providers = a , new providerinfo ( providerinfo ) , bool_ ) ; }	Adds or updates given content provider in the system.If content provider with the same {.
@ nullable public activityinfo removeactivity ( componentname componentname ) { return removecomponent ( componentname , activityfilters , p -> p . activities , ( p , a ) -> p . activities = a ) ; }	Removes activity from the package manager.
@ nullable public serviceinfo removeservice ( componentname componentname ) { return removecomponent ( componentname , servicefilters , p -> p . services , ( p , a ) -> p . services = a ) ; }	Removes service from the package manager.
@ nullable public providerinfo removeprovider ( componentname componentname ) { return removecomponent ( componentname , providerfilters , p -> p . providers , ( p , a ) -> p . providers = a ) ; }	Removes content provider from the package manager.
@ nullable public activityinfo removereceiver ( componentname componentname ) { return removecomponent ( componentname , receiverfilters , p -> p . receivers , ( p , a ) -> p . receivers = a ) ; }	Removes broadcast receiver from the package manager.
@ deprecated public void setresolveinfosforintent ( intent intent , list < resolveinfo > info ) { resolveinfoforintent . remove ( intent ) ; for ( resolveinfo resolveinfo : info ) { addresolveinfoforintent ( intent , resolveinfo ) ; } }	Sets extra resolve infos for an intent.Those entries are added to whatever might be in the manifest already.Note that all resolve infos will have {.
@ deprecated public void addresolveinfoforintent ( intent intent , resolveinfo info ) { info . isdefault = bool_ ; componentinfo [ ] componentinfos = new componentinfo [ ] { info . activityinfo , info . serviceinfo , build . version . sdk_int >= kitkat ? info . providerinfo : null } ; for ( componentinfo component : componentinfos ) { if ( component != null && component . applicationinfo != null ) { component . applicationinfo . flags |= applicationinfo . flag_installed ; if ( component . applicationinfo . processname == null ) { component . applicationinfo . processname = component . applicationinfo . packagename ; } } } if ( info . match == num_ ) { info . match = integer . max_value ;	Adds extra resolve info for an intent.Note that this resolve info will have {.
public void addpackageinternal ( package apppackage ) { int flags = get_activities | get_receivers | get_services | get_providers | get_instrumentation | get_intent_filters | get_signatures | get_resolved_filter | get_meta_data | get_gids | match_disabled_components | get_shared_library_files | get_uri_permission_patterns | get_permissions | match_uninstalled_packages | get_configurations | match_disabled_until_used_components | match_direct_boot_unaware | match_direct_boot_aware ; for ( permissiongroup permissiongroup : apppackage . permissiongroups ) { permissiongroupinfo permissiongroupinfo = packageparser . generatepermissiongroupinfo ( permissiongroup , flags ) ; addpermissiongroupinfo ( permissiongroupinfo ) ; } packageinfo packageinfo = reflector ( _packageparser_ . class ) . generatepackageinfo ( apppackage , new int [ ] { num_ } , flags , num_ , num_ ) ; packageinfo . applicationinfo . uid = process . myuid ( ) ; packageinfo . applicationinfo . datadir = createtempdir ( packageinfo . packagename + str_ ) ; installpackage ( packageinfo ) ; addfilters ( activityfilters , apppackage . activities ) ; addfilters ( servicefilters , apppackage . services ) ; addfilters ( providerfilters , apppackage . providers ) ; addfilters ( receiverfilters , apppackage . receivers ) ; }	Internal use only.
public void addintentfilterforactivity ( componentname componentname , intentfilter filter ) throws namenotfoundexception { addintentfilterforcomponent ( componentname , filter , activityfilters ) ; }	Add intent filter for given activity.
public void addintentfilterforservice ( componentname componentname , intentfilter filter ) throws namenotfoundexception { addintentfilterforcomponent ( componentname , filter , servicefilters ) ; }	Add intent filter for given service.
public void addintentfilterforreceiver ( componentname componentname , intentfilter filter ) throws namenotfoundexception { addintentfilterforcomponent ( componentname , filter , receiverfilters ) ; }	Add intent filter for given receiver.
public void addintentfilterforprovider ( componentname componentname , intentfilter filter ) throws namenotfoundexception { addintentfilterforcomponent ( componentname , filter , providerfilters ) ; }	Add intent filter for given provider.
private static int findparent ( int packed_locale , final string script ) { if ( hasregion ( packed_locale ) ) { for ( map . entry < string , map < integer , integer > > entry : script_parents . entryset ( ) ) { if ( script . equals ( entry . getkey ( ) ) ) { map < integer , integer > map = entry . getvalue ( ) ; integer lookup_result = map . get ( packed_locale ) ; if ( lookup_result != null ) { return lookup_result ; } break ; } } return dropregion ( packed_locale ) ; } return packed_root ; }	to represent the root locale.
static int findancestors ( int [ ] out , ref < long > stop_list_index , int packed_locale , final string script , final int [ ] stop_list , int stop_set_length ) { int ancestor = packed_locale ; int count = num_ ; do { if ( out != null ) { out [ count ] = ancestor ; } count ++ ; for ( int i = num_ ; i < stop_set_length ; i ++ ) { if ( stop_list [ i ] == ancestor ) { stop_list_index . set ( ( long ) i ) ; return count ; } } ancestor = findparent ( ancestor , script ) ; } while ( ancestor != packed_root ) ; stop_list_index . set ( ( long ) - num_ ) ; return count ; }	any results in 'out'.).
public static package callparsepackage ( path apkfile ) { packageparser packageparser = new packageparser ( ) ; int flags = packageparser . parse_ignore_processes ; try { package thepackage ; if ( runtimeenvironment . getapilevel ( ) >= build . version_codes . lollipop ) {	Parses an AndroidManifest.xml file using the framework PackageParser.
@ override public intent getintentforactivity ( class < ? extends activity > activityclass ) { packagemanager packagemanager = gettargetcontext ( ) . getpackagemanager ( ) ; componentname componentname = new componentname ( gettargetcontext ( ) , activityclass ) ; intent intent = intent . makemainactivity ( componentname ) ; if ( packagemanager . resolveactivity ( intent , num_ ) != null ) { return intent ; } return intent . makemainactivity ( new componentname ( getcontext ( ) , activityclass ) ) ; }	This implementation makes sure, that the activity you are trying to launch exists.
static boolean verifyrestabletype ( restable_type header ) { if ( header . id == num_ ) { logerror ( str_ ) ; return bool_ ; } int entry_count = dtohl ( header . entrycount ) ;	the ResChunk_header is safe.
private static list < manifestidentifier > findlibraries ( path resdirectory ) throws ioexception { list < manifestidentifier > librarybasedirs = new arraylist < > ( ) ; if ( resdirectory != null ) { path basedir = resdirectory . getparent ( ) ; final properties properties = getproperties ( basedir . resolve ( str_ ) ) ; properties overrideproperties = getproperties ( basedir . resolve ( str_ ) ) ; properties . putall ( overrideproperties ) ; int libref = num_ ; string lib ; while ( ( lib = properties . getproperty ( str_ + libref ) ) != null ) { path librarydir = basedir . resolve ( lib ) ; if ( files . isdirectory ( librarydir ) ) {	Find valid library AndroidManifest files referenced from an already loaded AndroidManifest's`project.properties` file, recursively.
@ implementation ( minsdk = n ) @ nullable protected charsequence getorganizationname ( componentname admin ) { if ( build . version . sdk_int >= build . version_codes . o ) { enforcedeviceownerorprofileowner ( admin ) ; } else { enforceprofileowner ( admin ) ; } return organizationname ; }	Returns organization name. The API can only be called by profile owner since Android N. Android framework has a hidden API for getting the organization name for device owner sinceAndroid O. This method, however, is extended to return the organization name for device ownerstoo to make testing of {.
@ implementation ( minsdk = lollipop ) protected boolean setpermittedaccessibilityservices ( componentname admin , list < string > packagenames ) { enforcedeviceownerorprofileowner ( admin ) ; permittedaccessibilityservices = packagenames ; return bool_ ; }	Sets permitted accessibility services.
@ implementation ( minsdk = lollipop ) protected boolean setpermittedinputmethods ( componentname admin , list < string > packagenames ) { enforcedeviceownerorprofileowner ( admin ) ; permittedinputmethods = packagenames ; return bool_ ; }	Sets permitted input methods.
public boolean activateresettoken ( componentname admin ) { if ( ! passwordresettokens . containskey ( admin ) ) { throw new illegalargumentexception ( str_ + admin ) ; } return componentswithactivatedtokens . add ( admin ) ; }	Activates reset token for given admin.
public set < restable_config > getresourceconfigurations ( boolean exclude_system , boolean exclude_mipmap ) {	boolean exclude_mipmap = false);.
public set < string > getresourcelocales ( boolean exclude_system , boolean merge_equivalent_languages ) { atrace_call ( ) ; set < string > locales = new hashset < > ( ) ; for ( final packagegroup package_group : package_groups_ ) { for ( final configuredpackage package_ : package_group . packages_ ) { if ( exclude_system && package_ . loaded_package_ . issystem ( ) ) { continue ; } package_ . loaded_package_ . collectlocales ( merge_equivalent_languages , locales ) ; } } return locales ; }	boolean merge_equivalent_languages = false);.
public asset opennonasset ( final string filename , asset . accessmode mode , ref < apkassetscookie > out_cookie ) { atrace_call ( ) ; for ( int i = apk_assets_ . size ( ) - num_ ; i >= num_ ; i -- ) { asset asset = apk_assets_ . get ( i ) . open ( filename , mode ) ; if ( istruthy ( asset ) ) { if ( out_cookie != null ) { out_cookie . set ( apkassetscookie . forint ( i ) ) ; } return asset ; } } if ( out_cookie != null ) { out_cookie . set ( k_invalid_cookie ) ; } return null ; }	is inconsistent for split APKs.
public void addavailablerestoresets ( long restoretoken , list < string > packages ) { servicestate . restoredata . put ( restoretoken , packages ) ; }	Adds a restore set available to be restored.
private void executeonlooper ( controlrunnable runnable ) { if ( thread . currentthread ( ) == reallooper . getthread ( ) ) { runnable . run ( ) ; } else { if ( reallooper . equals ( looper . getmainlooper ( ) ) ) { throw new unsupportedoperationexception ( str_ ) ; } looperexecutor . execute ( runnable ) ; runnable . waittillcomplete ( ) ; } }	Executes the given runnable on the loopers thread, and waits for it to complete.
@ implementation ( maxsdk = jelly_bean_mr1 ) @ suppresswarnings ( str_ ) protected < t extends parcelable > t readparcelable ( classloader loader ) {	this needs to start above 0, which is a magic number to Parcel.
@ implementation ( minsdk = m ) protected void writeblob ( byte [ ] b , int offset , int len ) { if ( b == null ) { realobject . writeint ( - num_ ) ; return ; } throwsifoutofbounds ( b . length , offset , len ) ; long nativeptr = reflectionhelpers . getfield ( realobject , str_ ) ; nativewriteblob ( nativeptr , b , offset , len ) ; }	non-existent-in-JDK java.util.Arrays.checkOffsetAndCount method.
@ implementation ( minsdk = lollipop ) protected static void nativewriteblob ( long nativeptr , byte [ ] b , int offset , int len ) { nativewritebytearray ( nativeptr , b , offset , len ) ; }	nativeWriteBlob was introduced in lollipop, thus no need for a int nativePtr variant.
public byte [ ] tobytearray ( ) { int olddataposition = dataposition ; try { bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; objectoutputstream oos = new objectoutputstream ( bos ) ;	Converts a ByteBuffer to a raw byte array.
public void setdataposition ( int pos ) { if ( pos > datasize ) {	Sets the current data position.
private void checkconsistentreadandincrementposition ( class < ? > clazz , fakeencodeditem item ) { int endposition = dataposition + item . sizebytes ; for ( int i = dataposition ; i < endposition ; i ++ ) { fakeencodeditem founditemitem = i < datasize ? data [ i ] : null ; if ( founditemitem != item ) { throw new unreliablebehaviorerror ( clazz , dataposition , item , string . format ( locale . us , str_ , founditemitem == null ? str_ : founditemitem . value , i ) ) ; } } dataposition = math . min ( datasize , dataposition + item . sizebytes ) ; }	Ensures that the next sizeBytes are all the initial value we read. This detects: Reading an item, but not starting at its start position Reading items that were truncated by setSize Reading items that were partially overwritten by another.
private object peek ( ) { return dataposition < datasize && data [ dataposition ] != null ? data [ dataposition ] . value : null ; }	Returns the item at the current position, or null if uninitialized or null.
private < t > fakeencodeditem readnextitem ( class < t > clazz ) { fakeencodeditem item = data [ dataposition ] ; if ( item == null ) {	Reads a complete item in the byte buffer.
private < t > t readvalue ( t pastendvalue , class < t > clazz , boolean allownull ) { if ( dataposition >= datasize ) {	Reads the next value in the byte buffer of a specified type.
private boolean readzeroes ( int bytes ) { int endposition = dataposition + bytes ; if ( endposition > datasize ) { return bool_ ; } for ( int i = dataposition ; i < endposition ; i ++ ) { if ( data [ i ] == null || ! data [ i ] . isencodedasallzerobytes ) { return bool_ ; } }	Determines if there is a sequence of castable zeroes, and consumes them.
private < t > t readprimitive ( int defaultsizebytes , t defaultvalue , class < t > clazz ) {	Reads a primitive, which may reinterpret zeros of other types.
private void writeitem ( fakeencodeditem item ) { int endposition = dataposition + item . sizebytes ; if ( endposition > data . length ) {	Writes an encoded item directly, bypassing alignment, and possibly repeating an item.
public static byte [ ] readbytes ( inputstream is ) throws ioexception { try ( bytearrayoutputstream bos = new bytearrayoutputstream ( is . available ( ) ) ) { copy ( is , bos ) ; return bos . tobytearray ( ) ; } }	This method consumes an input stream and returns its content.
@ deprecated public synchronized long getnativeobjectid ( t o ) { checknotnull ( o ) ; long nativeid = nativeobjtoidmap . inverse ( ) . get ( o ) ; if ( nativeid == null ) { nativeid = nextid ; if ( debug ) { system . out . printf ( str_ , name , nativeid , o ) ; } nativeobjtoidmap . put ( nativeid , o ) ; nextid ++ ; } return nativeid ; }	Retrieve the native id for given object.
public synchronized t getnativeobject ( long nativeid ) { t object = nativeobjtoidmap . get ( nativeid ) ; if ( object != null ) { return object ; } else { throw new nullpointerexception ( string . format ( str_ , nativeid , nativeobjtoidmap . keyset ( ) ) ) ; } }	Retrieve the native object for given id. Throws if object with that id cannot be found.
public void callattach ( context context ) { reflectionhelpers . callinstancemethod ( application . class , realapplication , str_ , reflectionhelpers . classparameter . from ( context . class , context ) ) ; }	Attaches an application to a base context.
public void setdefaultnetworkactive ( boolean isactive ) { defaultnetworkactive = isactive ; if ( defaultnetworkactive ) { for ( connectivitymanager . onnetworkactivelistener l : onnetworkactivelisteners ) { if ( l != null ) { l . onnetworkactive ( ) ; } } } }	Sets the active state of the default network.By default this is true and affects the result of {.
@ implementation protected int load ( string path , int priority ) { int soundid = soundids . getandincrement ( ) ; idtopaths . put ( soundid , path ) ; return soundid ; }	FileDescriptor which would make it difficult to check if a given sound has been placed.
public void reconstructwidgetviewasifphonewasrotated ( int appwidgetid ) { widgetinfo widgetinfo = widgetinfos . get ( appwidgetid ) ; widgetinfo . view = createwidgetview ( widgetinfo . layoutid ) ; widgetinfo . lastremoteviews . reapply ( context , widgetinfo . view ) ; }	Triggers a reapplication of the most recent set of actions against the widget, which is what happens when thephone is rotated.
public int [ ] createwidgets ( class < ? extends appwidgetprovider > appwidgetproviderclass , int widgetlayoutid , int howmanytocreate ) { appwidgetprovider appwidgetprovider = reflectionhelpers . callconstructor ( appwidgetproviderclass ) ; int [ ] newwidgetids = new int [ howmanytocreate ] ; for ( int i = num_ ; i < howmanytocreate ; i ++ ) { view widgetview = createwidgetview ( widgetlayoutid ) ; int mywidgetid = nextwidgetid ++ ; widgetinfos . put ( mywidgetid , new widgetinfo ( widgetview , widgetlayoutid , appwidgetprovider ) ) ; newwidgetids [ i ] = mywidgetid ; } appwidgetprovider . onupdate ( context , realappwidgetmanager , newwidgetids ) ; return newwidgetids ; }	Creates a bunch of widgets by inflating the same layout multiple times.
public void invokeseekcompletelistener ( ) { int duration = getmediainfo ( ) . duration ; setcurrentposition ( pendingseek > duration ? duration : pendingseek < num_ ? num_ : pendingseek ) ; pendingseek = - num_ ; if ( state == started ) { dostart ( ) ; } if ( seekcompletelistener == null ) { return ; } seekcompletelistener . onseekcomplete ( player ) ; }	Allows test cases to simulate seek completion by invoking callback.
public void invokeinfolistener ( int what , int extra ) { if ( infolistener != null ) { infolistener . oninfo ( player , what , extra ) ; } }	Allows test cases to directly simulate invocation of the OnInfo event.
public void invokeerrorlistener ( int what , int extra ) {	Allows test cases to directly simulate invocation of the OnError event.
public static display getdefaultdisplay ( ) { windowmanager windowmanager = ( windowmanager ) runtimeenvironment . application . getsystemservice ( context . window_service ) ; return windowmanager . getdefaultdisplay ( ) ; }	Returns the default display.
public void setdensitydpi ( int densitydpi ) { if ( isjb ( ) ) { this . densitydpi = densitydpi ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . logicaldensitydpi = densitydpi ) ; } }	Changes the density for this display.Any registered {.
public void setxdpi ( float xdpi ) { if ( isjb ( ) ) { this . xdpi = xdpi ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . physicalxdpi = xdpi ) ; } }	Changes the horizontal DPI for this display.Any registered {.
public void setydpi ( float ydpi ) { if ( isjb ( ) ) { this . ydpi = ydpi ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . physicalydpi = ydpi ) ; } }	Changes the vertical DPI for this display.Any registered {.
public void setname ( string name ) { if ( isjb ( ) ) { this . name = name ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . name = name ) ; } }	Changes the name for this display.Any registered {.
public void setflags ( int flags ) { reflector ( _display_ . class , realobject ) . setflags ( flags ) ; if ( ! isjb ( ) ) { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . flags = flags ) ; } }	Changes the flags for this display.Any registered {.
public void setwidth ( int width ) { if ( isjb ( ) ) { this . width = width ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . appwidth = width ) ; } }	Changes the width available to the application for this display.Any registered {.
public void setheight ( int height ) { if ( isjb ( ) ) { this . height = height ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . appheight = height ) ; } }	Changes the height available to the application for this display.Any registered {.
public void setrealwidth ( int width ) { if ( isjb ( ) ) { this . realwidth = width ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . logicalwidth = width ) ; } }	Changes the simulated physical width for this display.Any registered {.
public void setrealheight ( int height ) { if ( isjb ( ) ) { this . realheight = height ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . logicalheight = height ) ; } }	Changes the simulated physical height for this display.Any registered {.
public void setrotation ( int rotation ) { if ( isjb ( ) ) { this . rotation = rotation ; } else { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . rotation = rotation ) ; } }	Changes the rotation for this display.Any registered {.
public void setstate ( int state ) { if ( ! isjb ( ) ) { shadowdisplaymanager . changedisplay ( realobject . getdisplayid ( ) , di -> di . state = state ) ; } }	Changes the simulated state for this display, such as whether it is on or offAny registered {.
protected void releaseconnection ( ) {	Returns the connection back to the connection managerand prepares for retrieving a new connection duringthe next request.
protected void establishroute ( httproute route , httpcontext context ) throws httpexception , ioexception { httproutedirector rowdy = new basicroutedirector ( ) ; int step ; do { httproute fact = managedconn . getroute ( ) ; step = rowdy . nextstep ( route , fact ) ; switch ( step ) { case httproutedirector . connect_target : case httproutedirector . connect_proxy : managedconn . open ( route , context , this . params ) ; break ; case httproutedirector . tunnel_target : { boolean secure = createtunneltotarget ( route , context ) ; this . log . debug ( str_ ) ; managedconn . tunneltarget ( secure , this . params ) ; } break ; case httproutedirector . tunnel_proxy : {	Establishes the target route.
public string qualify ( string value ) { if ( value == null ) return null ; if ( attributeresource . isresourcereference ( value ) ) { return str_ + resname . qualifyresourcename ( value . trim ( ) . substring ( num_ ) . replace ( str_ , str_ ) , packagename , str_ ) ; } else if ( attributeresource . isstylereference ( value ) ) { return str_ + resname . qualifyresourcename ( value . trim ( ) . substring ( num_ ) , packagename , str_ ) ; } else { return stringresources . processstringresources ( value ) ; } }	for testing only...
int navigatetonextnode ( node node ) throws xmlpullparserexception { node nextnode = node . getnextsibling ( ) ; if ( nextnode != null ) {	Navigate to the next node after a node and all of hischildren have been explored.If the node has unexplored siblings navigate to thenext sibling.
private static boolean isandroidsupportedfeature ( string name ) { if ( name == null ) { return bool_ ; } for ( string feature : available_features ) { if ( feature . equals ( name ) ) { return bool_ ; } } return bool_ ; }	Tell is a given feature is supported by android.
int add ( asset asset , asset idmapasset , final int cookie , boolean copydata , boolean appaslib , boolean issystemasset ) { final byte [ ] data = asset . getbuffer ( bool_ ) ; if ( data == null ) { alogw ( str_ ) ; return unknown_error ; } int idmapsize = num_ ; object idmapdata = null ; if ( idmapasset != null ) { idmapdata = idmapasset . getbuffer ( bool_ ) ; if ( idmapdata == null ) { alogw ( str_ ) ; return unknown_error ; } idmapsize = ( int ) idmapasset . getlength ( ) ; } return addinternal ( data , ( int ) asset . getlength ( ) , idmapdata , idmapsize , appaslib , cookie , copydata , issystemasset ) ; }	bool appAsLib=false, bool isSystemAsset=false);.
public static string getqualifiers ( configuration configuration , displaymetrics displaymetrics ) { return configurationv25 . resourcequalifierstring ( configuration , displaymetrics ) ; }	Returns a qualifier string describing the given configuration and display metrics.
public static void setqualifiers ( string newqualifiers ) { configuration configuration ; displaymetrics displaymetrics = new displaymetrics ( ) ; if ( newqualifiers . startswith ( str_ ) ) { configuration = new configuration ( resources . getsystem ( ) . getconfiguration ( ) ) ; displaymetrics . setto ( resources . getsystem ( ) . getdisplaymetrics ( ) ) ; } else { configuration = new configuration ( ) ; } bootstrap . applyqualifiers ( newqualifiers , getapilevel ( ) , configuration , displaymetrics ) ; resources systemresources = resources . getsystem ( ) ; systemresources . updateconfiguration ( configuration , displaymetrics ) ; if ( application != null ) { application . getresources ( ) . updateconfiguration ( configuration , displaymetrics ) ; } }	Overrides the current device configuration.If `newQualifiers` starts with a plus (`+`), the prior configuration is used as the baseconfiguration, with the given changes applied additively.
public static string buildstring ( char [ ] data ) { int count = num_ ; for ( count = num_ ; count < data . length ; count ++ ) { if ( data [ count ] == num_ ) { break ; } } return new string ( data , num_ , count ) ; }	Builds a string from a null-terminated char data.
public static < s > servicefinder < s > load ( class < s > service , classloader loader ) { return new servicefinder < > ( service , loader ) ; }	Creates a new service loader for the given service type and classloader.
public static < s > s loadfromsystemproperty ( final class < s > service ) { try { final string classname = system . getproperty ( service . getname ( ) ) ; if ( classname != null ) { class < ? > c = classloader . getsystemclassloader ( ) . loadclass ( classname ) ; return ( s ) c . newinstance ( ) ; } return null ; } catch ( exception e ) { throw new error ( e ) ; } }	Internal API to support built-in SPIs that check a system property first.Returns an instance specified by a property with the class' binary name, or null ifno such property is set.
public boolean haspermissionforpackage ( usbdevice device , string packagename ) { list < usbdevice > usbdevices = grantedpermissions . get ( packagename ) ; return usbdevices != null && usbdevices . contains ( device ) ; }	Returns true if the given package has permission to access the device.
public void revokepermission ( usbdevice device , string packagename ) { list < usbdevice > usbdevices = grantedpermissions . get ( packagename ) ; if ( usbdevices != null ) { usbdevices . remove ( device ) ; } }	Revokes permission to a USB device granted to a package.
public void addorupdateusbdevice ( usbdevice usbdevice , boolean haspermission ) { preconditions . checknotnull ( usbdevice ) ; preconditions . checknotnull ( usbdevice . getdevicename ( ) ) ; usbdevices . put ( usbdevice . getdevicename ( ) , usbdevice ) ; if ( haspermission ) { grantpermission ( usbdevice ) ; } else { revokepermission ( usbdevice , runtimeenvironment . application . getpackagename ( ) ) ; } }	Adds a USB device into available USB devices map with permission value.
public void removeusbdevice ( usbdevice usbdevice ) { preconditions . checknotnull ( usbdevice ) ; usbdevices . remove ( usbdevice . getdevicename ( ) ) ; revokepermission ( usbdevice , runtimeenvironment . application . getpackagename ( ) ) ; }	Removes a USB device from available USB devices map.
public void addport ( string portid ) { if ( runtimeenvironment . getapilevel ( ) >= build . version_codes . q ) { usbports . put ( ( usbport ) createusbport ( realusbmanager , portid , usbportstatus . mode_dual ) , ( usbportstatus ) createusbportstatus ( usbportstatus . mode_dual , usbportstatus . power_role_sink , usbportstatus . data_role_device , num_ ) ) ; return ; } usbports . put ( callconstructor ( usbport . class , from ( string . class , portid ) , from ( int . class , getstaticfield ( usbport . class , str_ ) ) ) , ( usbportstatus ) createusbportstatus ( getstaticfield ( usbport . class , str_ ) , getstaticfield ( usbport . class , str_ ) , getstaticfield ( usbport . class , str_ ) , num_ ) ) ; }	Adds a USB port to UsbManager.
@ implementation protected parcelfiledescriptor openaccessory ( usbaccessory accessory ) { try { file tmpusbdir = runtimeenvironment . gettempdirectory ( ) . createifnotexists ( str_ ) . tofile ( ) ; return parcelfiledescriptor . open ( new file ( tmpusbdir , str_ ) , parcelfiledescriptor . mode_read_write ) ; } catch ( filenotfoundexception error ) { throw new runtimeexception ( str_ , error ) ; } }	Opens a file descriptor from a temporary file.
public mediaitem createmediaitem ( string parentid , string mediaid , string title , int flag ) { final mediametadatacompat metadatacompat = new mediametadatacompat . builder ( ) . putstring ( mediametadatacompat . metadata_key_media_id , mediaid ) . putstring ( mediametadatacompat . metadata_key_title , title ) . putstring ( mediametadatacompat . metadata_key_media_uri , uri . parse ( mediaid ) . tostring ( ) ) . build ( ) ; final mediaitem mediaitem = new mediaitem ( metadatacompat . getdescription ( ) , flag ) ; mediaitems . put ( mediaid , mediaitem ) ;	Creates a MediaItem and returns it.
@ suppresswarnings ( str_ ) public static < r > r getfield ( final object object , final string fieldname ) { try { return traverseclasshierarchy ( object . getclass ( ) , nosuchfieldexception . class , new insidetraversal < r > ( ) { @ override public r run ( class < ? > traversalclass ) throws exception { field field = traversalclass . getdeclaredfield ( fieldname ) ; field . setaccessible ( bool_ ) ; return ( r ) field . get ( object ) ; } } ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Reflectively get the value of a field.
public static < r > r callinstancemethod ( final object instance , final string methodname , classparameter < ? > ... classparameters ) { try { final class < ? > [ ] classes = classparameter . getclasses ( classparameters ) ; final object [ ] values = classparameter . getvalues ( classparameters ) ; return traverseclasshierarchy ( instance . getclass ( ) , nosuchmethodexception . class , new insidetraversal < r > ( ) { @ override @ suppresswarnings ( str_ ) public r run ( class < ? > traversalclass ) throws exception { method declaredmethod = traversalclass . getdeclaredmethod ( methodname , classes ) ; declaredmethod . setaccessible ( bool_ ) ; return ( r ) declaredmethod . invoke ( instance , values ) ; } } ) ; } catch ( invocationtargetexception e ) { if ( e . gettargetexception ( ) instanceof runtimeexception ) { throw ( runtimeexception ) e . gettargetexception ( ) ; } if ( e . gettargetexception ( ) instanceof error ) { throw ( error ) e . gettargetexception ( ) ; } throw new runtimeexception ( e . gettargetexception ( ) ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Reflectively call an instance method on an object.
public static < r > r callinstancemethod ( class < ? > cl , final object instance , final string methodname , classparameter < ? > ... classparameters ) { try { final class < ? > [ ] classes = classparameter . getclasses ( classparameters ) ; final object [ ] values = classparameter . getvalues ( classparameters ) ; method method = cl . getdeclaredmethod ( methodname , classes ) ; method . setaccessible ( bool_ ) ; if ( modifier . isstatic ( method . getmodifiers ( ) ) ) { throw new illegalargumentexception ( method + str_ ) ; } return ( r ) method . invoke ( instance , values ) ; } catch ( invocationtargetexception e ) { if ( e . gettargetexception ( ) instanceof runtimeexception ) { throw ( runtimeexception ) e . gettargetexception ( ) ; } if ( e . gettargetexception ( ) instanceof error ) { throw ( error ) e . gettargetexception ( ) ; } throw new runtimeexception ( e . gettargetexception ( ) ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Reflectively call an instance method on an object on a specific class.
public static < r > r callstaticmethod ( classloader classloader , string fullyqualifiedclassname , string methodname , classparameter < ? > ... classparameters ) { class < ? > clazz = loadclass ( classloader , fullyqualifiedclassname ) ; return callstaticmethod ( clazz , methodname , classparameters ) ; }	Helper method for calling a static method using a class from a custom class loader.
@ suppresswarnings ( str_ ) public static < r > r callstaticmethod ( class < ? > clazz , string methodname , classparameter < ? > ... classparameters ) { try { class < ? > [ ] classes = classparameter . getclasses ( classparameters ) ; object [ ] values = classparameter . getvalues ( classparameters ) ; method method = clazz . getdeclaredmethod ( methodname , classes ) ; method . setaccessible ( bool_ ) ; if ( ! modifier . isstatic ( method . getmodifiers ( ) ) ) { throw new illegalargumentexception ( method + str_ ) ; } return ( r ) method . invoke ( null , values ) ; } catch ( invocationtargetexception e ) { if ( e . gettargetexception ( ) instanceof runtimeexception ) { throw ( runtimeexception ) e . gettargetexception ( ) ; } if ( e . gettargetexception ( ) instanceof error ) { throw ( error ) e . gettargetexception ( ) ; } throw new runtimeexception ( e . gettargetexception ( ) ) ; } catch ( nosuchmethodexception e ) { throw new runtimeexception ( str_ + clazz + str_ + methodname , e ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Reflectively call a static method on a class.
public static < t > t newinstance ( class < t > cl ) { try { return cl . getdeclaredconstructor ( ) . newinstance ( ) ; } catch ( instantiationexception | illegalaccessexception | nosuchmethodexception | invocationtargetexception e ) { throw new runtimeexception ( e ) ; } }	Create a new instance of a class.
public static < r > r callconstructor ( class < ? extends r > clazz , classparameter < ? > ... classparameters ) { try { final class < ? > [ ] classes = classparameter . getclasses ( classparameters ) ; final object [ ] values = classparameter . getvalues ( classparameters ) ; constructor < ? extends r > constructor = clazz . getdeclaredconstructor ( classes ) ; constructor . setaccessible ( bool_ ) ; return constructor . newinstance ( values ) ; } catch ( instantiationexception e ) { throw new runtimeexception ( str_ + clazz . getname ( ) , e ) ; } catch ( invocationtargetexception e ) { if ( e . gettargetexception ( ) instanceof runtimeexception ) { throw ( runtimeexception ) e . gettargetexception ( ) ; } if ( e . gettargetexception ( ) instanceof error ) { throw ( error ) e . gettargetexception ( ) ; } throw new runtimeexception ( e . gettargetexception ( ) ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Reflectively call the constructor of an object.
@ implementation ( minsdk = p ) protected void startranging ( rangingrequest request , executor executor , rangingresultcallback callback ) { if ( ! rangingresults . isempty ( ) ) { executor . execute ( ( ) -> callback . onrangingresults ( this . rangingresults ) ) ; } else { executor . execute ( ( ) -> callback . onrangingfailure ( rangingresultcallback . status_code_fail ) ) ; } }	If there are RangingResults set by the setRangeResults method of this shadow class, this methodwill call the onRangingResults method of the callback on the executor thread and pass the listof RangingResults.
@ implementation public static typeface getfontsync ( fontrequest request ) { return typeface . create ( request . getquery ( ) , typeface . normal ) ; }	Returns a stub typeface immediately.
@ nonnull synchronized public packageresourcetable getcompiletimesdkresourcetable ( ) { if ( compiletimesdkresourcetable == null ) { resourcetablefactory resourcetablefactory = new resourcetablefactory ( ) ; compiletimesdkresourcetable = resourcetablefactory . newframeworkresourcetable ( new resourcepath ( android . r . class , null , null ) ) ; } return compiletimesdkresourcetable ; }	Returns the ResourceTable for the compile time SDK.
@ suppresswarnings ( str_ ) @ deprecated public static void dump ( view view ) { shadowview shadowview = shadow . extract ( view ) ; shadowview . dump ( ) ; }	Emits an xml-like representation of the view to System.out.
@ suppresswarnings ( str_ ) public static string innertext ( view view ) { shadowview shadowview = shadow . extract ( view ) ; return shadowview . innertext ( ) ; }	Returns the text contained within this view.
private list < wrapper > getappropriatewrappers ( intent intent , string receiverpermission ) { broadcastintents . add ( intent ) ; list < wrapper > result = new arraylist < > ( ) ; list < wrapper > copy = new arraylist < > ( ) ; copy . addall ( registeredreceivers ) ; string intentclass = intent . getcomponent ( ) != null ? intent . getcomponent ( ) . getclassname ( ) : null ; for ( wrapper wrapper : copy ) { if ( ( hasmatchingpermission ( wrapper . broadcastpermission , receiverpermission ) && wrapper . intentfilter . matchaction ( intent . getaction ( ) ) ) || ( intentclass != null && intentclass . equals ( wrapper . broadcastreceiver . getclass ( ) . getname ( ) ) ) ) { final int match = wrapper . intentfilter . matchdata ( intent . gettype ( ) , intent . getscheme ( ) , intent . getdata ( ) ) ; if ( match != intentfilter . no_match_data && match != intentfilter . no_match_type ) { result . add ( wrapper ) ; } } } return result ; }	Returns the BroadcaseReceivers wrappers, matching intent's action and permissions.
private listenablefuture < broadcastresultholder > postintent ( final wrapper wrapper , final intent intent , listenablefuture < broadcastresultholder > oldresult , final atomicboolean abort , final context context ) { final handler scheduler = ( wrapper . scheduler != null ) ? wrapper . scheduler : getmainhandler ( context ) ; return futures . transformasync ( oldresult , new asyncfunction < broadcastresultholder , broadcastresultholder > ( ) { @ override public listenablefuture < broadcastresultholder > apply ( broadcastresultholder broadcastresultholder ) throws exception { final broadcastreceiver . pendingresult result = shadowbroadcastpendingresult . create ( broadcastresultholder . resultcode , broadcastresultholder . resultdata , broadcastresultholder . resultextras , bool_ ) ; wrapper . broadcastreceiver . setpendingresult ( result ) ; scheduler . post ( ( ) -> { shadowbroadcastreceiver shadowbroadcastreceiver = shadow . extract ( wrapper . broadcastreceiver ) ; shadowbroadcastreceiver . onreceive ( context , intent , abort ) ; } ) ; return broadcastresultholder . transform ( result ) ; } } , directexecutor ( ) ) ; }	Enforces that BroadcastReceivers invoked during an ordered broadcast run serially, passingalong their results.
@ implementation ( minsdk = jelly_bean_mr2 ) protected static void beginsection ( string sectionname ) { if ( trace . istagenabled ( trace_tag_app ) ) { if ( crashonincorrectusage ) { if ( sectionname . length ( ) > max_section_name_len ) { throw new illegalargumentexception ( str_ ) ; } } else if ( sectionname == null ) { log . w ( tag , str_ ) ; return ; } else if ( sectionname . length ( ) > max_section_name_len ) { log . w ( tag , str_ ) ; return ; } synchronized ( lock ) { currentsections . addfirst ( sectionname ) ; } } }	Starts a new trace section with given name.
@ implementation ( minsdk = jelly_bean_mr2 ) protected static void endsection ( ) { if ( trace . istagenabled ( trace_tag_app ) ) { synchronized ( lock ) { if ( currentsections . isempty ( ) ) { log . e ( tag , str_ ) ; return ; } previoussections . offer ( currentsections . removefirst ( ) ) ; } } }	Ends the most recent active trace section.
@ suppresswarnings ( str_ ) @ nonnull private synchronized < t > provider < t > getprovider ( final key < t > key ) {	Finds a provider for the given key.Calls are guaranteed idempotent and non-blocking.
boolean create ( string origfilename , int fd , long offset , int length , boolean readonly ) { this . mfilename = origfilename ; this . fd = fd ; this . mdataoffset = offset ; this . readonly = readonly ; return bool_ ; }	Returns "false" on failure.
public int runall ( ) { int numtasksrun = num_ ; if ( thread . currentthread ( ) . equals ( executorthread ) ) { logger . info ( str_ ) ; return numtasksrun ; } while ( hasqueuedtasks ( ) ) { runnext ( ) ; numtasksrun ++ ; } return numtasksrun ; }	Execute all posted tasks and block until they are complete.
public boolean runnext ( ) { if ( ! hasqueuedtasks ( ) ) { return bool_ ; } if ( thread . currentthread ( ) . equals ( executorthread ) ) { logger . info ( str_ ) ; return bool_ ; } runnable task = deferredtasks . poll ( ) ; task . run ( ) ; return bool_ ; }	Executes the next queued task.Will be ignored if called from the executor service thread to prevent deadlocks.
@ implementation ( minsdk = o ) protected int requestaudiofocus ( android . media . audiofocusrequest audiofocusrequest ) { lastaudiofocusrequest = new audiofocusrequest ( audiofocusrequest ) ; return nextresponsevalue ; }	Provides a mock like interface for the requestAudioFocus method by storing the request objectfor later inspection and returning the value specified in setNextFocusRequestResponse.
@ implementation ( minsdk = o ) protected int abandonaudiofocusrequest ( android . media . audiofocusrequest audiofocusrequest ) { lastabandonedaudiofocusrequest = audiofocusrequest ; return nextresponsevalue ; }	Provides a mock like interface for the abandonAudioFocusRequest method by storing the requestobject for later inspection and returning the value specified in setNextFocusRequestResponse.
@ implementation ( minsdk = lollipop ) protected void native_start ( ) {	Starts the async encoding process, by first reporting a format change event, and thenpresenting an input buffer to the callback.
@ implementation ( minsdk = lollipop ) protected bytebuffer getbuffer ( boolean input , int index ) { bytebuffer [ ] buffers = input ? inputbuffers : outputbuffers ; return ( index >= num_ && index < buffers . length ) ? buffers [ index ] : null ; }	Returns the input or output buffer corresponding to the given index, or null if invalid.
@ implementation ( minsdk = lollipop ) protected void native_queueinputbuffer ( int index , int offset , int size , long presentationtimeus , int flags ) {	Triggers presentation of the corresponding output buffer for the given input buffer, and passesthe given metadata as buffer info.
@ implementation ( minsdk = lollipop ) protected void releaseoutputbuffer ( int index , boolean render , boolean updatepts , long timens ) { if ( reachedeos ) { return ; } makeinputbufferavailable ( index ) ; }	Triggers presentation of the corresponding input buffer for the given output buffer, if end ofstream has not yet been signaled.
private static bundle metadatatobundle ( map < string , object > meta ) { if ( meta . size ( ) == num_ ) { return null ; } bundle bundle = new bundle ( ) ; for ( map . entry < string , object > entry : meta . entryset ( ) ) { string key = entry . getkey ( ) ; object value = entry . getvalue ( ) ; if ( boolean . class . isinstance ( value ) ) { bundle . putboolean ( key , ( boolean ) value ) ; } else if ( float . class . isinstance ( value ) ) { bundle . putfloat ( key , ( float ) value ) ; } else if ( integer . class . isinstance ( value ) ) { bundle . putint ( key , ( integer ) value ) ; } else { bundle . putstring ( key , value == null ? null : value . tostring ( ) ) ; } } return bundle ; }	Goes through the meta data and puts each value in to a bundle as the correct type.
static string convertsqlwithlocalizedunicodecollator ( string sql ) { matcher matcher = collate_localized_unicode_pattern . matcher ( sql ) ; return matcher . replaceall ( str_ ) ; }	Convert SQL with phrase COLLATE LOCALIZED or COLLATE UNICODE to COLLATE NOCASE.
private static packageinfo newpackageinfo ( packageinfo orig ) { parcel parcel = parcel . obtain ( ) ; orig . writetoparcel ( parcel , num_ ) ; parcel . setdataposition ( num_ ) ; return packageinfo . creator . createfromparcel ( parcel ) ; }	There is no copy constructor for PackageInfo.
private void applyflagstocomponentinfo ( componentinfo componentinfo , int flags ) throws namenotfoundexception { componentinfo . name = ( componentinfo . name == null ) ? str_ : componentinfo . name ; applicationinfo applicationinfo = componentinfo . applicationinfo ; boolean isapplicationenabled = bool_ ; if ( applicationinfo != null ) { if ( applicationinfo . packagename == null ) { applicationinfo . packagename = componentinfo . packagename ; } applyflagstoapplicationinfo ( componentinfo . applicationinfo , flags ) ; componentinfo . packagename = applicationinfo . packagename ; isapplicationenabled = applicationinfo . enabled ; } if ( ( flags & get_meta_data ) == num_ ) { componentinfo . metadata = null ; } boolean iscomponentenabled = iscomponentenabled ( componentinfo ) ; if ( ( flags & match_all ) != num_ && build . version . sdk_int >= num_ ) { return ; }	Modifies the component in place using.
private int getpermissionindex ( packageinfo packageinfo , string permissionname ) { if ( packageinfo . requestedpermissions != null ) { for ( int i = num_ ; i < packageinfo . requestedpermissions . length ; i ++ ) { if ( permissionname . equals ( packageinfo . requestedpermissions [ i ] ) ) { return i ; } } } return - num_ ; }	Returns the index of the given permission in the PackageInfo.requestedPermissions array, or -1if it's not found.
@ implementation ( minsdk = lollipop ) protected drawable getuserbadgedicon ( drawable icon , userhandle user ) { return icon ; }	Adds a profile badge to the icon.This implementation just returns the unbadged icon, as some default implementations add aninternal resource to the icon that is unavailable to Robolectric.
private boolean hasprofileownerordeviceowneroncurrentuser ( ) { devicepolicymanager devicepolicymanager = ( devicepolicymanager ) context . getsystemservice ( context . device_policy_service ) ; return devicepolicymanager . getprofileowner ( ) != null || ( userhandle . of ( userhandle . myuserid ( ) ) . issystem ( ) && devicepolicymanager . getdeviceowner ( ) != null ) ; }	Returns whether the current user profile has a profile owner or a device owner.
private static char [ ] extractcodepoint ( string codepoint ) { try { return character . tochars ( integer . valueof ( codepoint , num_ ) ) ; } catch ( illegalargumentexception e ) {	Converts code points in a given string to actual characters.
public static < t > t reflector ( class < t > iclass , object target ) { class < ? > targetclass = determinetargetclass ( iclass ) ; constructor < ? extends t > ctor = ( constructor < ? extends t > ) cache . get ( iclass ) ; try { if ( ctor == null ) { class < ? extends t > reflectorclass = createreflectorclass ( iclass , targetclass ) ; ctor = reflectorclass . getconstructor ( targetclass ) ; ctor . setaccessible ( bool_ ) ; } cache . put ( iclass , ctor ) ; return ctor . newinstance ( target ) ; } catch ( nosuchmethodexception | instantiationexception | illegalaccessexception | invocationtargetexception e ) { throw new illegalstateexception ( e ) ; } }	Returns an object which provides accessors for invoking otherwise inaccessible methods andfields.
public static status getstatus ( account account , string authority , boolean create ) { map < account , status > map = syncableaccounts . get ( authority ) ; if ( map == null ) { map = new hashmap < > ( ) ; syncableaccounts . put ( authority , map ) ; } status status = map . get ( account ) ; if ( status == null && create ) { status = new status ( ) ; map . put ( account , status ) ; } return status ; }	Retrieve information on the status of the given account.
public collection < contentobserver > getcontentobservers ( uri uri ) { arraylist < contentobserver > observers = new arraylist < > ( num_ ) ; for ( contentobserverentry entry : contentobservers ) { if ( entry . matches ( uri ) ) { observers . add ( entry . observer ) ; } } return observers ; }	Returns the content observers registered for updates under the given URI.Will be empty if no observer is registered.
public static int adddisplay ( string qualifiersstr ) { int id = getshadowdisplaymanagerglobal ( ) . adddisplay ( createdisplayinfo ( qualifiersstr , null ) ) ; shadowmainlooper ( ) . idle ( ) ; return id ; }	Adds a simulated display and drain the main looper queue to ensure all the callbacks areprocessed.
static void changedisplay ( int displayid , consumer < displayconfig > consumer ) { displayinfo displayinfo = displaymanagerglobal . getinstance ( ) . getdisplayinfo ( displayid ) ; if ( displayinfo != null ) { displayconfig displayconfig = new displayconfig ( displayinfo ) ; consumer . accept ( displayconfig ) ; displayconfig . copyto ( displayinfo ) ; fixnominaldimens ( displayinfo ) ; } getshadowdisplaymanagerglobal ( ) . changedisplay ( displayid , displayinfo ) ; }	Changes properties of a simulated display.
private static string fixtracepath ( string tracepath ) { string defaulttracebody = str_ ; string defaulttraceextension = str_ ; if ( tracepath == null || tracepath . charat ( num_ ) != str_ ) { final file dir = runtimeenvironment . application . getexternalfilesdir ( null ) ; if ( tracepath == null ) { tracepath = new file ( dir , defaulttracebody ) . getabsolutepath ( ) ; } else { tracepath = new file ( dir , tracepath ) . getabsolutepath ( ) ; } } if ( ! tracepath . endswith ( defaulttraceextension ) ) { tracepath += defaulttraceextension ; } return tracepath ; }	Forked from android.os.Debug.
private int findnext ( bitset bits , int value , calendar calendar , int field , int nextfield , list < integer > lowerorders ) { int nextvalue = bits . nextsetbit ( value ) ;	Search the bits provided for the next set bit after the value provided,and reset the calendar.
private void reset ( calendar calendar , list < integer > fields ) { for ( int field : fields ) { calendar . set ( field , field == calendar . day_of_month ? num_ : num_ ) ; } }	Reset the calendar setting all the fields provided to zero.
private void parse ( string expression ) throws illegalargumentexception { string [ ] fields = strings . splitignoreblank ( expression , str_ ) ; if ( fields . length != num_ ) { throw new illegalargumentexception ( string . format ( str_ , fields . length , expression ) ) ; } setnumberhits ( this . seconds , fields [ num_ ] , num_ , num_ ) ; setnumberhits ( this . minutes , fields [ num_ ] , num_ , num_ ) ; setnumberhits ( this . hours , fields [ num_ ] , num_ , num_ ) ; setdaysofmonth ( this . daysofmonth , fields [ num_ ] ) ; setmonths ( this . months , fields [ num_ ] ) ; setdays ( this . daysofweek , replaceordinals ( fields [ num_ ] , str_ ) , num_ ) ; if ( this . daysofweek . get ( num_ ) ) {	Parse the given pattern expression.
private int getargindex ( final int arg ) { int index = ( access & opcodes . acc_static ) == num_ ? num_ : num_ ; for ( int i = num_ ; i < arg ; i ++ ) { index += argumenttypes [ i ] . getsize ( ) ; } return index ; }	Returns the index of the given method argument in the frame's localvariables array.
private void loadinsn ( final type type , final int index ) { mv . visitvarinsn ( type . getopcode ( opcodes . iload ) , index ) ; }	Generates the instruction to push a local variable on the stack.
private void storeinsn ( final type type , final int index ) { mv . visitvarinsn ( type . getopcode ( opcodes . istore ) , index ) ; }	Generates the instruction to store the top stack value in a localvariable.
public void loadargs ( final int arg , final int count ) { int index = getargindex ( arg ) ; for ( int i = num_ ; i < count ; ++ i ) { type t = argumenttypes [ arg + i ] ; loadinsn ( t , index ) ; index += t . getsize ( ) ; } }	Generates the instructions to load the given method arguments on thestack.
public void loadargarray ( ) { push ( argumenttypes . length ) ; newarray ( object_type ) ; for ( int i = num_ ; i < argumenttypes . length ; i ++ ) { dup ( ) ; push ( i ) ; loadarg ( i ) ; box ( argumenttypes [ i ] ) ; arraystore ( object_type ) ; } }	Generates the instructions to load all the method arguments on the stack,as a single object array.
public void loadlocal ( final int local , final type type ) { setlocaltype ( local , type ) ; loadinsn ( type , local ) ; }	Generates the instruction to load the given local variable on the stack.
public void storelocal ( final int local , final type type ) { setlocaltype ( local , type ) ; storeinsn ( type , local ) ; }	Generates the instruction to store the top stack value in the given localvariable.
public void swap ( final type prev , final type type ) { if ( type . getsize ( ) == num_ ) { if ( prev . getsize ( ) == num_ ) { swap ( ) ;	Generates the instructions to swap the top two stack values.
public void box ( final type type ) { if ( type . getsort ( ) == type . object || type . getsort ( ) == type . array ) { return ; } if ( type == type . void_type ) { push ( ( string ) null ) ; } else { type boxed = getboxedtype ( type ) ; newinstance ( boxed ) ; if ( type . getsize ( ) == num_ ) {	Generates the instructions to box the top stack value.
public void unbox ( final type type ) { type t = number_type ; method sig = null ; switch ( type . getsort ( ) ) { case type . void : return ; case type . char : t = character_type ; sig = char_value ; break ; case type . boolean : t = boolean_type ; sig = boolean_value ; break ; case type . double : sig = double_value ; break ; case type . float : sig = float_value ; break ; case type . long : sig = long_value ; break ; case type . int : case type . short : case type . byte : sig = int_value ; } if ( sig == null ) { checkcast ( type ) ; } else { checkcast ( t ) ; invokevirtual ( t , sig ) ; } }	Generates the instructions to unbox the top stack value.
public void ifcmp ( final type type , final int mode , final label label ) { switch ( type . getsort ( ) ) { case type . long : mv . visitinsn ( opcodes . lcmp ) ; break ; case type . double : mv . visitinsn ( mode == ge || mode == gt ? opcodes . dcmpl : opcodes . dcmpg ) ; break ; case type . float : mv . visitinsn ( mode == ge || mode == gt ? opcodes . fcmpl : opcodes . fcmpg ) ; break ; case type . array : case type . object : switch ( mode ) { case eq : mv . visitjumpinsn ( opcodes . if_acmpeq , label ) ; return ; case ne : mv . visitjumpinsn ( opcodes . if_acmpne , label ) ; return ; } throw new illegalargumentexception ( str_ + type ) ; default : int intop = - num_ ; switch ( mode ) { case eq : intop = opcodes . if_icmpeq ; break ; case ne : intop = opcodes . if_icmpne ; break ; case ge : intop = opcodes . if_icmpge ; break ; case lt : intop = opcodes . if_icmplt ; break ; case le : intop = opcodes . if_icmple ; break ; case gt : intop = opcodes . if_icmpgt ; break ; } mv . visitjumpinsn ( intop , label ) ; return ; } mv . visitjumpinsn ( mode , label ) ; }	Generates the instructions to jump to a label based on the comparison ofthe top two stack values.
private void fieldinsn ( final int opcode , final type ownertype , final string name , final type fieldtype ) { mv . visitfieldinsn ( opcode , ownertype . getinternalname ( ) , name , fieldtype . getdescriptor ( ) ) ; }	Generates a get field or set field instruction.
public void getstatic ( final type owner , final string name , final type type ) { fieldinsn ( opcodes . getstatic , owner , name , type ) ; }	Generates the instruction to push the value of a static field on thestack.
public void putstatic ( final type owner , final string name , final type type ) { fieldinsn ( opcodes . putstatic , owner , name , type ) ; }	Generates the instruction to store the top stack value in a static field.
public void getfield ( final type owner , final string name , final type type ) { fieldinsn ( opcodes . getfield , owner , name , type ) ; }	Generates the instruction to push the value of a non static field on thestack.
public void putfield ( final type owner , final string name , final type type ) { fieldinsn ( opcodes . putfield , owner , name , type ) ; }	Generates the instruction to store the top stack value in a non staticfield.
private void invokeinsn ( final int opcode , final type type , final method method , final boolean itf ) { string owner = type . getsort ( ) == type . array ? type . getdescriptor ( ) : type . getinternalname ( ) ; mv . visitmethodinsn ( opcode , owner , method . getname ( ) , method . getdescriptor ( ) , itf ) ; }	Generates an invoke method instruction.
public void invokevirtual ( final type owner , final method method ) { invokeinsn ( opcodes . invokevirtual , owner , method , bool_ ) ; }	Generates the instruction to invoke a normal method.
public void invokeconstructor ( final type type , final method method ) { invokeinsn ( opcodes . invokespecial , type , method , bool_ ) ; }	Generates the instruction to invoke a constructor.
public void invokestatic ( final type owner , final method method ) { invokeinsn ( opcodes . invokestatic , owner , method , bool_ ) ; }	Generates the instruction to invoke a static method.
public void invokeinterface ( final type owner , final method method ) { invokeinsn ( opcodes . invokeinterface , owner , method , bool_ ) ; }	Generates the instruction to invoke an interface method.
public void throwexception ( final type type , final string msg ) { newinstance ( type ) ; dup ( ) ; push ( msg ) ; invokeconstructor ( type , method . getmethod ( str_ ) ) ; throwexception ( ) ; }	Generates the instructions to create and throw an exception.
public void checkcast ( final type type ) { if ( ! type . equals ( object_type ) ) { typeinsn ( opcodes . checkcast , type ) ; } }	Generates the instruction to check that the top stack value is of thegiven type.
private void visitimplicitfirstframe ( ) {	Visit the implicit first frame of this method.
private int startframe ( final int offset , final int nlocal , final int nstack ) { int n = num_ + nlocal + nstack ; if ( frame == null || frame . length < n ) { frame = new int [ n ] ; } frame [ num_ ] = offset ; frame [ num_ ] = nlocal ; frame [ num_ ] = nstack ; return num_ ; }	Starts the visit of a stack map frame.
item newmethoditem ( final string owner , final string name , final string desc , final boolean itf ) { int type = itf ? imeth : meth ; key3 . set ( type , owner , name , desc ) ; item result = get ( key3 ) ; if ( result == null ) { put122 ( type , newclass ( owner ) , newnametype ( name , desc ) ) ; result = new item ( index ++ , key3 ) ; put ( result ) ; } return result ; }	Adds a method reference to the constant pool of the class being build.Does nothing if the constant pool already contains a similar item.
item newfloat ( final float value ) { key . set ( value ) ; item result = get ( key ) ; if ( result == null ) { pool . putbyte ( float ) . putint ( key . intval ) ; result = new item ( index ++ , key ) ; put ( result ) ; } return result ; }	Adds a float to the constant pool of the class being build.
private item newstring ( final string value ) { key2 . set ( str , value , null , null ) ; item result = get ( key2 ) ; if ( result == null ) { pool . put12 ( str , newutf8 ( value ) ) ; result = new item ( index ++ , key2 ) ; put ( result ) ; } return result ; }	Adds a string to the constant pool of the class being build.
item newnametypeitem ( final string name , final string desc ) { key2 . set ( name_type , name , desc , null ) ; item result = get ( key2 ) ; if ( result == null ) { put122 ( name_type , newutf8 ( name ) , newutf8 ( desc ) ) ; result = new item ( index ++ , key2 ) ; put ( result ) ; } return result ; }	Adds a name and type to the constant pool of the class being build.
private item get ( final item key ) { item i = items [ key . hashcode % items . length ] ; while ( i != null && ( i . type != key . type || ! key . isequalto ( i ) ) ) { i = i . next ; } return i ; }	Returns the constant pool's hash table item which is equal to the givenitem.
private void put122 ( final int b , final int s1 , final int s2 ) { pool . put12 ( b , s1 ) . putshort ( s2 ) ; }	Puts one byte and two shorts into the constant pool.
private void put112 ( final int b1 , final int b2 , final int s ) { pool . put11 ( b1 , b2 ) . putshort ( s ) ; }	Puts two bytes and one short into the constant pool.
public void visitenum ( string name , string desc , string value ) { if ( av != null ) { av . visitenum ( name , desc , value ) ; } }	Visits an enumeration value of the annotation.
public annotationvisitor visitannotation ( string name , string desc ) { if ( av != null ) { return av . visitannotation ( name , desc ) ; } return null ; }	Visits a nested annotation value of the annotation.
private static int pos4twist ( double rank , double phase , double period , int horw , int xory , int yorx ) { double dyorx = math . pi * rank * yorx / horw + phase ; double dxory = math . sin ( dyorx ) ; return xory + ( int ) ( dxory * period ) ; }	2. width, y, x.
public void visitparameter ( string name , int access ) { if ( api < opcodes . asm5 ) { throw new runtimeexception ( ) ; } if ( mv != null ) { mv . visitparameter ( name , access ) ; } }	Visits a parameter of this method.
public annotationvisitor visitannotation ( string desc , boolean visible ) { if ( mv != null ) { return mv . visitannotation ( desc , visible ) ; } return null ; }	Visits an annotation of this method.
public annotationvisitor visitparameterannotation ( int parameter , string desc , boolean visible ) { if ( mv != null ) { return mv . visitparameterannotation ( parameter , desc , visible ) ; } return null ; }	Visits an annotation of a parameter this method.
public void visittypeinsn ( int opcode , string type ) { if ( mv != null ) { mv . visittypeinsn ( opcode , type ) ; } }	Visits a type instruction.
public void visitfieldinsn ( int opcode , string owner , string name , string desc ) { if ( mv != null ) { mv . visitfieldinsn ( opcode , owner , name , desc ) ; } }	Visits a field instruction.
@ deprecated public void visitmethodinsn ( int opcode , string owner , string name , string desc ) { if ( api >= opcodes . asm5 ) { boolean itf = opcode == opcodes . invokeinterface ; visitmethodinsn ( opcode , owner , name , desc , itf ) ; return ; } if ( mv != null ) { mv . visitmethodinsn ( opcode , owner , name , desc ) ; } }	Visits a method instruction.
public void visittableswitchinsn ( int min , int max , label dflt , label ... labels ) { if ( mv != null ) { mv . visittableswitchinsn ( min , max , dflt , labels ) ; } }	Visits a TABLESWITCH instruction.
public void visitlookupswitchinsn ( label dflt , int [ ] keys , label [ ] labels ) { if ( mv != null ) { mv . visitlookupswitchinsn ( dflt , keys , labels ) ; } }	Visits a LOOKUPSWITCH instruction.
public void visitmultianewarrayinsn ( string desc , int dims ) { if ( mv != null ) { mv . visitmultianewarrayinsn ( desc , dims ) ; } }	Visits a MULTIANEWARRAY instruction.
public void visitlinenumber ( int line , label start ) { if ( mv != null ) { mv . visitlinenumber ( line , start ) ; } }	Visits a line number declaration.
private int get ( final int local ) { if ( outputlocals == null || local >= outputlocals . length ) {	Returns the output frame local variable type at the given index.
private void set ( final int local , final int type ) {	Sets the output frame local variable type at the given index.
private void push ( final classwriter cw , final string desc ) { int type = type ( cw , desc ) ; if ( type != num_ ) { push ( type ) ; if ( type == long || type == double ) { push ( top ) ; } } }	Pushes a new type onto the output frame stack.
private static int type ( final classwriter cw , final string desc ) { string t ; int index = desc . charat ( num_ ) == str_ ? desc . indexof ( str_ ) + num_ : num_ ; switch ( desc . charat ( index ) ) { case str_ : return num_ ; case str_ : case str_ : case str_ : case str_ : case str_ : return integer ; case str_ : return float ; case str_ : return long ; case str_ : return double ; case str_ :	Returns the int encoding of the given type.
private void pop ( final int elements ) { if ( outputstacktop >= elements ) { outputstacktop -= elements ; } else {	Pops the given number of types from the output frame stack.
private void pop ( final string desc ) { char c = desc . charat ( num_ ) ; if ( c == str_ ) { pop ( ( type . getargumentsandreturnsizes ( desc ) > > num_ ) - num_ ) ; } else if ( c == str_ || c == str_ ) { pop ( num_ ) ; } else { pop ( num_ ) ; } }	Pops a type from the output frame stack.
private void init ( final int var ) {	Adds a new type to the list of types on which a constructor is invoked inthe basic block.
private int init ( final classwriter cw , final int t ) { int s ; if ( t == uninitialized_this ) { s = object | cw . addtype ( cw . thisname ) ; } else if ( ( t & ( dim | base_kind ) ) == uninitialized ) { string type = cw . typetable [ t & base_value ] . strval1 ; s = object | cw . addtype ( type ) ; } else { return t ; } for ( int j = num_ ; j < initializationcount ; ++ j ) { int u = initializations [ j ] ; int dim = u & dim ; int kind = u & kind ; if ( kind == local ) { u = dim + inputlocals [ u & value ] ; } else if ( kind == stack ) { u = dim + inputstack [ inputstack . length - ( u & value ) ] ; } if ( t == u ) { return s ; } } return t ; }	Replaces the given type with the appropriate type if it is one of thetypes on which a constructor is invoked in the basic block.
public void visitsource ( string source , string debug ) { if ( cv != null ) { cv . visitsource ( source , debug ) ; } }	Visits the source of the class.
public void visitouterclass ( string owner , string name , string desc ) { if ( cv != null ) { cv . visitouterclass ( owner , name , desc ) ; } }	Visits the enclosing class of the class.
public annotationvisitor visitannotation ( string desc , boolean visible ) { if ( cv != null ) { return cv . visitannotation ( desc , visible ) ; } return null ; }	Visits an annotation of the class.
public static int extract ( int bs , int low , int high ) { bs = bs > > low ; int mask = num_ ; for ( int i = num_ ; i < ( high - low ) ; i ++ ) { mask += num_ << i ; } return bs & mask ; }	Get part of one integer as a new integer.
public static type getobjecttype ( final string internalname ) { char [ ] buf = internalname . tochararray ( ) ; return new type ( buf [ num_ ] == str_ ? array : object , buf , num_ , buf . length ) ; }	Returns the Java type corresponding to the given internal name.
public static type [ ] getargumenttypes ( final string methoddescriptor ) { char [ ] buf = methoddescriptor . tochararray ( ) ; int off = num_ ; int size = num_ ; while ( bool_ ) { char car = buf [ off ++ ] ; if ( car == str_ ) { break ; } else if ( car == str_ ) { while ( buf [ off ++ ] != str_ ) { } ++ size ; } else if ( car != str_ ) { ++ size ; } } type [ ] args = new type [ size ] ; off = num_ ; size = num_ ; while ( buf [ off ] != str_ ) { args [ size ] = gettype ( buf , off ) ; off += args [ size ] . len + ( args [ size ] . sort == object ? num_ : num_ ) ; size += num_ ; } return args ; }	Returns the Java types corresponding to the argument types of the givenmethod descriptor.
public static type getreturntype ( final string methoddescriptor ) { char [ ] buf = methoddescriptor . tochararray ( ) ; int off = num_ ; while ( bool_ ) { char car = buf [ off ++ ] ; if ( car == str_ ) { return gettype ( buf , off ) ; } else if ( car == str_ ) { while ( buf [ off ++ ] != str_ ) { } } } }	Returns the Java type corresponding to the return type of the givenmethod descriptor.
public static int getargumentsandreturnsizes ( final string desc ) { int n = num_ ; int c = num_ ; while ( bool_ ) { char car = desc . charat ( c ++ ) ; if ( car == str_ ) { car = desc . charat ( c ) ; return n << num_ | ( car == str_ ? num_ : ( car == str_ || car == str_ ? num_ : num_ ) ) ; } else if ( car == str_ ) { while ( desc . charat ( c ++ ) != str_ ) { } n += num_ ; } else if ( car == str_ ) { while ( ( car = desc . charat ( c ) ) == str_ ) { ++ c ; } if ( car == str_ || car == str_ ) { n -= num_ ; } } else if ( car == str_ || car == str_ ) { n += num_ ; } else { n += num_ ; } } }	Computes the size of the arguments and of the return value of a method.
private static type gettype ( final char [ ] buf , final int off ) { int len ; switch ( buf [ off ] ) { case str_ : return void_type ; case str_ : return boolean_type ; case str_ : return char_type ; case str_ : return byte_type ; case str_ : return short_type ; case str_ : return int_type ; case str_ : return float_type ; case str_ : return long_type ; case str_ : return double_type ; case str_ : len = num_ ; while ( buf [ off + len ] == str_ ) { ++ len ; } if ( buf [ off + len ] == str_ ) { ++ len ; while ( buf [ off + len ] != str_ ) { ++ len ; } } return new type ( array , buf , off , len + num_ ) ; case str_ : len = num_ ; while ( buf [ off + len ] != str_ ) { ++ len ; } return new type ( object , buf , off + num_ , len - num_ ) ;	Returns the Java type corresponding to the given type descriptor.
private void getdescriptor ( final stringbuilder buf ) { if ( this . buf == null ) {	Appends the descriptor corresponding to this Java type to the givenstring buffer.
public static string getdescriptor ( final class < ? > c ) { stringbuilder buf = new stringbuilder ( ) ; getdescriptor ( buf , c ) ; return buf . tostring ( ) ; }	Returns the descriptor corresponding to the given Java type.
public int getopcode ( final int opcode ) { if ( opcode == opcodes . iaload || opcode == opcodes . iastore ) {	Returns a JVM instruction opcode adapted to this Java type.
public bytevector putbyte ( final int b ) { int length = this . length ; if ( length + num_ > data . length ) { enlarge ( num_ ) ; } data [ length ++ ] = ( byte ) b ; this . length = length ; return this ; }	Puts a byte into this byte vector.
bytevector put11 ( final int b1 , final int b2 ) { int length = this . length ; if ( length + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) b1 ; data [ length ++ ] = ( byte ) b2 ; this . length = length ; return this ; }	Puts two bytes into this byte vector.
public bytevector putshort ( final int s ) { int length = this . length ; if ( length + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) ( s > > > num_ ) ; data [ length ++ ] = ( byte ) s ; this . length = length ; return this ; }	Puts a short into this byte vector.
bytevector put12 ( final int b , final int s ) { int length = this . length ; if ( length + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) b ; data [ length ++ ] = ( byte ) ( s > > > num_ ) ; data [ length ++ ] = ( byte ) s ; this . length = length ; return this ; }	Puts a byte and a short into this byte vector.
public bytevector putint ( final int i ) { int length = this . length ; if ( length + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) i ; this . length = length ; return this ; }	Puts an int into this byte vector.
public bytevector putlong ( final long l ) { int length = this . length ; if ( length + num_ > data . length ) { enlarge ( num_ ) ; } byte [ ] data = this . data ; int i = ( int ) ( l > > > num_ ) ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) i ; i = ( int ) l ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) ( i > > > num_ ) ; data [ length ++ ] = ( byte ) i ; this . length = length ; return this ; }	Puts a long into this byte vector.
public bytevector pututf8 ( final string s ) { int charlength = s . length ( ) ; if ( charlength > num_ ) { throw new illegalargumentexception ( ) ; } int len = length ; if ( len + num_ + charlength > data . length ) { enlarge ( num_ + charlength ) ; } byte [ ] data = this . data ;	Puts an UTF8 string into this byte vector.
public bytevector putbytearray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { system . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }	Puts an array of bytes into this byte vector.
private void enlarge ( final int size ) { int length1 = num_ * data . length ; int length2 = length + size ; byte [ ] newdata = new byte [ length1 > length2 ? length1 : length2 ] ; system . arraycopy ( data , num_ , newdata , num_ , length ) ; data = newdata ; }	Enlarge this byte vector so that it can receive n more bytes.
@ override public string getcolumnname ( int col ) { return ( col < header . length ) ? columnmapping . get ( header [ col ] . touppercase ( ) ) : null ; }	Retrieves the column name for a given column position.
public void setcolumnmapping ( map < string , string > columnmapping ) { this . columnmapping . clear ( ) ; for ( map . entry < string , string > entry : columnmapping . entryset ( ) ) { this . columnmapping . put ( entry . getkey ( ) . touppercase ( ) , entry . getvalue ( ) ) ; } }	Sets the column mapping to those passed in.
@ override public < t > t getvalue ( string propertyname , class < t > returntype ) { return getcontainer ( ) . getvalue ( propertyname , returntype ) ; }	Returns the value for the given property cast to the passed returnType.If the type of the property and the given return type are not compatible an exception will be thrown.If the passed propertyName is not a defined property, an exception is thrown.
@ override public void init ( configurationvalueprovider ... configurationvalueproviders ) { if ( configurationvalueproviders != null ) { for ( configurationproperty property : getcontainer ( ) . properties . values ( ) ) { property . init ( configurationvalueproviders ) ; } } }	Override default values for properties with the given ConfigurationProviders.
public static iocase forname ( string name ) { if ( iocase . sensitive . name . equals ( name ) ) { return iocase . sensitive ; } if ( iocase . insensitive . name . equals ( name ) ) { return iocase . insensitive ; } if ( iocase . system . name . equals ( name ) ) { return iocase . system ; } throw new illegalargumentexception ( str_ + name ) ; }	Factory method to create an IOCase from a name.
string convertcase ( string str ) { if ( str == null ) { return null ; } return issensitive ? str : str . tolowercase ( ) ; }	Converts the case of the input String to a standard format.Subsequent operations can then use standard String methods.
public object getcurrentvalue ( change change ) { try { for ( propertydescriptor descriptor : propertyutils . getinstance ( ) . getdescriptors ( change . getclass ( ) ) ) { if ( descriptor . getdisplayname ( ) . equals ( this . parametername ) ) { method readmethod = descriptor . getreadmethod ( ) ; if ( readmethod == null ) { readmethod = change . getclass ( ) . getmethod ( str_ + stringutil . uppercasefirst ( descriptor . getname ( ) ) ) ; } return readmethod . invoke ( change ) ; } } throw new runtimeexception ( str_ + this . parametername ) ; } catch ( exception e ) { throw new unexpectedliquibaseexception ( e ) ; } }	Returns the current value of this parameter for the given Change.
public static < t > t [ ] createifnull ( t [ ] arguments ) { if ( arguments == null ) { return ( t [ ] ) new object [ num_ ] ; } else { return arguments ; } }	Returns a new empty array if the passed array is null.
public static < t > set < t > createifnull ( set < t > currentvalue ) { if ( currentvalue == null ) { return new hashset < > ( ) ; } else { return currentvalue ; } }	Returns a new empty set if the passed array is null.
private boolean getglobalparam ( map property ) { boolean global = null ; object globalobj = property . get ( str_ ) ; if ( globalobj == null ) {	Extract the global parameter from the properties.
protected void attachparams ( list < columnconfig > cols , preparedstatement stmt ) throws sqlexception , databaseexception { int i = num_ ;	Sets the list of bind variables for the execution of a DML statement.
public string getabsolutepath ( string path ) { string p = path ; file f = new file ( p ) ; if ( ! f . isabsolute ( ) ) { string basepath = filenameutils . getfullpath ( changeset . getchangelog ( ) . getphysicalfilepath ( ) ) ; p = filenameutils . normalize ( basepath + p ) ; } return p ; }	Gets absolute and normalized path for path.If path is relative, absolute path is calculated relative to change log file.
public static checksum parse ( string checksumvalue ) { if ( checksumvalue == null ) { return null ; }	Parse the given storedCheckSum string value and return a new CheckSum object.
public static checksum compute ( string valuetochecksum ) { return new checksum ( md5util . computemd5 (	Compute a storedCheckSum of the given string.
protected classloader getclassloaderincludingprojectclasspath ( ) throws mojoexecutionexception { try { list classpathelements = project . getcompileclasspathelements ( ) ; classpathelements . add ( project . getbuild ( ) . getoutputdirectory ( ) ) ; url urls [ ] = new url [ classpathelements . size ( ) ] ; for ( int i = num_ ; i < classpathelements . size ( ) ; ++ i ) { urls [ i ] = new file ( ( string ) classpathelements . get ( i ) ) . touri ( ) . tourl ( ) ; } return new urlclassloader ( urls , getmavenartifactclassloader ( ) ) ; } catch ( exception e ) { throw new mojoexecutionexception ( str_ , e ) ; } }	Returns an isolated classloader.
protected void printsettings ( string indent ) { if ( indent == null ) { indent = str_ ; } getlog ( ) . info ( indent + str_ + driver ) ; getlog ( ) . info ( indent + str_ + url ) ; getlog ( ) . info ( indent + str_ + username ) ; getlog ( ) . info ( indent + str_ + str_ ) ; getlog ( ) . info ( indent + str_ + emptypassword ) ; getlog ( ) . info ( indent + str_ + propertyfile ) ; getlog ( ) . info ( indent + str_ + propertyfilewilloverride ) ; getlog ( ) . info ( indent + str_ + promptonnonlocaldatabase ) ; getlog ( ) . info ( indent + str_ + clearchecksums ) ; }	Prints the settings that have been set of defaulted for the plugin.
protected void parsepropertiesfile ( inputstream propertiesinputstream ) throws mojoexecutionexception { if ( propertiesinputstream == null ) { throw new mojoexecutionexception ( str_ ) ; } properties props = new properties ( ) ; try { props . load ( propertiesinputstream ) ; } catch ( ioexception e ) { throw new mojoexecutionexception ( str_ , e ) ; } for ( iterator it = props . keyset ( ) . iterator ( ) ; it . hasnext ( ) ; ) { string key = null ; try { key = ( string ) it . next ( ) ; field field = mavenutils . getdeclaredfield ( this . getclass ( ) , key ) ; if ( propertyfilewilloverride ) { getlog ( ) . debug ( str_ + field . getname ( ) ) ; setfieldvalue ( field , props . get ( key ) . tostring ( ) ) ; } else { if ( ! iscurrentfieldvaluespecified ( field ) ) { getlog ( ) . debug ( str_ + field . getname ( ) ) ; setfieldvalue ( field , props . get ( key ) . tostring ( ) ) ; } } } catch ( exception e ) { getlog ( ) . info ( str_ + key + str_ + str_ ) ; } } }	Parses a properties file and sets the associated fields in the plugin.
private boolean iscurrentfieldvaluespecified ( field f ) throws illegalaccessexception { object currentvalue = f . get ( this ) ; if ( currentvalue == null ) { return bool_ ; } object defaultvalue = getdefaultvalue ( f ) ; if ( defaultvalue == null ) { return currentvalue != null ; } else {	This method will check to see if the user has specified a value different to that ofthe default value.
public void writenext ( string [ ] nextline , boolean applyquotestoall ) { if ( nextline == null ) { return ; } stringbuilder sb = new stringbuilder ( nextline . length * num_ ) ;	Writes the next line to the file.
protected boolean stringcontainsspecialcharacters ( string line ) { return ( line . indexof ( quotechar ) != - num_ ) || ( line . indexof ( escapechar ) != - num_ ) || ( line . indexof ( separator ) != - num_ ) || line . contains ( default_line_end ) || line . contains ( str_ ) ; }	checks to see if the line contains special characters.
protected stringbuilder processline ( string nextelement ) { stringbuilder sb = new stringbuilder ( nextelement . length ( ) * num_ ) ;	Processes all the characters in a line.
private void processcharacter ( stringbuilder sb , char nextchar ) { if ( ( escapechar != no_escape_character ) && checkcharacterstoescape ( nextchar ) ) { sb . append ( escapechar ) . append ( nextchar ) ; } else { sb . append ( nextchar ) ; } }	Appends the character to the StringBuilder adding the escape character if needed.
protected object valueof ( object value ) { if ( value == null ) { return value ; } else if ( type . isassignablefrom ( value . getclass ( ) ) ) { return value ; } else if ( value instanceof string ) { if ( type . equals ( boolean . class ) ) { return boolean . valueof ( ( string ) value ) ; } else if ( type . equals ( integer . class ) ) { return integer . valueof ( ( string ) value ) ; } else if ( type . equals ( bigdecimal . class ) ) { return new bigdecimal ( ( string ) value ) ; } else if ( type . equals ( long . class ) ) { return long . valueof ( ( string ) value ) ; } else if ( type . equals ( list . class ) ) { return stringutil . splitandtrim ( ( string ) value , str_ ) ; } else { throw new unexpectedliquibaseexception ( str_ + value . getclass ( ) . getsimplename ( ) + str_ + type . getsimplename ( ) ) ; } } else { throw new unexpectedliquibaseexception ( str_ + value . getclass ( ) . getsimplename ( ) + str_ + type . getsimplename ( ) ) ; } }	Converts an object of a different type to the type used by this property.
public < t > t getvalue ( class < t > type ) { if ( ! this . type . isassignablefrom ( type ) ) { throw new unexpectedliquibaseexception ( str_ + name + str_ + this . type . getsimplename ( ) + str_ + type . getsimplename ( ) ) ; } return ( t ) value ; }	Returns the value currently stored in this property cast to the given type.
public void setvalue ( object value ) { if ( ( value != null ) && ! type . isassignablefrom ( value . getclass ( ) ) ) { throw new unexpectedliquibaseexception ( str_ + name + str_ + type . getsimplename ( ) + str_ + value . getclass ( ) . getsimplename ( ) ) ; } this . value = value ; wasoverridden = bool_ ; }	Overwrites the value currently stored in this property.
public configurationproperty addalias ( string ... aliases ) { if ( aliases != null ) { this . aliases . addall ( arrays . aslist ( aliases ) ) ; } return this ; }	Adds an alias for this property.
public configurationproperty setdefaultvalue ( object defaultvalue ) { if ( ( defaultvalue != null ) && ! type . isassignablefrom ( defaultvalue . getclass ( ) ) ) { if ( ( type == long . class ) && ( defaultvalue instanceof integer ) ) { return setdefaultvalue ( ( ( integer ) defaultvalue ) . longvalue ( ) ) ; } throw new unexpectedliquibaseexception ( str_ + name + str_ + type . getsimplename ( ) + str_ + defaultvalue . getclass ( ) . getsimplename ( ) ) ; } this . defaultvalue = defaultvalue ; return this ; }	Sets the default value to use if no ConfigurationProviders override it.
private boolean applyiscomputedexpressionheuristic ( columnconfig column , database database ) { string expr = column . getname ( ) ; string regex = str_	An imperfect heuristic to determine if an expression is more likely a column name or a computed expression.
public void tag ( string tagstring ) throws liquibaseexception { lockservice lockservice = lockservicefactory . getinstance ( ) . getlockservice ( database ) ; lockservice . waitforlock ( ) ; try { changeloghistoryservicefactory . getinstance ( ) . getchangelogservice ( database ) . generatedeploymentid ( ) ; checkliquibasetables ( bool_ , null , new contexts ( ) , new labelexpression ( ) ) ; getdatabase ( ) . tag ( tagstring ) ; } finally { try { lockservice . releaselock ( ) ; } catch ( lockexception e ) { log . severe ( logtype . log , msg_could_not_release_lock , e ) ; } } }	'Tags' the database for future rollback.
public databasechangeloglock [ ] listlocks ( ) throws liquibaseexception { checkliquibasetables ( bool_ , null , new contexts ( ) , new labelexpression ( ) ) ; return lockservicefactory . getinstance ( ) . getlockservice ( database ) . listlocks ( ) ; }	Display change log lock information.
public list < changesetstatus > getchangesetstatuses ( contexts contexts , labelexpression labelexpression , boolean checkliquibasetables ) throws liquibaseexception { changelogparameters . setcontexts ( contexts ) ; changelogparameters . setlabels ( labelexpression ) ; databasechangelog changelog = getdatabasechangelog ( ) ; if ( checkliquibasetables ) { checkliquibasetables ( bool_ , changelog , contexts , labelexpression ) ; } changelog . validate ( database , contexts , labelexpression ) ; changelogiterator logiterator = getstandardchangelogiterator ( contexts , labelexpression , changelog ) ; statusvisitor visitor = new statusvisitor ( database ) ; logiterator . run ( visitor , new runtimeenvironment ( database , contexts , labelexpression ) ) ; return visitor . getstatuses ( ) ; }	Returns the ChangeSetStatuses of all changesets in the change log file and history in the order theywould be ran.
public void clearchecksums ( ) throws liquibaseexception { log . info ( logtype . log , str_ ) ; lockservice lockservice = lockservicefactory . getinstance ( ) . getlockservice ( database ) ; lockservice . waitforlock ( ) ; try { checkliquibasetables ( bool_ , null , new contexts ( ) , new labelexpression ( ) ) ; updatestatement updatestatement = new updatestatement ( getdatabase ( ) . getliquibasecatalogname ( ) , getdatabase ( ) . getliquibaseschemaname ( ) , getdatabase ( ) . getdatabasechangelogtablename ( ) ) ; updatestatement . addnewcolumnvalue ( str_ , null ) ; executorservice . getinstance ( ) . getexecutor ( database ) . execute ( updatestatement ) ; getdatabase ( ) . commit ( ) ; } finally { try { lockservice . releaselock ( ) ; } catch ( lockexception e ) { log . severe ( logtype . log , msg_could_not_release_lock , e ) ; } } resetservices ( ) ; }	Sets checksums to null so they will be repopulated next run.
public list < t > parse ( mappingstrategy < t > mapper , reader reader ) { return parse ( mapper , new csvreader ( reader ) ) ; }	parse the values from a csvReader constructed from the passed in Reader.
protected t processline ( mappingstrategy < t > mapper , string [ ] line ) throws reflectiveoperationexception , introspectionexception { t bean = mapper . createbean ( ) ; for ( int col = num_ ; col < line . length ; col ++ ) { if ( mapper . isannotationdriven ( ) ) { processfield ( mapper , line , bean , col ) ; } else { processproperty ( mapper , line , bean , col ) ; } } return bean ; }	Creates a single object from a line from the csv file.
protected propertyeditor getpropertyeditor ( propertydescriptor desc ) throws reflectiveoperationexception { class < ? > cls = desc . getpropertyeditorclass ( ) ; if ( null != cls ) { return ( propertyeditor ) cls . getconstructor ( ) . newinstance ( ) ; } return getpropertyeditorvalue ( desc . getpropertytype ( ) ) ; }	Attempt to find custom property editor on descriptor first, else try the propery editor manager.
protected void addifmatching ( packagescanfilter test , string fqn , set < class < ? > > classes ) { try { string externalname = fqn . substring ( num_ , fqn . indexof ( str_ ) ) . replace ( str_ , str_ ) ; set < classloader > set = getclassloaders ( ) ; boolean found = bool_ ; for ( classloader classloader : set ) { log . fine ( logtype . log , str_ + externalname + str_ + test + str_ + classloader ) ; try { class < ? > type = classloader . loadclass ( externalname ) ; log . fine ( logtype . log , str_ + type + str_ + classloader ) ; if ( test . matches ( type ) ) { log . fine ( logtype . log , str_ + type + str_ + classloader ) ; classes . add ( type ) ; } found = bool_ ; break ; } catch ( classnotfoundexception e ) { log . fine ( logtype . log , str_ + fqn + str_ + classloader + str_ + e , e ) ; } catch ( linkageerror e ) { log . fine ( logtype . log , str_ + fqn + str_ + classloader + str_ + e , e ) ; } catch ( exception e ) { log . severe ( logtype . log , str_ + fqn + str_ + classloader + str_ + e , e ) ; } } if ( ! found ) {	Add the class designated by the fully qualified class name provided tothe set of resolved classes if and only if it is approved by the Testsupplied.
public static class getpropertytype ( object object , string propertyname ) { method readmethod = getreadmethod ( object , propertyname ) ; if ( readmethod == null ) { return null ; } return readmethod . getreturntype ( ) ; }	Tried to determine the appropriate reader method for a given propertyName of a given object and, if found,returns the class of its return type.
public static boolean hasproperty ( object object , string propertyname ) { return hasreadproperty ( object , propertyname ) && haswriteproperty ( object , propertyname ) ; }	Examines the given object's class and returns true if reader and writer methods both exist for thegiven property name.
private static method getreadmethod ( object object , string propertyname ) { string getmethodname = str_ + propertyname . substring ( num_ , num_ ) . touppercase ( locale . english ) + propertyname . substring ( num_ ) ; string ismethodname = str_ + propertyname . substring ( num_ , num_ ) . touppercase ( locale . english ) + propertyname . substring ( num_ ) ; method [ ] methods = getmethods ( object ) ; for ( method method : methods ) { if ( ( method . getname ( ) . equals ( getmethodname ) || method . getname ( ) . equals ( ismethodname ) ) && ( method . getparametertypes ( ) . length == num_ ) ) { return method ; } } return null ; }	Tries to find the Java method to read a given propertyName for the given object.
private static method getwritemethod ( object object , string propertyname ) { string methodname = str_ + propertyname . substring ( num_ , num_ ) . touppercase ( locale . english ) + propertyname . substring ( num_ ) ; method [ ] methods = getmethods ( object ) ; for ( method method : methods ) { if ( method . getname ( ) . equals ( methodname ) && ( method . getparametertypes ( ) . length == num_ ) ) { return method ; } } return null ; }	Tries to find the Java method to write a new value for a given propertyName to the given object.
private static method [ ] getmethods ( object object ) { method [ ] methods = methodcache . get ( object . getclass ( ) ) ; if ( methods == null ) { methods = object . getclass ( ) . getmethods ( ) ; methodcache . put ( object . getclass ( ) , methods ) ; } return methods ; }	Determines the class of a given object and returns an array of that class's methods.
protected object undocollection ( object potentialcollection , object otherobject ) { if ( ( potentialcollection != null ) && ( otherobject != null ) && ( potentialcollection instanceof collection ) && ! ( otherobject instanceof collection ) ) { if ( ( ( ( collection ) potentialcollection ) . size ( ) == num_ ) && ( ( collection ) potentialcollection ) . iterator ( ) . next ( ) . getclass ( ) . equals ( otherobject . getclass ( ) ) ) { potentialcollection = ( ( collection ) potentialcollection ) . iterator ( ) . next ( ) ; } } return potentialcollection ; }	Sometimes an attribute in one object is a single-entity collection and on the other it is just the object.Check the passed potentialCollection and if it is a single-entry collection of the same type as the otherObject, return just the collection element.Otherwise, return the original collection.
public list < foreignkey > getoutgoingforeignkeys ( ) { list < foreignkey > fklist = getattribute ( str_ , list . class ) ; return ( ( fklist == null ) ? new arraylist < foreignkey > ( num_ ) : fklist ) ; }	Returns the list of all outgoing FOREIGN KEYS from this table.
cdiliquibaseconfig filelocked ( final string id , callable < cdiliquibaseconfig > action ) throws exception { log . info ( logtype . log , string . format ( str_ , id ) ) ; string lockpath = string . format ( str_ , root_path ) ; file lockfile = new file ( lockpath ) ; if ( ! lockfile . exists ( ) && lockfile . createnewfile ( ) ) { log . info ( logtype . log , string . format ( str_ , id , lockpath ) ) ; } log . info ( logtype . log , string . format ( str_ , id , lockpath ) ) ; cdiliquibaseconfig actionresult = null ; filelock lock = null ; try ( fileoutputstream filestream = new fileoutputstream ( lockpath ) ; filechannel filechannel = filestream . getchannel ( ) ; ) { while ( null == lock ) { try { lock = filechannel . trylock ( ) ; } catch ( overlappingfilelockexception e ) { log . fine ( logtype . log , string . format ( str_ , id ) ) ; } if ( null == lock ) { log . fine ( logtype . log , string . format ( str_ , id ) ) ; thread . sleep ( file_lock_timeout ) ; } } log . info ( logtype . log , string . format ( str_ , id ) ) ; actionresult = action . call ( ) ; lock . release ( ) ; } catch ( exception e ) { log . warning ( logtype . log , e . getmessage ( ) , e ) ; } return actionresult ; }	Synchronization among multiple JVM's.
public static string getsimplepathforresources ( string entryname , string path ) { string [ ] components = path . split ( str_ ) ; if ( components . length == num_ ) { if ( components [ num_ ] . endswith ( str_ ) ) { return components [ num_ ] . substring ( num_ ) ; } else { return entryname . replacefirst ( components [ num_ ] , str_ ) . substring ( num_ ) ; } } return entryname ; }	Method used to simplify an entryNameEx: with path jar:/some/jar.jar!/BOOT-INF/classes!/db/changelog and entryName /BOOT-INF/classes/db/changelogThe simple entry name for Spring is db/changelog(/BOOT-INF/classes/ is not needed and break the liquibase alphabetical sort order).
public boolean isfilteredby ( class < ? extends changesetfilter > filtertype ) { if ( ! willrun ) { return bool_ ; } if ( filterresults == null ) { return bool_ ; } for ( changesetfilterresult result : filterresults ) { if ( result . getfilter ( ) . equals ( filtertype ) ) { return bool_ ; } } return bool_ ; }	Convenience method to check wither a given ChangeSetFilter type is a reason for running the change set or not.
public static string getvalueforcolumn ( resultset rs , string columnnametocheck , database database ) throws sqlexception { resultsetmetadata metadata = rs . getmetadata ( ) ; int numberofcolumns = metadata . getcolumncount ( ) ; string correctedcolumnname = database . correctobjectname ( columnnametocheck , column . class ) ;	Checks whether a result set has a column matching the specified column name.The column name is first changed to match the database format.E.g.
public void init ( configurationvalueprovider ... configurationvalueproviders ) { if ( configurationvalueproviders == null ) { configurationvalueproviders = new configurationvalueprovider [ num_ ] ; } this . configurationvalueproviders = configurationvalueproviders ; this . reset ( ) ; }	Re-initialize the configuration with the given ConfigurationProviders.
public static void initializedatabase ( string username , string defaultcatalogname , string defaultschemaname , database database ) throws databaseexception { if ( ( ( defaultcatalogname != null ) || ( defaultschemaname != null ) ) && ! ( database . getconnection ( ) instanceof offlineconnection ) ) { if ( database instanceof oracledatabase ) { string schema = defaultcatalogname ; if ( schema == null ) { schema = defaultschemaname ; } executorservice . getinstance ( ) . getexecutor ( database ) . execute ( new rawsqlstatement ( str_ + database . escapeobjectname ( schema , schema . class ) ) ) ; } else if ( database instanceof postgresdatabase && defaultschemaname != null ) { executorservice . getinstance ( ) . getexecutor ( database ) . execute ( new rawsqlstatement ( str_ + database . escapeobjectname ( defaultschemaname , schema . class ) ) ) ; } else if ( database instanceof abstractdb2database ) { string schema = defaultcatalogname ; if ( schema == null ) { schema = defaultschemaname ; } executorservice . getinstance ( ) . getexecutor ( database ) . execute ( new rawsqlstatement ( str_ + schema ) ) ; } else if ( database instanceof mysqldatabase ) { string schema = defaultcatalogname ; if ( schema == null ) { schema = defaultschemaname ; } executorservice . getinstance ( ) . getexecutor ( database ) . execute ( new rawsqlstatement ( str_ + schema ) ) ; } } }	Executes RawSqlStatements particular to each database engine to set the default schema for the given Database.
public static boolean namematches ( databaseobject databaseobject1 , databaseobject databaseobject2 , database accordingto ) { string object1name = accordingto . correctobjectname ( databaseobject1 . getname ( ) , databaseobject1 . getclass ( ) ) ; string object2name = accordingto . correctobjectname ( databaseobject2 . getname ( ) , databaseobject2 . getclass ( ) ) ; if ( ( object1name == null ) && ( object2name == null ) ) { return bool_ ; } if ( ( object1name == null ) || ( object2name == null ) ) { return bool_ ; } if ( accordingto . iscasesensitive ( ) ) { return object1name . equals ( object2name ) ; } else { return object1name . equalsignorecase ( object2name ) ; } }	Static so it can be used in other comparators if needed.
private void setvalidateoptionifavailable ( database database , foreignkey foreignkey , cachedrow cachedrow ) { if ( ! ( database instanceof oracledatabase ) ) { return ; } final string constraintvalidate = cachedrow . getstring ( str_ ) ; final string validate = str_ ; if ( constraintvalidate != null && ! constraintvalidate . isempty ( ) ) { foreignkey . setshouldvalidate ( validate . equals ( cleannamefromdatabase ( constraintvalidate . trim ( ) , database ) ) ) ; } }	Method to map 'validate' option for FK. This thing works only for ORACLE.
public boolean addtype ( class < ? extends databaseobject > type , database database ) { boolean added = this . types . add ( type ) ; if ( added ) { for ( class < ? extends databaseobject > container : snapshotgeneratorfactory . getinstance ( ) . getcontainertypes ( type , database ) ) { addtype ( container , database ) ; } } return added ; }	Adds a new DatabaseObject type to the list of object types to be included in snapshots.
@ override public void afterpropertiesset ( ) throws liquibaseexception { configurationproperty shouldrunproperty = liquibaseconfiguration . getinstance ( ) . getproperty ( globalconfiguration . class , globalconfiguration . should_run ) ; if ( ! shouldrunproperty . getvalue ( boolean . class ) ) { scope . getcurrentscope ( ) . getlog ( getclass ( ) ) . info ( logtype . log , str_ + liquibaseconfiguration . getinstance ( ) . describevaluelookuplogic ( shouldrunproperty ) + str_ ) ; return ; } if ( ! shouldrun ) { scope . getcurrentscope ( ) . getlog ( getclass ( ) ) . info ( logtype . log , str_ + str_ + str_ + getbeanname ( ) + str_ ) ; return ; } connection c = null ; liquibase liquibase = null ; try { c = getdatasource ( ) . getconnection ( ) ; liquibase = createliquibase ( c ) ; generaterollbackfile ( liquibase ) ; performupdate ( liquibase ) ; } catch ( sqlexception e ) { throw new databaseexception ( e ) ; } finally { database database = null ; if ( liquibase != null ) { database = liquibase . getdatabase ( ) ; } if ( database != null ) { database . close ( ) ; } } }	Executed automatically when the bean is initialized.
protected string checkfortrim ( string s , propertydescriptor prop ) { return trimmableproperty ( prop ) ? s . trim ( ) : s ; }	Returns the trimmed value of the string only if the property the string is describing should be trimmedto be converted to that type.
protected object convertvalue ( string value , propertydescriptor prop ) throws reflectiveoperationexception { propertyeditor editor = getpropertyeditor ( prop ) ; object obj = value ; if ( null != editor ) { editor . setastext ( value ) ; obj = editor . getvalue ( ) ; } return obj ; }	Convert a string value to its Object value.
public static void main ( string [ ] args ) { int errorlevel = num_ ; try { errorlevel = run ( args ) ; } catch ( throwable e ) { system . exit ( - num_ ) ; } system . exit ( errorlevel ) ; }	Entry point. This is what gets executes when starting this program from the command line. This is actuallya simple wrapper so that an errorlevel of != 0 is guaranteed in case of an uncaught exception.
@ suppresswarnings ( str_ ) private static string [ ] splitarg ( string arg ) throws commandlineparsingexception { string [ ] splitarg = arg . split ( str_ , num_ ) ; if ( splitarg . length < num_ ) { throw new commandlineparsingexception ( string . format ( corebundle . getstring ( str_ ) , arg ) ) ; } splitarg [ num_ ] = splitarg [ num_ ] . replacefirst ( str_ , str_ ) ; return splitarg ; }	What the number 2 stands for is obvious from the context.
private static boolean isnoargcommand ( string arg ) { return commands . migrate . equals ( arg ) || commands . migrate_sql . equalsignorecase ( arg ) || commands . update . equalsignorecase ( arg ) || commands . update_sql . equalsignorecase ( arg ) || commands . future_rollback_sql . equalsignorecase ( arg ) || commands . update_testing_rollback . equalsignorecase ( arg ) || commands . list_locks . equalsignorecase ( arg ) || commands . drop_all . equalsignorecase ( arg ) || commands . release_locks . equalsignorecase ( arg ) || commands . validate . equalsignorecase ( arg ) || commands . help . equalsignorecase ( arg ) || commands . clear_checksums . equalsignorecase ( arg ) || commands . changelog_sync . equalsignorecase ( arg ) || commands . changelog_sync_sql . equalsignorecase ( arg ) || commands . mark_next_changeset_ran . equalsignorecase ( arg ) || commands . mark_next_changeset_ran_sql . equalsignorecase ( arg ) ; }	Returns true if the given main command arg needs no special parameters.
private static file extract ( jarfile jar , jarentry entry ) throws ioexception {	Extract a single object from a JAR file into a temporary file.
private void parsedefaultpropertyfilefromresource ( file potentialpropertyfile ) throws ioexception , commandlineparsingexception { try ( inputstream resourceasstream = getclass ( ) . getclassloader ( ) . getresourceasstream ( potentialpropertyfile . getabsolutepath ( ) ) ) { if ( resourceasstream != null ) { parsepropertiesfile ( resourceasstream ) ; } } }	Open a property file that is embedded as a Java resource and parse it.
protected string [ ] fixupargs ( string [ ] args ) { list < string > fixedargs = new arraylist < > ( ) ; for ( int i = num_ ; i < args . length ; i ++ ) { string arg = args [ i ] ; if ( ( arg . startswith ( str_ ) || arg . startswith ( str_ ) ) && ! arg . contains ( str_ ) ) { string nextarg = null ; if ( ( i + num_ ) < args . length ) { nextarg = args [ i + num_ ] ; } if ( ( nextarg != null ) && ! nextarg . startswith ( str_ ) && ! iscommand ( nextarg ) ) { arg = arg + str_ + nextarg ; i ++ ; } }	On windows machines, it splits args on '=' signs.
protected list < string > checksetup ( ) { list < string > messages = new arraylist < > ( ) ; if ( command == null ) { messages . add ( corebundle . getstring ( str_ ) ) ; } else if ( ! iscommand ( command ) ) { messages . add ( string . format ( corebundle . getstring ( str_ ) , command ) ) ; } else { if ( stringutil . trimtonull ( url ) == null ) { messages . add ( string . format ( corebundle . getstring ( str_ ) , str_ + options . url ) ) ; } if ( ischangelogrequired ( command ) && ( stringutil . trimtonull ( changelogfile ) == null ) ) { messages . add ( string . format ( corebundle . getstring ( str_ ) , str_ + options . changelog_file ) ) ; } if ( isnoargcommand ( command ) && ! commandparams . isempty ( ) ) { messages . add ( corebundle . getstring ( errormsg_unexpected_parameters ) + commandparams ) ; } else { validatecommandparameters ( messages ) ; } } return messages ; }	After parsing, checks if the given combination of main command and can be executed.
private void checkformissingcommandparameters ( final list < string > messages ) { if ( ( commandparams . isempty ( ) || commandparams . iterator ( ) . next ( ) . startswith ( str_ ) ) && ( commands . calculate_checksum . equalsignorecase ( command ) ) ) { messages . add ( corebundle . getstring ( str_ ) ) ; } }	Checks for missing command line parameters and, if any problems are found,returns the list of issues in String form.
private void checkformalformedcommandparameters ( final list < string > messages ) { if ( commandparams . isempty ( ) ) { return ; } final int changeset_minimum_identifier_parts = num_ ; if ( commands . calculate_checksum . equalsignorecase ( command ) ) { for ( final string param : commandparams ) { if ( ( param != null ) && ! param . startswith ( str_ ) ) { final string [ ] parts = param . split ( str_ ) ; if ( parts . length < changeset_minimum_identifier_parts ) { messages . add ( corebundle . getstring ( str_ ) ) ; break ; } } } } else if ( commands . diff_changelog . equalsignorecase ( command ) && ( difftypes != null ) && difftypes . tolowercase ( ) . contains ( str_ ) ) { messages . add ( string . format ( corebundle . getstring ( str_ ) , options . diff_types , commands . generate_changelog ) ) ; } }	Checks for incorrectly written command line parameters and, if any problems are found,returns the list of issues in String form.
protected void printhelp ( list < string > errormessages , printstream stream ) { stream . println ( corebundle . getstring ( str_ ) ) ; for ( string message : errormessages ) { stream . println ( str_ + message ) ; } stream . println ( ) ; }	If any errors have been found, print the list of errors first, then print the command line help text.
protected void printhelp ( printstream stream ) { string helptext = commandlinehelpbundle . getstring ( str_ ) ; stream . println ( helptext ) ; }	Print instructions on how to use this program from the command line.
protected void parseoptions ( string [ ] paramargs ) throws commandlineparsingexception { string [ ] args = fixupargs ( paramargs ) ; boolean seencommand = bool_ ; for ( string arg : args ) { if ( iscommand ( arg ) ) { this . command = arg ; if ( this . command . equalsignorecase ( commands . migrate ) ) { this . command = commands . update ; } else if ( this . command . equalsignorecase ( commands . migrate_sql ) ) { this . command = commands . update_sql ; } seencommand = bool_ ; } else if ( seencommand ) {	Parses the command line options.
private string getcommandparam ( string paramname , string defaultvalue ) throws commandlineparsingexception { for ( string param : commandparams ) { if ( ! param . contains ( str_ ) ) { continue ; } string [ ] splitarg = splitarg ( param ) ; string attributename = splitarg [ num_ ] ; string value = splitarg [ num_ ] ; if ( attributename . equalsignorecase ( paramname ) ) { return value ; } } return defaultvalue ; }	Returns the value for a command line parameter of the form parameterName=value, or defaultValue if thatparameter has not been specified by the user.
public static integer readinteger ( string value ) { if ( value == null ) { return null ; } return integer . valueof ( value ) ; }	Convenience method for converting a string to an Integer object.
public boolean matches ( labels runtimelabels ) { if ( ( runtimelabels == null ) || runtimelabels . isempty ( ) ) { return bool_ ; } if ( this . labels . isempty ( ) ) { return bool_ ; } for ( string expression : this . labels ) { if ( matches ( expression , runtimelabels ) ) { return bool_ ; } } return bool_ ; }	Returns true if the passed runtime labels match this label expression.
public boolean has ( databaseobject example , database database ) throws databaseexception , invalidexampleexception {	Checks if a specific object is present in a database.
public databasesnapshot createsnapshot ( databaseobject [ ] examples , database database , snapshotcontrol snapshotcontrol ) throws databaseexception , invalidexampleexception { databaseconnection conn = database . getconnection ( ) ; if ( conn == null ) { return new emptydatabasesnapshot ( database , snapshotcontrol ) ; } if ( conn instanceof offlineconnection ) { databasesnapshot snapshot = ( ( offlineconnection ) conn ) . getsnapshot ( examples ) ; if ( snapshot == null ) { throw new databaseexception ( str_ ) ; } return snapshot ; } return new jdbcdatabasesnapshot ( examples , database , snapshotcontrol ) ; }	Creates a database snapshot for a given array of DatabaseObjects.
public < t extends databaseobject > t createsnapshot ( t example , database database ) throws databaseexception , invalidexampleexception { return createsnapshot ( example , database , new snapshotcontrol ( database ) ) ; }	Creates a DatabaseSnapshot for a single DatabaseObject.
private list < dropforeignkeyconstraintchange > generatechildren ( database database ) {	Iterates through all the FOREIGN KEYs of the target table and outputs a list of DropForeignKeyConstraintChangesfor a given database type.
private static void cleandirectory ( final file directory ) throws ioexception { if ( ! directory . exists ( ) ) { return ; } if ( ! directory . isdirectory ( ) ) { return ; } ioexception exception = null ; final file [ ] files = directory . listfiles ( ) ; if ( files != null ) { for ( final file file : files ) { try { cleandirectory ( file ) ; if ( ! file . delete ( ) ) { throw new ioexception ( str_ + file . getabsolutepath ( ) ) ; } } catch ( final ioexception ioe ) { exception = ioe ; } } } if ( null != exception ) { throw exception ; } }	Clean a directory without deleting it.
public static string [ ] splitsql ( string multilinesql , string enddelimiter ) { return processmutlilinesql ( multilinesql , bool_ , bool_ , enddelimiter ) ; }	Splits a candidate multi-line SQL statement along ;'s and "go"'s.
public static string pad ( string value , int length ) { value = stringutil . trimtoempty ( value ) ; if ( value . length ( ) >= length ) { return value ; } return value + stringutil . repeat ( str_ , length - value . length ( ) ) ; }	Adds spaces to the right of the input value until the string has reached the given length.
public static string leftpad ( string value , int length ) { value = stringutil . trimtoempty ( value ) ; if ( value . length ( ) >= length ) { return value ; } return stringutil . repeat ( str_ , length - value . length ( ) ) + value ; }	Adds spaces to the left of the input value until the string has reached the given length.
public static string randomidentifer ( int len ) { final string ab = str_ ; stringbuilder sb = new stringbuilder ( len ) ; for ( int i = num_ ; i < len ; i ++ ) sb . append ( ab . charat ( rnd . nextint ( ab . length ( ) ) ) ) ; return sb . tostring ( ) ; }	Produce a random identifer of the given length, consisting only of uppercase letters.
public static string stripsqlcommentsandwhitespacesfromtheend ( string sqlstring ) { if ( isempty ( sqlstring ) ) { return sqlstring ; } stringbuilder str = new stringbuilder ( sqlstring ) ; boolean strmodified = bool_ ; while ( strmodified ) { strmodified = bool_ ;	Strips the comments and whitespaces from the end of given sql string.
public static string concatconsistentcase ( string basestring , string addition ) { boolean haslowercase = haslowercase ( basestring ) ; boolean hasuppercase = hasuppercase ( basestring ) ; if ( ( haslowercase && hasuppercase ) || ( ! haslowercase && ! hasuppercase ) ) {	Concatenates the addition string to the baseString string, adjusting the case of "addition" to match the base string.If the string is all caps, append addition in all caps.
protected string [ ] getdatabasecatalognames ( database database ) throws sqlexception , databaseexception { list < string > returnlist = new arraylist < > ( ) ; resultset catalogs = null ; try { if ( ( ( abstractjdbcdatabase ) database ) . jdbccallscatalogsschemas ( ) ) { catalogs = ( ( jdbcconnection ) database . getconnection ( ) ) . getmetadata ( ) . getschemas ( ) ; } else { catalogs = ( ( jdbcconnection ) database . getconnection ( ) ) . getmetadata ( ) . getcatalogs ( ) ; } while ( catalogs . next ( ) ) { if ( ( ( abstractjdbcdatabase ) database ) . jdbccallscatalogsschemas ( ) ) { returnlist . add ( catalogs . getstring ( str_ ) ) ; } else { returnlist . add ( catalogs . getstring ( str_ ) ) ; } } } finally { if ( catalogs != null ) { try { catalogs . close ( ) ; } catch ( sqlexception ignore ) { } } } return returnlist . toarray ( new string [ returnlist . size ( ) ] ) ; }	Fetches an array of Strings with the catalog names in the database.
public stringclauses append ( string key , string clause ) { validate . notnull ( stringutil . trimtonull ( key ) , str_ ) ; key = stringutil . trimtoempty ( key ) . tolowercase ( ) ; clause = stringutil . trimtoempty ( clause ) ; if ( clauses . containskey ( key ) ) { throw new illegalargumentexception ( str_ + key + str_ ) ; } clauses . put ( key , clause . trim ( ) ) ; return this ; }	Adds a new clause at the end of the list with the given key.
public stringclauses append ( string key , stringclauses subclauses ) { validate . notnull ( stringutil . trimtonull ( key ) , str_ ) ; key = stringutil . trimtoempty ( key ) . tolowercase ( ) ; if ( clauses . containskey ( key ) ) { throw new illegalargumentexception ( str_ + key + str_ ) ; } clauses . put ( key , subclauses ) ; return this ; }	Adds a new sub-clause at the end of the list with the given key.
public stringclauses prepend ( string key , string clause ) { return prependimpl ( key , stringutil . trimtoempty ( clause ) ) ; }	Adds a clause with the given key to the beginning of the list.
public stringclauses insertbefore ( string existingkey , string newkey , string newvalue ) throws illegalargumentexception { return insertbeforeimpl ( existingkey , newkey , newvalue ) ; }	Inserts a new clause before the given key.
public stringclauses insertafter ( string existingkey , string newkey , string newvalue ) { return insertafterimpl ( existingkey , newkey , newvalue ) ; }	Inserts a new clause after the given key.
public string get ( string exitingkey ) { exitingkey = stringutil . trimtoempty ( exitingkey ) . tolowercase ( ) ; object clauses = getimpl ( exitingkey ) ; if ( clauses == null ) { return null ; } return clauses . tostring ( ) ; }	Retrieves the given key.
public stringclauses getsubclause ( string exitingkey ) { exitingkey = stringutil . trimtoempty ( exitingkey ) . tolowercase ( ) ; object clauses = getimpl ( exitingkey ) ; if ( clauses == null ) { return null ; } if ( clauses instanceof string ) { return new stringclauses ( ) . append ( ( string ) clauses ) ; } return ( stringclauses ) clauses ; }	Retrieves the given key.
public void print ( printstream out , changelogserializer changelogserializer ) throws parserconfigurationexception , ioexception , databaseexception { list < changeset > changesets = generatechangesets ( ) ; changelogserializer . write ( changesets , out ) ; out . flush ( ) ; }	Prints changeLog that would bring the target database to be the same asthe reference database.
public list < database > getimplementeddatabases ( ) { list < database > returnlist = new arraylist < > ( ) ; for ( sortedset < database > set : implementeddatabases . values ( ) ) { returnlist . add ( set . iterator ( ) . next ( ) ) ; } return returnlist ; }	Returns instances of all implemented database types.
public list < database > getinternaldatabases ( ) { list < database > returnlist = new arraylist < > ( ) ; for ( sortedset < database > set : internaldatabases . values ( ) ) { returnlist . add ( set . iterator ( ) . next ( ) ) ; } return returnlist ; }	Returns instances of all "internal" database types.
public boolean validate ( database database ) { int maxparameters = this . getmaxparameters ( database ) ; int minparameters = this . getminparameters ( database ) ; if ( parameters . size ( ) > maxparameters ) { throw new unexpectedliquibaseexception ( str_ + getclass ( ) + str_ + maxparameters + str_ ) ; } if ( parameters . size ( ) < minparameters ) { throw new unexpectedliquibaseexception ( str_ + getclass ( ) + str_ + minparameters + str_ ) ; } return bool_ ; }	Validates the correct state of this data type against a given database.
public databasedatatype todatabasedatatype ( database database ) { if ( database instanceof mssqldatabase ) { string name = database . escapedatatypename ( getname ( ) ) ; int datatypemaxparameters = database . getdatatypemaxparameters ( getname ( ) ) ; object [ ] parameters = getparameters ( ) ; if ( datatypemaxparameters < parameters . length ) { parameters = arrays . copyofrange ( parameters , num_ , datatypemaxparameters ) ; } return new databasedatatype ( name , parameters ) ; } databasedatatype type = new databasedatatype ( name . touppercase ( locale . us ) , getparameters ( ) ) ; type . addadditionalinformation ( additionalinformation ) ; return type ; }	Transforms this data type into the native data type of the target DBMS.
public string objecttosql ( object value , database database ) { if ( ( value == null ) || str_ . equals ( value . tostring ( ) . tolowercase ( locale . us ) ) ) { return null ; } else if ( value instanceof databasefunction ) { return functiontosql ( ( databasefunction ) value , database ) ; } else if ( value instanceof number ) { return numbertosql ( ( number ) value , database ) ; } return othertosql ( value , database ) ; }	Returns the value object in a format to include in SQL.
protected boolean iscurrentdatetimefunction ( string string , database database ) { return string . tolowercase ( locale . us ) . startswith ( str_ ) || string . tolowercase ( locale . us ) . startswith ( databasefunction . current_date_time_place_holder ) || database . getcurrentdatetimefunction ( ) . tolowercase ( locale . us ) . equals ( string . tolowercase ( locale . us ) ) ; }	Determines if the given function name refers to the function that returns the currenttime and date for a specific DBMS.
public boolean supportsbooleandatatype ( ) { if ( getconnection ( ) == null ) return bool_ ;	boolean data type column are allowed for versions >= 11.1.1.1.
private string getconcatsql ( list < string > values ) { if ( values . size ( ) == num_ ) { return values . get ( num_ ) ; } else { return start_concat + values . get ( num_ ) + sep_concat + getconcatsql ( values . sublist ( num_ , values . size ( ) ) ) + end_concat ; } }	Recursive way of building CONCAT instruction.
public boolean generatestatementsvolatile ( sqlstatement statement , database database ) { for ( sqlgenerator generator : getgenerators ( statement , database ) ) { if ( generator . generatestatementsisvolatile ( database ) ) { return bool_ ; } } return bool_ ; }	Return true if the SqlStatement class queries the database in any way to determine Statements to execute.If the statement queries the database, it cannot be used in updateSql type operations.
private static void addartifact ( set < uri > urls , artifact artifact , log log , boolean verbose ) throws malformedurlexception { file f = artifact . getfile ( ) ; if ( f == null ) { log . warn ( str_ + artifact . getgroupid ( ) + str_ + artifact . getartifactid ( ) + str_ ) ; } else { addfile ( urls , f , log , verbose ) ; }	Adds the artifact file into the set of URLs so it can be used in a URLClassLoader.
public static field getdeclaredfield ( class clazz , string fieldname ) throws nosuchfieldexception { field f = getfield ( clazz , fieldname ) ; if ( f == null ) {	Recursively searches for the field specified by the fieldName in the class and allthe super classes until it either finds it, or runs out of parents.
protected list < string > getalternatepaths ( string path ) { list < string > alternatepaths = new arraylist < > ( ) ; if ( path . startswith ( str_ ) ) {	Return alternate options for the given path that the user maybe meant.
public boolean matches ( contexts runtimecontexts ) { if ( ( runtimecontexts == null ) || runtimecontexts . isempty ( ) ) { return bool_ ; } if ( this . contexts . isempty ( ) ) { return bool_ ; } for ( string expression : this . contexts ) { if ( matches ( expression , runtimecontexts ) ) { return bool_ ; } } return bool_ ; }	Returns true if the passed runtime contexts match this context expression.
private resourceaccessor createresourceaccessor ( classloader classloader ) { list < resourceaccessor > resourceaccessors = new arraylist < resourceaccessor > ( ) ; resourceaccessors . add ( new filesystemresourceaccessor ( paths . get ( str_ ) . toabsolutepath ( ) . getroot ( ) . tofile ( ) ) ) ; resourceaccessors . add ( new classloaderresourceaccessor ( classloader ) ) ; string changelogdirectory = getchangelogdirectory ( ) ; if ( changelogdirectory != null ) { changelogdirectory = changelogdirectory . trim ( ) . replace ( str_ , str_ ) ;	Creates a suitable ResourceAccessor for use in an Ant task..
protected void closedatabase ( database database ) { try { if ( database != null ) { database . close ( ) ; } } catch ( databaseexception e ) { log ( str_ , e , project . msg_warn ) ; } }	Convenience method to safely close the database connection.
private int appendnextcharacterandadvanceloop ( string line , stringbuilder sb , int i ) { sb . append ( line . charat ( i + num_ ) ) ; i ++ ; return i ; }	Appends the next character in the line to the stringbuffer.
private boolean isnextcharacterescapedquote ( string nextline , boolean inquotes , int i ) { return inquotes	Checks to see if the character after the index is a quotation character.precondition: the current character is a quote or an escape.
protected boolean isnextcharacterescapable ( string nextline , boolean inquotes , int i ) { return inquotes	Checks to see if the character after the current index in a String is an escapable character.Meaning the next character is either a quotation character or the escape char and you are insidequotes.precondition: the current character is an escape.
public list < parsednode > getchildren ( string namespace , string nodename ) { list < parsednode > returnlist = new arraylist < > ( ) ; for ( parsednode node : children ) { if ( nodematches ( node , namespace , nodename ) ) { returnlist . add ( node ) ; } } return collections . unmodifiablelist ( returnlist ) ; }	Returns all child nodes with the given namespace and name.If none match, an empty list is returned.Returned list is unmodifiableList.
public < t > t getvalue ( class < t > type ) throws parsednodeexception { return convertobject ( value , type ) ; }	Return the value associated with this node converted to the given type.
public parsednode getchild ( string namespace , string name ) throws parsednodeexception { parsednode returnnode = null ; for ( parsednode node : children ) { if ( nodematches ( node , namespace , name ) ) { if ( returnnode != null ) { throw new parsednodeexception ( str_ + namespace + str_ + name ) ; } returnnode = node ; } } return returnnode ; }	Returns the ParsedNode defined by the given namespace and name.
public < t > t getchildvalue ( string namespace , string nodename , class < t > type ) throws parsednodeexception { object rawvalue = getchildvalue ( namespace , nodename ) ; if ( rawvalue == null ) { return null ; } return convertobject ( rawvalue , type ) ; }	Returns the value of the given node, converted to the passed type.
public object getchildvalue ( string namespace , string nodename ) throws parsednodeexception { parsednode child = getchild ( namespace , nodename ) ; if ( child == null ) { return null ; } return child . getvalue ( ) ; }	Returns the value of the given node with no conversion attempted.
@ override public void close ( ) throws ioexception { for ( inputstream stream : this ) { try { stream . close ( ) ; } catch ( ioexception e ) { scope . getcurrentscope ( ) . getlog ( getclass ( ) ) . severe ( str_ , e ) ; } } }	Close the streams in this collection.
public boolean isautoincrement ( ) { return str_ . equals ( type . tolowercase ( locale . us ) ) || str_ . equals ( type . tolowercase ( locale . us ) ) || str_ . equals ( type . tolowercase ( locale . us ) ) ; }	Mainly for postgres, check if the column is a serial data type.
protected boolean iscompressedfile ( path path ) { return path != null && ( path . tostring ( ) . startswith ( str_ ) || path . tostring ( ) . tolowercase ( ) . endswith ( str_ ) || path . tostring ( ) . tolowercase ( ) . endswith ( str_ ) ) ; }	Returns true if the given path is a compressed file.
public column getcolumn ( string columnname ) { for ( column column : getcolumns ( ) ) { if ( column . getname ( ) . equalsignorecase ( columnname ) ) { return column ; } } return null ; }	Returns the column object for the given columnName.
public < t extends singletonobject > t getsingleton ( class < t > type ) { if ( getparent ( ) != null ) { return getparent ( ) . getsingleton ( type ) ; } string key = type . getname ( ) ; t singleton = get ( key , type ) ; if ( singleton == null ) { try { try { constructor < t > constructor = type . getdeclaredconstructor ( scope . class ) ; constructor . setaccessible ( bool_ ) ; singleton = constructor . newinstance ( this ) ; } catch ( nosuchmethodexception e ) {	Looks up the singleton object of the given type.
@ override public void tag ( final string tagstring ) throws databaseexception { database database = getdatabase ( ) ; executor executor = executorservice . getinstance ( ) . getexecutor ( database ) ; int totalrows = executorservice . getinstance ( ) . getexecutor ( database ) . queryforint ( new selectfromdatabasechangelogstatement ( new columnconfig ( ) . setname ( str_ , bool_ ) ) ) ; if ( totalrows == num_ ) { changeset emptychangeset = new changeset ( string . valueof ( new date ( ) . gettime ( ) ) , str_ , bool_ , bool_ , str_ , null , null , getdatabase ( ) . getobjectquotingstrategy ( ) , null ) ; this . setexectype ( emptychangeset , changeset . exectype . executed ) ; } executor . execute ( new tagdatabasestatement ( tagstring ) ) ; getdatabase ( ) . commit ( ) ; if ( this . ranchangesetlist != null ) { ranchangesetlist . get ( ranchangesetlist . size ( ) - num_ ) . settag ( tagstring ) ; } }	Tags the database changelog with the given string.
public precondition create ( string tagname ) { class < ? > aclass = preconditions . get ( tagname ) ; if ( aclass == null ) { return null ; } try { return ( precondition ) aclass . getconstructor ( ) . newinstance ( ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Create a new Precondition subclass based on the given tag name.
public static boolean isnowortodayformat ( string value ) { boolean ret = bool_ ; if ( value != null ) { string lowervalue = value . tolowercase ( ) ; if ( lowervalue . length ( ) >= now_length && lowervalue . startswith ( now ) ) { ret = bool_ ; } else if ( lowervalue . length ( ) >= today_length && lowervalue . startswith ( today ) ) { ret = bool_ ; } } return ret ; }	Checks if date starts with "NOW" or "TODAY".
public object getvalue ( string key , databasechangelog changelog ) { changelogparameter parameter = findparameter ( key , changelog ) ; return ( parameter != null ) ? parameter . getvalue ( ) : null ; }	Return the value of a parameter.
private void setvalidateoptionifavailable ( database database , uniqueconstraint uniqueconstraint , map < string , ? > columnsmetadata ) { if ( ! ( database instanceof oracledatabase ) ) { return ; } final object constraintvalidate = columnsmetadata . get ( str_ ) ; final string validate = str_ ; if ( constraintvalidate != null && ! constraintvalidate . tostring ( ) . trim ( ) . isempty ( ) ) { uniqueconstraint . setshouldvalidate ( validate . equals ( cleannamefromdatabase ( constraintvalidate . tostring ( ) . trim ( ) , database ) ) ) ; } }	Method to map 'validate' option for UC. This thing works only for ORACLE.
private string getuniqueconstraintssqlinformix ( informixdatabase database , schema schema , string name ) { stringbuffer sqlbuf = new stringbuffer ( ) ; sqlbuf . append ( str_ ) ;	Gets an SQL query that returns the constraint names and columns for all UNIQUE constraints.
public map < string , changeparametermetadata > getsetparameters ( change change ) { map < string , changeparametermetadata > returnmap = new hashmap < > ( ) ; for ( map . entry < string , changeparametermetadata > entry : getparameters ( ) . entryset ( ) ) { if ( entry . getvalue ( ) . getcurrentvalue ( change ) != null ) { returnmap . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } return collections . unmodifiablemap ( returnmap ) ; }	Return the parameters of the given change that are set to a non-null value.
public map < string , changeparametermetadata > getrequiredparameters ( database database ) { map < string , changeparametermetadata > returnmap = new hashmap < > ( ) ; for ( changeparametermetadata metadata : parameters . values ( ) ) { if ( metadata . isrequiredfor ( database ) ) { returnmap . put ( metadata . getparametername ( ) , metadata ) ; } } return returnmap ; }	Returns the required parameters for this change for the given database.
private string converttostring ( object newvalue , database database ) { string sqlstring ; if ( newvalue == null || newvalue . tostring ( ) . equals ( str_ ) || newvalue . tostring ( ) . equalsignorecase ( str_ ) ) { sqlstring = str_ ; } else if ( newvalue instanceof string && ! lookslikefunctioncall ( ( ( string ) newvalue ) , database ) ) { sqlstring = str_ + database . escapestringfordatabase ( newvalue . tostring ( ) ) + str_ ; } else if ( newvalue instanceof date ) { sqlstring = database . getdateliteral ( ( ( date ) newvalue ) ) ; } else if ( newvalue instanceof boolean ) { if ( ( ( boolean ) newvalue ) ) { sqlstring = datatypefactory . getinstance ( ) . gettruebooleanvalue ( database ) ; } else { sqlstring = datatypefactory . getinstance ( ) . getfalsebooleanvalue ( database ) ; } } else { sqlstring = newvalue . tostring ( ) ; } return sqlstring ; }	Copied and modified from liquibase.sqlgenerator.core.InsertOrUpdateGeneratorMySQL.
@ override public set < string > getserializablefields ( ) { return scope . getcurrentscope ( ) . getsingleton ( changefactory . class ) . getchangemetadata ( this ) . getparameters ( ) . keyset ( ) ; }	Returns the fields on this change that are serializable.
private static string dogetfullpath ( string filename , boolean includeseparator ) { if ( filename == null ) { return null ; } int prefix = getprefixlength ( filename ) ; if ( prefix < num_ ) { return null ; } if ( prefix >= filename . length ( ) ) { if ( includeseparator ) { return getprefix ( filename ) ;	Does the work of getting the path.
protected void createindexlookup ( string [ ] values ) { if ( indexlookup . isempty ( ) ) { for ( int i = num_ ; i < values . length ; i ++ ) { indexlookup . put ( values [ i ] , i ) ; } } }	Creates an index map of column names to column position.
@ override public integer getcolumnindex ( string name ) { if ( null == header ) { throw new illegalstateexception ( str_ ) ; } createindexlookup ( header ) ; return indexlookup . get ( name ) ; }	Gets the column index that corresponds to a specific colum name.If the CSV file doesn't have a header row, this method will always returnnull.
@ override public propertydescriptor finddescriptor ( int col ) throws introspectionexception { string columnname = getcolumnname ( col ) ; return ( stringutil . trimtonull ( columnname ) != null ) ? finddescriptor ( columnname ) : null ; }	Gets the property descriptor for a given column position.
@ override public beanfield findfield ( int col ) { string columnname = getcolumnname ( col ) ; return ( stringutil . trimtonull ( columnname ) != null ) ? findfield ( columnname ) : null ; }	Gets the field for a given column position.
public string getcolumnname ( int col ) { return ( ( null != header ) && ( col < header . length ) ) ? header [ col ] : null ; }	Get the column name for a given column position.
protected propertydescriptor finddescriptor ( string name ) throws introspectionexception { if ( null == descriptormap ) { descriptormap = loaddescriptormap ( ) ;	Find the property descriptor for a given column.
protected beanfield findfield ( string name ) { if ( null == fieldmap ) { fieldmap = loadfieldmap ( ) ;	Find the field for a given column.
protected boolean matches ( string name , propertydescriptor desc ) { return desc . getname ( ) . equals ( name . trim ( ) ) ; }	Determines if the name of a property descriptor matches the column name.Currently only used by unit tests.
protected map < string , propertydescriptor > loaddescriptormap ( ) throws introspectionexception { map < string , propertydescriptor > map = new hashmap < > ( ) ; propertydescriptor [ ] descriptors ; descriptors = loaddescriptors ( gettype ( ) ) ; for ( propertydescriptor descriptor : descriptors ) { map . put ( descriptor . getname ( ) . touppercase ( ) . trim ( ) , descriptor ) ; } return map ; }	builds a map of property descriptors for the Bean.
@ override public string getcolumnname ( int col ) { return ( col < columnmapping . length ) ? columnmapping [ col ] : null ; }	gets a column name.
public void setcolumnmapping ( string ... columnmapping ) { this . columnmapping = ( columnmapping != null ) ? columnmapping . clone ( ) : new string [ ] { } ; resetindexmap ( ) ; createindexlookup ( this . columnmapping ) ; }	Setter for the ColumnMappings.
protected int getsize ( ) { if ( getparameters ( ) . length == num_ ) { return - num_ ; } if ( getparameters ( ) [ num_ ] instanceof string ) { return integer . parseint ( ( string ) getparameters ( ) [ num_ ] ) ; } if ( getparameters ( ) [ num_ ] instanceof number ) { return ( ( number ) getparameters ( ) [ num_ ] ) . intvalue ( ) ; } return - num_ ; }	Return the size of this data type definition. If unknown or unspecified, return -1.
public static boolean supportsdefaultvaluecomputed ( string columntype , string defaultvalue ) { hashset < string > possiblecomputedvalues = supported_default_value_computed_map . get ( columntype ) ; return ( possiblecomputedvalues != null ) && possiblecomputedvalues . contains ( defaultvalue . tolowercase ( ) ) ; }	Checks to see if the string is an acceptable computed value for HSQL"datetime" columns are the only columns for which HSQL supports computer values.
public list < changesetstatus > getchangesetstorun ( ) { arraylist < changesetstatus > returnlist = new arraylist < > ( ) ; for ( changesetstatus status : changesetstatuses . values ( ) ) { if ( status . getwillrun ( ) ) { returnlist . add ( status ) ; } } return returnlist ; }	Return the change sets that will execute.
@ override public string escapeobjectname ( string objectname , class < ? extends databaseobject > objecttype ) { if ( ( quotingstrategy == objectquotingstrategy . legacy ) && hasmixedcase ( objectname ) ) { return str_ + objectname + str_ ; } else if ( objecttype != null && liquibasecolumn . class . isassignablefrom ( objecttype ) ) { return ( objectname != null && ! objectname . isempty ( ) ) ? objectname . trim ( ) : objectname ; } return super . escapeobjectname ( objectname , objecttype ) ; }	This has special case logic to handle NOT quoting column names if they areof type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCKtables.
public columnconfig setvaluenumeric ( string valuenumeric ) { if ( ( valuenumeric == null ) || str_ . equalsignorecase ( valuenumeric ) ) { this . valuenumeric = null ; } else { string saved = valuenumeric ; if ( valuenumeric . startswith ( str_ ) ) { valuenumeric = valuenumeric . replacefirst ( str_ , str_ ) ; valuenumeric = valuenumeric . replacefirst ( str_ , str_ ) ; } try { this . valuenumeric = valuenumeric . of ( locale . us , valuenumeric ) ; } catch ( parseexception e ) { this . valuecomputed = new databasefunction ( saved ) ; } } return this ; }	Set the number this column should be set to.
public columnconfig setvalueboolean ( string valueboolean ) { valueboolean = stringutil . trimtonull ( valueboolean ) ; if ( ( valueboolean == null ) || str_ . equalsignorecase ( valueboolean ) ) { this . valueboolean = null ; } else { if ( str_ . equalsignorecase ( valueboolean ) || str_ . equals ( valueboolean ) ) { this . valueboolean = bool_ ; } else if ( str_ . equalsignorecase ( valueboolean ) || str_ . equals ( valueboolean ) ) { this . valueboolean = bool_ ; } else { this . valuecomputed = new databasefunction ( valueboolean ) ; } } return this ; }	Set the valueBoolean based on a given string.If the passed value cannot be parsed as a date, it is assumed to be a function that returns a boolean.If the string "null" or an empty string is passed, it will set a null value.If "1" is passed, defaultValueBoolean is set to true.
public columnconfig setdefaultvalueboolean ( string defaultvalueboolean ) { defaultvalueboolean = stringutil . trimtonull ( defaultvalueboolean ) ; if ( ( defaultvalueboolean == null ) || str_ . equalsignorecase ( defaultvalueboolean ) ) { this . defaultvalueboolean = null ; } else { if ( str_ . equalsignorecase ( defaultvalueboolean ) || str_ . equals ( defaultvalueboolean ) ) { this . defaultvalueboolean = bool_ ; } else if ( str_ . equalsignorecase ( defaultvalueboolean ) || str_ . equals ( defaultvalueboolean ) ) { this . defaultvalueboolean = bool_ ; } else { this . defaultvaluecomputed = new databasefunction ( defaultvalueboolean ) ; } } return this ; }	Set the defaultValueBoolean based on a given string.If the passed value cannot be parsed as a date, it is assumed to be a function that returns a boolean.If the string "null" or an empty string is passed, it will set a null value.If "1" is passed, defaultValueBoolean is set to true.
public void unregister ( string name ) { for ( change change : new arraylist < > ( findallinstances ( ) ) ) { if ( getchangemetadata ( change ) . getname ( ) . equals ( name ) ) { this . removeinstance ( change ) ; } } }	Unregister all instances of a given Change name.
public sortedset < string > getdefinedchanges ( ) { sortedset < string > names = new treeset < > ( ) ; for ( change change : findallinstances ( ) ) { names . add ( getchangemetadata ( change ) . getname ( ) ) ; } return collections . unmodifiablesortedset ( names ) ; }	Returns all defined changes in the registry.
public change create ( string name ) { change plugin = getplugin ( name ) ; if ( plugin == null ) { return null ; } try { return plugin . getclass ( ) . getconstructor ( ) . newinstance ( ) ; } catch ( exception e ) { throw new unexpectedliquibaseexception ( e ) ; } }	Create a new Change implementation for the given change name.
@ override public boolean promptfornonlocaldatabase ( database database ) throws databaseexception { return joptionpane . showconfirmdialog ( null , str_ + streamutil . getlineseparator ( ) + str_ + database . getconnection ( ) . geturl ( ) + streamutil . getlineseparator ( ) + str_ + database . getconnection ( ) . getconnectionusername ( ) + streamutil . getlineseparator ( ) + streamutil . getlineseparator ( ) + str_ , str_ , joptionpane . yes_no_option , joptionpane . warning_message ) == joptionpane . no_option ; }	Displays swing-based dialog about running against a non-localhost database.Returns true if the user selected that they are OK with that.
protected string getconnectionschemaname ( ) { if ( connection == null ) { return null ; } if ( connection instanceof offlineconnection ) { return ( ( offlineconnection ) connection ) . getschema ( ) ; } try { sqlstatement currentschemastatement = getconnectionschemanamecallstatement ( ) ; return executorservice . getinstance ( ) . getexecutor ( this ) . queryforobject ( currentschemastatement , string . class ) ; } catch ( exception e ) { scope . getcurrentscope ( ) . getlog ( getclass ( ) ) . info ( logtype . log , str_ , e ) ; } return null ; }	Overwrite this method to get the default schema name for the connection.If you only need to change the statement that obtains the current schema then override.
@ override public boolean issafetorunupdate ( ) throws databaseexception { databaseconnection connection = getconnection ( ) ; if ( connection == null ) { return bool_ ; } string url = connection . geturl ( ) ; if ( url == null ) { return bool_ ; } return ( url . contains ( str_ ) ) || ( url . contains ( str_ ) ) ; }	Default implementation, just look for "local" IPs.
protected list < sqlvisitor > filterrollbackvisitors ( final list < sqlvisitor > visitors ) { final list < sqlvisitor > rollbackvisitors = new arraylist < > ( ) ; if ( visitors != null ) { for ( sqlvisitor visitor : visitors ) { if ( visitor . isapplytorollback ( ) ) { rollbackvisitors . add ( visitor ) ; } } } return rollbackvisitors ; }	Takes a list of SqlVisitors and returns a new list with only the SqlVisitors set to apply to rollbacks.
@ override public int getmaxfractionaldigitsfortimestamp ( ) { if ( getconnection ( ) == null ) {	Most relational databases support 9 fractional digits, and subclasses must overwrite this method if theysupport less than that.
protected string checkstring ( string text ) throws unexpectedliquibaseexception { if ( null == text || text . isempty ( ) ) { return text ; } final int len = text . length ( ) ; char current ; int codepoint ; for ( int i = num_ ; i < len ; i ++ ) { current = text . charat ( i ) ; if ( character . ishighsurrogate ( current ) && i + num_ < len && character . islowsurrogate ( text . charat ( i + num_ ) ) ) { codepoint = text . codepointat ( i ++ ) ; } else { codepoint = current ; } if ( ( codepoint == str_ ) || ( codepoint == str_ ) || ( codepoint == str_ ) || ( codepoint == num_ ) || ( codepoint == num_ ) || ( ( codepoint >= num_ ) && ( codepoint <= num_ ) ) || ( ( codepoint >= num_ ) && ( codepoint <= num_ ) ) || ( ( codepoint >= num_ ) && ( codepoint <= num_ ) ) || ( ( codepoint >= num_ ) && ( codepoint <= num_ ) ) ) {	Catch any characters that will cause problems when parsing the XML down the road.
public element createnode ( string nodenamespace , string nodename , string nodecontent ) { element element = currentchangelogfiledom . createelementns ( nodenamespace , nodename ) ; element . settextcontent ( nodecontent ) ; return element ; }	create a XML node with nodeName and simple text content.
public static void notnull ( object object , string failmessage ) throws unexpectedliquibaseexception { if ( object == null ) { fail ( failmessage ) ; } }	Throws exception if passed object is null.
boolean issybaseproductname ( string dbproductname ) { return product_name . equals ( dbproductname ) || str_ . equals ( dbproductname ) || str_ . equals ( dbproductname ) || str_ . equals ( dbproductname ) ; }	package private to facilitate testing.
public sqlvisitor create ( string tagname ) { class < ? > aclass = tagtoclassmap . get ( tagname ) ; if ( aclass == null ) { return null ; } try { return ( sqlvisitor ) aclass . getconstructor ( ) . newinstance ( ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Create a new Change subclass based on the given tag name.
public static string getlocalhostaddress ( ) throws unknownhostexception , socketexception { try { return getlocalhost ( ) . gethostaddress ( ) ; } catch ( exception e ) { scope . getcurrentscope ( ) . getlog ( netutil . class ) . fine ( logtype . log , str_ , e ) ; return str_ ; } }	Returns Local Host IP Address.
public static string getlocalhostname ( ) throws unknownhostexception , socketexception { try { return getlocalhost ( ) . gethostname ( ) ; } catch ( exception e ) { scope . getcurrentscope ( ) . getlog ( netutil . class ) . fine ( logtype . log , str_ , e ) ; return str_ ; } }	Returns Local Host Name.
public static void surroundwithschemasets ( list < sql > sql , string schemaname , database database ) { if ( ( stringutil . trimtonull ( schemaname ) != null ) && ! liquibaseconfiguration . getinstance ( ) . getproperty ( changelogparsercofiguration . class , changelogparsercofiguration . use_procedure_schema ) . getvalue ( boolean . class ) ) { string defaultschema = database . getdefaultschemaname ( ) ; if ( database instanceof oracledatabase ) { sql . add ( num_ , new unparsedsql ( str_ + database . escapeobjectname ( schemaname , schema . class ) ) ) ; sql . add ( new unparsedsql ( str_ + database . escapeobjectname ( defaultschema , schema . class ) ) ) ; } else if ( database instanceof abstractdb2database ) { sql . add ( num_ , new unparsedsql ( str_ + schemaname ) ) ; sql . add ( new unparsedsql ( str_ + defaultschema ) ) ; } } }	Convenience method for when the schemaName is set but we don't want to parse the body.
private static char [ ] encodehex ( byte [ ] data ) { int l = data . length ; char [ ] out = new char [ l << num_ ] ;	Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.The returned array will be double the length of the passed array, as it takes two characters to represent anygiven byte.
protected string [ ] getdatabaseschemanames ( database database ) throws sqlexception , databaseexception { list < string > returnlist = new arraylist < > ( ) ; resultset schemas = null ; try { schemas = ( ( jdbcconnection ) database . getconnection ( ) ) . getmetadata ( ) . getschemas ( ) ; while ( schemas . next ( ) ) { returnlist . add ( jdbcutils . getvalueforcolumn ( schemas , str_ , database ) ) ; } } finally { if ( schemas != null ) { schemas . close ( ) ; } } return returnlist . toarray ( new string [ returnlist . size ( ) ] ) ; }	Fetches an array of Strings with the schema names in the database.
public string [ ] readnext ( ) throws ioexception { string [ ] result = null ; do { string nextline = getnextline ( ) ; if ( ! hasnext ) { return validateresult ( result ) ; } string [ ] r = parser . parselinemulti ( nextline ) ; if ( r . length > num_ ) { if ( result == null ) { result = r ; } else { result = combineresultsfrommultiplereads ( result , r ) ; } } } while ( parser . ispending ( ) ) ; return validateresult ( result ) ; }	Reads the next line from the buffer and converts to a string array.
protected string getnextline ( ) throws ioexception { if ( isclosed ( ) ) { hasnext = bool_ ; return null ; } if ( ! this . linesskiped ) { for ( int i = num_ ; i < skiplines ; i ++ ) { linereader . readline ( ) ; linesread ++ ; } this . linesskiped = bool_ ; } string nextline = linereader . readline ( ) ; if ( nextline == null ) { hasnext = bool_ ; } else { linesread ++ ; } return hasnext ? nextline : null ; }	Reads the next line from the file.
private boolean isclosed ( ) { if ( ! verifyreader ) { return bool_ ; } try { br . mark ( read_ahead_limit ) ; int nextbyte = br . read ( ) ; br . reset ( ) ;	Checks to see if the file is closed.
public synchronized void startpolling ( polledconfigurationsource source , abstractpollingscheduler scheduler ) { this . scheduler = scheduler ; this . source = source ; init ( source , scheduler ) ; scheduler . startpolling ( source , this ) ; }	Start polling the configuration source with the specified scheduler.
public void start ( ) throws exception {	Adds a listener to the pathChildrenCache, initializes the cache, then starts the cache-management background thread.
public static void setappconffolder ( file appconffolderfromconfig , string baseconfigfilename ) { webapplicationproperties . appconffolder = appconffolderfromconfig ; webapplicationproperties . baseconfigfilename = baseconfigfilename ; }	The folder where the application's properties files are located.
public dynamicintproperty getintproperty ( string propname , int defaultvalue , final runnable propertychangecallback ) { checkandwarn ( propname ) ; dynamicintproperty property = new dynamicintproperty ( propname , defaultvalue ) ; addcallback ( propertychangecallback , property ) ; return property ; }	Create a new property whose value is an integer and subject to change on-the-fly.
public dynamiclongproperty getlongproperty ( string propname , long defaultvalue , final runnable propertychangecallback ) { checkandwarn ( propname ) ; dynamiclongproperty property = new dynamiclongproperty ( propname , defaultvalue ) ; addcallback ( propertychangecallback , property ) ; return property ; }	Create a new property whose value is a long and subject to change on-the-fly.
public dynamicbooleanproperty getbooleanproperty ( string propname , boolean defaultvalue , final runnable propertychangecallback ) { checkandwarn ( propname ) ; dynamicbooleanproperty property = new dynamicbooleanproperty ( propname , defaultvalue ) ; addcallback ( propertychangecallback , property ) ; return property ; }	Create a new property whose value is a boolean and subject to change on-the-fly.
public dynamicfloatproperty getfloatproperty ( string propname , float defaultvalue , final runnable propertychangecallback ) { checkandwarn ( propname ) ; dynamicfloatproperty property = new dynamicfloatproperty ( propname , defaultvalue ) ; addcallback ( propertychangecallback , property ) ; return property ; }	Create a new property whose value is a float and subject to change on-the-fly.
public dynamicdoubleproperty getdoubleproperty ( string propname , double defaultvalue , final runnable propertychangecallback ) { checkandwarn ( propname ) ; dynamicdoubleproperty property = new dynamicdoubleproperty ( propname , defaultvalue ) ; addcallback ( propertychangecallback , property ) ; return property ; }	Create a new property whose value is a double and subject to change on-the-fly.
@ override protected map < string , propertywithdeploymentcontext > loadpropertiesfromtable ( string table ) { map < string , propertywithdeploymentcontext > propertymap = new hashmap < string , propertywithdeploymentcontext > ( ) ; map < string , attributevalue > lastkeysevaluated = null ; do { scanrequest scanrequest = new scanrequest ( ) . withtablename ( table ) . withexclusivestartkey ( lastkeysevaluated ) ; scanresult result = dbscanwiththroughputbackoff ( scanrequest ) ; for ( map < string , attributevalue > item : result . getitems ( ) ) { string keyval = item . get ( keyattributename . get ( ) ) . gets ( ) ;	Scan the table in dynamo and create a map with the results.
public static dynamicproperty getinstance ( string propname ) {	Gets the DynamicProperty for a given property name.This may be a previously constructed object,or an object constructed on-demand to satisfy the request.
private static boolean updateallproperties ( ) { boolean changed = bool_ ; for ( dynamicproperty prop : all_props . values ( ) ) { if ( prop . updatevalue ( ) ) { prop . notifycallbacks ( ) ; changed = bool_ ; } } return changed ; }	return true iff _some_ value actually changed.
@ override public void addcallback ( runnable callback ) { if ( callback != null ) { prop . addcallback ( callback ) ; callbacks . add ( callback ) ; } }	Add the callback to be triggered when the value of the property is changed.
@ override public void removeallcallbacks ( ) { final set < runnable > callbackstoremove = new hashset < runnable > ( callbacks ) ; for ( runnable callback : callbackstoremove ) { prop . removecallback ( callback ) ; } callbacks . removeall ( callbackstoremove ) ; }	Remove all callbacks registered through this instance of property.
public static httpverburiregexpropertyvalue getverburiregex ( string propvalue ) { httpverburiregexpropertyvalue returnvalue = null ; if ( propvalue != null ) { propvalue = propvalue . trim ( ) ; int methodseparatorindex = propvalue . indexof ( method_separator ) ; string uriregex = propvalue ;	Expects property value to be of the form &lt;uriRegex&gt; OR &lt;HTTPVerb name&gt;&lt;space&gt;&lt;uriRegex&gt;.
public static properties loadpropertiesfrominputstream ( inputstream fin ) throws ioexception { properties props = new properties ( ) ; inputstreamreader reader = new inputstreamreader ( fin , str_ ) ; try { props . load ( reader ) ; return props ; } finally { if ( reader != null ) { reader . close ( ) ; } if ( fin != null ) { fin . close ( ) ; } } }	Load properties from InputStream with utf-8 encoding, and it will take care of closing the input stream.
@ override public void addproperty ( string name , object value ) { if ( containskey ( name ) ) {	Need to override this method for PDCLOUD-1809.
void addorchangeproperty ( final string name , final object newvalue , final configuration config ) {	Add or update the property in the underlying config depending on if it exists.
void deleteproperty ( final string key , final configuration config ) { if ( config . containskey ( key ) ) { logger . debug ( str_ + key + str_ ) ; config . clearproperty ( key ) ; } }	Delete a property in the underlying config.
@ override public void clear ( ) { fireevent ( event_clear , null , null , bool_ ) ; map . clear ( ) ; fireevent ( event_clear , null , null , bool_ ) ; }	Clear the map and fire corresonding events.
public properties getproperties ( ) { properties p = new properties ( ) ; for ( iterator i = getkeys ( ) ; i . hasnext ( ) ; ) { string name = ( string ) i . next ( ) ; string value = getstring ( name ) ; p . put ( name , value ) ; } return p ; }	Utility method to get a Properties object from this Configuration.
protected synchronized void initialload ( final polledconfigurationsource source , final configuration config ) { pollresult result = null ; try { result = source . poll ( bool_ , null ) ; checkpoint = result . getcheckpoint ( ) ; fireevent ( eventtype . poll_success , result , null ) ; } catch ( throwable e ) { throw new runtimeexception ( str_ + source , e ) ; } try { populateproperties ( result , config ) ; } catch ( throwable e ) { throw new runtimeexception ( str_ , e ) ; } }	Do an initial poll from the source and apply the result to the configuration.
public void addconfigurationatindex ( abstractconfiguration config , string name , int index ) throws indexoutofboundsexception { if ( ! configlist . contains ( config ) ) { checkindex ( index ) ; configlist . add ( index , config ) ; if ( name != null ) { namedconfigurations . put ( name , config ) ; } config . addconfigurationlistener ( eventpropagater ) ; fireevent ( event_configuration_source_changed , null , null , bool_ ) ; } else { logger . warn ( config + str_ ) ; } }	Add a configuration with a name at a particular index.
public boolean removeconfiguration ( configuration config ) {	Remove a configuration. The container configuration cannot be removed.
public configuration removeconfiguration ( string name ) { configuration conf = getconfiguration ( name ) ; if ( conf != null && ! conf . equals ( containerconfiguration ) ) { configlist . remove ( conf ) ; namedconfigurations . remove ( name ) ; } else if ( conf != null && conf . equals ( containerconfiguration ) ) { throw new illegalargumentexception ( str_ ) ; } return conf ; }	Removes the configuration with the specified name.
public iterator < string > getkeys ( ) throws concurrentmodificationexception { set < string > keys = new linkedhashset < string > ( ) ; for ( iterator < string > it = overrideproperties . getkeys ( ) ; it . hasnext ( ) ; ) { keys . add ( it . next ( ) ) ; } for ( configuration config : configlist ) { for ( iterator < string > it = config . getkeys ( ) ; it . hasnext ( ) ; ) { try { keys . add ( it . next ( ) ) ; } catch ( concurrentmodificationexception e ) { logger . error ( str_ + config + str_ + getnameforconfiguration ( config ) ) ; throw e ; } } } return keys . iterator ( ) ; }	Get all the keys contained by sub configurations.
@ override public iterator < string > getkeys ( string prefix ) { set < string > keys = new linkedhashset < string > ( ) ; for ( iterator < string > it = overrideproperties . getkeys ( prefix ) ; it . hasnext ( ) ; ) { keys . add ( it . next ( ) ) ; } for ( configuration config : configlist ) { for ( iterator < string > it = config . getkeys ( prefix ) ; it . hasnext ( ) ; ) { keys . add ( it . next ( ) ) ; } } return keys . iterator ( ) ; }	Get the list of the keys contained in the sub configurations that match thespecified prefix.
@ override public boolean containskey ( string key ) { if ( overrideproperties . containskey ( key ) ) { return bool_ ; } for ( configuration config : configlist ) { if ( config . containskey ( key ) ) { return bool_ ; } } return bool_ ; }	Check if the any of the sub configurations contains the specified key.
@ override public list getlist ( string key , list defaultvalue ) { list < object > list = new arraylist < object > ( ) ;	Get a List of objects associated with the given configuration key.If the key doesn't map to an existing object, the default valueis returned.
@ override public string [ ] getstringarray ( string key ) { list < object > list = getlist ( key ) ;	Get an array of strings associated with the given configuration key.If the key doesn't map to an existing object an empty array is returned.
public static void loadcascadedpropertiesfromresources ( string configname ) throws ioexception { properties props = loadcascadedproperties ( configname ) ; if ( instance instanceof aggregatedconfiguration ) { concurrentmapconfiguration config = new concurrentmapconfiguration ( ) ; config . loadproperties ( props ) ; ( ( aggregatedconfiguration ) instance ) . addconfiguration ( config , configname ) ; } else { configurationutils . loadproperties ( props , instance ) ; } }	Load resource configName.properties first.
public static void loadpropertiesfromconfiguration ( abstractconfiguration config ) { if ( instance == null ) { instance = getconfiginstance ( ) ; } if ( instance instanceof aggregatedconfiguration ) { ( ( aggregatedconfiguration ) instance ) . addconfiguration ( config ) ; } else { properties props = configurationutils . getproperties ( config ) ; configurationutils . loadproperties ( props , instance ) ; } }	Load properties from the specified configuration into system wide configuration.
public static void loadproperties ( properties properties ) { if ( instance == null ) { instance = getconfiginstance ( ) ; } configurationutils . loadproperties ( properties , instance ) ; }	Load the specified properties into system wide configuration.
@ override public pollresult poll ( boolean initial , object checkpoint ) throws ioexception { if ( configurls == null || configurls . length == num_ ) { return pollresult . createfull ( null ) ; } map < string , object > map = new hashmap < string , object > ( ) ; for ( url url : configurls ) { inputstream fin = url . openstream ( ) ; properties props = configurationutils . loadpropertiesfrominputstream ( fin ) ; for ( entry < object , object > entry : props . entryset ( ) ) { map . put ( ( string ) entry . getkey ( ) , entry . getvalue ( ) ) ; } } return pollresult . createfull ( map ) ; }	Retrieve the content of the property files.
public double getangle ( location location ) {	The angle relative to the direction EAST.
@ override public v computeifabsent ( k key , function < ? super k , ? extends v > mappingfunction ) {	An overridden implementation that heavily favors read access over write access speed.This is thread-safe.{.
public static void main ( string [ ] args ) { cloudbalancinggenerator generator = new cloudbalancinggenerator ( ) ; generator . writecloudbalance ( num_ , num_ ) ; generator . writecloudbalance ( num_ , num_ ) ; generator . writecloudbalance ( num_ , num_ ) ;	in gigabyte per hour.
public static string getgetterpropertyname ( member member ) { if ( member instanceof field ) { return member . getname ( ) ; } else if ( member instanceof method ) { string methodname = member . getname ( ) ; for ( string prefix : property_accessor_prefixes ) { if ( methodname . startswith ( prefix ) ) { return decapitalizepropertyname ( methodname . substring ( prefix . length ( ) ) ) ; } } } return null ; }	Returns the JavaBeans property name of the given member.
public static boolean isgettermethod ( method method ) { if ( method . getparametertypes ( ) . length != num_ ) { return bool_ ; } string methodname = method . getname ( ) ; if ( methodname . startswith ( property_accessor_prefix_get ) && method . getreturntype ( ) != void . class ) { return bool_ ; } else if ( methodname . startswith ( property_accessor_prefix_is ) && method . getreturntype ( ) == boolean . class ) { return bool_ ; } return bool_ ; }	Checks whether the given method is a valid getter method according to the JavaBeans standard.
public void addhardconstraintmatch ( rulecontext kcontext , bigdecimal hardweight ) { hardscore = hardscore . add ( hardweight ) ; registerconstraintmatch ( kcontext , ( ) -> hardscore = hardscore . subtract ( hardweight ) , ( ) -> hardmediumsoftbigdecimalscore . of ( hardweight , bigdecimal . zero , bigdecimal . zero ) ) ; }	Add a hard constraint of specified weighting.This is typically used in Drools scoring to add a hard constraint match (negative value to indicate an infeasiblesolution).
public void addmediumconstraintmatch ( rulecontext kcontext , bigdecimal mediumweight ) { mediumscore = mediumscore . add ( mediumweight ) ; registerconstraintmatch ( kcontext , ( ) -> mediumscore = mediumscore . subtract ( mediumweight ) , ( ) -> hardmediumsoftbigdecimalscore . of ( bigdecimal . zero , mediumweight , bigdecimal . zero ) ) ; }	Add a medium level constraint of specified weighting.This is typically used in Drools scoring to add a medium priority constraint match.
public void addsoftconstraintmatch ( rulecontext kcontext , bigdecimal softweight ) { softscore = softscore . add ( softweight ) ; registerconstraintmatch ( kcontext , ( ) -> softscore = softscore . subtract ( softweight ) , ( ) -> hardmediumsoftbigdecimalscore . of ( bigdecimal . zero , bigdecimal . zero , softweight ) ) ; }	Add a soft constraint match of specified weighting.This is typically used in Drools scoring to add a low priority constraint match.
public static string cleanpath ( final url url ) { string path = url . getpath ( ) ; try { path = urldecoder . decode ( path , str_ ) ; } catch ( unsupportedencodingexception e ) { } if ( path . startswith ( str_ ) ) { path = path . substring ( str_ . length ( ) ) ; } if ( path . startswith ( str_ ) ) { path = path . substring ( str_ . length ( ) ) ; } if ( path . endswith ( str_ ) ) { path = path . substring ( num_ , path . lastindexof ( str_ ) ) + str_ ; } return path ; }	Cleans the URL.
public void checkifproblemfactsexist ( ) { if ( problemfactcollectionmemberaccessormap . isempty ( ) && problemfactmemberaccessormap . isempty ( ) ) { throw new illegalstateexception ( str_ + solutionclass + str_ + problemfactcollectionproperty . class . getsimplename ( ) + str_ + problemfactproperty . class . getsimplename ( ) + str_ + str_ ) ; } }	Only called if Drools score calculation is used.
public long getproblemscale ( solution_ solution ) { long problemscale = num_ ; for ( iterator < object > it = extractallentitiesiterator ( solution ) ; it . hasnext ( ) ; ) { object entity = it . next ( ) ; entitydescriptor < solution_ > entitydescriptor = findentitydescriptororfail ( entity . getclass ( ) ) ; problemscale += entitydescriptor . getproblemscale ( solution , entity ) ; } return problemscale ; }	Calculates an indication on how big this problem instance is.This is intentionally very loosely defined for now.
static string generatetaskname ( final request < ? > request ) { return request . getbaseuritemplate ( ) + str_ + operationnamegenerator . generate ( request . getmethod ( ) , request . getmethodname ( ) ) ; }	Generates a task name for the request.
private boolean hasrequestcontexttimeout ( requestcontext requestcontext ) { object requesttimeout = requestcontext . getlocalattr ( r2constants . request_timeout ) ; return ( requesttimeout instanceof number ) && ( ( ( number ) requesttimeout ) . intvalue ( ) > num_ ) ; }	Check whether per-request timeout is specified in the given request context.
private boolean needapplytasktimeout ( requestcontext requestcontext , configvalue < long > timeout ) {	check whether we need to apply timeout to a rest.li request task.
private < t > task < response < t > > createtaskwithtimeout ( final string name , final request < t > request , final requestcontext requestcontext , requestconfig config ) { configvalue < long > timeout = config . gettimeoutms ( ) ; task < response < t > > requesttask ; if ( requestgroup . isbatchable ( request , config ) ) { requesttask = createbatchabletask ( name , request , requestcontext , config ) ; } else { requesttask = task . async ( name , ( ) -> sendrequest ( request , requestcontext ) ) ; } if ( ! needapplytasktimeout ( requestcontext , timeout ) ) { return requesttask ; } else { return withtimeout ( requesttask , timeout ) ; } }	Apply timeout to a ParSeq rest.li request task through parseq timer task.
public task < httpresponse > build ( final string hash , final inputstream body ) throws ioexception { if ( hash == null ) {	Return task that has general HTTP status and body information based on the build task's result.
private task < exec . result > getbuildtask ( final string hash , final inputstream body ) { task < exec . result > existing = _inflightbuildtasks . get ( hash ) ; if ( existing != null ) { log . info ( str_ + hash ) ; return existing . shareable ( ) ; } else { task < exec . result > newbuildtask = createnewbuildtask ( hash , body ) ; existing = _inflightbuildtasks . putifabsent ( hash , newbuildtask ) ; if ( existing != null ) { log . info ( str_ + hash ) ; return existing . shareable ( ) ; } else { return newbuildtask ; } } }	Returns task that builds graph using graphviz.
private task < exec . result > createnewbuildtask ( final string hash , final inputstream body ) { log . info ( str_ + hash ) ; final task < void > createdotfile = task . action ( str_ , ( ) -> files . copy ( body , pathtocachefile ( hash , str_ ) , standardcopyoption . replace_existing ) ) ;	Returns new task that builds graph using graphviz.
private string writegenericfailureinfo ( final exec . result result ) throws ioexception { stringbuilder sb = new stringbuilder ( ) ; sb . append ( str_ ) . append ( result . getstatus ( ) ) . append ( str_ ) . append ( str_ ) ; files . lines ( result . getstdout ( ) ) . foreach ( sb :: append ) ; sb . append ( str_ ) ; files . lines ( result . getstderr ( ) ) . foreach ( sb :: append ) ; return sb . tostring ( ) ; }	Writes error info to a String.
public static trace single ( shallowtrace shallowtrace ) { return single ( shallowtrace , tracebuilder . unknown_plan_class , tracebuilder . unknown_plan_id ) ; }	Need to fix in the next major version release.
public task < t > batchable ( final string desc , final k key ) { task < t > batchabletask = task . async ( desc , ctx -> { final batchpromise < t > result = new batchpromise < > ( ) ; final long planid = ctx . getplanid ( ) ; final groupbatchbuilder builder = _batches . computeifabsent ( planid , k -> new groupbatchbuilder ( ) ) ; final g group = classify ( key ) ; batch < k , t > fullbatch = builder . add ( group , key , ctx . getshallowtracebuilder ( ) , result ) ; if ( fullbatch != null ) { try { ctx . run ( taskforbatch ( group , fullbatch , bool_ ) ) ; } catch ( throwable t ) {	This method returns Task that returns value for a single key allowing this strategy to batch operations.
public string getbatchname ( g group , batch < k , t > batch ) { return str_ + batch . keysize ( ) + str_ + batch . batchsize ( ) + str_ ; }	Overriding this method allows providing custom name for a batch.
public synchronized < t > t harvest ( function < histogram , t > consumer ) { initializerecorder ( ) ; _recycle = _recorder . getintervalhistogram ( _recycle ) ; return consumer . apply ( _recycle ) ; }	Allows consuming histogram and returning a result.Histogram passed to the consumer includes stable, consistent viewof all values accumulated since last harvest.This method is thread safe.
private static parseqrestliclientconfig createdefaultconfig ( ) { parseqrestliclientconfigbuilder builder = new parseqrestliclientconfigbuilder ( ) ; builder . addtimeoutms ( str_ , default_timeout ) ; builder . addbatchingenabled ( str_ , default_batching_enabled ) ; builder . addmaxbatchsize ( str_ , default_max_batch_size ) ; return builder . build ( ) ; }	Default configuration map must specify default values for all properties.
private < r > consumer3 < fusiontracecontext , promise < s > , settable < t > > compose ( final consumer3 < fusiontracecontext , promise < s > , settable < r > > predecessor , final consumer3 < fusiontracecontext , promise < r > , settable < t > > propagator ) { return ( tracecontext , src , dst ) -> { tracecontext . createsurrogate ( ) ; predecessor . accept ( tracecontext , src , new settable < r > ( ) { @ override public void done ( r value ) throws promiseresolvedexception { try { geteffectiveshallowtracebuilder ( tracecontext ) . setstartnanos ( system . nanotime ( ) ) ; propagator . accept ( tracecontext , promises . value ( value ) , dst ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } } @ override public void fail ( throwable error ) throws promiseresolvedexception { try { geteffectiveshallowtracebuilder ( tracecontext ) . setstartnanos ( system . nanotime ( ) ) ; propagator . accept ( tracecontext , promises . error ( error ) , dst ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } } } ) ; } ; }	Composes transformation with the transformation of the predecessor.
public static < s , t > fusiontask < ? , t > create ( final string name , final task < s > task , final promisepropagator < s , t > propagator ) { return new fusiontask < s , t > ( name , task , propagator ) ; }	Create new FusionTask with an async predecessor.
public enginebuilder setengineproperty ( string key , object value ) { _properties . put ( key , value ) ; return this ; }	Sets an engine related property on the engine.That property can then be accessed by tasks via the Context.
@ suppresswarnings ( str_ ) public static < t > promise < t > value ( final t value ) { if ( value == null ) { if ( void == null ) { return new resolvedvalue < t > ( value ) ; } else { return ( promise < t > ) void ; } } return new resolvedvalue < t > ( value ) ; }	Creates a new promise that is already resolved with the given value.
public static < t > void propagateresult ( final promise < t > source , final settable < t > dest ) { source . addlistener ( new transformingpromiselistener < t , t > ( dest , promisetransformer . identity ( ) ) ) ; }	Copies the value or error from the source promise to the destinationpromise.
task < string > createresilientsummary ( int id ) { return fetchperson ( id ) . map ( this :: shortsummary ) . recover ( e -> str_ + id ) ; }	handles failures delivering degraded experience.
task < string > createresponsivesummary ( int id ) { return fetchperson ( id ) . withtimeout ( num_ , timeunit . milliseconds ) . map ( this :: shortsummary ) . recover ( e -> str_ + id ) ; }	handles failures delivering degraded experience in timely fashion.
task < list < string > > createconnectionssummaries ( int id ) { return fetchperson ( id ) . flatmap ( str_ , person -> createconnectionssummaries ( person . getconnections ( ) ) ) ; }	create list of summaries, one per each connection.
public static string findnodewithnextlowestsn ( list < string > children , string node ) { list < string > sortedchildren = children . stream ( ) . sorted ( ( string o1 , string o2 ) -> long . compare ( getsequencenumber ( o1 ) , getsequencenumber ( o2 ) ) ) . collect ( collectors . tolist ( ) ) ; int index = sortedchildren . indexof ( node ) ; if ( index > num_ ) { return sortedchildren . get ( index - num_ ) ; } else if ( index == num_ ) { return node ; } else { return null ; } }	Finds node with next lowest sequence number than the given node withinthe given list of nodes.
private void appendtaskstacktrace ( final throwable error ) { stacktraceelement [ ] taskstacktrace = _taskstacktraceholder != null ? _taskstacktraceholder . getstacktrace ( ) : null ;	Concatenate stack traces if kept the original stack trace from the task creation.
private void monitor ( ) { _lastmonitoringstep = _clock . nanotime ( ) ; _nextallowedlogging = _lastmonitoringstep ; while ( ! _stopped ) { try { _clock . sleepnano ( _checkintervalnano ) ; } catch ( interruptedexception e ) { break ; } monitorstep ( ) ; } }	Main loop of monitoring thread.
private void checkforstall ( long currenttime ) { long delta = currenttime - _lastmonitoringstep ; if ( delta < _shortestobserveddelta ) { _shortestobserveddelta = delta ; } long stall = math . max ( num_ , delta - _shortestobserveddelta ) ; if ( stall > _minstallnano ) { _stalls . put ( _lastmonitoringstep , stall ) ; if ( _stalls . size ( ) > _stallshistorysize ) { _stalls . pollfirstentry ( ) ; } } }	Check how much we missed scheduled wake up and if it is larger than _minStallNanothen consider it a stall and remember it.
public static < u > task < u > withretrypolicy ( string name , retrypolicy policy , function1 < integer , task < u > > taskfunction ) { retriabletask < u > retriabletask = new retriabletask < > ( name , policy , taskfunction ) ; task < u > retrytaskwrapper = task . async ( name + str_ , retriabletask :: run ) ; retrytaskwrapper . getshallowtracebuilder ( ) . settasktype ( tasktype . with_retry . getname ( ) ) ; return retrytaskwrapper ; }	A helper for creating task wrapper with associated retry policy.
private task < t > wrap ( int attempt ) { task < t > retrytask = task . async ( _policy . getname ( ) + str_ + attempt , context -> { final settablepromise < t > result = promises . settable ( ) ; task < t > task = _taskfunction . apply ( attempt ) ; final task < t > recovery = task . async ( _name + str_ , recoverycontext -> { final settablepromise < t > recoveryresult = promises . settable ( ) ; if ( task . isfailed ( ) ) {	Create a wrapped task with associated recovery task that will retry if necessary.
private void retry ( int attempt , throwable error , errorclassification errorclassification , context recoverycontext , settablepromise < t > recoveryresult ) { long backofftime = _policy . getbackoffpolicy ( ) . nextbackoff ( attempt , error ) ; if ( errorclassification == errorclassification . unrecoverable ) {	Invoke event monitors and schedule a retry if policy allows.
private promise < ? extends t > run ( context context ) { _startedat = system . currenttimemillis ( ) ; task < t > task = wrap ( num_ ) ; context . run ( task ) ; return task ; }	Starts a retriable task.
private static exception failcoercion ( final object object , final class < ? > targettype ) { return new exception ( str_ + targettype . getsimplename ( ) + str_ + object . getclass ( ) . getname ( ) + str_ + object . tostring ( ) ) ; }	Generates a consistent exception that can be used if coercion fails.
@ deprecated public parseqrestliclientbuilder setrestclient ( restclient client ) { argumentutil . requirenotnull ( client , str_ ) ; _client = client ; return this ; }	Sets the underlying Rest.li client implementation.
private task < string > acquire ( long deadline ) { final string uuid = uuid . randomuuid ( ) . tostring ( ) ; return safecreatelocknode ( uuid , deadline , bool_ ) . onfailure ( e -> _zkclient . deletenodehasuuid ( _lockpath , uuid ) ) . flatmap ( locknode -> tryacquire ( locknode , deadline ) . withtimeout ( deadline - system . currenttimemillis ( ) , timeunit . milliseconds ) . onfailure ( e -> _zkclient . deletenode ( locknode ) ) ) ; }	Try to acquire the lock within the given deadline.
private task < void > release ( ) { return planlocal . get ( getplanlocalkey ( ) , lockinternal . class ) . flatmap ( lockinternal -> {	Try to release the lock.
private boolean tryacquirepermit ( string planclass ) { return _concurrentplans . tryacquire ( ) && ( _planbasedratelimiter == null || _planbasedratelimiter . tryacquire ( planclass ) ) ; }	rate limiter and then from plan class level rate limit if specified.
public static synchronized asynchttpclient getningclient ( ) { if ( _client . get ( ) == null ) { initialize ( new asynchttpclientconfig . builder ( ) . build ( ) ) ; } return _client . get ( ) ; }	Returns raw http client.
@ suppresswarnings ( str_ ) public static synchronized void initialize ( asynchttpclientconfig cfg ) { if ( ! _client . compareandset ( null , new asynchttpclient ( cfg ) ) ) { throw new runtimeexception ( str_ ) ; } }	Initializes HttpClient with custom configuration.
public string consumetoany ( final char ... chars ) { bufferup ( ) ; final int start = bufpos ; final int remaining = buflength ; final char [ ] val = charbuf ; outer : while ( bufpos < remaining ) { for ( char c : chars ) { if ( val [ bufpos ] == c ) break outer ; } bufpos ++ ; } return bufpos > start ? cachestring ( charbuf , stringcache , start , bufpos - start ) : str_ ; }	Read characters until the first of any delimiters is found.
public static void nonullelements ( object [ ] objects , string msg ) { for ( object obj : objects ) if ( obj == null ) throw new illegalargumentexception ( msg ) ; }	Validates that the array contains no null elements.
public static void notempty ( string string , string msg ) { if ( string == null || string . length ( ) == num_ ) throw new illegalargumentexception ( msg ) ; }	Validates that the string is not empty.
static matrix parsetransform ( string s ) {	delims are whitespace or ,'s.
public dbcursor getfilelist ( final dbobject query , final dbobject sort ) { return filescollection . find ( query ) . sort ( sort ) ; }	Gets a sorted, filtered list of files stored in this gridfs.
public list < gridfsdbfile > find ( final string filename , final dbobject sort ) { return find ( new basicdbobject ( str_ , filename ) , sort ) ; }	Finds a list of files matching the given filename.
public list < gridfsdbfile > find ( final dbobject query , final dbobject sort ) { list < gridfsdbfile > files = new arraylist < gridfsdbfile > ( ) ; dbcursor cursor = filescollection . find ( query ) ; if ( sort != null ) { cursor . sort ( sort ) ; } try { while ( cursor . hasnext ( ) ) { files . add ( injectgridfsinstance ( cursor . next ( ) ) ) ; } } finally { cursor . close ( ) ; } return collections . unmodifiablelist ( files ) ; }	Finds a list of files matching the given query.
public void remove ( final objectid id ) { if ( id == null ) { throw new illegalargumentexception ( str_ ) ; } filescollection . remove ( new basicdbobject ( str_ , id ) ) ; chunkscollection . remove ( new basicdbobject ( str_ , id ) ) ; }	Removes the file matching the given id.
public void remove ( final dbobject query ) { if ( query == null ) { throw new illegalargumentexception ( str_ ) ; } for ( final gridfsdbfile f : find ( query ) ) { f . remove ( ) ; } }	Removes all files matching the given query.
@ override public object put ( final string key , final object v ) { return put ( _getint ( key ) , v ) ; }	Puts a value at an index.
public object get ( final string key ) { int i = _getint ( key ) ; if ( i < num_ ) { return null ; } if ( i >= size ( ) ) { return null ; } return get ( i ) ; }	Gets a value at an index.
public static < t > builder < t > builder ( final class < t > type ) { return new builder < t > ( notnull ( str_ , type ) ) ; }	Creates a new builder for ClassTypeData.
public long getmaxtime ( final timeunit timeunit ) { notnull ( str_ , timeunit ) ; return timeunit . convert ( maxtimems , timeunit . milliseconds ) ; }	Gets the maximum execution time on the server for this operation.
public < t > mongocompressor withproperty ( final string key , final t value ) { return new mongocompressor ( this , key , value ) ; }	Creates a new compressor from this compressor with the given property added to it.
@ suppresswarnings ( str_ ) @ nullable public string getname ( ) { list < serverdescription > any = getclusterdescription ( ) . getanyprimaryorsecondary ( ) ; return any . isempty ( ) ? null : any . get ( num_ ) . getsetname ( ) ; }	Get the name of the replica set.
@ suppresswarnings ( str_ ) @ nullable public serveraddress getmaster ( ) { list < serverdescription > primaries = getclusterdescription ( ) . getprimaries ( ) ; return primaries . isempty ( ) ? null : primaries . get ( num_ ) . getaddress ( ) ; }	Gets the ServerAddress of the master server in this replica set.
public boolean ismaster ( final serveraddress serveraddress ) { serveraddress masterserveraddress = getmaster ( ) ; return masterserveraddress != null && masterserveraddress . equals ( serveraddress ) ; }	Checks to see if a given server is the primary server in this replica set.
@ suppresswarnings ( str_ ) public int getmaxbsonobjectsize ( ) { list < serverdescription > primaries = getclusterdescription ( ) . getprimaries ( ) ; return primaries . isempty ( ) ? serverdescription . getdefaultmaxdocumentsize ( ) : primaries . get ( num_ ) . getmaxdocumentsize ( ) ; }	Gets the maximum size for a BSON object supported by the current master server.
public querybuilder put ( final string key ) { _currentkey = key ; if ( _query . get ( key ) == null ) { _query . put ( _currentkey , new nullobject ( ) ) ; } return this ; }	Adds a new key to the query if not present yet.
private void applymajoritywriteconcerntotransactionoptions ( ) { if ( transactionoptions != null ) { writeconcern writeconcern = transactionoptions . getwriteconcern ( ) ; if ( writeconcern != null ) { transactionoptions = transactionoptions . merge ( transactionoptions . builder ( ) . writeconcern ( writeconcern . withw ( str_ ) ) . build ( ) , transactionoptions ) ; } else { transactionoptions = transactionoptions . merge ( transactionoptions . builder ( ) . writeconcern ( writeconcern . majority ) . build ( ) , transactionoptions ) ; } } else { transactionoptions = transactionoptions . builder ( ) . writeconcern ( writeconcern . majority ) . build ( ) ; } }	Apply majority write concern if the commit is to be retried.
public boolean ok ( ) { object okvalue = get ( str_ ) ; if ( okvalue instanceof boolean ) { return ( boolean ) okvalue ; } else if ( okvalue instanceof number ) { return ( ( number ) okvalue ) . intvalue ( ) == num_ ; } else { return bool_ ; } }	Gets the "ok" field, which is whether this command executed correctly or not.
@ nullable public string geterrormessage ( ) { object foo = get ( str_ ) ; if ( foo == null ) { return null ; } return foo . tostring ( ) ; }	Gets the error message associated with a failed command.
public propertymodelbuilder < t > readannotations ( final list < annotation > annotations ) { this . readannotations = unmodifiablelist ( notnull ( str_ , annotations ) ) ; return this ; }	Sets the read annotations, to be applied when serializing to BSON.
public static list < string > getindexnames ( final list < indexmodel > indexes , final codecregistry codecregistry ) { list < string > indexnames = new arraylist < string > ( indexes . size ( ) ) ; for ( indexmodel index : indexes ) { string name = index . getoptions ( ) . getname ( ) ; if ( name != null ) { indexnames . add ( name ) ; } else { indexnames . add ( indexhelper . generateindexname ( index . getkeys ( ) . tobsondocument ( bsondocument . class , codecregistry ) ) ) ; } } return indexnames ; }	Get a list of index names for the given list of index models.
public static string generateindexname ( final bsondocument index ) { stringbuilder indexname = new stringbuilder ( ) ; for ( final string keynames : index . keyset ( ) ) { if ( indexname . length ( ) != num_ ) { indexname . append ( str_ ) ; } indexname . append ( keynames ) . append ( str_ ) ; bsonvalue ascordescvalue = index . get ( keynames ) ; if ( ascordescvalue instanceof bsonnumber ) { indexname . append ( ( ( bsonnumber ) ascordescvalue ) . intvalue ( ) ) ; } else if ( ascordescvalue instanceof bsonstring ) { indexname . append ( ( ( bsonstring ) ascordescvalue ) . getvalue ( ) . replace ( str_ , str_ ) ) ; } } return indexname . tostring ( ) ; }	Convenience method to generate an index name from the set of fields it is over.
@ deprecated public void validate ( ) { if ( fs == null ) { throw new mongoexception ( str_ ) ; } if ( md5 == null ) { throw new mongoexception ( str_ ) ; } dbobject cmd = new basicdbobject ( str_ , id ) ; cmd . put ( str_ , fs . getbucketname ( ) ) ; dbobject res = fs . getdb ( ) . command ( cmd ) ; if ( res != null && res . containsfield ( str_ ) ) { string m = res . get ( str_ ) . tostring ( ) ; if ( m . equals ( md5 ) ) { return ; } throw new mongoexception ( str_ + md5 + str_ + m + str_ ) ; }	Verifies that the MD5 matches between the database and the local file.
public codec < ? > get ( final bsontype bsontype ) { codec < ? > codec = codecs [ bsontype . getvalue ( ) ] ; if ( codec == null ) { class < ? > clazz = bsontypeclassmap . get ( bsontype ) ; if ( clazz == null ) { throw new codecconfigurationexception ( format ( str_ , bsontype ) ) ; } else { throw new codecconfigurationexception ( format ( str_ , clazz ) ) ; } } return codec ; }	Gets the Codec mapped to the given bson type.
private int calculatebatchsize ( ) { integer batchsize = mongoiterable . getbatchsize ( ) ; if ( batchsize != null ) { return batchsize ; } long requested = getrequested ( ) ; if ( requested <= num_ ) { return num_ ; } else if ( requested < integer . max_value ) { return ( int ) requested ; } else { return integer . max_value ; } }	Returns the batchSize to be used with the cursor.
public static long parse ( final string string ) { if ( string . length ( ) == num_ ) { throw new numberformatexception ( str_ ) ; } int radix = num_ ; int maxsafepos = max_safe_digits [ radix ] - num_ ; long value = num_ ; for ( int pos = num_ ; pos < string . length ( ) ; pos ++ ) { int digit = character . digit ( string . charat ( pos ) , radix ) ; if ( digit == - num_ ) { throw new numberformatexception ( string ) ; } if ( pos > maxsafepos && overflowinparse ( value , digit , radix ) ) { throw new numberformatexception ( str_ + string ) ; } value = ( value * radix ) + digit ; } return value ; }	Equivalent to Long.parseUnsignedLong in Java 8.
public < t > t decodewithchildcontext ( final decoder < t > decoder , final bsonreader reader ) { return decoder . decode ( reader , default_context ) ; }	Creates a child context and then deserializes using the reader.
protected boolean checkstate ( final state [ ] validstates ) { for ( final state cur : validstates ) { if ( cur == getstate ( ) ) { return bool_ ; } } return bool_ ; }	Checks if this writer's current state is in the list of given states.
public void pipe ( final bsonreader reader , final list < bsonelement > extraelements ) { notnull ( str_ , reader ) ; notnull ( str_ , extraelements ) ; pipedocument ( reader , extraelements ) ; }	Reads a single document from the given BsonReader and writes it to this, appending the given extra elements to the document.
protected void pipeextraelements ( final list < bsonelement > extraelements ) { notnull ( str_ , extraelements ) ; for ( bsonelement cur : extraelements ) { writename ( cur . getname ( ) ) ; pipevalue ( cur . getvalue ( ) ) ; } }	Pipe a list of extra element to this writer.
public byte [ ] tobytearray ( ) { bytebuffer buffer = bytebuffer . allocate ( object_id_length ) ; puttobytebuffer ( buffer ) ; return buffer . array ( ) ;	Convert to a byte array.
public void puttobytebuffer ( final bytebuffer buffer ) { notnull ( str_ , buffer ) ; istrueargument ( str_ , buffer . remaining ( ) >= object_id_length ) ; buffer . put ( int3 ( timestamp ) ) ; buffer . put ( int2 ( timestamp ) ) ; buffer . put ( int1 ( timestamp ) ) ; buffer . put ( int0 ( timestamp ) ) ; buffer . put ( int2 ( randomvalue1 ) ) ; buffer . put ( int1 ( randomvalue1 ) ) ; buffer . put ( int0 ( randomvalue1 ) ) ; buffer . put ( short1 ( randomvalue2 ) ) ; buffer . put ( short0 ( randomvalue2 ) ) ; buffer . put ( int2 ( counter ) ) ; buffer . put ( int1 ( counter ) ) ; buffer . put ( int0 ( counter ) ) ; }	Convert to bytes and put those bytes to the provided ByteBuffer.Note that the numbers are stored in big-endian order.
public string tohexstring ( ) { char [ ] chars = new char [ object_id_length * num_ ] ; int i = num_ ; for ( byte b : tobytearray ( ) ) { chars [ i ++ ] = hex_chars [ b > > num_ & num_ ] ; chars [ i ++ ] = hex_chars [ b & num_ ] ; } return new string ( chars ) ; }	Converts this instance into a 24-byte hexadecimal string representation.
public string getshortdescription ( ) { return str_ + str_ + address + str_ + type + ( ! tagset . iterator ( ) . hasnext ( ) ? str_ : str_ + tagset ) + ( state == connected ? ( str_ + getroundtripformattedinmilliseconds ( ) + str_ ) : str_ ) + str_ + state + ( exception == null ? str_ : str_ + translateexceptiontostring ( ) ) + str_ ; }	Returns a short, pretty description for this ServerDescription.
@ suppresswarnings ( str_ ) public static basicdbobjectbuilder start ( final map documentasmap ) { basicdbobjectbuilder builder = new basicdbobjectbuilder ( ) ; iterator < map . entry > i = documentasmap . entryset ( ) . iterator ( ) ; while ( i . hasnext ( ) ) { map . entry entry = i . next ( ) ; builder . add ( entry . getkey ( ) . tostring ( ) , entry . getvalue ( ) ) ; } return builder ; }	Creates an object builder from an existing map of key value pairs.
public basicdbobjectbuilder push ( final string key ) { basicdbobject o = new basicdbobject ( ) ; _cur ( ) . put ( key , o ) ; _stack . addlast ( o ) ; return this ; }	Creates an new empty object and inserts it into the current object with the given key.
public void addresult ( final bulkwriteresult result , final indexmap indexmap ) { insertedcount += result . getinsertedcount ( ) ; matchedcount += result . getmatchedcount ( ) ; deletedcount += result . getdeletedcount ( ) ; modifiedcount += result . getmodifiedcount ( ) ; mergeupserts ( result . getupserts ( ) , indexmap ) ; }	Add a result.
public void adderrorresult ( final mongobulkwriteexception exception , final indexmap indexmap ) { addresult ( exception . getwriteresult ( ) , indexmap ) ; mergewriteerrors ( exception . getwriteerrors ( ) , indexmap ) ; mergewriteconcernerror ( exception . getwriteconcernerror ( ) ) ; }	Add an error result.
public void addwriteerrorresult ( final bulkwriteerror writeerror , final indexmap indexmap ) { notnull ( str_ , writeerror ) ; mergewriteerrors ( aslist ( writeerror ) , indexmap ) ; }	Add a write error result.
public void adderrorresult ( final list < bulkwriteerror > writeerrors , final writeconcernerror writeconcernerror , final indexmap indexmap ) { mergewriteerrors ( writeerrors , indexmap ) ; mergewriteconcernerror ( writeconcernerror ) ; }	Add a list of error results and a write concern error.
public mongobulkwriteexception geterror ( ) { return haserrors ( ) ? new mongobulkwriteexception ( createresult ( ) , new arraylist < bulkwriteerror > ( writeerrors ) , writeconcernerrors . isempty ( ) ? null : writeconcernerrors . get ( writeconcernerrors . size ( ) - num_ ) , serveraddress ) : null ; }	Gets the combined errors as an exception.
private node < e > nextnonmarker ( ) { node < e > f = getnext ( ) ; return ( f == null || ! f . ismarker ( ) ) ? f : f . getnext ( ) ; }	Returns next node, ignoring deletion marker.
node < e > successor ( ) { node < e > f = nextnonmarker ( ) ; for ( ; ; ) { if ( f == null ) return null ; if ( ! f . isdeleted ( ) ) { if ( f . getprev ( ) != this && ! isdeleted ( ) ) f . setprev ( this ) ;	Returns the next non-deleted node, swinging next pointeraround any encountered deleted nodes, and also patching upsuccessor's prev link to point back to this.
node < e > predecessor ( ) { node < e > n = this ; for ( ; ; ) { node < e > b = n . getprev ( ) ; if ( b == null ) return n . findpredecessorof ( this ) ; node < e > s = b . getnext ( ) ; if ( s == this ) return b ; if ( s == null || ! s . ismarker ( ) ) { node < e > p = b . findpredecessorof ( this ) ; if ( p != null ) return p ; } n = b ; } }	Returns the previous non-deleted node, patching up pointersas needed.
node < e > forward ( ) { node < e > f = successor ( ) ; return ( f == null || f . isspecial ( ) ) ? null : f ; }	Returns the next node containing a nondeleted user element.Use for forward list traversal.
node < e > back ( ) { node < e > f = predecessor ( ) ; return ( f == null || f . isspecial ( ) ) ? null : f ; }	Returns previous node containing a nondeleted user element, ifpossible.
node < e > append ( e element ) { for ( ; ; ) { node < e > f = getnext ( ) ; if ( f == null || f . ismarker ( ) ) return null ; node < e > x = new node < e > ( element , f , this ) ; if ( casnext ( f , x ) ) { f . setprev ( x ) ;	Tries to insert a node holding element as successor, failingif this node is deleted.
node < e > prepend ( e element ) { for ( ; ; ) { node < e > b = predecessor ( ) ; if ( b == null ) return null ; node < e > x = new node < e > ( element , this , b ) ; if ( b . casnext ( this , x ) ) { setprev ( x ) ;	Tries to insert a node holding element as predecessor, failingif no live predecessor can be found to link to.
boolean delete ( ) { node < e > b = getprev ( ) ; node < e > f = getnext ( ) ; if ( b != null && f != null && ! f . ismarker ( ) && casnext ( f , new node < e > ( f ) ) ) { if ( b . casnext ( this , f ) ) f . setprev ( b ) ; return bool_ ; } return bool_ ; }	Tries to mark this node as deleted, failing if alreadydeleted or if this node is header or trailer.
node < e > replace ( e newelement ) { for ( ; ; ) { node < e > b = getprev ( ) ; node < e > f = getnext ( ) ; if ( b == null || f == null || f . ismarker ( ) ) return null ; node < e > x = new node < e > ( newelement , f , b ) ; if ( casnext ( f , new node < e > ( x ) ) ) { b . successor ( ) ;	Tries to insert a node holding element to replace this node.failing if already deleted.
@ deprecated @ override public bsondocument execute ( final writebinding binding ) { return withconnection ( binding , new callablewithconnection < bsondocument > ( ) { @ override public bsondocument call ( final connection connection ) { if ( serverisatleastversionthreedottwo ( connection . getdescription ( ) ) ) { return executecommand ( binding , str_ , fsync_unlock_command , connection ) ; } else { return queryunlock ( connection ) ; } } } ) ; }	Unlocks the MongoDB server, allowing write operations to go through.
public final list < serverdescription > choose ( final clusterdescription clusterdescription ) { switch ( clusterdescription . gettype ( ) ) { case replica_set : return chooseforreplicaset ( clusterdescription ) ; case sharded : case standalone : return choosefornonreplicaset ( clusterdescription ) ; case unknown : return collections . emptylist ( ) ; default : throw new unsupportedoperationexception ( str_ + clusterdescription . gettype ( ) ) ; } }	Chooses the servers from the given cluster than match this read preference.
public static readpreference primarypreferred ( final long maxstaleness , final timeunit timeunit ) { return new primarypreferredreadpreference ( collections . < tagset > emptylist ( ) , maxstaleness , timeunit ) ; }	Gets a read preference that forces reads to the primary if available, otherwise to a secondary.
public static readpreference secondary ( final long maxstaleness , final timeunit timeunit ) { return new secondaryreadpreference ( collections . < tagset > emptylist ( ) , maxstaleness , timeunit ) ; }	Gets a read preference that forces reads to a secondary that is less stale than the given maximum.
public static readpreference nearest ( final long maxstaleness , final timeunit timeunit ) { return new nearestreadpreference ( collections . < tagset > emptylist ( ) , maxstaleness , timeunit ) ; }	Gets a read preference that forces reads to a primary or a secondary that is less stale than the given maximum.
public static readpreference valueof ( final string name ) { notnull ( str_ , name ) ; string nametocheck = name . tolowercase ( ) ; if ( nametocheck . equals ( primary . getname ( ) . tolowercase ( ) ) ) { return primary ; } if ( nametocheck . equals ( secondary . getname ( ) . tolowercase ( ) ) ) { return secondary ; } if ( nametocheck . equals ( secondary_preferred . getname ( ) . tolowercase ( ) ) ) { return secondary_preferred ; } if ( nametocheck . equals ( primary_preferred . getname ( ) . tolowercase ( ) ) ) { return primary_preferred ; } if ( nametocheck . equals ( nearest . getname ( ) . tolowercase ( ) ) ) { return nearest ; } throw new illegalargumentexception ( str_ + name ) ; }	Creates a read preference from the given read preference name.
public static taggablereadpreference valueof ( final string name , final list < tagset > tagsetlist ) { return valueof ( name , tagsetlist , null , milliseconds ) ; }	Creates a taggable read preference from the given read preference name and list of tag sets.
public static void readfully ( final inputstream inputstream , final byte [ ] buffer , final int offset , final int length ) throws ioexception { if ( buffer . length < length + offset ) { throw new illegalargumentexception ( str_ ) ; } int arrayoffset = offset ; int bytestoread = length ; while ( bytestoread > num_ ) { int bytesread = inputstream . read ( buffer , arrayoffset , bytestoread ) ; if ( bytesread < num_ ) { throw new eofexception ( ) ; } bytestoread -= bytesread ; arrayoffset += bytesread ; } }	Reads bytes from the input stream and puts them into the given byte buffer.
public static int readint ( final inputstream inputstream , final byte [ ] buffer ) throws ioexception { readfully ( inputstream , buffer , num_ ) ; return readint ( buffer ) ; }	Reads and returns a single integer value from the input stream.
public static int readint ( final byte [ ] buffer , final int offset ) { int x = num_ ; x |= ( num_ & buffer [ offset + num_ ] ) << num_ ; x |= ( num_ & buffer [ offset + num_ ] ) << num_ ; x |= ( num_ & buffer [ offset + num_ ] ) << num_ ; x |= ( num_ & buffer [ offset + num_ ] ) << num_ ; return x ; }	Reads and returns a single integer value from the buffer.
public static int readintbe ( final byte [ ] buffer , final int offset ) { int x = num_ ; x |= ( num_ & buffer [ offset + num_ ] ) << num_ ; x |= ( num_ & buffer [ offset + num_ ] ) << num_ ; x |= ( num_ & buffer [ offset + num_ ] ) << num_ ; x |= ( num_ & buffer [ offset + num_ ] ) << num_ ; return x ; }	Reads and returns a single big-endian integer value.
public static long readlong ( final inputstream inputstream , final byte [ ] buffer ) throws ioexception { readfully ( inputstream , buffer , num_ ) ; return readlong ( buffer ) ; }	Reads and returns a single long value from the input stream.
@ deprecated public list < mongocredential > getcredentiallist ( ) { return credential != null ? singletonlist ( credential ) : collections . < mongocredential > emptylist ( ) ; }	Gets the credentials in an immutable list.
private clusterableserver getrandomserver ( final list < serverdescription > serverdescriptions ) { while ( ! serverdescriptions . isempty ( ) ) { int serverpos = getrandom ( ) . nextint ( serverdescriptions . size ( ) ) ; clusterableserver server = getserver ( serverdescriptions . get ( serverpos ) . getaddress ( ) ) ; if ( server != null ) { return server ; } else { serverdescriptions . remove ( serverpos ) ; } } return null ; }	gets a random server that still exists in the cluster.
public static mongoclient create ( final connectionstring connectionstring , @ nullable final mongodriverinformation mongodriverinformation ) { return create ( mongoclientsettings . builder ( ) . applyconnectionstring ( connectionstring ) . build ( ) , mongodriverinformation , connectionstring . getstreamtype ( ) ) ; }	Create a new client with the given connection string.
public object copy ( ) {	Copies this instance into a new Object.
public static < s > classmodelbuilder < s > builder ( final class < s > type ) { return new classmodelbuilder < s > ( type ) ; }	Creates a new Class Model builder instance using reflection.
public dbcollection getcollection ( final string name ) { dbcollection collection = collectioncache . get ( name ) ; if ( collection != null ) { return collection ; } collection = new dbcollection ( name , this , executor ) ; if ( mongo . getmongoclientoptions ( ) . getdbdecoderfactory ( ) != defaultdbdecoder . factory ) { collection . setdbdecoderfactory ( mongo . getmongoclientoptions ( ) . getdbdecoderfactory ( ) ) ; } if ( mongo . getmongoclientoptions ( ) . getdbencoderfactory ( ) != defaultdbencoder . factory ) { collection . setdbencoderfactory ( mongo . getmongoclientoptions ( ) . getdbencoderfactory ( ) ) ; } dbcollection old = collectioncache . putifabsent ( name , collection ) ; return old != null ? old : collection ; }	Gets a collection with a given name.
public void dropdatabase ( ) { try { getexecutor ( ) . execute ( new dropdatabaseoperation ( getname ( ) , getwriteconcern ( ) ) , getreadconcern ( ) ) ; } catch ( mongowriteconcernexception e ) { throw createwriteconcernexception ( e ) ; } }	Drops this database. Removes all data on disk. Use with caution.
public set < string > getcollectionnames ( ) { list < string > collectionnames = new mongoiterableimpl < dbobject > ( null , executor , readconcern . default , primary ( ) , mongo . getmongoclientoptions ( ) . getretryreads ( ) ) { @ override public readoperation < batchcursor < dbobject > > asreadoperation ( ) { return new listcollectionsoperation < dbobject > ( name , commandcodec ) . nameonly ( bool_ ) ; } } . map ( new function < dbobject , string > ( ) { @ override public string apply ( final dbobject result ) { return ( string ) result . get ( str_ ) ; } } ) . into ( new arraylist < string > ( ) ) ; collections . sort ( collectionnames ) ; return new linkedhashset < string > ( collectionnames ) ; }	Returns a set containing the names of all collections in this database.
public commandresult command ( final dbobject command , final readpreference readpreference , @ nullable final dbencoder encoder ) { try { return executecommand ( wrap ( command , encoder ) , getcommandreadpreference ( command , readpreference ) ) ; } catch ( mongocommandexception ex ) { return new commandresult ( ex . getresponse ( ) , ex . getserveraddress ( ) ) ; } }	Executes a database command with the selected readPreference, and encodes the command using the given encoder.
public commandresult command ( final dbobject command , final readpreference readpreference ) { return command ( command , readpreference , null ) ; }	Executes the command against the database with the given read preference.
public boolean collectionexists ( final string collectionname ) { set < string > collectionnames = getcollectionnames ( ) ; for ( final string name : collectionnames ) { if ( name . equalsignorecase ( collectionname ) ) { return bool_ ; } } return bool_ ; }	Checks to see if a collection with a given name exists on a server.
@ deprecated public commandresult doeval ( final string code , final object ... args ) { dbobject commanddocument = new basicdbobject ( str_ , code ) . append ( str_ , aslist ( args ) ) ; return executecommand ( wrap ( commanddocument ) ) ; }	Evaluates JavaScript functions on the database server.
@ deprecated public commandresult getstats ( ) { bsondocument commanddocument = new bsondocument ( str_ , new bsonint32 ( num_ ) ) . append ( str_ , new bsonint32 ( num_ ) ) ; return executecommand ( commanddocument ) ; }	Helper method for calling a 'dbStats' command.
@ deprecated public writeresult removeuser ( final string username ) { try { executor . execute ( new com . mongodb . operation . dropuseroperation ( getname ( ) , username , getwriteconcern ( ) ) , getreadconcern ( ) ) ; return new writeresult ( num_ , bool_ , null ) ; } catch ( mongowriteconcernexception e ) { throw createwriteconcernexception ( e ) ; } }	Removes the specified user from the database.
readpreference getcommandreadpreference ( final dbobject command , @ nullable final readpreference requestedpreference ) { string comstring = command . keyset ( ) . iterator ( ) . next ( ) . tolowercase ( ) ; boolean primaryrequired = ! obedient_commands . contains ( comstring ) ; if ( primaryrequired ) { return readpreference . primary ( ) ; } else if ( requestedpreference == null ) { return readpreference . primary ( ) ; } else { return requestedpreference ; } }	Determines the read preference that should be used for the given command.
public < u > codec < u > get ( final class < u > clazz ) { if ( hascycles ( clazz ) ) { return new lazycodec < u > ( registry , clazz ) ; } else { return registry . get ( new childcodecregistry < u > ( this , clazz ) ) ; } }	Gets a Codec, but if it detects a cyclic dependency, return a LazyCodec which breaks the chain.
public writeresult update ( final dbobject query , final dbobject update , final dbcollectionupdateoptions options ) { notnull ( str_ , query ) ; notnull ( str_ , update ) ; notnull ( str_ , options ) ; writeconcern writeconcern = options . getwriteconcern ( ) != null ? options . getwriteconcern ( ) : getwriteconcern ( ) ; com . mongodb . bulk . writerequest . type updatetype = ! update . keyset ( ) . isempty ( ) && update . keyset ( ) . iterator ( ) . next ( ) . startswith ( str_ ) ? com . mongodb . bulk . writerequest . type . update : com . mongodb . bulk . writerequest . type . replace ; updaterequest updaterequest = new updaterequest ( wrap ( query ) , wrap ( update , options . getencoder ( ) ) , updatetype ) . upsert ( options . isupsert ( ) ) . multi ( options . ismulti ( ) ) . collation ( options . getcollation ( ) ) . arrayfilters ( wrapallownull ( options . getarrayfilters ( ) , options . getencoder ( ) ) ) ; return executewriteoperation ( new updateoperation ( getnamespace ( ) , bool_ , writeconcern , retrywrites , singletonlist ( updaterequest ) ) . bypassdocumentvalidation ( options . getbypassdocumentvalidation ( ) ) ) ; }	Modify an existing document or documents in collection.
@ nullable public dbobject findone ( final object id , final dbobject projection ) { return findone ( new basicdbobject ( str_ , id ) , new dbcollectionfindoptions ( ) . projection ( projection ) ) ; }	Get a single document from collection by '_id'.
public dbcollection rename ( final string newname , final boolean droptarget ) { try { executor . execute ( new renamecollectionoperation ( getnamespace ( ) , new mongonamespace ( getnamespace ( ) . getdatabasename ( ) , newname ) , getwriteconcern ( ) ) . droptarget ( droptarget ) , getreadconcern ( ) ) ; return getdb ( ) . getcollection ( newname ) ; } catch ( mongowriteconcernexception e ) { throw createwriteconcernexception ( e ) ; } }	Change the name of an existing collection.
public commandresult explainaggregate ( final list < ? extends dbobject > pipeline , final aggregationoptions options ) { aggregateoperation < bsondocument > operation = new aggregateoperation < bsondocument > ( getnamespace ( ) , preparepipeline ( pipeline ) , new bsondocumentcodec ( ) ) . maxtime ( options . getmaxtime ( milliseconds ) , milliseconds ) . allowdiskuse ( options . getallowdiskuse ( ) ) . collation ( options . getcollation ( ) ) . retryreads ( retryreads ) ; return new commandresult ( executor . execute ( operation . asexplainableoperation ( explainverbosity . query_planner ) , primarypreferred ( ) , getreadconcern ( ) ) ) ; }	Return the explain plan for the aggregation pipeline.
public void createindex ( final dbobject keys , @ nullable final string name , final boolean unique ) { dbobject options = new basicdbobject ( ) ; if ( name != null && name . length ( ) > num_ ) { options . put ( str_ , name ) ; } if ( unique ) { options . put ( str_ , boolean . true ) ; } createindex ( keys , options ) ; }	Forces creation of an index on a set of fields, if one does not already exist.
public void createindex ( final dbobject keys , final dbobject options ) { try { executor . execute ( createindexoperation ( keys , options ) , getreadconcern ( ) ) ; } catch ( mongowriteconcernexception e ) { throw createwriteconcernexception ( e ) ; } }	Creates an index on the field specified, if that index does not already exist.
@ nullable public dbobject findandremove ( @ nullable final dbobject query ) { return findandmodify ( query , null , null , bool_ , null , bool_ , bool_ ) ; }	Atomically remove and return a single document.
public synchronized void setdbdecoderfactory ( @ nullable final dbdecoderfactory factory ) { this . decoderfactory = factory ;	Set a custom decoder factory for this collection.
public synchronized void setdbencoderfactory ( @ nullable final dbencoderfactory factory ) { this . encoderfactory = factory ;	Set a custom encoder factory for this collection.
public list < dbobject > getindexinfo ( ) { return new mongoiterableimpl < dbobject > ( null , executor , readconcern . default , primary ( ) , retryreads ) { @ override public readoperation < batchcursor < dbobject > > asreadoperation ( ) { return new listindexesoperation < dbobject > ( getnamespace ( ) , getdefaultdbobjectcodec ( ) ) . retryreads ( retryreads ) ; } } . into ( new arraylist < dbobject > ( ) ) ; }	Return a list of the indexes for this collection. Each object in the list is the "info document" from MongoDB.
public void dropindex ( final dbobject index ) { try { executor . execute ( new dropindexoperation ( getnamespace ( ) , wrap ( index ) , getwriteconcern ( ) ) , getreadconcern ( ) ) ; } catch ( mongowriteconcernexception e ) { throw createwriteconcernexception ( e ) ; } }	Drops an index from this collection.
public void dropindex ( final string indexname ) { try { executor . execute ( new dropindexoperation ( getnamespace ( ) , indexname , getwriteconcern ( ) ) , getreadconcern ( ) ) ; } catch ( mongowriteconcernexception e ) { throw createwriteconcernexception ( e ) ; } }	Drops the index with the given name from this collection.
public boolean iscapped ( ) { commandresult commandresult = getstats ( ) ; object cappedfield = commandresult . get ( str_ ) ; return cappedfield != null && ( cappedfield . equals ( num_ ) || cappedfield . equals ( bool_ ) ) ; }	Checks whether this collection is capped.
public void setinternalclass ( final string path , final class < ? extends dbobject > aclass ) { setobjectfactory ( objectfactory . update ( aclass , aslist ( path . split ( str_ ) ) ) ) ; }	Sets the internal class for the given path in the document hierarchy.
protected class < ? extends dbobject > getinternalclass ( final string path ) { return objectfactory . getclassforpath ( aslist ( path . split ( str_ ) ) ) ; }	Gets the internal class for the given path in the document hierarchy.
public static < titem > bson set ( final string fieldname , @ nullable final titem value ) { return new simpleupdate < titem > ( fieldname , value , str_ ) ; }	Creates an update that sets the value of the field with the given name to the given value.
public static < titem > bson setoninsert ( final string fieldname , @ nullable final titem value ) { return new simpleupdate < titem > ( fieldname , value , str_ ) ; }	Creates an update that sets the value of the field with the given name to the given value, but only if the update is an upsert thatresults in an insert of a document.
public static bson rename ( final string fieldname , final string newfieldname ) { notnull ( str_ , newfieldname ) ; return new simpleupdate < string > ( fieldname , newfieldname , str_ ) ; }	Creates an update that renames a field.
public static bson inc ( final string fieldname , final number number ) { notnull ( str_ , number ) ; return new simpleupdate < number > ( fieldname , number , str_ ) ; }	Creates an update that increments the value of the field with the given name by the given value.
public static bson mul ( final string fieldname , final number number ) { notnull ( str_ , number ) ; return new simpleupdate < number > ( fieldname , number , str_ ) ; }	Creates an update that multiplies the value of the field with the given name by the given number.
public static < titem > bson min ( final string fieldname , final titem value ) { return new simpleupdate < titem > ( fieldname , value , str_ ) ; }	Creates an update that sets the value of the field to the given value if the given value is less than the current value of thefield.
public static < titem > bson max ( final string fieldname , final titem value ) { return new simpleupdate < titem > ( fieldname , value , str_ ) ; }	Creates an update that sets the value of the field to the given value if the given value is greater than the current value of thefield.
public static < titem > bson addtoset ( final string fieldname , @ nullable final titem value ) { return new simpleupdate < titem > ( fieldname , value , str_ ) ; }	Creates an update that adds the given value to the array value of the field with the given name, unless the value isalready present, in which case it does nothing.
public static < titem > bson addeachtoset ( final string fieldname , final list < titem > values ) { return new witheachupdate < titem > ( fieldname , values , str_ ) ; }	Creates an update that adds each of the given values to the array value of the field with the given name, unless the value isalready present, in which case it does nothing.
public static < titem > bson push ( final string fieldname , @ nullable final titem value ) { return new simpleupdate < titem > ( fieldname , value , str_ ) ; }	Creates an update that adds the given value to the array value of the field with the given name.
public static < titem > bson pusheach ( final string fieldname , final list < titem > values ) { return new pushupdate < titem > ( fieldname , values , new pushoptions ( ) ) ; }	Creates an update that adds each of the given values to the array value of the field with the given name.
public static < titem > bson pull ( final string fieldname , @ nullable final titem value ) { return new simpleupdate < titem > ( fieldname , value , str_ ) ; }	Creates an update that removes all instances of the given value from the array value of the field with the given name.
public static bson pullbyfilter ( final bson filter ) { return new bson ( ) { @ override public < tdocument > bsondocument tobsondocument ( final class < tdocument > tdocumentclass , final codecregistry codecregistry ) { bsondocumentwriter writer = new bsondocumentwriter ( new bsondocument ( ) ) ; writer . writestartdocument ( ) ; writer . writename ( str_ ) ; encodevalue ( writer , filter , codecregistry ) ; writer . writeenddocument ( ) ; return writer . getdocument ( ) ; } } ; }	Creates an update that removes from an array all elements that match the given filter.
public static < titem > bson pullall ( final string fieldname , final list < titem > values ) { return new pullallupdate < titem > ( fieldname , values ) ; }	Creates an update that removes all instances of the given values from the array value of the field with the given name.
protected void writequeryprologue ( final bsonoutput bsonoutput ) { bsonoutput . writeint32 ( getcursorflag ( ) ) ; bsonoutput . writecstring ( getcollectionname ( ) ) ; bsonoutput . writeint32 ( skip ) ; bsonoutput . writeint32 ( numbertoreturn ) ; }	Write the query prologue to the given BSON output.
private void incrementgenerationonsocketexception ( final internalconnection connection , final throwable t ) { if ( t instanceof mongosocketexception && ! ( t instanceof mongosocketreadtimeoutexception ) ) { if ( logger . iswarnenabled ( ) ) { logger . warn ( format ( str_ , getid ( connection ) , serverid . getaddress ( ) , serverid . getaddress ( ) ) ) ; } invalidate ( ) ; } }	If there was a socket exception that wasn't some form of interrupted read, increment the generation count so that any connectionscreated prior will be discarded.
public static < t > list < class < ? > > getancestry ( final class < t > clazz ) { return classancestry . getancestry ( clazz ) ; }	Helper method that walks superclass and interface graph, superclasses first, then interfaces, to compute an ancestry list.
@ deprecated public static replaceoptions createreplaceoptions ( final updateoptions updateoptions ) { notnull ( str_ , updateoptions ) ; list < ? extends bson > arrayfilters = updateoptions . getarrayfilters ( ) ; istrue ( str_ , arrayfilters == null || arrayfilters . isempty ( ) ) ; return new replaceoptions ( ) . bypassdocumentvalidation ( updateoptions . getbypassdocumentvalidation ( ) ) . collation ( updateoptions . getcollation ( ) ) . upsert ( updateoptions . isupsert ( ) ) ; }	Creates replace options from updateOptions.
public static byte [ ] decode ( final string s ) { int delta = s . endswith ( str_ ) ? num_ : s . endswith ( str_ ) ? num_ : num_ ; byte [ ] buffer = new byte [ s . length ( ) * bytes_per_unencoded_block / bytes_per_encoded_block - delta ] ; int mask = num_ ; int pos = num_ ; for ( int i = num_ ; i < s . length ( ) ; i += bytes_per_encoded_block ) { int c0 = decode_table [ s . charat ( i ) ] ; int c1 = decode_table [ s . charat ( i + num_ ) ] ; buffer [ pos ++ ] = ( byte ) ( ( ( c0 << num_ ) | ( c1 > > num_ ) ) & mask ) ; if ( pos >= buffer . length ) { return buffer ; } int c2 = decode_table [ s . charat ( i + num_ ) ] ; buffer [ pos ++ ] = ( byte ) ( ( ( c1 << num_ ) | ( c2 > > num_ ) ) & mask ) ; if ( pos >= buffer . length ) { return buffer ; } int c3 = decode_table [ s . charat ( i + num_ ) ] ; buffer [ pos ++ ] = ( byte ) ( ( ( c2 << num_ ) | c3 ) & mask ) ; } return buffer ; }	Decodes the given Base64-encoded string.
public static string encode ( final byte [ ] in ) { int modulus = num_ ; int bitworkarea = num_ ; int numencodedbytes = ( in . length / bytes_per_unencoded_block ) * bytes_per_encoded_block + ( ( in . length % bytes_per_unencoded_block == num_ ) ? num_ : num_ ) ; byte [ ] buffer = new byte [ numencodedbytes ] ; int pos = num_ ; for ( int b : in ) { modulus = ( modulus + num_ ) % bytes_per_unencoded_block ; if ( b < num_ ) { b += num_ ; } bitworkarea = ( bitworkarea << num_ ) + b ;	Encodes the given byte array into a Base64-encoded string.
@ deprecated @ suppresswarnings ( str_ ) @ nullable public serveraddress getaddress ( ) { clusterdescription description = getclusterdescription ( ) ; if ( description . getprimaries ( ) . isempty ( ) ) { return null ; } return description . getprimaries ( ) . get ( num_ ) . getaddress ( ) ; }	Gets the address of the current master.
@ suppresswarnings ( str_ ) @ deprecated @ nullable public replicasetstatus getreplicasetstatus ( ) { clusterdescription clusterdescription = getclusterdescription ( ) ; return clusterdescription . gettype ( ) == replica_set && clusterdescription . getconnectionmode ( ) == multiple ? new replicasetstatus ( delegate . getcluster ( ) ) : null ;	Get the status of the replica set cluster.
@ deprecated public list < string > getdatabasenames ( ) { return new mongoiterableimpl < dbobject > ( null , createoperationexecutor ( ) , readconcern . default , primary ( ) , options . getretryreads ( ) ) { @ override public readoperation < batchcursor < dbobject > > asreadoperation ( ) { return new listdatabasesoperation < dbobject > ( mongoclient . getcommandcodec ( ) ) ; } } . map ( new function < dbobject , string > ( ) { @ override public string apply ( final dbobject result ) { return ( string ) result . get ( str_ ) ; } } ) . into ( new arraylist < string > ( ) ) ; }	Gets a list of the names of all databases on the connected server.
@ deprecated public commandresult fsync ( final boolean async ) { dbobject command = new basicdbobject ( str_ , num_ ) ; if ( async ) { command . put ( str_ , num_ ) ; } return getdb ( admin_database_name ) . command ( command ) ; }	Forces the master server to fsync the RAM data to disk This is done automatically by the server at intervals, but can be forced forbetter reliability.
@ deprecated public commandresult fsyncandlock ( ) { dbobject command = new basicdbobject ( str_ , num_ ) ; command . put ( str_ , num_ ) ; return getdb ( admin_database_name ) . command ( command ) ; }	Forces the master server to fsync the RAM data to disk, then lock all writes.
@ deprecated public dbobject unlock ( ) { return dbobjects . todbobject ( createoperationexecutor ( ) . execute ( new fsyncunlockoperation ( ) , readpreference , readconcern ) ) ; }	Unlocks the database, allowing the write operations to go through.
public bsonnumber asnumber ( ) { if ( getbsontype ( ) != bsontype . int32 && getbsontype ( ) != bsontype . int64 && getbsontype ( ) != bsontype . double ) { throw new bsoninvalidoperationexception ( format ( str_ , getbsontype ( ) ) ) ; } return ( bsonnumber ) this ; }	Gets this value as a BsonNumber if it is one, otherwise throws exception.
public connectionid withservervalue ( final int servervalue ) { istrue ( str_ , this . servervalue == null ) ; return new connectionid ( serverid , localvalue , servervalue ) ; }	Creates a new connectionId with the set server value.
private static list < class < ? > > computeancestry ( final class < ? > c ) { list < class < ? > > result = new arraylist < class < ? > > ( ) ; result . add ( object . class ) ; computeancestry ( c , result ) ; collections . reverse ( result ) ; return unmodifiablelist ( new arraylist < class < ? > > ( result ) ) ; }	Starting with children and going back to parents.
@ suppresswarnings ( { str_ , str_ , str_ } ) public string tojson ( ) { stringwriter stringwriter = new stringwriter ( ) ; jsonwriter writer = new jsonwriter ( stringwriter , new jsonwritersettings ( ) ) ; codec codec = getregistry ( ) . get ( getclass ( ) ) ; codec . encode ( writer , this , encodercontext . builder ( ) . build ( ) ) ; return stringwriter . tostring ( ) ; }	Converts to GeoJSON representation.
@ override @ suppresswarnings ( str_ ) public mapreducebatchcursor < t > execute ( final readbinding binding ) { return executecommand ( binding , namespace . getdatabasename ( ) , getcommandcreator ( binding . getsessioncontext ( ) ) , commandresultdocumentcodec . create ( decoder , str_ ) , transformer ( ) , bool_ ) ; }	Executing this will return a cursor with your results and the statistics in.
@ nullable public long getexpireafter ( final timeunit timeunit ) { if ( expireafterseconds == null ) { return null ; } return timeunit . convert ( expireafterseconds , timeunit . seconds ) ; }	Gets the time to live for documents in the collection.
public dbobject todbobject ( ) { dbobject args = new basicdbobject ( str_ , collectionname ) . append ( str_ , condition ) . append ( str_ , reduce ) . append ( str_ , initial ) ; if ( keys != null ) { args . put ( str_ , keys ) ; } if ( keyf != null ) { args . put ( str_ , keyf ) ; } if ( finalize != null ) { args . put ( str_ , finalize ) ; } return new basicdbobject ( str_ , args ) ; }	Turns this group command into the DBObject format of the command.
public integer getlogicalsessiontimeoutminutes ( ) { integer retval = null ; for ( serverdescription cur : getserversbypredicate ( new predicate ( ) { @ override public boolean apply ( final serverdescription serverdescription ) { return serverdescription . isprimary ( ) || serverdescription . issecondary ( ) ; } } ) ) { if ( cur . getlogicalsessiontimeoutminutes ( ) == null ) { return null ; } if ( retval == null ) { retval = cur . getlogicalsessiontimeoutminutes ( ) ; } else { retval = math . min ( retval , cur . getlogicalsessiontimeoutminutes ( ) ) ; } } return retval ; }	Gets the logical session timeout in minutes, or null if at least one of the known servers does not support logical sessions.
@ deprecated public set < serverdescription > getall ( ) { set < serverdescription > serverdescriptionset = new treeset < serverdescription > ( new comparator < serverdescription > ( ) { @ override public int compare ( final serverdescription o1 , final serverdescription o2 ) { int val = o1 . getaddress ( ) . gethost ( ) . compareto ( o2 . getaddress ( ) . gethost ( ) ) ; if ( val != num_ ) { return val ; } return integercompare ( o1 . getaddress ( ) . getport ( ) , o2 . getaddress ( ) . getport ( ) ) ; } private int integercompare ( final int p1 , final int p2 ) { return ( p1 < p2 ) ? - num_ : ( ( p1 == p2 ) ? num_ : num_ ) ; } } ) ; serverdescriptionset . addall ( serverdescriptions ) ; return collections . unmodifiableset ( serverdescriptionset ) ; }	Returns the Set of all server descriptions in this cluster, sorted by the String value of the ServerAddress of each one.
@ deprecated public serverdescription getbyserveraddress ( final serveraddress serveraddress ) { for ( final serverdescription cur : serverdescriptions ) { if ( cur . isok ( ) && cur . getaddress ( ) . equals ( serveraddress ) ) { return cur ; } } return null ; }	Returns the ServerDescription for the server at the given address.
@ deprecated public list < serverdescription > getprimaries ( ) { return getserversbypredicate ( new predicate ( ) { public boolean apply ( final serverdescription serverdescription ) { return serverdescription . isprimary ( ) ; } } ) ; }	While it may seem counter-intuitive that a MongoDB cluster can have more than one primary, it can in the case where the client's viewof the cluster is a set of mongos servers, any of which can serve as the primary.
@ deprecated public list < serverdescription > getsecondaries ( ) { return getserversbypredicate ( new predicate ( ) { public boolean apply ( final serverdescription serverdescription ) { return serverdescription . issecondary ( ) ; } } ) ; }	Get a list of all the secondaries in this cluster.
@ deprecated public list < serverdescription > getsecondaries ( final tagset tagset ) { return getserversbypredicate ( new predicate ( ) { public boolean apply ( final serverdescription serverdescription ) { return serverdescription . issecondary ( ) && serverdescription . hastags ( tagset ) ; } } ) ; }	Get a list of all the secondaries in this cluster that match a given TagSet.
@ deprecated public list < serverdescription > getany ( ) { return getserversbypredicate ( new predicate ( ) { public boolean apply ( final serverdescription serverdescription ) { return serverdescription . isok ( ) ; } } ) ; }	Gets a list of ServerDescriptions for all the servers in this cluster which are currently accessible.
@ deprecated public list < serverdescription > getanyprimaryorsecondary ( ) { return getserversbypredicate ( new predicate ( ) { public boolean apply ( final serverdescription serverdescription ) { return serverdescription . isprimary ( ) || serverdescription . issecondary ( ) ; } } ) ; }	Gets a list of all the primaries and secondaries in this cluster.
@ deprecated public list < serverdescription > getanyprimaryorsecondary ( final tagset tagset ) { return getserversbypredicate ( new predicate ( ) { public boolean apply ( final serverdescription serverdescription ) { return ( serverdescription . isprimary ( ) || serverdescription . issecondary ( ) ) && serverdescription . hastags ( tagset ) ; } } ) ; }	Gets a list of all the primaries and secondaries in this cluster that match the given replica set tags.
public string getshortdescription ( ) { stringbuilder serverdescriptions = new stringbuilder ( ) ; string delimiter = str_ ; for ( final serverdescription cur : this . serverdescriptions ) { serverdescriptions . append ( delimiter ) . append ( cur . getshortdescription ( ) ) ; delimiter = str_ ; } if ( srvresolutionexception == null ) { return format ( str_ , type , serverdescriptions ) ; } else { return format ( str_ , type , srvresolutionexception , serverdescriptions ) ; } }	Returns a short, pretty description for this ClusterDescription.
public static mongocredential createscramsha256credential ( final string username , final string source , final char [ ] password ) { return new mongocredential ( scram_sha_256 , username , source , password ) ; }	Creates a MongoCredential instance for the SCRAM-SHA-256 SASL mechanism.
public static mongocredential createplaincredential ( final string username , final string source , final char [ ] password ) { return new mongocredential ( plain , username , source , password ) ; }	Creates a MongoCredential instance for the PLAIN SASL mechanism.
public < t > mongocredential withmechanismproperty ( final string key , final t value ) { return new mongocredential ( this , key , value ) ; }	Creates a new MongoCredential as a copy of this instance, with the specified mechanism property added.
public mongocredential withmechanism ( final authenticationmechanism mechanism ) { if ( this . mechanism != null ) { throw new illegalargumentexception ( str_ ) ; } return new mongocredential ( mechanism , username , source , password , mechanismproperties ) ; }	Creates a new MongoCredential with the set mechanism.
@ suppresswarnings ( str_ ) @ nullable public < t > t getmechanismproperty ( final string key , @ nullable final t defaultvalue ) { notnull ( str_ , key ) ; t value = ( t ) mechanismproperties . get ( key . tolowercase ( ) ) ; return ( value == null ) ? defaultvalue : value ; }	Get the value of the given key to a mechanism property, or defaultValue if there is no mapping.
public byte [ ] tobytearray ( ) { try { bytearrayoutputstream bout = new bytearrayoutputstream ( size ( ) ) ; pipe ( bout ) ; return bout . tobytearray ( ) ; } catch ( ioexception ioe ) { throw new runtimeexception ( str_ , ioe ) ; } }	Gets a copy of the buffered bytes.
@ suppresswarnings ( str_ ) void addobjectserializer ( final class c , final objectserializer serializer ) { _serializers . put ( c , serializer ) ; }	Assign a ObjectSerializer to perform a type specific serialization scheme.
public updaterequest multi ( final boolean ismulti ) { if ( ismulti && updatetype == type . replace ) { throw new illegalargumentexception ( str_ ) ; } this . ismulti = ismulti ; return this ; }	Sets whether this will update all documents matching the query filter.
public void encode ( final bsonoutput bsonoutput , final sessioncontext sessioncontext ) { notnull ( str_ , sessioncontext ) ; int messagestartposition = bsonoutput . getposition ( ) ; writemessageprologue ( bsonoutput ) ; encodingmetadata encodingmetadata = encodemessagebodywithmetadata ( bsonoutput , sessioncontext ) ; backpatchmessagelength ( messagestartposition , bsonoutput ) ; this . encodingmetadata = encodingmetadata ; }	Encoded the message to the given output.
protected void writemessageprologue ( final bsonoutput bsonoutput ) { bsonoutput . writeint32 ( num_ ) ;	Writes the message prologue to the given output.
protected void adddocument ( final bsondocument document , final bsonoutput bsonoutput , final fieldnamevalidator validator ) { adddocument ( document , getcodec ( document ) , encodercontext . builder ( ) . build ( ) , bsonoutput , validator , settings . getmaxdocumentsize ( ) + document_headroom , null ) ; }	Appends a document to the message.
protected void addcollectibledocument ( final bsondocument document , final bsonoutput bsonoutput , final fieldnamevalidator validator ) { adddocument ( document , getcodec ( document ) , encodercontext . builder ( ) . isencodingcollectibledocument ( bool_ ) . build ( ) , bsonoutput , validator , settings . getmaxdocumentsize ( ) , null ) ; }	Appends a document to the message that is intended for storage in a collection.
protected void backpatchmessagelength ( final int startposition , final bsonoutput bsonoutput ) { int messagelength = bsonoutput . getposition ( ) - startposition ; bsonoutput . writeint32 ( bsonoutput . getposition ( ) - messagelength , messagelength ) ; }	Backpatches the message length into the beginning of the message.
protected dbobject createchunk ( final object id , final int currentchunknumber , final byte [ ] writebuffer ) { return new basicdbobject ( str_ , id ) . append ( str_ , currentchunknumber ) . append ( str_ , writebuffer ) ; }	Creates a new chunk of this file.
public dbcursor copy ( ) { return new dbcursor ( collection , filter , findoptions , executor , decoderfactory , decoder , retryreads ) ; }	Creates a copy of an existing database cursor.
@ override public boolean hasnext ( ) { if ( closed ) { throw new illegalstateexception ( str_ ) ; } if ( cursor == null ) { findoperation < dbobject > operation = getqueryoperation ( decoder ) ; if ( operation . getcursortype ( ) == cursortype . tailable ) { operation . cursortype ( cursortype . tailableawait ) ; } initializecursor ( operation ) ; } boolean hasnext = cursor . hasnext ( ) ; setservercursoronfinalizer ( cursor . getservercursor ( ) ) ; return hasnext ; }	Checks if there is another object available. Note : Automatically adds the {.
@ nullable public dbobject trynext ( ) { if ( cursor == null ) { findoperation < dbobject > operation = getqueryoperation ( decoder ) ; if ( ! operation . getcursortype ( ) . istailable ( ) ) { throw new illegalargumentexception ( str_ ) ; } initializecursor ( operation ) ; } dbobject next = cursor . trynext ( ) ; setservercursoronfinalizer ( cursor . getservercursor ( ) ) ; return currentobject ( next ) ; }	Non blocking check for tailable cursors to see if another object is available.
public list < dbobject > toarray ( final int max ) { checkiteratororarray ( iteratororarray . array ) ; fillarray ( max - num_ ) ; return all ; }	Converts this cursor to an array.
@ nullable public dbobject one ( ) { dbcursor findonecursor = copy ( ) . limit ( - num_ ) ; try { return findonecursor . hasnext ( ) ? findonecursor . next ( ) : null ; } finally { findonecursor . close ( ) ; } }	Returns the first document that matches the query.
public readpreference getreadpreference ( ) { readpreference readpreference = findoptions . getreadpreference ( ) ; if ( readpreference != null ) { return readpreference ; } return collection . getreadpreference ( ) ; }	Gets the default read preference.
readconcern getreadconcern ( ) { readconcern readconcern = findoptions . getreadconcern ( ) ; if ( readconcern != null ) { return readconcern ; } return collection . getreadconcern ( ) ; }	Get the read concern for this collection.
protected void _put ( final string name , final object value ) { cur ( ) . put ( name , ! bson . hasdecodehooks ( ) ? value : bson . applydecodinghooks ( value ) ) ; }	Puts a new value into the document.
protected void putdbref ( final string name , final dbref ref ) { basicdbobject dbrefdocument = new basicdbobject ( str_ , ref . getcollectionname ( ) ) . append ( str_ , ref . getid ( ) ) ; if ( ref . getdatabasename ( ) != null ) { dbrefdocument . put ( str_ , ref . getdatabasename ( ) ) ; } putobject ( name , dbrefdocument ) ; }	Deals with encoding database references.
public static bulkwriteresult unacknowledged ( ) { return new bulkwriteresult ( ) { @ override public boolean wasacknowledged ( ) { return bool_ ; } @ override public int getinsertedcount ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override public int getmatchedcount ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override public int getdeletedcount ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override @ deprecated public boolean ismodifiedcountavailable ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override public int getmodifiedcount ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override public list < bulkwriteupsert > getupserts ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override public boolean equals ( final object o ) { if ( this == o ) { return bool_ ; } if ( o == null || getclass ( ) != o . getclass ( ) ) { return bool_ ; } bulkwriteresult that = ( bulkwriteresult ) o ; return ! that . wasacknowledged ( ) ; } @ override public int hashcode ( ) { return num_ ; } @ override public string tostring ( ) { return str_ ; } private unsupportedoperationexception getunacknowledgedwriteexception ( ) { return new unsupportedoperationexception ( str_ ) ; } } ; }	Create an unacknowledged BulkWriteResult.
public inetsocketaddress getsocketaddress ( ) { try { return new inetsocketaddress ( inetaddress . getbyname ( host ) , port ) ; } catch ( unknownhostexception e ) { throw new mongosocketexception ( e . getmessage ( ) , this , e ) ; } }	Gets the underlying socket address.
public list < inetsocketaddress > getsocketaddresses ( ) { try { inetaddress [ ] inetaddresses = inetaddress . getallbyname ( host ) ; list < inetsocketaddress > inetsocketaddresslist = new arraylist < inetsocketaddress > ( ) ; for ( inetaddress inetaddress : inetaddresses ) { inetsocketaddresslist . add ( new inetsocketaddress ( inetaddress , port ) ) ; } return inetsocketaddresslist ; } catch ( unknownhostexception e ) { throw new mongosocketexception ( e . getmessage ( ) , this , e ) ; } }	Gets all underlying socket addresses.
public static < titem > bson ne ( final string fieldname , @ nullable final titem value ) { return new operatorfilter < titem > ( str_ , fieldname , value ) ; }	Creates a filter that matches all documents where the value of the field name does not equal the specified value.
public static < titem > bson gt ( final string fieldname , final titem value ) { return new operatorfilter < titem > ( str_ , fieldname , value ) ; }	Creates a filter that matches all documents where the value of the given field is greater than the specified value.
public static < titem > bson lt ( final string fieldname , final titem value ) { return new operatorfilter < titem > ( str_ , fieldname , value ) ; }	Creates a filter that matches all documents where the value of the given field is less than the specified value.
public static < titem > bson gte ( final string fieldname , final titem value ) { return new operatorfilter < titem > ( str_ , fieldname , value ) ; }	Creates a filter that matches all documents where the value of the given field is greater than or equal to the specified value.
public static < titem > bson lte ( final string fieldname , final titem value ) { return new operatorfilter < titem > ( str_ , fieldname , value ) ; }	Creates a filter that matches all documents where the value of the given field is less than or equal to the specified value.
public static bson or ( final iterable < bson > filters ) { return new ornorfilter ( ornorfilter . operator . or , filters ) ; }	Creates a filter that preforms a logical OR of the provided list of filters.
public static bson nor ( final iterable < bson > filters ) { return new ornorfilter ( ornorfilter . operator . nor , filters ) ; }	Creates a filter that performs a logical NOR operation on all the specified filters.
public static bson exists ( final string fieldname , final boolean exists ) { return new operatorfilter < bsonboolean > ( str_ , fieldname , bsonboolean . valueof ( exists ) ) ; }	Creates a filter that matches all documents that either contain or do not contain the given field, depending on the value of theexists parameter.
@ deprecated public static bson text ( final string search , final string language ) { notnull ( str_ , search ) ; return text ( search , new textsearchoptions ( ) . language ( language ) ) ; }	Creates a filter that matches all documents matching the given search term using the given language.
public static bson text ( final string search , final textsearchoptions textsearchoptions ) { notnull ( str_ , search ) ; notnull ( str_ , textsearchoptions ) ; return new textfilter ( search , textsearchoptions ) ; }	Creates a filter that matches all documents matching the given the search term with the given text search options.
public static bson elemmatch ( final string fieldname , final bson filter ) { return new bson ( ) { @ override public < tdocument > bsondocument tobsondocument ( final class < tdocument > documentclass , final codecregistry codecregistry ) { return new bsondocument ( fieldname , new bsondocument ( str_ , filter . tobsondocument ( documentclass , codecregistry ) ) ) ; } } ; }	Creates a filter that matches all documents containing a field that is an array where at least one member of the array matches thegiven filter.
public static bson geowithinbox ( final string fieldname , final double lowerleftx , final double lowerlefty , final double upperrightx , final double upperrighty ) { bsondocument box = new bsondocument ( str_ , new bsonarray ( aslist ( new bsonarray ( aslist ( new bsondouble ( lowerleftx ) , new bsondouble ( lowerlefty ) ) ) , new bsonarray ( aslist ( new bsondouble ( upperrightx ) , new bsondouble ( upperrighty ) ) ) ) ) ) ; return new operatorfilter < bsondocument > ( str_ , fieldname , box ) ; }	Creates a filter that matches all documents containing a field with grid coordinates data that exist entirely within the specifiedbox.
public static bson geowithinpolygon ( final string fieldname , final list < list < double > > points ) { bsonarray pointsarray = new bsonarray ( ) ; for ( list < double > point : points ) { pointsarray . add ( new bsonarray ( aslist ( new bsondouble ( point . get ( num_ ) ) , new bsondouble ( point . get ( num_ ) ) ) ) ) ; } bsondocument polygon = new bsondocument ( str_ , pointsarray ) ; return new operatorfilter < bsondocument > ( str_ , fieldname , polygon ) ; }	Creates a filter that matches all documents containing a field with grid coordinates data that exist entirely within the specifiedpolygon.
public static bson geowithincenter ( final string fieldname , final double x , final double y , final double radius ) { bsondocument center = new bsondocument ( str_ , new bsonarray ( arrays . < bsonvalue > aslist ( new bsonarray ( aslist ( new bsondouble ( x ) , new bsondouble ( y ) ) ) , new bsondouble ( radius ) ) ) ) ; return new operatorfilter < bsondocument > ( str_ , fieldname , center ) ; }	Creates a filter that matches all documents containing a field with grid coordinates data that exist entirely within the specifiedcircle.
public static bson near ( final string fieldname , final point geometry , @ nullable final double maxdistance , @ nullable final double mindistance ) { return new geometryoperatorfilter < point > ( str_ , fieldname , geometry , maxdistance , mindistance ) ; }	Creates a filter that matches all documents containing a field with geospatial data that is near the specified GeoJSON point.
public static bson near ( final string fieldname , final double x , final double y , @ nullable final double maxdistance , @ nullable final double mindistance ) { return createnearfilterdocument ( fieldname , x , y , maxdistance , mindistance , str_ ) ; }	Creates a filter that matches all documents containing a field with geospatial data that is near the specified point.
public static int regexflags ( final string s ) { int flags = num_ ; if ( s == null ) { return flags ; } for ( final char f : s . tolowercase ( ) . tochararray ( ) ) { flags |= regexflag ( f ) ; } return flags ; }	Converts a sequence of regular expression modifiers from the database into Java regular expression flags.
public static int regexflag ( final char c ) { int flag = flag_lookup [ c ] ; if ( flag == num_ ) { throw new illegalargumentexception ( string . format ( str_ , c ) ) ; } return flag ; }	Converts a regular expression modifier from the database into Java regular expression flags.
public static string regexflags ( final int flags ) { int processedflags = flags ; stringbuilder buf = new stringbuilder ( ) ; for ( int i = num_ ; i < flag_lookup . length ; i ++ ) { if ( ( processedflags & flag_lookup [ i ] ) > num_ ) { buf . append ( ( char ) i ) ; processedflags -= flag_lookup [ i ] ; } } if ( processedflags > num_ ) { throw new illegalargumentexception ( str_ ) ; } return buf . tostring ( ) ; }	Converts Java regular expression flags into regular expression modifiers from the database.
public indexrequest textversion ( final integer textversion ) { if ( textversion != null ) { istrueargument ( str_ , valid_text_index_versions . contains ( textversion ) ) ; } this . textversion = textversion ; return this ; }	Set the text index version number.
public indexrequest sphereversion ( final integer sphereversion ) { if ( sphereversion != null ) { istrueargument ( str_ , valid_sphere_index_versions . contains ( sphereversion ) ) ; } this . sphereversion = sphereversion ; return this ; }	Sets the 2dsphere index version number.
public dbcollectionfindoptions copy ( ) { dbcollectionfindoptions copiedoptions = new dbcollectionfindoptions ( ) ; copiedoptions . batchsize ( batchsize ) ; copiedoptions . limit ( limit ) ; copiedoptions . modifiers ( modifiers ) ; copiedoptions . projection ( projection ) ; copiedoptions . maxtime ( maxtimems , timeunit . milliseconds ) ; copiedoptions . maxawaittime ( maxawaittimems , timeunit . milliseconds ) ; copiedoptions . skip ( skip ) ; copiedoptions . sort ( sort ) ; copiedoptions . cursortype ( cursortype ) ; copiedoptions . nocursortimeout ( nocursortimeout ) ; copiedoptions . oplogreplay ( oplogreplay ) ; copiedoptions . partial ( partial ) ; copiedoptions . readpreference ( readpreference ) ; copiedoptions . readconcern ( readconcern ) ; copiedoptions . collation ( collation ) ; copiedoptions . comment ( comment ) ; copiedoptions . hint ( hint ) ; copiedoptions . max ( max ) ; copiedoptions . min ( min ) ; copiedoptions . returnkey ( returnkey ) ; copiedoptions . showrecordid ( showrecordid ) ; return copiedoptions ; }	Copy this DBCollectionFindOptions instance into a new instance.
@ suppresswarnings ( str_ ) public static < t > t converttotype ( final class < t > clazz , final object value , final string errormessage ) { if ( ! clazz . isassignablefrom ( value . getclass ( ) ) ) { throw new illegalargumentexception ( errormessage ) ; } return ( t ) value ; }	Cast an object to the given class and return it, or throw IllegalArgumentException if it's not assignable to that class.
@ override public void encode ( final bsonwriter writer , final dbobject document , final encodercontext encodercontext ) { basicoutputbuffer buffer = new basicoutputbuffer ( ) ; try { encoder . writeobject ( buffer , document ) ; bsonbinaryreader reader = new bsonbinaryreader ( new bytebufferbsoninput ( new bytebufnio ( wrap ( buffer . tobytearray ( ) ) ) ) ) ; try { writer . pipe ( reader ) ; } finally { reader . close ( ) ; } } finally { buffer . close ( ) ; } }	over an array of ByteBuffer instances from a PooledByteBufferOutputBuffer.
@ override public bulkwriteresult execute ( final writebinding binding ) { return withreleasableconnection ( binding , new callablewithconnectionandsource < bulkwriteresult > ( ) { @ override public bulkwriteresult call ( final connectionsource connectionsource , final connection connection ) { validatewriterequestsandreleaseconnectioniferror ( connection ) ; if ( getwriteconcern ( ) . isacknowledged ( ) || serverisatleastversionthreedotsix ( connection . getdescription ( ) ) ) { bulkwritebatch bulkwritebatch = bulkwritebatch . createbulkwritebatch ( namespace , connectionsource . getserverdescription ( ) , connection . getdescription ( ) , ordered , writeconcern , bypassdocumentvalidation , retrywrites , writerequests , binding . getsessioncontext ( ) ) ; return executebulkwritebatch ( binding , connection , bulkwritebatch ) ; } else { return executelegacybatches ( connection ) ; } } } ) ; }	Executes a bulk write operation.
public bulkupdaterequestbuilder upsert ( ) { return new bulkupdaterequestbuilder ( bulkwriteoperation , query , bool_ , codec , replacementcodec , collation , null ) ; }	Specifies that the request being built should be an upsert.
public bulkupdaterequestbuilder arrayfilters ( final list < ? extends dbobject > arrayfilters ) { return new bulkupdaterequestbuilder ( bulkwriteoperation , query , bool_ , codec , replacementcodec , collation , arrayfilters ) ; }	Specifies that the request being built should use the given array filters for an update. Note that this option only applies toupdate operations and will be ignored for replace operations.
@ override public mapreducestatistics execute ( final writebinding binding ) { return withconnection ( binding , new operationhelper . callablewithconnection < mapreducestatistics > ( ) { @ override public mapreducestatistics call ( final connection connection ) { validatecollation ( connection , collation ) ; return executecommand ( binding , namespace . getdatabasename ( ) , getcommand ( connection . getdescription ( ) ) , connection , transformer ( ) ) ; } } ) ; }	Executing this will return a cursor with your results in.
public static synchronized void init ( final mongoembeddedsettings mongoembeddedsettings ) { if ( mongoembeddedlibrary != null ) { throw new mongoclientembeddedexception ( str_ ) ; } try { mongoembeddedlibrary = mongoembeddedcapi . create ( mongoembeddedsettings . getyamlconfig ( ) , mongoembeddedsettings . getloglevel ( ) . tocapiloglevel ( ) , mongoembeddedsettings . getlibrarypath ( ) ) ; } catch ( exception e ) { throw new mongoclientembeddedexception ( format ( str_ + str_ , e . getmessage ( ) ) , e ) ; } }	Initializes the mongod library for use. The library must be called at most once per process before calling {.
public static synchronized mongoclient create ( final mongoclientsettings mongoclientsettings ) { if ( mongoembeddedlibrary == null ) { throw new mongoclientembeddedexception ( str_ ) ; } try { cluster cluster = new embeddedcluster ( mongoembeddedlibrary , mongoclientsettings ) ; return new mongoclientimpl ( cluster , mongoclientsettings . getwrappedmongoclientsettings ( ) , null ) ; } catch ( exception e ) { throw new mongoclientembeddedexception ( format ( str_ + str_ + str_ , e . getmessage ( ) ) , e ) ; } }	Creates a new client.
public static synchronized void close ( ) { if ( mongoembeddedlibrary != null ) { try { mongoembeddedlibrary . close ( ) ; } catch ( exception e ) { throw new mongoclientembeddedexception ( format ( str_ + str_ + str_ , e . getmessage ( ) ) , e ) ; } mongoembeddedlibrary = null ; } }	Closes down the mongod library.
public static void enablesni ( final string host , final sslparameters sslparameters ) { if ( sni_ssl_helper != null ) { sni_ssl_helper . enablesni ( host , sslparameters ) ; } }	Enable SNI if running on Java 8 or later.
@ suppresswarnings ( str_ ) public static byte gettype ( final object object ) { if ( object == null ) { return null ; } if ( object instanceof integer || object instanceof short || object instanceof byte || object instanceof atomicinteger ) { return number_int ; } if ( object instanceof long || object instanceof atomiclong ) { return number_long ; } if ( object instanceof number ) { return number ; } if ( object instanceof string ) { return string ; } if ( object instanceof java . util . list ) { return array ; } if ( object instanceof byte [ ] ) { return binary ; } if ( object instanceof objectid ) { return oid ; } if ( object instanceof boolean ) { return boolean ; } if ( object instanceof java . util . date ) { return date ; } if ( object instanceof bsontimestamp ) { return timestamp ; } if ( object instanceof java . util . regex . pattern ) { return regex ; } if ( object instanceof dbobject || object instanceof dbref ) { return object ; } if ( object instanceof codewscope ) { return code_w_scope ; } if ( object instanceof code ) { return code ; } return - num_ ; }	Gets the type byte for a given object.
public dbobject todbobject ( ) { basicdbobject cmd = new basicdbobject ( ) ; cmd . put ( str_ , mapreduce ) ; cmd . put ( str_ , map ) ; cmd . put ( str_ , reduce ) ; if ( verbose != null ) { cmd . put ( str_ , verbose ) ; } basicdbobject out = new basicdbobject ( ) ; switch ( outputtype ) { case inline : out . put ( str_ , num_ ) ; break ; case replace : out . put ( str_ , outputcollection ) ; break ; case merge : out . put ( str_ , outputcollection ) ; break ; case reduce : out . put ( str_ , outputcollection ) ; break ; default : throw new illegalargumentexception ( str_ ) ; } if ( outputdb != null ) { out . put ( str_ , outputdb ) ; } cmd . put ( str_ , out ) ; if ( query != null ) { cmd . put ( str_ , query ) ; } if ( finalize != null ) { cmd . put ( str_ , finalize ) ; } if ( sort != null ) { cmd . put ( str_ , sort ) ; } if ( limit > num_ ) { cmd . put ( str_ , limit ) ; } if ( scope != null ) { cmd . put ( str_ , scope ) ; } if ( jsmode != null ) { cmd . put ( str_ , jsmode ) ; } if ( maxtimems != num_ ) { cmd . put ( str_ , maxtimems ) ; } return cmd ; }	Turns this command into a DBObject representation of this map reduce command.
public string getshortdescription ( ) { return str_ + ( hosts . isempty ( ) ? str_ : str_ + hosts ) + ( srvhost == null ? str_ : str_ + srvhost ) + str_ + mode + str_ + requiredclustertype + str_ + serverselectiontimeoutms + str_ + str_ + str_ + maxwaitqueuesize + ( requiredreplicasetname == null ? str_ : str_ + requiredreplicasetname + str_ ) + ( description == null ? str_ : str_ + description + str_ ) + str_ ; }	Returns a short, pretty description for these ClusterSettings.
public static updateresult acknowledged ( final long matchedcount , @ nullable final long modifiedcount , @ nullable final bsonvalue upsertedid ) { return new acknowledgedupdateresult ( matchedcount , modifiedcount , upsertedid ) ; }	Create an acknowledged UpdateResult.
@ deprecated public string getcontenttype ( ) { if ( extraelements != null && extraelements . containskey ( str_ ) ) { return extraelements . getstring ( str_ ) ; } else { throw new mongogridfsexception ( str_ ) ; } }	The content type of the file.
@ deprecated @ suppresswarnings ( str_ ) public list < string > getaliases ( ) { if ( extraelements != null && extraelements . containskey ( str_ ) ) { return ( list < string > ) extraelements . get ( str_ ) ; } else { throw new mongogridfsexception ( str_ ) ; } }	The aliases for the file.
public string getfirstkey ( ) { return findindocument ( new finder < string > ( ) { @ override public string find ( final bsonreader bsonreader ) { return bsonreader . readname ( ) ; } @ override public string notfound ( ) { throw new nosuchelementexception ( ) ; } } ) ; }	Gets the first key in this document, or null if the document is empty.
public < t > void encodewithchildcontext ( final encoder < t > encoder , final bsonwriter writer , final t value ) { encoder . encode ( writer , value , default_context ) ; }	Creates a child context based on this and serializes the value with it to the writer.
public bsondocument asdocument ( ) { bsondocument readconcern = new bsondocument ( ) ; if ( level != null ) { readconcern . put ( str_ , new bsonstring ( level . getvalue ( ) ) ) ; } return readconcern ; }	Gets this read concern as a document.
@ override public void compress ( final list < bytebuf > source , final bsonoutput target ) { int uncompressedsize = getuncompressedsize ( source ) ; byte [ ] singlebytearraysource = new byte [ uncompressedsize ] ; copy ( source , singlebytearraysource ) ; try { byte [ ] out = new byte [ snappy . maxcompressedlength ( uncompressedsize ) ] ; int compressedsize = snappy . compress ( singlebytearraysource , num_ , singlebytearraysource . length , out , num_ ) ; target . writebytes ( out , num_ , compressedsize ) ; } catch ( ioexception e ) { throw new mongointernalexception ( str_ , e ) ; } }	be copied into a single byte array.
public string getstring ( final string key ) { object foo = get ( key ) ; if ( foo == null ) { return null ; } return foo . tostring ( ) ; }	Returns the value of a field as a string.
public boolean getboolean ( final string key , final boolean def ) { object foo = get ( key ) ; if ( foo == null ) { return def ; } if ( foo instanceof number ) { return ( ( number ) foo ) . intvalue ( ) > num_ ; } if ( foo instanceof boolean ) { return ( boolean ) foo ; } throw new illegalargumentexception ( str_ + foo . getclass ( ) ) ; }	Returns the value of a field as a boolean.
public objectid getobjectid ( final string field , final objectid def ) { object foo = get ( field ) ; return ( foo != null ) ? ( objectid ) foo : def ; }	Returns the object id or def if not set.
public date getdate ( final string field , final date def ) { object foo = get ( field ) ; return ( foo != null ) ? ( date ) foo : def ; }	Returns the date or def if not set.
@ suppresswarnings ( str_ ) private static object canonicalize ( final object from ) { if ( from instanceof bsonobject && ! ( from instanceof basicbsonlist ) ) { return canonicalizebsonobject ( ( bsonobject ) from ) ; } else if ( from instanceof list ) { return canonicalizelist ( ( list < object > ) from ) ; } else if ( from instanceof map ) { return canonicalizemap ( ( map < string , object > ) from ) ; } else { return from ; } }	create a copy of "from", but with keys ordered alphabetically.
@ nullable public mongocredential getcredential ( ) { if ( getcredentialslist ( ) . size ( ) > num_ ) { throw new illegalstateexception ( str_ ) ; } else if ( getcredentialslist ( ) . isempty ( ) ) { return null ; } else { return getcredentialslist ( ) . get ( num_ ) ; } }	Gets the credential that this client authenticates all connections with.
public clientsession startsession ( final clientsessionoptions options ) { clientsession clientsession = createclientsession ( notnull ( str_ , options ) ) ; if ( clientsession == null ) { throw new mongoclientexception ( str_ ) ; } return clientsession ; }	Creates a client session.
@ nullable public integer getwtimeout ( final timeunit timeunit ) { notnull ( str_ , timeunit ) ; return wtimeoutms == null ? null : ( int ) timeunit . convert ( wtimeoutms , timeunit . milliseconds ) ; }	Gets the wTimeout in the given time unit.
public bsondocument asdocument ( ) { bsondocument document = new bsondocument ( ) ; addw ( document ) ; addwtimeout ( document ) ; addfsync ( document ) ; addj ( document ) ; return document ; }	Gets this write concern as a document.
public boolean isacknowledged ( ) { if ( w instanceof integer ) { return ( integer ) w > num_ || ( journal != null && journal ) || ( fsync != null && fsync ) ; } return bool_ ; }	Returns true if this write concern indicates that write operations must be acknowledged.
public writeconcern withw ( final int w ) { return new writeconcern ( integer . valueof ( w ) , wtimeoutms , fsync , journal ) ; }	Constructs a new WriteConcern from the current one and the specified integer-based value for w.
public writeconcern withw ( final string w ) { notnull ( str_ , w ) ; return new writeconcern ( w , wtimeoutms , fsync , journal ) ; }	Constructs a new WriteConcern from the current one and the specified tag-set based value for w.
public writeconcern withwtimeout ( final long wtimeout , final timeunit timeunit ) { notnull ( str_ , timeunit ) ; long newwtimeoutms = timeunit . milliseconds . convert ( wtimeout , timeunit ) ; istrueargument ( str_ , wtimeout >= num_ ) ; istrueargument ( str_ + integer . max_value + str_ , newwtimeoutms <= integer . max_value ) ; return new writeconcern ( w , ( int ) newwtimeoutms , fsync , journal ) ; }	Constructs a new WriteConcern from the current one and the specified wTimeout in the given time unit.
@ deprecated public static majority majoritywriteconcern ( final int wtimeout , final boolean fsync , final boolean j ) { return new majority ( wtimeout , fsync , j ) ; }	Create a Majority Write Concern that requires a majority of servers to acknowledge the write.
public void insert ( final dbobject document ) { istrue ( str_ , ! closed ) ; if ( document . get ( id_field_name ) == null ) { document . put ( id_field_name , new objectid ( ) ) ; } addrequest ( new insertrequest ( document , collection . getobjectcodec ( ) ) ) ; }	Add an insert request to the bulk operation.
public bulkwriterequestbuilder find ( final dbobject query ) { istrue ( str_ , ! closed ) ; return new bulkwriterequestbuilder ( this , query , collection . getdefaultdbobjectcodec ( ) , collection . getobjectcodec ( ) ) ; }	Start building a write request to add to the bulk write operation.
public bulkwriteresult execute ( ) { istrue ( str_ , ! closed ) ; closed = bool_ ; return collection . executebulkwriteoperation ( ordered , bypassdocumentvalidation , requests ) ; }	Execute the bulk write operation with the default write concern of the collection from which this came.
public object copy ( ) {	Creates a new instance which is a copy of this BasicDBObject.
public static bson geohaystack ( final string fieldname , final bson additional ) { notnull ( str_ , fieldname ) ; return compoundindex ( new bsondocument ( fieldname , new bsonstring ( str_ ) ) , additional ) ; }	Create an index key for a geohaystack index on the given field.
public list < string > getindexnames ( ) { list < string > indexnames = new arraylist < string > ( requests . size ( ) ) ; for ( indexrequest request : requests ) { if ( request . getname ( ) != null ) { indexnames . add ( request . getname ( ) ) ; } else { indexnames . add ( indexhelper . generateindexname ( request . getkeys ( ) ) ) ; } } return indexnames ; }	Gets the index names.
public bsonvalue get ( final object key , final bsonvalue defaultvalue ) { bsonvalue value = get ( key ) ; return value != null ? value : defaultvalue ; }	If the document does not contain the given key, return the given default value.
public bsondocument getdocument ( final object key , final bsondocument defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asdocument ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonarray getarray ( final object key , final bsonarray defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asarray ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonnumber getnumber ( final object key , final bsonnumber defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asnumber ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonint32 getint32 ( final object key , final bsonint32 defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asint32 ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonint64 getint64 ( final object key , final bsonint64 defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asint64 ( ) ; }	If the document does not contain the given key, return the given default value.
public bsondecimal128 getdecimal128 ( final object key , final bsondecimal128 defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asdecimal128 ( ) ; }	If the document does not contain the given key, return the given default value.
public bsondouble getdouble ( final object key , final bsondouble defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asdouble ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonboolean getboolean ( final object key , final bsonboolean defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asboolean ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonstring getstring ( final object key , final bsonstring defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asstring ( ) ; }	If the document does not contain the given key, return the given default value.
public bsondatetime getdatetime ( final object key , final bsondatetime defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asdatetime ( ) ; }	If the document does not contain the given key, return the given default value.
public bsontimestamp gettimestamp ( final object key , final bsontimestamp defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . astimestamp ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonobjectid getobjectid ( final object key , final bsonobjectid defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asobjectid ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonbinary getbinary ( final object key , final bsonbinary defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asbinary ( ) ; }	If the document does not contain the given key, return the given default value.
public bsonregularexpression getregularexpression ( final object key , final bsonregularexpression defaultvalue ) { if ( ! containskey ( key ) ) { return defaultvalue ; } return get ( key ) . asregularexpression ( ) ; }	If the document does not contain the given key, return the given default value.
private void writehandlingtasks ( final registeredsocket socket , final writeoperation op ) throws ioexception { while ( bool_ ) { try { socket . tlschannel . write ( op . bufferset . array , op . bufferset . offset , op . bufferset . length ) ; return ; } catch ( needstaskexception e ) { warnaboutneedtask ( ) ; e . gettask ( ) . run ( ) ; } } }	Intended use of the channel group is with sockets that run tasks internally, but out of tolerance, run tasks inthread in case the socket does not.
@ suppresswarnings ( { str_ , str_ } ) public static bsondocument asbsondocument ( final object document , final codecregistry codecregistry ) { if ( document == null ) { return null ; } if ( document instanceof bsondocument ) { return ( bsondocument ) document ; } else { return new bsondocumentwrapper ( document , codecregistry . get ( document . getclass ( ) ) ) ; } }	A helper to convert an document of type Object to a BsonDocument If not already a BsonDocument it looks up the documents' class in the codecRegistry and wraps it into a BsonDocumentWrapper .
public static < t > t notnull ( final string name , final t value , final singleresultcallback < ? > callback ) { if ( value == null ) { illegalargumentexception exception = new illegalargumentexception ( name + str_ ) ; callback . onresult ( null , exception ) ; throw exception ; } return value ; }	Throw IllegalArgumentException if the value is null.
public static void istrue ( final string name , final boolean condition , final singleresultcallback < ? > callback ) { if ( ! condition ) { illegalstateexception exception = new illegalstateexception ( str_ + name ) ; callback . onresult ( null , exception ) ; throw exception ; } }	Throw IllegalStateException if the condition if false.
public propertymodelbuilder < ? > getproperty ( final string propertyname ) { notnull ( str_ , propertyname ) ; for ( propertymodelbuilder < ? > propertymodelbuilder : propertymodelbuilders ) { if ( propertymodelbuilder . getname ( ) . equals ( propertyname ) ) { return propertymodelbuilder ; } } return null ; }	Gets a property by the property name.
public classmodel < t > build ( ) { list < propertymodel < ? > > propertymodels = new arraylist < propertymodel < ? > > ( ) ; propertymodel < ? > idpropertymodel = null ; statenotnull ( str_ , type ) ; for ( convention convention : conventions ) { convention . apply ( this ) ; } statenotnull ( str_ , instancecreatorfactory ) ; if ( discriminatorenabled ) { statenotnull ( str_ , discriminatorkey ) ; statenotnull ( str_ , discriminator ) ; } for ( propertymodelbuilder < ? > propertymodelbuilder : propertymodelbuilders ) { boolean isidproperty = propertymodelbuilder . getname ( ) . equals ( idpropertyname ) ; if ( isidproperty ) { propertymodelbuilder . readname ( id_property_name ) . writename ( id_property_name ) ; } propertymodel < ? > model = propertymodelbuilder . build ( ) ; propertymodels . add ( model ) ; if ( isidproperty ) { idpropertymodel = model ; } } validatepropertymodels ( type . getsimplename ( ) , propertymodels ) ; return new classmodel < t > ( type , propertynametotypeparametermap , instancecreatorfactory , discriminatorenabled , discriminatorkey , discriminator , idpropertymodelholder . create ( type , idpropertymodel , idgenerator ) , unmodifiablelist ( propertymodels ) ) ; }	Creates a new ClassModel instance based on the mapping data provided.
@ deprecated public updateoptions getoptions ( ) { return new updateoptions ( ) . bypassdocumentvalidation ( options . getbypassdocumentvalidation ( ) ) . collation ( options . getcollation ( ) ) . upsert ( options . isupsert ( ) ) ; }	Gets the options to apply.
@ nullable public static javawrapper getwrapperifreflectionobject ( final class c ) { if ( reflectiondbobject . class . isassignablefrom ( c ) ) { return getwrapper ( c ) ; } return null ; }	Returns the wrapper if this object can be assigned from this class.
public static javawrapper getwrapper ( final class c ) { javawrapper w = _wrappers . get ( c ) ; if ( w == null ) { w = new javawrapper ( c ) ; _wrappers . put ( c , w ) ; } return w ; }	Returns an existing Wrapper instance associated with a class, or creates a new one.
public uuid asuuid ( ) { if ( ! bsonbinarysubtype . isuuid ( type ) ) { throw new bsoninvalidoperationexception ( str_ ) ; } if ( type != bsonbinarysubtype . uuid_standard . getvalue ( ) ) { throw new bsoninvalidoperationexception ( str_ ) ; } return uuidhelper . decodebinarytouuid ( this . data . clone ( ) , this . type , uuidrepresentation . standard ) ; }	Returns the binary as a UUID.
public uuid asuuid ( final uuidrepresentation uuidrepresentation ) { assertions . notnull ( str_ , uuidrepresentation ) ; final byte uuidtype = uuidrepresentation == uuidrepresentation . standard ? bsonbinarysubtype . uuid_standard . getvalue ( ) : bsonbinarysubtype . uuid_legacy . getvalue ( ) ; if ( type != uuidtype ) { throw new bsoninvalidoperationexception ( str_ ) ; } return uuidhelper . decodebinarytouuid ( data . clone ( ) , type , uuidrepresentation ) ; }	Returns the binary as a UUID.
protected object parse ( final string name ) { object value = null ; char current = get ( ) ; switch ( current ) {	Parse an unknown type.
public void readhex ( ) { if ( pos < s . length ( ) && ( ( s . charat ( pos ) >= str_ && s . charat ( pos ) <= str_ ) || ( s . charat ( pos ) >= str_ && s . charat ( pos ) <= str_ ) || ( s . charat ( pos ) >= str_ && s . charat ( pos ) <= str_ ) ) ) { pos ++ ; } else { throw new jsonparseexception ( s , pos ) ; } }	Read the current character, making sure that it is a hexidecimal character.
public void skipws ( ) { while ( pos < s . length ( ) && character . iswhitespace ( s . charat ( pos ) ) ) { pos ++ ; } }	Advances the position in the string past any whitespace.
public string parsestring ( final boolean needquote ) { char quot = num_ ; if ( check ( str_ ) ) { quot = str_ ; } else if ( check ( str_ ) ) { quot = str_ ; } else if ( needquote ) { throw new jsonparseexception ( s , pos ) ; } char current ; if ( quot > num_ ) { read ( quot ) ; } stringbuilder buf = new stringbuilder ( ) ; int start = pos ; while ( pos < s . length ( ) ) { current = s . charat ( pos ) ; if ( quot > num_ ) { if ( current == quot ) { break ; } } else { if ( current == str_ || current == str_ ) { break ; } } if ( current == str_ ) { pos ++ ; char x = get ( ) ; char special = num_ ;	Parses a string.
public number parsenumber ( ) { get ( ) ; int start = this . pos ; boolean isdouble = bool_ ; if ( check ( str_ ) || check ( str_ ) ) { pos ++ ; } outer : while ( pos < s . length ( ) ) { switch ( s . charat ( pos ) ) { case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : pos ++ ; break ; case str_ : isdouble = bool_ ; parsefraction ( ) ; break ; case str_ : case str_ : isdouble = bool_ ; parseexponent ( ) ; break ; default : break outer ; } } try { if ( isdouble ) { return double . valueof ( s . substring ( start , pos ) ) ; } long val = long . valueof ( s . substring ( start , pos ) ) ; if ( val <= integer . max_value && val >= integer . min_value ) { return val . intvalue ( ) ; } return val ; } catch ( numberformatexception e ) { throw new jsonparseexception ( s , start , e ) ; } }	Parses a number.
public void parseexponent ( ) {	Advances the pointer through the exponent.
protected object parsearray ( final string name ) { if ( name != null ) { _callback . arraystart ( name ) ; } else { _callback . arraystart ( ) ; } read ( str_ ) ; int i = num_ ; char current = get ( ) ; while ( current != str_ ) { string elemname = string . valueof ( i ++ ) ; object elem = parse ( elemname ) ; docallback ( elemname , elem ) ; if ( ( current = get ( ) ) == str_ ) { read ( str_ ) ; } else if ( current == str_ ) { break ; } else { throw new jsonparseexception ( s , pos ) ; } } read ( str_ ) ; return _callback . arraydone ( ) ; }	Parses the next array.
public void updateone ( final dbobject update ) { bulkwriteoperation . addrequest ( new updaterequest ( query , update , bool_ , upsert , querycodec , collation , arrayfilters ) ) ; }	Adds a request to update one document in the collection that matches the query with which this builder was created.
public connectiondescription withconnectionid ( final connectionid connectionid ) { notnull ( str_ , connectionid ) ; return new connectiondescription ( connectionid , serverversion , maxwireversion , servertype , maxbatchcount , maxdocumentsize , maxmessagesize , compressors ) ; }	Creates a new connection description with the set connection id.
public static writeconcernresult acknowledged ( final int count , final boolean isupdateofexisting , @ nullable final bsonvalue upsertedid ) { return new writeconcernresult ( ) { @ override public boolean wasacknowledged ( ) { return bool_ ; } @ override public int getcount ( ) { return count ; } @ override public boolean isupdateofexisting ( ) { return isupdateofexisting ; } @ override @ nullable public bsonvalue getupsertedid ( ) { return upsertedid ; } @ override public boolean equals ( final object o ) { if ( this == o ) { return bool_ ; } if ( o == null || getclass ( ) != o . getclass ( ) ) { return bool_ ; } writeconcernresult that = ( writeconcernresult ) o ; if ( ! that . wasacknowledged ( ) ) { return bool_ ; } if ( count != that . getcount ( ) ) { return bool_ ; } if ( isupdateofexisting != that . isupdateofexisting ( ) ) { return bool_ ; } if ( upsertedid != null ? ! upsertedid . equals ( that . getupsertedid ( ) ) : that . getupsertedid ( ) != null ) { return bool_ ; } return bool_ ; } @ override public int hashcode ( ) { int result = count ; result = num_ * result + ( isupdateofexisting ? num_ : num_ ) ; result = num_ * result + ( upsertedid != null ? upsertedid . hashcode ( ) : num_ ) ; return result ; } @ override public string tostring ( ) { return str_ + str_ + count + str_ + isupdateofexisting + str_ + upsertedid + str_ ; } } ; }	Create an acknowledged WriteConcernResult.
public static writeconcernresult unacknowledged ( ) { return new writeconcernresult ( ) { @ override public boolean wasacknowledged ( ) { return bool_ ; } @ override public int getcount ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override public boolean isupdateofexisting ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override public bsonvalue getupsertedid ( ) { throw getunacknowledgedwriteexception ( ) ; } @ override public boolean equals ( final object o ) { if ( this == o ) { return bool_ ; } if ( o == null || getclass ( ) != o . getclass ( ) ) { return bool_ ; } writeconcernresult that = ( writeconcernresult ) o ; return ! that . wasacknowledged ( ) ; } @ override public int hashcode ( ) { return num_ ; } @ override public string tostring ( ) { return str_ ; } private unsupportedoperationexception getunacknowledgedwriteexception ( ) { return new unsupportedoperationexception ( str_ ) ; } } ; }	Create an unacknowledged WriteConcernResult.
@ suppresswarnings ( str_ ) private < t > t getembeddedvalue ( final list < ? > keys , final class < t > clazz , final t defaultvalue ) { object value = this ; iterator < ? > keyiterator = keys . iterator ( ) ; while ( keyiterator . hasnext ( ) ) { object key = keyiterator . next ( ) ; value = ( ( document ) value ) . get ( key ) ; if ( ! ( value instanceof document ) ) { if ( value == null ) { return defaultvalue ; } else if ( keyiterator . hasnext ( ) ) { throw new classcastexception ( format ( str_ , key , value . getclass ( ) . getname ( ) ) ) ; } } } return clazz != null ? clazz . cast ( value ) : ( t ) value ; }	Throws ClassCastException if any of the intermediate embedded values is not a Document.
@ suppresswarnings ( str_ ) private < t > list < t > constructvalueslist ( final object key , final class < t > clazz , final list < t > defaultvalue ) { list < ? > value = get ( key , list . class ) ; if ( value == null ) { return defaultvalue ; } for ( object item : value ) { if ( ! clazz . isassignablefrom ( item . getclass ( ) ) ) { throw new classcastexception ( format ( str_ , clazz . getname ( ) ) ) ; } } return ( list < t > ) value ; }	A ClassCastException will be thrown if an element in the list is not of type T.
public static transactionoptions merge ( final transactionoptions options , final transactionoptions defaultoptions ) { notnull ( str_ , options ) ; notnull ( str_ , defaultoptions ) ; return transactionoptions . builder ( ) . writeconcern ( options . getwriteconcern ( ) == null ? defaultoptions . getwriteconcern ( ) : options . getwriteconcern ( ) ) . readconcern ( options . getreadconcern ( ) == null ? defaultoptions . getreadconcern ( ) : options . getreadconcern ( ) ) . readpreference ( options . getreadpreference ( ) == null ? defaultoptions . getreadpreference ( ) : options . getreadpreference ( ) ) . build ( ) ; }	Merge the two provided transaction options, with the first taking precedence over the second.
@ override public void release ( final t t , final boolean prune ) { if ( t == null ) { throw new illegalargumentexception ( str_ ) ; } if ( closed ) { close ( t ) ; return ; } if ( prune ) { close ( t ) ; } else { available . addlast ( t ) ; } releasepermit ( ) ; }	call done when you are done with an object from the pool if there is room and the object is ok will get added.
@ override public t get ( final long timeout , final timeunit timeunit ) { if ( closed ) { throw new illegalstateexception ( str_ ) ; } if ( ! acquirepermit ( timeout , timeunit ) ) { throw new mongotimeoutexception ( string . format ( str_ , timeout , timeunit ) ) ; } t t = available . polllast ( ) ; if ( t == null ) { t = createnewandreleasepermitiffailure ( bool_ ) ; } return t ; }	Gets an object from the pool - will block if none are available.
@ override public void close ( ) { closed = bool_ ; iterator < t > iter = available . iterator ( ) ; while ( iter . hasnext ( ) ) { t t = iter . next ( ) ; close ( t ) ; iter . remove ( ) ; } }	Clears the pool of all objects.
public int pipe ( final outputstream os ) throws ioexception { writablebytechannel channel = channels . newchannel ( os ) ; return channel . write ( getbufferforinternalbytes ( ) ) ; }	Pipe the raw bytes into the given output stream.
protected void throwinvalidcontexttype ( final string methodname , final bsoncontexttype actualcontexttype , final bsoncontexttype ... validcontexttypes ) { string validcontexttypesstring = stringutils . join ( str_ , aslist ( validcontexttypes ) ) ; string message = format ( str_ , methodname , validcontexttypesstring , actualcontexttype ) ; throw new bsoninvalidoperationexception ( message ) ; }	Throws an InvalidOperationException when the method called is not valid for the current ContextType.
protected void throwinvalidstate ( final string methodname , final state ... validstates ) { string validstatesstring = stringutils . join ( str_ , aslist ( validstates ) ) ; string message = format ( str_ , methodname , validstatesstring , state ) ; throw new bsoninvalidoperationexception ( message ) ; }	Throws an InvalidOperationException when the method called is not valid for the current state.
protected void verifybsontype ( final string methodname , final bsontype requiredbsontype ) { if ( state == state . initial || state == state . scope_document || state == state . type ) { readbsontype ( ) ; } if ( state == state . name ) {	Verifies the current state and BSONType of the reader.
protected void verifyname ( final string expectedname ) { readbsontype ( ) ; string actualname = readname ( ) ; if ( ! actualname . equals ( expectedname ) ) { throw new bsonserializationexception ( format ( str_ , expectedname , actualname ) ) ; } }	Verifies the name of the current element.
protected void checkpreconditions ( final string methodname , final bsontype type ) { if ( isclosed ( ) ) { throw new illegalstateexception ( str_ ) ; } verifybsontype ( methodname , type ) ; }	Ensures any conditions are met before reading commences.
public static decimal128 parse ( final string value ) { string lowercasedvalue = value . tolowercase ( ) ; if ( nan_strings . contains ( lowercasedvalue ) ) { return nan ; } if ( negative_nan_strings . contains ( lowercasedvalue ) ) { return negative_nan ; } if ( positive_infinity_strings . contains ( lowercasedvalue ) ) { return positive_infinity ; } if ( negative_infinity_strings . contains ( lowercasedvalue ) ) { return negative_infinity ; } return new decimal128 ( new bigdecimal ( value ) , value . charat ( num_ ) == str_ ) ; }	Returns a Decimal128 value representing the given String.
public bigdecimal bigdecimalvalue ( ) { if ( isnan ( ) ) { throw new arithmeticexception ( str_ ) ; } if ( isinfinite ( ) ) { throw new arithmeticexception ( str_ ) ; } bigdecimal bigdecimal = bigdecimalvaluenonegativezerocheck ( ) ;	Gets a BigDecimal that is equivalent to this Decimal128.
private byte [ ] getbytes ( ) { byte [ ] bytes = new byte [ num_ ] ; long mask = num_ ; for ( int i = num_ ; i >= num_ ; i -- ) { bytes [ i ] = ( byte ) ( ( low & mask ) > > > ( ( num_ - i ) << num_ ) ) ; mask = mask << num_ ; } mask = num_ ; for ( int i = num_ ; i >= num_ ; i -- ) { bytes [ i ] = ( byte ) ( ( high & mask ) > > > ( ( num_ - i ) << num_ ) ) ; mask = mask << num_ ; } mask = num_ ; bytes [ num_ ] = ( byte ) ( ( high & mask ) > > > num_ ) ; return bytes ; }	May have leading zeros. Strip them before considering making this method public.
public aggregateexplainoperation hint ( final bsonvalue hint ) { istrueargument ( str_ , hint == null || hint . isdocument ( ) || hint . isstring ( ) ) ; this . hint = hint ; return this ; }	Sets the hint for which index to use.
public bsondocument asdocument ( ) { bsondocument collation = new bsondocument ( ) ; if ( locale != null ) { collation . put ( str_ , new bsonstring ( locale ) ) ; } if ( caselevel != null ) { collation . put ( str_ , new bsonboolean ( caselevel ) ) ; } if ( casefirst != null ) { collation . put ( str_ , new bsonstring ( casefirst . getvalue ( ) ) ) ; } if ( strength != null ) { collation . put ( str_ , new bsonint32 ( strength . getintrepresentation ( ) ) ) ; } if ( numericordering != null ) { collation . put ( str_ , new bsonboolean ( numericordering ) ) ; } if ( alternate != null ) { collation . put ( str_ , new bsonstring ( alternate . getvalue ( ) ) ) ; } if ( maxvariable != null ) { collation . put ( str_ , new bsonstring ( maxvariable . getvalue ( ) ) ) ; } if ( normalization != null ) { collation . put ( str_ , new bsonboolean ( normalization ) ) ; } if ( backwards != null ) { collation . put ( str_ , new bsonboolean ( backwards ) ) ; } return collation ; }	Gets this collation options as a document.
public long writeto ( final file file ) throws ioexception { fileoutputstream out = null ; try { out = new fileoutputstream ( file ) ; return writeto ( out ) ; } finally { if ( out != null ) { out . close ( ) ; } } }	Writes the file's data to a file on disk.
public long writeto ( final outputstream out ) throws ioexception { int nc = numchunks ( ) ; for ( int i = num_ ; i < nc ; i ++ ) { out . write ( getchunk ( i ) ) ; } return length ; }	Writes the file's data to an OutputStream.
void remove ( ) { fs . getfilescollection ( ) . remove ( new basicdbobject ( str_ , id ) ) ; fs . getchunkscollection ( ) . remove ( new basicdbobject ( str_ , id ) ) ; }	Removes file from GridFS i.e.
public pushoptions sort ( @ nullable final integer sort ) { if ( sortdocument != null ) { throw new illegalstateexception ( str_ ) ; } this . sort = sort ; return this ; }	Sets the sort direction for sorting array elements that are not documents.
public pushoptions sortdocument ( @ nullable final bson sortdocument ) { if ( sort != null ) { throw new illegalstateexception ( str_ ) ; } this . sortdocument = sortdocument ; return this ; }	Sets the sort direction for sorting array elements that are documents.
@ bsonignore @ nullable public mongonamespace getnamespace ( ) { if ( namespacedocument == null ) { return null ; } if ( ! namespacedocument . containskey ( str_ ) || ! namespacedocument . containskey ( str_ ) ) { return null ; } return new mongonamespace ( namespacedocument . getstring ( str_ ) . getvalue ( ) , namespacedocument . getstring ( str_ ) . getvalue ( ) ) ; }	Returns the namespaceThe invalidate operation type does include a MongoNamespace in the ChangeStreamDocument response.
@ bsonignore @ nullable public string getdatabasename ( ) { if ( namespacedocument == null ) { return null ; } if ( ! namespacedocument . containskey ( str_ ) ) { return null ; } return namespacedocument . getstring ( str_ ) . getvalue ( ) ; }	Returns the database name.
public static < tfulldocument > codec < changestreamdocument < tfulldocument > > createcodec ( final class < tfulldocument > fulldocumentclass , final codecregistry codecregistry ) { return new changestreamdocumentcodec < tfulldocument > ( fulldocumentclass , codecregistry ) ; }	Creates the codec for the specific ChangeStreamOutput type.
public static builder builder ( final clientsessionoptions options ) { notnull ( str_ , options ) ; builder builder = new builder ( ) ; builder . causallyconsistent = options . iscausallyconsistent ( ) ; builder . defaulttransactionoptions = options . getdefaulttransactionoptions ( ) ; return builder ; }	Gets an instance of a builder initialized with the given options.
public void reset ( ) { connectionsperhost = num_ ; threadsallowedtoblockforconnectionmultiplier = num_ ; maxwaittime = num_ * num_ * num_ ; connecttimeout = num_ * num_ ; socketfactory = socketfactory . getdefault ( ) ; sockettimeout = num_ ; socketkeepalive = bool_ ; readpreference = null ; writeconcern = null ; safe = bool_ ; w = num_ ; wtimeout = num_ ; fsync = bool_ ; j = bool_ ; dbdecoderfactory = defaultdbdecoder . factory ; dbencoderfactory = defaultdbencoder . factory ; description = null ; cursorfinalizerenabled = bool_ ; alwaysusembeans = bool_ ; requiredreplicasetname = null ; }	Reset all settings to the default.
public mongooptions copy ( ) { mongooptions m = new mongooptions ( ) ; m . connectionsperhost = connectionsperhost ; m . threadsallowedtoblockforconnectionmultiplier = threadsallowedtoblockforconnectionmultiplier ; m . maxwaittime = maxwaittime ; m . connecttimeout = connecttimeout ; m . socketfactory = socketfactory ; m . sockettimeout = sockettimeout ; m . socketkeepalive = socketkeepalive ; m . readpreference = readpreference ; m . writeconcern = writeconcern ; m . safe = safe ; m . w = w ; m . wtimeout = wtimeout ; m . fsync = fsync ; m . j = j ; m . dbdecoderfactory = dbdecoderfactory ; m . dbencoderfactory = dbencoderfactory ; m . description = description ; m . cursorfinalizerenabled = cursorfinalizerenabled ; m . alwaysusembeans = alwaysusembeans ; m . requiredreplicasetname = requiredreplicasetname ; return m ; }	Copy this MongoOptions instance into a new instance.
@ suppresswarnings ( str_ ) public writeconcern getwriteconcern ( ) { writeconcern retval ; if ( writeconcern != null ) { retval = writeconcern ; } else if ( w != num_ || wtimeout != num_ || fsync | j ) { retval = writeconcern . acknowledged ; if ( w != num_ ) { retval = retval . withw ( w ) ; } if ( wtimeout != num_ ) { retval = retval . withwtimeout ( wtimeout , timeunit . milliseconds ) ; } if ( fsync ) { retval = retval . withfsync ( fsync ) ; } if ( j ) { retval = retval . withj ( j ) ; } } else if ( safe ) { retval = writeconcern . acknowledged ; } else { retval = writeconcern . unacknowledged ; } return retval ; }	Helper method to return the appropriate WriteConcern instance based on the current related options settings.
public static string getuseragent ( string servicename , boolean allowtelemetry ) { string macaddress = str_ ; if ( allowtelemetry ) { macaddress = gethashmac . gethashmac ( ) ; } return string . format ( servicename + str_ , macaddress ) ; }	Generate UserAgent string for given service.
@ suppressfbwarnings ( str_ ) private void populateproperties ( configurableenvironment environment , vcappojo [ ] pojos ) { final map < string , object > map = new hashmap < > ( ) ; populatedefaultstorageproperties ( map , findpojoforservicetype ( vcapservicetype . azure_storage , pojos ) ) ; populatedefaultservicebusproperties ( map , findpojoforservicetype ( vcapservicetype . azure_servicebus , pojos ) ) ; populatedefaultdocumentdbproperties ( map , findpojoforservicetype ( vcapservicetype . azure_documentdb , pojos ) ) ; addorreplace ( environment . getpropertysources ( ) , map ) ; }	Populates default properties during .
private boolean ismatchingusergroupkey ( final jsonnode node ) { return node . get ( aadauthenticationproperties . getusergroup ( ) . getkey ( ) ) . astext ( ) . equals ( aadauthenticationproperties . getusergroup ( ) . getvalue ( ) ) ; }	Checks that the JSON Node is a valid User Group to extract User Groups from.
public set < grantedauthority > convertgroupstograntedauthorities ( final list < usergroup > groups ) {	Converts UserGroup list to Set of GrantedAutorities.
public serviceendpoints getserviceendpoints ( string environment ) { assert . notempty ( endpoints , str_ ) ; if ( ! endpoints . containskey ( environment ) ) { throw new illegalargumentexception ( environment + str_ + str_ + endpoints . keyset ( ) ) ; } return endpoints . get ( environment ) ; }	Get ServiceEndpoints data for the given environment.
@ bean @ scope ( beandefinition . scope_singleton ) @ conditionalonmissingbean ( aadauthenticationfilter . class ) public aadauthenticationfilter azureadjwttokenfilter ( ) { log . info ( str_ ) ; return new aadauthenticationfilter ( aadauthprops , serviceendpointsprops , getjwtresourceretriever ( ) ) ; }	Declare AADAuthenticationFilter bean.
public livereload register ( final path path , final string ... includes ) { if ( files . exists ( path ) ) { paths . add ( new object [ ] { path , arrays . aslist ( includes ) } ) ; } return this ; }	Add the given path to the watcher.
public map < string , list < file > > build ( final string dist , final file dir ) throws exception { log . debug ( str_ , dist , aggregators ) ; aggregators ( aggregators , conf ) ; return buildinternal ( dist , dir ) ; }	Build assets using the given distribution and write output to the provided directory.Build process is defined as follow:1.
private void register ( final path dir ) throws ioexception { watchkey key = dir . register ( watcher , new kind [ ] { entry_create , entry_delete , entry_modify } , high ) ; keys . put ( key , dir ) ; }	Register the given directory with the WatchService.
public ramltype newproperty ( string name , string type , boolean required , string ... values ) { if ( properties == null ) { properties = new linkedhashmap < > ( ) ; } if ( values . length > num_ ) { properties . put ( required ? name : name + str_ , immutablemap . of ( str_ , values ) ) ; } else { properties . put ( required ? name : name + str_ , type ) ; } return this ; }	Defines a new property.
public static ramltype valueof ( string name ) { switch ( name . tolowercase ( ) ) { case str_ : return boolean ; case str_ : case str_ : case str_ : case str_ : case str_ : return integer ; case str_ : case str_ : return number ; case str_ : case str_ : case str_ : return string ; case str_ : case str_ : case str_ : case str_ : return file ; case str_ : case str_ : case str_ : return date_time ; } return new ramltype ( str_ , name ) ; }	Get a RAML type from string.
public fileeventoptions kind ( final watchevent . kind < path > kind ) { requirenonnull ( kind , str_ ) ; kinds . add ( kind ) ; return this ; }	Append a kind filter.The default filter is: {.
public hbs dowith ( final consumer < handlebars > callback ) { requirenonnull ( callback , str_ ) ; return dowith ( ( hbs , conf ) -> callback . accept ( hbs ) ) ; }	Set a handlebars callback. {.
public micrometer dowith ( @ nonnull final consumer < compositemeterregistry > configurer ) { return dowith ( ( registry , conf ) -> configurer . accept ( registry ) ) ; }	Advanced configuration of main registry.
public thl dowith ( final consumer < templateengine > callback ) { requirenonnull ( callback , str_ ) ; return dowith ( ( e , c ) -> callback . accept ( e ) ) ; }	Set a configuration callback. {.
public auth form ( final string pattern , final class < ? extends authenticator < usernamepasswordcredentials > > authenticator ) { bindings . put ( pattern , ( binder , conf ) -> { typeliteral < authenticator < usernamepasswordcredentials > > usernamepasswordauthenticator = new typeliteral < authenticator < usernamepasswordcredentials > > ( ) { } ; binder . bind ( usernamepasswordauthenticator . getrawtype ( ) ) . to ( authenticator ) ; bindprofile ( binder , commonprofile . class ) ; multibinder . newsetbinder ( binder , client . class ) . addbinding ( ) . toprovider ( formauth . class ) ; return new formfilter ( conf . getstring ( str_ ) , conf . getstring ( str_ ) + authcallbackpath ( conf ) ) ; } ) ; return this ; }	Add a form auth client.
public auth basic ( final string pattern , final class < ? extends authenticator < usernamepasswordcredentials > > authenticator ) { bindings . put ( pattern , ( binder , config ) -> { typeliteral < authenticator < usernamepasswordcredentials > > usernamepasswordauthenticator = new typeliteral < authenticator < usernamepasswordcredentials > > ( ) { } ; binder . bind ( usernamepasswordauthenticator . getrawtype ( ) ) . to ( authenticator ) ; bindprofile ( binder , commonprofile . class ) ; multibinder . newsetbinder ( binder , client . class ) . addbinding ( ) . toprovider ( basicauth . class ) ; return new authfilter ( indirectbasicauthclient . class , commonprofile . class ) ; } ) ; return this ; }	Add a basic auth client.
public void resolve ( @ nullable final object value ) { if ( value == null ) { handler . handle ( null , null ) ; } else { result result ; if ( value instanceof result ) { super . set ( value ) ; result = ( result ) value ; } else { super . set ( value ) ; result = clone ( ) ; } handler . handle ( result , null ) ; } }	Resolve the deferred value and handle it.
public ramlpath path ( string pattern ) { ramlpath path = resources . get ( pattern ) ; if ( path == null ) { path = new ramlpath ( ) ; resources . put ( pattern , path ) ; } return path ; }	Get a path for the given pattern.
public ramltype define ( type type ) { if ( types == null ) { types = new linkedhashmap < > ( ) ; } type componenttype = componenttype ( type ) ; string typename = moretypes . getrawtype ( componenttype ) . getsimplename ( ) ; ramltype ramltype = ramltype . valueof ( typename ) ; if ( ramltype . isobject ( ) ) { ramltype existing = types . get ( typename ) ; if ( existing == null ) { modelconverters converter = modelconverters . getinstance ( ) ; property property = converter . readasproperty ( componenttype ) ; map < propertybuilder . propertyid , object > args = new enummap < > ( propertybuilder . propertyid . class ) ; for ( map . entry < string , model > entry : converter . readall ( componenttype ) . entryset ( ) ) { define ( entry . getkey ( ) , entry . getvalue ( ) ) ; } ramltype = define ( typename , propertybuilder . tomodel ( propertybuilder . merge ( property , args ) ) ) ; } else { ramltype = existing ; } } return type != componenttype ? ramltype . toarray ( ) : ramltype ; }	Register a Java type and produces an equivalent RAML type.
public string toyaml ( ) throws ioexception { yamlmapper mapper = new yamlmapper ( ) ; mapper . setserializationinclusion ( jsoninclude . include . non_null ) ; mapper . configure ( yamlgenerator . feature . always_quote_numbers_as_strings , bool_ ) ; mapper . configure ( yamlgenerator . feature . minimize_quotes , bool_ ) ; return str_ + mapper . writer ( ) . withdefaultprettyprinter ( ) . writevalueasstring ( this ) ; }	Convert this RAML object to Yaml.
public map < integer , string > status ( ) { return optional . ofnullable ( status ) . orelse ( immutablemap . of ( ) ) ; }	Get status codes.
public int statuscode ( ) { return status ( ) . entryset ( ) . stream ( ) . map ( it -> it . getkey ( ) ) . filter ( code -> code >= num_ && code < num_ ) . findfirst ( ) . orelseget ( ( ) -> type ( ) == void . class ? num_ : num_ ) ; }	Status code.
public routeresponse status ( final map < integer , string > status ) { if ( status != null ) { if ( this . status == null ) { this . status = new linkedhashmap < > ( ) ; this . status . putall ( status ) ; } } return this ; }	Set status code map.
public void setmediatype ( final string mediatype , ramltype body ) { if ( this . mediatype == null ) { this . mediatype = new linkedhashmap < > ( ) ; } this . mediatype . put ( mediatype , body ) ; }	Set media type.
static throwing . runnable runenhancer ( ) { return ( ) -> { set < string > packages = pkg . getandset ( null ) ; if ( packages != null ) { ebeanenhancer . newenhancer ( ) . run ( packages ) ; } } ; }	package for test.
public void setmediatype ( final list < string > mediatype ) { this . mediatype = mediatype == null ? null : ( mediatype . isempty ( ) ? null : mediatype ) ; }	Set media types.
public ramlparameter queryparameter ( string name ) { if ( queryparameters == null ) { queryparameters = new linkedhashmap < > ( ) ; } ramlparameter param = queryparameters . get ( name ) ; if ( param == null ) { param = new ramlparameter ( name ) ; queryparameters . put ( name , param ) ; } return param ; }	Get or create a query parameter using the giving name.
public ramlparameter formparameter ( string name ) { if ( formparameters == null ) { formparameters = new linkedhashmap < > ( ) ; } ramlparameter param = formparameters . get ( name ) ; if ( param == null ) { param = new ramlparameter ( name ) ; formparameters . put ( name , param ) ; } return param ; }	Get or create a form parameter using the giving name.
public ramlparameter headerparameter ( string name ) { if ( headers == null ) { headers = new linkedhashmap < > ( ) ; } ramlparameter param = headers . get ( name ) ; if ( param == null ) { param = new ramlparameter ( name ) ; headers . put ( name , param ) ; } return param ; }	Get or create a header parameter using the giving name.
public ramlresponse response ( integer status ) { if ( responses == null ) { responses = new linkedhashmap < > ( ) ; } ramlresponse response = responses . get ( status ) ; if ( response == null ) { response = new ramlresponse ( ) ; responses . put ( status , response ) ; } return response ; }	Get or create a response using the given status code.
public hbv dowith ( final consumer < hibernatevalidatorconfiguration > configurer ) { requirenonnull ( configurer , str_ ) ; this . configurer = ( hvc , conf ) -> configurer . accept ( hvc ) ; return this ; }	Setup a configurer callback.
@ override public int read ( final byte [ ] b , int off , int len ) throws ioexception { int read = num_ ; while ( len > num_ ) { if ( encoderout . position ( ) > num_ ) { encoderout . flip ( ) ; int c = math . min ( encoderout . remaining ( ) , len ) ; encoderout . get ( b , off , c ) ; off += c ; len -= c ; read += c ; encoderout . compact ( ) ; } else { if ( ! endofinput && ( lastcoderresult == null || lastcoderresult . isunderflow ( ) ) ) { encoderin . compact ( ) ; int position = encoderin . position ( ) ;	Read the specified number of bytes into an array.
public static requery reactive ( final string name , final entitymodel model ) { return new requery ( name , reactiveentitystore . class , model , conf -> reactivesupport . toreactivestore ( new entitydatastore < > ( conf ) ) ) ; }	Creates a Requery module with RxJava data store. {.
public static requery reactor ( final string name , final entitymodel model ) { return new requery ( name , reactorentitystore . class , model , conf -> new reactorentitystore < > ( new entitydatastore < > ( conf ) ) ) ; }	Creates a Requery module with Reactor data store. {.
public static requery completionstage ( final string name , final entitymodel model ) { return new requery ( name , completionstageentitystore . class , model , conf -> new completableentitystore ( new entitydatastore < > ( conf ) ) ) ; }	Creates an async Requery module with Java 8 data store. {.
public static requery kotlin ( final string name , final entitymodel model ) { return new requery ( name , kotlinentitydatastore . class , model , conf -> new kotlinentitydatastore < > ( conf ) ) ; }	Creates a Kotlin Requery module. {.
public xss js ( final javascriptescapetype type , final javascriptescapelevel level ) { this . jslevel = requirenonnull ( level , str_ ) ; this . jstype = requirenonnull ( type , str_ ) ; return this ; }	Set JavaScript escape type and level.
public xss html ( final htmlescapetype type , final htmlescapelevel level ) { this . htmllevel = requirenonnull ( level , str_ ) ; this . htmltype = requirenonnull ( type , str_ ) ; return this ; }	Set HTML escape type and level.
public xss json ( final jsonescapetype type , final jsonescapelevel level ) { this . jsonlevel = requirenonnull ( level , str_ ) ; this . jsontype = requirenonnull ( type , str_ ) ; return this ; }	Set JSON escape type and level.
public xss css ( final cssstringescapetype type , final cssstringescapelevel level ) { this . csslevel = requirenonnull ( level , str_ ) ; this . csstype = requirenonnull ( type , str_ ) ; return this ; }	Set CSS escape type and level.
private map < string , object > attrs ( final string path , final string ... without ) { map < string , object > attrs = new linkedhashmap < > ( get ( path ) ) ; arrays . aslist ( without ) . foreach ( attrs :: remove ) ; return attrs ; }	Read an object path and optionally filter some child paths.
private charsequence css ( final string id , final element svg ) { throwing . function < string , tuple < tuple < number , string > , tuple < number , string > > > viewbox = throwing . < string , tuple < tuple < number , string > , tuple < number , string > > > throwingfunction ( name -> { string vbox = svg . attr ( name ) ; string [ ] dimension = vbox . split ( str_ ) ; return new tuple ( parse ( dimension [ num_ ] ) , parse ( dimension [ _3 ] ) ) ; } ) . memoized ( ) ; tuple < number , string > w = optional . ofnullable ( strings . emptytonull ( svg . attr ( str_ ) ) ) . map ( this :: parse ) . orelseget ( ( ) -> viewbox . apply ( str_ ) . _1 ) ; tuple < number , string > h = optional . ofnullable ( strings . emptytonull ( svg . attr ( str_ ) ) ) . map ( this :: parse ) . orelseget ( ( ) -> viewbox . apply ( str_ ) . _2 ) ; stringbuilder css = new stringbuilder ( ) ; css . append ( get ( str_ ) . tostring ( ) ) . append ( str_ ) . append ( id ) . append ( str_ ) . append ( w . _1 ) . append ( w . _2 ) . append ( str_ ) . append ( str_ ) . append ( h . _1 ) . append ( h . _2 ) . append ( str_ ) ; return css ; }	Generate a CSS rule, it reads the width and height attributes of the svg element or fallback toviewBox attribute.
private tuple < number , string > parse ( final string value ) { matcher matcher = size . matcher ( value ) ; if ( matcher . find ( ) ) { string number = matcher . group ( num_ ) ; string unit = matcher . group ( _3 ) ; boolean round = get ( str_ ) ; number num = double . parsedouble ( number ) ; return new tuple ( round ? math . round ( num . doublevalue ( ) ) : num , unit ) ; } return null ; }	Parse a css size unit value, like 10px or 18.919px and optionally round the value to theclosest integer.
private void write ( final path path , final list < charsequence > sequence ) throws ioexception { log . debug ( str_ , path . normalize ( ) . toabsolutepath ( ) ) ; path . tofile ( ) . getparentfile ( ) . mkdirs ( ) ; files . write ( path , sequence ) ; }	Write content to file.
public transactionalrequest handle ( string name ) { this . handlekey = key . get ( handle . class , names . named ( name ) ) ; return this ; }	Use a named key for accessing to the request scoped Handle.
private model domodel ( type type , model model ) { map < string , property > properties = model . getproperties ( ) ; if ( properties != null ) { beandescription desc = json . mapper ( ) . getserializationconfig ( ) . introspect ( json . mapper ( ) . constructtype ( type ) ) ; for ( beanpropertydefinition beanproperty : desc . findproperties ( ) ) { property property = properties . get ( beanproperty . getname ( ) ) ; if ( property != null ) { property . setrequired ( beanproperty . isrequired ( ) ) ; } } } return model ; }	Mostly for kotlin null safe operator and immutable properties.
@ nonnull public < t > optional < t > lasteventid ( final class < t > type ) { return lasteventid . tooptional ( type ) ; }	Server sent event will send a Last-Event-ID header if the server goes down.
@ nonnull public completablefuture < optional < object > > send ( final object data ) { return event ( data ) . send ( ) ; }	Send an event. {.
@ nonnull public view put ( final string name , final object value ) { requirenonnull ( name , str_ ) ; model . put ( name , value ) ; return this ; }	Set a model attribute and override existing attribute.
@ nonnull public view put ( final map < string , ? > values ) { values . foreach ( ( k , v ) -> model . put ( k , v ) ) ; return this ; }	Set model attributes and override existing values.
public static classloader classloader ( final classloader parent ) throws ioexception { return classloader ( parent , new file ( system . getproperty ( str_ ) ) ) ; }	Constructs a new AssetClassLoader that includes the 'public' dir if present in the current working dir.
public static classloader classloader ( final classloader parent , file projectdir ) throws ioexception { requirenonnull ( parent , str_ ) ; file publicdir = new file ( projectdir , str_ ) ; if ( publicdir . exists ( ) ) { return new urlclassloader ( new url [ ] { publicdir . touri ( ) . tourl ( ) } , parent ) ; } return parent ; }	Constructs a new AssetClassLoader that includes the 'public' dir if present in the provided working dir.
public routemethod attributes ( map < string , object > attributes ) { if ( attributes != null ) { if ( this . attributes == null ) { this . attributes = new linkedhashmap < > ( ) ; } this . attributes . putall ( attributes ) ; } return this ; }	Set route attributes.
public routemethod attribute ( string name , object value ) { if ( this . attributes == null ) { this . attributes = new linkedhashmap < > ( ) ; } this . attributes . put ( name , value ) ; return this ; }	Set route attribute.
public routemethod param ( string name , consumer < routeparameter > customizer ) { parameters ( ) . stream ( ) . filter ( p -> name . equals ( p . name ( ) ) ) . findfirst ( ) . ifpresent ( customizer ) ; return this ; }	Find a parameter by name and invoke the given callback.
public static status valueof ( final int statuscode ) { integer key = integer . valueof ( statuscode ) ; status status = statusmap . get ( key ) ; return status == null ? new status ( key , key . tostring ( ) ) : status ; }	Return the enum constant of this type with the specified numeric value.
public jdbi3 dowith ( consumer < jdbi > configurer ) { return dowith ( ( jdbi , conf ) -> configurer . accept ( jdbi ) ) ; }	Configurer a jdbi instance.
@ override public rewrittenstatement rewrite ( final string sql , final binding params , final statementcontext ctx ) { final parsedstatement stmt = new parsedstatement ( ) ; try { final string parsedsql = parsestring ( sql , stmt , params ) ; return new myrewrittenstatement ( parsedsql , stmt , ctx ) ; } catch ( illegalargumentexception e ) { throw new unabletocreatestatementexception ( str_ , e , ctx ) ; } }	Munge up the SQL as desired.
protected void send ( final request req , final response rsp , final asset asset ) throws throwable { rsp . send ( asset ) ; }	Send an asset to the client.
public jdbi dowith ( consumer < dbi > configurer ) { return dowith ( ( dbi , conf ) -> configurer . accept ( dbi ) ) ; }	Configure DBI instance.
public jooq dowith ( consumer < configuration > configurer ) { return dowith ( ( configuration , conf ) -> configurer . accept ( configuration ) ) ; }	Configuration callback.
public quartz with ( final jobdetail job , final trigger trigger ) { requirenonnull ( job , str_ ) ; requirenonnull ( trigger , str_ ) ; jobmap . put ( job , trigger ) ; return this ; }	Schedule the provided job and trigger.
public quartz with ( final class < ? extends job > jobclass , final biconsumer < jobbuilder , triggerbuilder < trigger > > configurer ) { requirenonnull ( jobclass , str_ ) ; jobbuilder job = jobbuilder . newjob ( jobclass ) . withidentity ( jobkey . jobkey ( jobclass . getsimplename ( ) , jobclass . getpackage ( ) . getname ( ) ) ) ; triggerbuilder < trigger > trigger = triggerbuilder . newtrigger ( ) . withidentity ( triggerkey . triggerkey ( jobclass . getsimplename ( ) , jobclass . getpackage ( ) . getname ( ) ) ) ; configurer . accept ( job , trigger ) ; return with ( job . build ( ) , trigger . build ( ) ) ; }	Schedule the provided job and trigger.
private void shutdowngracefully ( final iterator < eventexecutorgroup > iterator ) { if ( iterator . hasnext ( ) ) { eventexecutorgroup group = iterator . next ( ) ; if ( ! group . isshuttingdown ( ) ) { group . shutdowngracefully ( ) . addlistener ( future -> { if ( ! future . issuccess ( ) ) { log . debug ( str_ , group , future . cause ( ) ) ; } shutdowngracefully ( iterator ) ; } ) ; } } }	Shutdown executor in order.
public cassandra dowithcluster ( final consumer < cluster > configurer ) { requirenonnull ( configurer , str_ ) ; return dowithcluster ( ( cc , c ) -> configurer . accept ( cc ) ) ; }	Configure a cluster after creation.
@ nonnull public static result with ( final status status ) { requirenonnull ( status , str_ ) ; return new result ( ) . status ( status ) ; }	Set the response status.
public jackson module ( final module module ) { requirenonnull ( module , str_ ) ; modules . add ( binder -> binder . addbinding ( ) . toinstance ( module ) ) ; return this ; }	Register the provided module.
public pac4j unauthenticated ( supplier < userprofile > provider ) { requirenonnull ( provider , str_ ) ; return unauthenticated ( req -> provider . get ( ) ) ; }	Set a default action which is execute when no user is logged in. {.
public pac4j form ( string pattern ) { return clientinternal ( pattern , conf -> { showdevlogin = bool_ ; return new formclient ( str_ , new simpletestusernamepasswordauthenticator ( ) ) ; } , null ) ; }	Add a simple login form.
public list < routemethod > parse ( string application ) throws exception { return new bytecoderouteparser ( loader , dir ) . parse ( application ) . stream ( ) . filter ( filter ) . collect ( collectors . tolist ( ) ) ; }	Parse application bytecode and build route methods from it.
public scanner scan ( final class < ? > type ) {	Add a scan criteria like an annotation, interface or class.
public apitool swagger ( string path , consumer < swagger > swagger ) { return swagger ( new options ( path , options ) , swagger ) ; }	Mount Swagger at the given path and customize Swagger objects.
public apitool swagger ( options options , consumer < swagger > swagger ) { this . swaggeroptions = objects . requirenonnull ( options , str_ ) ; this . swagger = swagger ; return this ; }	Mount Swagger using the given options.
public apitool raml ( string path , consumer < raml > raml ) { return raml ( new options ( path , options ) , raml ) ; }	Mount RAML at the given path and customize RAML objects.
public apitool raml ( options options , consumer < raml > raml ) { this . ramloptions = objects . requirenonnull ( options , str_ ) ; this . raml = raml ; return this ; }	Mount RAML using the given options.
public string process ( string filename , string source , config conf ) throws exception { return process ( filename , source , conf , getclass ( ) . getclassloader ( ) ) ; }	Method that processes the provided source and returns the processed contents.
public void receiveresultcterecepcaoos ( com . fincatto . documentofiscal . cte300 . webservices . recepcaoos . cterecepcaoosstub . cterecepcaoosresult result ) { }	auto generated Axis2 call back method for cteRecepcaoOS methodoverride this method for handling normal response from cteRecepcaoOS operation.
public void receiveresultmdferecepcaolote ( com . fincatto . documentofiscal . mdfe3 . webservices . recepcao . mdferecepcaostub . mdferecepcaoloteresult result ) { }	auto generated Axis2 call back method for mdfeRecepcaoLote methodoverride this method for handling normal response from mdfeRecepcaoLote operation.
public void receiveresultcteinutilizacaoct ( com . fincatto . documentofiscal . cte300 . webservices . inutilizacao . cteinutilizacaostub . cteinutilizacaoctresult result ) { }	auto generated Axis2 call back method for cteInutilizacaoCT methodoverride this method for handling normal response from cteInutilizacaoCT operation.
public void receiveresultmdferecepcaoevento ( com . fincatto . documentofiscal . mdfe3 . webservices . recepcaoevento . mdferecepcaoeventostub . mdferecepcaoeventoresult result ) { }	auto generated Axis2 call back method for mdfeRecepcaoEvento methodoverride this method for handling normal response from mdfeRecepcaoEvento operation.
public void receiveresultcteconsultact ( com . fincatto . documentofiscal . cte300 . webservices . consulta . cteconsultastub . cteconsultactresult result ) { }	auto generated Axis2 call back method for cteConsultaCT methodoverride this method for handling normal response from cteConsultaCT operation.
public void receiveresultmdfeconsnaoenc ( com . fincatto . documentofiscal . mdfe3 . webservices . consultanaoencerrado . mdfeconsnaoencstub . mdfeconsnaoencresult result ) { }	auto generated Axis2 call back method for mdfeConsNaoEnc methodoverride this method for handling normal response from mdfeConsNaoEnc operation.
@ suppresswarnings ( str_ ) private org . apache . axiom . soap . soapenvelope toenvelope ( final org . apache . axiom . soap . soapfactory factory ) { return factory . getdefaultenvelope ( ) ; }	get the default envelope.
private java . util . map getenvelopenamespaces ( final org . apache . axiom . soap . soapenvelope env ) { final java . util . map returnmap = new java . util . hashmap ( ) ; final java . util . iterator namespaceiterator = env . getalldeclarednamespaces ( ) ; while ( namespaceiterator . hasnext ( ) ) { final org . apache . axiom . om . omnamespace ns = ( org . apache . axiom . om . omnamespace ) namespaceiterator . next ( ) ; returnmap . put ( ns . getprefix ( ) , ns . getnamespaceuri ( ) ) ; } return returnmap ; }	A utility method that copies the namepaces from the SOAPEnvelope.
public void receiveresultnfeconsultanf ( com . fincatto . documentofiscal . nfe310 . webservices . nota . consulta . nfeconsultastub . nfeconsultanfresult result ) { }	auto generated Axis2 call back method for nfeConsultaNF methodoverride this method for handling normal response from nfeConsultaNF operation.
nfloteenvio getloteassinado ( final nfloteenvio lote ) throws exception {	Retorna o Lote assinado.
public nfloteenvioretornodados envialote ( final nfloteenvio lote ) throws exception { if ( lote . getindicadorprocessamento ( ) . equals ( nfloteindicadorprocessamento . processamento_sincrono ) && lote . getnotas ( ) . size ( ) > num_ ) { throw new illegalargumentexception ( str_ ) ; } else if ( lote . getnotas ( ) . size ( ) == num_ ) { throw new illegalargumentexception ( str_ ) ; } return this . wsloteenvio . envialote ( lote ) ; }	Faz o envio de lote para a Sefaz.
public nfstatusservicoconsultaretorno consultastatus ( final dfunidadefederativa uf , final dfmodelo modelo ) throws exception { return this . wsstatusconsulta . consultastatus ( uf , modelo ) ; }	Faz a consulta de status responsavel pela UF.
public nfenviaeventoretorno corrigenota ( final string chavedeacesso , final string textocorrecao , final int numerosequencialevento ) throws exception { return this . wscartacorrecao . corrigenota ( chavedeacesso , textocorrecao , numerosequencialevento ) ; }	Faz a correcao da nota.
public nfenviaeventoretorno cancelanota ( final string chave , final string numeroprotocolo , final string motivo ) throws exception { return this . wscancelamento . cancelanota ( chave , numeroprotocolo , motivo ) ; }	Faz o cancelamento da nota.
public nfretornoeventoinutilizacao inutilizanota ( final int anoinutilizacaonumeracao , final string cnpjemitente , final string serie , final string numeroinicial , final string numerofinal , final string justificativa , final dfmodelo modelo ) throws exception { return this . wsinutilizacao . inutilizanota ( anoinutilizacaonumeracao , cnpjemitente , serie , numeroinicial , numerofinal , justificativa , modelo ) ; }	Inutiliza a nota.
public nfretornoconsultacadastro consultacadastro ( final string cnpj , final dfunidadefederativa uf ) throws exception { return this . wsconsultacadastro . consultacadastro ( cnpj , uf ) ; }	Realiza a consulta de cadastro de pessoa juridica com inscricao estadual.
public void receiveresultcterecepcaolote ( com . fincatto . documentofiscal . cte300 . webservices . recepcao . cterecepcaostub . cterecepcaoloteresult result ) { }	auto generated Axis2 call back method for cteRecepcaoLote methodoverride this method for handling normal response from cteRecepcaoLote operation.
public void receiveresultcteretrecepcao ( com . fincatto . documentofiscal . cte300 . webservices . retrecepcao . cteretrecepcaostub . cteretrecepcaoresult result ) { }	auto generated Axis2 call back method for cteRetRecepcao methodoverride this method for handling normal response from cteRetRecepcao operation.
public string getxmlassinado ( final string chaveacesso , final string textocorrecao , final int numerosequencialevento ) throws exception { final string cartacorrecaoxml = this . gerardadoscartacorrecao ( chaveacesso , textocorrecao , numerosequencialevento ) . tostring ( ) ; return new assinaturadigital ( this . config ) . assinardocumento ( cartacorrecaoxml ) ; }	Retorna XML assinado para uso externo.
public void receiveresultcterecepcaoevento ( com . fincatto . documentofiscal . cte300 . webservices . recepcaoevento . recepcaoeventostub . cterecepcaoeventoresult result ) { }	auto generated Axis2 call back method for cteRecepcaoEvento methodoverride this method for handling normal response from cteRecepcaoEvento operation.
public cteretornocancelamento cancelanota ( final string chave , final string numeroprotocolo , final string motivo ) throws exception { return this . wscancelamento . cancelanota ( chave , numeroprotocolo , motivo ) ; }	Faz o cancelamento do CTe.
public void receiveresultmdfeconsultamdf ( com . fincatto . documentofiscal . mdfe3 . webservices . consulta . mdfeconsultastub . mdfeconsultamdfresult result ) { }	auto generated Axis2 call back method for mdfeConsultaMDF methodoverride this method for handling normal response from mdfeConsultaMDF operation.
public void receiveresultmdferetrecepcao ( com . fincatto . documentofiscal . mdfe3 . webservices . retornorecepcao . mdferetrecepcaostub . mdferetrecepcaoresult result ) { }	auto generated Axis2 call back method for mdfeRetRecepcao methodoverride this method for handling normal response from mdfeRetRecepcao operation.
public mdferetorno cancelamdfe ( final string chave , final string numeroprotocolo , final string motivo ) throws exception { return this . wscancelamento . cancelanota ( chave , numeroprotocolo , motivo ) ; }	Faz o cancelamento do MDFe.
public mdferetorno encerramentoassinado ( final string chaveacesso , final string eventoassinadoxml ) throws exception { return this . wsencerramento . encerramentomdfeassinado ( chaveacesso , eventoassinadoxml ) ; }	Faz o encerramento do MDFe assinado.
public void receiveresultmdfestatusservicomdf ( com . fincatto . documentofiscal . mdfe3 . webservices . statusservico . mdfestatusservicostub . mdfestatusservicomdfresult result ) { }	auto generated Axis2 call back method for mdfeStatusServicoMDF methodoverride this method for handling normal response from mdfeStatusServicoMDF operation.
private omelement efetuaconsultastatusbahia ( final omelement omelement ) throws remoteexception { final nfestatusservicostub . nfecabecmsg cabec = new nfestatusservicostub . nfecabecmsg ( ) ; cabec . setcuf ( dfunidadefederativa . ba . getcodigoibge ( ) ) ; cabec . setversaodados ( this . config . getversao ( ) ) ; final nfestatusservicostub . nfecabecmsge cabecenv = new nfestatusservicostub . nfecabecmsge ( ) ; cabecenv . setnfecabecmsg ( cabec ) ; final nfestatusservicostub . nfedadosmsg dados = new nfestatusservicostub . nfedadosmsg ( ) ; dados . setextraelement ( omelement ) ; final nfautorizador31 autorizador = nfautorizador31 . valueofcodigouf ( dfunidadefederativa . ba ) ; final string endpoint = autorizador . getnfestatusservico ( this . config . getambiente ( ) ) ; if ( endpoint == null ) { throw new illegalargumentexception ( str_ + dfmodelo . nfe . name ( ) + str_ + autorizador . name ( ) + str_ + dfunidadefederativa . ba . name ( ) ) ; } return new nfestatusservicostub ( endpoint ) . nfestatusserviconf ( dados , cabecenv ) . getextraelement ( ) ; }	este metodo teve que ser implementado pois a Bahia trata de forma diferente.
public static double cosinesimilarity ( float [ ] x , float [ ] y , double normy ) { int length = x . length ; double dot = num_ ; double totalxsq = num_ ; for ( int i = num_ ; i < length ; i ++ ) { double xi = x [ i ] ; totalxsq += xi * xi ; dot += xi * y [ i ] ; } return dot / ( math . sqrt ( totalxsq ) * normy ) ; }	Computes cosine similarity of values in two given arrays, when the norm of one array isknown in advance, which is a not-uncommon case.
public void compute ( ) {	Proactively try to compute the solver asynchronously, if not already computed.Does not block.
public static void deleterecursively ( path rootdir ) throws ioexception { if ( rootdir == null || ! files . exists ( rootdir ) ) { return ; } files . walkfiletree ( rootdir , new simplefilevisitor < path > ( ) { @ override public filevisitresult visitfile ( path file , basicfileattributes attrs ) throws ioexception { files . delete ( file ) ; return filevisitresult . continue ; } @ override public filevisitresult postvisitdirectory ( path dir , ioexception exc ) throws ioexception { files . delete ( dir ) ; return filevisitresult . continue ; } } ) ; }	Deletes the given path, and if it is a directory, all files and subdirectories within it.
public static < t > t loadinstanceof ( string implclassname , class < t > superclass , class < ? > [ ] constructortypes , object [ ] constructorargs ) { try { class < ? extends t > configclass = loadclass ( implclassname , superclass ) ; constructor < ? extends t > constructor = configclass . getconstructor ( constructortypes ) ; return constructor . newinstance ( constructorargs ) ; } catch ( nosuchmethodexception | instantiationexception | illegalaccessexception e ) { throw new illegalargumentexception ( str_ + superclass + str_ , e ) ; } catch ( invocationtargetexception ite ) { throw new illegalstateexception ( str_ + superclass + str_ , ite . getcause ( ) ) ; } }	Loads and instantiates a named implementation class, a subclass of a given supertype,whose constructor takes the given arguments.
public void publishadditionalmodeldata ( javasparkcontext sparkcontext , pmml pmml , javardd < m > newdata , javardd < m > pastdata , path modelparentpath , topicproducer < string , string > modelupdatetopic ) {	Optionally, publish additional model-related information to the update topic,after the model has been written.
public void opencustomtab ( final context context , final customtabsintent customtabsintent , final uri uri , customtabfallback fallback ) { final string packagename = getpackagenametouse ( context ) ; if ( packagename != null ) { final customtabsserviceconnection connection = new customtabsserviceconnection ( ) { @ override public void oncustomtabsserviceconnected ( componentname componentname , customtabsclient client ) { client . warmup ( num_ ) ;	Opens the URL on a Custom Tab if possible.
@ nullable public string getpackagenametouse ( context context ) { if ( packagenametouse != null ) return packagenametouse ; packagemanager pm = context . getpackagemanager ( ) ;	Goes through all apps that handle VIEW intents and have a warmup service.
private boolean hasspecializedhandlerintents ( context context , intent intent ) { try { packagemanager pm = context . getpackagemanager ( ) ; list < resolveinfo > handlers = pm . queryintentactivities ( intent , packagemanager . get_resolved_filter ) ; if ( handlers == null || handlers . size ( ) == num_ ) { return bool_ ; } for ( resolveinfo resolveinfo : handlers ) { intentfilter filter = resolveinfo . filter ; if ( filter == null ) continue ; if ( filter . countdataauthorities ( ) == num_ || filter . countdatapaths ( ) == num_ ) continue ; if ( resolveinfo . activityinfo == null ) continue ; return bool_ ; } } catch ( runtimeexception e ) { log . e ( tag , str_ ) ; } return bool_ ; }	Used to check whether there is a specialized handler for a given intent.
private void load ( ) { accesstoken accesstoken = accesstokenstorage . getaccesstoken ( ) ; if ( accesstoken != null ) { accesstokensession session = new accesstokensession ( sessionconfiguration , accesstokenstorage ) ; riderequestview . setsession ( session ) ; loadriderequestview ( ) ; } else { login ( ) ; } }	Loads the appropriate view in the activity based on whether user is successfully authorized or not.
public void execute ( ) { final customtabsintent intent = new customtabsintent . builder ( ) . build ( ) ; customtabshelper . opencustomtab ( context , intent , uri , new customtabshelper . browserfallback ( ) ) ; }	Executes the deeplink to launch the Uber app.
private void validateconfiguration ( sessionconfiguration configuration ) { string nullerror = str_ ; string sampleerror = str_ + str_ + str_ ; checknotnull ( configuration , string . format ( nullerror , str_ ) ) ; checknotnull ( configuration . getclientid ( ) , string . format ( nullerror , str_ ) ) ; checknotnull ( configuration . getredirecturi ( ) , string . format ( nullerror , str_ ) ) ; checkstate ( ! configuration . getclientid ( ) . equals ( str_ ) , string . format ( sampleerror , str_ ) ) ; checkstate ( ! configuration . getredirecturi ( ) . equals ( str_ ) , string . format ( sampleerror , str_ ) ) ; }	Validates the local variables needed by the Uber SDK used in the sample project.
public static intent newresponseintent ( context context , uri responseuri ) { intent intent = new intent ( context , loginactivity . class ) ; intent . setdata ( responseuri ) ; intent . addflags ( intent . flag_activity_clear_top | intent . flag_activity_single_top ) ; return intent ; }	Used to handle Redirect URI response from customtab or browser.
public boolean editmap ( configurationhandler configurationhandler ) { string method = configurationhandler . getmethod ( ) . touppercase ( ) ; if ( configurationhandlermap . containskey ( method . valueof ( method ) ) ) { configurationhandlermap . put ( method . valueof ( method ) , configurationhandler ) ; return bool_ ; } return bool_ ; }	Edit representation for method specified in sent parameter after controller calls for it.
public static void main ( string [ ] args ) { if ( args . length != num_ ) { system . err . println ( str_ ) ; system . exit ( num_ ) ; } int numtasks = num_ ; int numiters = num_ ; blockingqueue < taskrequest > taskqueue = new linkedblockingqueue < > ( ) ; final taskgenerator taskgenerator = new taskgenerator ( taskqueue , numiters , numtasks ) ; final sampleframework framework = new sampleframework ( taskqueue , args [ num_ ] ,	Main method to run the task generator.
public void shutdown ( ) { system . out . println ( str_ ) ; protos . status status = mesosschedulerdriver . stop ( ) ; isshutdown . set ( bool_ ) ; }	Shuts down the Mesos driver.
@ override public result evaluate ( taskrequest taskrequest , virtualmachinecurrentstate targetvm , tasktrackerstate tasktrackerstate ) { collection < taskrequest > runningtasks = targetvm . getrunningtasks ( ) ; if ( runningtasks != null && ! runningtasks . isempty ( ) ) return new result ( bool_ , str_ + runningtasks . size ( ) + str_ ) ; collection < taskassignmentresult > taskscurrentlyassigned = targetvm . gettaskscurrentlyassigned ( ) ; if ( taskscurrentlyassigned != null && ! taskscurrentlyassigned . isempty ( ) ) return new result ( bool_ , str_ + taskscurrentlyassigned . size ( ) + str_ ) ; return new result ( bool_ , str_ ) ; }	Determines whether the prospective host already has tasks either running on it or assigned to be run onit, and returns a false Result if either of those things is the case.
@ override public result evaluate ( taskrequest taskrequest , virtualmachinecurrentstate targetvm , tasktrackerstate tasktrackerstate ) { string targethostattrval = getattrvalue ( targetvm . getcurravailableresources ( ) ) ; if ( targethostattrval == null || targethostattrval . isempty ( ) ) { return new result ( bool_ , hostattributename + str_ + targetvm . getcurravailableresources ( ) . hostname ( ) ) ; } string requiredattrval = hostattributevaluegetter . call ( taskrequest . getid ( ) ) ; return targethostattrval . equals ( requiredattrval ) ? new result ( bool_ , str_ ) : new result ( bool_ , str_ + hostattributename + str_ + requiredattrval + str_ + targethostattrval ) ; }	Tests a host to determine whether it has an attribute of the required value for this task request.
public void setautoscalercallback ( action1 < autoscaleaction > callback ) throws illegalstateexception { checkifshutdown ( ) ; if ( autoscaler == null ) { throw new illegalstateexception ( str_ ) ; } autoscaler . setcallback ( callback ) ; }	Set the autoscale call back action.
public void disablevm ( string hostname , long durationmillis ) throws illegalstateexception { logger . debug ( str_ + hostname + str_ + durationmillis + str_ ) ; assignablevms . disableuntil ( hostname , system . currenttimemillis ( ) + durationmillis ) ; }	Disable the virtual machine with the specified hostname.
public boolean disablevmbyvmid ( string vmid , long durationmillis ) throws illegalstateexception { final string hostname = assignablevms . gethostnamefromvmid ( vmid ) ; if ( hostname == null ) { return bool_ ; } disablevm ( hostname , durationmillis ) ; return bool_ ; }	Disable the virtual machine with the specified ID.
public void enablevm ( string hostname ) throws illegalstateexception { logger . debug ( str_ + hostname ) ; assignablevms . enablevm ( hostname ) ; }	Enable the VM with the specified host name.
public void shutdown ( ) { if ( isshutdown . compareandset ( bool_ , bool_ ) ) { executorservice . shutdown ( ) ; if ( autoscaler != null ) { autoscaler . shutdown ( ) ; } } }	Mark task scheduler as shutdown and shutdown any thread pool executors created.
public boolean hasproperties ( string ... properties ) { for ( string property : properties ) { if ( ! hasproperty ( property ) ) { return bool_ ; } } return bool_ ; }	Check if this entity contains all of the given properties.
public static demo . cdemofileinfo infoforsource ( final source source ) throws ioexception { enginetype enginetype = source . readenginetype ( ) ; source . setposition ( source . readfixedint32 ( ) ) ; packetinstance < generatedmessage > pi = enginetype . getnextpacketinstance ( source ) ; return ( demo . cdemofileinfo ) pi . parse ( ) ; }	Retrieves summary-data from the given input source.
private static s2dotamatchmetadata . cdotamatchmetadatafile metadataforstream ( inputstream stream ) throws ioexception { return packet . parse ( s2dotamatchmetadata . cdotamatchmetadatafile . class , bytestring . readfrom ( stream ) ) ; }	reads a metadata stream and returns it's contents.
private byte [ ] readpacket ( source source ) throws ioexception { int size = source . readfixedint32 ( ) ; return packetreader . readfromsource ( source , size , bool_ ) ; }	alternative to 6? Similar to dota?.
public int readvarint32 ( ) throws ioexception { byte tmp = readbyte ( ) ; if ( tmp >= num_ ) { return tmp ; } int result = tmp & num_ ; if ( ( tmp = readbyte ( ) ) >= num_ ) { result |= tmp << num_ ; } else { result |= ( tmp & num_ ) << num_ ; if ( ( tmp = readbyte ( ) ) >= num_ ) { result |= tmp << num_ ; } else { result |= ( tmp & num_ ) << num_ ; if ( ( tmp = readbyte ( ) ) >= num_ ) { result |= tmp << num_ ; } else { result |= ( tmp & num_ ) << num_ ; result |= ( tmp = readbyte ( ) ) << num_ ; if ( tmp < num_ ) { throw new ioexception ( str_ ) ; } } } } return result ; }	reads a variable int32 from the current position.
public int readfixedint32 ( ) throws ioexception { return bytebuffer . wrap ( readbytes ( num_ ) ) . order ( byteorder . little_endian ) . asintbuffer ( ) . get ( ) ; }	reads a fixed int32 from the current position.
public enginetype readenginetype ( ) throws ioexception { try { enginetype = engineid . typeformagic ( new string ( readbytes ( num_ ) ) ) ; if ( enginetype == null ) { throw new ioexception ( ) ; } return enginetype ; } catch ( ioexception e ) { throw new ioexception ( str_ ) ; } }	reads the magic of a demo file, identifying the engine type.
public containertag with ( domcontent child ) { if ( this == child ) { throw new runtimeexception ( str_ ) ; } if ( child == null ) { return this ;	Appends a DomContent-object to the end of this element.
public containertag with ( iterable < ? extends domcontent > children ) { if ( children != null ) { for ( domcontent child : children ) { this . with ( child ) ; } } return this ; }	Appends a list of DomContent-objects to the end of this element.
@ suppresswarnings ( str_ ) public static < t , u > t iff ( optional < u > optional , function < u , t > iffunction ) { if ( objects . nonnull ( optional ) && optional . ispresent ( ) ) { return optional . map ( iffunction ) . orelse ( null ) ; } return null ; }	Generic if-expression to if'ing inside method calls.
public static string document ( containertag htmltag ) { if ( htmltag . gettagname ( ) . equals ( str_ ) ) { return document ( ) . render ( ) + htmltag . render ( ) ; } throw new illegalargumentexception ( str_ ) ; }	Return a complete html document string.
boolean setattribute ( string name , string value ) { if ( value == null ) { return attributes . add ( new attribute ( name ) ) ; } for ( attribute attribute : attributes ) { if ( attribute . getname ( ) . equals ( name ) ) { attribute . setvalue ( value ) ;	Sets an attribute on an element.
public t attr ( string attribute , object value ) { setattribute ( attribute , value == null ? null : string . valueof ( value ) ) ; return ( t ) this ; }	Sets a custom attribute.
public t attr ( attribute attribute ) { iterator < attribute > iterator = attributes . iterator ( ) ; string name = attribute . getname ( ) ; if ( name != null ) {	Adds the specified attribute.
public t withclasses ( string ... classes ) { stringbuilder sb = new stringbuilder ( ) ; for ( string s : classes ) { sb . append ( s != null ? s : str_ ) . append ( str_ ) ; } return attr ( attr . class , sb . tostring ( ) . trim ( ) ) ; }	Convenience methods that call attr with predefined attributes.
public static string compressjs ( string code ) { inputstream instream = new bytearrayinputstream ( code . getbytes ( ) ) ; bytearrayoutputstream outstream = new bytearrayoutputstream ( ) ; jsmin jsmin = new jsmin ( instream , outstream ) ; try { jsmin . jsmin ( ) ; return outstream . tostring ( ) . trim ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return str_ ; } }	Compress a JS-string.
private arraylist < property > parseproperties ( string contents ) { arraylist < string > parts = new arraylist < > ( ) ; boolean binsidestring = bool_ , binsideurl = bool_ ; int j = num_ ; string substr ; for ( int i = num_ ; i < contents . length ( ) ; i ++ ) { if ( binsidestring ) {	Parses out the properties of a selector's body.
private part [ ] parsevalues ( string contents ) { string [ ] parts = contents . split ( str_ ) ; part [ ] results = new part [ parts . length ] ; for ( int i = num_ ; i < parts . length ; i ++ ) { try { results [ i ] = new part ( parts [ i ] , property ) ; } catch ( exception e ) { log . warning ( e . getmessage ( ) ) ; results [ i ] = null ; } } return results ; }	Parse the values out of a property.
private void handleonvisiblemenuitemswidthchanged ( int menuitemswidth ) { if ( menuitemswidth == num_ ) { mclearbutton . settranslationx ( - util . dptopx ( num_ ) ) ; int paddingright = util . dptopx ( num_ ) ; if ( misfocused ) { paddingright += util . dptopx ( clear_btn_width_dp ) ; } else { paddingright += util . dptopx ( num_ ) ; } msearchinput . setpadding ( num_ , num_ , paddingright , num_ ) ; } else { mclearbutton . settranslationx ( - menuitemswidth ) ; int paddingright = menuitemswidth ; if ( misfocused ) { paddingright += util . dptopx ( clear_btn_width_dp ) ; } msearchinput . setpadding ( num_ , num_ , paddingright , num_ ) ; } }	ensures that the end margin of the search input is according to Material specs.
public void setleftactioniconcolor ( int color ) { mleftactioniconcolor = color ; mmenubtndrawable . setcolor ( color ) ; drawablecompat . settint ( miconbackarrow , color ) ; drawablecompat . settint ( miconsearch , color ) ; }	Sets the menu button's color.
public void setbackgroundcolor ( int color ) { mbackgroundcolor = color ; if ( mquerysection != null && msuggestionslist != null ) { mquerysection . setcardbackgroundcolor ( color ) ; msuggestionslist . setbackgroundcolor ( color ) ; } }	Sets the background color of the searchview including the suggestions section.
public void openmenu ( boolean withanim ) { mmenuopen = bool_ ; openmenudrawable ( mmenubtndrawable , withanim ) ; if ( monmenuclicklistener != null ) { monmenuclicklistener . onmenuopened ( ) ; } }	Mimics a menu click that opens the menu.
public void closemenu ( boolean withanim ) { mmenuopen = bool_ ; closemenudrawable ( mmenubtndrawable , withanim ) ; if ( monmenuclicklistener != null ) { monmenuclicklistener . onmenuclosed ( ) ; } }	Mimics a menu click that closes.
public void inflateoverflowmenu ( int menuid ) { mmenuid = menuid ; mmenuview . reset ( menuid , actionmenuavailwidth ( ) ) ; if ( misfocused ) { mmenuview . hideifroomitems ( bool_ ) ; } }	Inflates the menu items froman xml resource.
public void setshowsearchkey ( boolean show ) { mshowsearchkey = show ; if ( show ) { msearchinput . setimeoptions ( editorinfo . ime_action_search ) ; } else { msearchinput . setimeoptions ( editorinfo . ime_action_none ) ; } }	Sets whether the the button with the search iconwill appear in the soft-keyboard or not.
public void setdismissonoutsideclick ( boolean enable ) { mdismissonoutsidetouch = enable ; msuggestionssection . setontouchlistener ( new ontouchlistener ( ) { @ override public boolean ontouch ( view v , motionevent event ) {	Set whether a touch outside of thesearch bar's bounds will cause the search bar toloos focus.
public boolean setsearchfocused ( final boolean focused ) { boolean updatedtonotfocused = ! focused && this . misfocused ; if ( ( focused != this . misfocused ) && msuggestionsecheightlistener == null ) { if ( missuggestionssectionheightset ) { setsearchfocusedinternal ( focused ) ; } else { msuggestionsecheightlistener = new onsuggestionsecheightsetlistener ( ) { @ override public void onsuggestionsecheightset ( ) { setsearchfocusedinternal ( focused ) ; msuggestionsecheightlistener = null ; } } ; } } return updatedtonotfocused ; }	Sets whether the search is focused or not.
private boolean updatesuggestionssectionheight ( list < ? extends searchsuggestion > newsearchsuggestions , boolean withanim ) { final int cardtopbottomshadowpadding = util . dptopx ( card_view_corners_and_top_bottom_shadow_height ) ; final int cardradiussize = util . dptopx ( card_view_top_bottom_shadow_height ) ; int visiblesuggestionheight = calculatesuggestionitemsheight ( newsearchsuggestions , msuggestionlistcontainer . getheight ( ) ) ; int diff = msuggestionlistcontainer . getheight ( ) - visiblesuggestionheight ; int addedtranslationyforshadowoffsets = ( diff <= cardtopbottomshadowpadding ) ? - ( cardtopbottomshadowpadding - diff ) : diff < ( msuggestionlistcontainer . getheight ( ) - cardtopbottomshadowpadding ) ? cardradiussize : num_ ; final float newtranslationy = - msuggestionlistcontainer . getheight ( ) + visiblesuggestionheight + addedtranslationyforshadowoffsets ;	returns true if the suggestion items occupy the full RecyclerView's height, false otherwise.
private int calculatesuggestionitemsheight ( list < ? extends searchsuggestion > suggestions , int max ) {	results is >= max.
public void setonbindsuggestioncallback ( searchsuggestionsadapter . onbindsuggestioncallback callback ) { this . monbindsuggestioncallback = callback ; if ( msuggestionsadapter != null ) { msuggestionsadapter . setonbindsuggestioncallback ( monbindsuggestioncallback ) ; } }	Set a callback that will be called after each suggestion view in the suggestions recyclerlist is bound.
public static string getmd5checksum ( string filename ) { try { byte [ ] b = createchecksum ( filename ) ; string result = str_ ; for ( int i = num_ ; i < b . length ; i ++ ) { result += integer . tostring ( ( b [ i ] & num_ ) + num_ , num_ ) . substring ( num_ ) ; } return result ; } catch ( exception e ) { return str_ ; } }	a byte array to a HEX string.
public static okhttpclient . builder configuretoignorecertificate ( okhttpclient . builder builder ) { log . warn ( str_ ) ; try { final trustmanager [ ] trustallcerts = new trustmanager [ ] { new x509trustmanager ( ) { @ override public void checkclienttrusted ( java . security . cert . x509certificate [ ] chain , string authtype ) { } @ override public void checkservertrusted ( java . security . cert . x509certificate [ ] chain , string authtype ) { } @ override public java . security . cert . x509certificate [ ] getacceptedissuers ( ) { return new java . security . cert . x509certificate [ ] { } ; } } } ; final sslcontext sslcontext = sslcontext . getinstance ( str_ ) ; sslcontext . init ( null , trustallcerts , new java . security . securerandom ( ) ) ; final sslsocketfactory sslsocketfactory = sslcontext . getsocketfactory ( ) ; builder . sslsocketfactory ( sslsocketfactory , ( x509trustmanager ) trustallcerts [ num_ ] ) ; builder . hostnameverifier ( new hostnameverifier ( ) { @ override public boolean verify ( string hostname , sslsession session ) { return bool_ ; } } ) ; } catch ( exception e ) { log . warn ( str_ + e , e ) ; } return builder ; }	Setting testMode configuration. If set as testMode, the connection will skip certification check.
@ suppresswarnings ( str_ ) @ override public t read ( jsonreader in ) throws ioexception { list < exception > exceptions = new arraylist < > ( subtypes . length ) ; readersupplier readersupplier = readforsupplier ( in ) ; for ( typeadapter < ? > typeadapter : adapters ) { try { return ( t ) typeadapter . read ( readersupplier . create ( ) ) ; } catch ( exception ex ) { exceptions . add ( ex ) ; } } jsonparseexception failure = new jsonparseexception ( string . format ( str_ , type , arrays . tostring ( subtypes ) ) ) ; for ( exception exception : exceptions ) { failure . addsuppressed ( exception ) ; } throw failure ; }	enforced by constructor parameters.
@ value . lazy public nameforms typeabstract ( ) { if ( protoclass ( ) . kind ( ) . isconstructor ( ) ) { return typevalue ( ) ; } list < string > classsegments = lists . newarraylistwithexpectedsize ( num_ ) ; element e = sourcenames . collectclasssegments ( protoclass ( ) . sourceelement ( ) , classsegments ) ; verify ( e instanceof packageelement ) ; string packageof = ( ( packageelement ) e ) . getqualifiedname ( ) . tostring ( ) ; string relative = dot_joiner . join ( classsegments ) ; boolean relativealreadyqualified = bool_ ; if ( ! implementationpackage ( ) . equals ( packageof ) ) { relative = dot_joiner . join ( packageof , relative ) ; relativealreadyqualified = bool_ ; } return immutableconstitution . nameforms . builder ( ) . simple ( names ( ) . typeabstract ) . relativeraw ( relative ) . packageof ( packageof ) . genericargs ( generics ( ) . args ( ) ) . relativealreadyqualified ( relativealreadyqualified ) . visibility ( protoclass ( ) . visibility ( ) ) . build ( ) ; }	Actual abstract value type that is definitive model for the value type.
private string inpackage ( string toplevel , string ... nested ) { return dot_joiner . join ( null , toplevel , ( object [ ] ) nested ) ; }	Package relative path.
@ value . lazy public nameforms typeimmutable ( ) { string simple , relative ; if ( protoclass ( ) . kind ( ) . isnested ( ) ) { string enclosingsimplename = typeimmutableenclosingsimplename ( ) ; simple = names ( ) . typeimmutablenested ( ) ; relative = inpackage ( enclosingsimplename , simple ) ; } else if ( hasimmutableinbuilder ( ) ) { simple = names ( ) . typeimmutable ; relative = inpackage ( typebuildersimplename ( ) , simple ) ; } else { simple = names ( ) . typeimmutable ; relative = inpackage ( simple ) ; } return immutableconstitution . nameforms . builder ( ) . simple ( simple ) . relativeraw ( relative ) . genericargs ( generics ( ) . args ( ) ) . packageof ( implementationpackage ( ) ) . visibility ( implementationvisibility ( ) ) . build ( ) ; }	Actual immutable value type generated implementation.
@ suppresswarnings ( str_ ) @ override @ nullable public < t > typeadapter < t > create ( gson gson , typetoken < t > type ) { if ( id_type_token . equals ( type ) ) { return ( typeadapter < t > ) wrapped_id_adapter ; } if ( time_instant_type_token . equals ( type ) ) { return ( typeadapter < t > ) wrapped_time_instant_adapter ; } if ( binary_type_token . equals ( type ) ) { return ( typeadapter < t > ) wrapped_binary_adapter ; } if ( pattern_type_token . equals ( type ) ) { return ( typeadapter < t > ) pattern_adapter ; } if ( decimal128_type_token . equals ( type ) ) { return ( typeadapter < t > ) decimal128_adapter ; } return null ; }	safe unchecked, typecheck performed by type token equality.
@ suppresswarnings ( str_ ) public static < e extends ordinalvalue < e > > immutableordinalset < e > of ( ) {	Returns singleton empty immutable ordinal set.
@ override public iterator < e > iterator ( ) { return new abstractiterator < e > ( ) { private final int length = length ( ) ; private int index = num_ ; @ override protected e computenext ( ) { int p = index ++ ; if ( p < length ) { return get ( p ) ; } return endofdata ( ) ; } } ; }	Iterator over all present inhabitants of ordinal domain.
private static string cachingkey ( valueattribute valueattribute ) { return string . format ( str_ , valueattribute . containedtypeelement . getqualifiedname ( ) , joiner . on ( str_ ) . join ( valueattribute . containingtype . constitution . style ( ) . attributebuilder ( ) ) ) ; }	The same class included in two parents, may or may not be nested builders based on that discovery pattern.
public string getserializedname ( ) { if ( serializedname == null ) { optional < serializednamemirror > serializednameannotation = serializednamemirror . find ( element ) ; if ( serializednameannotation . ispresent ( ) ) { serializednamemirror m = serializednameannotation . get ( ) ; serializedname = m . value ( ) ; alternateserializednames = m . alternate ( ) ; return serializedname ; } optional < namedmirror > namedannotation = namedmirror . find ( element ) ; if ( namedannotation . ispresent ( ) ) { string value = namedannotation . get ( ) . value ( ) ; if ( ! value . isempty ( ) ) { serializedname = value ; return serializedname ; } } optional < oknamedmirror > oknamedannotation = oknamedmirror . find ( element ) ; if ( oknamedannotation . ispresent ( ) ) { string value = oknamedannotation . get ( ) . name ( ) ; if ( ! value . isempty ( ) ) { serializedname = value ; return serializedname ; } } if ( ismarkedasmongoid ( ) ) { serializedname = id_attribute_name ; return serializedname ; } serializedname = str_ ; return serializedname ; } return serializedname ; }	Serialized name, actully specified via annotation.
public string getmarshaledname ( ) { string serializedname = getserializedname ( ) ; if ( ! serializedname . isempty ( ) ) { return serializedname ; } return names . raw ; }	Marshaled name for compatibility with repository.
public static < t > predicate < t > of ( expression < t > expression ) { if ( expressions . isnil ( expression ) ) {	Factory method to create evaluator instance.
public static < v > fluentfuture < v > from ( listenablefuture < v > future ) { if ( future instanceof fluentfuture < ? > ) { return ( fluentfuture < v > ) future ; } return new wrapingfluentfuture < > ( future , moreexecutors . directexecutor ( ) ) ; }	Wraps listenable future with a fluent future.
@ encoding . expose public optional < immutablemap < k , v > > getimmutable ( ) { return optional . ofnullable ( map ) ; }	alternatively it can be exposed as Optional of ImmutableMap.
protected string stringify ( declaredtype input , typevarcontext context ) { return totypeelement ( input ) . getqualifiedname ( ) . tostring ( ) ; }	overridable stringify.
public final tokenbuffer nexttokenbuffer ( ) throws ioexception { tokenbuffer buffer = new tokenbuffer ( parser ) ;	Reads current value including objects and array as effiecient token buffer.Use of Jackson's own mechanisms is important to preserve custom elementssuch as special embedded objects in BSON or other data formats.
void close ( ) { lock . lock ( ) ; condition . signal ( ) ; setautoaccept ( bool_ ) ; lock . unlock ( ) ; holder_ = null ; }	Closes the current window.
public object execute ( string scriptbody , object [ ] parameters ) { try { asyncresult = new asyncscriptresult ( ) ; function function = createinjectedscriptfunction ( scriptbody , asyncresult ) ; try { page . executejavascriptfunction ( function , function , parameters , page . getdocumentelement ( ) ) ; } catch ( scriptexception e ) { throw new webdriverexception ( e ) ; } try { return asyncresult . waitforresult ( timeoutmillis ) ; } catch ( interruptedexception e ) { throw new webdriverexception ( e ) ; } } finally { asyncresult = null ; } }	Injects an asynchronous script for execution and waits for its result.
public void sethttpproxy ( string host , int port , list < string > noproxyhosts ) { proxyconfig = new proxyconfig ( ) ; proxyconfig . setproxyhost ( host ) ; proxyconfig . setproxyport ( port ) ; if ( noproxyhosts != null && noproxyhosts . size ( ) > num_ ) { for ( string noproxyhost : noproxyhosts ) { proxyconfig . addhoststoproxybypass ( noproxyhost ) ; } } getwebclient ( ) . getoptions ( ) . setproxyconfig ( proxyconfig ) ; }	Sets HTTP proxy for WebClient with bypass proxy hosts.
public void setautoproxy ( string autoproxyurl ) { proxyconfig = new proxyconfig ( ) ; proxyconfig . setproxyautoconfigurl ( autoproxyurl ) ; getwebclient ( ) . getoptions ( ) . setproxyconfig ( proxyconfig ) ; }	Sets Proxy Autoconfiguration URL for WebClient.
public static boxdevelopereditionapiconnection userclient ( string userid ) { if ( userid == null ) {	Get a BoxDeveloperEditionAPIConnection that can be used by an App user to access Box.
public void updatemodifiedfieldsfromentity ( processdefinitionentity updatingprocessdefinition ) { if ( ! this . key . equals ( updatingprocessdefinition . key ) || ! this . deploymentid . equals ( updatingprocessdefinition . deploymentid ) ) { throw new processengineexception ( str_ ) ; }	Updates all modifiable fields from another process definition entity.
private void addfoureyestasklistener ( activityimpl activity ) { usertaskactivitybehavior usertaskactivitybehavior = ( usertaskactivitybehavior ) activity . getactivitybehavior ( ) ; boolean listeneralreadyexists = bool_ ;	Add TaskListener on "complete" event generically every time, so we don'thave to add it in the XML.
@ postdeploy public void deployprocessestotenantengines ( ) {	private static final String PROCESS_DEFINITION_KEY = "tenantdemo-process-application";.
private void checktaskselectedviabridge ( ) { string bridgetaskid = ( string ) getsharedsessionattribute ( bridge_task_id ) ; string selectedtaskid = ( string ) getsharedsessionattribute ( associated_task_id ) ; if ( selectedtaskid == null && bridgetaskid != null ) { switchtaskid ( bridgetaskid ) ; } if ( selectedtaskid != null && bridgetaskid != null && ! selectedtaskid . equals ( bridgetaskid ) ) {	"lazy" load task if bridge state has changed in the meantime.
public static string getservletcontextpath ( processengine processengine , string processdefinitionid ) { return getservletcontextpath ( getprocessapplicationinfo ( processengine , processdefinitionid ) ) ; }	Retrieve the servlet context path of a process definition from a known process engine.
public static string getservletcontextpath ( string processdefinitionid ) { processapplicationinfo processapplicationinfo = getprocessapplicationinfo ( processdefinitionid ) ; if ( processapplicationinfo == null ) { return null ; } return processapplicationinfo . getproperties ( ) . get ( processapplicationinfo . prop_servlet_context_path ) ; }	Retrieve the servlet context path of a process definition from any process engine.
public static processapplicationinfo getprocessapplicationinfo ( processengine processengine , string processdefinitionid ) { processdefinition processdefinition = processengine . getrepositoryservice ( ) . getprocessdefinition ( processdefinitionid ) ;	Retrieve the application info of a process definition from a known process engine.
public static processapplicationinfo getprocessapplicationinfo ( string processdefinitionid ) { processengineservice processengineservice = bpmplatform . getprocessengineservice ( ) ; processapplicationservice processappservice = bpmplatform . getprocessapplicationservice ( ) ;	Retrieve the application info path of a process definition from any process engine.
@ suppresswarnings ( str_ ) @ bean public userdetailsservice userdetailsservice ( ) { inmemoryuserdetailsmanager manager = new inmemoryuserdetailsmanager ( ) ; manager . createuser ( user . withdefaultpasswordencoder ( ) . username ( str_ ) . password ( str_ ) . roles ( str_ , str_ ) . build ( ) ) ; manager . createuser ( user . withdefaultpasswordencoder ( ) . username ( str_ ) . password ( str_ ) . roles ( str_ ) . build ( ) ) ; return manager ; }	In real world scenarios, this would be replaced by the actual IAM solution.
@ suppresswarnings ( str_ ) public static final < t extends serializable > t castvalue ( final object value ) { return value != null ? ( t ) value : null ; }	Type- and null-safe cast of variable-value.
@ postconstruct public void init ( ) throws exception { log . info ( str_ ) ; log . info ( str_ ) ; log . info ( str_ ) ; camundabpmcomponent component = new camundabpmcomponent ( processengine ) ; component . setcamelcontext ( cdicamelcontext ) ; cdicamelcontext . addcomponent ( str_ , component ) ;	private QueueConnectionFactory queueConnectionFactory;.
public static void checkisset ( final delegateexecution execution , final string variablename ) { checkargument ( variablename != null , variable_name_must_be_not_null ) ; final object variablelocal = execution . getvariablelocal ( variablename ) ; final object variable = execution . getvariable ( variablename ) ; checkstate ( variablelocal != null || variable != null , format ( condition_violated + str_ , execution . getcurrentactivityid ( ) , variablename ) ) ; }	Checks if a variable is set.
public static void checkissetglobal ( final delegateexecution execution , final string variablename ) { checkargument ( variablename != null , variable_name_must_be_not_null ) ; final object variable = execution . getvariable ( variablename ) ; checkstate ( variable != null , format ( condition_violated + str_ , execution . getcurrentactivityid ( ) , variablename ) ) ; }	Checks if a global variable is set.
public void open ( boolean animated ) {	Simply opens the menu by doing necessary calculations.
public void close ( boolean animated ) {	Closes the menu.
public void updateitempositions ( ) {	Recalculates the positions of each sub action item on demand.
private point getactionviewcoordinates ( ) { int [ ] coords = new int [ num_ ] ;	Gets the coordinates of the main action viewThis method should only be called after the main layout of the Activity is drawn,such as when a user clicks the action button.
public point getactionviewcenter ( ) { point point = getactionviewcoordinates ( ) ; point . x += mainactionview . getmeasuredwidth ( ) / num_ ; point . y += mainactionview . getmeasuredheight ( ) / num_ ; return point ; }	Returns the center point of the main action view.
private point calculateitempositions ( ) {	Calculates the desired positions of all items.
public view getactivitycontentview ( ) { try { return ( ( activity ) mainactionview . getcontext ( ) ) . getwindow ( ) . getdecorview ( ) . findviewbyid ( android . r . id . content ) ; } catch ( classcastexception e ) { throw new classcastexception ( str_ ) ; } }	Finds and returns the main content view from the Activity context.
private point getscreensize ( ) { point size = new point ( ) ; getwindowmanager ( ) . getdefaultdisplay ( ) . getsize ( size ) ; return size ; }	Retrieves the screen size from the Activity context.
public void setcontentview ( view contentview , framelayout . layoutparams params ) { if ( params == null ) { params = new framelayout . layoutparams ( layoutparams . wrap_content , layoutparams . wrap_content , gravity . center ) ; final int margin = getresources ( ) . getdimensionpixelsize ( r . dimen . sub_action_button_content_margin ) ; params . setmargins ( margin , margin , margin , margin ) ; } contentview . setclickable ( bool_ ) ; this . addview ( contentview , params ) ; }	Sets a content view with custom LayoutParams that will be displayed inside this SubActionButton.
public void setposition ( int position , viewgroup . layoutparams layoutparams ) { boolean setdefaultmargin = bool_ ; int gravity ; switch ( position ) { case position_top_center : gravity = gravity . top | gravity . center_horizontal ; break ; case position_top_right : gravity = gravity . top | gravity . right ; break ; case position_right_center : gravity = gravity . right | gravity . center_vertical ; break ; case position_bottom_center : gravity = gravity . bottom | gravity . center_horizontal ; break ; case position_bottom_left : gravity = gravity . bottom | gravity . left ; break ; case position_left_center : gravity = gravity . left | gravity . center_vertical ; break ; case position_top_left : gravity = gravity . top | gravity . left ; break ; case position_bottom_right : default : setdefaultmargin = bool_ ; gravity = gravity . bottom | gravity . right ; break ; } if ( ! systemoverlay ) { try { framelayout . layoutparams lp = ( framelayout . layoutparams ) layoutparams ; lp . gravity = gravity ; setlayoutparams ( lp ) ; } catch ( classcastexception e ) { throw new classcastexception ( str_ + str_ ) ; } } else { try { windowmanager . layoutparams lp = ( windowmanager . layoutparams ) layoutparams ; lp . gravity = gravity ; if ( setdefaultmargin ) { int margin = getcontext ( ) . getresources ( ) . getdimensionpixelsize ( r . dimen . action_button_margin ) ; lp . x = margin ; lp . y = margin ; } setlayoutparams ( lp ) ; } catch ( classcastexception e ) { throw new classcastexception ( str_ + str_ ) ; } } }	Sets the position of the button by calculating its Gravity from the position parameter.
public void attach ( viewgroup . layoutparams layoutparams ) { if ( systemoverlay ) { try { getwindowmanager ( ) . addview ( this , layoutparams ) ; } catch ( securityexception e ) { throw new securityexception ( str_ + str_ ) ; } } else { ( ( viewgroup ) getactivitycontentview ( ) ) . addview ( this , layoutparams ) ; } }	Attaches it to the content view with specified LayoutParams.
public stateconfiguration < s , t > permit ( t trigger , s destinationstate ) { enforcenotidentitytransition ( destinationstate ) ; return publicpermit ( trigger , destinationstate ) ; }	Accept the specified trigger and transition to the destination state.
public stateconfiguration < s , t > permitif ( t trigger , s destinationstate , funcboolean guard ) { enforcenotidentitytransition ( destinationstate ) ; return publicpermitif ( trigger , destinationstate , guard ) ; }	Accept the specified trigger and transition to the destination state if guard is true.
public stateconfiguration < s , t > permitifotherwiseignore ( t trigger , s destinationstate , final funcboolean guard ) { enforcenotidentitytransition ( destinationstate ) ; ignoreif ( trigger , new funcboolean ( ) { @ override public boolean call ( ) { return ! guard . call ( ) ; } } ) ; return publicpermitif ( trigger , destinationstate , guard ) ; }	Accept the specified trigger and transition to the destination state if guard true, otherwise ignore.
public stateconfiguration < s , t > ignoreif ( t trigger , funcboolean guard ) { assert guard != null : guard_is_null ; representation . addtriggerbehaviour ( new internaltriggerbehaviour < s , t > ( trigger , guard , no_action ) ) ; return this ; }	ignore the specified trigger when in the configured state, if the guard returns true.
private staterepresentation < tstate , ttrigger > getorcreaterepresentation ( tstate state ) { staterepresentation < tstate , ttrigger > result = stateconfiguration . get ( state ) ; if ( result == null ) { result = new staterepresentation < > ( state ) ; stateconfiguration . put ( state , result ) ; } return result ; }	Return StateRepresentation for the specified state.
public void addinstance ( object instance ) throws exception { state currentstate = state . get ( ) ; if ( ( currentstate == state . stopping ) || ( currentstate == state . stopped ) ) { throw new illegalstateexception ( ) ; } else { startinstance ( instance ) ; if ( methodsmap . get ( instance . getclass ( ) ) . hasfor ( predestroy . class ) ) { managedinstances . add ( instance ) ; } } }	Add an additional managed instance.
private boolean setoverflow ( int bucket , int overflow ) { for ( int i = num_ ; i < overflows ; i ++ ) { if ( overflowbuckets [ i ] == bucket ) { overflowvalues [ i ] = ( byte ) overflow ; return bool_ ; } } return bool_ ; }	Returns false if not overflow bucket matching the given bucket id was found.
public densehll mergewith ( densehll other ) { if ( indexbitlength != other . indexbitlength ) { throw new illegalargumentexception ( string . format ( str_ , numberofbuckets ( indexbitlength ) , numberofbuckets ( other . indexbitlength ) ) ) ; } int baseline = math . max ( this . baseline , other . baseline ) ; int baselinecount = num_ ; int overflows = num_ ; int [ ] overflowbuckets = new int [ overflow_grow_increment ] ; byte [ ] overflowvalues = new byte [ overflow_grow_increment ] ; int numberofbuckets = numberofbuckets ( indexbitlength ) ; for ( int i = num_ ; i < numberofbuckets ; i ++ ) { int value = math . max ( getvalue ( i ) , other . getvalue ( i ) ) ; int delta = value - baseline ; if ( delta == num_ ) { baselinecount ++ ; } else if ( delta > max_delta ) {	Returns "this" for chaining.
public static byte [ ] encodesequence ( byte [ ] ... encodedvalues ) { int length = num_ ; for ( byte [ ] encodedvalue : encodedvalues ) { length += encodedvalue . length ; } byte [ ] lengthencoded = encodelength ( length ) ; bytearraydataoutput out = bytestreams . newdataoutput ( num_ + lengthencoded . length + length ) ; out . write ( sequence_tag ) ; out . write ( lengthencoded ) ; for ( byte [ ] entry : encodedvalues ) { out . write ( entry ) ; } return out . tobytearray ( ) ; }	Encodes a sequence of encoded values.
public static list < byte [ ] > decodesequence ( byte [ ] sequence ) { int index = num_ ;	Decodes a sequence of encoded values.
public static byte [ ] decodesequenceoptionalelement ( byte [ ] element ) { int index = num_ ;	Decodes a optional element of a sequence.
public static byte [ ] encodebitstring ( int padbits , byte [ ] value ) { checkargument ( padbits >= num_ && padbits < num_ , str_ ) ; byte [ ] lengthencoded = encodelength ( value . length + num_ ) ; bytearraydataoutput out = bytestreams . newdataoutput ( num_ + lengthencoded . length + value . length ) ; out . write ( bit_string_tag ) ; out . write ( lengthencoded ) ; out . write ( padbits ) ; out . write ( value ) ; return out . tobytearray ( ) ; }	Encodes a bit string padded with the specified number of bits.The encoding is a byte containing the padBits followed by the value bytes.
public static byte [ ] encodeoctetstring ( byte [ ] value ) { byte [ ] lengthencoded = encodelength ( value . length ) ; bytearraydataoutput out = bytestreams . newdataoutput ( num_ + lengthencoded . length + value . length ) ; out . write ( octet_string_tag ) ; out . write ( lengthencoded ) ; out . write ( value ) ; return out . tobytearray ( ) ; }	Encodes an octet string.
public static byte [ ] encodelength ( int length ) { if ( length < num_ ) { return new byte [ ] { ( byte ) length } ; } int numberofbits = num_ - integer . numberofleadingzeros ( length ) ; int numberofbytes = ( numberofbits + num_ ) / num_ ; byte [ ] encoded = new byte [ num_ + numberofbytes ] ; encoded [ num_ ] = ( byte ) ( numberofbytes | num_ ) ; for ( int i = num_ ; i < numberofbytes ; i ++ ) { int bytetoencode = ( numberofbytes - i ) ; int shiftsize = ( bytetoencode - num_ ) * num_ ; encoded [ i + num_ ] = ( byte ) ( length > > > shiftsize ) ; } return encoded ; }	Encodes the length of a DER value.
public static logger get ( string name ) { java . util . logging . logger logger = java . util . logging . logger . getlogger ( name ) ; return new logger ( logger ) ; }	Gets a named logger.
public void debug ( throwable exception , string message ) { logger . log ( fine , message , exception ) ; }	Logs a message at DEBUG level.
public void warn ( throwable exception , string message ) { logger . log ( warning , message , exception ) ; }	Logs a message at WARN level.
public void error ( throwable exception , string message ) { logger . log ( severe , message , exception ) ; }	Logs a message at ERROR level.
public httpuribuilder replacepath ( string path ) { requirenonnull ( path , str_ ) ; if ( ! path . isempty ( ) && ! path . startswith ( str_ ) ) { path = str_ + path ; } this . path = path ; return this ; }	Replace the current path with the given unencoded path.
private static string percentdecode ( string encoded ) { preconditions . checkargument ( ascii ( ) . matchesallof ( encoded ) , str_ ) ; bytearrayoutputstream out = new bytearrayoutputstream ( encoded . length ( ) ) ; for ( int i = num_ ; i < encoded . length ( ) ; i ++ ) { char c = encoded . charat ( i ) ; if ( c == str_ ) { preconditions . checkargument ( i + num_ < encoded . length ( ) , str_ ) ; int high = character . digit ( encoded . charat ( i + num_ ) , num_ ) ; int low = character . digit ( encoded . charat ( i + num_ ) , num_ ) ; preconditions . checkargument ( high != - num_ && low != - num_ , str_ , encoded . substring ( i , i + num_ ) ) ; int value = ( high << num_ ) | ( low ) ; out . write ( value ) ; i += num_ ; } else { out . write ( ( int ) c ) ; } } try { return utf_8 . newdecoder ( ) . onmalformedinput ( codingerroraction . report ) . decode ( bytebuffer . wrap ( out . tobytearray ( ) ) ) . tostring ( ) ; } catch ( charactercodingexception e ) { throw new illegalargumentexception ( str_ ) ; } }	input must be an ASCII string representing a percent-encoded UTF-8 byte sequence.
@ nullable private static doublesummarystats processcontenttimestamps ( list < long > contenttimestamps ) { requirenonnull ( contenttimestamps , str_ ) ;	Calculate the summary statistics for the interarrival time of the onResponseContent callbacks.
< t > t build ( configurationprovider < t > configurationprovider ) { requirenonnull ( configurationprovider , str_ ) ; registerconfigurationprovider ( configurationprovider , optional . empty ( ) ) ;	This is used by the configuration provider.
public void update ( long value , long timestamp ) { lockforregularusage ( ) ; try { final double priority = weight ( timestamp - starttime ) / random ( ) ; final long newcount = count . incrementandget ( ) ; if ( newcount <= reservoirsize ) { values . put ( priority , value ) ; } else { double first = values . firstkey ( ) ; if ( first < priority ) { if ( values . putifabsent ( priority , value ) == null ) {	Adds an old value with a fixed timestamp to the sample.
public static string base64encode ( byte [ ] bytes ) {	Encodes the specified data into a base64 string.
public static byte [ ] base64decode ( string encoded ) { int padding = num_ ; for ( int i = encoded . length ( ) - num_ ; encoded . charat ( i ) == str_ ; i -- ) { padding ++ ; } int length = encoded . length ( ) * num_ / num_ - padding ; byte [ ] bytes = new byte [ length ] ; for ( int i = num_ , index = num_ , n = encoded . length ( ) ; i < n ; i += num_ ) { int word = reverselookup [ encoded . charat ( i ) ] << num_ ; word += reverselookup [ encoded . charat ( i + num_ ) ] << num_ ; word += reverselookup [ encoded . charat ( i + num_ ) ] << num_ ; word += reverselookup [ encoded . charat ( i + num_ ) ] ; for ( int j = num_ ; j < num_ && index + j < length ; j ++ ) { bytes [ index + j ] = ( byte ) ( word > > ( num_ * ( num_ - j ) ) ) ; } index += num_ ; } return bytes ; }	Decodes the specified base64 string back into its raw data.
@ override public synchronized void flush ( ) throws ioexception { super . flush ( ) ; string record = this . tostring ( ) ; reset ( ) ; if ( record . isempty ( ) || record . equals ( lineseparator ) ) {	write the current buffer contents to the underlying logger.
@ suppresswarnings ( str_ ) public string dumpdestination ( uri uri ) { destination destination = httpclient . getdestination ( uri . getscheme ( ) , uri . gethost ( ) , uri . getport ( ) ) ; if ( destination == null ) { return null ; } return dumpdestination ( destination ) ; }	todo this should be .
public static double computealpha ( double targetweight , long targetageinseconds ) { checkargument ( targetageinseconds > num_ , str_ ) ; checkargument ( targetweight > num_ && targetweight < num_ , str_ ) ; return - math . log ( targetweight ) / targetageinseconds ; }	Compute the alpha decay factor such that the weight of an entry with age 'targetAgeInSeconds' is targetWeight'.
public static < x , y > void propagatecancellation ( listenablefuture < ? extends x > source , future < ? extends y > destination , boolean mayinterruptifrunning ) { source . addlistener ( ( ) -> { if ( source . iscancelled ( ) ) { destination . cancel ( mayinterruptifrunning ) ; } } , directexecutor ( ) ) ; }	Cancels the destination Future if the source Future is cancelled.
@ deprecated public static < v > completablefuture < v > unmodifiablefuture ( completablefuture < v > future ) { return unmodifiablefuture ( future , bool_ ) ; }	Returns a future that can not be completed or canceled.
@ deprecated public static < v > completablefuture < v > unmodifiablefuture ( completablefuture < v > future , boolean propagatecancel ) { requirenonnull ( future , str_ ) ; function < boolean , boolean > oncancelfunction ; if ( propagatecancel ) { oncancelfunction = future :: cancel ; } else { oncancelfunction = mayinterrupt -> bool_ ; } unmodifiablecompletablefuture < v > unmodifiablefuture = new unmodifiablecompletablefuture < > ( oncancelfunction ) ; future . whencomplete ( ( value , exception ) -> { if ( exception != null ) { unmodifiablefuture . internalcompleteexceptionally ( exception ) ; } else { unmodifiablefuture . internalcomplete ( value ) ; } } ) ; return unmodifiablefuture ; }	Returns a future that can not be completed or optionally canceled.
@ deprecated public static < v > completablefuture < v > failedfuture ( throwable throwable ) { requirenonnull ( throwable , str_ ) ; completablefuture < v > future = new completablefuture < > ( ) ; future . completeexceptionally ( throwable ) ; return future ; }	Returns a failed future containing the specified throwable.
public static < v , e extends exception > v getfuturevalue ( future < v > future , class < e > exceptiontype ) throws e { requirenonnull ( future , str_ ) ; requirenonnull ( exceptiontype , str_ ) ; try { return future . get ( ) ; } catch ( interruptedexception e ) { thread . currentthread ( ) . interrupt ( ) ; throw new runtimeexception ( str_ , e ) ; } catch ( executionexception e ) { throwable cause = e . getcause ( ) == null ? e : e . getcause ( ) ; propagateifpossible ( cause , exceptiontype ) ; throw new runtimeexception ( cause ) ; } }	Waits for the value from the future.
public static < t > optional < t > trygetfuturevalue ( future < t > future ) { requirenonnull ( future , str_ ) ; if ( ! future . isdone ( ) ) { return optional . empty ( ) ; } return trygetfuturevalue ( future , num_ , milliseconds ) ; }	Gets the current value of the future without waiting.
public static < v > optional < v > trygetfuturevalue ( future < v > future , int timeout , timeunit timeunit ) { return trygetfuturevalue ( future , timeout , timeunit , runtimeexception . class ) ; }	Waits for the the value from the future for the specified time.
public static < v , e extends exception > optional < v > trygetfuturevalue ( future < v > future , int timeout , timeunit timeunit , class < e > exceptiontype ) throws e { requirenonnull ( future , str_ ) ; checkargument ( timeout >= num_ , str_ ) ; requirenonnull ( timeunit , str_ ) ; requirenonnull ( exceptiontype , str_ ) ; try { return optional . ofnullable ( future . get ( timeout , timeunit ) ) ; } catch ( interruptedexception e ) { thread . currentthread ( ) . interrupt ( ) ; throw new runtimeexception ( str_ , e ) ; } catch ( executionexception e ) { throwable cause = e . getcause ( ) == null ? e : e . getcause ( ) ; propagateifpossible ( cause , exceptiontype ) ; throw new runtimeexception ( cause ) ; } catch ( timeoutexception expected ) {	Waits for the the value from the future for the specified time.
public static void checksuccess ( future < ? > future , string errormessage ) { requirenonnull ( future , str_ ) ; requirenonnull ( errormessage , str_ ) ; checkargument ( future . isdone ( ) , str_ ) ; try { getfuturevalue ( future ) ; } catch ( runtimeexception e ) { throw new illegalargumentexception ( errormessage , e ) ; } }	Checks that the completed future completed successfully.
public static < v > listenablefuture < v > whenanycomplete ( iterable < ? extends listenablefuture < ? extends v > > futures ) { requirenonnull ( futures , str_ ) ; checkargument ( ! isempty ( futures ) , str_ ) ; extendedsettablefuture < v > firstcompletedfuture = extendedsettablefuture . create ( ) ; for ( listenablefuture < ? extends v > future : futures ) { firstcompletedfuture . setasync ( future ) ; } return firstcompletedfuture ; }	Creates a future that completes when the first future completes either normallyor exceptionally.
@ deprecated public static < v > completablefuture < v > firstcompletedfuture ( iterable < ? extends completionstage < ? extends v > > futures ) { return firstcompletedfuture ( futures , bool_ ) ; }	Creates a future that completes when the first future completes either normallyor exceptionally.
@ deprecated public static < v > completablefuture < v > firstcompletedfuture ( iterable < ? extends completionstage < ? extends v > > futures , boolean propagatecancel ) { requirenonnull ( futures , str_ ) ; checkargument ( ! isempty ( futures ) , str_ ) ; completablefuture < v > future = new completablefuture < > ( ) ; for ( completionstage < ? extends v > stage : futures ) { stage . whencomplete ( ( value , exception ) -> { if ( exception != null ) { future . completeexceptionally ( exception ) ; } else { future . complete ( value ) ; } } ) ; } if ( propagatecancel ) { future . exceptionally ( throwable -> { if ( throwable instanceof cancellationexception ) { for ( completionstage < ? extends v > sourcefuture : futures ) { if ( sourcefuture instanceof future ) { ( ( future < ? > ) sourcefuture ) . cancel ( bool_ ) ; } } } return null ; } ) ; } return future ; }	Creates a future that completes when the first future completes either normallyor exceptionally.
@ deprecated public static < v > completablefuture < list < v > > allaslist ( list < completablefuture < ? extends v > > futures ) { completablefuture < void > alldonefuture = completablefuture . allof ( futures . toarray ( new completablefuture [ futures . size ( ) ] ) ) ;	Returns an unmodifiable future that is completed when all of the givenfutures complete.
public static < v > completablefuture < v > tocompletablefuture ( listenablefuture < v > listenablefuture ) { requirenonnull ( listenablefuture , str_ ) ; completablefuture < v > future = new completablefuture < > ( ) ; future . exceptionally ( throwable -> { if ( throwable instanceof cancellationexception ) { listenablefuture . cancel ( bool_ ) ; } return null ; } ) ; futurecallback < v > callback = new futurecallback < v > ( ) { @ override public void onsuccess ( v result ) { future . complete ( result ) ; } @ override public void onfailure ( throwable t ) { future . completeexceptionally ( t ) ; } } ; futures . addcallback ( listenablefuture , callback , directexecutor ( ) ) ; return future ; }	Converts a ListenableFuture to a CompletableFuture.
public static < v > listenablefuture < v > tolistenablefuture ( completablefuture < v > completablefuture ) { requirenonnull ( completablefuture , str_ ) ; settablefuture < v > future = settablefuture . create ( ) ; propagatecancellation ( future , completablefuture , bool_ ) ; completablefuture . whencomplete ( ( value , exception ) -> { if ( exception != null ) { future . setexception ( exception ) ; } else { future . set ( value ) ; } } ) ; return future ; }	Converts a CompletableFuture to a ListenableFuture.
public static < t > void addexceptioncallback ( listenablefuture < t > future , runnable exceptioncallback , executor executor ) { requirenonnull ( exceptioncallback , str_ ) ; addexceptioncallback ( future , t -> exceptioncallback . run ( ) , executor ) ; }	Invokes the callback, using the specified executor, if the future fails.
private int tryremove ( int node ) { checkargument ( node != - num_ , str_ ) ; int left = lefts [ node ] ; int right = rights [ node ] ; if ( left == - num_ && right == - num_ ) {	Remove the node if possible or set its count to 0 if it has children andit needs to be kept around.
private double computemaxpathweight ( int node ) { if ( node == - num_ || levels [ node ] == num_ ) { return num_ ; } double leftmaxweight = computemaxpathweight ( lefts [ node ] ) ; double rightmaxweight = computemaxpathweight ( rights [ node ] ) ; return math . max ( leftmaxweight , rightmaxweight ) + counts [ node ] ; }	Computes the max "weight" of any path starting at node and ending at a leaf in thehypothetical complete tree. The weight is the sum of counts in the ancestors of a given node.
public void addhash ( long hash ) { instance . inserthash ( hash ) ; if ( instance instanceof sparsehll ) { instance = makedenseifnecessary ( ( sparsehll ) instance ) ; } }	Adds a value that has already been hashed to the set of values tracked by this HyperLogLog instance.
public static map < string , string > loadpropertiesfrom ( string path ) throws ioexception { properties properties = new properties ( ) ; try ( inputstream inputstream = new fileinputstream ( path ) ) { properties . load ( inputstream ) ; } return fromproperties ( properties ) ; }	Loads properties from the given file.
public < t > void bindconfigglobaldefaults ( class < t > configclass , configdefaults < t > configdefaults ) { key < t > key = key . get ( configclass , globaldefaults . class ) ; binder . bindconfigdefaults ( new configdefaultsholder < > ( key , configdefaults ) ) ; }	Binds default values for all the instances of given config class for the current binder.
public duration next ( int pollcount , duration previousduration ) { return new duration ( fibonacci ( offset + pollcount ) , timeunit ) ; }	Generate the next duration.
private int fib ( int value , int current , int previous ) { if ( value == num_ ) { return previous ; } else if ( value == num_ ) { return current ; } return fib ( value - num_ , current + previous , current ) ; }	Tail recursive implementation of fibonacci.
public duration multiply ( long amount ) { return new multiply ( ) . apply ( this , unit == null ? forever : new duration ( amount , unit ) ) ; }	Multiply this amount with the given amount.
public duration divide ( long amount ) { return new divide ( ) . apply ( this , unit == null ? forever : new duration ( amount , unit ) ) ; }	Divide this duration amount with the given amount.
private static field findsinglefieldusingstrategy ( fieldmatcherstrategy strategy , object object , boolean checkhierarchy , class < ? > startclass ) { assertobjectingetinternalstateisnotnull ( object ) ; field foundfield = null ; final class < ? > originalstartclass = startclass ; while ( startclass != null ) { final field [ ] declaredfields = startclass . getdeclaredfields ( ) ; for ( field field : declaredfields ) { if ( strategy . matches ( field ) && hasfieldpropermodifier ( object , field ) ) { if ( foundfield != null ) { throw new toomanyfieldsfoundexception ( str_ + strategy + str_ ) ; } foundfield = field ; } } if ( foundfield != null ) { break ; } else if ( ! checkhierarchy ) { break ; } startclass = startclass . getsuperclass ( ) ; } if ( foundfield == null ) { strategy . notfound ( originalstartclass , ! isclass ( object ) ) ; return null ; } foundfield . setaccessible ( bool_ ) ; return foundfield ; }	Find single field using strategy.
private static boolean hasfieldpropermodifier ( object object , field field ) { return ( ( object instanceof class < ? > && modifier . isstatic ( field . getmodifiers ( ) ) ) || ! ( object instanceof class < ? > || modifier . isstatic ( field . getmodifiers ( ) ) ) ) ; }	Checks for field proper modifier.
public static void throwexceptioniffieldwasnotfound ( class < ? > type , string fieldname , field field ) { if ( field == null ) { throw new fieldnotfoundexception ( str_ + fieldname + str_ + type . getname ( ) + str_ ) ; } }	Throw exception if field was not found.
public static field getfieldannotatedwith ( object object , class < ? extends annotation > annotationtype ) { return findsinglefieldusingstrategy ( new fieldannotationmatcherstrategy ( annotationtype ) , object , bool_ , gettype ( object ) ) ; }	Get field annotated with a particular annotation.
public conditionfactory conditionevaluationlistener ( conditionevaluationlistener conditionevaluationlistener ) { return new conditionfactory ( alias , timeoutconstraint , pollinterval , polldelay , catchuncaughtexceptions , exceptionsignorer , conditionevaluationlistener , executorlifecycle ) ; }	Handle condition evaluation results each time evaluation of a condition occurs.
public conditionfactory pollexecutorservice ( executorservice executorservice ) { if ( executorservice != null && executorservice instanceof scheduledexecutorservice ) { throw new illegalargumentexception ( str_ + scheduledexecutorservice . class . getname ( ) ) ; } return new conditionfactory ( alias , timeoutconstraint , pollinterval , polldelay , bool_ , exceptionsignorer , conditionevaluationlistener , executorlifecycle . withoutcleanup ( executorservice ) ) ; }	Specify the executor service whose threads will be used to evaluate the poll condition in Awaitility.Note that the executor service must be shutdown manually!This is an advanced feature and it should only be used sparingly.
public void untiltrue ( final atomicboolean atomic ) { untilatomic ( atomic , anyof ( is ( boolean . true ) , is ( bool_ ) ) ) ; }	Await until a Atomic boolean becomes true.
public void untilfalse ( final atomicboolean atomic ) { untilatomic ( atomic , anyof ( is ( boolean . false ) , is ( bool_ ) ) ) ; }	Await until a Atomic boolean becomes false.
public static conditionfactory catchuncaughtexceptions ( ) { return new conditionfactory ( null , defaultwaitconstraint , defaultpollinterval , defaultpolldelay , defaultcatchuncaughtexceptions , defaultexceptionignorer , defaultconditionevaluationlistener , defaultexecutorlifecycle ) ; }	Catching uncaught exceptions in other threads.
public static void setdefaulttimeout ( long timeout , timeunit unit ) { defaultwaitconstraint = defaultwaitconstraint . withmaxwaittime ( new duration ( timeout , unit ) ) ; }	Sets the default timeout all await statements will use.
public static void setdefaulttimeout ( duration defaulttimeout ) { if ( defaulttimeout == null ) { throw new illegalargumentexception ( str_ ) ; } defaultwaitconstraint = defaultwaitconstraint . withmaxwaittime ( defaulttimeout ) ; }	Sets the default timeout that all await statements will use.
public static list < string > tokenize ( string arguments , boolean stringify ) { linkedlist < string > arglist = new linkedlist < > ( ) ; stringbuilder currarg = new stringbuilder ( ) ; boolean escaped = bool_ ; int state = no_token_state ;	Tokenizes the given String into String tokens.
protected static string _escapequotesandbackslashes ( string s ) { final stringbuilder buf = new stringbuilder ( s ) ;	Inserts backslashes before any occurrences of a backslash orquote in the given string.
public result servestatic ( ) { object renderable = new renderable ( ) { @ override public void render ( context context , result result ) { string filename = getfilenamefrompathorreturnrequestpath ( context ) ; url url = getstaticfilefromassetsdir ( filename ) ; streamouturlentity ( url , context , result ) ; } } ; return results . ok ( ) . render ( renderable ) ; }	Serves resources from the assets directory of your application.For instance:route: /robots.txtA request to /robots.txt will be served from /assets/robots.txt.You can also use a path like the following to serve files:route: /assets/{fileName: .*}matches/assets/app/app.cssand will return/assets/app/app.css (from your jar).
private propertiesconfiguration loadlanguageconfiguration ( string fileorurl ) { propertiesconfiguration configuration = swissknife . loadconfigurationinutf8 ( fileorurl ) ; if ( configuration != null && ninjaproperties . isdev ( ) ) {	Attempts to load a message file and sets the file changed reloadingstrategy on the configuration if the runtime mode is Dev.
private map < string , configuration > loadallmessagefilesforregisteredlanguages ( ) { map < string , configuration > langtokeyandvaluesmappingmutable = maps . newhashmap ( ) ;	Does all the loading of message files.Only registered messages in application.conf are loaded.
protected static url geturlforstringfromclasspathasfileorurl ( string logbackconfigurationfile ) { url url = null ; try { url = resources . getresource ( logbackconfigurationfile ) ; } catch ( illegalargumentexception ex ) {	Looks up a potential file from1) The classpahth2) From the filesystem3) From an URL.
protected static string generatesecret ( random random ) { string charsetforsecret = str_ ; stringbuilder stringbuilder = new stringbuilder ( num_ ) ; for ( int i = num_ ; i < num_ ; i ++ ) { int chartopopickfromcharset = random . nextint ( charsetforsecret . length ( ) ) ; stringbuilder . append ( charsetforsecret . charat ( chartopopickfromcharset ) ) ; } return stringbuilder . tostring ( ) ; }	!!!! Only for testing purposes !!!!Usually you want to use {.
protected runclassinseparatejvmmachine buildrunclassinseparatejvmmachine ( string name , string classnamewithmaintorun , list < string > classpath , list < string > jvmarguments , file mavenbasedir ) { return new runclassinseparatejvmmachine ( name , classnamewithmaintorun , classpath , buildjvmarguments ( ) , mavenbasedir ) ; }	so we can mock a fake one for unit testing.
static public class < ? extends standalone > resolvestandaloneclass ( ) { return resolvestandaloneclass ( system . getproperty ( standalone . key_ninja_standalone_class ) , forwardingserviceloader . loadwithsystemserviceloader ( standalone . class ) , standalone . default_standalone_class ) ; }	Resolves which standalone class to use.
public string encrypt ( string data ) { objects . requirenonnull ( data , str_ ) ; if ( ! secretkeyspec . ispresent ( ) ) { return data ; } try {	Encrypts data with secret key.
public string decrypt ( string data ) { objects . requirenonnull ( data , str_ ) ; if ( ! secretkeyspec . ispresent ( ) ) { return data ; }	Decrypts data with secret key.
private final string readninjaversion ( ) {	Simply reads a property resource file that contains the version of thisNinja build.
private void register ( path path ) throws ioexception {	Register the given path with the WatchService.
public static ninjamode determinemodefromsystempropertiesorprodifnotset ( ) { optional < ninjamode > ninjamodeoptional = determinemodefromsystemproperties ( ) ; ninjamode ninjamode ; if ( ! ninjamodeoptional . ispresent ( ) ) { ninjamode = ninjamode . prod ; } else { ninjamode = ninjamodeoptional . get ( ) ; } logger . info ( str_ , ninjamode . tostring ( ) ) ; return ninjamode ; }	returns NinjaMode.dev if no mode is set.
public boolean isvalidmimetype ( string mimetype ) { if ( mimetype == null ) { return bool_ ; } else if ( mimetype . indexof ( str_ ) != - num_ ) { return mimetypes . contains ( mimetype . split ( str_ ) [ num_ ] ) ; } else { return mimetypes . contains ( mimetype ) ; } }	check the mimetype is referenced in the mimetypes database.
public route buildroute ( injector injector ) { if ( functionalmethod == null ) { log . error ( str_ , uri ) ; throw new illegalstateexception ( str_ ) ; }	Build the route.
@ override final public void run ( ) {	Configure, start, add shutdown hook, and join.
protected string createserverurl ( string scheme , string host , integer port ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( scheme ) ; sb . append ( str_ ) ; sb . append ( ( host != null ? host : str_ ) ) ; if ( ( str_ . equals ( scheme ) && port != num_ ) || ( str_ . equals ( scheme ) && port != num_ ) ) { sb . append ( str_ ) ; sb . append ( port ) ; } return sb . tostring ( ) ; }	helpful utilities for subclasses.
@ override public void init ( router router ) { this . router = router ; configurereflections ( ) ; controllers = maps . newhashmap ( ) ; methods = sets . newhashset ( ) ; processfoundmethods ( ) ; sortmethods ( ) ; registermethods ( ) ; }	Scans, identifies, and registers annotated controller methods for thecurrent runtime settings.
private void processfoundmethods ( ) { for ( method method : findcontrollermethods ( ) ) { if ( allowmethod ( method ) ) {	Takes the found methods and checks if they have a valid format.If they do, the controller path classes for these methods are generated.
private void sortmethods ( ) { list < method > methodlist = new arraylist < > ( methods ) ; collections . sort ( methodlist , new comparator < method > ( ) { @ override public int compare ( method m1 , method m2 ) { int o1 = integer . max_value ; if ( m1 . isannotationpresent ( order . class ) ) { order order = m1 . getannotation ( order . class ) ; o1 = order . value ( ) ; } int o2 = integer . max_value ; if ( m2 . isannotationpresent ( order . class ) ) { order order = m2 . getannotation ( order . class ) ; o2 = order . value ( ) ; } if ( o1 == o2 ) {	Sorts the methods into registration order.
@ suppresswarnings ( str_ ) private set < method > findcontrollermethods ( ) { set < method > methods = sets . newlinkedhashset ( ) ; methods . addall ( reflections . getmethodsannotatedwith ( path . class ) ) ; boolean enablecustomhttpmethods = ninjaproperties . getbooleanwithdefault ( ninja_custom_http_methods , bool_ ) ; if ( enablecustomhttpmethods ) { reflections annotationreflections = new reflections ( str_ , new typeannotationsscanner ( ) , new subtypesscanner ( ) ) ; for ( class < ? > httpmethod : annotationreflections . gettypesannotatedwith ( httpmethod . class ) ) { if ( httpmethod . isannotation ( ) ) { methods . addall ( reflections . getmethodsannotatedwith ( ( class < ? extends annotation > ) httpmethod ) ) ; } } } else {	Searches for Methods that have either a Path Annotation or a HTTP-Method Annotation.
private void configurereflections ( ) { optional < string > basepackage = optional . ofnullable ( ninjaproperties . get ( ninjaconstant . application_modules_base_package ) ) ; if ( basepackage . ispresent ( ) ) { reflections = new reflections ( basepackage . get ( ) + str_ + ninjaconstant . controllers_dir , new methodannotationsscanner ( ) ) ; } else { reflections = new reflections ( ninjaconstant . controllers_dir , new methodannotationsscanner ( ) ) ; } }	Configures the set of packages to scan for annotated controller methods.
private boolean allowmethod ( method method ) {	Determines if this method may be registered as a route.
private string gethttpmethod ( method method ) { for ( annotation annotation : method . getannotations ( ) ) { class < ? extends annotation > annotationclass = annotation . annotationtype ( ) ; if ( annotationclass . isannotationpresent ( httpmethod . class ) ) { httpmethod httpmethod = annotationclass . getannotation ( httpmethod . class ) ; return httpmethod . value ( ) ; } }	Returns the HTTP method for the controller method.
public static controllermethodinvoker build ( method functionalmethod , method implementationmethod , injector injector , ninjaproperties ninjaproperties ) {	Builds an invoker for a functional method.
public static string getrealclassnamelowercamelcase ( object object ) { return caseformat . upper_camel . to ( caseformat . lower_camel , object . getclass ( ) . getsimplename ( ) ) ; }	Returns the lower class name.
public static boolean doesclassexist ( string namewithpackage , object instancetogetclassloaderfrom ) { boolean exists = bool_ ; try { class . forname ( namewithpackage , bool_ , instancetogetclassloaderfrom . getclass ( ) . getclassloader ( ) ) ; exists = bool_ ; } catch ( classnotfoundexception e ) { exists = bool_ ; } return exists ; }	Used to check whether a class exists on the classpath.
static public string getsourcecoderelativepathforstacktraceelement ( stacktraceelement ste ) { string packagename = ste . getclassname ( ) ;	Calculates the relative path of the source code file of a StackTraceelement if its available.
public void add ( string key , object value , string expiration ) { checkserializable ( value ) ; cache . add ( key , value , timeutil . parseduration ( expiration ) ) ; }	Add an element only if it doesn't exist.
@ suppresswarnings ( str_ ) public < t > t get ( string key , class < t > clazz ) { return ( t ) cache . get ( key ) ; }	Convenient clazz to get a value a class type;.
void checkserializable ( object value ) { if ( value != null && ! ( value instanceof serializable ) ) { throw new cacheexception ( str_ + value . getclass ( ) . getname ( ) , new notserializableexception ( value . getclass ( ) . getname ( ) ) ) ; } }	Utility that check that an object is serializable.
public result render ( string key , object value ) { render ( new abstractmap . simpleentry < string , object > ( key , value ) ) ; return this ; }	Implicitly generates a hashmap as object being rendered and addsthis key, value pair.
public result renderraw ( final byte [ ] bytes ) { renderable renderable = new renderable ( ) { @ override public void render ( context context , result result ) { if ( result . getcontenttype ( ) == null ) { result . contenttype ( result . application_octet_stream ) ; } responsestreams responsestreams = context . finalizeheaders ( result ) ; try ( outputstream outputstream = responsestreams . getoutputstream ( ) ) { outputstream . write ( bytes ) ; } catch ( ioexception ioexception ) { throw new internalservererrorexception ( ioexception ) ; } } } ; render ( renderable ) ; return this ; }	This method directly renders the byte array to the output.
public cookie getcookie ( string cookiename ) { for ( cookie cookie : getcookies ( ) ) { if ( cookie . getname ( ) . equals ( cookiename ) ) { return cookie ; } } return null ; }	Returns cookie with that name or null.
public result donotcachecontent ( ) { addheader ( cache_control , cache_control_default_nocache_value ) ; addheader ( date , dateutil . formatforhttpheader ( system . currenttimemillis ( ) ) ) ; addheader ( expires , dateutil . formatforhttpheader ( num_ ) ) ; return this ; }	This function setsCache-Control: no-cache, no-storeDate: (current date)Expires: 1970=> it therefore effectively forces the browser and every proxy in betweennot to cache content.See also https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers.
public static void checkthatapplicationsecretisset ( boolean isprod , string basedirwithouttrailingslash , propertiesconfiguration defaultconfiguration , configuration compositeconfiguration ) { string applicationsecret = compositeconfiguration . getstring ( ninjaconstant . applicationsecret ) ; if ( applicationsecret == null || applicationsecret . isempty ( ) ) {	This method checks that your configurations have set aapplication.secret=23r213r12r123If application.secret is missing or is empty it will do the following:- In dev and test mode it'll generate a new application secret and write the secretto both src/main/java/conf/application.conf and the classes dir were the compiled stuffgoes.- In prod it will throw a runtime exception and stop the server.
public boolean addall ( @ nonnull final collection < ? extends t > collection ) { boolean result = mitems . addall ( collection ) ; notifydatasetchanged ( ) ; return result ; }	Adds the objects in the specified collection to the end of this List.
private int getpositionforid ( final long itemid ) { view v = getviewforid ( itemid ) ; if ( v == null ) { return adapterview . invalid_position ; } else { return mwrapper . getpositionforview ( v ) ; } }	Retrieves the position in the list corresponding to itemId.
private void switchviews ( final view switchview , final long switchid , final float translationy ) { assert mhoverdrawable != null ; assert madapter != null ; assert mmobileview != null ; final int switchviewposition = mwrapper . getpositionforview ( switchview ) ; int mobileviewposition = mwrapper . getpositionforview ( mmobileview ) ; ( ( swappable ) madapter ) . swapitems ( switchviewposition - mwrapper . getheaderviewscount ( ) , mobileviewposition - mwrapper . getheaderviewscount ( ) ) ; ( ( baseadapter ) madapter ) . notifydatasetchanged ( ) ; mhoverdrawable . shift ( switchview . getheight ( ) ) ; mswitchviewanimator . animateswitchview ( switchid , translationy ) ; }	Switches the item that is currently being dragged with the item belonging to given id,by notifying the adapter to swap positions and that the data set has changed.
public void removeactiveindex ( final int index ) { boolean found = bool_ ; for ( iterator < atomicinteger > iterator = mactiveindexes . iterator ( ) ; iterator . hasnext ( ) && ! found ; ) { if ( iterator . next ( ) . get ( ) == index ) { iterator . remove ( ) ; found = bool_ ; } } if ( mactiveindexes . isempty ( ) ) { insertpending ( ) ; } }	Clear the active state for given index.
@ nonnull public collection < integer > getactiveindexes ( ) { collection < integer > result = new hashset < > ( ) ; for ( atomicinteger i : mactiveindexes ) { result . add ( i . get ( ) ) ; } return result ; }	Returns a collection of currently active indexes.
@ nullable public view gettitleview ( final int position ) { view titleview = null ; view parentview = findviewforposition ( position ) ; if ( parentview != null ) { object tag = parentview . gettag ( ) ; if ( tag instanceof viewholder ) { titleview = ( ( viewholder ) tag ) . titleview ; } } return titleview ; }	Return the title view at the specified position.
@ nullable public view getcontentview ( final int position ) { view contentview = null ; view parentview = findviewforposition ( position ) ; if ( parentview != null ) { object tag = parentview . gettag ( ) ; if ( tag instanceof viewholder ) { contentview = ( ( viewholder ) tag ) . contentview ; } } return contentview ; }	Return the content view at the specified position.
public void expand ( final int position ) { long itemid = getitemid ( position ) ; if ( mexpandedids . contains ( itemid ) ) { return ; } toggle ( position ) ; }	Expand the view at given position.
public void collapse ( final int position ) { long itemid = getitemid ( position ) ; if ( ! mexpandedids . contains ( itemid ) ) { return ; } toggle ( position ) ; }	Collapse the view at given position.
@ nullable private view getcontentparent ( final int position ) { view contentparent = null ; view parentview = findviewforposition ( position ) ; if ( parentview != null ) { object tag = parentview . gettag ( ) ; if ( tag instanceof viewholder ) { contentparent = ( ( viewholder ) tag ) . contentparent ; } } return contentparent ; }	Return the content parent at the specified position.
@ suppresswarnings ( { str_ , str_ } ) @ nonnull protected animator [ ] getadditionalanimators ( @ nonnull final view view , @ nonnull final viewgroup parent ) { return new animator [ ] { } ; }	Override this method to provide additional animators on top of the default height and alpha animation.
@ nonnull static bitmap getbitmapfromview ( @ nonnull final view v ) { bitmap bitmap = bitmap . createbitmap ( v . getmeasuredwidth ( ) , v . getmeasuredheight ( ) , bitmap . config . argb_8888 ) ; canvas canvas = new canvas ( bitmap ) ; v . draw ( canvas ) ; return bitmap ; }	Returns a bitmap showing a screenshot of the view passed in.
private boolean isdismissable ( final int position ) { if ( mlistviewwrapper . getadapter ( ) == null ) { return bool_ ; } if ( mdismissablemanager != null ) { long downid = mlistviewwrapper . getadapter ( ) . getitemid ( position ) ; return mdismissablemanager . isdismissable ( downid , position ) ; } return bool_ ; }	Finds out whether the item represented by given position is dismissable.
private void reset ( ) { if ( mvelocitytracker != null ) { mvelocitytracker . recycle ( ) ; } mvelocitytracker = null ; mdownx = num_ ; mdowny = num_ ; mcurrentview = null ; mswipingview = null ; mcurrentposition = adapterview . invalid_position ; mswiping = bool_ ; mcandismisscurrent = bool_ ; }	Resets the fields to the initial values, ready to start over.
public void reset ( ) { for ( int i = num_ ; i < manimators . size ( ) ; i ++ ) { manimators . get ( manimators . keyat ( i ) ) . cancel ( ) ; } manimators . clear ( ) ; mfirstanimatedposition = - num_ ; mlastanimatedposition = - num_ ; manimationstartmillis = - num_ ; mshouldanimate = bool_ ; }	Call this method to reset animation status on all views.
void cancelexistinganimation ( @ nonnull final view view ) { int hashcode = view . hashcode ( ) ; animator animator = manimators . get ( hashcode ) ; if ( animator != null ) { animator . end ( ) ; manimators . remove ( hashcode ) ; } }	Cancels any existing animations for given View.
private void animateview ( final int position , @ nonnull final view view , @ nonnull final animator [ ] animators ) { if ( manimationstartmillis == - num_ ) { manimationstartmillis = systemclock . uptimemillis ( ) ; } viewhelper . setalpha ( view , num_ ) ; animatorset set = new animatorset ( ) ; set . playtogether ( animators ) ; set . setstartdelay ( calculateanimationdelay ( position ) ) ; set . setduration ( manimationdurationmillis ) ; set . start ( ) ; manimators . put ( view . hashcode ( ) , set ) ; }	Animates given View.
@ suppresslint ( str_ ) private int calculateanimationdelay ( final int position ) { int delay ; int lastvisibleposition = mlistviewwrapper . getlastvisibleposition ( ) ; int firstvisibleposition = mlistviewwrapper . getfirstvisibleposition ( ) ; int numberofitemsonscreen = lastvisibleposition - firstvisibleposition ; int numberofanimateditems = position - num_ - mfirstanimatedposition ; if ( numberofitemsonscreen + num_ < numberofanimateditems ) { delay = manimationdelaymillis ; if ( mlistviewwrapper . getlistview ( ) instanceof gridview && build . version . sdk_int >= build . version_codes . honeycomb ) { int numcolumns = ( ( gridview ) mlistviewwrapper . getlistview ( ) ) . getnumcolumns ( ) ; delay += manimationdelaymillis * ( position % numcolumns ) ; } } else { int delaysincestart = ( position - mfirstanimatedposition ) * manimationdelaymillis ; delay = math . max ( num_ , ( int ) ( - systemclock . uptimemillis ( ) + manimationstartmillis + minitialdelaymillis + delaysincestart ) ) ; } return delay ; }	Returns the delay in milliseconds after which animation for View with position mLastAnimatedPosition + 1 should start.
@ nonnull public static animator [ ] concatanimators ( @ nonnull final animator [ ] childanimators , @ nonnull final animator [ ] animators , @ nonnull final animator alphaanimator ) { animator [ ] allanimators = new animator [ childanimators . length + animators . length + num_ ] ; int i ; for ( i = num_ ; i < childanimators . length ; ++ i ) { allanimators [ i ] = childanimators [ i ] ; } for ( animator animator : animators ) { allanimators [ i ] = animator ; ++ i ; } allanimators [ allanimators . length - num_ ] = alphaanimator ; return allanimators ; }	Merges given Animators into one array.
public void handlenoncors ( final httpservletrequest request , final httpservletresponse response , final filterchain filterchain ) throws ioexception , servletexception {	Handles a request, that's not a CORS request, but is a valid request i.e.it is not a cross-origin request.
@ override public void addstreamofliteralwords ( buffer buffer , int start , int number ) { for ( int x = start ; x < start + number ; ++ x ) if ( buffer . getword ( x ) != num_ ) throw nonemptyexception ; }	throws a NonEmptyException exception when number is greater than 0.
public static void materialize ( final iteratingrlw i , final bitmapstorage c ) { while ( bool_ ) { if ( i . getrunninglength ( ) > num_ ) { c . addstreamofemptywords ( i . getrunningbit ( ) , i . getrunninglength ( ) ) ; } int il = i . getnumberofliteralwords ( ) ; for ( int k = num_ ; k < il ; ++ k ) c . addword ( i . getliteralwordat ( k ) ) ; if ( ! i . next ( ) ) break ; } }	Generate a bitmap from an iterator.
public t poll ( ) { t ans = this . a [ num_ ] ; this . a [ num_ ] = this . a [ this . lastindex -- ] ; percolatedown ( num_ ) ; return ans ; }	Remove the element on top of the heap.
private void resizebuffer ( int number ) { int size = newsizeinwords ( number ) ; if ( size >= this . buffer . length ) { long oldbuffer [ ] = this . buffer ; this . buffer = new long [ size ] ; system . arraycopy ( oldbuffer , num_ , this . buffer , num_ , oldbuffer . length ) ; } }	Resizes the buffer if the number of words to add exceeds the buffer capacity.
private int newsizeinwords ( int number ) { int size = this . actualsizeinwords + number ; if ( size >= this . buffer . length ) { if ( size < num_ ) size = size * num_ ; else if ( size * num_ / num_ < size )	Returns the resulting buffer size in words given the number of words to add.
public static ewahcompressedbitmap32 xor ( final ewahcompressedbitmap32 ... bitmaps ) { priorityqueue < ewahcompressedbitmap32 > pq = new priorityqueue < ewahcompressedbitmap32 > ( bitmaps . length , new comparator < ewahcompressedbitmap32 > ( ) { @ override public int compare ( ewahcompressedbitmap32 a , ewahcompressedbitmap32 b ) { return a . sizeinbytes ( ) - b . sizeinbytes ( ) ; } } ) ; collections . addall ( pq , bitmaps ) ; if ( pq . isempty ( ) ) return new ewahcompressedbitmap32 ( ) ; while ( pq . size ( ) > num_ ) { ewahcompressedbitmap32 x1 = pq . poll ( ) ; ewahcompressedbitmap32 x2 = pq . poll ( ) ; pq . add ( x1 . xor ( x2 ) ) ; } return pq . poll ( ) ; }	Simple algorithm that computes the XOR aggregate.
@ override public void addstreamofliteralwords ( buffer32 buffer , int start , int number ) { for ( int i = start ; i < start + number ; i ++ ) { addliteralword ( buffer . getword ( i ) ) ; } }	virtually add several literal words.
public final void fillwithliterals ( final list < ewahpointer32 > container ) { for ( int k = this . litwlist . nextsetbit ( num_ ) ; k >= num_ ; k = this . litwlist . nextsetbit ( k + num_ ) ) { container . add ( this . rw [ k ] ) ; } }	append to the list the literal words as EWAHPointer.
public bitset asbitset ( ) { bitset bs = new bitset ( this . size ( ) ) ; this . data . rewind ( ) ; this . data . get ( bs . data , num_ , bs . data . length ) ; return bs ; }	Get a copy of this ImmutableBitSet as a mutable BitSet.
public int cardinality ( ) { int sum = num_ ; int length = this . data . limit ( ) ; for ( int k = num_ ; k < length ; ++ k ) sum += long . bitcount ( this . data . get ( k ) ) ; return sum ; }	Compute the number of bits set to 1.
public boolean empty ( ) { int length = this . data . limit ( ) ; for ( int k = num_ ; k < length ; ++ k ) if ( this . data . get ( k ) != num_ ) return bool_ ; return bool_ ; }	Check whether a bitset contains a set bit.
public intiterator intiterator ( ) { return new intiterator ( ) { @ override public boolean hasnext ( ) { return this . i >= num_ ; } @ override public int next ( ) { this . j = this . i ; this . i = immutablebitset . this . nextsetbit ( this . i + num_ ) ; return this . j ; } private int i = immutablebitset . this . nextsetbit ( num_ ) ; private int j ; } ; }	Iterate over the set bits.
public boolean intersects ( bitset bs ) { for ( int k = num_ ; k < math . min ( this . data . limit ( ) , bs . data . length ) ; ++ k ) { if ( ( this . data . get ( k ) & bs . data [ k ] ) != num_ ) return bool_ ; } return bool_ ; }	Checks whether two bitsets intersect.
public intiterator unsetintiterator ( ) { return new intiterator ( ) { @ override public boolean hasnext ( ) { return this . i >= num_ ; } @ override public int next ( ) { this . j = this . i ; this . i = immutablebitset . this . nextunsetbit ( this . i + num_ ) ; return this . j ; } private int i = immutablebitset . this . nextunsetbit ( num_ ) ; private int j ; } ; }	Iterate over the unset bits.
public void parsenextrun ( ) { if ( ( this . isliteral ) || ( this . iterator . getnumberofliteralwords ( ) == num_ ) ) {	Process the next run.
public void open ( ) { state = state . opened ; showicons ( bool_ ) ; animator [ left ] . setfloatvalues ( button [ left ] , num_ ) ; animator [ right ] . setfloatvalues ( button [ right ] , width ) ; animator [ radius ] . setfloatvalues ( button [ radius ] , num_ ) ; animator [ top ] . setfloatvalues ( button [ top ] , num_ ) ; animator [ bottom ] . setfloatvalues ( button [ bottom ] , height ) ; animatorset . cancel ( ) ; animatorset . start ( ) ; if ( iconopeneddrawable instanceof animatable ) { ( ( animatable ) iconopeneddrawable ) . start ( ) ; } viewgroup parentview = ( viewgroup ) tapbarmenu . this . getparent ( ) ; this . animate ( ) . y ( menuanchor == menu_anchor_bottom ? parentview . getbottom ( ) - height : num_ ) . setduration ( animationduration ) . setinterpolator ( decelerate_interpolator ) . start ( ) ; }	Open the menu.
public void close ( ) { updatedimensions ( width , height ) ; state = state . closed ; showicons ( bool_ ) ; animator [ left ] . setfloatvalues ( num_ , button [ left ] ) ; animator [ right ] . setfloatvalues ( width , button [ right ] ) ; animator [ radius ] . setfloatvalues ( num_ , button [ radius ] ) ; animator [ top ] . setfloatvalues ( num_ , button [ top ] ) ; animator [ bottom ] . setfloatvalues ( height , button [ bottom ] ) ; animatorset . cancel ( ) ; animatorset . start ( ) ; if ( iconcloseddrawable instanceof animatable ) { ( ( animatable ) iconcloseddrawable ) . start ( ) ; } this . animate ( ) . y ( yposition ) . setduration ( animationduration ) . setinterpolator ( decelerate_interpolator ) . start ( ) ; }	Close the menu.
public void setmenubackgroundcolor ( int colorresid ) { backgroundcolor = contextcompat . getcolor ( getcontext ( ) , colorresid ) ; paint . setcolor ( backgroundcolor ) ; invalidate ( ) ; }	Sets TapBarMenu's background color from given resource.
private int [ ] fetchdatabasenamerangeindexfromurlforh2filemode ( string url ) { int filelabelindex = url . indexof ( file_mode_flag ) ; int parameterlabelindex = url . indexof ( str_ , filelabelindex ) ; if ( parameterlabelindex == - num_ ) { parameterlabelindex = url . length ( ) ; } if ( filelabelindex != - num_ ) { return new int [ ] { filelabelindex + file_mode_flag . length ( ) + num_ , parameterlabelindex } ; } else { return null ; } }	Fetch range index that the database name from connection url if H2 database running with filemode.
private int [ ] fetchdatabasenamerangeindexfromurlforh2memmode ( string url ) { int filelabelindex = url . indexof ( memory_mode_flag ) ; int parameterlabelindex = url . indexof ( str_ , filelabelindex ) ; if ( parameterlabelindex == - num_ ) { parameterlabelindex = url . length ( ) ; } if ( filelabelindex != - num_ ) { return new int [ ] { filelabelindex + memory_mode_flag . length ( ) + num_ , parameterlabelindex } ; } else { return null ; } }	Fetch range index that the database name from connection url if H2 database running with memorymode.
public static connectioninfo parser ( string url ) { if ( null == url ) { return connectioninfo . unknown_connection_info ; } string lowercaseurl = url . tolowercase ( ) ; connectionurlparser parser = findurlparser ( lowercaseurl ) ; if ( parser == null ) { return connectioninfo . unknown_connection_info ; } try { return parser . parse ( url ) ; } catch ( exception e ) { log . log ( level . warning , str_ ) ; } return connectioninfo . unknown_connection_info ; }	parse the url to the ConnectionInfo.
public static void registerconnectionparser ( string urlprefix , connectionurlparser parser ) { if ( null == urlprefix || parser == null ) { throw new illegalargumentexception ( str_ ) ; } parserregister . put ( urlprefix . tolowercase ( ) , parser ) ; }	register new ConnectionURLParser. Can override existing parser.
protected string fetchdatabasenamefromurl ( string url ) { urllocation hostslocation = fetchdatabasenameindexrange ( url ) ; return url . substring ( hostslocation . startindex ( ) , hostslocation . endindex ( ) ) ; }	Fetch database name from connection url.
public static void run ( final context context , final class < ? > daemonserviceclazz , final int interval ) { new thread ( new runnable ( ) { @ override public void run ( ) { command . install ( context , bin_dir_name , daemon_bin_name ) ; start ( context , daemonserviceclazz , interval ) ; } } ) . start ( ) ; }	Run daemon process.
private static void copyfile ( file file , inputstream is , string mode ) throws ioexception , interruptedexception { final string abspath = file . getabsolutepath ( ) ; final fileoutputstream out = new fileoutputstream ( file ) ; byte buf [ ] = new byte [ num_ ] ; int len ; while ( ( len = is . read ( buf ) ) > num_ ) { out . write ( buf , num_ , len ) ; } out . close ( ) ; is . close ( ) ; runtime . getruntime ( ) . exec ( str_ + mode + str_ + abspath ) . waitfor ( ) ; }	copy file to destination.
public static void copyassets ( context context , string assetsfilename , file file , string mode ) throws ioexception , interruptedexception { assetmanager manager = context . getassets ( ) ; final inputstream is = manager . open ( assetsfilename ) ; copyfile ( file , is , mode ) ; }	copy file in assets into destination file.
@ suppresswarnings ( str_ ) public static boolean install ( context context , string destdir , string filename ) { string binarydir = str_ ; string abi = build . cpu_abi ; if ( abi . startswith ( str_ ) ) { binarydir = str_ ; } else if ( abi . startswith ( str_ ) ) { binarydir = str_ ; } string assetfilename = binarydir + file . separator + filename ; try { file f = new file ( context . getdir ( destdir , context . mode_private ) , filename ) ; if ( f . exists ( ) ) { log . d ( tag , str_ ) ; return bool_ ; } copyassets ( context , assetfilename , f , str_ ) ; return bool_ ; } catch ( exception e ) { log . e ( tag , str_ + e . getmessage ( ) ) ; return bool_ ; } }	Install specified binary into destination directory.
private void handlemissingfields ( ) { missingfieldhandler missingfieldhandler = reader . getmissingfieldhandler ( ) ; if ( missingfieldhandler != null ) { for ( missingfields mf : missingfields ) { missingfieldhandler . fieldmissing ( mf . target , mf . fieldname , mf . value ) ; } }	calls the missing field handler if any for each recorded missing field.
private object getenum ( class c , jsonobject jsonobj ) { try { return enum . valueof ( c , ( string ) jsonobj . get ( str_ ) ) ; } catch ( exception e ) {	Fetch enum value (may need to try twice, due to potential 'name' field shadowing by enum subclasses.
protected void patchunresolvedreferences ( ) { iterator i = unresolvedrefs . iterator ( ) ; while ( i . hasnext ( ) ) { unresolvedreference ref = ( unresolvedreference ) i . next ( ) ; object objtofix = ref . referencingobj . target ; jsonobject objreferenced = reader . getobjectsread ( ) . get ( ref . refid ) ; if ( ref . index >= num_ ) {	For all fields where the value was ".
public static object jsontojava ( string json , map < string , object > optionalargs ) { if ( optionalargs == null ) { optionalargs = new hashmap < string , object > ( ) ; optionalargs . put ( use_maps , bool_ ) ; } if ( ! optionalargs . containskey ( use_maps ) ) { optionalargs . put ( use_maps , bool_ ) ; } jsonreader jr = new jsonreader ( json , optionalargs ) ; object obj = jr . readobject ( ) ; jr . close ( ) ; return obj ; }	Convert the passed in JSON string into a Java object graph.
public object jsonobjectstojava ( jsonobject root ) { getargs ( ) . put ( use_maps , bool_ ) ; return convertparsedmapstojava ( root ) ; }	Convert a root JsonObject that represents parsed JSON, intoan actual Java object.
public void traversefields ( final deque < jsonobject < string , object > > stack , final jsonobject < string , object > jsonobj ) { final object javamate = jsonobj . target ; final iterator < map . entry < string , object > > i = jsonobj . entryset ( ) . iterator ( ) ; final class cls = javamate . getclass ( ) ; while ( i . hasnext ( ) ) { map . entry < string , object > e = i . next ( ) ; string key = e . getkey ( ) ; final field field = metautils . getfield ( cls , key ) ; object rhs = e . getvalue ( ) ; if ( field != null ) { assignfield ( stack , jsonobj , field , rhs ) ; } else if ( missingfieldhandler != null ) { handlemissingfield ( stack , jsonobj , rhs , key ) ; }	Walk the Java object fields and copy them from the JSON object to the Java object, performingany necessary conversions on primitives, or deep traversals for field assignments to other objects,arrays, Collections, or Maps.
private void storemissingfield ( object target , string missingfield , object value ) { missingfields . add ( new missingfields ( target , missingfield , value ) ) ; }	stores the missing field and their values to call back the handler at the end of the resolution, cause somereference may need to be resolved later.
public static class getrawtype ( final type t ) { if ( t instanceof parameterizedtype ) { parameterizedtype ptype = ( parameterizedtype ) t ; if ( ptype . getrawtype ( ) instanceof class ) { return ( class ) ptype . getrawtype ( ) ; } } return null ; }	Given the passed in Type t, return the raw type of it, if the passed in value is a ParameterizedType.
private object readarray ( jsonobject object ) throws ioexception { final list < object > array = new arraylist ( ) ; while ( bool_ ) { final object o = readvalue ( object ) ; if ( o != empty_array ) { array . add ( o ) ; } final int c = skipwhitespaceread ( ) ; if ( c == str_ ) { break ; } else if ( c != str_ ) { error ( str_ ) ; } } return array . toarray ( ) ; }	Read a JSON array.
private number readnumber ( int c ) throws ioexception { final fastpushbackreader in = input ; final stringbuilder number = numbuf ; number . setlength ( num_ ) ; number . appendcodepoint ( c ) ; boolean isfloat = bool_ ; if ( jsonreader . islenient ( ) && ( c == str_ || c == str_ || c == str_ ) ) {	Read a JSON number.
public static field getfield ( class c , string field ) { return getdeepdeclaredfields ( c ) . get ( field ) ; }	Return an instance of of the Java Field class corresponding to the passed in field name.
static string removeleadingandtrailingquotes ( string s ) { matcher m = extraquotes . matcher ( s ) ; if ( m . find ( ) ) { s = m . group ( num_ ) ; } return s ; }	Strip leading and trailing double quotes from the passed in String.
public static string formatjson ( string json , map readingargs , map writingargs ) { map args = new hashmap ( ) ; if ( readingargs != null ) { args . putall ( readingargs ) ; } args . put ( jsonreader . use_maps , bool_ ) ; object obj = jsonreader . jsontojava ( json , args ) ; args . clear ( ) ; if ( writingargs != null ) { args . putall ( writingargs ) ; } args . put ( pretty_print , bool_ ) ; return objecttojson ( obj , args ) ; }	Format the passed in JSON string in a nice, human readable format.
private void tab ( writer output , int delta ) throws ioexception { if ( ! isprettyprint ) { return ; } output . write ( new_line ) ; depth += delta ; for ( int i = num_ ; i < depth ; i ++ ) { output . write ( str_ ) ; } }	tab the JSON output by the given number of characters specified by delta.
public boolean writearrayelementifmatching ( class arraycomponentclass , object o , boolean showtype , writer output ) { if ( ! o . getclass ( ) . isassignablefrom ( arraycomponentclass ) || notcustom . contains ( o . getclass ( ) ) ) { return bool_ ; } try { return writecustom ( arraycomponentclass , o , showtype , output ) ; } catch ( ioexception e ) { throw new jsonioexception ( str_ , e ) ; } }	Write the passed in array element to the JSON output, if any only if, there is a customer writerfor the class of the instance 'o'.
protected boolean writecustom ( class arraycomponentclass , object o , boolean showtype , writer output ) throws ioexception { if ( nevershowtype ) { showtype = bool_ ; } jsonclasswriterbase closestwriter = getcustomwriter ( arraycomponentclass ) ; if ( closestwriter == null ) { return bool_ ; } if ( writeoptionalreference ( o ) ) { return bool_ ; } boolean referenced = objsreferenced . containskey ( o ) ; if ( closestwriter instanceof jsonclasswriter ) { jsonclasswriter writer = ( jsonclasswriter ) closestwriter ; if ( writer . hasprimitiveform ( ) ) { if ( ( ! referenced && ! showtype ) || closestwriter instanceof writers . jsonstringwriter ) { if ( writer instanceof writers . datewriter ) { ( ( writers . datewriter ) writer ) . writeprimitiveform ( o , output , args ) ; } else { writer . writeprimitiveform ( o , output ) ; } return bool_ ; } } } output . write ( str_ ) ; tabin ( ) ; if ( referenced ) { writeid ( getid ( o ) ) ; if ( showtype ) { output . write ( str_ ) ; newline ( ) ; } } if ( showtype ) { writetype ( o , output ) ; } if ( referenced || showtype ) { output . write ( str_ ) ; newline ( ) ; } if ( closestwriter instanceof jsonclasswriterex ) { ( ( jsonclasswriterex ) closestwriter ) . write ( o , showtype || referenced , output , args ) ; } else { ( ( jsonclasswriter ) closestwriter ) . write ( o , showtype || referenced , output ) ; } tabout ( ) ; output . write ( str_ ) ; return bool_ ; }	Perform the actual custom writing for an array element that has a custom writer.
private jsonclasswriterbase forcegetcustomwriter ( class c ) { jsonclasswriterbase closestwriter = nullwriter ; int mindistance = integer . max_value ; for ( map . entry < class , jsonclasswriterbase > entry : writers . entryset ( ) ) { class clz = entry . getkey ( ) ; if ( clz == c ) { return entry . getvalue ( ) ; } int distance = metautils . getdistance ( clz , c ) ; if ( distance < mindistance ) { mindistance = distance ; closestwriter = entry . getvalue ( ) ; } } return closestwriter ; }	Fetch the customer writer for the passed in Class.
public void write ( object obj ) { tracereferences ( obj ) ; objvisited . clear ( ) ; try { writeimpl ( obj , bool_ ) ; } catch ( exception e ) { throw new jsonioexception ( str_ , e ) ; } flush ( ) ; objvisited . clear ( ) ; objsreferenced . clear ( ) ; }	Write the passed in Java object in JSON format.
protected void tracereferences ( object root ) { if ( root == null ) { return ; } map < class , list < field > > fieldspecifiers = ( map ) args . get ( field_specifiers ) ; final deque < object > stack = new arraydeque < object > ( ) ; stack . addfirst ( root ) ; final map < object , long > visited = objvisited ; final map < object , long > referenced = objsreferenced ; while ( ! stack . isempty ( ) ) { final object obj = stack . removefirst ( ) ; if ( ! metautils . islogicalprimitive ( obj . getclass ( ) ) ) { long id = visited . get ( obj ) ; if ( id != null ) {	Walk object graph and visit each instance, following each field, each Collection, Map and so on.Tracks visited to handle cycles and to determine if an item is referenced elsewhere.
protected void tracefields ( final deque < object > stack , final object obj , final map < class , list < field > > fieldspecifiers ) {	Reach-ability trace to visit all objects within the graph to be written.This API will handle any object, using either reflection APIs or byconsulting a specified FIELD_SPECIFIERS map if provided.
public static boolean ensurejsonprimitivekeys ( map map ) { for ( object o : map . keyset ( ) ) { if ( ! ( o instanceof string ) ) { return bool_ ; } } return bool_ ; }	Ensure that all keys within the Map are String instances.
private void writecollectionelement ( object o ) throws ioexception { if ( o == null ) { out . write ( str_ ) ; } else if ( o instanceof boolean || o instanceof double ) { writeprimitive ( o , bool_ ) ; } else if ( o instanceof long ) { writeprimitive ( o , writelongsasstrings ) ; } else if ( o instanceof string ) {	Write an element that is contained in some type of Collection or Map.
private static map < string , string > createmapfromlist ( final list < string > all ) { final map < string , string > map = new concurrenthashmap < > ( ) ; for ( final string documentelement : all ) { if ( documentelement != null ) { map . put ( documentelement , documentelement ) ; } } return map ; }	Creates the map from list.
@ embedded @ attributeoverrides ( { @ attributeoverride ( name = str_ , column = @ column ( name = str_ ) ) , @ attributeoverride ( name = str_ , column = @ column ( name = str_ ) ) } ) public source getsource ( ) { return source ; }	Gets the source.
@ manytoone ( targetentity = topics . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public topics gettopics ( ) { return topics ; }	Gets the topics.
@ id @ column ( name = str_ ) @ generatedvalue ( strategy = generationtype . auto ) public long gethjid ( ) { return hjid ; }	Gets the hjid.
@ onetomany ( targetentity = documentdetaildata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < documentdetaildata > getdocumentdetaillist ( ) { return this . documentdetaillist ; }	Gets the document detail list.
private static axes createaxesxydatefloat ( ) { return new axes ( ) . addaxis ( new xyaxis ( ) . setrenderer ( axisrenderers . date ) . settickoptions ( new axistickrenderer ( ) . setformatstring ( year_month_day_format ) . setfontfamily ( font_family ) . settextcolor ( text_color ) . setfontsize ( font_size ) ) . setnumberticks ( number_ticks_date ) ) . addaxis ( new xyaxis ( xyaxes . y ) . setrenderer ( axisrenderers . linear ) . settickoptions ( new axistickrenderer ( ) . setformatstring ( float_format ) . setfontfamily ( font_family ) . settextcolor ( text_color ) . setfontsize ( font_size ) ) . setnumberticks ( number_ticks ) ) ; }	Creates the axes XY date float.
private static grid createdefaultgrid ( ) { final grid grid = new grid ( ) ; grid . setbackground ( background_color ) ; grid . setgridlinecolor ( gridline_color ) ; grid . setbordercolor ( border_color ) ; return grid ; }	Creates the default grid.
private static legend createdlegendenhancedinsidenorthwest ( ) { return setlegendstyling ( new legend ( ) . setshow ( bool_ ) . setrendereroptions ( new enhancedlegendrenderer ( ) . setseriestoggle ( seriestoggles . normal ) . setseriestogglereplot ( bool_ ) . setnumbercolumns ( legend_columns ) . setnumberrows ( legend_rows ) ) . setplacement ( legendplacements . inside_grid ) . setlocation ( legendlocations . north_west ) ) ; }	Created legend enhanced inside north west.
private static legend createdlegendenhancedinsidewest ( ) { return setlegendstyling ( new legend ( ) . setshow ( bool_ ) . setplacement ( legendplacements . inside_grid ) . setlocation ( legendlocations . west ) . setrenderer ( legendrenderers . enhanced ) . setrendereroptions ( new enhancedlegendrenderer ( ) . setseriestoggle ( seriestoggles . normal ) . setseriestogglereplot ( bool_ ) . setnumbercolumns ( legend_columns ) . setnumberrows ( legend_rows ) ) ) ; }	Created legend enhanced inside west.
private static legend createlegendoutsideonecolumn ( ) { return setlegendstyling ( new legend ( ) . setshow ( bool_ ) . setrendereroptions ( new enhancedlegendrenderer ( ) . setseriestoggle ( seriestoggles . normal ) . setseriestogglereplot ( bool_ ) . setnumbercolumns ( one_column_number_of_columns ) . setnumberrows ( one_column_number_of_rows ) ) . setplacement ( legendplacements . outside_grid ) ) ; }	Creates the legend outside one column.
private static legend setlegendstyling ( final legend legend ) { legend . setbackground ( background_color ) . setfontfamily ( font_family ) . settextcolor ( text_color ) . setfontsize ( legend_font_size ) ; return legend ; }	Sets the legend styling.
private static highlighter createhighlighter ( ) { return new highlighter ( ) . setshow ( bool_ ) . setshowtooltip ( bool_ ) . settooltipalwaysvisible ( bool_ ) . setkeeptooltipinsidechart ( bool_ ) ; }	Creates the high lighter.
private static highlighter createhighlighternorth ( ) { return new highlighter ( ) . setshow ( bool_ ) . setshowtooltip ( bool_ ) . settooltipalwaysvisible ( bool_ ) . setkeeptooltipinsidechart ( bool_ ) . settooltiplocation ( tooltiplocations . north ) . settooltipaxes ( tooltipaxes . xy_bar ) . setshowmarker ( bool_ ) . setbringseriestofront ( bool_ ) ; }	Creates the high lighter north.
private static seriesdefaults createseriesdefaultpiechart ( ) { return new seriesdefaults ( ) . setrenderer ( seriesrenderers . pie ) . setrendereroptions ( new pierenderer ( ) . setshowdatalabels ( bool_ ) ) . setshadow ( bool_ ) ; }	Creates the series default pie chart.
private static seriesdefaults createdonoutseriesdefault ( ) { return new seriesdefaults ( ) . setrenderer ( seriesrenderers . donut ) . setrendereroptions ( new donutrenderer ( ) . setslicemargin ( slice_margin ) . setstartangle ( start_angle ) . setshowdatalabels ( bool_ ) . setdatalabels ( datalabels . value ) ) ; }	Creates the donout series default.
@ onetomany ( targetentity = documentattachment . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < documentattachment > getdocumentattachmentlist ( ) { return this . documentattachmentlist ; }	Gets the document attachment list.
@ override public void createcommitteeerankingmenubar ( final menubar menubar ) { initapplicationmenubar ( menubar ) ; applicationmenuitemfactory . addrankingmenu ( menubar ) ; createcommitteerankingtopics ( menubar . additem ( committee_ranking_text , null , null ) ) ; }	Creates the committeee ranking menu bar.
@ override public void createcommitteerankingtopics ( final menuitem committeemenuitem ) { committeemenuitem . additem ( overview_text , vaadinicons . group , command_overview ) ; final menuitem listbytopic = committeemenuitem . additem ( ranking_list_by_topic_text , vaadinicons . group , null ) ; final menuitem listitem = listbytopic . additem ( political_work_summary_text , vaadinicons . group , command_datagrid ) ; listitem . setdescription ( current_and_past_member_and_summary_of_polticial_days ) ; final menuitem chartbytopic = committeemenuitem . additem ( chart_by_topic_text , vaadinicons . group , null ) ; chartbytopic . additem ( current_committees_current_members_text , vaadinicons . group , command_current_committees_by_headcount ) ; chartbytopic . additem ( current_parties_active_in_committees_current_assignments , vaadinicons . group , command_committees_by_party ) ; chartbytopic . additem ( current_parties_active_in_committees_total_days_served_in_committees , vaadinicons . group , command_current_committees_by_party_days_served ) ; chartbytopic . additem ( all_committees_total_members , vaadinicons . group , command_all_committees_by_headcount ) ; committeemenuitem . additem ( page_visit_history_text , vaadinicons . group , command_pagevisit_history ) ; }	Creates the committee ranking topics.
@ override public void createoverviewpage ( final verticallayout panelcontent ) { final responsiverow grid = rowutil . creategridlayout ( panelcontent ) ; createbuttonlink ( grid , political_work_summary_text , vaadinicons . group , command_datagrid , str_ ) ; createbuttonlink ( grid , current_committees_current_members_text , vaadinicons . group , command_current_committees_by_headcount , str_ ) ; createbuttonlink ( grid , current_parties_active_in_committees_current_assignments , vaadinicons . group , command_committees_by_party , str_ ) ; createbuttonlink ( grid , current_parties_active_in_committees_total_days_served_in_committees , vaadinicons . group , command_current_committees_by_party_days_served , str_ ) ; createbuttonlink ( grid , all_committees_total_members , vaadinicons . group , command_all_committees_by_headcount , str_ ) ; createbuttonlink ( grid , page_visit_history_text , vaadinicons . group , command_pagevisit_history , str_ ) ; }	Creates the overview page.
private void createoverviewcontent ( final verticallayout panelcontent , final persondata persondata , final viewriksdagenpolitician viewriksdagenpolitician , final string pageid ) { labelfactory . createheader2label ( panelcontent , overview ) ; final link createpoliticianpagelink = getpagelinkfactory ( ) . createpoliticianpagelink ( persondata ) ; panelcontent . addcomponent ( createpoliticianpagelink ) ; final image image = new image ( str_ , new externalresource ( persondata . getimageurl192 ( ) . replace ( str_ , str_ ) ) ) ; final horizontallayout horizontallayout = new horizontallayout ( ) ; horizontallayout . setsizefull ( ) ; panelcontent . addcomponent ( horizontallayout ) ; horizontallayout . addcomponent ( image ) ; getformfactory ( ) . addformpaneltextfields ( horizontallayout , viewriksdagenpolitician , viewriksdagenpolitician . class , as_list ) ; final verticallayout overviewlayout = new verticallayout ( ) ; overviewlayout . setsizefull ( ) ; panelcontent . addcomponent ( overviewlayout ) ; panelcontent . setexpandratio ( overviewlayout , contentratio . large_form ) ; getpoliticianmenuitemfactory ( ) . createoverviewpage ( overviewlayout , pageid ) ; panelcontent . setexpandratio ( createpoliticianpagelink , contentratio . small ) ; panelcontent . setexpandratio ( horizontallayout , contentratio . grid ) ; }	Creates the overview content.
@ onetomany ( targetentity = swedenmunicipalityelectionregiondata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < swedenmunicipalityelectionregiondata > getkommunvalkrets ( ) { return this . kommunvalkrets ; }	Gets the kommunvalkrets.
private static void configureauthentication ( final string role ) { final collection < grantedauthority > authorities = authorityutils . createauthoritylist ( role ) ; final authentication authentication = new usernamepasswordauthenticationtoken ( str_ , str_ , authorities ) ; securitycontextholder . getcontext ( ) . setauthentication ( authentication ) ; }	Configure authentication.
public void setlist ( final list < compliancecheck > list ) { this . list = collections . unmodifiablelist ( listutils . emptyifnull ( list ) ) ; }	Sets the list.
public void setstatusmap ( final map < status , list < ruleviolation > > statusmap ) { this . statusmap = collections . unmodifiablemap ( maputils . emptyifnull ( statusmap ) ) ; }	Sets the status map.
public void setresourcetypemap ( final map < resourcetype , list < ruleviolation > > resourcetypemap ) { this . resourcetypemap = collections . unmodifiablemap ( maputils . emptyifnull ( resourcetypemap ) ) ; }	Sets the resource type map.
@ onetomany ( targetentity = swedenmunicipalitydata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < swedenmunicipalitydata > getkommun ( ) { return this . kommun ; }	Gets the kommun.
@ onetomany ( targetentity = assignmentelement . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < assignmentelement > getuppdrag ( ) { return this . uppdrag ; }	Gets the uppdrag.
@ manytoone ( targetentity = documentproposaldata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public documentproposaldata getproposal ( ) { return proposal ; }	Gets the proposal.
public string getpagepath ( ) { if ( pagereference != null && ! pagereference . isempty ( ) ) { return page + page_separator + pagereference ; } else { return page ; } }	Gets the page path.
private void updateballot ( final string ballotid ) { try { configureauthentication ( ) ; updateservice . updatevotedatadata ( riksdagenapi . getballot ( ballotid ) ) ; } catch ( final datafailureexception e ) { logger . warn ( str_ + ballotid + str_ , e ) ; } finally { clearauthentication ( ) ; } }	Update ballot.
private list < viewriksdagenvotedataballotpartysummarydaily > getmaxsizeviewriksdagenvotedataballotpartysummarydaily ( ) { initpartymap ( ) ; final optional < entry < string , list < viewriksdagenvotedataballotpartysummarydaily > > > first = partymap . entryset ( ) . stream ( ) . sorted ( ( e1 , e2 ) -> integer . compare ( e2 . getvalue ( ) . size ( ) , e1 . getvalue ( ) . size ( ) ) ) . findfirst ( ) ; if ( first . ispresent ( ) ) { return first . get ( ) . getvalue ( ) ; } else { return new arraylist < > ( ) ; } }	Gets the max size view riksdagen vote data ballot party summary daily.
private synchronized void initpartymap ( ) { if ( partymap == null ) { final datacontainer < viewriksdagenvotedataballotpartysummarydaily , riksdagenvotedataballotpartyperiodsummaryembeddedid > partyballotsummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewriksdagenvotedataballotpartysummarydaily . class ) ; partymap = partyballotsummarydailydatacontainer . getall ( ) . parallelstream ( ) . filter ( objects :: nonnull ) . collect ( collectors . groupingby ( t -> t . getembeddedid ( ) . getparty ( ) ) ) ; } }	Inits the party map.
private static void addpartydata ( final dataseries dataseries , final simpledateformat simpledateformat , final list < viewriksdagenvotedataballotpartysummarydaily > list , final function < viewriksdagenvotedataballotpartysummarydaily , object > t ) { dataseries . newseries ( ) ; for ( final viewriksdagenvotedataballotpartysummarydaily viewriksdagenvotedataballotpartysummarydaily : list ) { if ( viewriksdagenvotedataballotpartysummarydaily != null ) { dataseries . add ( simpledateformat . format ( viewriksdagenvotedataballotpartysummarydaily . getembeddedid ( ) . getvotedate ( ) ) , t . apply ( viewriksdagenvotedataballotpartysummarydaily ) ) ; } } }	Adds the party data.
private void createpartyballotchart ( final abstractorderedlayout content , final datavaluecalculator datavaluecalculator ) { final map < string , list < viewriksdagenvotedataballotpartysummarydaily > > map = getpartymap ( ) ; final dataseries dataseries = new dataseries ( ) ; final simpledateformat simpledateformat = new simpledateformat ( dd_mmm_yyyy , locale . english ) ; final series series = new series ( ) ; for ( final entry < string , list < viewriksdagenvotedataballotpartysummarydaily > > entry : map . entryset ( ) ) { if ( ! str_ . equals ( entry . getkey ( ) ) ) { addballotdata ( datavaluecalculator , dataseries , simpledateformat , series , entry ) ; } } addchart ( content , str_ , new dcharts ( ) . setdataseries ( dataseries ) . setoptions ( getchartoptions ( ) . createoptionsxydatefloatlegendinsideonecolumn ( series ) ) . show ( ) , bool_ ) ; }	Creates the party ballot chart.
private void addballotdata ( final datavaluecalculator datavaluecalculator , final dataseries dataseries , final simpledateformat simpledateformat , final series series , final entry < string , list < viewriksdagenvotedataballotpartysummarydaily > > entry ) { series . addseries ( new xyseries ( ) . setlabel ( getpartyname ( entry . getkey ( ) ) ) ) ; dataseries . newseries ( ) ; final list < viewriksdagenvotedataballotpartysummarydaily > list = entry . getvalue ( ) ; for ( final viewriksdagenvotedataballotpartysummarydaily viewriksdagenvotedataballotpartysummarydaily : list ) { if ( viewriksdagenvotedataballotpartysummarydaily != null ) { dataseries . add ( simpledateformat . format ( viewriksdagenvotedataballotpartysummarydaily . getembeddedid ( ) . getvotedate ( ) ) , datavaluecalculator . getdatavalue ( viewriksdagenvotedataballotpartysummarydaily ) ) ; } } }	Adds the ballot data.
private static map < integer , map < string , string > > createorgministrymap ( final map < integer , list < governmentbodyannualsummary > > data ) { final map < integer , map < string , string > > orgministrymap = new hashmap < > ( ) ; final set < entry < integer , list < governmentbodyannualsummary > > > entryset = data . entryset ( ) ; for ( final entry < integer , list < governmentbodyannualsummary > > entry : entryset ) { orgministrymap . put ( entry . getkey ( ) , entry . getvalue ( ) . stream ( ) . collect ( collectors . groupingby ( t -> t . getorgnumber ( ) . replaceall ( str_ , str_ ) , collectors . collectingandthen ( collectors . tolist ( ) , values -> values . get ( num_ ) . getministry ( ) ) ) ) ) ; } return orgministrymap ; }	Creates the org ministry map.
private static void addresultformonth ( final governmentbodyannualoutcomesummary governmentbodyannualoutcomesummary , final int month , final string value ) { if ( value != null && value . length ( ) > num_ ) { governmentbodyannualoutcomesummary . adddata ( month , double . valueof ( value . replaceall ( str_ , str_ ) ) ) ; } }	Adds the result for month.
private static abstractfield < ? > createfield ( final string property ) { if ( stringutils . containsignorecase ( property , hidden_field_name ) ) { return new passwordfield ( ) ; } else { return new textfield ( ) ; } }	Creates the field.
private static < t extends serializable > void createdisplaypropertyconverters ( final list < string > displayproperties , final componentcontainer formcontent , final binder < t > binder , final propertydescriptor [ ] propertydescriptors ) { for ( final string property : displayproperties ) { final class < ? > typeofproperty = gettypeofproperty ( propertydescriptors , property ) ; if ( typeofproperty != null ) { final abstractfield < ? > field = new textfield ( ) ; field . setreadonly ( bool_ ) ; field . setcaption ( property ) ; field . setwidth ( contentsize . full_size ) ; formcontent . addcomponent ( field ) ; final converter converter = getconverterfortype ( typeofproperty ) ; if ( converter != null ) { binder . forfield ( field ) . withconverter ( converter ) . bind ( property ) ; } else { binder . forfield ( field ) . bind ( property ) ; } } } }	Creates the display property converters.
private static converter getconverterfortype ( final class < ? > typeofproperty ) { converter converter ; if ( date . class . equals ( typeofproperty ) ) { converter = new stringtodateconverter ( ) ; } else if ( integer . class . equals ( typeofproperty ) || str_ . equalsignorecase ( typeofproperty . getname ( ) ) ) { converter = new stringtointegerconverter ( str_ ) ; } else if ( long . class . equals ( typeofproperty ) || str_ . equalsignorecase ( typeofproperty . getname ( ) ) ) { converter = new stringtolongconverter ( str_ ) ; } else if ( biginteger . class . equals ( typeofproperty ) ) { converter = new stringtobigintegerconverter ( str_ ) ; } else if ( bigdecimal . class . equals ( typeofproperty ) ) { converter = new stringtobigdecimalconverter ( str_ ) ; } else if ( boolean . class . equals ( typeofproperty ) || str_ . equalsignorecase ( typeofproperty . getname ( ) ) ) { converter = new stringtobooleanconverter ( str_ ) ; } else if ( typeofproperty . isenum ( ) ) { converter = new stringtoenumconverter ( ) ; } else { converter = null ; } return converter ; }	Gets the converter for type.
private static class < ? > gettypeofproperty ( final propertydescriptor [ ] propertydescriptors , final string property ) { for ( final propertydescriptor propertydescriptor : propertydescriptors ) { if ( propertydescriptor . getname ( ) . equalsignorecase ( property ) ) { return propertydescriptor . getpropertytype ( ) ; } } return null ; }	Gets the type of property.
@ onetomany ( targetentity = documentactivitydata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < documentactivitydata > getdocumentactivities ( ) { return this . documentactivities ; }	Gets the document activities.
protected final useraccount getuseraccountfromsecuritycontext ( ) { final securitycontext context = securitycontextholder . getcontext ( ) ; if ( context != null ) { final authentication authentication = context . getauthentication ( ) ; if ( authentication != null ) { return userdao . findfirstbyproperty ( useraccount_ . userid , authentication . getprincipal ( ) . tostring ( ) ) ; } } return null ; }	Gets the user account from security context.
@ onetomany ( targetentity = swedencountydata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < swedencountydata > getcountyregions ( ) { return this . countyregions ; }	Gets the county regions.
@ manytoone ( targetentity = againstproposalcontainer . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public againstproposalcontainer getagainstproposalcontainer ( ) { return againstproposalcontainer ; }	Gets the against proposal container.
@ manytoone ( targetentity = committeeproposalcontainer . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public committeeproposalcontainer getcommitteeproposalcontainer ( ) { return committeeproposalcontainer ; }	Gets the committee proposal container.
@ onetomany ( targetentity = applicationactionevent . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < applicationactionevent > getevents ( ) { if ( events == null ) { events = new arraylist < > ( ) ; } return this . events ; }	Gets the value of the events property.
protected final string getpageid ( final string parameters ) { if ( parameters != null ) { string cleanedstring = parameters ; if ( parameters . contains ( str_ ) ) { cleanedstring = cleanedstring . replace ( cleanedstring . substring ( cleanedstring . indexof ( str_ ) , cleanedstring . lastindexof ( str_ ) + num_ ) , str_ ) ; } return cleanedstring . substring ( cleanedstring . lastindexof ( str_ ) + str_ . length ( ) , cleanedstring . length ( ) ) ; } else { return str_ ; } }	Gets the page id.
protected final int getpagenr ( final string parameters ) { final string cleanedstring = parameters ; string pagenrvalue ; if ( cleanedstring != null && cleanedstring . contains ( str_ ) && cleanedstring . contains ( str_ ) ) { pagenrvalue = cleanedstring . substring ( cleanedstring . indexof ( str_ ) + num_ , cleanedstring . lastindexof ( str_ ) ) ; } else { pagenrvalue = str_ ; } int pagenr = num_ ; if ( pagenrvalue . length ( ) > num_ && ! pagenrvalue . contains ( str_ ) ) { pagenr = integer . parseint ( pagenrvalue ) ; } return pagenr ; }	Gets the page nr.
protected final verticallayout createpanelcontent ( ) { final verticallayout panelcontent = new verticallayout ( ) ; panelcontent . setmargin ( bool_ ) ; panelcontent . setwidth ( num_ , unit . percentage ) ; panelcontent . setheight ( num_ , unit . percentage ) ; panelcontent . setstylename ( str_ ) ; return panelcontent ; }	Creates the panel content.
protected final void createpagevisithistory ( final string pagename , final string pageid , final verticallayout panelcontent ) { final tabsheet tabsheet = new tabsheet ( ) ; tabsheet . setwidth ( num_ , unit . percentage ) ; tabsheet . setheight ( num_ , unit . percentage ) ; panelcontent . addcomponent ( tabsheet ) ; panelcontent . setexpandratio ( tabsheet , contentratio . large ) ; final horizontallayout tabcontentpageitemrankhistory = new horizontallayout ( ) ; tabcontentpageitemrankhistory . setwidth ( num_ , unit . percentage ) ; tabcontentpageitemrankhistory . setheight ( num_ , unit . percentage ) ; final tab tabpageitemrankhistory = tabsheet . addtab ( tabcontentpageitemrankhistory ) ; tabpageitemrankhistory . setcaption ( current_page_visit_history ) ; adminchartdatamanager . createapplicationactioneventpageelementdailysummarychart ( tabcontentpageitemrankhistory , pagename , pageid ) ; final horizontallayout tabcontentpagemodesummary = new horizontallayout ( ) ; tabcontentpagemodesummary . setwidth ( num_ , unit . percentage ) ; tabcontentpagemodesummary . setheight ( num_ , unit . percentage ) ; final tab tabpagemodesummary = tabsheet . addtab ( tabcontentpagemodesummary ) ; tabpagemodesummary . setcaption ( general_page_mode_page_visit ) ; adminchartdatamanager . createapplicationactioneventpagemodedailysummarychart ( tabcontentpagemodesummary , pagename ) ; }	Creates the page visit history.
private static void addpoliticianindicatordata ( final list < viewriksdagenvotedataballotpoliticiansummarydaily > list , final dataseries dataseries , final simpledateformat simpledateformat ) { addpoliticandata ( list , dataseries , simpledateformat , viewriksdagenvotedataballotpoliticiansummarydaily :: getwonpercentage ) ; addpoliticandata ( list , dataseries , simpledateformat , viewriksdagenvotedataballotpoliticiansummarydaily :: getrebelpercentage ) ; addpoliticandata ( list , dataseries , simpledateformat , viewriksdagenvotedataballotpoliticiansummarydaily :: getpoliticianpercentageabsent ) ; addpoliticandata ( list , dataseries , simpledateformat , viewriksdagenvotedataballotpoliticiansummarydaily :: getnumberballots ) ; }	Adds the politician indicator data.
private static void addpoliticandata ( final list < viewriksdagenvotedataballotpoliticiansummarydaily > list , final dataseries dataseries , final simpledateformat simpledateformat , final function < viewriksdagenvotedataballotpoliticiansummarydaily , object > t ) { dataseries . newseries ( ) ; for ( final viewriksdagenvotedataballotpoliticiansummarydaily viewriksdagenvotedataballotpoliticiansummarydaily : list ) { if ( viewriksdagenvotedataballotpoliticiansummarydaily != null ) { dataseries . add ( simpledateformat . format ( viewriksdagenvotedataballotpoliticiansummarydaily . getembeddedid ( ) . getvotedate ( ) ) , t . apply ( viewriksdagenvotedataballotpoliticiansummarydaily ) ) ; } } }	Adds the politican data.
public void setgoogleauthscratchcodes ( final list < integer > googleauthscratchcodes ) { if ( googleauthscratchcodes != null ) { this . googleauthscratchcodes = googleauthscratchcodes . stream ( ) . collect ( collectors . tolist ( ) ) ; } }	Sets the google auth scratch codes.
public final void createroleghant ( final abstractorderedlayout rolesummarylayouttabsheet , final collection < t > assignmentlist ) { final comparator < t > compare = getcomparator ( ) ; final list < t > list = assignmentlist . stream ( ) . filter ( ( final t x ) -> new datetime ( getstepmapping ( ) . getfromdate ( x ) . gettime ( ) ) . getyear ( ) > filter_data_before_year ) . collect ( collectors . tolist ( ) ) ; collections . sort ( list , compare ) ; final gantt creategantt = creategenericgantt ( list , getrolemapping ( ) , getstepmapping ( ) ) ; rolesummarylayouttabsheet . addcomponent ( creategantt ) ; rolesummarylayouttabsheet . setexpandratio ( creategantt , contentratio . grid ) ; }	Creates the role ghant.
private gantt creategenericgantt ( final list < t > assignmentlist , final function < t , string > rolemapping , final stepmapping < t > stepmapping ) { final map < string , list < t > > assignmentlistmap = assignmentlist . stream ( ) . collect ( collectors . groupingby ( rolemapping , treemap :: new , collectors . tolist ( ) ) ) ; final gantt gantt = creategantt ( ) ; if ( ! assignmentlist . isempty ( ) ) { gantt . setstartdate ( stepmapping . getfromdate ( assignmentlist . get ( num_ ) ) ) ; gantt . setenddate ( stripdatesaftercurrentdate ( stepmapping . gettodate ( assignmentlist . get ( assignmentlist . size ( ) - num_ ) ) ) ) ; for ( final entry < string , list < t > > entry : entriessortedbyvalues ( assignmentlistmap , stepmapping ) ) { final string stepname = entry . getkey ( ) ; final step step = new step ( stepname , captionmode . html ) ; step . setdescription ( stepname ) ; final list < t > assignments = entry . getvalue ( ) ; collections . sort ( assignments , getcomparator ( ) ) ; addviewgenericrolemembertostep ( stepname , step , assignments , stepmapping ) ; gantt . addstep ( step ) ; } } return gantt ; }	Creates the generic gantt.
private sortedset < map . entry < string , list < t > > > entriessortedbyvalues ( final map < string , list < t > > map , final stepmapping < t > stepmapping ) { final comparator < ? super entry < string , list < t > > > compare = ( o1 , o2 ) -> { final comparator < t > compare1 = ( o11 , o21 ) -> { final int comparedate = stepmapping . getfromdate ( o11 ) . compareto ( stepmapping . getfromdate ( o21 ) ) ; if ( comparedate == num_ ) { final int comparetype = stepmapping . getrolecode ( o11 ) . compareto ( stepmapping . getrolecode ( o21 ) ) ; if ( comparetype == num_ ) { return stepmapping . getorg ( o11 ) . compareto ( stepmapping . getorg ( o21 ) ) ; } else { return comparetype ; } } return comparedate ; } ; collections . sort ( o1 . getvalue ( ) , compare1 ) ; collections . sort ( o2 . getvalue ( ) , compare1 ) ; return compare1 . compare ( o1 . getvalue ( ) . get ( num_ ) , o2 . getvalue ( ) . get ( num_ ) ) ; } ; final sortedset < map . entry < string , list < t > > > sortedentries = new treeset < > ( compare ) ; sortedentries . addall ( map . entryset ( ) ) ; return sortedentries ; }	Entries sorted by values.
private void addviewgenericrolemembertostep ( final string stepname , final step step , final list < t > assignments , final stepmapping < t > stepmapping ) { for ( final t assignmentdata : assignments ) { string substepname = str_ ; if ( stepmapping . getrolecode ( assignmentdata ) != null ) { substepname = new stringbuilder ( ) . append ( stepmapping . getfirstname ( assignmentdata ) ) . append ( content_separator ) . append ( stepmapping . getlastname ( assignmentdata ) ) . append ( party_start_tag ) . append ( stepmapping . getparty ( assignmentdata ) ) . append ( party_end_tag ) . tostring ( ) ; } final substep samerolesubstep = new substep ( stepname + str_ + substepname , captionmode . html ) ; samerolesubstep . setdescription ( stepname + str_ + substepname ) ; samerolesubstep . setbackgroundcolor ( stepmapping . getbackgroundcolor ( assignmentdata ) ) ; samerolesubstep . setstartdate ( stepmapping . getfromdate ( assignmentdata ) . gettime ( ) ) ; samerolesubstep . setenddate ( stripdatesaftercurrentdate ( stepmapping . gettodate ( assignmentdata ) ) . gettime ( ) ) ; step . addsubstep ( samerolesubstep ) ; } }	Adds the view generic role member to step.
private static final date stripdatesaftercurrentdate ( final date todate ) { final datetime currenttime = new datetime ( ) ; if ( currenttime . isbefore ( todate . gettime ( ) ) ) { return currenttime . plusdays ( num_ ) . todate ( ) ; } else { return todate ; } }	Strip dates after current date.
private static final gantt creategantt ( ) { final gantt gantt = new gantt ( ) ; gantt . setsizefull ( ) ; gantt . setwidth ( num_ , unit . percentage ) ; gantt . setheight ( num_ , unit . percentage ) ; gantt . setresizablesteps ( bool_ ) ; gantt . setmovablesteps ( bool_ ) ; gantt . setresolution ( resolution . week ) ; return gantt ; }	Creates the gantt.
protected final string converttoyearsstring ( final long totaldays ) { final long years = totaldays / days_per_standard_year ; final long days = totaldays - years * days_per_standard_year ; return years + str_ + days + str_ ; }	Convert to years string.
private object loadsecretxadatasource ( final reference ref ) { return loadbasedatasource ( new secretpgxadatasource ( ( ( secretreference ) ref ) . getsecretcredentialsmanager ( ) ) , ref ) ; }	Load secret XA data source.
private void sendmessage ( final dataagentworkorder workorder ) { switch ( workorder . gettarget ( ) ) { case model_external_riksdagen : for ( final riksdagendatasources datasource : riksdagendatasources . values ( ) ) { jmssender . send ( riksdagenapidestination , datasource ) ; } break ; case model_external_worldbank : for ( final worldbankdatasources datasource : worldbankdatasources . values ( ) ) { jmssender . send ( worldbankapidestination , datasource ) ; } break ; default : break ; } }	Send message.
@ onetomany ( targetentity = documentpersonreferencedata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < documentpersonreferencedata > getdocumentpersonreferencelist ( ) { return this . documentpersonreferencelist ; }	Gets the document person reference list.
private static string cleanupdecision ( final string chamber ) { return chamber . touppercase ( locale . english ) . replace ( str_ , str_ ) . replace ( str_ , str_ ) . replace ( str_ , str_ ) . replace ( str_ , str_ ) . replace ( str_ , str_ ) . replace ( str_ , str_ ) ; }	Cleanup decision.
private static string getdocumentname ( final documentstatuscontainer document ) { if ( str_ . equalsignorecase ( document . getdocument ( ) . getdocumenttype ( ) ) ) { return str_ ; } else if ( document . getdocument ( ) . getsubtype ( ) != null && document . getdocument ( ) . getsubtype ( ) . length ( ) > str_ . length ( ) ) { return document . getdocument ( ) . getsubtype ( ) ; } else { return str_ ; } }	Gets the document name.
private static string getcommittteeshortname ( final documentproposaldata proposal ) { final string uppercase = proposal . getprocessedin ( ) . replaceall ( str_ , str_ ) . replace ( str_ , str_ ) . touppercase ( locale . english ) ; if ( uppercase . contains ( str_ ) ) { return uppercase . substring ( num_ , uppercase . indexof ( str_ ) ) ; } else { return uppercase ; } }	Gets the committtee short name.
private void blockbyuserfailedloginattempts ( final string email , final loginblockresultimpl loginblockresultimpl ) { final useraccount userexist = userdao . findfirstbyproperty ( useraccount_ . email , email ) ; if ( userexist != null ) { final applicationconfiguration maxloginattemptsbyuser = applicationconfigurationservice . checkvalueorloaddefault ( max_failed_login_attempts_recent_hour_per_user , blocks_any_login_attempts_after_this_number_is_reached , configurationgroup . authentication , loginblockedaccessimpl . class . getsimplename ( ) , login_blocker , blocks_login_attempts , application_authentication_allow_max_recent_failed_logins_by_user , default_max_login_attempts ) ; final list < applicationactionevent > failedloginsbythisuser = applicationactioneventdao . findlistbyproperty ( new object [ ] { email , applicationoperationtype . authentication , serviceresult . failure . tostring ( ) } , applicationactionevent_ . elementid , applicationactionevent_ . applicationoperation , applicationactionevent_ . applicationmessage ) ; final date onehourago = new date ( system . currenttimemillis ( ) - one_hour ) ; final map < boolean , list < applicationactionevent > > recentoldloginattemptsmap = failedloginsbythisuser . stream ( ) . collect ( collectors . groupingby ( ( final applicationactionevent x ) -> x . getcreateddate ( ) . after ( onehourago ) ) ) ; final list < applicationactionevent > recentfailedlogins = recentoldloginattemptsmap . get ( boolean . true ) ; if ( recentfailedlogins != null && recentfailedlogins . size ( ) > numberutils . toint ( maxloginattemptsbyuser . getpropertyvalue ( ) , default_max_logins ) ) { loginblockresultimpl . setblocked ( bool_ ) ; loginblockresultimpl . addmessages ( blocked_by_more_than_5_recent_login_attempts_by_this_user ) ; } } }	Block by user failed login attempts.
private static void navigatetopage ( final ruleviolation violation ) { if ( violation . getresourcetype ( ) == resourcetype . party ) { ui . getcurrent ( ) . getnavigator ( ) . navigateto ( userviews . party_view_name + page_separator + violation . getid ( ) ) ; } else { ui . getcurrent ( ) . getnavigator ( ) . navigateto ( userviews . politician_view_name + page_separator + violation . getid ( ) ) ; } }	Navigate to page.
protected applicationmanager getapplicationmanager ( ) { return webapplicationcontextutils . getwebapplicationcontext ( ( ( servletrequestattributes ) requestcontextholder . currentrequestattributes ( ) ) . getrequest ( ) . getsession ( bool_ ) . getservletcontext ( ) ) . getbean ( applicationmanager . class ) ; }	Gets the application manager.
protected void shownotification ( final string caption , final string description , final type type ) { notification . show ( caption , description , type ) ; }	Show notification.
@ onetomany ( targetentity = topic . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < topic > gettopic ( ) { return this . topic ; }	Gets the topic.
private static void addsourcesandindicatorstomenu ( final menuitem countryindicators , final map < string , list < viewworldbankindicatordatacountrysummary > > sourceindicatormap ) { final map < string , list < viewworldbankindicatordatacountrysummary > > sortedindicatormap = sourceindicatormap . entryset ( ) . stream ( ) . sorted ( ( e1 , e2 ) -> e1 . getkey ( ) . compareto ( e2 . getkey ( ) ) ) . collect ( collectors . tomap ( map . entry :: getkey , map . entry :: getvalue , ( e1 , e2 ) -> e1 , linkedhashmap :: new ) ) ; for ( final entry < string , list < viewworldbankindicatordatacountrysummary > > entry : sortedindicatormap . entryset ( ) ) { final menuitem sourceitems = countryindicators . additem ( entry . getkey ( ) , null , null ) ; final list < viewworldbankindicatordatacountrysummary > sortedentries = entry . getvalue ( ) . stream ( ) . sorted ( ( e1 , e2 ) -> e1 . getindicatorname ( ) . compareto ( e2 . getindicatorname ( ) ) ) . collect ( collectors . tolist ( ) ) ; for ( final viewworldbankindicatordatacountrysummary indciatorsummary : sortedentries ) { final menuitem additem = sourceitems . additem ( indciatorsummary . getindicatorname ( ) , new pagemodemenucommand ( userviews . country_ranking_view_name , pagemode . indicators , indciatorsummary . getembeddedid ( ) . getindicatorid ( ) ) ) ; additem . setstylename ( str_ ) ; } } }	Adds the sources and indicators to menu.
private map < string , list < viewworldbankindicatordatacountrysummary > > gettopicindicatormap ( ) { final datacontainer < viewworldbankindicatordatacountrysummary , worldbankindicatordatacountrysummaryembeddedid > indicatordatacountrsummarydailydatacontainer = applicationmanager . getdatacontainer ( viewworldbankindicatordatacountrysummary . class ) ; return indicatordatacountrsummarydailydatacontainer . findlistbyembeddedproperty ( viewworldbankindicatordatacountrysummary . class , viewworldbankindicatordatacountrysummary_ . embeddedid , worldbankindicatordatacountrysummaryembeddedid . class , worldbankindicatordatacountrysummaryembeddedid_ . countryid , str_ ) . parallelstream ( ) . filter ( t -> t != null && t . getsourcevalue ( ) != null && t . getendyear ( ) > data_points_for_year_above && t . getdatapoint ( ) > minimum_number_data_points ) . flatmap ( t -> arrays . aslist ( t . gettopics ( ) . split ( str_ ) ) . stream ( ) . map ( topic -> new abstractmap . simpleentry < > ( topic , t ) ) ) . collect ( collectors . groupingby ( simpleentry :: getkey , collectors . mapping ( simpleentry :: getvalue , collectors . tolist ( ) ) ) ) ; }	Gets the topic indicator map.
@ elementcollection @ ordercolumn ( name = str_ ) @ column ( name = str_ ) @ collectiontable ( name = str_ , joincolumns = { @ joincolumn ( name = str_ ) } ) public list < string > getaddress ( ) { if ( address == null ) { address = new arraylist < > ( ) ; } return this . address ; }	Gets the value of the address property.
protected final void addcachehints ( final typedquery < ? > typedquery , final string comment ) { typedquery . sethint ( str_ , cachemode . normal ) ; typedquery . sethint ( str_ , boolean . true ) ; typedquery . sethint ( str_ , comment ) ; }	Adds the cache hints.
protected final list < string > getstringidlist ( final singularattribute < t , string > property ) { final criteriaquery < string > criteria = getcriteriabuilder ( ) . createquery ( string . class ) ; final root < t > root = criteria . from ( persistentclass ) ; criteria . select ( getcriteriabuilder ( ) . construct ( string . class , root . get ( property ) ) ) ; return getentitymanager ( ) . createquery ( criteria ) . getresultlist ( ) ; }	Gets the string id list.
private static list < string > readusingzipinputstream ( final inputstream inputstream ) throws ioexception { final bufferedinputstream bis = new bufferedinputstream ( inputstream ) ; final zipinputstream is = new zipinputstream ( bis ) ; final list < string > list = new arraylist < > ( ) ; try { zipentry entry ; while ( ( entry = is . getnextentry ( ) ) != null ) { if ( entry . getname ( ) . startswith ( str_ ) ) { list . addall ( readcsvcontent ( is ) ) ; } } } finally { is . close ( ) ; } return list ; }	Read using zip input stream.
@ override public void createpagingcontrols ( final abstractorderedlayout content , final string name , final string pageid , final long size , final int pagenr , final int resultperpage ) { final horizontallayout pagingcontrols = new horizontallayout ( ) ; pagingcontrols . setspacing ( bool_ ) ; pagingcontrols . setmargin ( bool_ ) ; final long maxpages = ( size + resultperpage - num_ ) / resultperpage ; final stringbuilder stringbuilder = new stringbuilder ( ) ; stringbuilder . append ( page_header ) . append ( pagenr ) . append ( page_separator ) . append ( maxpages ) . append ( pages_total_results ) . append ( size ) . append ( results_per_page ) . append ( resultperpage ) . append ( show ) ; final label pageinfo = new label ( stringbuilder . tostring ( ) ) ; pagingcontrols . addcomponent ( pageinfo ) ; pagingcontrols . setexpandratio ( pageinfo , contentratio . small ) ; if ( pagenr > page_one ) { addpaginglink ( previous_page , name , pageid , pagenr - num_ , pagingcontrols ) ; } if ( maxpages > page_one && pagenr < maxpages ) { addpaginglink ( next_page , name , pageid , pagenr + num_ , pagingcontrols ) ; } if ( maxpages > limit_for_displaying_start_end_links && pagenr > page_one ) { addpaginglink ( first_page , name , pageid , num_ , pagingcontrols ) ; } if ( maxpages > limit_for_displaying_start_end_links && pagenr < maxpages ) { addpaginglink ( last_page , name , pageid , maxpages , pagingcontrols ) ; } content . addcomponent ( pagingcontrols ) ; content . setexpandratio ( pagingcontrols , contentratio . small2 ) ; }	Creates the paging controls.
private void addpaginglink ( final string label , final string name , final string pageid , final long maxpages , final horizontallayout pagingcontrols ) { final link previouspagelink = pagelinkfactory . createadminpaginglink ( label , name , pageid , string . valueof ( maxpages ) ) ; pagingcontrols . addcomponent ( previouspagelink ) ; pagingcontrols . setexpandratio ( previouspagelink , contentratio . small ) ; }	Adds the paging link.
@ onetomany ( targetentity = againstproposaldata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < againstproposaldata > getagainstproposallist ( ) { return this . againstproposallist ; }	Gets the against proposal list.
private static void adddataserievalue ( final dataseries dataseries , final entry entry , final int value ) { if ( entry . getkey ( ) != null && value > num_ ) { dataseries . add ( first_of_jan + entry . getkey ( ) , value ) ; } }	Adds the data serie value.
private void addannualsummary ( final map < string , list < governmentbodyannualoutcomesummary > > report , final verticallayout content , final string label ) { final dataseries dataseries = new dataseries ( ) ; final series series = new series ( ) ; for ( final entry < string , list < governmentbodyannualoutcomesummary > > entry : report . entryset ( ) ) { final list < governmentbodyannualoutcomesummary > allvalues = entry . getvalue ( ) ; if ( ! allvalues . isempty ( ) ) { addannualsummarydata ( dataseries , series , entry , allvalues ) ; } } addchart ( content , label , new dcharts ( ) . setdataseries ( dataseries ) . setoptions ( getchartoptions ( ) . createoptionsxydatefloatlogyaxislegendoutside ( series ) ) . show ( ) , bool_ ) ; }	Adds the annual summary.
private static void addannualsummarydata ( final dataseries dataseries , final series series , final entry < string , list < governmentbodyannualoutcomesummary > > entry , final list < governmentbodyannualoutcomesummary > allvalues ) { series . addseries ( new xyseries ( ) . setlabel ( entry . getkey ( ) ) . setshowlabel ( bool_ ) ) ; dataseries . newseries ( ) ; final map < integer , list < governmentbodyannualoutcomesummary > > map = allvalues . stream ( ) . collect ( collectors . groupingby ( governmentbodyannualoutcomesummary :: getyear ) ) ; for ( final entry < integer , list < governmentbodyannualoutcomesummary > > data : map . entryset ( ) ) { final list < governmentbodyannualoutcomesummary > values = data . getvalue ( ) ; final double sum = values . stream ( ) . maptodouble ( governmentbodyannualoutcomesummary :: getyeartotal ) . sum ( ) ; if ( sum > num_ ) { dataseries . add ( data . getkey ( ) + first_jan_data_suffix , ( int ) sum ) ; } } }	Adds the annual summary data.
private void addannualdata ( final verticallayout content , final string name , final string label , final map < string , list < governmentbodyannualoutcomesummary > > collect ) { final dataseries dataseries = new dataseries ( ) ; final series series = new series ( ) ; final simpledateformat simpledateformat = new simpledateformat ( str_ , locale . english ) ; for ( final entry < string , list < governmentbodyannualoutcomesummary > > entry : collect . entryset ( ) ) { series . addseries ( new xyseries ( ) . setlabel ( entry . getkey ( ) ) ) ; dataseries . newseries ( ) ; addentrydata ( dataseries , simpledateformat , entry ) ; } addchart ( content , name + label , new dcharts ( ) . setdataseries ( dataseries ) . setoptions ( getchartoptions ( ) . createoptionsxydatefloatlogyaxislegendoutside ( series ) ) . show ( ) , bool_ ) ; }	Adds the annual data.
private static void addentrydata ( final dataseries dataseries , final simpledateformat simpledateformat , final entry < string , list < governmentbodyannualoutcomesummary > > entry ) { for ( final governmentbodyannualoutcomesummary data : entry . getvalue ( ) ) { final map < date , double > valuemap = data . getvaluemap ( ) ; for ( final entry < date , double > entrydata : valuemap . entryset ( ) ) { if ( entrydata . getvalue ( ) != null && entrydata . getvalue ( ) . intvalue ( ) > num_ ) { dataseries . add ( simpledateformat . format ( entrydata . getkey ( ) ) , entrydata . getvalue ( ) . intvalue ( ) ) ; } } } }	Adds the entry data.
private void createministrysummary ( final abstractorderedlayout content , final string field , final string label ) { final dataseries dataseries = new dataseries ( ) ; final series series = new series ( ) ; final map < string , list < governmentbodyannualoutcomesummary > > reportbyministry = esvapi . getgovernmentbodyreportbyministry ( ) ; for ( final entry < string , list < governmentbodyannualoutcomesummary > > entry : reportbyministry . entryset ( ) ) { series . addseries ( new xyseries ( ) . setlabel ( entry . getkey ( ) ) ) ; dataseries . newseries ( ) ; final map < integer , double > annualsummarymap = entry . getvalue ( ) . stream ( ) . filter ( t -> t . getdescriptionfields ( ) . get ( field ) != null ) . collect ( collectors . groupingby ( governmentbodyannualoutcomesummary :: getyear , collectors . summingdouble ( governmentbodyannualoutcomesummary :: getyeartotal ) ) ) ; for ( final entry < integer , double > entrydata : annualsummarymap . entryset ( ) ) { if ( entrydata . getvalue ( ) != null && entrydata . getvalue ( ) . intvalue ( ) > num_ ) { dataseries . add ( entrydata . getkey ( ) + num_ + str_ , entrydata . getvalue ( ) ) ; } } } addchart ( content , label , new dcharts ( ) . setdataseries ( dataseries ) . setoptions ( getchartoptions ( ) . createoptionsxydatefloatlogyaxislegendoutside ( series ) ) . show ( ) , bool_ ) ; }	Creates the ministry summary.
private void createrolelist ( final verticallayout rolesummarylayouttabsheet , final list < assignmentdata > assignmentlist ) { final comparator < assignmentdata > compare = ( o1 , o2 ) -> o1 . getfromdate ( ) . compareto ( o2 . getfromdate ( ) ) ; collections . sort ( assignmentlist , compare ) ; getgridfactory ( ) . createbasicbeanitemgrid ( rolesummarylayouttabsheet , assignmentdata . class , assignmentlist , assignments , column_order , hide_columns , null , null , null ) ; }	Creates the role list.
private static void processall ( final list < documentelement > dokument , final processdatastrategy < documentelement > processstrategy ) { for ( final documentelement documentelement : dokument ) { try { processstrategy . process ( documentelement ) ; } catch ( final runtimeexception e ) { logger . warn ( error_processing_document , documentelement . getid ( ) , e ) ; } } }	Process all.
private void loadandprocessdocumentlist ( final string url , final processdatastrategy < documentelement > processstrategy ) throws xmlagentexception { final documentcontainerelement dokumentlista = ( ( jaxbelement < documentcontainerelement > ) xmlagent . unmarshallxml ( riksdagendocumentlistmarshaller , url , http_dokumentlista_riksdagen_external_model_cia_hack23_com_impl , null , null ) ) . getvalue ( ) ; int resultsize = dokumentlista . getdokument ( ) . size ( ) ; processall ( dokumentlista . getdokument ( ) , processstrategy ) ; final biginteger pages = dokumentlista . gettotalpages ( ) ; for ( int i = num_ ; i < pages . intvalue ( ) ; i ++ ) { final documentcontainerelement otherpagesdokumentlista = ( ( jaxbelement < documentcontainerelement > ) xmlagent . unmarshallxml ( riksdagendocumentlistmarshaller , url + page_property + i , http_dokumentlista_riksdagen_external_model_cia_hack23_com_impl , null , null ) ) . getvalue ( ) ; resultsize = resultsize + otherpagesdokumentlista . getdokument ( ) . size ( ) ; processall ( otherpagesdokumentlista . getdokument ( ) , processstrategy ) ; logger . info ( loading_documents , resultsize , dokumentlista . gethits ( ) ) ; } }	Load and process document list.
private list < documentelement > loaddocumentlist ( final string url , final int maxnumberpages ) throws xmlagentexception { final list < documentelement > result = new arraylist < > ( ) ; documentcontainerelement dokumentlista = ( ( jaxbelement < documentcontainerelement > ) xmlagent . unmarshallxml ( riksdagendocumentlistmarshaller , url , http_dokumentlista_riksdagen_external_model_cia_hack23_com_impl , null , null ) ) . getvalue ( ) ; result . addall ( dokumentlista . getdokument ( ) ) ; final biginteger pages = dokumentlista . gettotalpages ( ) ; for ( int i = num_ ; i < pages . intvalue ( ) && i < maxnumberpages ; i ++ ) { dokumentlista = ( ( jaxbelement < documentcontainerelement > ) xmlagent . unmarshallxml ( riksdagendocumentlistmarshaller , fixbrokenurl ( dokumentlista . getnextpage ( ) ) , http_dokumentlista_riksdagen_external_model_cia_hack23_com_impl , null , null ) ) . getvalue ( ) ; result . addall ( dokumentlista . getdokument ( ) ) ; logger . info ( loading_documents , result . size ( ) , dokumentlista . gethits ( ) ) ; } return result ; }	Load document list.
private static string readwithstringbuffer ( final reader fr ) throws ioexception { final bufferedreader br = new bufferedreader ( fr ) ; string line ; final stringbuilder result = new stringbuilder ( ) ; while ( ( line = br . readline ( ) ) != null ) { result . append ( line ) ; } return result . tostring ( ) ; }	Read with string buffer.
private static string readinputstream ( final string accessurl ) throws ioexception { final url url = new url ( accessurl . replace ( str_ , str_ ) ) ; return readwithstringbuffer ( new bufferedreader ( new inputstreamreader ( url . openconnection ( ) . getinputstream ( ) , standardcharsets . utf_8 ) ) ) ; }	Read input stream.
@ onetomany ( targetentity = ballotdocumentelement . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < ballotdocumentelement > getvotering ( ) { return this . votering ; }	Gets the votering.
private list < governmentbodyannualoutcomesummary > getgovernmentbodylist ( ) { final list < governmentbodyannualoutcomesummary > result = new arraylist < > ( ) ; try { result . addall ( esvgovernmentbodyoperationoutcomereader . readincomecsv ( ) ) ; result . addall ( esvgovernmentbodyoperationoutcomereader . readoutgoingcsv ( ) ) ; } catch ( final ioexception e ) { logger . error ( get_government_body_report , e ) ; return result ; } return result ; }	Gets the government body list.
@ manytoone ( targetentity = personassignmentelement . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public personassignmentelement getpersonassignmentelement ( ) { return personassignmentelement ; }	Gets the person assignment element.
@ manytoone ( targetentity = persondetailelement . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public persondetailelement getpersondetailelement ( ) { return persondetailelement ; }	Gets the person detail element.
public static void createrowitem ( final responsiverow row , final button button , final string description ) { final csslayout layout = new csslayout ( ) ; layout . addstylename ( str_ ) ; responsive . makeresponsive ( layout ) ; layout . setsizeundefined ( ) ; button . addstylename ( itembox ) ; button . addstylename ( title ) ; responsive . makeresponsive ( button ) ; button . setwidth ( num_ , unit . percentage ) ; layout . addcomponent ( button ) ; final label descriptionlabel = new label ( description ) ; descriptionlabel . addstylename ( itembox ) ; responsive . makeresponsive ( descriptionlabel ) ; descriptionlabel . setwidth ( num_ , unit . percentage ) ; layout . addcomponent ( descriptionlabel ) ; row . addcolumn ( ) . withdisplayrules ( display_size_xs_device , displays_size_xm_device , display_size_md_device , display_size_lg_device ) . withcomponent ( layout ) ; }	Creates the row item.
public static responsiverow creategridlayout ( final abstractorderedlayout panelcontent ) { final responsivelayout layout = new responsivelayout ( ) ; responsive . makeresponsive ( layout ) ; layout . addstylename ( str_ ) ; layout . setwidth ( num_ , unit . percentage ) ; layout . setheight ( num_ , unit . percentage ) ; panelcontent . addcomponent ( layout ) ; panelcontent . setexpandratio ( layout , contentratio . large ) ; return layout . addrow ( ) ; }	Creates the grid layout.
private void sendcountryindicatorworkorder ( final map < string , string > currentsaved , final list < string > indicators , final string countryiso2code ) { for ( final string indicator : indicators ) { if ( countryiso2code != null && countryiso2code . length ( ) > num_ && ! currentsaved . containskey ( countryiso2code + str_ + indicator ) ) { final list < string > load = new arraylist < > ( ) ; load . add ( countryiso2code ) ; load . add ( indicator ) ; getjmssender ( ) . send ( dataworkdestination , ( serializable ) load ) ; } } }	Send country indicator work order.
@ manytoone ( targetentity = documentproposalcontainer . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public documentproposalcontainer getdocumentproposal ( ) { return documentproposal ; }	Gets the document proposal.
@ manytoone ( targetentity = documentactivitycontainer . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public documentactivitycontainer getdocumentactivitycontainer ( ) { return documentactivitycontainer ; }	Gets the document activity container.
@ manytoone ( targetentity = documentdetailcontainer . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public documentdetailcontainer getdocumentdetailcontainer ( ) { return documentdetailcontainer ; }	Gets the document detail container.
@ manytoone ( targetentity = documentattachmentcontainer . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public documentattachmentcontainer getdocumentattachmentcontainer ( ) { return documentattachmentcontainer ; }	Gets the document attachment container.
@ manytoone ( targetentity = documentreferencecontainer . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public documentreferencecontainer getdocumentreferencecontainer ( ) { return documentreferencecontainer ; }	Gets the document reference container.
@ manytoone ( targetentity = documentpersonreferencecontainer . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public documentpersonreferencecontainer getdocumentpersonreferencecontainer ( ) { return documentpersonreferencecontainer ; }	Gets the document person reference container.
private map < string , list < viewriksdagenpartydocumentdailysummary > > getviewriksdagenpartydocumentdailysummarymap ( ) { final datacontainer < viewriksdagenpartydocumentdailysummary , riksdagendocumentpartysummaryembeddedid > politicianballotsummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewriksdagenpartydocumentdailysummary . class ) ; return politicianballotsummarydailydatacontainer . getall ( ) . parallelstream ( ) . filter ( objects :: nonnull ) . collect ( collectors . groupingby ( t -> t . getembeddedid ( ) . getpartyshortcode ( ) . touppercase ( locale . english ) . replace ( under_score , empty_string ) . trim ( ) ) ) ; }	Gets the view riksdagen party document daily summary map.
private static void adddocumenthistorybypartydata ( final dataseries dataseries , final series series , final map < string , list < viewriksdagenpartydocumentdailysummary > > map ) { final simpledateformat simpledateformat = new simpledateformat ( dd_mmm_yyyy , locale . english ) ; for ( final entry < string , list < viewriksdagenpartydocumentdailysummary > > entry : map . entryset ( ) ) { series . addseries ( new xyseries ( ) . setlabel ( entry . getkey ( ) ) ) ; dataseries . newseries ( ) ; if ( entry . getvalue ( ) != null ) { for ( final viewriksdagenpartydocumentdailysummary item : entry . getvalue ( ) ) { dataseries . add ( simpledateformat . format ( item . getembeddedid ( ) . getpublicdate ( ) ) , item . gettotal ( ) ) ; } } else { logger . info ( log_msg_missing_data_for_key , entry ) ; } } }	Adds the document history by party data.
private static string [ ] readmissingpersonlist ( ) { final scanner sc = new scanner ( riksdagenpersonsworkgeneratorimpl . class . getresourceasstream ( str_ ) , standardcharsets . utf_8 . name ( ) ) ; final list < string > lines = new arraylist < > ( ) ; while ( sc . hasnextline ( ) ) { lines . add ( sc . nextline ( ) ) ; } sc . close ( ) ; return lines . toarray ( new string [ num_ ] ) ; }	Read missing person list.
private void appendobjectpresentation ( final stringbuilder stringbuilder , final object object ) { try { final string beanproperty = beanutils . getproperty ( object , property ) ; if ( beanproperty != null ) { stringbuilder . append ( beanproperty ) ; } else { addfallbackvalue ( stringbuilder , object ) ; } } catch ( final illegalaccessexception | invocationtargetexception | nosuchmethodexception e ) { logger . warn ( str_ , property , object , e ) ; } stringbuilder . append ( content_separator ) ; }	Append object presentation.
private void addfallbackvalue ( final stringbuilder stringbuilder , final object object ) throws illegalaccessexception , invocationtargetexception , nosuchmethodexception { if ( fallbackcolumn != null ) { final string beanpropertyfallback = beanutils . getproperty ( object , fallbackcolumn ) ; if ( beanpropertyfallback != null ) { stringbuilder . append ( beanpropertyfallback ) ; } } }	Adds the fallback value.
private void reencryptvaultvalues ( final changepasswordrequest servicerequest , final useraccount useraccount ) { final string authkey = vaultmanager . getencryptedvalue ( servicerequest . getcurrentpassword ( ) , useraccount ) ; if ( authkey != null ) { final encryptedvalue encryptedvalue = encryptedvaluedao . findfirstbyproperty ( encryptedvalue_ . userid , useraccount . getuserid ( ) ) ; encryptedvalue . setstorage ( vaultmanager . encryptvalue ( servicerequest . getnewpassword ( ) , useraccount . getuserid ( ) , authkey ) ) ; encryptedvaluedao . merge ( encryptedvalue ) ; } }	Reencrypt vault values.
@ onetomany ( targetentity = swedencountyelectoralarea . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < swedencountyelectoralarea > getlandstingsvalkrets ( ) { return this . landstingsvalkrets ; }	Gets the landstingsvalkrets.
private static void addcommiteesummary ( final stringbuilder stringbuilder , final entry < string , list < proposalcommitteeesummary > > entry , final optional < viewriksdagencommittee > vewriksdagencommittee ) { if ( vewriksdagencommittee . ispresent ( ) ) { final map < string , list < proposalcommitteeesummary > > doctypemap = entry . getvalue ( ) . stream ( ) . collect ( collectors . groupingby ( proposalcommitteeesummary :: getdoctype ) ) ; stringbuilder . append ( str_ ) . append ( vewriksdagencommittee . get ( ) . getembeddedid ( ) . getdetail ( ) ) ; for ( final entry < string , list < proposalcommitteeesummary > > docentry : doctypemap . entryset ( ) ) { if ( docentry . getkey ( ) . length ( ) > num_ && entry . getkey ( ) . length ( ) > num_ ) { addentry ( stringbuilder , entry , docentry ) ; } } } }	Adds the commitee summary.
private static void addentry ( final stringbuilder stringbuilder , final entry < string , list < proposalcommitteeesummary > > entry , final entry < string , list < proposalcommitteeesummary > > docentry ) { stringbuilder . append ( str_ ) . append ( docentry . getvalue ( ) . size ( ) ) . append ( str_ ) . append ( docentry . getkey ( ) ) . append ( str_ ) ; final map < string , list < proposalcommitteeesummary > > decisionmap = docentry . getvalue ( ) . stream ( ) . collect ( collectors . groupingby ( proposalcommitteeesummary :: getdecision ) ) ; for ( final entry < string , list < proposalcommitteeesummary > > decisionentry : decisionmap . entryset ( ) ) { if ( decisionentry . getkey ( ) . length ( ) > num_ && entry . getkey ( ) . length ( ) > num_ ) { stringbuilder . append ( decisionentry . getvalue ( ) . size ( ) ) . append ( str_ ) . append ( decisionentry . getkey ( ) ) . append ( str_ ) ; } } stringbuilder . append ( str_ ) ; }	Adds the entry.
private static void adddecisiondatarows ( final sankeychart chart , final entry < string , list < proposalcommitteeesummary > > entry , final viewriksdagencommittee vewriksdagencommittee ) { final map < string , list < proposalcommitteeesummary > > decisionmap = entry . getvalue ( ) . stream ( ) . collect ( collectors . groupingby ( proposalcommitteeesummary :: getdecision ) ) ; for ( final entry < string , list < proposalcommitteeesummary > > decisionentry : decisionmap . entryset ( ) ) { if ( decisionentry . getkey ( ) . length ( ) > num_ && entry . getkey ( ) . length ( ) > num_ ) { chart . adddatarow ( vewriksdagencommittee . getembeddedid ( ) . getdetail ( ) , decisionentry . getkey ( ) , decisionentry . getvalue ( ) . size ( ) ) ; } } }	Adds the decision data rows.
private static void adddoctypedatarows ( final sankeychart chart , final entry < string , list < proposalcommitteeesummary > > entry , final viewriksdagencommittee vewriksdagencommittee ) { final map < string , list < proposalcommitteeesummary > > doctypemap = entry . getvalue ( ) . stream ( ) . collect ( collectors . groupingby ( proposalcommitteeesummary :: getdoctype ) ) ; for ( final entry < string , list < proposalcommitteeesummary > > docentry : doctypemap . entryset ( ) ) { if ( docentry . getkey ( ) . length ( ) > num_ && entry . getkey ( ) . length ( ) > num_ ) { chart . adddatarow ( docentry . getkey ( ) , vewriksdagencommittee . getembeddedid ( ) . getdetail ( ) , docentry . getvalue ( ) . size ( ) ) ; } } }	Adds the doc type data rows.
private static void adddoctypedecisiondatarows ( final sankeychart chart , final entry < string , list < proposalcommitteeesummary > > entry ) { final map < string , list < proposalcommitteeesummary > > doctypemap = entry . getvalue ( ) . stream ( ) . collect ( collectors . groupingby ( proposalcommitteeesummary :: getdoctype ) ) ; for ( final entry < string , list < proposalcommitteeesummary > > docentry : doctypemap . entryset ( ) ) { final map < string , list < proposalcommitteeesummary > > decisionmap = docentry . getvalue ( ) . stream ( ) . collect ( collectors . groupingby ( proposalcommitteeesummary :: getdecision ) ) ; for ( final entry < string , list < proposalcommitteeesummary > > decisionentry : decisionmap . entryset ( ) ) { if ( decisionentry . getkey ( ) . length ( ) > num_ && entry . getkey ( ) . length ( ) > num_ ) { chart . adddatarow ( docentry . getkey ( ) , decisionentry . getkey ( ) , decisionentry . getvalue ( ) . size ( ) ) ; } } } }	Adds the doc type decision data rows.
public static string getuseridfromsecuritycontext ( ) { final securitycontext context = securitycontextholder . getcontext ( ) ; if ( context != null ) { final authentication authentication = context . getauthentication ( ) ; if ( authentication != null ) { return authentication . getprincipal ( ) . tostring ( ) ; } } return null ; }	Gets the user id from security context.
public static string getrequesturl ( final page current ) { if ( current != null ) { return current . getlocation ( ) . tostring ( ) ; } else { final httpservletrequest httprequest = ( ( servletrequestattributes ) requestcontextholder . currentrequestattributes ( ) ) . getrequest ( ) ; return httprequest . getrequesturl ( ) . tostring ( ) ; } }	Gets the request url.
public static boolean allowroleinsecuritycontext ( final string role ) { boolean result = bool_ ; final securitycontext context = securitycontextholder . getcontext ( ) ; if ( context != null && context . getauthentication ( ) != null ) { final collection < ? extends grantedauthority > authorities = context . getauthentication ( ) . getauthorities ( ) ; for ( final grantedauthority grantedauthority : authorities ) { if ( role . equalsignorecase ( grantedauthority . getauthority ( ) ) ) { result = bool_ ; } } } return result ; }	Allow role in security context.
private map < string , list < viewapplicationactioneventpagedailysummary > > getapplicationactioneventpagedailysummarymap ( ) { final datacontainer < viewapplicationactioneventpagedailysummary , applicationactioneventpageperiodsummaryembeddedid > documenttypesummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewapplicationactioneventpagedailysummary . class ) ; return documenttypesummarydailydatacontainer . getall ( ) . parallelstream ( ) . filter ( objects :: nonnull ) . collect ( collectors . groupingby ( t -> t . getembeddedid ( ) . getpage ( ) ) ) ; }	Gets the application action event page daily summary map.
private map < string , list < viewapplicationactioneventpagemodedailysummary > > getapplicationactioneventpagemodedailysummarymap ( final string page ) { final datacontainer < viewapplicationactioneventpagemodedailysummary , applicationactioneventpagemodeperiodsummaryembeddedid > documenttypesummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewapplicationactioneventpagemodedailysummary . class ) ; final list < viewapplicationactioneventpagemodedailysummary > findorderedlistbyembeddedproperty = documenttypesummarydailydatacontainer . findorderedlistbyembeddedproperty ( viewapplicationactioneventpagemodedailysummary . class , viewapplicationactioneventpagemodedailysummary_ . embeddedid , applicationactioneventpagemodeperiodsummaryembeddedid . class , applicationactioneventpagemodeperiodsummaryembeddedid_ . page , page , applicationactioneventpagemodeperiodsummaryembeddedid_ . createddate ) ; return findorderedlistbyembeddedproperty . parallelstream ( ) . filter ( objects :: nonnull ) . collect ( collectors . groupingby ( t -> t . getembeddedid ( ) . getpagemode ( ) ) ) ; }	Gets the application action event page mode daily summary map.
private list < viewapplicationactioneventpageelementdailysummary > getapplicationactioneventpageelementdailysummarylist ( final string page , final string elementid ) { final datacontainer < viewapplicationactioneventpageelementdailysummary , applicationactioneventpageelementperiodsummaryembeddedid > documenttypesummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewapplicationactioneventpageelementdailysummary . class ) ; final list < viewapplicationactioneventpageelementdailysummary > findorderedlistbyembeddedproperty = documenttypesummarydailydatacontainer . findorderedlistbyembeddedproperty ( viewapplicationactioneventpageelementdailysummary . class , viewapplicationactioneventpageelementdailysummary_ . embeddedid , applicationactioneventpageelementperiodsummaryembeddedid . class , applicationactioneventpageelementperiodsummaryembeddedid_ . elementid , elementid , applicationactioneventpageelementperiodsummaryembeddedid_ . createddate ) ; return findorderedlistbyembeddedproperty . parallelstream ( ) . filter ( t -> t != null && t . getembeddedid ( ) . getpage ( ) . equals ( page ) ) . collect ( collectors . tolist ( ) ) ; }	Gets the application action event page element daily summary list.
private static void addviewapplicationactioneventpageelementdailysummaryvalues ( final string label , final series series , final list < viewapplicationactioneventpageelementdailysummary > list , final dataseries dataseries , final simpledateformat simpledateformat , final tolongfunction < viewapplicationactioneventpageelementdailysummary > t ) { series . addseries ( new xyseries ( ) . setlabel ( label ) ) ; dataseries . newseries ( ) ; for ( final viewapplicationactioneventpageelementdailysummary item : list ) { dataseries . add ( simpledateformat . format ( item . getembeddedid ( ) . getcreateddate ( ) ) , t . applyaslong ( item ) ) ; } }	Adds the view application action event page element daily summary values.
private static void updatepersonassignmentdata ( final personassignmentdata exist , final personassignmentdata update ) { final list < assignmentdata > assignmentlist = update . getassignmentlist ( ) ; for ( final assignmentdata assignmentdata : assignmentlist ) { updateassignmentdata ( exist . getassignmentlist ( ) , assignmentdata ) ; } }	Update person assignment data.
private static void updateassignmentdata ( final list < assignmentdata > assignmentlist , final assignmentdata assignmentdata ) { for ( final assignmentdata matchassignmentdata : assignmentlist ) { if ( matchassignmentdata . getfromdate ( ) . equals ( assignmentdata . getfromdate ( ) ) && matchassignmentdata . getorgcode ( ) . equals ( assignmentdata . getorgcode ( ) ) && matchassignmentdata . getrolecode ( ) . equals ( assignmentdata . getrolecode ( ) ) ) { matchassignmentdata . setstatus ( assignmentdata . getstatus ( ) ) ; matchassignmentdata . settodate ( assignmentdata . gettodate ( ) ) ; return ; } } assignmentlist . add ( assignmentdata ) ; }	Update assignment data.
protected final v inputvalidation ( final t servicerequest ) { final set < constraintviolation < t > > validaterequest = validaterequest ( servicerequest ) ; if ( ! validaterequest . isempty ( ) ) { final createapplicationeventrequest eventrequest = createapplicationeventforservice ( servicerequest ) ; final v response = createerrorresponse ( ) ; handleinputviolations ( eventrequest , validaterequest , response ) ; createapplicationeventservice . processservice ( eventrequest ) ; return response ; } else { return null ; } }	Input validation.
protected final createapplicationeventrequest createbaseapplicationeventrequest ( ) { final createapplicationeventrequest eventrequest = new createapplicationeventrequest ( ) ; final useraccount useraccount = getuseraccountfromsecuritycontext ( ) ; if ( useraccount != null ) { eventrequest . setuserid ( useraccount . getuserid ( ) ) ; } return eventrequest ; }	Creates the base application event request.
private set < constraintviolation < t > > validaterequest ( final t request ) { final validatorfactory factory = validation . builddefaultvalidatorfactory ( ) ; return factory . getvalidator ( ) . validate ( request ) ; }	Validate request.
private string gethumanmessage ( final set < constraintviolation < t > > requestconstraintviolations ) { return requestconstraintviolations . stream ( ) . sorted ( ( p1 , p2 ) -> p1 . getpropertypath ( ) . tostring ( ) . compareto ( p2 . getpropertypath ( ) . tostring ( ) ) ) . map ( p -> p . getpropertypath ( ) . tostring ( ) + str_ + p . getmessage ( ) ) . collect ( collectors . joining ( str_ ) ) ; }	Gets the human message.
private void handleinputviolations ( final createapplicationeventrequest eventrequest , final set < constraintviolation < t > > requestconstraintviolations , final v response ) { final string errormessage = gethumanmessage ( requestconstraintviolations ) ; ( ( abstractresponse ) response ) . seterrormessage ( errormessage ) ; eventrequest . seterrormessage ( errormessage ) ; }	Handle input violations.
private void createdataindicatorsummarychartpanel ( final verticallayout verticallayout , final string indicator ) { final datacontainer < viewworldbankindicatordatacountrysummary , worldbankindicatordatacountrysummaryembeddedid > indicatordatacountrsummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewworldbankindicatordatacountrysummary . class ) ; final optional < viewworldbankindicatordatacountrysummary > indicatorsummary = indicatordatacountrsummarydailydatacontainer . getall ( ) . parallelstream ( ) . filter ( t -> t != null && t . getembeddedid ( ) . getindicatorid ( ) . equals ( indicator ) ) . findfirst ( ) ; viewworldbankindicatordatacountrysummary indicatorsummaryvalue = null ; if ( indicatorsummary . ispresent ( ) ) { indicatorsummaryvalue = indicatorsummary . get ( ) ; getformfactory ( ) . addformpaneltextfields ( verticallayout , indicatorsummaryvalue , viewworldbankindicatordatacountrysummary . class , as_list ) ; } final datacontainer < worldbankdata , serializable > datacontainer = getapplicationmanager ( ) . getdatacontainer ( worldbankdata . class ) ; final list < worldbankdata > datalist = datacontainer . findlistbyembeddedproperty ( worldbankdata . class , worldbankdata_ . indicator , indicator . class , indicator_ . id , indicator ) ; chartdatamanager . createindicatorchart ( verticallayout , datalist , indicatorsummaryvalue ) ; }	Creates the data indicator summary chart panel.
protected final void initapplicationmenubar ( final menubar menubar ) { menubar . removeitems ( ) ; menubar . setwidth ( menu_bar_width ) ; menubar . setstylename ( header_style_name ) ; final menuitem mainviewitem = menubar . additem ( application , vaadinicons . server , null ) ; mainviewitem . additem ( start_text , vaadinicons . star , command_mainview_overview ) ; final menuitem mainitem = mainviewitem . additem ( main , vaadinicons . star , null ) ; mainitem . additem ( page_visit_history_text , vaadinicons . line_chart , command_mainview_pagevisithistory ) ; if ( usercontextutil . allowroleinsecuritycontext ( role_admin ) || usercontextutil . allowroleinsecuritycontext ( role_user ) ) { mainviewitem . additem ( userhome , vaadinicons . user , command_userhome ) ; createadminmenu ( mainviewitem ) ; mainviewitem . additem ( logout , vaadinicons . sign_out , command_logout ) ; } else { mainviewitem . additem ( login , vaadinicons . sign_in , command_login ) ; mainviewitem . additem ( register , vaadinicons . file_add , command_register ) ; } }	Inits the application menu bar.
private static void createadminmenu ( final menuitem mainviewitem ) { if ( usercontextutil . allowroleinsecuritycontext ( role_admin ) ) { final menuitem adminmenuitem = mainviewitem . additem ( admin_text , vaadinicons . server , null ) ; final menuitem configurationmenuitem = adminmenuitem . additem ( configuration , vaadinicons . tools , null ) ; configurationmenuitem . additem ( application_configuration , vaadinicons . tools , command_application_configuration ) ; configurationmenuitem . additem ( agency , vaadinicons . server , command_agency ) ; configurationmenuitem . additem ( portal , vaadinicons . sitemap , command_portal ) ; configurationmenuitem . additem ( country , vaadinicons . flag , command_country ) ; configurationmenuitem . additem ( language , vaadinicons . accessibility , command_language ) ; configurationmenuitem . additem ( language_content , vaadinicons . file_text , command_language_content ) ; final menuitem managementmenuitem = adminmenuitem . additem ( management , vaadinicons . server , null ) ; managementmenuitem . additem ( agent_operations_text , vaadinicons . briefcase , command_agent_operation ) ; managementmenuitem . additem ( data_summary_text , vaadinicons . database , command_datasummary ) ; managementmenuitem . additem ( data_author_summary , vaadinicons . database , command_author_datasummary ) ; managementmenuitem . additem ( email , vaadinicons . mailbox , command_email ) ; managementmenuitem . additem ( system_performance , vaadinicons . dashboard , command_monitoring ) ; final menuitem useractivitymenuitem = adminmenuitem . additem ( user_activity , vaadinicons . database , null ) ; useractivitymenuitem . additem ( application_session , vaadinicons . laptop , command_application_session ) ; useractivitymenuitem . additem ( application_event , vaadinicons . arrows , command_application_events ) ; useractivitymenuitem . additem ( application_event_charts , vaadinicons . arrows , command_application_events_charts ) ; useractivitymenuitem . additem ( useraccount , vaadinicons . group , command_useraccount ) ; } }	Creates the admin menu.
protected final void createbuttonlink ( final responsiverow row , final string linktext , final resource icon , final clicklistener command , final string description ) { final csslayout layout = new csslayout ( ) ; layout . addstylename ( str_ ) ; responsive . makeresponsive ( layout ) ; layout . setsizeundefined ( ) ; final button button = new button ( linktext ) ; responsive . makeresponsive ( button ) ; button . setstylename ( link_style_name ) ; button . addstylename ( str_ ) ; button . addclicklistener ( command ) ; button . seticon ( icon ) ; button . setwidth ( num_ , unit . percentage ) ; layout . addcomponent ( button ) ; final label descriptionlabel = new label ( description ) ; descriptionlabel . addstylename ( str_ ) ; responsive . makeresponsive ( descriptionlabel ) ; descriptionlabel . setwidth ( num_ , unit . percentage ) ; layout . addcomponent ( descriptionlabel ) ; row . addcolumn ( ) . withdisplayrules ( display_size_xs_device , displays_size_xm_device , display_size_md_device , display_size_lg_device ) . withcomponent ( layout ) ; }	Creates the button link.
public void setresultelement ( final list < documentelement > resultelement ) { if ( resultelement != null ) { this . resultelement = resultelement . stream ( ) . collect ( collectors . tolist ( ) ) ; } }	Sets the result element.
@ bean public kiecontainer kiecontainer ( ) { final kieservices kieservices = kieservices . factory . get ( ) ; final kiecontainer kcontainer = kieservices . getkieclasspathcontainer ( ) ; logger . info ( str_ , kcontainer . getclassloader ( ) , kcontainer . getclassloader ( ) . getparent ( ) ) ; final results verifyresults = kcontainer . verify ( ) ; for ( final message m : verifyresults . getmessages ( ) ) { logger . warn ( str_ , m ) ; } final kiebase kiebase = kcontainer . getkiebase ( ) ; for ( final kiepackage kp : kiebase . getkiepackages ( ) ) { for ( final rule rule : kp . getrules ( ) ) { logger . info ( str_ , kp , rule . getname ( ) ) ; } } return kcontainer ; }	Kie container.
@ bean public javers getjavers ( final platformtransactionmanager txmanager ) { final javerssqlrepository sqlrepository = sqlrepositorybuilder . sqlrepository ( ) . withconnectionprovider ( new connectionprovider ( ) { @ override public connection getconnection ( ) { final sessionimpl session = ( sessionimpl ) entitymanager . unwrap ( session . class ) ; return session . connection ( ) ; } } ) . withdialect ( dialectname . postgres ) . build ( ) ; return transactionaljaversbuilder . javers ( ) . withtxmanager ( txmanager ) . withobjectaccesshook ( new hibernateunproxyobjectaccesshook ( ) ) . registerjaversrepository ( sqlrepository ) . withmappingstyle ( mappingstyle . bean ) . build ( ) ; }	Gets the javers.
@ bean public javersauditableaspect javersauditableaspect ( final javers javers , final authorprovider authorprovider , final commitpropertiesprovider commitpropertiesprovider ) { return new javersauditableaspect ( javers , authorprovider , commitpropertiesprovider ) ; }	Javers auditable aspect.
@ bean public authorprovider authorprovider ( ) { return ( ) -> { final securitycontext context = securitycontextholder . getcontext ( ) ; if ( context != null && context . getauthentication ( ) != null ) { return context . getauthentication ( ) . getprincipal ( ) . tostring ( ) ; } else { return str_ ; } } ; }	Author provider.
private void createrolesummary ( final verticallayout rolesummarylayouttabsheet , final list < assignmentdata > assignmentlist , final viewriksdagenpolitician viewriksdagenpolitician ) { final verticallayout layout = new verticallayout ( ) ; layout . setsizefull ( ) ; layout . addcomponent ( new label ( total_assignments + assignmentlist . size ( ) ) ) ; if ( viewriksdagenpolitician != null ) { layout . addcomponent ( new label ( government_experience + converttoyearsstring ( viewriksdagenpolitician . gettotaldaysservedgovernment ( ) ) ) ) ; layout . addcomponent ( new label ( speaker_experience + converttoyearsstring ( viewriksdagenpolitician . gettotaldaysservedspeaker ( ) ) ) ) ; layout . addcomponent ( new label ( committee_experience + converttoyearsstring ( viewriksdagenpolitician . gettotaldaysservedcommittee ( ) ) ) ) ; layout . addcomponent ( new label ( eu_experience + converttoyearsstring ( viewriksdagenpolitician . gettotaldaysservedeu ( ) ) ) ) ; layout . addcomponent ( new label ( parliament_experience + converttoyearsstring ( viewriksdagenpolitician . gettotaldaysservedparliament ( ) ) ) ) ; layout . addcomponent ( new label ( party_experience + converttoyearsstring ( viewriksdagenpolitician . gettotaldaysservedparty ( ) ) ) ) ; } rolesummarylayouttabsheet . addcomponent ( layout ) ; rolesummarylayouttabsheet . setexpandratio ( layout , contentratio . grid ) ; }	Creates the role summary.
private static void addministryperyeartomap ( final string name , final map < integer , list < governmentbodyannualsummary > > map , final hssfsheet mysheet ) { if ( mysheet . getsheetname ( ) . chars ( ) . allmatch ( character :: isdigit ) ) { final int year = integer . parseint ( mysheet . getsheetname ( ) ) ; final list < governmentbodyannualsummary > yearlist = new arraylist < > ( ) ; final iterator < row > rowiterator = mysheet . iterator ( ) ;	Adds the ministry per year to map.
private static void addgovernmentbodyannualsummarytolist ( final string name , final int year , final list < governmentbodyannualsummary > yearlist , final row row ) { if ( row . getlastcellnum ( ) >= expected_column_length ) { final governmentbodyannualsummary governmentbodyannualsummary = creategovernmentbodyannualsummaryfromrow ( year , row ) ; if ( name == null || name . equalsignorecase ( governmentbodyannualsummary . getministry ( ) ) ) { yearlist . add ( governmentbodyannualsummary ) ; } } }	Adds the government body annual summary to list.
private static int getinteger ( final string str ) { if ( str == null || str . trim ( ) . length ( ) == num_ ) { return num_ ; } else { return integer . parseint ( str ) ; } }	Gets the integer.
private static void adddataforyeartomap ( final string name , final map < integer , governmentbodyannualsummary > map , final hssfsheet mysheet ) { if ( mysheet . getsheetname ( ) . chars ( ) . allmatch ( character :: isdigit ) ) { final int year = integer . parseint ( mysheet . getsheetname ( ) ) ; final iterator < row > rowiterator = mysheet . iterator ( ) ; rowiterator . next ( ) ; while ( rowiterator . hasnext ( ) ) { addgovernmentbodyannualsummarytomap ( name , map , year , rowiterator . next ( ) ) ; } } }	Adds the data for year to map.
private static void addgovernmentbodyannualsummarytomap ( final string name , final map < integer , governmentbodyannualsummary > map , final int year , final row row ) { if ( row . getlastcellnum ( ) >= expected_column_length ) { final governmentbodyannualsummary governmentbodyannualsummary = creategovernmentbodyannualsummaryfromrow ( year , row ) ; if ( name == null || name . equalsignorecase ( governmentbodyannualsummary . getname ( ) ) ) { map . put ( year , governmentbodyannualsummary ) ; } } }	Adds the government body annual summary to map.
private static governmentbodyannualsummary creategovernmentbodyannualsummaryfromrow ( final int year , final row row ) { return new governmentbodyannualsummary ( year , defaultvalueifnull ( row . getcell ( name_cell ) ) , getinteger ( defaultvalueifnull ( row . getcell ( consecutive_number_cell ) ) ) , defaultvalueifnull ( row . getcell ( government_body_id_cell ) ) , defaultvalueifnull ( row . getcell ( mcode_cell ) ) , defaultvalueifnull ( row . getcell ( ministry_cell ) ) , defaultvalueifnull ( row . getcell ( org_number_cell ) ) , getinteger ( defaultvalueifnull ( row . getcell ( headcount_cell ) ) ) , getinteger ( defaultvalueifnull ( row . getcell ( annual_headcount_cell ) ) ) , defaultvalueifnull ( row . getcell ( vat_cell ) ) , defaultvalueifnull ( row . getcell ( comment_cell ) ) ) ; }	Creates the government body annual summary from row.
@ manytoone ( targetentity = personassignmentdata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public personassignmentdata getpersonassignmentdata ( ) { return personassignmentdata ; }	Gets the person assignment data.
@ manytoone ( targetentity = persondetaildata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public persondetaildata getpersondetaildata ( ) { return persondetaildata ; }	Gets the person detail data.
private map < string , list < viewriksdagencommitteedecisiontypedailysummary > > getcommitteedecisiontypemap ( ) { final datacontainer < viewriksdagencommitteedecisiontypedailysummary , riksdagencommitteedecisiontypesummaryembeddedid > committeeballotdecisionpartydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewriksdagencommitteedecisiontypedailysummary . class ) ; final date now = new date ( ) ; final date notbefore = new gregoriancalendar ( num_ , calendar . january , num_ ) . gettime ( ) ; return committeeballotdecisionpartydatacontainer . getall ( ) . parallelstream ( ) . filter ( t -> t != null && ! t . getembeddedid ( ) . getdecisiondate ( ) . after ( now ) && ! notbefore . after ( t . getembeddedid ( ) . getdecisiondate ( ) ) ) . collect ( collectors . groupingby ( t -> t . getembeddedid ( ) . getdecisiontype ( ) ) ) ; }	Gets the committee decision type map.
private map < string , list < viewriksdagencommitteedecisiontypeorgdailysummary > > getcommitteedecisiontypeorgmap ( ) { final datacontainer < viewriksdagencommitteedecisiontypeorgdailysummary , riksdagencommitteedecisiontypeorgsummaryembeddedid > committeeballotdecisionpartydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewriksdagencommitteedecisiontypeorgdailysummary . class ) ; return committeeballotdecisionpartydatacontainer . getall ( ) . parallelstream ( ) . filter ( objects :: nonnull ) . collect ( collectors . groupingby ( t -> t . getembeddedid ( ) . getorg ( ) ) ) ; }	Gets the committee decision type org map.
private static void adddecisiontypebyorgdata ( final simpledateformat simpledateformat , final dataseries dataseries , final series series , final map < string , list < viewriksdagencommitteedecisiontypeorgdailysummary > > map ) { for ( final entry < string , list < viewriksdagencommitteedecisiontypeorgdailysummary > > entry : map . entryset ( ) ) { if ( ! empty_string . equals ( entry . getkey ( ) ) ) { final xyseries label = new xyseries ( ) ; label . setlabel ( entry . getkey ( ) ) ; series . addseries ( label ) ; dataseries . newseries ( ) ; for ( final viewriksdagencommitteedecisiontypeorgdailysummary item : entry . getvalue ( ) ) { dataseries . add ( simpledateformat . format ( item . getembeddedid ( ) . getdecisiondate ( ) ) , item . gettotal ( ) ) ; } } } }	Adds the decision type by org data.
private static void displaydocumentattachements ( final verticallayout panelcontent , final list < documentattachment > documentattachmentlist ) { for ( final documentattachment documentattachment : documentattachmentlist ) { if ( pdf . equalsignorecase ( documentattachment . getfiletype ( ) ) ) { final wtpdfviewer wtpdfviewer = new wtpdfviewer ( ) ; wtpdfviewer . setsizefull ( ) ; wtpdfviewer . setresource ( new streamresource ( new streamsourceimplementation ( documentattachment . getfileurl ( ) ) , documentattachment . getfilename ( ) ) ) ; panelcontent . addcomponent ( wtpdfviewer ) ; panelcontent . setexpandratio ( wtpdfviewer , contentratio . large ) ; } else { final verticallayout verticallayout = new verticallayout ( ) ; panelcontent . addcomponent ( verticallayout ) ; panelcontent . setexpandratio ( verticallayout , contentratio . small ) ; final externalattachmentdownloadlink link = new externalattachmentdownloadlink ( documentattachment . getfilename ( ) , documentattachment . getfiletype ( ) , documentattachment . getfileurl ( ) ) ; verticallayout . addcomponent ( link ) ; } } }	Display document attachements.
public static void createheader2label ( final abstractorderedlayout panel , final string content ) { final label label = new label ( content ) ; label . setstylename ( str_ ) ; panel . addcomponent ( label ) ; panel . setexpandratio ( label , contentratio . small ) ; }	Creates a new Label object.
private static key buildkey ( final string userid , final string password ) { return new secretkeyspec ( arrays . copyof ( new sha3 . digest512 ( ) . digest ( ( userid + str_ + password ) . getbytes ( standardcharsets . utf_8 ) ) , key_size_in_bytes ) , algorithm ) ; }	Builds the key.
@ override public final string getrulesummary ( ) { final collection < ruleviolation > values = ruleviolationmap . values ( ) ; final stringbuilder builder = new stringbuilder ( ) ; for ( final ruleviolation ruleviolation : values ) { builder . append ( str_ ) . append ( ruleviolation . getrulename ( ) ) . append ( str_ ) . append ( ruleviolation . getstatus ( ) ) . append ( str_ ) ; } return builder . tostring ( ) ; }	Gets the rule summary.
public final void addviolation ( final status status , final string rulename , final string rulegroup , final string ruledescription , final string positive ) { final ruleviolation currentruleviolation = ruleviolationmap . get ( rulename ) ; if ( currentruleviolation == null || status . ordinal ( ) > currentruleviolation . getstatus ( ) . ordinal ( ) ) { ruleviolationmap . put ( rulename , new ruleviolation ( getid ( ) , getname ( ) , resourcetype , rulename , ruledescription , rulegroup , status , positive ) ) ; } }	Adds the violation.
private static map < string , string > createmapfromlistvote ( final list < votedataembeddedid > list ) { final map < string , string > map = new concurrenthashmap < > ( ) ; for ( final votedataembeddedid documentelement : list ) { map . put ( documentelement . getballotid ( ) , documentelement . getballotid ( ) ) ; } return map ; }	Creates the map from list vote.
private static boolean checkincludedate ( final date after , final list < string > documenttypevalues , final documentelement documentelement ) { try { if ( documentelement . getmadepublicdate ( ) != null && documentelement . getmadepublicdate ( ) . length ( ) > num_ ) { return getdate ( documentelement . getmadepublicdate ( ) ) . after ( after ) && documenttypevalues . contains ( documentelement . getdocumenttype ( ) ) ; } else { return getdate ( documentelement . getcreateddate ( ) ) . after ( after ) && documenttypevalues . contains ( documentelement . getdocumenttype ( ) ) ; } } catch ( final parseexception e ) { logger . warn ( str_ , documentelement , e ) ; return bool_ ; } }	Check include date.
private static date getdate ( final string date ) throws parseexception { if ( riksdagen_java_simple_date_format . length ( ) > date . length ( ) ) { return new simpledateformat ( riksdagen_java_simple_date_time_format , locale . english ) . parse ( date ) ; } else { return new simpledateformat ( riksdagen_java_simple_date_format , locale . english ) . parse ( date ) ; } }	Gets the date.
@ onetomany ( targetentity = swedenpoliticalparty . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < swedenpoliticalparty > getparties ( ) { return this . parties ; }	Gets the parties.
private verticallayout createenablegoogleauthbutton ( ) { final verticallayout formlayout = new verticallayout ( ) ; formlayout . setsizefull ( ) ; final panel formpanel = new panel ( ) ; formpanel . setsizefull ( ) ; formlayout . addcomponent ( formpanel ) ; final formlayout formcontent = new formlayout ( ) ; formpanel . setcontent ( formcontent ) ; final setgoogleauthenticatorcredentialrequest request = new setgoogleauthenticatorcredentialrequest ( ) ; request . setsessionid ( requestcontextholder . currentrequestattributes ( ) . getsessionid ( ) ) ; request . setuserpassword ( str_ ) ; final clicklistener listener = new setgoogleauthenticatorcredentialclicklistener ( request ) ; getformfactory ( ) . addrequestinputformfields ( formcontent , request , setgoogleauthenticatorcredentialrequest . class , as_list , enable_google_authenticator , listener ) ; return formlayout ; }	Creates the enable google auth button.
private verticallayout createdisablegoogleauthbutton ( ) { final verticallayout formlayout = new verticallayout ( ) ; formlayout . setsizefull ( ) ; final panel formpanel = new panel ( ) ; formpanel . setsizefull ( ) ; formlayout . addcomponent ( formpanel ) ; final formlayout formcontent = new formlayout ( ) ; formpanel . setcontent ( formcontent ) ; final disablegoogleauthenticatorcredentialrequest request = new disablegoogleauthenticatorcredentialrequest ( ) ; request . setsessionid ( requestcontextholder . currentrequestattributes ( ) . getsessionid ( ) ) ; request . setuserpassword ( str_ ) ; final clicklistener listener = new disablegoogleauthenticatorcredentialclicklistener ( request ) ; getformfactory ( ) . addrequestinputformfields ( formcontent , request , disablegoogleauthenticatorcredentialrequest . class , as_list , disable_google_authenticator , listener ) ; return formlayout ; }	Creates the disable google auth button.
private verticallayout createchangepasswordbutton ( ) { final verticallayout formlayout = new verticallayout ( ) ; formlayout . setsizefull ( ) ; final panel formpanel = new panel ( ) ; formpanel . setsizefull ( ) ; formlayout . addcomponent ( formpanel ) ; final formlayout formcontent = new formlayout ( ) ; formpanel . setcontent ( formcontent ) ; final changepasswordrequest request = new changepasswordrequest ( ) ; request . setsessionid ( requestcontextholder . currentrequestattributes ( ) . getsessionid ( ) ) ; request . setcurrentpassword ( str_ ) ; request . setnewpassword ( str_ ) ; request . setrepeatnewpassword ( str_ ) ; final clicklistener listener = new changepasswordclicklistener ( request ) ; getformfactory ( ) . addrequestinputformfields ( formcontent , request , changepasswordrequest . class , arrays . aslist ( str_ , str_ , str_ ) , str_ , listener ) ; return formlayout ; }	Creates the change password button.
@ onetomany ( targetentity = documentreferencedata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < documentreferencedata > getdocumentreferencelist ( ) { return this . documentreferencelist ; }	Gets the document reference list.
private static date bestguessvotedate ( final ballotcontainer ballotcontainer ) throws parseexception { final com . hack23 . cia . model . external . riksdagen . votering . impl . ballotdocumentelement ballotdocumentelement = ballotcontainer . getballotdocumentelement ( ) ; date result ; final string createddate = ballotcontainer . getballotdocumentelement ( ) . getcreateddate ( ) ; if ( createddate != null && createddate . length ( ) >= yyyy_mm_dd . length ( ) ) { result = new simpledateformat ( yyyy_mm_dd , locale . english ) . parse ( createddate ) ; } else { final string systemdate = ballotdocumentelement . getsystemdate ( ) ; if ( systemdate != null && systemdate . length ( ) >= yyyy_mm_dd . length ( ) ) { result = new simpledateformat ( yyyy_mm_dd , locale . english ) . parse ( systemdate ) ; } else { result = new simpledateformat ( yyyy_mm_dd , locale . english ) . parse ( ballotdocumentelement . getmadepublicdate ( ) ) ; } } return result ; }	Best guess vote date.
private static date checksamedate ( final list < votedatadto > votelist ) throws parseexception { final set < string > set = new hashset < > ( ) ; date result = null ; for ( final votedatadto votedata : votelist ) { final string votedate = votedata . getvotedate ( ) ; if ( votedate != null && votedate . length ( ) >= yyyy_mm_dd . length ( ) ) { set . add ( votedata . getvotedate ( ) ) ; } } if ( set . size ( ) == contains_one ) { final string datestring = set . iterator ( ) . next ( ) ; result = new simpledateformat ( yyyy_mm_dd , locale . english ) . parse ( datestring ) ; } return result ; }	Check same date.
public date trytofindvalidvotedate ( final ballotcontainer ballotcontainer , final list < votedatadto > votedatalist ) throws parseexception { date ballotdate ; final date samedate = checksamedate ( votedatalist ) ; if ( samedate != null ) { ballotdate = samedate ; } else { ballotdate = bestguessvotedate ( ballotcontainer ) ; } return ballotdate ; }	Try to find valid vote date.
public static string getipinformation ( final webbrowser webbrowser ) { string ipinformation = webbrowser . getaddress ( ) ; final httpservletrequest httprequest = ( ( servletrequestattributes ) requestcontextholder . currentrequestattributes ( ) ) . getrequest ( ) ; final string xforwardedforheader = httprequest . getheader ( x_forwarded_for ) ; if ( xforwardedforheader != null ) { final string [ ] split = xforwardedforheader . split ( str_ ) ; if ( split . length != num_ ) { ipinformation = split [ num_ ] ; } } return ipinformation ; }	Gets the ip information.
public static string getoperatingsystem ( final webbrowser webbrowser ) { synchronized ( user_agent_analyzer ) { final useragent useragent = user_agent_analyzer . parse ( webbrowser . getbrowserapplication ( ) ) ; return useragent . getvalue ( useragent . device_class ) + str_ + useragent . getvalue ( useragent . operating_system_name ) + str_ + useragent . getvalue ( useragent . operating_system_version ) ; } }	Gets the operating system.
@ onetomany ( targetentity = committeeproposaldata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < committeeproposaldata > getcommitteeproposallist ( ) { return this . committeeproposallist ; }	Gets the committee proposal list.
@ onetomany ( targetentity = swedenparliamentelectoralregion . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < swedenparliamentelectoralregion > getparliamentelectoralregions ( ) { return this . parliamentelectoralregions ; }	Gets the parliament electoral regions.
private map < string , list < viewriksdagenorgdocumentdailysummary > > getviewriksdagenorgdocumentdailysummarymap ( ) { final datacontainer < viewriksdagenorgdocumentdailysummary , riksdagendocumentorgsummaryembeddedid > politicianballotsummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewriksdagenorgdocumentdailysummary . class ) ; return politicianballotsummarydailydatacontainer . getall ( ) . parallelstream ( ) . filter ( t -> t != null && ! t . getembeddedid ( ) . getpublicdate ( ) . startswith ( year_prefix ) ) . collect ( collectors . groupingby ( t -> stringescapeutils . unescapehtml4 ( t . getembeddedid ( ) . getorg ( ) ) . touppercase ( locale . english ) . replace ( under_score , empty_string ) . replace ( minus_sign , empty_string ) . trim ( ) ) ) ; }	Gets the view riksdagen org document daily summary map.
private static void adddocumenthistorybyorgdata ( final dataseries dataseries , final series series , final list < viewriksdagenorgdocumentdailysummary > itemlist ) { final map < string , list < viewriksdagenorgdocumentdailysummary > > map = itemlist . parallelstream ( ) . filter ( objects :: nonnull ) . collect ( collectors . groupingby ( t -> stringutils . defaultifblank ( t . getdocumenttype ( ) , no_info ) ) ) ; final simpledateformat simpledateformat = new simpledateformat ( dd_mmm_yyyy , locale . english ) ; final simpledateformat parseincomingdateformat = new simpledateformat ( str_ , locale . english ) ; for ( final entry < string , list < viewriksdagenorgdocumentdailysummary > > entry : map . entryset ( ) ) { addnewdataserie ( dataseries , series , simpledateformat , parseincomingdateformat , entry ) ; } }	Adds the document history by org data.
private static void addnewdataserie ( final dataseries dataseries , final series series , final simpledateformat simpledateformat , final simpledateformat parseincomingdateformat , final entry < string , list < viewriksdagenorgdocumentdailysummary > > entry ) { series . addseries ( new xyseries ( ) . setlabel ( entry . getkey ( ) ) ) ; dataseries . newseries ( ) ; if ( entry . getvalue ( ) != null ) { for ( final viewriksdagenorgdocumentdailysummary item : entry . getvalue ( ) ) { adddataitem ( dataseries , simpledateformat , parseincomingdateformat , item ) ; } } }	Adds the new data serie.
private static void adddataitem ( final dataseries dataseries , final simpledateformat simpledateformat , final simpledateformat parseincomingdateformat , final viewriksdagenorgdocumentdailysummary item ) { if ( item != null && item . getembeddedid ( ) . getpublicdate ( ) . length ( ) > num_ ) { try { dataseries . add ( simpledateformat . format ( parseincomingdateformat . parse ( item . getembeddedid ( ) . getpublicdate ( ) ) ) , item . gettotal ( ) ) ; } catch ( final parseexception e ) { logger . warn ( str_ , item . getembeddedid ( ) . getpublicdate ( ) ) ; } } }	Adds the data item.
@ postconstruct public void initusercommandmap ( ) { usercommandmap . put ( manageuseraccountrequest . accountoperation . delete , account -> { removedatamanager . removeuseraccountapplicationhistory ( account . getuserid ( ) ) ; getuserdao ( ) . delete ( account ) ; return new manageuseraccountresponse ( serviceresult . success ) ; } ) ; usercommandmap . put ( manageuseraccountrequest . accountoperation . unlock , account -> { account . setuserlockstatus ( userlockstatus . unlocked ) ; getuserdao ( ) . persist ( account ) ; return new manageuseraccountresponse ( serviceresult . success ) ; } ) ; usercommandmap . put ( manageuseraccountrequest . accountoperation . lock , account -> { account . setuserlockstatus ( userlockstatus . locked ) ; getuserdao ( ) . persist ( account ) ; return new manageuseraccountresponse ( serviceresult . success ) ; } ) ; }	Inits the user command map.
private manageuseraccountresponse performoperation ( final manageuseraccountrequest servicerequest , final createapplicationeventrequest eventrequest ) { manageuseraccountresponse response ; eventrequest . setelementid ( servicerequest . getuseracountid ( ) ) ; eventrequest . setapplicationmessage ( servicerequest . getaccountoperation ( ) . tostring ( ) ) ; final useraccount accounttomodify = getuserdao ( ) . findfirstbyproperty ( useraccount_ . userid , servicerequest . getuseracountid ( ) ) ; final usercommand usercommand = usercommandmap . get ( servicerequest . getaccountoperation ( ) ) ; if ( accounttomodify != null && usercommand != null ) { response = usercommand . execute ( accounttomodify ) ; } else { response = new manageuseraccountresponse ( serviceresult . failure ) ; } eventrequest . setapplicationmessage ( response . getresult ( ) . tostring ( ) ) ; return response ; }	Perform operation.
@ onetomany ( targetentity = votedatadto . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < votedatadto > getvotedatalist ( ) { return this . votedatalist ; }	Gets the vote data list.
@ onetomany ( targetentity = assignmentdata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < assignmentdata > getassignmentlist ( ) { return this . assignmentlist ; }	Gets the assignment list.
private static void configurecolumnordersandhiddenfields ( final string [ ] columnorder , final string [ ] hidecolumns , final grid grid ) { if ( columnorder != null ) { grid . setcolumnorder ( columnorder ) ; } if ( hidecolumns != null ) { for ( final string o : hidecolumns ) { grid . removecolumn ( o ) ; } } }	Configure column orders and hidden fields.
private static void configurelisteners ( final selectionlistener listener , final grid grid ) { if ( listener != null ) { grid . addselectionlistener ( listener ) ; } }	Configure listeners.
private static void creategridcellfilter ( final string [ ] columnorder , final grid grid , final class datatype ) { if ( columnorder != null ) { final gridcellfilter filter = new gridcellfilter ( grid , datatype ) ; for ( final string column : columnorder ) { if ( grid . getcolumn ( column ) != null ) { filter . settextfilter ( column , bool_ , bool_ ) ; } } } }	Creates the grid cell filter.
private static void setcolumnconverters ( final listpropertyconverter [ ] collectionpropertyconverter , final grid grid ) { if ( collectionpropertyconverter != null ) { for ( final listpropertyconverter converter : collectionpropertyconverter ) { grid . removecolumn ( converter . getcolumn ( ) ) ; final column column = grid . addcolumn ( converter ) ; column . setcaption ( wordutils . capitalize ( converter . getcolumn ( ) ) ) ; column . setid ( converter . getcolumn ( ) ) ; } } }	Sets the column converters.
private map < string , list < viewriksdagendocumenttypedailysummary > > getdocumenttypemap ( ) { final datacontainer < viewriksdagendocumenttypedailysummary , riksdagendocumenttypesummaryembeddedid > documenttypesummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewriksdagendocumenttypedailysummary . class ) ; return documenttypesummarydailydatacontainer . getall ( ) . parallelstream ( ) . filter ( t -> t != null && ! t . getembeddedid ( ) . getpublicdate ( ) . startswith ( year_prefix ) && stringutils . containsignorecase ( mot_prop_bet , t . getembeddedid ( ) . getdocumenttype ( ) ) ) . collect ( collectors . groupingby ( t -> t . getembeddedid ( ) . getdocumenttype ( ) ) ) ; }	Gets the document type map.
private static void adddataseries ( final simpledateformat simpledateformat , final simpledateformat parseinputdateformat , final dataseries dataseries , final series series , final entry < string , list < viewriksdagendocumenttypedailysummary > > entry ) { series . addseries ( new xyseries ( ) . setlabel ( entry . getkey ( ) ) ) ; dataseries . newseries ( ) ; for ( final viewriksdagendocumenttypedailysummary item : entry . getvalue ( ) ) { if ( item != null && item . getembeddedid ( ) . getpublicdate ( ) . length ( ) > num_ ) { try { dataseries . add ( simpledateformat . format ( parseinputdateformat . parse ( item . getembeddedid ( ) . getpublicdate ( ) ) ) , item . gettotal ( ) ) ; } catch ( final parseexception e ) { logger . warn ( str_ , item . getembeddedid ( ) . getpublicdate ( ) ) ; } } } }	Adds the data series.
@ onetomany ( targetentity = swedenelectiontype . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < swedenelectiontype > getelectiontypes ( ) { return this . electiontypes ; }	Gets the election types.
@ basic @ column ( name = str_ ) @ lob public string getballotsummaryitem ( ) { return xmladapterutils . unmarshall ( elementasstring . class , this . getballotsummary ( ) ) ; }	Gets the ballot summary item.
@ embedded @ attributeoverrides ( { @ attributeoverride ( name = str_ , column = @ column ( name = str_ ) ) , @ attributeoverride ( name = str_ , column = @ column ( name = str_ ) ) } ) public adminregion getadminregion ( ) { return adminregion ; }	Gets the adminregion.
@ embedded @ attributeoverrides ( { @ attributeoverride ( name = str_ , column = @ column ( name = str_ ) ) , @ attributeoverride ( name = str_ , column = @ column ( name = str_ ) ) } ) public incomelevel getincomelevel ( ) { return incomelevel ; }	Gets the income level.
@ embedded @ attributeoverrides ( { @ attributeoverride ( name = str_ , column = @ column ( name = str_ ) ) , @ attributeoverride ( name = str_ , column = @ column ( name = str_ ) ) } ) public lendingtype getlendingtype ( ) { return lendingtype ; }	Gets the lending type.
@ manytoone ( targetentity = ballotdocumentdata . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public ballotdocumentdata getballotdocumentdata ( ) { return ballotdocumentdata ; }	Gets the ballot document data.
@ manytoone ( targetentity = ballotdocumentelement . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public ballotdocumentelement getballotdocumentelement ( ) { return ballotdocumentelement ; }	Gets the ballot document element.
public static void main ( string [ ] args ) { if ( args . length == expected_number_args ) { final string encryptvalue = new encryptproperty ( ) . encryptvalue ( args [ num_ ] , args [ num_ ] ) ; system . out . println ( encrypted_value + encryptvalue ) ; system . out . println ( encrypted_property_value + enc_content_prefix + encryptvalue + enc_content_suffix ) ; } else { system . out . println ( help_message ) ; } }	The main method.
public string encryptvalue ( final string symmetrickey , final string value ) { return getencryptor ( symmetrickey ) . encrypt ( value ) ; }	Encrypt value.
private static standardpbestringencryptor getencryptor ( final string symmetrickey ) { security . addprovider ( new bouncycastleprovider ( ) ) ; final standardpbestringencryptor mysecondencryptor = new standardpbestringencryptor ( ) ; mysecondencryptor . setprovidername ( bc_provider_name ) ; mysecondencryptor . setalgorithm ( pbewithsha256and128bitaes_cbc_bc ) ; mysecondencryptor . setpassword ( symmetrickey ) ; return mysecondencryptor ; }	Gets the encryptor.
public string decryptvalue ( final string symmetrickey , final string value ) { return getencryptor ( symmetrickey ) . decrypt ( value ) ; }	Decrypt value.
@ onetomany ( targetentity = swedencountyelectoralregion . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < swedencountyelectoralregion > getcountyelectoralregions ( ) { return this . countyelectoralregions ; }	Gets the county electoral regions.
protected final jobcontextholder getjobcontextholder ( final jobexecutioncontext jobcontext ) { final scheduler scheduler = jobcontext . getscheduler ( ) ; jobcontextholder bean = null ; try { final schedulercontext schedulercontext = scheduler . getcontext ( ) ; final applicationcontext appcontext = ( applicationcontext ) schedulercontext . get ( application_context ) ; bean = appcontext . getbean ( jobcontextholder . class ) ; } catch ( final schedulerexception e ) { logger . error ( str_ , e ) ; } return bean ; }	Gets the job context holder.
@ onetomany ( targetentity = portal . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < portal > getportals ( ) { if ( portals == null ) { portals = new arraylist < > ( ) ; } return this . portals ; }	Gets the value of the portals property.
protected final optional < useraccount > getactiveuseraccount ( ) { final datacontainer < useraccount , long > datacontainer = getapplicationmanager ( ) . getdatacontainer ( useraccount . class ) ; return datacontainer . getallby ( useraccount_ . userid , usercontextutil . getuseridfromsecuritycontext ( ) ) . stream ( ) . findfirst ( ) ; }	Gets the active user account.
@ onetomany ( targetentity = documentelement . class , cascade = { cascadetype . all } ) @ joincolumn ( name = str_ ) public list < documentelement > getdokument ( ) { return this . dokument ; }	Gets the dokument.
protected final void createbasiclayoutwithpanelandfooter ( final string panelname ) { final verticallayout layout = createfullsizeverticallayout ( ) ; final verticallayout pagemodecontent = createfullsizeverticallayout ( bool_ , bool_ ) ; layout . addcomponent ( pagemodecontent ) ; final horizontallayout topheader = new horizontallayout ( ) ; addlogotoheader ( topheader ) ; createtoptitleheader ( topheader ) ; topheaderrightpanel . removeallcomponents ( ) ; topheader . addcomponent ( topheaderrightpanel ) ; topheader . setcomponentalignment ( topheaderrightpanel , alignment . middle_right ) ; topheader . setexpandratio ( topheaderrightpanel , contentratio . large ) ; createtopheaderactionsforusercontext ( ) ; topheaderrightpanel . setwidth ( str_ ) ; topheaderrightpanel . setheight ( str_ ) ; topheader . setwidth ( str_ ) ; topheader . setheight ( str_ ) ; pagemodecontent . addcomponent ( topheader ) ; pagemodecontent . setcomponentalignment ( topheader , alignment . top_center ) ; pagemodecontent . addcomponent ( getbarmenu ( ) ) ; pagemodecontent . setcomponentalignment ( getbarmenu ( ) , alignment . top_center ) ; panel = new panel ( panelname ) ; panel . addstylename ( str_ ) ; panel . setsizefull ( ) ; pagemodecontent . addcomponent ( panel ) ; pagemodecontent . setexpandratio ( panel , contentratio . full_size ) ; pagemodecontent . addcomponent ( pagelinkfactory . createmainviewpagelink ( ) ) ; setcontent ( layout ) ; setwidth ( num_ , unit . percentage ) ; setheight ( num_ , unit . percentage ) ; setsizefull ( ) ; }	Creates the basic layout with panel and footer.
private void createtopheaderactionsforusercontext ( ) { if ( usercontextutil . allowroleinsecuritycontext ( role_admin ) || usercontextutil . allowroleinsecuritycontext ( role_user ) ) { final link userhomepagelink = pagelinkfactory . createuserhomeviewpagelink ( ) ; topheaderrightpanel . addcomponent ( userhomepagelink ) ; topheaderrightpanel . setcomponentalignment ( userhomepagelink , alignment . middle_right ) ; final button logoutbutton = new button ( logout , vaadinicons . sign_out ) ; final logoutrequest logoutrequest = new logoutrequest ( ) ; logoutrequest . setsessionid ( requestcontextholder . currentrequestattributes ( ) . getsessionid ( ) ) ; logoutbutton . addclicklistener ( new logoutclicklistener ( logoutrequest ) ) ; topheaderrightpanel . addcomponent ( logoutbutton ) ; topheaderrightpanel . setcomponentalignment ( logoutbutton , alignment . middle_right ) ; } else { final link createregisterpagelink = pagelinkfactory . createregisterpagelink ( ) ; topheaderrightpanel . addcomponent ( createregisterpagelink ) ; topheaderrightpanel . setcomponentalignment ( createregisterpagelink , alignment . middle_right ) ; final link createloginpagelink = pagelinkfactory . createloginpagelink ( ) ; topheaderrightpanel . addcomponent ( createloginpagelink ) ; topheaderrightpanel . setcomponentalignment ( createloginpagelink , alignment . middle_right ) ; } }	Creates the top header actions for user context.
private static verticallayout createfullsizeverticallayout ( final boolean margin , final boolean spacing ) { final verticallayout layout = new verticallayout ( ) ; layout . setmargin ( margin ) ; layout . setspacing ( spacing ) ; layout . setwidth ( num_ , unit . percentage ) ; layout . setheight ( num_ , unit . percentage ) ; return layout ; }	Creates the full size vertical layout.
private static void addlogotoheader ( final horizontallayout topheader ) { final themeresource cialogoresource = new themeresource ( str_ ) ; final image cialogoimage = new image ( null , cialogoresource ) ; topheader . addcomponent ( cialogoimage ) ; cialogoimage . setwidth ( str_ ) ; cialogoimage . setheight ( str_ ) ; topheader . setcomponentalignment ( cialogoimage , alignment . middle_left ) ; topheader . setexpandratio ( cialogoimage , contentratio . small ) ; }	Adds the logo to header.
private static void createtoptitleheader ( final horizontallayout topheader ) { final horizontallayout toptitleheadertpanel = new horizontallayout ( ) ; final label titlelabel = new label ( str_ ) ; titlelabel . setstylename ( str_ ) ; toptitleheadertpanel . addcomponent ( titlelabel ) ; toptitleheadertpanel . setcomponentalignment ( titlelabel , alignment . middle_left ) ; final label sloganlabel = new label ( str_ ) ; sloganlabel . setstylename ( str_ ) ; toptitleheadertpanel . addcomponent ( sloganlabel ) ; toptitleheadertpanel . setcomponentalignment ( sloganlabel , alignment . middle_right ) ; topheader . addcomponent ( toptitleheadertpanel ) ; topheader . setcomponentalignment ( toptitleheadertpanel , alignment . middle_left ) ; topheader . setexpandratio ( toptitleheadertpanel , contentratio . grid ) ; }	Creates the top title header.
private static int getsmtpport ( final applicationconfiguration smtpport ) { if ( stringutils . isnumeric ( smtpport . getpropertyvalue ( ) ) ) { return integer . parseint ( smtpport . getpropertyvalue ( ) ) ; } else { return integer . parseint ( default_smtp_port ) ; } }	Gets the smtp port.
private languagedata findlanguage ( final string locale ) { for ( final languagedata languagedata : languagedatadao . getall ( ) ) { if ( languagedata . getlanguagecode ( ) . equalsignorecase ( locale ) ) { return languagedata ; } } return null ; }	Find language.
private static list < languagedata > getsupportedlocaleslanguagedata ( ) { final list < languagedata > languages = new arraylist < > ( ) ; for ( final locale locale : dateformat . getavailablelocales ( ) ) { final string localestring = locale . tostring ( ) . trim ( ) ; if ( locale . getdisplaycountry ( locale . english ) . length ( ) == num_ && ! stringutils . isempty ( localestring ) && localestring . length ( ) == expected_locale_length ) { languages . add ( new languagedata ( ) . withcreateddate ( new date ( ) ) . withlanguagecode ( localestring ) . withlanguagename ( locale . getdisplayname ( locale . english ) ) . withlanguageenabled ( boolean . false ) ) ; } } return languages ; }	Gets the supported locales language data.
private static map < string , list < viewriksdagenvotedataballotpartysummary > > createissueconcernmap ( final list < viewriksdagenvotedataballotpartysummary > partyballotlist ) { final map < string , list < viewriksdagenvotedataballotpartysummary > > concernissuepartyballotsummarymap = new hashmap < > ( ) ; for ( final viewriksdagenvotedataballotpartysummary partysummary : partyballotlist ) { if ( partysummary . getembeddedid ( ) . getissue ( ) != null || partysummary . getembeddedid ( ) . getconcern ( ) != null ) { final string key = partysummary . getembeddedid ( ) . getissue ( ) + partysummary . getembeddedid ( ) . getconcern ( ) ; final list < viewriksdagenvotedataballotpartysummary > partysummarlist = concernissuepartyballotsummarymap . computeifabsent ( key , k -> new arraylist < > ( ) ) ; partysummarlist . add ( partysummary ) ; } } return concernissuepartyballotsummarymap ; }	Creates the issue concern map.
public static source setnamespaceonxmlstream ( final inputstream in , final string namespace ) throws jdomexception , ioexception { final saxbuilder sb = new saxbuilder ( new xmlreadersax2factory ( bool_ ) ) ; final document doc = sb . build ( in ) ; doc . getrootelement ( ) . setnamespace ( namespace . getnamespace ( namespace ) ) ; return new jdomsource ( doc ) ; }	Sets the name space on xml stream.
protected final void addchart ( final abstractorderedlayout content , final string caption , final dcharts chart , final boolean fullpage ) { final horizontallayout horizontallayout = new horizontallayout ( ) ; final int browserwindowwidth = getchartwindowwidth ( ) ; final int browserwindowheight = getchartwindowheight ( fullpage ) ; horizontallayout . setwidth ( browserwindowwidth , unit . pixels ) ; horizontallayout . setheight ( browserwindowheight , unit . pixels ) ; horizontallayout . setmargin ( bool_ ) ; horizontallayout . setspacing ( bool_ ) ; horizontallayout . addstylename ( str_ ) ; final panel formpanel = new panel ( ) ; formpanel . setsizefull ( ) ; formpanel . setcontent ( horizontallayout ) ; formpanel . setcaption ( caption ) ; content . addcomponent ( formpanel ) ; content . setexpandratio ( formpanel , contentratio . large ) ; chart . setwidth ( num_ , unit . percentage ) ; chart . setheight ( num_ , unit . percentage ) ; chart . setmarginright ( chart_right_margin ) ; chart . setmarginleft ( chart_left_margin ) ; chart . setmarginbottom ( chart_bottom_margin_size ) ; chart . setmargintop ( chart_top_margin_size ) ; horizontallayout . addcomponent ( chart ) ; chart . setcaption ( caption ) ; }	Adds the chart.
private static int getchartwindowheight ( final boolean fullpage ) { if ( fullpage ) { return math . max ( ( int ) ( page . getcurrent ( ) . getbrowserwindowheight ( ) * height_percentage_full_page ) , minimum_chart_height_full_page ) ; } else { return math . max ( ( int ) ( page . getcurrent ( ) . getbrowserwindowheight ( ) * height_percetage_half_page ) , ninimum_chart_height_half_page ) ; } }	Gets the chart window height.
protected final string getpartyname ( final string party ) { final datacontainer < viewriksdagenparty , string > datacontainer = applicationmanager . getdatacontainer ( viewriksdagenparty . class ) ; final optional < viewriksdagenparty > matchingobjects = datacontainer . getall ( ) . stream ( ) . filter ( ( final viewriksdagenparty p ) -> p . getpartyid ( ) . equalsignorecase ( party ) ) . findfirst ( ) ; if ( matchingobjects . ispresent ( ) ) { return matchingobjects . get ( ) . getpartyname ( ) ; } else { return party ; } }	Gets the party name.
private map < string , list < viewriksdagenpoliticiandocumentdailysummary > > getviewriksdagenpoliticiandocumentdailysummarymap ( ) { final datacontainer < viewriksdagenpoliticiandocumentdailysummary , riksdagendocumentpersonsummaryembeddedid > politicianballotsummarydailydatacontainer = getapplicationmanager ( ) . getdatacontainer ( viewriksdagenpoliticiandocumentdailysummary . class ) ; return politicianballotsummarydailydatacontainer . getall ( ) . parallelstream ( ) . filter ( objects :: nonnull ) . collect ( collectors . groupingby ( t -> t . getembeddedid ( ) . getpersonid ( ) ) ) ; }	Gets the view riksdagen politician document daily summary map.
@ override public useridentity login ( string username , object password , servletrequest request ) { useridentity user = super . login ( username , password , request ) ; if ( user != null ) { httpsession session = ( ( httpservletrequest ) request ) . getsession ( bool_ ) ; authentication cached = new sessionauthentication ( getauthmethod ( ) , user , password ) ; session . setattribute ( sessionauthentication . __j_authenticated , cached ) ; } return user ; }	"login" is copied without changes from FormAuthenticator.
private boolean iswindows ( ) { boolean result ; if ( os_name . tolowercase ( ) . contains ( str_ ) ) { result = bool_ ; } else { result = bool_ ; } getlog ( ) . debug ( str_ + result ) ; return result ; }	Are we running on a flavour of Windows.
protected void startandroidemulator ( ) throws mojoexecutionexception { parseparameters ( ) ; commandexecutor executor = commandexecutor . factory . createdefaultcommmandexecutor ( ) ; executor . setlogger ( this . getlog ( ) ) ; try { string filename ; if ( iswindows ( ) ) { filename = writeemulatorstartscriptwindows ( ) ; } else { filename = writeemulatorstartscriptunix ( ) ; } final androiddebugbridge androiddebugbridge = initandroiddebugbridge ( ) ; if ( androiddebugbridge . isconnected ( ) ) { waitforinitialdevicelist ( androiddebugbridge ) ; list < idevice > devices = arrays . aslist ( androiddebugbridge . getdevices ( ) ) ; int numberofdevices = devices . size ( ) ; getlog ( ) . info ( str_ + numberofdevices + str_ ) ; idevice existingemulator = findexistingemulator ( devices ) ; if ( existingemulator == null ) { getlog ( ) . info ( start_emulator_msg + filename ) ; executor . executecommand ( filename , null ) ; getlog ( ) . info ( start_emulator_wait_msg + parsedwait ) ;	Start the Android Emulator with the specified options.
void unlockemulator ( androiddebugbridge androiddebugbridge ) { if ( emulatorunlock ) { idevice myemulator = findexistingemulator ( arrays . aslist ( androiddebugbridge . getdevices ( ) ) ) ; int deviceport = extractportfromdevice ( myemulator ) ; if ( deviceport == - num_ ) { getlog ( ) . info ( str_ + devicehelper . getdescriptivename ( myemulator ) ) ; } else { getlog ( ) . info ( str_ + devicehelper . getdescriptivename ( myemulator ) ) ; sendemulatorcommand ( deviceport , str_ ) ; sendemulatorcommand ( deviceport , str_ ) ; sendemulatorcommand ( deviceport , str_ ) ; sendemulatorcommand ( deviceport , str_ ) ; } } }	Unlocks the emulator.
private string writeemulatorstartscriptwindows ( ) throws mojoexecutionexception { string filename = script_folder + str_ ; file file = new file ( filename ) ; printwriter writer = null ; try { writer = new printwriter ( new filewriter ( file ) ) ;	Writes the script to start the emulator in the background for windows based environments.
private string writeemulatorstartscriptunix ( ) throws mojoexecutionexception { string filename = script_folder + str_ ; file sh ; sh = new file ( str_ ) ; if ( ! sh . exists ( ) ) { sh = new file ( str_ ) ; } if ( ! sh . exists ( ) ) { sh = new file ( str_ ) ; } file file = new file ( filename ) ; printwriter writer = null ; try { writer = new printwriter ( new filewriter ( file ) ) ; writer . println ( str_ + sh . getabsolutepath ( ) ) ; writer . print ( assemblestartcommandline ( ) ) ; writer . print ( str_ ) ;	Writes the script to start the emulator in the background for unix based environments.
protected void stopandroidemulator ( ) throws mojoexecutionexception { parseparameters ( ) ; final androiddebugbridge androiddebugbridge = initandroiddebugbridge ( ) ; if ( androiddebugbridge . isconnected ( ) ) { list < idevice > devices = arrays . aslist ( androiddebugbridge . getdevices ( ) ) ; int numberofdevices = devices . size ( ) ; getlog ( ) . info ( str_ + numberofdevices + str_ ) ; for ( idevice device : devices ) { if ( device . isemulator ( ) ) { if ( isexistingemulator ( device ) ) { stopemulator ( device ) ; } } else { getlog ( ) . info ( str_ + devicehelper . getdescriptivename ( device ) ) ; } } } }	Stop the running Android Emulator.
private void stopemulator ( idevice device ) { int deviceport = extractportfromdevice ( device ) ; if ( deviceport == - num_ ) { getlog ( ) . info ( str_ + devicehelper . getdescriptivename ( device ) ) ; } else { getlog ( ) . info ( str_ + devicehelper . getdescriptivename ( device ) ) ; sendemulatorcommand ( deviceport , str_ ) ; boolean killed = sendemulatorcommand ( deviceport , str_ ) ; if ( ! killed ) { getlog ( ) . info ( str_ + devicehelper . getdescriptivename ( device ) ) ; } else { getlog ( ) . info ( str_ + devicehelper . getdescriptivename ( device ) ) ; } } }	This method contains the code required to stop an emulator.
private string assemblestartcommandline ( ) throws mojoexecutionexception { string emulatorpath ; if ( ! str_ . equals ( parsedemulatorlocation ) ) { emulatorpath = new file ( parsedemulatorlocation , parsedexecutable ) . getabsolutepath ( ) ; } else { emulatorpath = new file ( getandroidsdk ( ) . gettoolspath ( ) , parsedexecutable ) . getabsolutepath ( ) ; } stringbuilder startcommandline = new stringbuilder ( str_ ) . append ( emulatorpath ) . append ( str_ ) . append ( str_ ) . append ( parsedavd ) . append ( str_ ) ; if ( ! stringutils . isempty ( parsedoptions ) ) { startcommandline . append ( parsedoptions ) ; } getlog ( ) . info ( str_ + startcommandline ) ; return startcommandline . tostring ( ) ; }	Assemble the command line for starting the emulator based on the parameters supplied in the pom file and on thecommand line.
private string determineexecutable ( ) { string emulator ; if ( emulatorexecutable != null ) { emulator = emulatorexecutable ; } else { emulator = str_ ; } return emulator ; }	Get executable value for emulator from command line options or default to "emulator".
string determinewait ( ) { string wait ; if ( emulatorwait != null ) { wait = emulatorwait ; } else { wait = str_ ; } return wait ; }	Get wait value for emulator from command line option.
private string determineoptions ( ) { string options ; if ( emulatoroptions != null ) { options = emulatoroptions ; } else { options = str_ ; } return options ; }	Get options value for emulator from command line option.
string determineavd ( ) { string avd ; if ( emulatoravd != null ) { avd = emulatoravd ; } else { avd = str_ ; } return avd ; }	Get avd value for emulator from command line option.
string determineemulatorlocation ( ) { string location ; if ( emulatorlocation != null ) { location = emulatorlocation ; } else { location = str_ ; } return location ; }	Get location value for emulator from command line option.
public static void unjar ( jarfile jarfile , file outputdirectory , unjarlistener unjarlistener ) throws ioexception { for ( enumeration en = jarfile . entries ( ) ; en . hasmoreelements ( ) ; ) { jarentry entry = ( jarentry ) en . nextelement ( ) ; file entryfile = new file ( outputdirectory , entry . getname ( ) ) ; if ( unjarlistener . include ( entry ) ) {	Unjars the specified jar file into the the specified directory.
private map < string , string > calculatesourcedestinationmapping ( ) throws mojoexecutionexception { map < string , string > result = new hashmap < string , string > ( ) ; file sourcefile = new file ( parsedsource ) ; final string destinationpath ; if ( parseddestination . endswith ( str_ ) ) { destinationpath = parseddestination + sourcefile . getname ( ) ; } else { destinationpath = parseddestination ; } if ( sourcefile . isfile ( ) ) {	Calculates a map which contains all files to be pushed to the device oremulator.
public void visit ( dependencynode node , boolean collecting ) { if ( collecting ) { dependencies . add ( node . getartifact ( ) ) ; } if ( matchestarget ( node . getartifact ( ) ) ) { collecting = bool_ ; log . debug ( str_ + node . getartifact ( ) ) ; } for ( final dependencynode child : node . getchildren ( ) ) { visit ( child , collecting ) ; } }	Visits all nodes from the given node and collects dependencies.
private artifact resolveartifact ( artifact artifact ) throws mojoexecutionexception { final artifactresolutionrequest artifactresolutionrequest = new artifactresolutionrequest ( ) ; artifactresolutionrequest . setartifact ( artifact ) ; if ( remoteartifactrepositories != null && ! remoteartifactrepositories . isempty ( ) ) { artifactresolutionrequest . setremoterepositories ( remoteartifactrepositories ) ; } final artifactresolutionresult resolutionresult = this . artifactresolver . resolve ( artifactresolutionrequest ) ; log . debug ( str_ + artifact ) ; if ( resolutionresult . getartifacts ( ) . size ( ) == num_ ) { throw new mojoexecutionexception ( str_ + artifact + str_ + str_ ) ; } if ( resolutionresult . getartifacts ( ) . size ( ) > num_ ) { log . debug ( str_ + resolutionresult . getartifacts ( ) ) ; throw new mojoexecutionexception ( str_ + artifact + str_ + resolutionresult . getartifacts ( ) ) ; } final artifact resolvedartifact = resolutionresult . getartifacts ( ) . iterator ( ) . next ( ) ; log . debug ( str_ + resolvedartifact ) ; return resolvedartifact ; }	Resolves an artifact to a particular repository.
private void waituntilconnected ( androiddebugbridge adb ) { int trials = num_ ; final int connectionwaittime = num_ ; while ( trials > num_ ) { try { thread . sleep ( connectionwaittime ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } if ( adb . isconnected ( ) ) { break ; } trials -- ; } }	Run a wait loop until adb is connected or trials run out.
protected void waitforinitialdevicelist ( final androiddebugbridge androiddebugbridge ) throws mojoexecutionexception { if ( ! androiddebugbridge . hasinitialdevicelist ( ) ) { getlog ( ) . info ( str_ ) ; long limittime = system . currenttimemillis ( ) + adb_timeout_ms ; while ( ! androiddebugbridge . hasinitialdevicelist ( ) && ( system . currenttimemillis ( ) < limittime ) ) { try { thread . sleep ( num_ ) ; } catch ( interruptedexception e ) { throw new mojoexecutionexception ( str_ ) ; } } if ( ! androiddebugbridge . hasinitialdevicelist ( ) ) { getlog ( ) . error ( str_ ) ; } } }	Wait for the Android Debug Bridge to return an initial device list.
protected void deployapk ( final file apkfile ) throws mojoexecutionexception , mojofailureexception { if ( undeploybeforedeploy ) { undeployapk ( apkfile ) ; } dowithdevices ( new devicecallback ( ) { public void dowithdevice ( final idevice device ) throws mojoexecutionexception { string deviceloglineprefix = devicehelper . getdeviceloglineprefix ( device ) ; try { device . installpackage ( apkfile . getabsolutepath ( ) , bool_ ) ; getlog ( ) . info ( deviceloglineprefix + str_ + apkfile . getabsolutepath ( ) ) ; getlog ( ) . debug ( str_ + devicehelper . getdescriptivename ( device ) ) ; } catch ( installexception e ) { throw new mojoexecutionexception ( deviceloglineprefix + str_ + apkfile . getabsolutepath ( ) + str_ , e ) ; } } } ) ; }	Deploys an apk file to a connected emulator or usb device.
protected void deploybuiltapk ( ) throws mojoexecutionexception , mojofailureexception { if ( project . getpackaging ( ) . equals ( apk ) ) { file apkfile = new file ( targetdirectory , finalname + str_ + apk ) ; deployapk ( apkfile ) ; } else { getlog ( ) . info ( str_ ) ; } }	Deploy the apk built with the current projects to all attached devices and emulators.Skips other projects in a multi-module build without terminating.
protected boolean undeployapk ( file apkfile ) throws mojoexecutionexception , mojofailureexception { final string packagename ; packagename = extractpackagenamefromapk ( apkfile ) ; return undeployapk ( packagename ) ; }	Undeploys an apk from a connected emulator or usb device.
protected boolean undeployapk ( final string packagename ) throws mojoexecutionexception , mojofailureexception { final atomicboolean result = new atomicboolean ( bool_ ) ;	Undeploys an apk, specified by package name, from a connected emulatoror usb device.
protected string extractpackagenamefromapk ( file apkfile ) throws mojoexecutionexception { commandexecutor executor = commandexecutor . factory . createdefaultcommmandexecutor ( ) ; executor . setlogger ( this . getlog ( ) ) ; executor . setcapturestdout ( bool_ ) ; executor . setcapturestderr ( bool_ ) ; aaptcommandbuilder commandbuilder = aaptcommandbuilder . dump ( getlog ( ) ) . xmltree ( ) . setpathtoapk ( apkfile . getabsolutepath ( ) ) . addassetfile ( str_ ) ; getlog ( ) . info ( getandroidsdk ( ) . getaaptpath ( ) + str_ + commandbuilder . tostring ( ) ) ; try { executor . executecommand ( getandroidsdk ( ) . getaaptpath ( ) , commandbuilder . build ( ) , bool_ ) ; final string xmltree = executor . getstandardout ( ) ; return extractpackagenamefromandroidmanifestxmltree ( xmltree ) ; } catch ( executionexception e ) { throw new mojoexecutionexception ( str_ + apkfile ) ; } finally { string errout = executor . getstandarderror ( ) ; if ( ( errout != null ) && ( errout . trim ( ) . length ( ) > num_ ) ) { getlog ( ) . error ( errout ) ; } } }	Extracts the package name from an apk file.
protected string extractpackagenamefromandroidartifact ( artifact artifact ) throws mojoexecutionexception { final file unpackedlibfolder = getunpackedlibfolder ( artifact ) ; final file manifest = new file ( unpackedlibfolder , str_ ) ; if ( ! manifest . exists ( ) ) { throw new mojoexecutionexception ( str_ + unpackedlibfolder ) ; } return extractpackagenamefromandroidmanifest ( manifest ) ; }	Provides package name for android artifact.
protected string extractinstrumentationrunnerfromandroidmanifest ( file manifestfile ) throws mojoexecutionexception { final url xmlurl ; try { xmlurl = manifestfile . touri ( ) . tourl ( ) ; } catch ( malformedurlexception e ) { throw new mojoexecutionexception ( str_ + manifestfile , e ) ; } final documentcontainer documentcontainer = new documentcontainer ( xmlurl ) ; final object instrumentationrunner ; try { instrumentationrunner = jxpathcontext . newcontext ( documentcontainer ) . getvalue ( str_ , string . class ) ; } catch ( jxpathnotfoundexception e ) { return null ; } return ( string ) instrumentationrunner ; }	Attempts to find the instrumentation test runner from inside the AndroidManifest.xml file.
public void execute ( ) throws mojoexecutionexception , mojofailureexception { dowithdevices ( new devicecallback ( ) { public void dowithdevice ( final idevice device ) throws mojoexecutionexception { getlog ( ) . info ( devicehelper . getdescriptivenamewithstatus ( device ) ) ; } } ) ; }	Display a list of attached devices.
private static void copystreamwithoutclosing ( inputstream in , outputstream out ) throws ioexception { final int buffersize = num_ ; byte [ ] b = new byte [ buffersize ] ; int n ; while ( ( n = in . read ( b ) ) != - num_ ) { out . write ( b , num_ , n ) ; } }	Copies an input stream into an output stream but does not close the streams.
private void copygdbserver ( file destinationdirectory , string architecture ) throws mojoexecutionexception { try { final file destdir = new file ( destinationdirectory , architecture ) ; if ( destdir . exists ( ) ) {	Copy the Ndk GdbServer into the architecture output folder if the folder exists but the GdbServer doesn't.
private static file getjavaexecutable ( ) { final string javahome = system . getproperty ( str_ ) ; final string slash = file . separator ; return new file ( javahome + slash + str_ + slash + str_ ) ; }	Figure out the full path to the current java executable.
public string getproguardjarpath ( ) { file directory = new file ( gettoolspath ( ) , str_ + file . separator + str_ + file . separator ) ; file proguardjar = new file ( directory , str_ ) ; if ( proguardjar . exists ( ) ) { return proguardjar . getabsolutepath ( ) ; } throw new invalidsdkexception ( str_ + proguardjar ) ; }	Get the path for proguard.jar.
public string getshrinkedandroidjarpath ( ) { file shrinkedandroidjar = new file ( getbuildtoolslibdirectorypath ( ) , str_ ) ; if ( shrinkedandroidjar . exists ( ) ) { return shrinkedandroidjar . getabsolutepath ( ) ; } throw new invalidsdkexception ( str_ + shrinkedandroidjar ) ; }	Get the path for shrinkedAndroid.jar.
public string getbuildtoolslibdirectorypath ( ) { file buildtoolslib = new file ( getbuildtoolinfo ( ) . getlocation ( ) , str_ ) ; if ( buildtoolslib . exists ( ) ) { return buildtoolslib . getabsolutepath ( ) ; } throw new invalidsdkexception ( str_ + buildtoolslib ) ; }	Get the path for build-tools lib directory.
public string getmaindexclassesrulespath ( ) { file maindexclassesrules = new file ( getbuildtoolinfo ( ) . getlocation ( ) , str_ ) ; if ( maindexclassesrules . exists ( ) ) { return maindexclassesrules . getabsolutepath ( ) ; } throw new invalidsdkexception ( str_ + maindexclassesrules ) ; }	Get the path for mainDexClasses.rules.
public string getandroidpath ( ) { string cmd = str_ ; string ext = sdkconstants . currentplatform ( ) == num_ ? str_ : str_ ; return getpathfortool ( cmd + ext ) ; }	Get the android tool path.
public file getandroidjar ( ) throws mojoexecutionexception { final string androidjarpath = androidtarget . getpath ( iandroidtarget . android_jar ) ; if ( androidjarpath == null ) { throw new mojoexecutionexception ( str_ + androidtarget . getlocation ( ) ) ; } return new file ( androidjarpath ) ; }	Resolves the android.jar from this SDK.
public file getplatform ( ) { assertpathisdirectory ( sdkpath ) ; final file platformsdirectory = new file ( sdkpath , platforms_folder_name ) ; assertpathisdirectory ( platformsdirectory ) ; final file platformdirectory ; if ( androidtarget == null ) { iandroidtarget latesttarget = null ; androidtargetmanager targetmanager = sdkmanager . getandroidtargetmanager ( progressindicator ) ; for ( iandroidtarget target : targetmanager . gettargets ( progressindicator ) ) { if ( target . isplatform ( ) ) { if ( latesttarget == null || target . getversion ( ) . getapilevel ( ) > latesttarget . getversion ( ) . getapilevel ( ) ) { latesttarget = target ; } } } platformdirectory = new file ( latesttarget . getlocation ( ) ) ; } else { platformdirectory = new file ( androidtarget . getlocation ( ) ) ; } assertpathisdirectory ( platformdirectory ) ; return platformdirectory ; }	This method returns the previously specified version.
private void loadsdktoolsmajorversion ( ) { file propfile = new file ( sdkpath , str_ + source_properties_filename ) ; properties properties = new properties ( ) ; try { properties . load ( new fileinputstream ( propfile ) ) ; } catch ( ioexception e ) { throw new invalidsdkexception ( str_ + propfile . getabsolutefile ( ) ) ; } if ( properties . containskey ( sdk_tools_revision_property ) ) { try { string versionstring = properties . getproperty ( sdk_tools_revision_property ) ; string majorversion ; if ( versionstring . matches ( str_ ) ) { string [ ] versions = versionstring . split ( str_ ) ; majorversion = versions [ num_ ] ; } else { majorversion = versionstring ; } sdkmajorversion = integer . parseint ( majorversion ) ; } catch ( numberformatexception e ) { throw new invalidsdkexception ( str_ + sdk_tools_revision_property + str_ + properties . getproperty ( sdk_tools_revision_property ) ) ; } } }	Loads the SDK Tools version.
public void execute ( ) throws mojoexecutionexception , mojofailureexception {	Generates the sources.
protected void copymanifest ( ) throws mojoexecutionexception { getlog ( ) . debug ( str_ + androidmanifestfile + str_ + destinationmanifestfile ) ; if ( androidmanifestfile == null ) { getlog ( ) . debug ( str_ ) ; return ; } try { documentbuilderfactory dbf = documentbuilderfactory . newinstance ( ) ; documentbuilder db = dbf . newdocumentbuilder ( ) ; document doc = db . parse ( androidmanifestfile ) ; source source = new domsource ( doc ) ; transformerfactory xfactory = transformerfactory . newinstance ( ) ; transformer xformer = xfactory . newtransformer ( ) ; xformer . setoutputproperty ( outputkeys . omit_xml_declaration , str_ ) ; filewriter writer = null ; try { destinationmanifestfile . getparentfile ( ) . mkdirs ( ) ; writer = new filewriter ( destinationmanifestfile , bool_ ) ; if ( doc . getxmlencoding ( ) != null && doc . getxmlversion ( ) != null ) { string xmldecl = string . format ( str_ , doc . getxmlversion ( ) , doc . getxmlencoding ( ) ) ; writer . write ( xmldecl ) ; } result result = new streamresult ( writer ) ; xformer . transform ( source , result ) ; getlog ( ) . info ( str_ + androidmanifestfile + str_ + destinationmanifestfile ) ; } finally { ioutils . closequietly ( writer ) ; } } catch ( exception e ) { getlog ( ) . error ( str_ ) ; throw new mojoexecutionexception ( str_ , e ) ; } }	Copy the AndroidManifest.xml from androidManifestFile to destinationManifestFile.
protected void extractsourcedependencies ( ) throws mojoexecutionexception { for ( artifact artifact : getdirectdependencyartifacts ( ) ) { string type = artifact . gettype ( ) ; if ( type . equals ( apksources ) ) { getlog ( ) . debug ( str_ + artifact + str_ + artifact . getfile ( ) + str_ ) ; final file apksourcesfile = resolveartifacttofile ( artifact ) ; getlog ( ) . debug ( str_ + apksourcesfile + str_ ) ; extractapksources ( apksourcesfile ) ; } } if ( extracteddependenciesjavaresources . exists ( ) ) { projecthelper . addresource ( project , extracteddependenciesjavaresources . getabsolutepath ( ) , null , null ) ; project . addcompilesourceroot ( extracteddependenciesjavasources . getabsolutepath ( ) ) ; } }	Extract the source dependencies.
private void extractapklib ( artifact apklibartifact ) throws mojoexecutionexception { getunpackedlibhelper ( ) . extractapklib ( apklibartifact ) ;	Extracts ApkLib and adds the assets and apklib sources and resources to the build.
private void extractaarlib ( artifact aarartifact ) throws mojoexecutionexception { getunpackedlibhelper ( ) . extractaarlib ( aarartifact ) ;	Extracts AarLib and if this is an APK build then adds the assets and resources to the build.
private void checkforapklibdependencies ( ) throws mojoexecutionexception { final boolean isaarbuild = project . getpackaging ( ) . equals ( aar ) ; final dependencyresolver dependencyresolver = getdependencyresolver ( ) ; final set < artifact > allartifacts = project . getartifacts ( ) ; set < artifact > dependencyartifacts = getartifactresolverhelper ( ) . getfilteredartifacts ( allartifacts ) ; boolean foundapklib = bool_ ; for ( artifact artifact : dependencyartifacts ) { final string type = artifact . gettype ( ) ; if ( type . equals ( apklib ) && isaarbuild ) { getlog ( ) . warn ( str_ + artifact . getid ( ) ) ; foundapklib = bool_ ; } else if ( type . equals ( aar ) ) { final set < artifact > dependencies = dependencyresolver . getlibrarydependenciesfor ( session , repositorysystem , artifact ) ; for ( artifact dependency : dependencies ) { if ( dependency . gettype ( ) . equals ( apklib ) ) { getlog ( ) . warn ( str_ + artifact . getid ( ) + str_ + dependency . getid ( ) ) ; foundapklib = bool_ ; } } } } if ( foundapklib ) { getlog ( ) . warn ( str_ + str_ + str_ ) ; } }	Traverses the list of project dependencies looking for &quot;AAR depends on APKLIB&quot; artifact combinationthat has been deprecated.
map < string , set < artifact > > getpackagecomparemap ( set < artifact > dependencyartifacts ) throws mojoexecutionexception { if ( dependencyartifacts == null ) { throw new illegalargumentexception ( str_ ) ; } map < string , set < artifact > > packagecomparemap = new hashmap < string , set < artifact > > ( ) ; set < artifact > artifactset = new hashset < artifact > ( ) ; artifactset . add ( project . getartifact ( ) ) ; packagecomparemap . put ( getandroidmanifestpackagename ( ) , artifactset ) ; for ( artifact artifact : dependencyartifacts ) { string libpackage = extractpackagenamefromandroidartifact ( artifact ) ; set < artifact > artifacts = packagecomparemap . get ( libpackage ) ; if ( artifacts == null ) { artifacts = new hashset < artifact > ( ) ; packagecomparemap . put ( libpackage , artifacts ) ; } artifacts . add ( artifact ) ; } return packagecomparemap ; }	Provides map with all provided dependencies or project itself grouped by package name.
private void generatecorrectrjavaforapklibdependencies ( resourceclassgenerator resourcegenerator ) throws mojoexecutionexception { getlog ( ) . debug ( str_ ) ; getlog ( ) . debug ( str_ ) ;	Generate correct R.java for apklibs dependencies of a current project.
private void generatecorrectrjavaforaardependencies ( resourceclassgenerator resourcegenerator ) throws mojoexecutionexception {	Generate correct R.java for aar dependencies of a current project.
private void generaterforapklibdependency ( artifact apklibartifact ) throws mojoexecutionexception { final file unpackdir = getunpackedlibfolder ( apklibartifact ) ; getlog ( ) . debug ( str_ + apklibartifact . getgroupid ( ) + str_ + apklibartifact . getartifactid ( ) ) ; final file apklibmanifest = new file ( unpackdir , str_ ) ; final file apklibresdir = new file ( unpackdir , str_ ) ; list < file > dependenciesresdirectories = new arraylist < file > ( ) ; final set < artifact > apklibdeps = getdependencyresolver ( ) . getlibrarydependenciesfor ( this . session , this . repositorysystem , apklibartifact ) ; getlog ( ) . debug ( str_ + apklibartifact + str_ + apklibdeps ) ; for ( artifact dependency : apklibdeps ) {	Executes aapt to generate the R class for the given apklib.
private boolean isbuildconfigpresent ( artifact artifact ) throws mojoexecutionexception { string deppackagename = extractpackagenamefromandroidartifact ( artifact ) ; return isbuildconfigpresent ( artifact , deppackagename ) ; }	Check if given artifact includes a matching BuildConfig class.
private boolean isbuildconfigpresent ( artifact artifact , string packagename ) throws mojoexecutionexception { try { jarfile jar = new jarfile ( getunpackedaarclassesjar ( artifact ) ) ; jarentry entry = jar . getjarentry ( packagename . replace ( str_ , str_ ) + str_ ) ; return ( entry != null ) ; } catch ( ioexception e ) { getlog ( ) . error ( str_ , e ) ; throw new mojoexecutionexception ( str_ , e ) ; } }	Check whether the artifact includes a BuildConfig located in a given package.
private set < file > getdexinputfiles ( ) throws mojoexecutionexception { set < file > inputs = new hashset < file > ( ) ; if ( obfuscatedjar != null && obfuscatedjar . exists ( ) ) {	Gets the input files for dex.
public void execute ( ) throws mojoexecutionexception , mojofailureexception {	Execute the mojo by parsing the confign and actually doing the zipalign.
private static void checkclientsecretsfile ( googleclientsecrets clientsecrets ) { if ( clientsecrets . getdetails ( ) . getclientid ( ) . startswith ( str_ ) || clientsecrets . getdetails ( ) . getclientsecret ( ) . startswith ( str_ ) ) { log . error ( str_ + str_ ) ; system . exit ( num_ ) ; } }	Ensure the client secrets file has been filled out.
private void addlibsjarstoclasspath ( unpackedlibhelper helper , mavenproject project , artifact artifact ) throws mavenexecutionexception { try { final file unpacklibfolder = helper . getunpackedlibfolder ( artifact ) ; final file artifactfile = helper . getartifacttofile ( artifact ) ; zipfile zipfile = new zipfile ( artifactfile ) ; enumeration enumeration = zipfile . entries ( ) ; while ( enumeration . hasmoreelements ( ) ) { zipentry entry = ( zipentry ) enumeration . nextelement ( ) ; string entryname = entry . getname ( ) ;	Add jar files in libs into the project classpath.
private void addclassestoclasspath ( unpackedlibhelper helper , mavenproject project , artifact artifact ) throws mavenexecutionexception {	Add the dependent library classes to the project classpath.
public static string getgav ( ) { stringbuilder builder = new stringbuilder ( ) . append ( groupid ) . append ( colon ) . append ( artifactid ) . append ( colon ) . append ( version ) ; return builder . tostring ( ) ; }	Get the Maven GAV string of the plugin.
private void collectjvmarguments ( list < string > commands ) { if ( parsedjvmarguments != null ) { for ( string jvmargument : parsedjvmarguments ) {	Convert the jvm arguments in parsedJvmArguments as populated by the config in format as needed by the javacommand.
private file getjvmlibrary ( string filename ) { file libfile = new file ( getjavalibdir ( ) , filename ) ; if ( ! libfile . exists ( ) ) { libfile = new file ( getaltjavalibdir ( ) , filename ) ; if ( ! libfile . exists ( ) ) { libfile = null ; } } return libfile ; }	Finds a library file in either the primary or alternate lib directory.
public string gettoolchain ( file file ) throws mojoexecutionexception { string resolvedndktoolchain = null ;	Tries to resolve the toolchain based on the path of the file.
public string getndkbuildpath ( ) { if ( systemutils . is_os_windows ) { return new file ( ndkpath , str_ ) . getabsolutepath ( ) ; } else { return new file ( ndkpath , str_ ) . getabsolutepath ( ) ; } }	Returns the complete path for the ndk-build tool, based on this NDK.
private document readmanifest ( file manifestfile ) throws ioexception , parserconfigurationexception , saxexception { documentbuilderfactory dbf = documentbuilderfactory . newinstance ( ) ; documentbuilder db = dbf . newdocumentbuilder ( ) ; document doc = db . parse ( manifestfile ) ; return doc ; }	Read manifest using JAXP.
private void writemanifest ( file manifestfile , document doc ) throws ioexception , transformerexception { transformerfactory xfactory = transformerfactory . newinstance ( ) ; transformer xformer = xfactory . newtransformer ( ) ; xformer . setoutputproperty ( outputkeys . omit_xml_declaration , str_ ) ; source source = new domsource ( doc ) ; outputstreamwriter writer = null ; try { manifestfile . getparentfile ( ) . mkdirs ( ) ; string encoding = doc . getxmlencoding ( ) != null ? doc . getxmlencoding ( ) : str_ ; writer = new outputstreamwriter ( new fileoutputstream ( manifestfile , bool_ ) , encoding ) ; if ( doc . getxmlencoding ( ) != null && doc . getxmlversion ( ) != null ) { string xmldecl = string . format ( str_ , doc . getxmlversion ( ) , doc . getxmlencoding ( ) ) ; writer . write ( xmldecl ) ; } result result = new streamresult ( writer ) ; xformer . transform ( source , result ) ; } finally { ioutils . closequietly ( writer ) ; } }	Write manifest using JAXP transformer.
private void exportproperties ( ) { project . getproperties ( ) . setproperty ( str_ , parsedversionname ) ; project . getproperties ( ) . setproperty ( str_ , string . valueof ( parsedversioncodeautoincrement ) ) ; project . getproperties ( ) . setproperty ( str_ , string . valueof ( parsedversioncodeupdatefromversion ) ) ; project . getproperties ( ) . setproperty ( str_ , string . valueof ( parseddebuggable ) ) ; if ( parsedshareduserid != null ) { project . getproperties ( ) . setproperty ( str_ , parsedshareduserid ) ; } }	Expose the version properties and other simple parsed manifest entries.
private void performversioncodeupdatefromversion ( element manifestelement ) throws mojoexecutionexception { string verstring = project . getversion ( ) ; getlog ( ) . debug ( str_ + verstring ) ; string vercode = generateversioncodefromversionname ( verstring ) ; getlog ( ) . info ( str_ + attr_version_code + str_ + vercode ) ; manifestelement . setattribute ( attr_version_code , vercode ) ; project . getproperties ( ) . setproperty ( str_ , string . valueof ( vercode ) ) ; }	If the specified version name cannot be properly parsed then fall back toan automatic method.If the version can be parsed then generate a version code from theversion components.
public static string extractarchitecturefromartifact ( artifact artifact , final string defaultarchitecture ) { string classifier = artifact . getclassifier ( ) ; if ( classifier != null ) {	Extracts, if embedded correctly, the artifacts architecture from its classifier.
public string [ ] getfilenames ( file basedirectory ) { if ( ! basedirectory . exists ( ) ) { return new string [ num_ ] ; } final directoryscanner directoryscanner = new directoryscanner ( ) ; directoryscanner . setbasedir ( basedirectory ) ; directoryscanner . setincludes ( includes ) ; directoryscanner . adddefaultexcludes ( ) ; directoryscanner . scan ( ) ; return directoryscanner . getincludedfiles ( ) ; }	Finds the files in the supplied folder that match the configured includes.
public static string encrypt ( string data , string key ) { try { cipher c = cipher . getinstance ( str_ ) ; c . init ( cipher . encrypt_mode , secretkeyfactory . getinstance ( str_ ) . generatesecret ( new deskeyspec ( key . getbytes ( ) ) ) ) ; return hex . encodehexstring ( c . dofinal ( data . getbytes ( ) ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return null ; }	Convert data to encrypted hex string.
public static string decrypt ( string data , string key ) { try { cipher c = cipher . getinstance ( str_ ) ; c . init ( cipher . decrypt_mode , secretkeyfactory . getinstance ( str_ ) . generatesecret ( new deskeyspec ( key . getbytes ( ) ) ) ) ; return new string ( c . dofinal ( hex . decodehex ( data . tochararray ( ) ) ) , charset . defaultcharset ( ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return null ; }	Convert encrypted hex string to UTF-8 string.
private static string readname ( byte data [ ] , int offset , hashset < integer > jumps ) throws ioexception { int c = data [ offset ] & num_ ; if ( ( c & num_ ) == num_ ) { c = ( ( c & num_ ) << num_ ) + ( data [ offset + num_ ] & num_ ) ; if ( jumps . contains ( c ) ) { throw new dnsexception ( str_ , str_ ) ; } jumps . add ( c ) ; return readname ( data , c , jumps ) ; } if ( c == num_ ) { return str_ ; } string s = new string ( data , offset + num_ , c ) ; string t = readname ( data , offset + num_ + c , jumps ) ; if ( t . length ( ) > num_ ) { s = s + str_ + t ; } return s ; }	Parse a domain name starting at the given offset.
protected static int todigit ( final char ch , final int index ) throws hexdecodeexception { final int digit = character . digit ( ch , num_ ) ; if ( digit == - num_ ) { throw new hexdecodeexception ( str_ + ch + str_ + index ) ; } return digit ; }	Converts a hexadecimal character to an integer.
private boolean trytomove ( float deltay ) {	if deltaY > 0, tryToMove the content down.
public synchronized void startlistening ( context context ) { if ( ! mlistening ) { mcontext = context ; intentfilter filter = new intentfilter ( ) ; filter . addaction ( connectivitymanager . connectivity_action ) ; context . registerreceiver ( mreceiver , filter ) ; mlistening = bool_ ; } }	This method starts listening for network connectivity state changes.
public synchronized void stoplistening ( ) { if ( mlistening ) { mcontext . unregisterreceiver ( mreceiver ) ; mcontext = null ; mnetworkinfo = null ; mothernetworkinfo = null ; misfailover = bool_ ; mreason = null ; mlistening = bool_ ; } }	This method stops this class from listening for network changes.
public void send ( ) throws ioexception { hashmap < string , requestdata . uploadfileinfo > uploadfiles = mrequestdata . getuploadfiles ( ) ; hashmap < string , object > mpostdata = mrequestdata . getpostdata ( ) ;	post data to Server.
public void addformfield ( string name , string value ) { mwriter . append ( str_ + mboundary ) . append ( line_feed ) ; mwriter . append ( str_ + name + str_ ) . append ( line_feed ) ; mwriter . append ( str_ + mcharset ) . append ( line_feed ) ; mwriter . append ( line_feed ) ; mwriter . append ( value ) . append ( line_feed ) ; mwriter . flush ( ) ; }	Adds a form field to the request.
public void addfilepart ( string fieldname , file uploadfile , string filename ) throws ioexception { if ( textutils . isempty ( filename ) ) { filename = uploadfile . getname ( ) ; } mwriter . append ( str_ + mboundary ) . append ( line_feed ) ; mwriter . append ( str_ + fieldname + str_ + filename + str_ ) . append ( line_feed ) ; mwriter . append ( str_ + urlconnection . guesscontenttypefromname ( filename ) ) . append ( line_feed ) ; mwriter . append ( str_ ) . append ( line_feed ) ; mwriter . append ( line_feed ) ; mwriter . flush ( ) ; fileinputstream inputstream = new fileinputstream ( uploadfile ) ; byte [ ] buffer = new byte [ num_ ] ; int bytesread = - num_ ; while ( ( bytesread = inputstream . read ( buffer ) ) != - num_ ) { moutputstream . write ( buffer , num_ , bytesread ) ; } moutputstream . flush ( ) ; inputstream . close ( ) ; mwriter . append ( line_feed ) ; mwriter . flush ( ) ; }	Adds a upload file section to the request.
public bitmapdrawable createbitmapdrawable ( resources resources , bitmap bitmap ) { if ( bitmap == null ) { return null ; } bitmapdrawable drawable = null ; if ( bitmap != null ) { if ( version . hashoneycomb ( ) ) {	Create a BitmapDrawable which can be managed in ImageProvider.
public void preloadimages ( string [ ] urls ) { int len = urls . length ; for ( int i = num_ ; i < len ; i ++ ) { imageloadrequest request = new imageloadrequest ( urls [ i ] ) ; final imagetask imagetask = createimagetask ( request ) ; imagetask . setispreload ( ) ; addimagetask ( imagetask , null ) ; } }	Load the image in advance.
public void detachimageviewfromimagetask ( imagetask imagetask , cubeimageview imageview ) { imagetask . removeimageview ( imageview ) ; if ( imagetask . isloading ( ) ) { if ( ! imagetask . ispreload ( ) && ! imagetask . stillhasrelatedimageview ( ) ) { loadimagetask task = mloadworklist . get ( imagetask . getidentitykey ( ) ) ; if ( task != null ) { task . cancel ( ) ; } if ( debug ) { clog . d ( log_tag , str_ , imagetask ) ; } } } if ( ! imagetask . stillhasrelatedimageview ( ) ) { imagetask . trytorecycle ( ) ; } }	Detach the ImageView from the ImageTask.
public void addimagetask ( imagetask imagetask , cubeimageview imageview ) { if ( ! mhasbeenaddedtocomponentmanager ) { clog . w ( log_tag , str_ , this ) ; } loadimagetask runningtask = mloadworklist . get ( imagetask . getidentitykey ( ) ) ; if ( runningtask != null ) { if ( imageview != null ) { if ( debug ) { clog . d ( log_tag , msg_attack_to_running_task , imagetask , runningtask . getimagetask ( ) ) ; } runningtask . getimagetask ( ) . addimageview ( imageview ) ; runningtask . getimagetask ( ) . notifyloading ( mimageloadhandler , imageview ) ; } return ; } else { imagetask . addimageview ( imageview ) ; } imagetask . onloading ( mimageloadhandler ) ; loadimagetask loadimagetask = createloadimagetask ( imagetask ) ; mloadworklist . put ( imagetask . getidentitykey ( ) , loadimagetask ) ; mimagetaskexecutor . execute ( loadimagetask ) ; }	Add the ImageTask into loading list.
public boolean querycache ( imagetask imagetask , cubeimageview imageview ) { if ( null == mimageprovider ) { return bool_ ; } bitmapdrawable drawable = mimageprovider . getbitmapfrommemcache ( imagetask ) ; if ( imagetask . getstatistics ( ) != null ) { imagetask . getstatistics ( ) . s0_aftercheckmemorycache ( drawable != null ) ; } if ( drawable == null ) { return bool_ ; } if ( debug ) { clog . d ( log_tag , msg_hit_cache , imagetask , drawable . getintrinsicwidth ( ) , drawable . getintrinsicheight ( ) ) ; } imagetask . addimageview ( imageview ) ; imagetask . onloadtaskfinish ( drawable , mimageloadhandler ) ; return bool_ ; }	Check weather this imageTask has cache Drawable data.
public void recoverwork ( ) { if ( debug ) { clog . d ( log_tag , str_ , this ) ; } mexittasksearly = bool_ ; setpause ( bool_ ) ; iterator < entry < string , loadimagetask > > it = ( iterator < entry < string , loadimagetask > > ) mloadworklist . entryset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { entry < string , loadimagetask > item = it . next ( ) ; loadimagetask task = item . getvalue ( ) ; task . restart ( ) ; mimagetaskexecutor . execute ( task ) ; } }	Recover the from the work list.
public void stopwork ( ) { if ( debug ) { clog . d ( log_tag , str_ , this ) ; } mexittasksearly = bool_ ; setpause ( bool_ ) ; flushfilecache ( ) ; }	Drop all the work, and leave it in the work list.
public void destroy ( ) { if ( debug ) { clog . d ( log_tag , str_ , this ) ; } mexittasksearly = bool_ ; setpause ( bool_ ) ; iterator < entry < string , loadimagetask > > it = ( iterator < entry < string , loadimagetask > > ) mloadworklist . entryset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { entry < string , loadimagetask > item = it . next ( ) ; final loadimagetask task = item . getvalue ( ) ; it . remove ( ) ; if ( task != null ) { task . cancel ( ) ; } } mloadworklist . clear ( ) ; }	Drop all the work, clear the work list.
public imageloader attachtocubefragment ( cubefragment fragment ) { if ( fragment != null ) { if ( lifecyclecomponentmanager . tryaddcomponenttocontainer ( this , fragment , bool_ ) ) { mhasbeenaddedtocomponentmanager = bool_ ; } } return this ; }	LiefCycle phase will be same to CubeFragment, an will be processed automatically.
public void invalidatecache ( string key ) { if ( debug ) { clog . d ( log_tag , str_ , key ) ; } try { mfilecache . getdiskcache ( ) . delete ( key ) ; } catch ( ioexception e ) { if ( debug ) { e . printstacktrace ( ) ; } } mmemorycache . remove ( key ) ; }	delete cache by key.
public void cleardiskcache ( ) { if ( null != mfilecache ) { try { mfilecache . getdiskcache ( ) . clear ( ) ; } catch ( ioexception e ) { if ( debug ) { e . printstacktrace ( ) ; } } } }	clear the disk cache.
private simplehashsetentry < t > [ ] maketable ( int newcapacity ) { @ suppresswarnings ( str_ ) simplehashsetentry < t > [ ] newtable = ( simplehashsetentry < t > [ ] ) new simplehashsetentry [ newcapacity ] ; mtable = newtable ; threshold = ( newcapacity > > num_ ) + ( newcapacity > > num_ ) ;	Allocate a table of the given capacity and set the threshold accordingly.
private simplehashsetentry < t > [ ] doublecapacity ( ) { simplehashsetentry < t > [ ] oldtable = mtable ; int oldcapacity = oldtable . length ; if ( oldcapacity == maximum_capacity ) { return oldtable ; } int newcapacity = oldcapacity * num_ ; simplehashsetentry < t > [ ] newtable = maketable ( newcapacity ) ; if ( msize == num_ ) { return newtable ; } for ( int j = num_ ; j < oldcapacity ; j ++ ) { simplehashsetentry < t > e = oldtable [ j ] ; if ( e == null ) { continue ; } int highbit = e . mhash & oldcapacity ; simplehashsetentry < t > broken = null ; newtable [ j | highbit ] = e ; for ( simplehashsetentry < t > n = e . mnext ; n != null ; e = n , n = n . mnext ) { int nexthighbit = n . mhash & oldcapacity ; if ( nexthighbit != highbit ) { if ( broken == null ) { newtable [ j | nexthighbit ] = n ; } else { broken . mnext = n ; } broken = e ; highbit = nexthighbit ; } } if ( broken != null ) broken . mnext = null ; } return newtable ; }	Doubles the capacity of the hash table.
public void write ( string key , bitmap bitmap ) { if ( key == null || bitmap == null ) { return ; }	Adds a bitmap to both memory and disk cache.
public string getstring ( ) throws ioexception { inputstream in = getinputstream ( ) ; return in != null ? inputstreamtostring ( in ) : null ; }	Returns the last committed value as a string, or null if no valuehas been committed.
public void commit ( ) throws ioexception { if ( ! misunderedit ) { throw new ioexception ( str_ ) ; } if ( haserrors ) { mdiskcache . delete ( mkey ) ; } else { file dirty = gettempfile ( ) ; if ( dirty . exists ( ) ) { file clean = getcachefile ( ) ; dirty . renameto ( clean ) ; moldsize = msize ; msize = clean . length ( ) ; mdiskcache . commitedit ( this ) ; } else { abortedit ( ) ; } } misunderedit = bool_ ; }	Commits this edit so it is visible to readers.
@ suppresswarnings ( { str_ } ) public requestdata addfile ( string fieldname , string uploadfile , string filename ) { addfile ( fieldname , new file ( uploadfile ) , filename ) ; return this ; }	add file to be uploaded.
@ override public void clear ( ) { if ( mmemorycache != null ) { mmemorycache . evictall ( ) ; if ( debug ) { log . d ( log_tag , str_ ) ; } } }	clear the memory cache.
public void trytoresume ( ) throws ioexception { if ( mjournalfile . exists ( ) ) { try { readjournal ( ) ; processjournal ( ) ; mjournalwriter = new bufferedwriter ( new filewriter ( mjournalfile , bool_ ) , io_buffer_size ) ; if ( simpledisklrucache . debug ) { clog . d ( simpledisklrucache . log_tag , str_ ) ; } } catch ( ioexception journaliscorrupt ) { journaliscorrupt . printstacktrace ( ) ; if ( simpledisklrucache . debug ) { clog . d ( simpledisklrucache . log_tag , str_ ) ; } clear ( ) ; } } else { if ( simpledisklrucache . debug ) { clog . d ( simpledisklrucache . log_tag , str_ ) ; }	try to resume last status when we got off.
private void processjournal ( ) throws ioexception { fileutils . deleteifexists ( mjournalfiletmp ) ; for ( iterator < cacheentry > i = mlruentries . values ( ) . iterator ( ) ; i . hasnext ( ) ; ) { cacheentry cacheentry = i . next ( ) ; if ( ! cacheentry . isunderedit ( ) ) { msize += cacheentry . getsize ( ) ; } else { cacheentry . delete ( ) ; i . remove ( ) ; } } }	Computes the initial size and collects garbage as a part of opening thecache.
private void rebuildjournal ( ) throws ioexception { if ( mjournalwriter != null ) { mjournalwriter . close ( ) ; } writer writer = new bufferedwriter ( new filewriter ( mjournalfiletmp ) , io_buffer_size ) ; writer . write ( magic ) ; writer . write ( str_ ) ; writer . write ( version_1 ) ; writer . write ( str_ ) ; writer . write ( integer . tostring ( mappversion ) ) ; writer . write ( str_ ) ; writer . write ( str_ ) ; for ( cacheentry cacheentry : mlruentries . values ( ) ) { if ( cacheentry . isunderedit ( ) ) { writer . write ( saction_list [ action_dirty ] + str_ + cacheentry . getkey ( ) + str_ + cacheentry . getsize ( ) + str_ ) ; } else { writer . write ( saction_list [ action_clean ] + str_ + cacheentry . getkey ( ) + str_ + cacheentry . getsize ( ) + str_ ) ; } } writer . close ( ) ; mjournalfiletmp . renameto ( mjournalfile ) ; mjournalwriter = new bufferedwriter ( new filewriter ( mjournalfile , bool_ ) , io_buffer_size ) ; }	Creates a new journal that omits redundant information.
private synchronized void trimtosize ( ) { if ( msize > mcapacity ) { if ( simpledisklrucache . debug ) { clog . d ( simpledisklrucache . log_tag , str_ , msize ) ; } } while ( msize > mcapacity ) { map . entry < string , cacheentry > toevict = mlruentries . entryset ( ) . iterator ( ) . next ( ) ; string key = toevict . getkey ( ) ; cacheentry cacheentry = toevict . getvalue ( ) ; mlruentries . remove ( key ) ; msize -= cacheentry . getsize ( ) ; addactionlog ( action_pending_delete , cacheentry ) ; if ( simpledisklrucache . debug ) { clog . d ( simpledisklrucache . log_tag , str_ , key , cacheentry . getsize ( ) , msize ) ; } } }	remove files from list, delete files.
@ override public void loadmorefinish ( boolean emptyresult , boolean hasmore ) { mloaderror = bool_ ; mlistempty = emptyresult ; misloading = bool_ ; mhasmore = hasmore ; if ( mloadmoreuihandler != null ) { mloadmoreuihandler . onloadfinish ( this , emptyresult , hasmore ) ; } }	page has loaded.
public imagereuseinfo create ( string thissize ) { arraylist < string > list = new arraylist < string > ( ) ; boolean canbereused = bool_ ; for ( int i = num_ ; i < msizelist . length ; i ++ ) { string size = msizelist [ i ] ; if ( ! canbereused && thissize . equals ( size ) ) { canbereused = bool_ ; continue ; } if ( canbereused && ! thissize . equals ( size ) ) { list . add ( size ) ; } } if ( list . size ( ) == num_ ) { return new imagereuseinfo ( thissize , null ) ; } else { string [ ] sizelist = new string [ list . size ( ) ] ; list . toarray ( sizelist ) ; return new imagereuseinfo ( thissize , sizelist ) ; } }	Find out the size list can be re-sued.
@ override protected t dorequestsync ( ) { t data = requestcachemanager . getinstance ( ) . requestcachesync ( this ) ; if ( data == null ) { data = requestmanager . getinstance ( ) . getrequestproxy ( this ) . requestsync ( this ) ; } return data ; }	Timeout will not be considerate.
private void notifyrequestfinish ( resulttype type , t cachedata , boolean outofdate ) { if ( debug ) { clog . d ( log_tag , str_ , getcachekey ( ) , type , outofdate ) ; } if ( mhasnotified ) { return ; } mhasnotified = bool_ ; mhandler . oncacheablerequestfinish ( cachedata , type , outofdate ) ; }	will only notify once.
public void getresponse ( stringbuilder sb ) throws ioexception {	Completes the request and receives response from the server.
public void setloadingbitmap ( bitmap loadingbitmap ) { if ( version . hashoneycomb ( ) ) { mloadingdrawable = new bitmapdrawable ( mcontext . getresources ( ) , loadingbitmap ) ; } }	set the placeholder bitmap.
public void setcustomizedrightview ( view view ) { relativelayout . layoutparams lp = makelayoutparams ( view ) ; lp . addrule ( center_vertical ) ; lp . addrule ( align_parent_right ) ; getrightviewcontainer ( ) . addview ( view , lp ) ; }	set customized view to right side.
public boolean downloadtostream ( imagetask imagetask , string urlstring , outputstream outputstream , progressupdatehandler progressupdatehandler ) { disableconnectionreuseifnecessary ( ) ; httpurlconnection urlconnection = null ; bufferedoutputstream out = null ; bufferedinputstream in = null ; try { final url url = new url ( urlstring ) ; urlconnection = ( httpurlconnection ) url . openconnection ( ) ; urlconnection . setreadtimeout ( num_ ) ; int len = urlconnection . getcontentlength ( ) ; int total = num_ ; in = new bufferedinputstream ( urlconnection . getinputstream ( ) , io_buffer_size ) ; out = new bufferedoutputstream ( outputstream , io_buffer_size ) ; int b ; while ( ( b = in . read ( ) ) != - num_ ) { total ++ ; out . write ( b ) ; if ( progressupdatehandler != null ) { progressupdatehandler . onprogressupdate ( total , len ) ; } } return bool_ ; } catch ( final ioexception e ) { clog . e ( log_tag , str_ + e ) ; } finally { if ( urlconnection != null ) { urlconnection . disconnect ( ) ; } try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( final ioexception e ) { } } return bool_ ; }	Download a bitmap from a URL and write the content to an output stream.
public void addimageview ( cubeimageview imageview ) { if ( null == imageview ) { return ; } if ( null == mfirstimageviewholder ) { mfirstimageviewholder = new imageviewholder ( imageview ) ; return ; } imageviewholder holder = mfirstimageviewholder ; for ( ; ; holder = holder . mnext ) { if ( holder . contains ( imageview ) ) { return ; } if ( holder . mnext == null ) { break ; } } imageviewholder newholder = new imageviewholder ( imageview ) ; newholder . mprev = holder ; holder . mnext = newholder ; }	Bind ImageView with ImageTask.
public void removeimageview ( cubeimageview imageview ) { if ( null == imageview || null == mfirstimageviewholder ) { return ; } imageviewholder holder = mfirstimageviewholder ; do { if ( holder . contains ( imageview ) ) {	Remove the ImageView from ImageTask.
public void onloading ( imageloadhandler handler ) { mflag = mflag | status_loading ; if ( null == handler ) { return ; } if ( mfirstimageviewholder == null ) { handler . onloading ( this , null ) ; } else { imageviewholder holder = mfirstimageviewholder ; do { final cubeimageview imageview = holder . getimageview ( ) ; if ( null != imageview ) { handler . onloading ( this , imageview ) ; } } while ( ( holder = holder . mnext ) != null ) ; } }	When loading from network.
public void onloadtaskfinish ( bitmapdrawable drawable , imageloadhandler handler ) { mflag &= ~ status_loading ; if ( null == handler ) { return ; } int errorcode = mflag & error_code_mask ; if ( errorcode > num_ ) { onloaderror ( errorcode , handler ) ; return ; } if ( null != mimagetaskstatistics ) { mimagetaskstatistics . s5_beforeshow ( ) ; } if ( mfirstimageviewholder == null ) { handler . onloadfinish ( this , null , drawable ) ; } else { imageviewholder holder = mfirstimageviewholder ; do { final cubeimageview imageview = holder . getimageview ( ) ; if ( null != imageview ) { imageview . onloadfinish ( ) ; handler . onloadfinish ( this , imageview , drawable ) ; } } while ( ( holder = holder . mnext ) != null ) ; } if ( null != mimagetaskstatistics ) { mimagetaskstatistics . s6_aftershow ( imageprovider . getbitmapsize ( drawable ) ) ; imageperformancestatistics . onimageloaded ( this , mimagetaskstatistics ) ; } }	Will be called when begin load image data from dish or network.
public static string joinsizeinfotokey ( string key , int w , int h ) { if ( w > num_ && h != integer . max_value && h > num_ && h != integer . max_value ) { return new stringbuilder ( key ) . append ( size_sp ) . append ( w ) . append ( size_sp ) . append ( h ) . tostring ( ) ; } return key ; }	Join the key and the size information.
public static string joinsizetagtokey ( string key , string tag ) { return new stringbuilder ( key ) . append ( size_sp ) . append ( tag ) . tostring ( ) ; }	Join the tag with the key.
public void opendiskcacheasync ( ) { if ( debug ) { clog . d ( log_tag , str_ , mdiskcache ) ; } synchronized ( mdiskcachelock ) { mdiskcachestarting = bool_ ; new filecachetask ( task_init_cache ) . executenow ( ) ; } }	initiate the disk cache.
public void flushdiskcacheasyncwithdelay ( int delay ) { if ( debug ) { clog . d ( log_tag , str_ , delay ) ; } if ( misdelayflushing ) { return ; } misdelayflushing = bool_ ; new filecachetask ( task_flush_cache ) . executeafter ( delay ) ; }	flush the data to disk cache.
public diskcache getdiskcache ( ) { if ( ! mdiskcacheready ) { if ( debug ) { clog . d ( log_tag , str_ , mdiskcache ) ; } opendiskcacheasync ( ) ; } synchronized ( mdiskcachelock ) { while ( mdiskcachestarting ) { try { if ( debug ) { clog . d ( log_tag , str_ , mdiskcache ) ; } mdiskcachelock . wait ( ) ; } catch ( interruptedexception e ) { } } } return mdiskcache ; }	If disk is not read, will prepare it first.
public static void deletedirectoryquickly ( file dir ) throws ioexception { if ( ! dir . exists ( ) ) { return ; } final file to = new file ( dir . getabsolutepath ( ) + system . currenttimemillis ( ) ) ; dir . renameto ( to ) ; if ( ! dir . exists ( ) ) {	Try to delete directory in a fast way.
@ targetapi ( build . version_codes . froyo ) public static file getexternalcachedir ( context context ) { if ( version . hasfroyo ( ) ) { file path = context . getexternalcachedir ( ) ;	Get the external application cache directory.
@ suppresswarnings ( str_ ) @ targetapi ( build . version_codes . gingerbread ) public static long getusablespace ( file path ) { if ( path == null ) { return - num_ ; } if ( version . hasgingerbread ( ) ) { return path . getusablespace ( ) ; } else { if ( ! path . exists ( ) ) { return num_ ; } else { final statfs stats = new statfs ( path . getpath ( ) ) ; return ( long ) stats . getblocksize ( ) * ( long ) stats . getavailableblocks ( ) ; } } }	Check how much usable space is available at a given path.
private static void notifydrawable ( drawable drawable , final boolean isdisplayed ) { if ( drawable instanceof recyclingbitmapdrawable ) {	Notifies the drawable that it's displayed state has changed.
@ override public void onresume ( ) { super . onresume ( ) ; if ( ! mfirstresume ) { onback ( ) ; } if ( mfirstresume ) { mfirstresume = bool_ ; } if ( debug ) { showstatus ( str_ ) ; } }	Only when Activity resume, not very precise.When activity recover from partly invisible, onBecomesPartiallyInvisible will be triggered.
public t lastitem ( ) { if ( mdatalist == null || mdatalist . size ( ) == num_ ) { return null ; } return mdatalist . get ( mdatalist . size ( ) - num_ ) ; }	the last item in list.
@ override public void hide ( ) {	Hides the FAB.
public void alignsheetwithfab ( view fab ) {	Aligns the sheet's position with the FAB.
public void morphfromfab ( view fab , long showsheetduration , long showsheetcolorduration , animationlistener listener ) { sheet . setvisibility ( view . visible ) ; revealsheetwithfab ( fab , getfabrevealradius ( fab ) , getsheetrevealradius ( ) , showsheetduration , fabcolor , sheetcolor , showsheetcolorduration , listener ) ; }	Shows the sheet by morphing the FAB into the sheet.
public void morphintofab ( view fab , long hidesheetduration , long hidesheetcolorduration , animationlistener listener ) { revealsheetwithfab ( fab , getsheetrevealradius ( ) , getfabrevealradius ( fab ) , hidesheetduration , sheetcolor , fabcolor , hidesheetcolorduration , listener ) ; }	Hides the sheet by morphing the sheet into the FAB.
public void hide ( long duration , final animationlistener listener ) { overlay . animate ( ) . alpha ( num_ ) . setduration ( duration ) . setinterpolator ( interpolator ) . setlistener ( new animatorlisteneradapter ( ) { @ override public void onanimationstart ( animator animation ) { if ( listener != null ) { listener . onstart ( ) ; } } @ override public void onanimationend ( animator animation ) { overlay . setvisibility ( view . gone ) ; if ( listener != null ) { listener . onend ( ) ; } } } ) . start ( ) ; }	Hides the overlay.
public void showsheet ( ) { if ( isanimating ( ) ) { return ; } isshowing = bool_ ;	Shows the sheet.
private void setupactionbar ( ) { setsupportactionbar ( ( toolbar ) findviewbyid ( r . id . toolbar ) ) ; getsupportactionbar ( ) . setdisplayhomeasupenabled ( bool_ ) ; }	Sets up the action bar.
private void setupdrawer ( ) { drawerlayout = ( drawerlayout ) findviewbyid ( r . id . drawer_layout ) ; drawertoggle = new actionbardrawertoggle ( this , drawerlayout , r . string . opendrawer , r . string . closedrawer ) ; drawerlayout . setdrawerlistener ( drawertoggle ) ; }	Sets up the navigation drawer.
private void setuptabs ( ) {	Sets up the tabs.
private void setupfab ( ) { fab fab = ( fab ) findviewbyid ( r . id . fab ) ; view sheetview = findviewbyid ( r . id . fab_sheet ) ; view overlay = findviewbyid ( r . id . overlay ) ; int sheetcolor = getresources ( ) . getcolor ( r . color . background_card ) ; int fabcolor = getresources ( ) . getcolor ( r . color . theme_accent ) ;	Sets up the Floating action button.
private void updatefab ( int selectedpage ) { switch ( selectedpage ) { case mainpageradapter . all_pos : materialsheetfab . showfab ( ) ; break ; case mainpageradapter . shared_pos : materialsheetfab . showfab ( num_ , - getresources ( ) . getdimensionpixelsize ( r . dimen . snackbar_height ) ) ; break ; case mainpageradapter . favorites_pos : default : materialsheetfab . hidesheetthenfab ( ) ; break ; } }	Updates the FAB based on the selected page.
private void updatesnackbar ( int selectedpage ) { view snackbar = findviewbyid ( r . id . snackbar ) ; switch ( selectedpage ) { case mainpageradapter . shared_pos : snackbar . setvisibility ( view . visible ) ; break ; case mainpageradapter . all_pos : case mainpageradapter . favorites_pos : default : snackbar . setvisibility ( view . gone ) ; break ; } }	Updates the snackbar based on the selected page.
public void morphintosheet ( int endx , int endy , side side , int arcdegrees , float scalefactor , long duration , animationlistener listener ) { morph ( endx , endy , side , arcdegrees , scalefactor , duration , listener ) ; }	Animates the FAB as if the FAB is morphing into a sheet.
public void morphfromsheet ( int endx , int endy , side side , int arcdegrees , float scalefactor , long duration , animationlistener listener ) { fab . setvisibility ( view . visible ) ; morph ( endx , endy , side , arcdegrees , scalefactor , duration , listener ) ; }	Animates the FAB as if a sheet is being morphed into a FAB.
private void hidesuggestionsifnecessary ( final @ nonnull querytoken currentquery , final @ nonnull tokensource source ) { string queryts = currentquery . gettokenstring ( ) ; string currentts = source . getcurrenttokenstring ( ) ; if ( ! iswaitingforresults ( currentquery ) && queryts != null && queryts . equals ( currentts ) ) { msuggestionsvisibilitymanager . displaysuggestions ( bool_ ) ; } }	Hides the suggestions if there are no more incoming queries.
public boolean containsexplicitchar ( final @ nonnull charsequence input ) { if ( ! textutils . isempty ( input ) ) { for ( int i = num_ ; i < input . length ( ) ; i ++ ) { char c = input . charat ( i ) ; if ( isexplicitchar ( c ) ) { return bool_ ; } } } return bool_ ; }	Returns true if the input string contains an explicit character.
public boolean containswordbreakingchar ( final @ nonnull charsequence input ) { if ( ! textutils . isempty ( input ) ) { for ( int i = num_ ; i < input . length ( ) ; i ++ ) { char c = input . charat ( i ) ; if ( iswordbreakingchar ( c ) ) { return bool_ ; } } } return bool_ ; }	Returns true if the input string contains a word-breaking character.
public boolean onlylettersordigits ( final @ nonnull charsequence input , final int numcharstocheck , final int start ) {	Given a string and starting index, return true if the first "numCharsToCheck" characters atthe starting index are either a letter or a digit.
protected int getsearchstartindex ( final @ nonnull spanned text , int cursor ) { if ( cursor < num_ || cursor > text . length ( ) ) { cursor = num_ ; }	Returns the index of the end of the last span before the cursor orthe start of the current line if there are no spans before the cursor.
protected int getsearchendindex ( final @ nonnull spanned text , int cursor ) { if ( cursor < num_ || cursor > text . length ( ) ) { cursor = num_ ; }	Returns the index of the beginning of the first span after the cursor orlength of the text if there are no spans after the cursor.
public void displaytextcounter ( boolean display ) { if ( display ) { mtextcounterview . setvisibility ( textview . visible ) ; } else { mtextcounterview . setvisibility ( textview . gone ) ; } }	Show or hide the text counter view.
private void disablespellingsuggestions ( boolean disable ) {	Disables spelling suggestions from the user's keyboard.This is necessary because some keyboards will replace the input text withspelling suggestions automatically, which changes the suggestion results.This results in a confusing user experience.
private void updateeditortextcount ( ) { if ( mmentionsedittext != null && mtextcounterview != null ) { int textcount = mmentionsedittext . getmentionstext ( ) . length ( ) ; mtextcounterview . settext ( string . valueof ( textcount ) ) ; if ( mtextcountlimit > num_ && textcount > mtextcountlimit ) { mtextcounterview . settextcolor ( mbeyondcountlimittextcolor ) ; } else { mtextcounterview . settextcolor ( mwithincountlimittextcolor ) ; } } }	Updates the TextView counting the number of characters in the editor.
public void setmentionspanfactory ( @ nonnull final mentionsedittext . mentionspanfactory factory ) { if ( mmentionsedittext != null ) { mmentionsedittext . setmentionspanfactory ( factory ) ; } }	Sets the factory used to create MentionSpans within this class.
private void copy ( @ intrange ( from = num_ ) int start , @ intrange ( from = num_ ) int end ) { mentionseditable text = getmentionstext ( ) ; spannablestringbuilder copiedtext = ( spannablestringbuilder ) text . subsequence ( start , end ) ; mentionspan [ ] spans = text . getspans ( start , end , mentionspan . class ) ; intent intent = null ; if ( spans . length > num_ ) {	Copy the text between start and end in clipboard.If no span is present, text is saved as plain text but if span is presentsave it in Clipboard using intent.
private void paste ( @ intrange ( from = num_ ) int min , @ intrange ( from = num_ ) int max ) { if ( android . os . build . version . sdk_int < android . os . build . version_codes . honeycomb ) { android . text . clipboardmanager clipboard = ( android . text . clipboardmanager ) getcontext ( ) . getsystemservice ( context . clipboard_service ) ; mentionseditable text = getmentionstext ( ) ; text . replace ( text . length ( ) , text . length ( ) , clipboard . gettext ( ) ) ; } else { pastehoneycombimpl ( min , max ) ; } }	Paste clipboard content between min and max positions.
@ targetapi ( build . version_codes . honeycomb ) private void pastehoneycombimpl ( @ intrange ( from = num_ ) int min , @ intrange ( from = num_ ) int max ) { clipboardmanager clipboard = ( clipboardmanager ) getcontext ( ) . getsystemservice ( context . clipboard_service ) ; clipdata clip = clipboard . getprimaryclip ( ) ; if ( clip != null ) { for ( int i = num_ ; i < clip . getitemcount ( ) ; i ++ ) { clipdata . item item = clip . getitemat ( i ) ; string selectedtext = item . coercetotext ( getcontext ( ) ) . tostring ( ) ; mentionseditable text = getmentionstext ( ) ; mentionspan [ ] spans = text . getspans ( min , max , mentionspan . class ) ; for ( mentionspan span : spans ) { if ( text . getspanend ( span ) == min ) {	Paste clipboard content between min and max positions.
private void updateselectionifrequired ( final int selstart , final int selend ) { mentionseditable text = getmentionstext ( ) ; mentionspan startmentionspan = text . getmentionspanatoffset ( selstart ) ; mentionspan endmentionspan = text . getmentionspanatoffset ( selend ) ; boolean selchanged = bool_ ; int start = selstart ; int end = selend ; if ( text . getspanstart ( startmentionspan ) < selstart && selstart < text . getspanend ( startmentionspan ) ) { start = text . getspanstart ( startmentionspan ) ; selchanged = bool_ ; } if ( text . getspanstart ( endmentionspan ) < selend && selend < text . getspanend ( endmentionspan ) ) { end = text . getspanend ( endmentionspan ) ; selchanged = bool_ ; } if ( selchanged ) { setselection ( start , end ) ; } }	Don't allow user to set starting position or ending position of selection within the mention.
private boolean oncursorchanged ( final int index ) { editable text = gettext ( ) ; if ( text == null ) { return bool_ ; } mentionspan [ ] allspans = text . getspans ( num_ , text . length ( ) , mentionspan . class ) ; for ( mentionspan span : allspans ) {	Method to handle the cursor changing positions.
public void deselectallspans ( ) { mblockcompletion = bool_ ; editable text = gettext ( ) ; mentionspan [ ] spans = text . getspans ( num_ , text . length ( ) , mentionspan . class ) ; for ( mentionspan span : spans ) { if ( span . isselected ( ) ) { span . setselected ( bool_ ) ; updatespan ( span ) ; } } mblockcompletion = bool_ ; }	Deselects any spans in the editor that are currently selected.
public static string escapeforxml ( string source ) { args . nullnotpermitted ( source , str_ ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = num_ ; i < source . length ( ) ; i ++ ) { char c = source . charat ( i ) ; switch ( c ) { case str_ : { sb . append ( str_ ) ; break ; } case str_ : { sb . append ( str_ ) ; break ; } case str_ : { string next = source . substring ( i , math . min ( i + num_ , source . length ( ) ) ) ; if ( next . startswith ( str_ ) || next . startswith ( str_ ) || next . startswith ( str_ ) || next . startswith ( str_ ) || next . startswith ( str_ ) ) { sb . append ( c ) ; } else { sb . append ( str_ ) ; } break ; } case str_ : { sb . append ( str_ ) ; break ; } case str_ : { sb . append ( str_ ) ; break ; } default : sb . append ( c ) ; } } return sb . tostring ( ) ; }	Returns a new string where any special characters in the source stringhave been encoded.
public static void writetohtml ( file file , string title , string svgelement ) throws ioexception { bufferedwriter writer = null ; try { fileoutputstream fos = new fileoutputstream ( file ) ; outputstreamwriter osw = new outputstreamwriter ( fos , str_ ) ; writer = new bufferedwriter ( osw ) ; writer . write ( str_ ) ; writer . write ( str_ ) ; writer . write ( str_ ) ; writer . write ( str_ + title + str_ ) ; writer . write ( str_ ) ; writer . write ( str_ ) ; writer . write ( str_ ) ; writer . write ( svgelement + str_ ) ; writer . write ( str_ ) ; writer . write ( str_ ) ; writer . flush ( ) ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch ( ioexception ex ) { logger . getlogger ( svgutils . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } }	Writes an HTML file containing an SVG element.
@ override public bufferedimage createcompatibleimage ( int width , int height ) { colormodel model = getcolormodel ( ) ; writableraster raster = model . createcompatiblewritableraster ( width , height ) ; return new bufferedimage ( model , raster , model . isalphapremultiplied ( ) , null ) ; }	Creates a compatible image.
@ override public volatileimage createcompatiblevolatileimage ( int width , int height , imagecapabilities caps , int transparency ) throws awtexception { if ( img == null ) { img = new bufferedimage ( num_ , num_ , bufferedimage . type_int_argb ) ; gc = img . creategraphics ( ) . getdeviceconfiguration ( ) ; } return gc . createcompatiblevolatileimage ( width , height , caps , transparency ) ; }	Returns a volatile image.
public string valuestr ( ) { return new stringbuilder ( ) . append ( this . minx ) . append ( str_ ) . append ( this . miny ) . append ( str_ ) . append ( this . width ) . append ( str_ ) . append ( this . height ) . tostring ( ) ; }	Returns a string containing the view box coordinates and dimensions.
@ override public string mapfont ( string family ) { args . nullnotpermitted ( family , str_ ) ; string alternate = this . alternates . get ( family ) ; if ( alternate != null ) { return alternate ; } return family ; }	Maps the specified font family name to an alternative, or else returnsthe same family name.
public void setshaperendering ( string value ) { if ( ! value . equals ( str_ ) && ! value . equals ( str_ ) && ! value . equals ( str_ ) && ! value . equals ( str_ ) ) { throw new illegalargumentexception ( str_ + value ) ; } this . shaperendering = value ; }	Sets the value of the 'shape-rendering' property that will be written tothe SVG element.
public void settextrendering ( string value ) { if ( ! value . equals ( str_ ) && ! value . equals ( str_ ) && ! value . equals ( str_ ) && ! value . equals ( str_ ) ) { throw new illegalargumentexception ( str_ + value ) ; } this . textrendering = value ; }	Sets the value of the 'text-rendering' property that will be written tothe SVG element.
private void appendoptionalelementidfromhint ( stringbuilder sb ) { string elementid = ( string ) this . hints . get ( svghints . key_element_id ) ; if ( elementid != null ) { this . hints . put ( svghints . key_element_id , null ) ;	A utility method that appends an optional element id if one isspecified via the rendering hints.
private string rgbcolorstr ( color c ) { stringbuilder b = new stringbuilder ( str_ ) ; b . append ( c . getred ( ) ) . append ( str_ ) . append ( c . getgreen ( ) ) . append ( str_ ) . append ( c . getblue ( ) ) . append ( str_ ) ; return b . tostring ( ) ; }	Returns the SVG RGB color string for the specified color.
private string rgbacolorstr ( color c ) { stringbuilder b = new stringbuilder ( str_ ) ; double alphapercent = c . getalpha ( ) / num_ ; b . append ( c . getred ( ) ) . append ( str_ ) . append ( c . getgreen ( ) ) . append ( str_ ) . append ( c . getblue ( ) ) ; b . append ( str_ ) . append ( transformdp ( alphapercent ) ) ; b . append ( str_ ) ; return b . tostring ( ) ; }	Returns a string representing the specified color in RGBA format.
private string strokestyle ( ) { double strokewidth = num_ ; string strokecap = default_stroke_cap ; string strokejoin = default_stroke_join ; float miterlimit = default_miter_limit ; float [ ] dasharray = new float [ num_ ] ; if ( this . stroke instanceof basicstroke ) { basicstroke bs = ( basicstroke ) this . stroke ; strokewidth = bs . getlinewidth ( ) > num_ ? bs . getlinewidth ( ) : this . zerostrokewidth ; switch ( bs . getendcap ( ) ) { case basicstroke . cap_round : strokecap = str_ ; break ; case basicstroke . cap_square : strokecap = str_ ; break ; case basicstroke . cap_butt : default :	Returns a stroke style string based on the current stroke andalpha settings.
private string getsvgfillstyle ( ) { stringbuilder b = new stringbuilder ( ) ; b . append ( str_ ) . append ( svgcolorstr ( ) ) . append ( str_ ) ; b . append ( str_ ) . append ( getcoloralpha ( ) * getalpha ( ) ) ; return b . tostring ( ) ; }	Returns a fill style string based on the current paint andalpha settings.
private string getsvgfontstyle ( ) { stringbuilder b = new stringbuilder ( ) ; b . append ( str_ ) . append ( svgcolorstr ( ) ) . append ( str_ ) ; b . append ( str_ ) . append ( getcoloralpha ( ) * getalpha ( ) ) . append ( str_ ) ; string fontfamily = this . fontmapper . mapfont ( this . font . getfamily ( ) ) ; b . append ( str_ ) . append ( fontfamily ) . append ( str_ ) ; b . append ( str_ ) . append ( this . font . getsize ( ) ) . append ( this . fontsizeunits ) . append ( str_ ) ; if ( this . font . isbold ( ) ) { b . append ( str_ ) ; } if ( this . font . isitalic ( ) ) { b . append ( str_ ) ; } return b . tostring ( ) ; }	Returns a string containing font style info.
@ override public fontmetrics getfontmetrics ( font f ) { if ( this . fmimage == null ) { this . fmimage = new bufferedimage ( num_ , num_ , bufferedimage . type_int_rgb ) ; this . fmimageg2d = this . fmimage . creategraphics ( ) ; this . fmimageg2d . setrenderinghint ( renderinghints . key_fractionalmetrics , renderinghints . value_fractionalmetrics_on ) ; } return this . fmimageg2d . getfontmetrics ( f ) ; }	Returns the font metrics for the specified font.
@ override public void scale ( double sx , double sy ) { affinetransform t = gettransform ( ) ; t . scale ( sx , sy ) ; settransform ( t ) ; }	Applies a scale transformation.
@ override public void transform ( affinetransform t ) { affinetransform tx = gettransform ( ) ; tx . concatenate ( t ) ; settransform ( tx ) ; }	Applies this transform to the existing transform by concatenating it.
@ override public void settransform ( affinetransform t ) { if ( t == null ) { this . transform = new affinetransform ( ) ; } else { this . transform = new affinetransform ( t ) ; } this . clipref = null ; }	Sets the transform.
@ override public void setclip ( shape shape ) {	Sets the user clipping region.
private string registerclip ( shape clip ) { if ( clip == null ) { this . clipref = null ; return null ; }	Registers the clip so that we can later write out all the clipdefinitions in the DEFS element.
@ override public void clip ( shape s ) { if ( s instanceof line2d ) { s = s . getbounds2d ( ) ; } if ( this . clip == null ) { setclip ( s ) ; return ; } shape ts = this . transform . createtransformedshape ( s ) ; if ( ! ts . intersects ( this . clip . getbounds2d ( ) ) ) { setclip ( new rectangle2d . double ( ) ) ; } else { area a1 = new area ( ts ) ; area a2 = new area ( this . clip ) ; a1 . intersect ( a2 ) ; this . clip = new path2d . double ( a1 ) ; } this . clipref = null ; }	Clips to the intersection of the current clipping region and thespecified shape.According to the Oracle API specification, this method will accept a{.
@ override public void cliprect ( int x , int y , int width , int height ) { setrect ( x , y , width , height ) ; clip ( this . rect ) ; }	Clips to the intersection of the current clipping region and thespecified rectangle.
@ override public void setclip ( int x , int y , int width , int height ) { setrect ( x , y , width , height ) ; setclip ( this . rect ) ; }	Sets the user clipping region to the specified rectangle.
private byte [ ] getpngbytes ( image img ) { renderedimage ri ; if ( img instanceof renderedimage ) { ri = ( renderedimage ) img ; } else { bufferedimage bi = new bufferedimage ( img . getwidth ( null ) , img . getheight ( null ) , bufferedimage . type_int_argb ) ; graphics2d g2 = bi . creategraphics ( ) ; g2 . drawimage ( img , num_ , num_ , null ) ; ri = bi ; } bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; try { imageio . write ( ri , str_ , baos ) ; } catch ( ioexception ex ) { logger . getlogger ( svggraphics2d . class . getname ( ) ) . log ( level . severe , str_ , ex ) ; } return baos . tobytearray ( ) ; }	Returns the bytes representing a PNG format image.
@ override public void drawrenderedimage ( renderedimage img , affinetransform xform ) { bufferedimage bi = graphicsutils . convertrenderedimage ( img ) ; drawimage ( bi , xform , null ) ; }	Draws the rendered image.
@ override public void drawrenderableimage ( renderableimage img , affinetransform xform ) { renderedimage ri = img . createdefaultrendering ( ) ; drawrenderedimage ( ri , xform ) ; }	Draws the renderable image.
private string getclippathref ( ) { if ( this . clip == null ) { return str_ ; } if ( this . clipref == null ) { this . clipref = registerclip ( getclip ( ) ) ; } stringbuilder b = new stringbuilder ( ) ; b . append ( str_ ) . append ( this . clipref ) . append ( str_ ) ; return b . tostring ( ) ; }	Returns a clip path reference for the current user clip.
public static list < string > getparts ( string string , final string ... regexplist ) { final list < string > parts = new arraylist < > ( ) ; for ( final string regexp : regexplist ) { final pattern pattern = pattern . compile ( regexp ) ; final matcher matcher = pattern . matcher ( string ) ; final boolean found = matcher . find ( ) ; if ( ! found ) { return new arraylist < > ( ) ; } final string part = matcher . group ( num_ ) . trim ( ) ; parts . add ( part ) ; string = string . replacefirst ( quote ( matcher . group ( ) ) , str_ ) . trim ( ) ; } return parts ; }	Match one regexp at a time.
protected void recordlevel ( final string statkey , final long level ) { final string longkey = getactualstatkey ( statkey ) ; statscollector . recordlevel ( longkey , level ) ; }	Prefixes the stats key with the stat key prefix, and then calls statsCollector.recordLevel.
protected void recordtiming ( string statkey , long timespan ) { final string longkey = getactualstatkey ( statkey ) ; statscollector . recordtiming ( longkey , timespan ) ; }	Prefixes the stats key with the stat key prefix, and then calls statsCollector.recordTiming.
private void tracktimeouts ( ) { new arraylist < > ( httprequestholderlist ) . foreach ( httprequestholder -> { if ( httprequestholder . request . ishandled ( ) ) { httprequestholderlist . remove ( httprequestholder ) ; return ; } final long duration = time - httprequestholder . starttime ; if ( duration > timeoutintervalms ) { httprequestholder . request . handled ( ) ; httprequestholder . request . getreceiver ( ) . timeoutwithmessage ( string . format ( str_ , httprequestholder . request . address ( ) , httprequestholder . request . getremoteaddress ( ) , httprequestholder . starttime ) ) ; httprequestholderlist . remove ( httprequestholder ) ;	Tracks timeouts periodically if timeout tracking is enabled.
private void checkclient ( ) { try { if ( errorcount . get ( ) > num_ ) { errorcount . set ( num_ ) ; if ( backendservicehttpclient == null || backendservicehttpclient . isclosed ( ) ) { if ( backendservicehttpclient != null ) { try { backendservicehttpclient . stop ( ) ; } catch ( exception ex ) { logger . debug ( str_ , ex ) ; } } backendservicehttpclient = httpclientbuilder . buildandstart ( ) ; lasthttpclientstart = time ; } } if ( pingbuilder . ispresent ( ) ) { if ( backendservicehttpclient != null ) { pingbuilder . get ( ) . setbinaryreceiver ( ( code , contenttype , body ) -> { if ( code >= num_ && code < num_ ) { pingcount . incrementandget ( ) ; } else { errorcount . incrementandget ( ) ; } } ) . seterrorhandler ( e -> { logger . error ( str_ , e ) ; errorcount . incrementandget ( ) ; } ) ; final httprequest httprequest = pingbuilder . get ( ) . build ( ) ; backendservicehttpclient . sendhttprequest ( httprequest ) ; } } } catch ( exception ex ) { errorhandler . accept ( ex ) ; logger . error ( str_ ) ; } }	Checks client health periodically to see if we are connected.
@ override public void handlerequest ( final httprequest clientrequest ) { if ( tracktimeouts ) { httprequestholderlist . add ( new httprequestholder ( clientrequest , time ) ) ; } if ( httpclientrequestpredicate . test ( clientrequest ) ) { createbackendrequestpopulateandforward ( clientrequest ) ; } }	Request coming from the client side.
private void createbackendrequestpopulateandforward ( final httprequest clientrequest ) { try { if ( backendservicehttpclient == null ) { handlehttpclienterrorsforbackend ( clientrequest , new httpclientclosedconnectionexception ( str_ ) ) ; long timesincelaststart = time - lasthttpclientstart ; if ( timesincelaststart > num_ ) { checkclient ( ) ; } return ; } final httprequestbuilder httprequestbuilder = httprequestbuilder . httprequestbuilder ( ) . copyrequest ( clientrequest ) . setbinaryreceiver ( new httpbinaryreceiver ( ) { @ override public void response ( final int code , final string contenttype , final byte [ ] body , final multimap < string , string > headers ) { handlebackendclientresponses ( clientrequest , code , contenttype , body , headers ) ; } @ override public void response ( int code , string contenttype , byte [ ] body ) { response ( code , contenttype , body , multimap . empty ( ) ) ; } } ) . seterrorhandler ( e -> handlehttpclienterrorsforbackend ( clientrequest , e ) ) ; beforesend . accept ( httprequestbuilder ) ; backendservicehttpclient . sendhttprequest ( httprequestbuilder . build ( ) ) ; } catch ( httpclientclosedconnectionexception httpclientclosedconnectionexception ) { errorcount . incrementandget ( ) ; errorhandler . accept ( httpclientclosedconnectionexception ) ; logger . error ( str_ , httpclientclosedconnectionexception ) ; handlehttpclienterrorsforbackend ( clientrequest , httpclientclosedconnectionexception ) ; backendservicehttpclient = null ; long timesincelaststart = time - lasthttpclientstart ; if ( timesincelaststart > num_ ) { checkclient ( ) ; } } catch ( exception ex ) { errorcount . incrementandget ( ) ; errorhandler . accept ( ex ) ; logger . error ( str_ , ex ) ; handlehttpclienterrorsforbackend ( clientrequest , ex ) ; long timesincelaststart = time - lasthttpclientstart ; if ( timesincelaststart > num_ ) { checkclient ( ) ; } } }	Creates a backend request from the client request and then forwards it.
private void handlehttpclienterrorsforbackend ( final httprequest clientrequest , final exception e ) { errorhandler . accept ( e ) ; errorcount . incrementandget ( ) ; final string errormessage = string . format ( str_ , clientrequest . address ( ) ) ; logger . error ( errormessage , e ) ; if ( ! clientrequest . ishandled ( ) ) { clientrequest . handled ( ) ; clientrequest . getreceiver ( ) . error ( string . format ( str_ , errormessage ) ) ; } }	Handle errors.
private void handlebackendclientresponses ( final httprequest clientrequest , final int code , final string contenttype , final byte [ ] body , final multimap < string , string > headers ) { if ( ! clientrequest . ishandled ( ) ) { clientrequest . handled ( ) ; clientrequest . getreceiver ( ) . response ( code , contenttype , body , headers ) ; } }	Handle a response from the backend service.
@ queuecallback ( { queuecallbacktype . empty , queuecallbacktype . idle , queuecallbacktype . limit } ) public void process ( ) { reactor . process ( ) ; time = timer . time ( ) ; }	Manage periodic jobs.
public static servicediscovery createlokateservicediscovery ( final list < uri > configs ) { return servicediscoverybuilder ( ) . setservicediscoveryprovider ( new lokateservicediscoveryprovider ( discoveryservice . create ( configs ) ) ) . build ( ) ; }	Create service discovery that can talk via Lokate.
private void docall ( methodcall < object > methodcall ) { if ( debug ) { logger . debug ( servicebundleimpl . class . getname ( ) , str_ , methodcall . name ( ) , methodcall . address ( ) , str_ , methodcall ) ; } try { if ( methodcall . hascallback ( ) ) { callbackmanager . registercallbacks ( methodcall ) ; } boolean [ ] continueflag = new boolean [ num_ ] ; methodcall = handlebeforemethodcall ( methodcall , continueflag ) ; if ( ! continueflag [ num_ ] ) { if ( debug ) { logger . debug ( servicebundleimpl . class . getname ( ) + str_ + str_ ) ; } } else { final consumer < methodcall < object > > methoddispatcher = getmethoddispatcher ( methodcall ) ; methoddispatcher . accept ( methodcall ) ; } } catch ( exception ex ) { response < object > response = new responseimpl < > ( methodcall , ex ) ; this . responsequeue . sendqueue ( ) . sendandflush ( response ) ; } }	Handles calling a method.
@ override @ suppresswarnings ( str_ ) public void call ( final methodcall < object > methodcall ) { if ( debug ) { logger . debug ( servicebundleimpl . class . getname ( ) + str_ + methodcall . name ( ) + str_ + str_ + methodcall . address ( ) + str_ + methodcall ) ; } methodsendqueue . send ( methodcall ) ; }	Call the method.
@ override public < t > t createlocalproxy ( final class < t > serviceinterface , final string myservice ) { final consumer < methodcall < object > > callconsumer = this . servicemapping . get ( myservice ) ; if ( callconsumer == null ) { logger . error ( str_ + myservice ) ; } return factory . createlocalproxy ( serviceinterface , myservice , this , beforemethodsent ) ; }	Creates a proxy interface to a particular client.
private methodcall < object > beforemethodcall ( methodcall < object > methodcall , boolean [ ] continuecall ) { if ( this . beforemethodcall . before ( methodcall ) ) { continuecall [ num_ ] = bool_ ; methodcall = transformbeforemethodcall ( methodcall ) ; continuecall [ num_ ] = this . beforemethodcallaftertransform . before ( methodcall ) ; return methodcall ; } else { continuecall [ num_ ] = bool_ ; } return methodcall ; }	Handles before call operation.
private methodcall < object > transformbeforemethodcall ( methodcall < object > methodcall ) { if ( argtransformer == null || argtransformer == serviceconstants . no_op_arg_transform ) { return methodcall ; } object arg = this . argtransformer . transform ( methodcall ) ; return methodcallbuilder . transformed ( methodcall , arg ) ; }	Handles the before argument transformer.
@ suppresswarnings ( str_ ) public void stop ( ) { if ( debug ) { logger . debug ( servicebundleimpl . class . getname ( ) , str_ ) ; } methodqueue . stop ( ) ; for ( stoppable service : servicestostop ) { service . stop ( ) ; } try { responsequeue . stop ( ) ; } catch ( exception ex ) { logger . debug ( str_ , ex ) ; } try { webresponsequeue . stop ( ) ; } catch ( exception ex ) { logger . debug ( str_ , ex ) ; } if ( systemmanager != null ) systemmanager . serviceshutdown ( ) ; }	Stop the client bundle.
public servicebundle startupcallqueue ( ) { methodqueue . startlistener ( new receivequeuelistener < methodcall < object > > ( ) { long time ; long lasttimeautoflush ; @ override public void receive ( methodcall < object > item ) { docall ( item ) ;	Start the client bundle.
public string findservicename ( final string dnsservicename ) { string servicename = dnsservicenametoservicename . get ( dnsservicename ) ; servicename = servicename == null ? dnsservicename : servicename ; if ( debug ) logger . debug ( str_ , dnsservicename , servicename ) ; return servicename ; }	Looks up a service name based on its dns service name.
public void loadserviceendpointsbyservicename ( final callback < list < endpointdefinition > > callback , final string servicename ) { loadserviceendpointsbydnsservice ( callback , finddnsservicename ( servicename ) ) ; }	Load the service nodes based on the internal service name.DB, Ingester, RadarAggregator, etc.
private endpointdefinition convertsrvrecordtoendpointdefinition ( final srvrecord srvrecord ) { return new endpointdefinition ( findservicename ( srvrecord . service ( ) ) , srvrecord . target ( ) , srvrecord . port ( ) ) ; }	Convert a single srvRecord into an EndpointDefinition.
protected corsrequesttype checkrequesttype ( final httprequestholder request ) { corsrequesttype requesttype = corsrequesttype . invalid_cors ; if ( request == null ) { throw new illegalargumentexception ( corssupport . cors_null_request ) ; } string originheader = request . getheaders ( ) . get ( request_header_origin ) ;	Determines the request type.
private void handlehttprequest ( final httpserverrequest request ) { if ( debug ) { setupmetrics ( request ) ; logger . debug ( str_ , request . method ( ) , request . uri ( ) ) ; } switch ( request . method ( ) . tostring ( ) ) { case str_ : case str_ : case str_ : case str_ : case str_ : case str_ : handlerequestwithbody ( request ) ; break ; case str_ : case str_ : handlerequestwithnobody ( request ) ; break ; default : throw new illegalstateexception ( str_ + request . method ( ) ) ; } }	Handle a vertx request by converting it into a QBit request.
private boolean dohandlemethodcall ( methodcall < object > methodcall , final servicemethodhandler servicemethodhandler ) { if ( debug ) { logger . debug ( str_ + methodcall ) ; } if ( callbackmanager != null ) { if ( methodcall . hascallback ( ) && servicemethodhandler . couldhavecallback ( methodcall . name ( ) ) ) { callbackmanager . registercallbacks ( methodcall ) ; } }	This method is where all of the action is.
public static consul consul ( final string host , final int port ) { try { return new consul ( new url ( str_ , host , port , str_ ) . tostring ( ) ) ; } catch ( malformedurlexception e ) { throw new consulexception ( str_ , e ) ; } }	Creates a new client given a host and a port.
@ override public dnsclient get ( ) { final uri uri = addresslist . get ( index ) ; try { if ( debug ) logger . debug ( str_ , uri . getport ( ) , uri . gethost ( ) ) ; return vertx . creatednsclient ( uri . getport ( ) , uri . gethost ( ) ) ; } catch ( exception ex ) { logger . error ( str_ , ex ) ; logger . error ( str_ , uri . getport ( ) , uri . gethost ( ) ) ; return getiferrors ( ) ; } }	Get a DNS client.
@ override public receivequeue < t > receivequeue ( ) { if ( debug ) logger . debug ( str_ , name ) ; return new basicreceivequeue < > ( queue , polltimewait , polltimetimeunit , limit ) ; }	This returns a new instance of ReceiveQueue every time you call itso call it only once per thread.
@ override public sendqueue < t > sendqueue ( ) { if ( debug ) logger . debug ( str_ , name ) ; return sendqueuesupplier . get ( ) ; }	This returns a new instance of SendQueue every time you call itso call it only once per thread.
public static < t > callback < t > convertpromise ( final promise < t > promise ) { return convertpromisetocallback ( promise , callbackbuilder . callbackbuilder ( ) ) ; }	Converts a Reakt promise into a QBit callback.
public static < t > callback < t > convertpromise ( final reactor reactor , final promise < t > promise ) { return convertpromisetocallback ( promise , reactor . callbackbuilder ( ) ) ; }	Converts a Reakt promise into a QBit callback.Reactor is used to manage timeouts and ensure callback happens on same thread as caller.
public < t > callback < t > callback ( final consumer < promise < t > > promiseconsumer ) { promise < t > promise = promises . promise ( ) ; promiseconsumer . accept ( promise ) ; return reakt . convertpromise ( promise ) ; }	Creates a QBit callback based on promise created.
private void loadhealthyservices ( ) { try { string servicename = donequeue . poll ( ) ; while ( servicename != null ) { final string servicenametofetch = servicename ; if ( ! servicenamesbeingloaded . contains ( servicenametofetch ) ) { servicenamesbeingloaded . add ( servicenametofetch ) ; executorservice . submit ( ( ) -> { doloadhealthservices ( servicenametofetch ) ; } ) ; } servicename = donequeue . poll ( ) ; } } catch ( exception ex ) { ex . printstacktrace ( ) ; } }	Iterate through the health service queue and load the services.
private void dofailoverhealthservicesload ( final string servicenametofetch , exception ex ) { if ( backupprovider != null ) { if ( debug ) logger . debug ( str_ + str_ + str_ + servicenametofetch , ex ) ; final list < endpointdefinition > healthyservices = backupprovider . loadservices ( servicenametofetch ) ; populateservicemap ( servicenametofetch , healthyservices ) ; servicenamesbeingloaded . remove ( servicenametofetch ) ; } else { logger . error ( str_ + str_ + str_ + servicenametofetch , ex ) ; } sys . sleep ( num_ ) ;	If the primary load failed, we could have a backup provider registered.
@ override public dnsclient get ( ) { if ( debug ) logger . debug ( str_ , host , port ) ; return vertx . creatednsclient ( port , host ) ; }	Supply an instance of DnsClient.
public void addoneshotaftertask ( final long fireafter , final timeunit timeunit , final runnable task ) { fireonceaftertasks . add ( new fireoncetask ( task , timeunit , fireafter ) ) ; }	Add a task that gets executed once.
public void process ( ) { drainqueues ( ) ; currenttime = timer . now ( ) ; monitorcallbacks ( ) ; monitorcallbackcoordinators ( ) ; collaboratingservices . foreach ( serviceproxyutils :: flushserviceproxy ) ; processrepeatingtasks ( ) ; processfireoncetasks ( ) ; }	Process items in reactor.
public < t > asyncfuturecallback < t > removefuture ( asyncfuturecallback < t > asyncfuturecallback ) { this . removefuturequeue . offer ( asyncfuturecallback ) ; return asyncfuturecallback ; }	Remove a callback from the list of callbacks that we are managing.
private void monitorcallbacks ( ) { if ( futurelist . size ( ) > num_ ) { final list < asyncfuturecallback < ? > > removelist = new arraylist < > ( futurelist . size ( ) ) ; long now = currenttime ; for ( asyncfuturecallback < ? > callback : futurelist ) { if ( callback . isdone ( ) ) { callback . run ( ) ; removelist . add ( callback ) ; } else { if ( callback . checktimeout ( now ) ) { removelist . add ( callback ) ; } } } futurelist . removeall ( removelist ) ; } }	Monitors timeouts. If the callback timed-out trigger it, and then remove callback from the list.
private void monitorcallbackcoordinators ( ) { if ( coordinatorlist . size ( ) > num_ ) { final list < callbackcoordinator > removelist = new arraylist < > ( coordinatorlist . size ( ) ) ; for ( callbackcoordinator callable : coordinatorlist ) { if ( callable . checkcomplete ( ) ) { callable . finished ( ) ; removelist . add ( callable ) ; } else if ( callable . timedout ( currenttime ) ) { removelist . add ( callable ) ; } } coordinatorlist . removeall ( removelist ) ; } }	Monitors Callback Coordinators.Trigger timeouts if needed and remove coordinators from list that timed out.
public < t > callback < t > wrapcallbackwithtimeout ( final string operationdescription , final callback < t > callback , final logger logger , final timeunit timeunit , final long timeoutduration ) { return callbackbuilder ( ) . setcallback ( new callback < t > ( ) { @ override public void accept ( t t ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( str_ , operationdescription , t ) ; } callback . resolve ( t ) ; } } ) . setonerror ( error -> { logger . error ( string . format ( str_ , operationdescription ) , error ) ; callback . onerror ( error ) ; } ) . setontimeout ( ( ) -> { logger . error ( str_ , operationdescription ) ; callback . ontimeout ( ) ; } ) . settimeouttimeunit ( timeunit ) . settimeoutduration ( timeoutduration ) . build ( ) ; }	Used for quickly delegating one callback to another.This allows one liners so you don't have to create a builder for this common case.
public proxyservice build ( ) { return new proxyserviceimpl ( getreactor ( ) , gettimer ( ) , gethttpclientbuilder ( ) , getbeforesend ( ) , geterrorhandler ( ) , gethttpclientrequestpredicate ( ) , getcheckclientduration ( ) , pingbuilder == null ? optional . < httprequestbuilder > empty ( ) : optional . of ( pingbuilder ) , istracktimeouts ( ) , gettimeoutinterval ( ) ) ; }	Build the impl.
public proxyservice buildproxy ( ) { return getservicebuilder ( ) . setserviceobject ( build ( ) ) . buildandstart ( ) . createproxywithautoflush ( proxyservice . class , duration . hundred_millis ) ; }	Builds a proxy queue service to the impl.
public void handlewebsocketcall ( final websocketmessage websocketmessage ) { if ( debug ) logger . debug ( str_ + websocketmessage ) ; websocketdelegate websocketdelegate = websocketdelegatemap . get ( websocketmessage . getremoteaddress ( ) ) ; if ( websocketdelegate == null ) { websocketdelegate = new websocketdelegate ( protocolbatchsize , websocketmessage ) ; websocketdelegatemap . put ( websocketmessage . getremoteaddress ( ) , websocketdelegate ) ; } protocolparserthreadpool . execute ( ( ) -> { try { final list < methodcall < object > > methodcalllisttobeparsedfrombody = createmethodcalllisttobeparsedfrombody ( websocketmessage . getremoteaddress ( ) , websocketmessage . getmessage ( ) , websocketmessage ) ; if ( methodcalllisttobeparsedfrombody . size ( ) > num_ ) { methodcallsendqueue . sendbatch ( methodcalllisttobeparsedfrombody ) ; } } catch ( exception ex ) { logger . error ( str_ , ex ) ; } } ) ; }	All WebSocket calls come through here.
public void add ( final eventlistener < t > eventlistener ) { if ( eventlistener . subscriber ( ) ) { if ( debug ) logger . debug ( str_ , name , eventlistener ) ; listeners . add ( eventlistener ) ; stats . recordlevel ( eventbusname + str_ + name , listeners . size ( ) ) ; } else { if ( debug ) logger . debug ( str_ , name , eventlistener ) ; consumer = eventlistener ; } }	Add an event listener to the channelThere can only be one consumer and many listeners.
public static servicediscovery creatednsservicediscovery ( ) { final servicediscoverybuilder servicediscoverybuilder = servicediscoverybuilder . servicediscoverybuilder ( ) ; final vertx vertx = vertx . vertx ( ) ; final dnssupportbuilder dnssupportbuilder = dnssupportbuilder . dnssupportbuilder ( vertx ) . setdnsclientsupplier ( new dnsclientfromresolveconfsupplier ( vertx ) ) ; final dnsservicediscoveryproviderbuilder dnsservicediscoveryproviderbuilder = dnsservicediscoveryproviderbuilder . dnsservicediscoveryproviderbuilder ( ) . setdnssupport ( dnssupportbuilder . build ( ) ) ; return servicediscoverybuilder . setservicediscoveryprovider ( dnsservicediscoveryproviderbuilder . build ( ) ) . build ( ) ; }	Create service discovery that can talk DNS.
@ override public < t > t fromjson ( string json , class < t > cls ) { return parser . get ( ) . parse ( cls , json ) ; }	Convert from json string using Class as a suggestion for how to do the parse.
@ override public < t > list < t > fromjsonarray ( string json , class < t > componentclass ) { return parser . get ( ) . parselist ( componentclass , json ) ; }	Converts from a json string using componentClass as a guide to a List.
@ override public string tojson ( object object ) { return serializer . get ( ) . serialize ( object ) . tostring ( ) ; }	Converts from Object into JSON string.
@ override public < k , v > map < k , v > fromjsonmap ( string json , class < k > componentclasskey , class < v > componentclassvalue ) { map map = ( map ) parser . get ( ) . parse ( json ) ; final mapper mapper = this . mapper . get ( ) ; return extractmap ( componentclasskey , componentclassvalue , map , mapper ) ; }	Converts from a json string using componentClassKey and componentClassValue as a guide to a Map.
private < v > v converttomap ( valuemap valuemap ) { final map < string , object > map = new linkedhashmap < > ( valuemap . size ( ) ) ; valuemap . entryset ( ) . foreach ( new consumer < map . entry < string , object > > ( ) { @ override public void accept ( map . entry < string , object > entry ) { object value = entry . getvalue ( ) ; if ( value instanceof valuecontainer ) { valuecontainer valuecontainer = ( ( valuecontainer ) entry . getvalue ( ) ) ; value = valuecontainer . tovalue ( ) ; } if ( value instanceof value ) { map . put ( entry . getkey ( ) , ( ( value ) value ) . tovalue ( ) ) ; } else if ( value instanceof valuemap ) { map . put ( entry . getkey ( ) , converttomap ( ( ( valuemap ) value ) ) ) ; } else if ( value instanceof list ) { map . put ( entry . getkey ( ) , convertlist ( value , mapper . get ( ) ) ) ; } else { map . put ( entry . getkey ( ) , value ) ; } } } ) ; return ( v ) map ; }	Helper method.Converts a value map into a regular map of Java basic types.
public boolean couldhavecallback ( final string name ) { final boolean has = hashandlermap . get ( name ) ; if ( has == null ) { return bool_ ; } return has ; }	False is unknown, true is no callbacks.
public < t > callbackbuilder setcallback ( final class < t > returntype , final callback < t > callback ) { return withcallback ( returntype , callback ) ; }	Builder method to add a callback handler.
public < t > callbackbuilder wrap ( final callback < t > callback ) { this . witherrorhandler ( callback :: onerror ) ; this . withtimeouthandler ( callback :: ontimeout ) ; this . withcallback ( callback ) ; return this ; }	Builder method to wrap and delegate, timeout and error handling and callback itself.
public < t > callbackbuilder withlistcallback ( final class < t > componentclass , final callback < list < t > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes a list.
public < t > callbackbuilder withsetcallback ( final class < t > componentclass , final callback < set < t > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes a set.
public < t > callbackbuilder withcollectioncallback ( final class < t > componentclass , final callback < collection < t > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes a collection.
public < k , v > callbackbuilder withmapcallback ( final class < k > keyclass , final class < v > valueclass , final callback < map < k , v > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes a map.
public < t > callbackbuilder withoptionalcallback ( final class < t > cls , final callback < optional < t > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes an optional string.
public httpresponsebuilder addheader ( final string name , final string value ) { getheaders ( ) . put ( name , value ) ; return this ; }	Add a header.
public boolean isserviceregistered ( final string serviceid ) { map < string , service > serviceidtoservice = getservices ( ) ; return serviceidtoservice . containskey ( serviceid ) ; }	Checks to see if a service is registered with the local agent..
public void pingagent ( ) { http . response response = http . getresponse ( createuri ( str_ ) . tostring ( ) ) ; if ( response . status ( ) != num_ ) { die ( str_ , response . payloadasstring ( ) ) ; } }	Pings the Consul Agent.
public void register ( final registration registration ) { final uri uri = createuri ( str_ ) ; http . response response = http . jsonrestcallviaput ( uri . tostring ( ) , tojson ( registration ) ) ; if ( response . status ( ) != num_ ) { die ( str_ , uri , registration , response . payloadasstring ( ) ) ; } }	Register a service with Consul.
public void deregister ( final string serviceid ) { final uri uri = createuri ( str_ + serviceid ) ; http . response response = http . getresponse ( uri . tostring ( ) ) ; if ( response . status ( ) != num_ ) { die ( str_ , uri , serviceid , response . status ( ) , response . payloadasstring ( ) ) ; } }	Remove registration of a particular service.
public void deregistercheck ( string checkid ) { final uri uri = createuri ( str_ + checkid ) ; http . response response = http . getresponse ( uri . tostring ( ) ) ; if ( response . status ( ) != num_ ) { die ( str_ , uri , checkid , response . status ( ) , response . statusmessageasstring ( ) , response . payloadasstring ( ) ) ; } }	De-registers a Health Check with the Agent.
public void check ( string checkid , status status , string note ) { final uri uri = createuri ( str_ + status . geturi ( ) + str_ + checkid ) ; final http . response httpresponse = str . isempty ( note ) ? http . getresponse ( uri . tostring ( ) ) : http . getresponse ( uri . tostring ( ) + str_ + note ) ; if ( httpresponse . code ( ) != num_ ) { notregistered ( str_ , uri , httpresponse . code ( ) , httpresponse . statusmessageasstring ( ) , httpresponse . body ( ) ) ; } }	Checks in with Consul.
public void pass ( string checkid , @ suppresswarnings ( str_ ) string note ) throws notregisteredexception { checkttl ( checkid , status . pass , note ) ; }	Sets a TTL check to "passing" state with a note.
public void warn ( string checkid , string note ) throws notregisteredexception { checkttl ( checkid , status . warn , note ) ; }	Sets a TTL check to "warning" state with a note.
public void stop ( ) { flush ( ) ; if ( httpserverproxy != null ) { try { httpserverproxy . stop ( ) ; } catch ( exception ex ) { logger . warn ( str_ , ex ) ; } } }	Stop client. Stops processing call backs.
private void handleasynccallback ( final response < object > response , final callback < object > handler ) { if ( response . waserrors ( ) ) { handler . onerror ( new exception ( response . body ( ) . tostring ( ) ) ) ; } else { handler . accept ( response . body ( ) ) ; } }	Handles an async callbackWithTimeout.
private void send ( final string servicename , final string message , final consumer < exception > exceptionconsumer ) { if ( websocket == null ) { string websocketuri ; if ( servicename . startswith ( uri ) ) { websocketuri = servicename ; } else { websocketuri = str . add ( uri , str_ , servicename ) ; } this . websocket = httpserverproxy . createwebsocket ( websocketuri ) ; wirewebsocket ( servicename , message ) ; } try { if ( websocket . isclosed ( ) && connected ( ) ) { this . websocket . openandnotify ( netsocket -> { connected . set ( bool_ ) ; websocket . sendtext ( message , exceptionconsumer ) ; } , exceptionconsumer ) ; } else { websocket . sendtext ( message ) ; } } catch ( exception ex ) { this . connected . set ( bool_ ) ; if ( debug ) throw ex ; } }	Sends a message over websocket.
public < t > t createproxy ( final class < t > serviceinterface , final string servicename ) { return createproxy ( serviceinterface , servicename , str . join ( str_ , uri , servicename , uuid . randomuuid ( ) . tostring ( ) ) ) ; }	Creates a new client proxy given a client interface.
private receivequeuelistener < response < object > > createresponsequeuelistener ( ) { return new receivequeuelistener < response < object > > ( ) { @ override public void receive ( final response < object > response ) { if ( debug ) { logger . debug ( str_ + response ) ; } handleresponsefromservicebundle ( response , response . request ( ) . originatingrequest ( ) ) ; } @ override public void limit ( ) { httprequestserverhandler . checktimeoutsforrequests ( ) ; websockethandler . checkresponsebatchsend ( ) ; } @ override public void empty ( ) { httprequestserverhandler . checktimeoutsforrequests ( ) ; websockethandler . checkresponsebatchsend ( ) ; } @ override public void idle ( ) { httprequestserverhandler . checktimeoutsforrequests ( ) ; websockethandler . checkresponsebatchsend ( ) ; } } ; }	Creates the queue listener for method call responses from the client bundle.
@ override public receivequeue < t > receivequeue ( ) { final receivequeue < string > receivequeue = queue . receivequeue ( ) ; return new receivequeue < t > ( ) { @ override public t pollwait ( ) { final string item = receivequeue . pollwait ( ) ; return getparseditem ( item ) ; } private t getparseditem ( string item ) { if ( item != null ) { return fromjsonfunction . apply ( item ) ; } else { return null ; } } @ override public t poll ( ) { final string item = receivequeue . pollwait ( ) ; return getparseditem ( item ) ; } @ override public t take ( ) { final string item = receivequeue . take ( ) ; return getparseditem ( item ) ; } @ override public iterable < t > readbatch ( int max ) { final iterable < string > iterable = receivequeue . readbatch ( max ) ; return getparseditems ( iterable ) ; } private iterable < t > getparseditems ( iterable < string > iterable ) { int size = num_ ; if ( iterable instanceof list ) { size = ( ( list ) iterable ) . size ( ) ; } final list < t > items = new arraylist < > ( size ) ; for ( string item : iterable ) { items . add ( getparseditem ( item ) ) ; } return items ; } @ override public iterable < t > readbatch ( ) { final iterable < string > iterable = receivequeue . readbatch ( ) ; return getparseditems ( iterable ) ; } @ override public void stop ( ) { receivequeue . stop ( ) ; } } ; }	Create a wrapper ReceiveQueue that does decoding on the fly.
private sendqueue < t > createjsonsendqueue ( final sendqueue < string > sendqueue ) { return new sendqueue < t > ( ) { @ override public boolean send ( t item ) { sendqueue . send ( tojsonfunction . apply ( item ) ) ; return bool_ ; } @ override public void sendandflush ( t item ) { sendqueue . sendandflush ( tojsonfunction . apply ( item ) ) ; } @ override public void sendmany ( t ... items ) { for ( t item : items ) { sendqueue . send ( tojsonfunction . apply ( item ) ) ; } } @ override public void sendbatch ( collection < t > items ) { for ( t item : items ) { sendqueue . send ( tojsonfunction . apply ( item ) ) ; } } @ override public void sendbatch ( iterable < t > items ) { for ( t item : items ) { sendqueue . send ( tojsonfunction . apply ( item ) ) ; } } @ override public boolean shouldbatch ( ) { return sendqueue . shouldbatch ( ) ; } @ override public void flushsends ( ) { sendqueue . flushsends ( ) ; } @ override public int size ( ) { return sendqueue . size ( ) ; } @ override public string name ( ) { return sendqueue . name ( ) ; } @ override public void stop ( ) { sendqueue . stop ( ) ; } } ; }	Helper method to create SendQueue wrappers that do JSON encoding.
@ override public void startlistener ( final receivequeuelistener < t > listener ) { queue . startlistener ( item -> listener . receive ( fromjsonfunction . apply ( item ) ) ) ; }	Start a listener.
public servicequeue build ( ) { if ( debug ) logger . debug ( str_ ) ; servicequeuesizer servicequeuesizer = null ; if ( statsconfig != null ) { servicequeuesizer = new servicequeuesizer ( ) ; this . addqueuecallbackhandler ( new servicestatslistener ( statsconfig . servicename , statsconfig . statscollector , gettimer ( ) , statsconfig . flushtimeseconds , timeunit . seconds , statsconfig . sampleevery , servicequeuesizer ) ) ; } servicequeue servicequeue = new servicequeueimpl ( this . getrootaddress ( ) , this . getserviceaddress ( ) , this . getserviceobject ( ) , this . getrequestqueuebuilder ( ) , this . getresponsequeuebuilder ( ) , this . getservicemethodhandler ( ) , this . getresponsequeue ( ) , this . isasyncresponse ( ) , this . ishandlecallbacks ( ) , this . getsystemmanager ( ) , this . getbeforemethodcall ( ) , this . getbeforemethodcallaftertransform ( ) , this . getaftermethodcall ( ) , this . getaftermethodcallaftertransform ( ) , buildqueuecallbackhandler ( ) , getcallbackmanager ( ) , getbeforemethodsent ( ) , geteventmanager ( ) , isjoineventmanager ( ) ) ; if ( servicequeuesizer != null ) { servicequeuesizer . setservicequeue ( servicequeue ) ; } if ( qbitsystemmanager != null ) { qbitsystemmanager . registerservice ( servicequeue ) ; } return servicequeue ; }	Builds a service.
@ override public void checkinok ( final string name ) { if ( debug ) logger . debug ( str_ , name ) ; final nodehealthstat nodehealthstat = getservicehealthstat ( name ) ; nodehealthstat . setlastcheckin ( super . time ) ; nodehealthstat . setreason ( null ) ; nodehealthstat . setstatus ( healthstatus . pass ) ; super . incrementcount ( str_ ) ; oncheckin . ifpresent ( checkin -> checkin . accept ( beanutils . copy ( nodehealthstat ) ) ) ; }	Check in the service.
@ override public void failwitherror ( final string name , final throwable error ) { logger . error ( str_ , name ) ; super . incrementcount ( str_ ) ; final nodehealthstat nodehealthstat = getservicehealthstat ( name ) ; nodehealthstat . setstatus ( healthstatus . fail ) ; nodehealthstat . setreason ( healthfailreason . error ) ; nodehealthstat . setlastcheckin ( super . time ) ; nodehealthstat . seterror ( error ) ; onfail . ifpresent ( checkin -> checkin . accept ( beanutils . copy ( nodehealthstat ) ) ) ; }	Fail the node for the service with a specific status.
public managedservicebuilder enableloggingmappeddiagnosticcontext ( final set < string > requestheaders ) { this . enablerequestchain = bool_ ; this . enableloggingmappeddiagnosticcontext = bool_ ; this . requestheaderstotrackformappeddiagnosticcontext = collections . unmodifiableset ( requestheaders ) ; return this ; }	Enable the logging diagnostic context.
public managedservicebuilder enableconsulservicediscovery ( final string datacenter ) { final consulservicediscoverybuilder consulservicediscoverybuilder = consulservicediscoverybuilder ( ) ; consulservicediscoverybuilder . setdatacenter ( datacenter ) ; servicediscoverysupplier = consulservicediscoverybuilder :: build ; return this ; }	Enable consul discovery.
public adminbuilder getadminbuilder ( ) { if ( adminbuilder == null ) { adminbuilder = adminbuilder . adminbuilder ( ) ; final string qbitadminport = findadminport ( ) ; if ( qbitadminport != null && ! qbitadminport . isempty ( ) ) { adminbuilder . setport ( integer . parseint ( qbitadminport ) ) ; } adminbuilder . setcontextbuilder ( this . getcontextmetabuilder ( ) ) ; adminbuilder . sethealthservice ( gethealthservice ( ) ) ; adminbuilder . registerjavavmstatsjob ( getstatservicebuilder ( ) . buildstatscollector ( ) ) ; } return adminbuilder ; }	Get the Admin builder.
public contextmetabuilder getcontextmetabuilder ( ) { if ( contextmetabuilder == null ) { contextmetabuilder = contextmetabuilder . contextmetabuilder ( ) ; contextmetabuilder . sethostaddress ( this . getpublichost ( ) + str_ + this . getpublicport ( ) ) . setrooturi ( this . getrooturi ( ) ) ; } return contextmetabuilder ; }	Get context meta builder.
public managedservicebuilder addendpointservicewithservicemanagmentbundle ( final object endpointservice , final servicemanagementbundle servicemanagementbundle ) { addendpointservicewithaliasandqueuehandlercallbacks ( null , endpointservice , new queuecallbackhandler ( ) { @ override public void queueprocess ( ) { servicemanagementbundle . process ( ) ; } } ) ; return this ; }	Add an endpoint with a managment bundle.
public managedservicebuilder addendpointservicewithaliasandservicemanagmentbundle ( final string alias , final object endpointservice , final servicemanagementbundle servicemanagementbundle ) { addendpointservicewithaliasandqueuehandlercallbacks ( alias , endpointservice , new queuecallbackhandler ( ) { @ override public void queueprocess ( ) { servicemanagementbundle . process ( ) ; } } ) ; return this ; }	Add an endpoint with a managment bundle and an alias.
public managedservicebuilder addendpointservice ( final object endpointservice ) { getcontextmetabuilder ( ) . addservice ( endpointservice . getclass ( ) ) ; getendpointservices ( ) . add ( endpointservice ) ; return this ; }	Add an endpoint service.
public managedservicebuilder addendpointservice ( final string alias , final object endpointservice ) { getcontextmetabuilder ( ) . addservice ( alias , endpointservice . getclass ( ) ) ; getendpointservicemapwithalias ( ) . put ( alias , endpointservice ) ; return this ; }	Add endpoint service with alias.
public serviceendpointserver getserviceendpointserver ( ) { final serviceendpointserver serviceendpointserver = getendpointserverbuilder ( ) . build ( ) ; if ( managedservicedefinitionlist != null ) { managedservicedefinitionlist . foreach ( servicedef -> { if ( servicedef . getalias ( ) == null ) { serviceendpointserver . addservicewithqueuecallbackhandlers ( servicedef . getserviceobject ( ) , servicedef . getqueuecallbackhandlers ( ) ) ; } else { serviceendpointserver . addserviceobjectwithqueuecallbackhandlers ( servicedef . getalias ( ) , servicedef . getserviceobject ( ) , servicedef . getqueuecallbackhandlers ( ) ) ; } } ) ; } return serviceendpointserver ; }	Get the ServiceEndpointServer constructed with all of the service endpionts thatyou registered.
private interceptors configureinterceptors ( ) { interceptors interceptors = new interceptors ( ) ; setupmdcforhttprequestinterceptor setupmdcforhttprequestinterceptor ; if ( enableloggingmappeddiagnosticcontext ) { enablerequestchain = bool_ ; if ( requestheaderstotrackformappeddiagnosticcontext != null && requestheaderstotrackformappeddiagnosticcontext . size ( ) > num_ ) { setupmdcforhttprequestinterceptor = new setupmdcforhttprequestinterceptor ( requestheaderstotrackformappeddiagnosticcontext ) ; } else { setupmdcforhttprequestinterceptor = new setupmdcforhttprequestinterceptor ( collections . emptyset ( ) ) ; } interceptors . before . add ( setupmdcforhttprequestinterceptor ) ; interceptors . after . add ( setupmdcforhttprequestinterceptor ) ; } if ( enablerequestchain ) { final capturerequestinterceptor capturerequestinterceptor = new capturerequestinterceptor ( ) ; interceptors . before . add ( capturerequestinterceptor ) ; interceptors . after . add ( capturerequestinterceptor ) ; interceptors . beforesent . add ( new forwardcallmethodinterceptor ( new requestcontext ( ) ) ) ; } return interceptors ; }	Configure a list of common interceptors.
public boolean destroy ( final string sessionid , final session session , final string datacenter ) { final uri uri = createuri ( str_ + sessionid ) ; final httprequestbuilder httprequestbuilder = requestutils . gethttprequestbuilder ( datacenter , null , null , str_ ) ; http . response httpresponse = http . jsonrestcallviaput ( uri . tostring ( ) + str_ + httprequestbuilder . paramstring ( ) , tojson ( session ) ) ; if ( httpresponse == null || httpresponse . code ( ) != num_ ) { die ( str_ , sessionid , uri , httpresponse ) ; } return httpresponse . code ( ) == num_ ; }	Destroy the session.
@ override public list < endpointdefinition > loadservices ( final string servicename ) { if ( debug ) logger . debug ( str_ , servicename ) ; final countdownlatch countdownlatch = new countdownlatch ( num_ ) ; final atomicreference < list < endpointdefinition > > endpointsref = new atomicreference < > ( ) ; final atomicreference < throwable > exceptionatomicreference = new atomicreference < > ( ) ; dnssupport . loadserviceendpointsbyservicename ( callbackbuilder . newcallbackbuilder ( ) . withlistcallback ( endpointdefinition . class , endpointdefinitions -> { endpointsref . set ( endpointdefinitions ) ; countdownlatch . countdown ( ) ; } ) . witherrorhandler ( exceptionatomicreference :: set ) . build ( ) , servicename ) ; try { if ( debug ) logger . debug ( str_ , timeout , timeunit ) ; countdownlatch . await ( timeout , timeunit ) ; } catch ( interruptedexception e ) { throw new illegalstateexception ( str_ , e ) ; } if ( exceptionatomicreference . get ( ) != null ) { logger . error ( str_ , exceptionatomicreference . get ( ) ) ; throw new illegalstateexception ( str_ , exceptionatomicreference . get ( ) ) ; } else { if ( debug ) logger . debug ( str_ ) ; return endpointsref . get ( ) ; } }	Load the services.
private void delete ( string key , map < string , string > params ) { final uri uri = createuri ( str_ + key ) ; final httprequestbuilder httprequestbuilder = requestutils . gethttprequestbuilder ( null , null , requestoptions . blank , str_ ) ; final set < map . entry < string , string > > entries = params . entryset ( ) ; for ( map . entry < string , string > entry : entries ) { httprequestbuilder . addparam ( entry . getkey ( ) , entry . getvalue ( ) ) ; } httprequestbuilder . setmethoddelete ( ) ; final http . response httpresponse = http . deleteresponse ( uri . tostring ( ) + str_ + httprequestbuilder . paramstring ( ) ) ; if ( httpresponse . code ( ) != num_ ) { die ( str_ , uri , key , httpresponse . code ( ) , httpresponse . body ( ) ) ; } }	Deletes a specified key.
public void handlerequest ( final httprequest request ) { if ( debug ) { system . out . println ( str_ + request ) ; logger . debug ( str_ + request ) ; } if ( shouldcontinuehttprequest . test ( request ) ) { httprequestconsumer . accept ( request ) ; } }	Main entry point.
public void process ( ) { if ( ! receivequeue . ispresent ( ) ) { initqueue ( ) ; } receivequeue . ifpresent ( receivequeue -> { t item ; do { try { item = receivequeue . poll ( ) ; } catch ( exception ex ) { logger . debug ( str_ , ex ) ; initqueue ( ) ; item = null ; } if ( item != null ) { sendtoeventmanager ( item ) ; } } while ( item != null ) ; } ) ; }	Process. This can be called periodically and it will check to see if there are messages on the queue.
private void sendtoeventmanager ( t item ) { if ( debug ) { logger . debug ( str_ , item ) ; } try { if ( lock . trylock ( ) ) { eventmanager . sendarguments ( channel , item ) ; } else { lock . lock ( ) ; eventmanager . sendarguments ( channel , item ) ; } } finally { lock . unlock ( ) ; } }	Send the queue item to the event.
public void start ( ) { if ( ! queue . ispresent ( ) ) { initqueue ( ) ; } queue . ifpresent ( actualqueue -> actualqueue . startlistener ( eventbusqueueadapter . this :: sendtoeventmanager ) ) ; }	Start listener. Once this is called messages can come in on a foreign thread.
public optional < httprequest > gethttprequest ( ) { final optional < request < object > > request = this . getrequest ( ) ; if ( request . ispresent ( ) ) { return findhttprequest ( request . get ( ) ) ; } else { return optional . empty ( ) ; } }	Grab the current http request.
public void remove ( final eventconnector eventconnector ) { if ( eventconnector != null ) { try { if ( eventconnector instanceof remotetcpclientproxy ) { final remotetcpclientproxy remotetcpclientproxy = ( remotetcpclientproxy ) eventconnector ; logger . info ( str . sputs ( str_ , remotetcpclientproxy . host ( ) , str_ , remotetcpclientproxy . port ( ) , str_ , remotetcpclientproxy . connected ( ) ) ) ; remotetcpclientproxy . silentclose ( ) ; } this . eventconnectors . remove ( eventconnector ) ; } catch ( exception ex ) { logger . error ( str_ , ex ) ; } } }	Remove an event connector.
@ override public void forwardevent ( final eventtransferobject < object > event ) { if ( debug ) logger . debug ( str_ + event . channel ( ) + str_ + eventconnectors . size ( ) ) ; for ( int index = num_ ; index < eventconnectors . size ( ) ; index ++ ) { eventconnector eventconnector = null ; try { eventconnector = eventconnectors . get ( index ) ; eventconnector . forwardevent ( event ) ; } catch ( exception ex ) { logger . error ( str_ , ex ) ; if ( eventconnector instanceof remotetcpclientproxy ) { if ( ! ( ( remotetcpclientproxy ) eventconnector ) . connected ( ) ) { eventconnectors . remove ( eventconnector ) ; } } } } if ( debug ) logger . debug ( str_ + event . channel ( ) ) ; }	Forwards en event to another event system.
@ override public void flush ( ) { for ( int index = num_ ; index < eventconnectors . size ( ) ; index ++ ) { eventconnector eventconnector = null ; try { eventconnector = eventconnectors . get ( index ) ; if ( eventconnector instanceof clientproxy ) { serviceproxyutils . flushserviceproxy ( eventconnector ) ; } else { eventconnector . flush ( ) ; } } catch ( exception ex ) { logger . debug ( str_ , ex ) ; if ( eventconnector instanceof remotetcpclientproxy ) { if ( ! ( ( remotetcpclientproxy ) eventconnector ) . connected ( ) ) { eventconnectors . remove ( eventconnector ) ; } } } } }	Flushes the pool used to optimize flushing of IO operations.
public static microserviceconfig readconfig ( final string servicename ) { final logger logger = loggerfactory . getlogger ( microserviceconfig . class ) ; if ( new file ( resourcelocation ) . exists ( ) ) { final string json = io . read ( resourcelocation ) ; return jsonfactory . fromjson ( json , microserviceconfig . class ) ; } else if ( resourcelocationenv != null && new file ( resourcelocationenv ) . exists ( ) ) { final string json = io . read ( resourcelocationenv ) ; return jsonfactory . fromjson ( json , microserviceconfig . class ) ; } else { logger . info ( str_ ) ; final string qbitenv = system . getenv ( str_ ) ; final string resourcelocationonclasspath = qbitenv != null && ! qbitenv . isempty ( ) ? servicename + str_ + qbitenv + str_ : servicename + str_ ; final string json = io . read ( thread . currentthread ( ) . getcontextclassloader ( ) . getresourceasstream ( resourcelocationonclasspath ) ) ; return jsonfactory . fromjson ( json , microserviceconfig . class ) ; } }	Reads the readConfig file, which can be a classpath or file system resource.
private void registerhandlercallbackforclient ( final methodcall < object > methodcall , final callback < object > handler ) { final handlerkey handlerkey = new handlerkey ( methodcall . returnaddress ( ) , methodcall . address ( ) , methodcall . id ( ) , methodcall . timestamp ( ) ) ; if ( debug ) { if ( handlers . containskey ( handlerkey ) ) { logger . debug ( str_ , handlerkey ) ; } } handlers . put ( handlerkey , handler ) ; }	Register a callbackWithTimeout handler.
@ override public boolean before ( final methodcall methodcall ) { final optional < httprequest > httprequest = findhttprequest ( methodcall ) ; if ( httprequest . ispresent ( ) ) { extractrequestinfoandputitintomappeddiagnosticcontext ( httprequest . get ( ) ) ; } return bool_ ; }	Gets called before a method gets invoked on a service.This adds request URI, remote address and request headers of the HttpRequest if found.
private void extractrequestinfoandputitintomappeddiagnosticcontext ( final httprequest httprequest ) { mdc . put ( request_uri , httprequest . geturi ( ) ) ; mdc . put ( request_remote_address , httprequest . getremoteaddress ( ) ) ; mdc . put ( request_http_method , httprequest . getmethod ( ) ) ; mdc . put ( request_id , long . tostring ( httprequest . getmessageid ( ) ) ) ; extractheaders ( httprequest ) ; }	Extract request data and put it into the logging Mapped Diagnostic Context.
private void extractheaders ( final httprequest httprequest ) { if ( headerstoaddtologgingmappingdiagnosticscontext . size ( ) > num_ ) { final multimap < string , string > headers = httprequest . getheaders ( ) ; headerstoaddtologgingmappingdiagnosticscontext . foreach ( header -> { string value = headers . getfirst ( header ) ; if ( ! str . isempty ( value ) ) { mdc . put ( request_header_prefix + header , value ) ; } } ) ; } }	Extract headersToAddToLoggingMappingDiagnosticsContext data and put them into the logging mapping diagnostics context.
@ override public void handlerestcall ( final httprequest request ) { final list < string > errorlist = new arraylist < > ( num_ ) ; final methodcall < object > methodcall = standardrequesttransformer . transform ( request , errorlist ) ; if ( methodcall != null && errorlist . size ( ) == num_ ) { if ( ! addrequesttocheckfortimeouts ( request ) ) { handleoverflow ( request ) ; return ; } sendmethodtoservicebundle ( methodcall ) ; } else { if ( ! request . ishandled ( ) ) { handleerrorconverting ( request , errorlist , methodcall ) ; } return ; } final requestmetadata requestmetadata = metadataprovidermap . get ( requestmethod . valueof ( request . getmethod ( ) ) ) . get ( request . address ( ) ) ; final servicemethodmeta servicemethod = requestmetadata . getmethod ( ) ; if ( servicemethod . getmethodaccess ( ) . returntype ( ) == void . class && ! servicemethod . hascallback ( ) ) { request . handled ( ) ; final int responsecode = servicemethod . getresponsecode ( ) ; writeresponse ( request . getreceiver ( ) , responsecode == - num_ ? httpstatus . accepted : responsecode , servicemethod . getcontenttype ( ) , str_ , requestmetadata . getrequest ( ) . getresponseheaders ( ) ) ; } }	MOST IMPORTANT METHOD FOR DEBUGGING WHY SOMETHING IS NOT CALLED.
@ override public void handleresponsefromservicetohttpresponse ( final response < object > response , final httprequest originatingrequest ) { final string key = str . add ( str_ + originatingrequest . id ( ) , str_ , originatingrequest . returnaddress ( ) ) ; this . outstandingrequestmap . remove ( key ) ; if ( response . waserrors ( ) ) { handleerror ( response , originatingrequest ) ; } else { if ( response . body ( ) instanceof httpresponse ) { writehttpresponse ( originatingrequest . getreceiver ( ) , ( ( httpresponse ) response . body ( ) ) ) ; } else { final requestmetadata requestmetadata = metadataprovidermap . get ( requestmethod . valueof ( originatingrequest . getmethod ( ) ) ) . get ( originatingrequest . address ( ) ) ; final servicemethodmeta servicemethodmeta = requestmetadata . getmethod ( ) ; final int responsecode = servicemethodmeta . getresponsecode ( ) ; multimap < string , string > headers = response . headers ( ) ; if ( requestmetadata . getrequest ( ) . hasresponseheaders ( ) ) { if ( response . headers ( ) == multimap . empty ) { headers = new multimapimpl < > ( ) ; } else { headers = response . headers ( ) ; } headers . putallcopylists ( requestmetadata . getrequest ( ) . getresponseheaders ( ) ) ; } writeresponse ( originatingrequest . getreceiver ( ) , responsecode == - num_ ? httpstatus . ok : responsecode , servicemethodmeta . getcontenttype ( ) , jsonmapper . tojson ( response . body ( ) ) , headers ) ; } } }	2nd MOST IMPORTANT METHOD FOR DEBUGGING WHY SOMETHING IS NOT CALLED.
private boolean addrequesttocheckfortimeouts ( final request < object > request ) { string key = str . add ( str_ + request . id ( ) , str_ , request . returnaddress ( ) ) ; this . outstandingrequestmap . put ( key , request ) ; return outstandingrequestmap . size ( ) < numberofoutstandingrequests ; }	Add a request to the timeout queue.
@ override public boolean add ( long integer ) { if ( end + num_ >= values . length ) { values = lng . grow ( values ) ; } values [ end ] = integer ; end ++ ; return bool_ ; }	Add a new value to the list.
@ suppresswarnings ( str_ ) public statlist add ( int integer ) { if ( end + num_ >= values . length ) { values = lng . grow ( values ) ; } values [ end ] = integer ; end ++ ; return this ; }	Add a new value to the list but don't employ a wrapper.
public boolean addarray ( long ... newvalues ) { if ( end + newvalues . length >= values . length ) { values = lng . grow ( values , ( values . length + newvalues . length ) * num_ ) ; } system . arraycopy ( newvalues , num_ , values , end , newvalues . length ) ; end += newvalues . length ; return bool_ ; }	Add a new array to the list.
@ override public long set ( int index , long element ) { long oldvalue = values [ index ] ; values [ index ] = element ; return oldvalue ; }	Set a value in the list.
public long reduceby ( object function , string name ) { return lng . reduceby ( values , end , function , name ) ; }	This would be a good opportunity to reintroduce dynamic invoke.
@ override public void beforemethodsent ( final methodcallbuilder methodbuilder ) { if ( methodbuilder . getoriginatingrequest ( ) == null ) { final optional < request < object > > request = requestcontext . getrequest ( ) ; if ( request . ispresent ( ) ) { methodbuilder . setoriginatingrequest ( request . get ( ) ) ; } } }	Intercept the call before it gets sent to the service queue.
private void notifylistener ( changenotification < t > changenotification , boolean newlistener ) { lock . lock ( ) ; try { checknotnull ( changenotification , str_ ) ; final listener < t > listener = listenerref . get ( ) ; if ( listener != null ) { try { final boolean notified = listenernotified . getandset ( bool_ ) ; if ( ! ( newlistener && notified ) ) { listener . onchange ( changenotification ) ; } } catch ( throwable e ) { log . error ( str_ , e ) ; } } } finally { lock . unlock ( ) ; } }	Notify the listener about a change.
public static kryo adddefaultserializers ( kryo kryo ) { arraylistsublistserializer . adddefaultserializer ( kryo ) ; abstractlistsublistserializer . adddefaultserializer ( kryo ) ; javautilsublistserializer . adddefaultserializer ( kryo ) ; return kryo ; }	Adds appropriate sublist serializers as default serializers.
private method getparsefrommethod ( class < ? extends t > type ) throws nosuchmethodexception { if ( parsefrommethod == null ) { parsefrommethod = type . getmethod ( str_ , byte [ ] . class ) ; } return parsefrommethod ; }	Caches method reflection lookup.
private char _verifynoleadingzeroes ( ) throws ioexception , jsonparseexception {	Method called when we have seen one zero, and want to ensureit is not followed by another.
protected string _parseunquotedfieldname ( int i ) throws ioexception , jsonparseexception {	Method called when we see non-white space character otherthan double quote, when expecting a field name.In standard mode will just throw an expection; butin non-standard modes may be able to parse name.
protected jsontoken _handleunexpectedvalue ( int i ) throws ioexception , jsonparseexception {	Method for handling cases where first non-space characterof an expected value token is not legal for standard JSON content.
protected void _skipstring ( ) throws ioexception , jsonparseexception { _tokenincomplete = bool_ ; int inputptr = _inputptr ; int inputlen = _inputend ; char [ ] inputbuffer = _inputbuffer ; while ( bool_ ) { if ( inputptr >= inputlen ) { _inputptr = inputptr ; if ( ! loadmore ( ) ) { _reportinvalideof ( str_ ) ; } inputptr = _inputptr ; inputlen = _inputend ; } char c = inputbuffer [ inputptr ++ ] ; if ( c == int_apostrophe ) { _inputptr = inputptr ; break ; } else if ( c == str_ ) { _inputptr = inputptr ; _decodeescaped ( ) ; inputptr = _inputptr ; inputlen = _inputend ; } } }	Method called to skim through rest of unparsed String value,if it is not needed.
protected void _matchtoken ( string matchstr , int i ) throws ioexception , jsonparseexception { final int len = matchstr . length ( ) ; do { if ( _inputptr >= _inputend ) { if ( ! loadmore ( ) ) { _reportinvalideofinvalue ( ) ; } } if ( _inputbuffer [ _inputptr ] != matchstr . charat ( i ) ) { _reportinvalidtoken ( matchstr . substring ( num_ , i ) , str_ ) ; } ++ _inputptr ; } while ( ++ i < len ) ;	Helper method for checking whether input matches expected token.
protected byte [ ] _decodebase64 ( base64variant b64variant ) throws ioexception , jsonparseexception { bytearraybuilder builder = _getbytearraybuilder ( ) ;	Efficient handling for incremental parsing of base64-encodedtextual content.
public static boolean isidstrict ( string string ) { int len = string . length ( ) ; if ( len == num_ ) { return bool_ ; } if ( ! isidstartstrict ( string . charat ( num_ ) ) ) { return bool_ ; } for ( int i = num_ ; i < len ; i ++ ) { if ( ! isidcharstrict ( string . charat ( i ) ) ) { return bool_ ; } } return bool_ ; }	Returns true if a string does not need to be quoted when serialized.Uses the strict definition described in the Rison specification, appropriate for encoding.
public static boolean isidstrict ( char [ ] chars , int offset , int len ) { if ( len == num_ ) { return bool_ ; } int end = offset + len ; if ( ! isidstartstrict ( chars [ offset ++ ] ) ) { return bool_ ; } while ( offset < end ) { if ( ! isidcharstrict ( chars [ offset ++ ] ) ) { return bool_ ; } } return bool_ ; }	Returns true if the string represented by the specified character array does notUses the strict definition described in the Rison specification, appropriate for encoding.
private void _writestring ( char [ ] text , int offset , int len ) throws ioexception , jsongenerationexception { len += offset ;	This method called when the string content is already ina char buffer, and need not be copied for processing.
private int _prependorwrite ( char [ ] buffer , int ptr , char esc ) throws ioexception , jsongenerationexception { if ( ptr > num_ ) {	Method called to try to either prepend character escape at front ofgiven buffer; or if not possible, to write it out directly.
private void _appendcharacterescape ( char esc , char ch ) throws ioexception , jsongenerationexception { if ( ( _outputtail + num_ ) >= _outputend ) { _flushbuffer ( ) ; } _outputbuffer [ _outputtail ++ ] = esc ; _outputbuffer [ _outputtail ++ ] = ch ; }	Method called to append escape sequence for given character, at theend of standard output buffer; or if not possible, write out directly.
public static void setconversionproperties ( configuration conf ) { if ( conf != null ) { useenumid = conf . getboolean ( use_enum_id_conf_key , bool_ ) ; log . debug ( str_ + useenumid ) ; } }	Set the flags that can be used by the conversion.
public static string topigscript ( class < ? extends tbase < ? , ? > > thriftclass , class < ? extends loadfunc > pigloader ) { stringbuilder sb = new stringbuilder ( ) ; stringbuilder prefix = new stringbuilder ( str_ ) ; sb . append ( str_ ) . append ( pigloader . getname ( ) ) . append ( str_ ) . append ( thriftclass . getname ( ) ) . append ( str_ ) . append ( prefix ) . append ( str_ ) ; prefix . append ( str_ ) ; try { stringifyschema ( sb , toschema ( thriftclass ) , datatype . tuple , prefix ) ; } catch ( frontendexception e ) { throw new runtimeexception ( e ) ; } sb . append ( str_ ) ; return sb . tostring ( ) ; }	Turn a Thrift Struct into a loading schema for a pig script.
public static void stringifyschema ( stringbuilder sb , schema schema , byte type , stringbuilder prefix ) throws frontendexception {	type can only be BAG or TUPLE.
protected indexreader openindex ( path path , configuration conf ) throws ioexception { return directoryreader . open ( new lucenehdfsdirectory ( path , path . getfilesystem ( conf ) ) ) ; }	Open an index stored in pathOverride if you want more control over how indexes are opened.
@ override public float getprogress ( ) { if ( numindexes < num_ ) { return num_ ; } float indexprogress = ( float ) currentindexpathiter . previousindex ( ) / ( float ) numindexes ; float queriesprogress = num_ ; if ( queries . size ( ) > num_ ) { queriesprogress = ( float ) currentqueryiter . previousindex ( ) / ( float ) queries . size ( ) ; } queriesprogress *= num_ / numindexes ; return indexprogress + queriesprogress ; }	This is sort of an approximation of progress.It splits the progress equally among all indexes, then among all queries for that index.So it won't move linearly, since we don't know how many hits there will be per query.
public tuple totuple ( message msg ) { if ( msg == null ) {	Turn a generic message into a Tuple.
@ suppresswarnings ( str_ ) protected object messagetotuple ( fielddescriptor fielddescriptor , object fieldvalue ) { if ( fieldvalue == null ) {	Translate a nested message to a tuple.
@ suppresswarnings ( str_ ) protected object singlefieldtotuple ( fielddescriptor fielddescriptor , object fieldvalue ) { assert fielddescriptor . gettype ( ) != fielddescriptor . type . message : str_ + fielddescriptor . gettype ( ) ; if ( fielddescriptor . isrepeated ( ) ) {	Translate a single field to a tuple.
private object coercetopigtypes ( fielddescriptor fielddescriptor , object fieldvalue ) { if ( fielddescriptor . gettype ( ) == fielddescriptor . type . enum && fieldvalue != null ) { enumvaluedescriptor enumvaluedescriptor = ( enumvaluedescriptor ) fieldvalue ; return enumvaluedescriptor . getname ( ) ; } else if ( fielddescriptor . gettype ( ) == fielddescriptor . type . bool && fieldvalue != null ) { boolean boolvalue = ( boolean ) fieldvalue ; return new integer ( boolvalue ? num_ : num_ ) ; } else if ( fielddescriptor . gettype ( ) == fielddescriptor . type . bytes && fieldvalue != null ) { bytestring bsvalue = ( bytestring ) fieldvalue ; return new databytearray ( bsvalue . tobytearray ( ) ) ; } return fieldvalue ; }	If the given field value is an enum, translate it to the enum's name as a string, since Pig cannot handle enums.Also, if the given field value is a bool, translate it to 0 or 1 to avoid Pig bools, which can be sketchy.
public schema toschema ( descriptor msgdescriptor ) { schema schema = new schema ( ) ; try {	Turn a generic message descriptor into a Schema.
private fieldschema messagetofieldschema ( fielddescriptor fielddescriptor ) throws frontendexception { assert fielddescriptor . gettype ( ) == fielddescriptor . type . message : str_ + fielddescriptor . gettype ( ) ; schema innerschema = toschema ( fielddescriptor . getmessagetype ( ) ) ; if ( fielddescriptor . isrepeated ( ) ) { schema tupleschema = new schema ( ) ; tupleschema . add ( new fieldschema ( fielddescriptor . getname ( ) + str_ , innerschema , datatype . tuple ) ) ; return new fieldschema ( fielddescriptor . getname ( ) , tupleschema , datatype . bag ) ; } else { return new fieldschema ( fielddescriptor . getname ( ) , innerschema , datatype . tuple ) ; } }	Turn a nested message into a Schema object.
private fieldschema singlefieldtofieldschema ( fielddescriptor fielddescriptor ) throws frontendexception { assert fielddescriptor . gettype ( ) != fielddescriptor . type . message : str_ + fielddescriptor . gettype ( ) ; if ( fielddescriptor . isrepeated ( ) ) { schema itemschema = new schema ( ) ; itemschema . add ( new fieldschema ( fielddescriptor . getname ( ) , null , getpigdatatype ( fielddescriptor ) ) ) ; schema itemtupleschema = new schema ( ) ; itemtupleschema . add ( new fieldschema ( fielddescriptor . getname ( ) + str_ , itemschema , datatype . tuple ) ) ; return new fieldschema ( fielddescriptor . getname ( ) + str_ , itemtupleschema , datatype . bag ) ; } else { return new fieldschema ( fielddescriptor . getname ( ) , null , getpigdatatype ( fielddescriptor ) ) ; } }	Turn a single field into a Schema object.
public string topigscript ( descriptor msgdescriptor , string loaderclassname ) { stringbuffer sb = new stringbuffer ( ) ; final int initialtaboffset = num_ ; sb . append ( str_ + loaderclassname + str_ ) . append ( str_ ) ; sb . append ( tabs ( initialtaboffset ) ) . append ( str_ ) . append ( str_ ) ; sb . append ( topigscriptinternal ( msgdescriptor , initialtaboffset ) ) ; sb . append ( tabs ( initialtaboffset ) ) . append ( str_ ) . append ( str_ ) . append ( str_ ) ; return sb . tostring ( ) ; }	Turn a generic message descriptor into a loading schema for a pig script.
private stringbuffer topigscriptinternal ( descriptor msgdescriptor , int numtabs ) { stringbuffer sb = new stringbuffer ( ) ; try {	Turn a generic message descriptor into a loading schema for a pig script.
private stringbuffer messagetopigscript ( fielddescriptor fielddescriptor , int numtabs , boolean islast ) throws frontendexception { assert fielddescriptor . gettype ( ) == fielddescriptor . type . message : str_ + fielddescriptor . gettype ( ) ; if ( fielddescriptor . isrepeated ( ) ) { return new stringbuffer ( ) . append ( tabs ( numtabs ) ) . append ( fielddescriptor . getname ( ) ) . append ( str_ ) . append ( str_ ) . append ( tabs ( numtabs + num_ ) ) . append ( fielddescriptor . getname ( ) ) . append ( str_ ) . append ( str_ ) . append ( topigscriptinternal ( fielddescriptor . getmessagetype ( ) , numtabs + num_ ) ) . append ( tabs ( numtabs + num_ ) ) . append ( str_ ) . append ( str_ ) . append ( tabs ( numtabs ) ) . append ( str_ ) . append ( islast ? str_ : str_ ) . append ( str_ ) ; } else { return new stringbuffer ( ) . append ( tabs ( numtabs ) ) . append ( fielddescriptor . getname ( ) ) . append ( str_ ) . append ( str_ ) . append ( topigscriptinternal ( fielddescriptor . getmessagetype ( ) , numtabs + num_ ) ) . append ( tabs ( numtabs ) ) . append ( str_ ) . append ( islast ? str_ : str_ ) . append ( str_ ) ; } }	Turn a nested message into a pig script load string.
private stringbuffer singlefieldtopigscript ( fielddescriptor fielddescriptor , int numtabs , boolean islast ) throws frontendexception { assert fielddescriptor . gettype ( ) != fielddescriptor . type . message : str_ + fielddescriptor . gettype ( ) ; if ( fielddescriptor . isrepeated ( ) ) { return new stringbuffer ( ) . append ( tabs ( numtabs ) ) . append ( fielddescriptor . getname ( ) ) . append ( str_ ) . append ( str_ ) . append ( tabs ( numtabs + num_ ) ) . append ( fielddescriptor . getname ( ) ) . append ( str_ ) . append ( str_ ) . append ( tabs ( numtabs + num_ ) ) . append ( fielddescriptor . getname ( ) ) . append ( str_ ) . append ( getpigscriptdatatype ( fielddescriptor ) ) . append ( str_ ) . append ( tabs ( numtabs + num_ ) ) . append ( str_ ) . append ( str_ ) . append ( tabs ( numtabs ) ) . append ( str_ ) . append ( islast ? str_ : str_ ) . append ( str_ ) ; } else { return new stringbuffer ( ) . append ( tabs ( numtabs ) ) . append ( fielddescriptor . getname ( ) ) . append ( str_ ) . append ( getpigscriptdatatype ( fielddescriptor ) ) . append ( islast ? str_ : str_ ) . append ( str_ ) ; } }	Turn a single field into a pig script load string.
public static tstructdescriptor getinstance ( class < ? extends tbase < ? , ? > > tclass ) { synchronized ( structmap ) { tstructdescriptor desc = structmap . get ( tclass ) ; if ( desc == null ) { desc = new tstructdescriptor ( ) ; desc . tclass = tclass ; structmap . put ( tclass , desc ) ; desc . build ( tclass ) ; } return desc ; } }	Creates a descriptor for a Thrift class.
static private map < string , tenum > extractenummap ( class < ? extends tenum > enumclass ) { immutablemap . builder < string , tenum > builder = immutablemap . builder ( ) ; for ( tenum e : enumclass . getenumconstants ( ) ) { builder . put ( e . tostring ( ) , e ) ; } return builder . build ( ) ; }	returns 'enum name -> enum object' mapping.Currently used for converting Tuple to a Thrift object.
public static pathfilter newindexdirfilter ( configuration conf ) { return new pathfilters . compositepathfilter ( pathfilters . newexcludefilesfilter ( conf ) , pathfilters . exclude_hidden_paths_filter , new pathfilter ( ) { @ override public boolean accept ( path path ) { return path . getname ( ) . startswith ( str_ ) ; } } ) ; }	Creates a path filter that accepts non-hidden directories that start with "index-"This is what the indexes created by this output format look like,so this is useful for finding them when traversing the file system.
public static boolean usedynamicprotomessage ( class < ? > protoclass ) { return protoclass == null || protoclass . getcanonicalname ( ) . equals ( dynamicmessage . class . getcanonicalname ( ) ) ; }	For a configured protoClass, should the message be dynamic or is it a pre-generated Message class? If protoClass isnull or set to DynamicMessage.class, then the configurer intends for a dynamically generated protobuf to be used.
public static < m extends message > typeref < m > gettyperef ( string protoclassname ) { return new typeref < m > ( getprotobufclass ( protoclassname ) ) { } ; }	Returns typeref for a Protobuf class.
@ override public float getprogress ( ) { if ( start_ == end_ ) { return num_ ; } else { return math . min ( num_ , ( pos_ - start_ ) / ( float ) ( end_ - start_ ) ) ; } }	Get the progress within the split.
private byte [ ] serialize ( ) { if ( messagebytes == null && message != null ) { checkconverter ( ) ; messagebytes = converter . tobytes ( message ) ; if ( messagebytes == null ) {	Converts the message to raw bytes, and caches the converted value.
public static void setinputformat ( class < ? > realinputformatclass , configuration conf ) { conf . setclass ( str_ , deprecatedinputformatwrapper . class , org . apache . hadoop . mapred . inputformat . class ) ; hadooputils . setclassconf ( conf , class_conf_key , realinputformatclass ) ; }	For cases where we need to set hadoop1 input format in a hadoop2 Configuration object.
public static void setclassconf ( configuration conf , string configkey , class < ? > clazz ) { string existingclass = conf . get ( configkey ) ; string classname = clazz . getname ( ) ; if ( existingclass != null && ! existingclass . equals ( classname ) ) { throw new runtimeexception ( str_ + configkey + str_ + existingclass + str_ + classname ) ; } else { conf . set ( configkey , classname ) ; } }	A helper to set configuration to class name.Throws a RuntimeExcpetion if theconfiguration is already set to a different class name.
public static void writestringlisttoconfasjson ( string key , list < string > list , configuration conf ) { preconditions . checknotnull ( list ) ; conf . set ( key , jsonarray . tojsonstring ( list ) ) ; }	Writes a list of strings into a configuration by converting it to a json array.
@ suppresswarnings ( str_ ) public static list < string > readstringlistfromconfasjson ( string key , configuration conf ) { string json = conf . get ( key ) ; if ( json == null ) { return null ; } return lists . < string > newarraylist ( ( ( jsonarray ) jsonvalue . parse ( json ) ) ) ; }	Reads a list of strings stored as a json array from a configuration.
public static void writestringlisttoconfasbase64 ( string key , list < string > list , configuration conf ) { preconditions . checknotnull ( list ) ; iterator < string > iter = list . iterator ( ) ; stringbuilder sb = new stringbuilder ( ) ; while ( iter . hasnext ( ) ) { byte [ ] bytes = base64 . encodebase64 ( iter . next ( ) . getbytes ( charsets . utf_8 ) , bool_ ) ; sb . append ( new string ( bytes , charsets . utf_8 ) ) ; if ( iter . hasnext ( ) ) { sb . append ( str_ ) ; } } conf . set ( key , sb . tostring ( ) ) ; }	Writes a list of strings into a configuration by base64 encoding them and separatingthem with commas.
@ suppresswarnings ( str_ ) public static list < string > readstringlistfromconfasbase64 ( string key , configuration conf ) { string b64list = conf . get ( key ) ; if ( b64list == null ) { return null ; } list < string > strings = lists . newarraylist ( ) ; for ( string b64 : comma_splitter . split ( b64list ) ) { byte [ ] bytes = base64 . decodebase64 ( b64 . getbytes ( charsets . utf_8 ) ) ; strings . add ( new string ( bytes , charsets . utf_8 ) ) ; } return strings ; }	Reads a list of strings stored as comma separated base64.
private static void verifyancestry ( class < ? > tclass ) { if ( ! tbase . class . isassignablefrom ( tclass ) ) { utils . ensureclassloaderconsistency ( tbase . class , tclass . getclassloader ( ) ) ; throw new classcastexception ( tclass . getname ( ) + str_ ) ; } }	Verify that clazz is a Thrift class.
public static < m > m getfieldvalue ( object containingobject , string fieldname , class < m > fieldclass ) { return getfieldvalue ( containingobject . getclass ( ) , containingobject , fieldname , fieldclass ) ; }	Returns value of a fieldName in an object.
public static < m > m getfieldvalue ( class < ? > containingclass , string fieldname , class < m > fieldclass ) { return getfieldvalue ( containingclass , null , fieldname , fieldclass ) ; }	Returns value of a static field with given name in containingClass.
public static class < ? > getfieldvaluetype ( field field ) { switch ( field . gettype ( ) ) { case ttype . bool : return boolean . class ; case ttype . byte : return byte . class ; case ttype . double : return double . class ; case ttype . enum : return field . getenumclass ( ) ; case ttype . i16 : return short . class ; case ttype . i32 : return integer . class ; case ttype . i64 : return long . class ; case ttype . list : return list . class ; case ttype . map : return map . class ; case ttype . set : return set . class ; case ttype . stop : return null ; case ttype . string : return string . class ; case ttype . struct : return field . gettstructdescriptor ( ) . getthriftclass ( ) ; case ttype . void : return null ; } return null ; }	Returns the value class of the given thrift field.
public static void writefieldnotag ( tprotocol proto , field field , object value ) throws texception { if ( value == null ) { return ; } field innerfield = null ; switch ( field . gettype ( ) ) { case ttype . list : innerfield = field . getlistelemfield ( ) ; break ; case ttype . set : innerfield = field . getsetelemfield ( ) ; break ; case ttype . map : innerfield = field . getmapkeyfield ( ) ; break ; default : writesinglefieldnotag ( proto , field , value ) ; return ; }	Serializes a single field of a thrift struct.
public static message tupletomessage ( builder builder , tuple tuple ) { return tupletomessage ( builder , builder . getdescriptorfortype ( ) . getfields ( ) , tuple ) ; }	Turn a Tuple into a Message with the given type.
private static object tuplefieldtosinglefield ( fielddescriptor fielddescriptor , object tuplefield ) {	Converts a tupleField string to its corresponding protobuf enum type if necessary, otherwisereturns the tupleField as is.
private static void addfield ( descriptorproto . builder builder , string name , int fieldid , type type ) { fielddescriptorproto . builder fdbuilder = fielddescriptorproto . newbuilder ( ) . setname ( name ) . setnumber ( fieldid ) . settype ( type ) ; builder . addfield ( fdbuilder . build ( ) ) ; }	Add a field to a protobuf builder.
private static type pigtypetoprototype ( byte pigtypeid ) { switch ( pigtypeid ) { case datatype . boolean : return type . type_bool ; case datatype . integer : return type . type_int32 ; case datatype . long : return type . type_int64 ; case datatype . float : return type . type_float ; case datatype . double : return type . type_double ; case datatype . chararray : return type . type_string ; case datatype . bytearray : return type . type_bytes ; default : throw new illegalargumentexception ( str_ + pigtypeid + str_ ) ; } }	For a given Pig type, return the protobufs type that maps to it.
@ suppresswarnings ( str_ ) private static tbase < ? , ? > tothrift ( tstructdescriptor tdesc , tuple tuple ) { int size = tdesc . getfields ( ) . size ( ) ; int tuplesize = tuple . size ( ) ; @ suppresswarnings ( str_ ) tbase tobj = newtinstance ( tdesc . getthriftclass ( ) ) ; for ( int i = num_ ; i < size && i < tuplesize ; i ++ ) { object pobj ; try { pobj = tuple . get ( i ) ; } catch ( execexception e ) { throw new runtimeexception ( e ) ; } if ( pobj != null ) { field field = tdesc . getfieldat ( i ) ; try { tobj . setfieldvalue ( field . getfieldidenum ( ) , tothriftvalue ( field , pobj ) ) ; } catch ( exception e ) { string value = string . valueof ( tobj ) ; final int max_length = num_ ; if ( max_length < value . length ( ) ) { value = value . substring ( num_ , max_length - num_ ) + str_ ; } string type = tobj == null ? str_ : tobj . getclass ( ) . getname ( ) ; throw new runtimeexception ( string . format ( str_ , field . getname ( ) , value , type , i ) , e ) ; } }	Construct a Thrift object from the tuple.
@ suppresswarnings ( str_ ) public static object tothriftvalue ( field thriftfield , object pigvalue ) { try { switch ( thriftfield . gettype ( ) ) { case ttype . bool : return boolean . valueof ( ( ( integer ) pigvalue ) != num_ ) ; case ttype . byte : return ( ( integer ) pigvalue ) . bytevalue ( ) ; case ttype . i16 : return short . valueof ( ( ( integer ) pigvalue ) . shortvalue ( ) ) ; case ttype . string : return tostringtype ( pigvalue ) ; case ttype . struct : return tothrift ( thriftfield . gettstructdescriptor ( ) , ( tuple ) pigvalue ) ; case ttype . map : return tothriftmap ( thriftfield , ( map < string , object > ) pigvalue ) ; case ttype . set : return tothriftset ( thriftfield . getsetelemfield ( ) , ( databag ) pigvalue ) ; case ttype . list : return tothriftlist ( thriftfield . getlistelemfield ( ) , ( databag ) pigvalue ) ; case ttype . enum : return tothriftenum ( thriftfield , ( string ) pigvalue ) ; default :	For a given Pig value, return a Thrift object of the same type as the Thrift field passed.
private static tbase < ? , ? > newtinstance ( class < ? > tclass ) { try { return ( tbase < ? , ? > ) tclass . newinstance ( ) ; } catch ( exception e ) {	return an instance assuming tClass is a Thrift class.
public static void setcombinedinputformatdelegate ( configuration conf , class < ? extends inputformat > clazz ) { hadooputils . setclassconf ( conf , combined_input_format_delegate , clazz ) ; }	This sets configures the delegate, though it does not configure DelegateCombineFileInputFormat.
protected priorityqueue < luceneindexinputsplit > findsplits ( configuration conf ) throws ioexception { priorityqueue < luceneindexinputsplit > splits = new priorityqueue < luceneindexinputsplit > ( ) ; list < path > indexdirs = lists . newlinkedlist ( ) ;	Finds and creates all the index splits based on the input paths set in conf.
public static void setinputpaths ( list < path > paths , configuration conf ) throws ioexception { preconditions . checknotnull ( paths ) ; preconditions . checkargument ( ! paths . isempty ( ) ) ; string [ ] pathstrs = new string [ paths . size ( ) ] ; int i = num_ ; for ( path p : paths ) { filesystem fs = p . getfilesystem ( conf ) ; pathstrs [ i ++ ] = fs . makequalified ( p ) . tostring ( ) ; } conf . setstrings ( input_paths_key , pathstrs ) ; }	Sets the input paths for for this input format.All paths will be searched for indexes recursively.
public static path [ ] getinputpaths ( configuration conf ) { string [ ] pathstrs = preconditions . checknotnull ( conf . getstrings ( input_paths_key ) , str_ ) ; path [ ] paths = new path [ pathstrs . length ] ; for ( int i = num_ ; i < pathstrs . length ; i ++ ) { paths [ i ] = new path ( pathstrs [ i ] ) ; } return paths ; }	Gets the input paths for this input format.
public void add ( inputsplit split ) throws ioexception , interruptedexception { splits . add ( split ) ; totalsplitsizes += split . getlength ( ) ; locations = null ; }	Add an InputSplit to this collection.
public static byte evaluatedelimiter ( string inputdelimiter ) { if ( inputdelimiter . length ( ) == num_ ) { return inputdelimiter . getbytes ( ) [ num_ ] ; } else if ( inputdelimiter . length ( ) > num_ && inputdelimiter . charat ( num_ ) == str_ ) { switch ( inputdelimiter . charat ( num_ ) ) { case str_ : return ( byte ) str_ ; case str_ : case str_ : return integer . valueof ( inputdelimiter . substring ( num_ ) ) . bytevalue ( ) ; default : throw new illegalargumentexception ( str_ + inputdelimiter ) ; } } else { throw new illegalargumentexception ( str_ ) ; } }	Parse an input delimiter string, as with PigStorage, and return the byte it represents.
public static resourcefieldschema createresourcefieldschema ( requiredfield field ) throws ioexception { resourcefieldschema schema = new resourcefieldschema ( ) . setname ( field . getalias ( ) ) . settype ( field . gettype ( ) ) ; list < requiredfield > subfields = field . getsubfields ( ) ; if ( subfields != null && ! subfields . isempty ( ) ) { resourcefieldschema [ ] subschemafields = new resourcefieldschema [ subfields . size ( ) ] ; int i = num_ ; for ( requiredfield subfield : subfields ) { subschemafields [ i ++ ] = createresourcefieldschema ( subfield ) ; } resourceschema subschema = new resourceschema ( ) ; subschema . setfields ( subschemafields ) ; schema . setschema ( subschema ) ; } return schema ; }	Creates a new ResourceFieldSchema which reflects data from an input RequiredField.
public static void readfully ( inputstream in , bytearrayoutputstream out , byte [ ] buffer ) { try { int numread = num_ ; while ( ( numread = in . read ( buffer , num_ , buffer . length ) ) != - num_ ) { out . write ( buffer , num_ , numread ) ; } out . flush ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	Method used to read a protobuf input stream into a byte array.
@ override public tuple getnext ( ) throws ioexception { if ( reader == null ) { return null ; } pattern pattern = getpattern ( ) ; matcher matcher = pattern . matcher ( str_ ) ; object lineobj ; string line ; tuple t = null ;	Read the file line by line, returning lines the match the regex in Tuplesbased on the regex match groups.
public static base64 createstandardbase64 ( ) { try { return base64 . class . getconstructor ( int . class ) . newinstance ( num_ ) ; } catch ( securityexception e ) { } catch ( nosuchmethodexception e ) { } catch ( illegalargumentexception e ) { } catch ( instantiationexception e ) { } catch ( illegalaccessexception e ) { } catch ( invocationtargetexception e ) { } return new base64 ( ) ; }	Get a instance of standard base64 implementation from apachecommons-codec library.
public static < m extends message > protobufconverter < m > newinstance ( class < m > protoclass ) { return new protobufconverter < m > ( new typeref < m > ( protoclass ) { } ) ; }	Returns a ProtobufConverter for a given Protobuf class.
public boolean readnext ( binarywritable < m > writable ) throws ioexception { byte [ ] blob = readnextprotobytes ( ) ; if ( blob != null ) { writable . set ( protoconverter_ . frombytes ( blob ) ) ; return bool_ ; } return bool_ ; }	Returns true if new proto object was read into writable, false other wise.
public byte [ ] readnextprotobytes ( ) throws ioexception { while ( bool_ ) { if ( ! setupnewblockifneeded ( ) ) { return null ; } int blobindex = curblobs_ . size ( ) - numlefttoreadthisblock_ ; numlefttoreadthisblock_ -- ; byte [ ] blob = curblobs_ . get ( blobindex ) . tobytearray ( ) ; if ( blob . length == num_ && skipemptyrecords ) { continue ; } return blob ; } }	Return byte blob for the next proto object. null indicates end of stream;.
public boolean readnextprotobytes ( byteswritable writable ) throws ioexception { byte [ ] blob = readnextprotobytes ( ) ; if ( blob != null ) { writable . set ( blob , num_ , blob . length ) ; return bool_ ; } return bool_ ; }	returns true if bytes for next object are written to writable, falseother wise.
public static taskattemptcontext newtaskattemptcontext ( configuration conf , taskattemptid taskattemptid ) { return ( taskattemptcontext ) newinstance ( task_context_constructor , conf , taskattemptid ) ; }	Creates TaskAttempContext from a JobConf and jobId using the correctconstructor for based on Hadoop version.
public static mapcontext newmapcontext ( configuration conf , taskattemptid taskattemptid , recordreader recordreader , recordwriter recordwriter , outputcommitter outputcommitter , statusreporter statusreporter , inputsplit inputsplit ) { return ( mapcontext ) newinstance ( map_context_constructor , conf , taskattemptid , recordreader , recordwriter , outputcommitter , statusreporter , inputsplit ) ; }	Instantiates MapContext under Hadoop 1 and MapContextImpl under Hadoop 2.
public static < m extends tbase < ? , ? > > thriftwritable < m > newinstance ( class < m > tclass ) { return new thriftwritable < m > ( new typeref < m > ( tclass ) { } ) ; }	Returns a ThriftWritable for a given Thrift class.
@ suppresswarnings ( str_ ) public t newinstance ( ) throws nosuchmethodexception , illegalaccessexception , invocationtargetexception , instantiationexception { if ( constructor_ == null ) { constructor_ = getrawclass ( ) . getconstructor ( ) ; } return ( t ) constructor_ . newinstance ( ) ; }	Use the typeRef's parameter to create a new instance of the TypeRef's template parameter.
public t safenewinstance ( ) { try { return newinstance ( ) ; } catch ( nosuchmethodexception e ) { throw new illegalargumentexception ( e ) ; } catch ( illegalaccessexception e ) { throw new illegalargumentexception ( e ) ; } catch ( invocationtargetexception e ) { throw new illegalargumentexception ( e ) ; } catch ( instantiationexception e ) { throw new illegalargumentexception ( e ) ; } }	The cheap, ugly version of the above, for when you don't want to catch 900 exceptions atthe calling site.
public message . builder getbuilder ( class < ? extends tbase < ? , ? > > thriftclass ) { return messagebuildermap . get ( protomessagetype ( thriftclass ) ) . clone ( ) ; }	For the given thriftClass, return a Protobufs builder to build a similar protobuf class.
private message . builder mapentryprotobuilder ( tstructdescriptor descriptor , field field ) { return messagebuildermap . get ( mapprotomessagetype ( descriptor , field ) ) . clone ( ) ; }	Return Protobufs builder for a Map field.
private descriptorprotos . descriptorproto . builder mapdescriptorprotobuilder ( field field , string typename ) throws descriptorvalidationexception { descriptorprotos . descriptorproto . builder mapbuilder = descriptorprotos . descriptorproto . newbuilder ( ) . setname ( typename ) ; field keyfield = field . getmapkeyfield ( ) ; field valuefield = field . getmapvaluefield ( ) ; descriptorprotos . fielddescriptorproto . builder keybuilder = mapkeyprotobuilder ( ) ; descriptorprotos . fielddescriptorproto . builder valuebuilder = mapvalueprotobuilder ( ) ; setbuildertypefromfield ( keyfield , keybuilder ) ; setbuildertypefromfield ( valuefield , valuebuilder ) ; mapbuilder . addfield ( keybuilder . build ( ) ) ; mapbuilder . addfield ( valuebuilder . build ( ) ) ; return mapbuilder ; }	Generate a DescriptorProto.Builder for the Message type that will be usedto represent the entries of the input Map field.
private string resolvemessagetypename ( tstructdescriptor descriptor ) throws descriptorvalidationexception { string typename = protomessagetype ( descriptor . getthriftclass ( ) ) ;	For a TStructDescriptor, resolves the typeName and optionally converts and memoizes it'sschema.
@ suppresswarnings ( str_ ) public message convert ( t thriftobj ) { return doconvert ( ( tbase < ? , ? > ) preconditions . checknotnull ( thriftobj , str_ ) ) ; }	Convert a thrift object to a protobuf message.
@ suppresswarnings ( str_ ) public < f extends tfieldidenum > message doconvert ( tbase < ? , f > thriftobj ) { if ( thriftobj == null ) { return null ; } class < tbase < ? , f > > clazz = ( class < tbase < ? , f > > ) thriftobj . getclass ( ) ; checkstate ( clazz ) ; message . builder builder = getbuilder ( clazz ) ; tstructdescriptor fielddesc = tstructdescriptor . getinstance ( clazz ) ; int fieldid = num_ ; for ( field tfield : fielddesc . getfields ( ) ) {	conver TBase object to Message object.
private message buildmapentrymessage ( message . builder mapbuilder , field field , object mapkey , object mapvalue ) { fielddescriptor keyfielddescriptor = mapbuilder . getdescriptorfortype ( ) . findfieldbyname ( map_key_field_name ) ; fielddescriptor valuefielddescriptor = mapbuilder . getdescriptorfortype ( ) . findfieldbyname ( map_value_field_name ) ; boolean iskeystruct = field . getmapkeyfield ( ) . isstruct ( ) ; boolean isvaluestruct = field . getmapvaluefield ( ) . isstruct ( ) ; object convertedkey ; if ( iskeystruct ) { convertedkey = doconvert ( ( tbase < ? , ? > ) mapkey ) ; } else { convertedkey = sanitizerawvalue ( mapkey , field . getmapkeyfield ( ) ) ; } object convertedvalue ; if ( isvaluestruct ) { convertedvalue = doconvert ( ( tbase < ? , ? > ) mapvalue ) ; } else { convertedvalue = sanitizerawvalue ( mapvalue , field . getmapvaluefield ( ) ) ; } mapbuilder . setfield ( keyfielddescriptor , convertedkey ) ; mapbuilder . setfield ( valuefielddescriptor , convertedvalue ) ; return mapbuilder . build ( ) ; }	Builds a Message that contains the key value pair of a Map entry.
private string mapprotomessagetype ( tstructdescriptor descriptor , field field ) { return string . format ( str_ , protomessagetype ( descriptor . getthriftclass ( ) ) , field . getname ( ) ) ; }	name the proto message used for Map types after the thrift class name of the enclosingstruct and the field name.
public static void walkpath ( path path , filesystem fs , pathfilter filter , pathvisitor visitor ) throws ioexception { filestatus filestatus = fs . getfilestatus ( path ) ; if ( filter . accept ( path ) ) { visitor . visit ( filestatus ) ; } if ( filestatus . isdir ( ) ) { filestatus [ ] children = fs . liststatus ( path ) ; for ( filestatus childstatus : children ) { walkpath ( childstatus . getpath ( ) , fs , filter , visitor ) ; } } }	Recursively walk a path applying visitor to each path accepted byfilter.
public static void collectpaths ( path path , filesystem fs , pathfilter filter , final list < path > accumulator ) throws ioexception { walkpath ( path , fs , filter , new pathvisitor ( ) { @ override public void visit ( filestatus filestatus ) { accumulator . add ( filestatus . getpath ( ) ) ; } } ) ; }	Recursively walk a path, adding paths that are accepted by filter to accumulator.
public static void setcolumnnumber ( configuration conf , int columnnum ) { assert columnnum > num_ ; conf . setint ( rcfile . column_number_conf_str , columnnum ) ; }	set number of columns into the given configuration.
private static void updatejobconfforlocalsettings ( jobconf conf ) { string localsetcompressionenabled = conf . get ( compress_enable ) ; if ( localsetcompressionenabled != null ) { conf . set ( mr_compress_enable , localsetcompressionenabled ) ; } string localsetcompressiontype = conf . get ( compress_type ) ; if ( localsetcompressiontype != null ) { conf . set ( mr_compress_type , localsetcompressiontype ) ; } string localsetcompressioncodec = conf . get ( compress_codec ) ; if ( localsetcompressioncodec != null ) { conf . set ( mr_compress_codec , localsetcompressioncodec ) ; } }	We can allow overriding the compression settings for just this scheme here.
public static method parsemethodfor ( class < message > klass ) { try { return klass . getmethod ( str_ , new class [ ] { inputstream . class } ) ; } catch ( securityexception e ) { throw new runtimeexception ( e ) ; } catch ( nosuchmethodexception e ) { throw new runtimeexception ( e ) ; } }	Parse the method for a message.
public static message parsemessage ( method parsemethod , inputstream in ) { try { return ( message ) parsemethod . invoke ( null , in ) ; } catch ( illegalargumentexception e ) { throw new runtimeexception ( e ) ; } catch ( illegalaccessexception e ) { throw new runtimeexception ( e ) ; } catch ( invocationtargetexception e ) { throw new runtimeexception ( e ) ; } }	Parse the message in a given InputStream using scpecified Method.
public static message parsemessage ( class < message > klass , inputstream in ) { method parsemethod = parsemethodfor ( klass ) ; return parsemessage ( parsemethod , in ) ; }	Parse the message in a given Message container.
@ override @ suppresswarnings ( str_ ) public void putnext ( tuple tuple ) throws ioexception { json . clear ( ) ; if ( tuple != null && tuple . size ( ) >= num_ ) { map < string , object > map = ( map < string , object > ) tuple . get ( num_ ) ; if ( keystokeep_ == null ) { json . putall ( map ) ; } else { for ( map . entry < string , object > entry : map . entryset ( ) ) { if ( keystokeep_ . contains ( entry . getkey ( ) ) ) { json . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } } } try { writer . write ( null , new text ( json . tostring ( ) ) ) ; } catch ( interruptedexception e ) {	The first element is expected to be a map, or null.
public static < m extends message > void setclassconf ( class < m > protoclass , configuration jobconf ) { protobufs . setclassconf ( jobconf , lzoprotobufb64lineoutputformat . class , protoclass ) ; }	Sets an internal configuration in jobConf so that remote Tasksinstantiate appropriate object for this generic class based on protoClass.
private void settyperef ( configuration conf ) { string classname = conf . get ( class_conf_key ) ; if ( classname == null ) { throw new runtimeexception ( class_conf_key + str_ ) ; } class < ? > clazz = null ; try { clazz = conf . getclassbyname ( classname ) ; } catch ( classnotfoundexception e ) { throw new runtimeexception ( str_ + classname + str_ , e ) ; } typeref = new typeref < m > ( clazz ) { } ; }	set typeRef from conf.
protected void checkcontainersize ( int size ) throws tprotocolexception { if ( size < num_ ) { throw new tprotocolexception ( str_ + size ) ; } if ( checkreadlength_ && ( readlength_ - size ) < num_ ) { throw new tprotocolexception ( str_ + readlength_ + str_ + size ) ; } }	Check if the container size is valid.NOTE: This assumes that the elements are one byte each.
public void setpattern ( byte [ ] pattern ) { pattern_ = arrays . copyof ( pattern , pattern . length ) ; borders_ = new int [ pattern_ . length + num_ ] ; preprocess ( ) ; }	Sets a new pattern for this StreamSearcher to use.
public static string underscore ( string word ) { string firstpattern = str_ ; string secondpattern = str_ ; string replacementpattern = str_ ;	Underscore the given word.
public static string ordinalize ( int n ) { int mod100 = n % num_ ; if ( mod100 == num_ || mod100 == num_ || mod100 == num_ ) { return string . valueof ( n ) + str_ ; } switch ( n % num_ ) { case num_ : return string . valueof ( n ) + str_ ; case num_ : return string . valueof ( n ) + str_ ; case num_ : return string . valueof ( n ) + str_ ; default : return string . valueof ( n ) + str_ ; } }	Return the ordinal for the given number.
public static < m extends message > protobufwritable < m > newinstance ( class < m > tclass ) { return new protobufwritable < m > ( new typeref < m > ( tclass ) { } ) ; }	Returns a ProtobufWritable for a given Protobuf class.
public static lzow3cloginputformat newinstance ( final string fielddefinitionfile ) { return new lzow3cloginputformat ( ) { @ override public recordreader < longwritable , mapwritable > createrecordreader ( inputsplit split , taskattemptcontext context ) throws ioexception , interruptedexception { recordreader < longwritable , mapwritable > reader = new lzow3clogrecordreader ( ) { @ override protected string getfielddefinitionfile ( ) { return fielddefinitionfile ; } } ; reader . initialize ( split , context ) ; return reader ; } } ; }	Use this method to create valid instances of LzoW3CLogInputFormat.
public static void setoutputformat ( class < ? > realoutputformatclass , configuration conf ) { conf . setclass ( str_ , deprecatedoutputformatwrapper . class , org . apache . hadoop . mapred . outputformat . class ) ; hadooputils . setclassconf ( conf , class_conf_key , realoutputformatclass ) ; }	For cases where we need to set hadoop1 output format in a hadoop2 Configuration object.
public boolean match ( string word ) { int flags = ignorecase_ ? pattern . case_insensitive : num_ ; return pattern . compile ( pattern_ , flags ) . matcher ( word ) . find ( ) ; }	Does the given word match?.
public string replace ( string word ) { int flags = ignorecase_ ? pattern . case_insensitive : num_ ; return pattern . compile ( pattern_ , flags ) . matcher ( word ) . replaceall ( replacement_ ) ; }	Replace the word with its pattern.
public static string pluralize ( string word ) { if ( isuncountable ( word ) ) { return word ; } else { for ( inflection inflection : plurals_ ) { if ( inflection . match ( word ) ) { return inflection . replace ( word ) ; } } return word ; } }	Return the pluralized version of a word.
public static boolean isuncountable ( string word ) { for ( string w : uncountables_ ) { if ( w . equalsignorecase ( word ) ) { return bool_ ; } } return bool_ ; }	Return true if the word is uncountable.
protected dataoutputstream getoutputstream ( taskattemptcontext job ) throws ioexception , interruptedexception { return lzoutils . getindexedlzooutputstream ( hadoopcompat . getconfiguration ( job ) , getdefaultworkfile ( job , lzopcodec . default_lzo_extension ) ) ; }	Helper method to create lzo output file needed to create RecordWriter.
private static < w extends writable > void verifywritableclass ( class < w > writableclass , boolean iskeyclass , writableconverter < w > writableconverter ) { preconditions . checknotnull ( writableclass , str_ + str_ + str_ , iskeyclass ? str_ : str_ , writableconverter . getclass ( ) . getname ( ) ) ; }	Tests validity of Writable class, ensures consistent error message for both key and valuetests.
public static < m extends tbase < ? , ? > > thriftconverter < m > newinstance ( class < m > tclass ) { return new thriftconverter < m > ( new typeref < m > ( tclass ) { } ) ; }	Returns a ThriftConverter for a given Thrift class.
public static class < ? > getclass ( string classname ) { try { return pigcontext . resolveclassname ( classname ) ; } catch ( ioexception e ) { throw new runtimeexception ( str_ + classname , e ) ; } }	Returns class using Pig's class loader.
public static < t extends tbase < ? , ? > > typeref < t > getthrifttyperef ( string thriftclassname ) { return thriftutils . gettyperef ( getclass ( thriftclassname ) ) ; }	Returns TypeRef using Pig class loader.
public static arraylist < integer > findcolumnstoread ( configuration conf , list < integer > currfieldids , columnarmetadata storedinfo ) throws ioexception { arraylist < integer > columnstoread = lists . newarraylist ( ) ;	Returns list of columns that need to be read from the RCFile.These columns are the intersection of currently required columns andcolumns stored in the file.If any required column does not exist in the file, we need to readthe "unknown fields" column, which is usually the last last one.
public static < m extends tbase < ? , ? > > void setclassconf ( class < m > thriftclass , configuration jobconf ) { thriftutils . setclassconf ( jobconf , lzothriftb64lineoutputformat . class , thriftclass ) ; }	Sets an internal configuration in jobConf so that remote Tasksinstantiate appropriate object for this generic class based on thriftClass.
private string executehttprequest ( httpurirequest request ) { try {	Execute the given HTTP request.
private void addauthorization ( httprequest request , reddittoken rtoken ) { request . addheader ( str_ , rtoken . gettokentype ( ) + str_ + rtoken . getaccesstoken ( ) ) ; }	Add authorization to the HTTP request.
public void validate ( object response ) throws redditparseexception {	Validate that it is indeed the starting of a listing of reddit things.
private thing parsething ( kind kind , jsonobject data ) {	Parse the data into a thing if possible.
public list < mixedlistingelement > parse ( string jsontext ) throws redditparseexception {	Parse JSON received from reddit into a list of submissions and comments.This parser expects the JSON to be of a listing of submissions and comments.
public static string formatcommaseparatedlist ( list < string > list ) { stringbuilder builder = new stringbuilder ( ) ; for ( int i = num_ ; i < list . size ( ) ; i ++ ) { if ( i != num_ ) { builder . append ( str_ ) ; } builder . append ( list . get ( i ) ) ; } return builder . tostring ( ) ; }	Format a comma separated list of the given list.
private void waitifneeded ( ) {	Wait if required.
private void addbasicauthentication ( oauthclientrequest request , redditapp app ) { string authstring = app . getclientid ( ) + str_ + app . getclientsecret ( ) ; string authstringenc = datatypeconverter . printbase64binary ( authstring . getbytes ( ) ) ; request . addheader ( header_authorization , str_ + authstringenc ) ; }	Add the basic authentication protocol to the OAuth request usingthe credentials of the Reddit application provided.
public void refresh ( oauthjsonaccesstokenresponse token ) { this . accesstoken = token . getaccesstoken ( ) ; this . expiration = currenttimeseconds ( ) + token . getexpiresin ( ) ; this . expirationspan = token . getexpiresin ( ) ; this . scopes = new reddittokencompletescope ( token . getscope ( ) ) ; this . tokentype = token . getparam ( param_token_type ) ; }	Refresh this reddit token with data received from the new token.
public static string printcommenttree ( list < commenttreeelement > cs ) { stringbuilder builder = new stringbuilder ( ) ; for ( commenttreeelement c : cs ) { builder . append ( printcommenttree ( c , num_ ) ) ; } return builder . tostring ( ) ; }	Get printable version of the given comment tree.
public static integer safejsontointeger ( object obj ) { integer intvalue = null ; try { string str = safejsontostring ( obj ) ; intvalue = str != null ? integer . parseint ( str ) : null ; } catch ( numberformatexception e ) { logger . warn ( str_ , e ) ; } return intvalue ; }	Safely converts an object into an integer.
public static double safejsontodouble ( object obj ) { double doublevalue = null ; try { string str = safejsontostring ( obj ) ; doublevalue = str != null ? double . parsedouble ( str ) : null ; } catch ( numberformatexception e ) { logger . warn ( str_ , e ) ; } return doublevalue ; }	Safely converts an object into an double.
public static boolean safejsontoboolean ( object obj ) { string str = safejsontostring ( obj ) ; boolean booleanvalue = str != null ? boolean . parseboolean ( str ) : null ; return booleanvalue ; }	Safely converts an object into an boolean.
public static long safejsontolong ( object obj ) { long longvalue = null ; try { string str = safejsontostring ( obj ) ; longvalue = str != null ? long . parselong ( str ) : null ; } catch ( numberformatexception e ) { logger . warn ( str_ , e ) ; } return longvalue ; }	Safely converts an object into an long.
protected list < commenttreeelement > parserecursive ( jsonobject main ) throws redditparseexception { list < commenttreeelement > commenttree = new arraylist < commenttreeelement > ( ) ;	Parse a JSON object consisting of comments and add themto the already existing list of comments.
public list < subreddit > parse ( string jsontext ) throws redditparseexception {	Parse JSON received from reddit into a list of subreddits.This parser expects the JSON to be of a listing of subreddits.
public static string signature ( string endpoint , map < string , string > params , string clientsecret ) throws instagramexception { secretkeyspec keyspec = new secretkeyspec ( clientsecret . getbytes ( utf_8 ) , hmac_sha256 ) ;	signature returns the HmacSHA256 encoded signature used for signed Instagram requests.
public static map < string , string > sort ( map < string , string > map ) { preconditions . checknotnull ( map , str_ ) ; map < string , string > sorted = new linkedhashmap < string , string > ( ) ; for ( string key : getsortedkeys ( map ) ) { sorted . put ( key , map . get ( key ) ) ; } return sorted ; }	Sorts a Map.
public oembedinformation getoembedinformation ( string url ) throws instagramexception { string apimethod = string . format ( methods . oembed_information , url ) ; return createinstagramobject ( verbs . get , oembedinformation . class , apimethod , null ) ; }	Returns information about the media associated with that link.
private static < t > t createinstagramobject ( verbs verbs , class < t > clazz , string methodname , map < string , string > params ) throws instagramexception { response response ; try { response = getapiresponse ( verbs , methodname , params ) ; } catch ( ioexception e ) { throw new instagramexception ( str_ , e ) ; } if ( response . getcode ( ) >= num_ && response . getcode ( ) < num_ ) { return createobjectfromresponse ( clazz , response . getbody ( ) ) ; } throw handleinstagramerror ( response ) ; }	Create an Instagram object based on class-name and response.
private static < t > t createobjectfromresponse ( class < t > clazz , final string response ) throws instagramexception { gson gson = new gson ( ) ; t object ; try { object = gson . fromjson ( response , clazz ) ; } catch ( exception e ) { throw new instagramexception ( str_ + clazz . getname ( ) , e ) ; } return object ; }	Creates an object from the JSON response and the class which the object would be mapped to.
public static void checkbothnotnull ( object object1 , object object2 , string errormsg ) { check ( ! ( object1 == null && object2 == null ) , errormsg ) ; }	Checks that at least one of object1 or object2 is not null.
public static void checkemptystring ( string string , string errormsg ) { check ( stringutils . isnotblank ( string ) , errormsg ) ; }	Checks that a string is not null or empty.
public static void checkvalidurl ( string url , string errormsg ) { checkemptystring ( url , errormsg ) ; check ( isurl ( url ) , errormsg ) ; }	Checks that a URL is valid.
public static void checkvalidoauthcallback ( string url , string errormsg ) { checkemptystring ( url , errormsg ) ; if ( url . tolowercase ( ) . comparetoignorecase ( oauthconstants . out_of_band ) != num_ ) { check ( isurl ( url ) , errormsg ) ; } }	Checks that a URL is a valid OAuth callback.
@ deprecated public instagramclient getsignedheaderinstagram ( token accesstoken , string ipaddress ) { return new instagram ( accesstoken . gettoken ( ) , config . getapisecret ( ) , ipaddress ) ; }	Return an Instagram object with enforced signed header.
public static void configureconnectionsettings ( final request request , final instagramconfig config ) { request . setconnecttimeout ( config . getconnectiontimeoutmills ( ) , timeunit . milliseconds ) ; request . setreadtimeout ( config . getreadtimeoutmills ( ) , timeunit . milliseconds ) ;	Configure the request with the connection settings of config.
public string getbodycontents ( ) { try { return new string ( getbytebodycontents ( ) , getcharset ( ) ) ; } catch ( unsupportedencodingexception uee ) { throw new oauthexception ( str_ + charset , uee ) ; } }	Returns the body of the request.
public static void prettyprintjsonresponse ( logger logger , string jsonstring ) { if ( logger . isdebugenabled ( ) ) {	Pretty print the JSON response in the logs.
public instagramsubscription callback ( string callback ) { preconditions . checkvalidurl ( callback , str_ ) ; this . params . put ( constants . callback_url , callback ) ; return this ; }	Configures the callback url.
public instagramsubscription clientid ( string clientid ) { preconditions . checkemptystring ( clientid , str_ ) ; this . params . put ( constants . client_id , clientid ) ; return this ; }	Configures the clientId.
public instagramsubscription clientsecret ( string clientsecret ) { preconditions . checkemptystring ( clientsecret , str_ ) ; this . params . put ( constants . client_secret , clientsecret ) ; return this ; }	Configure the clientSecret.
public instagramsubscription object ( subscriptiontype type ) { this . params . put ( constants . subscription_type , type . tostring ( ) ) ; return this ; }	Configure the subscription type.
public instagramsubscription verifytoken ( string verifytoken ) { preconditions . checkemptystring ( verifytoken , str_ ) ; this . params . put ( constants . verify_token , verifytoken ) ; return this ; }	Configure the verifyToken for the subscription.
public instagramsubscription aspect ( string aspect ) { preconditions . checkemptystring ( aspect , str_ ) ; this . params . put ( constants . aspect , aspect ) ; return this ; }	Configure the aspect for the subscription.
public instagramsubscription latitute ( string latitude ) { preconditions . checkvalidlatlong ( latitude , str_ ) ; this . params . put ( constants . latitude , latitude ) ; return this ; }	Configure the latitude for geography subscription.
public instagramsubscription longitude ( string longitude ) { preconditions . checkvalidlatlong ( longitude , str_ ) ; this . params . put ( constants . longitude , longitude ) ; return this ; }	Configure the longitude for geography subscription.
public instagramsubscription radius ( string radius ) { preconditions . checkvalidradius ( radius , str_ ) ; this . params . put ( constants . radius , radius ) ; return this ; }	Configure the radius for geography subscription.
public subscriptionresponse deletesubscription ( string id ) throws instagramexception { final oauthrequest request = prepareoauthrequest ( verbs . delete ) ; request . addquerystringparameter ( str_ , id ) ; try { final response response = request . send ( ) ; return getsubscriptionresponse ( response . getbody ( ) ) ; } catch ( ioexception e ) { throw new instagramexception ( str_ + id + str_ , e ) ; } }	Deletes a subscription with the specified identifier.
public subscriptionresponse deleteallsubscription ( ) throws instagramexception { final oauthrequest request = prepareoauthrequest ( verbs . delete ) ; request . addquerystringparameter ( constants . subscription_type , str_ ) ; try { final response response = request . send ( ) ; return getsubscriptionresponse ( response . getbody ( ) ) ; } catch ( ioexception e ) { throw new instagramexception ( str_ , e ) ; } }	Deletes all the known subscription.
public subscriptionslistresponse getsubscriptionlist ( ) throws instagramexception { final oauthrequest request = prepareoauthrequest ( verbs . get ) ; try { final response response = request . send ( ) ; return getsubscriptionslistresponse ( response . getbody ( ) ) ; } catch ( ioexception e ) { throw new instagramexception ( str_ , e ) ; } }	Returns the currently active subscription.
public static string formurlencodemap ( map < string , string > map ) { preconditions . checknotnull ( map , str_ ) ; return ( map . size ( ) <= num_ ) ? empty_string : doformurlencode ( map ) ; }	Turns a map into a form-urlencoded string.
public static string percentencode ( string string ) { string encoded = formurlencode ( string ) ; for ( encodingrule rule : encoding_rules ) { encoded = rule . apply ( encoded ) ; } return encoded ; }	Percent encodes a string.
public static string appendparameterstoquerystring ( string url , map < string , string > params ) { preconditions . checknotnull ( url , str_ ) ; string querystring = urlutils . formurlencodemap ( params ) ; if ( querystring . equals ( empty_string ) ) { return url ; } else { url += ( url . indexof ( query_string_separator ) != - num_ ) ? param_separator : query_string_separator ; url += querystring ; return url ; } }	Append given parameters to the query string of the url.
public static string concatsortedpercentencodedparams ( map < string , string > params ) { stringbuilder result = new stringbuilder ( ) ; for ( map . entry < string , string > entry : params . entryset ( ) ) { result . append ( entry . getkey ( ) ) . append ( pair_separator ) ; result . append ( entry . getvalue ( ) ) . append ( param_separator ) ; } return result . tostring ( ) . substring ( num_ , result . length ( ) - num_ ) ; }	Concats a key-value map into a querystring-like String.
public static map < string , string > querystringtomap ( string querystring ) { map < string , string > result = new hashmap < string , string > ( ) ; if ( ( querystring != null ) && ( querystring . length ( ) > num_ ) ) { for ( string param : querystring . split ( param_separator ) ) { string pair [ ] = param . split ( pair_separator ) ; string key = formurldecode ( pair [ num_ ] ) ; string value = ( pair . length > num_ ) ? formurldecode ( pair [ num_ ] ) : empty_string ; result . put ( key , value ) ; } } return result ; }	Parses and form-urldecodes a querystring-like string into a map.
public void throwexception ( ) throws instagramexception { if ( errormeta != null ) { string msg = errormeta . geterrortype ( ) + str_ + errormeta . geterrormessage ( ) ; switch ( errormeta . getcode ( ) ) { case num_ : throw new instagrambadrequestexception ( errormeta . geterrortype ( ) , msg , this . headers ) ; case num_ : throw new instagramratelimitexception ( errormeta . geterrortype ( ) , msg , this . headers ) ; default : throw new instagramexception ( errormeta . geterrortype ( ) , msg , this . headers ) ; } } else { throw new instagramexception ( str_ , this . headers ) ; } }	Throw instagram exception to the client.
public void addtrade ( decimal tradevolume , decimal tradeprice ) { if ( openprice == null ) { openprice = tradeprice ; } closeprice = tradeprice ; if ( maxprice == null ) { maxprice = tradeprice ; } else { maxprice = maxprice . islessthan ( tradeprice ) ? tradeprice : maxprice ; } if ( minprice == null ) { minprice = tradeprice ; } else { minprice = minprice . isgreaterthan ( tradeprice ) ? tradeprice : minprice ; } volume = volume . plus ( tradevolume ) ; amount = amount . plus ( tradevolume . multipliedby ( tradeprice ) ) ; trades ++ ; }	Adds a trade at the end of tick period.
private void increaselengthto ( int index , int maxlength ) { if ( highestresultindex > - num_ ) { int newresultscount = math . min ( index - highestresultindex , maxlength ) ; if ( newresultscount == maxlength ) { results . clear ( ) ; results . addall ( collections . < t > ncopies ( maxlength , null ) ) ; } else if ( newresultscount > num_ ) { results . addall ( collections . < t > ncopies ( newresultscount , null ) ) ; removeexceedingresults ( maxlength ) ; } } else {	Increases the size of cached results buffer.
private decimal calculatemaximumdrawdown ( timeseries series , cashflow cashflow ) { decimal maximumdrawdown = decimal . zero ; decimal maxpeak = decimal . zero ; if ( ! series . isempty ( ) ) {	Calculates the maximum drawdown from a cash flow over a series.
public static list < integer > getsplitbeginindexes ( timeseries series , duration splitduration ) { arraylist < integer > beginindexes = new arraylist < > ( ) ; int beginindex = series . getbeginindex ( ) ; int endindex = series . getendindex ( ) ;	Builds a list of split indexes from splitDuration.
private void calculateregressionline ( int startindex , int endindex ) {	Calculates the regression line.
public order operate ( int index , decimal price , decimal amount ) { order order = null ; if ( isnew ( ) ) { order = new order ( index , startingtype , price , amount ) ; entry = order ; } else if ( isopened ( ) ) { if ( index < entry . getindex ( ) ) { throw new illegalstateexception ( str_ ) ; } order = new order ( index , startingtype . complementtype ( ) , price , amount ) ; exit = order ; } return order ; }	Operates the trade at the index-th position.
private static org . jfree . data . time . timeseries buildcharttimeseries ( timeseries tickseries , indicator < decimal > indicator , string name ) { org . jfree . data . time . timeseries charttimeseries = new org . jfree . data . time . timeseries ( name ) ; for ( int i = num_ ; i < tickseries . gettickcount ( ) ; i ++ ) { tick tick = tickseries . gettick ( i ) ; charttimeseries . add ( new minute ( date . from ( tick . getendtime ( ) . toinstant ( ) ) ) , indicator . getvalue ( i ) . todouble ( ) ) ; } return charttimeseries ; }	Builds a JFreeChart time series from a Ta4j time series and an indicator.
private static decimal randdecimal ( decimal min , decimal max ) { decimal randomdecimal = null ; if ( min != null && max != null && min . islessthan ( max ) ) { randomdecimal = max . minus ( min ) . multipliedby ( decimal . valueof ( math . random ( ) ) ) . plus ( min ) ; } return randomdecimal ; }	Generates a random decimal number between min and max.
private static tick generaterandomtick ( ) { final decimal maxrange = decimal . valueof ( str_ ) ;	Generates a random tick.
private void incrementacceleration ( ) { if ( acceleration . isgreaterthanorequal ( acceleration_threshold ) ) { acceleration = max_acceleration ; } else { acceleration = acceleration . plus ( acceleration_increment ) ; } }	Increments the acceleration factor.
private decimal calculatesar ( int index ) { decimal previoussar = getvalue ( index - num_ ) ; return extremepoint . multipliedby ( acceleration ) . plus ( decimal . one . minus ( acceleration ) . multipliedby ( previoussar ) ) ; }	Calculates the SAR.
private void calculate ( trade trade ) { final int entryindex = trade . getentry ( ) . getindex ( ) ; int begin = entryindex + num_ ; if ( begin > values . size ( ) ) { decimal lastvalue = values . get ( values . size ( ) - num_ ) ; values . addall ( collections . ncopies ( begin - values . size ( ) , lastvalue ) ) ; } int end = trade . getexit ( ) . getindex ( ) ; for ( int i = math . max ( begin , num_ ) ; i <= end ; i ++ ) { decimal ratio ; if ( trade . getentry ( ) . isbuy ( ) ) { ratio = timeseries . gettick ( i ) . getcloseprice ( ) . dividedby ( timeseries . gettick ( entryindex ) . getcloseprice ( ) ) ; } else { ratio = timeseries . gettick ( entryindex ) . getcloseprice ( ) . dividedby ( timeseries . gettick ( i ) . getcloseprice ( ) ) ; } values . add ( values . get ( entryindex ) . multipliedby ( ratio ) ) ; } }	Calculates the cash flow for a single trade.
private void filltotheend ( ) { if ( timeseries . getendindex ( ) >= values . size ( ) ) { decimal lastvalue = values . get ( values . size ( ) - num_ ) ; values . addall ( collections . ncopies ( timeseries . getendindex ( ) - values . size ( ) + num_ , lastvalue ) ) ; } }	Fills with last value till the end of the series.
private static void loadloggerconfiguration ( ) { loggercontext context = ( loggercontext ) loggerfactory . getiloggerfactory ( ) ; context . reset ( ) ; joranconfigurator configurator = new joranconfigurator ( ) ; configurator . setcontext ( context ) ; try { configurator . doconfigure ( logback_conf_file ) ; } catch ( joranexception je ) { logger . getlogger ( strategyexecutionlogging . class . getname ( ) ) . log ( level . severe , str_ , je ) ; } }	Loads the Logback configuration from a resource file.Only here to avoid polluting other examples with logs.
private static ohlcdataset createohlcdataset ( timeseries series ) { final int nbticks = series . gettickcount ( ) ; date [ ] dates = new date [ nbticks ] ; double [ ] opens = new double [ nbticks ] ; double [ ] highs = new double [ nbticks ] ; double [ ] lows = new double [ nbticks ] ; double [ ] closes = new double [ nbticks ] ; double [ ] volumes = new double [ nbticks ] ; for ( int i = num_ ; i < nbticks ; i ++ ) { tick tick = series . gettick ( i ) ; dates [ i ] = new date ( tick . getendtime ( ) . toepochsecond ( ) * num_ ) ; opens [ i ] = tick . getopenprice ( ) . todouble ( ) ; highs [ i ] = tick . getmaxprice ( ) . todouble ( ) ; lows [ i ] = tick . getminprice ( ) . todouble ( ) ; closes [ i ] = tick . getcloseprice ( ) . todouble ( ) ; volumes [ i ] = tick . getvolume ( ) . todouble ( ) ; } ohlcdataset dataset = new defaulthighlowdataset ( str_ , dates , highs , lows , opens , closes , volumes ) ; return dataset ; }	Builds a JFreeChart OHLC dataset from a ta4j time series.
private static timeseriescollection createadditionaldataset ( timeseries series ) { closepriceindicator indicator = new closepriceindicator ( series ) ; timeseriescollection dataset = new timeseriescollection ( ) ; org . jfree . data . time . timeseries charttimeseries = new org . jfree . data . time . timeseries ( str_ ) ; for ( int i = num_ ; i < series . gettickcount ( ) ; i ++ ) { tick tick = series . gettick ( i ) ; charttimeseries . add ( new second ( new date ( tick . getendtime ( ) . toepochsecond ( ) * num_ ) ) , indicator . getvalue ( i ) . todouble ( ) ) ; } dataset . addseries ( charttimeseries ) ; return dataset ; }	Builds an additional JFreeChart dataset from a ta4j time series.
private static void addcashflowaxis ( xyplot plot , timeseriescollection dataset ) { final numberaxis cashaxis = new numberaxis ( str_ ) ; cashaxis . setautorangeincludeszero ( bool_ ) ; plot . setrangeaxis ( num_ , cashaxis ) ; plot . setdataset ( num_ , dataset ) ; plot . mapdatasettorangeaxis ( num_ , num_ ) ; final standardxyitemrenderer cashflowrenderer = new standardxyitemrenderer ( ) ; cashflowrenderer . setseriespaint ( num_ , color . blue ) ; plot . setrenderer ( num_ , cashflowrenderer ) ; }	Adds the cash flow axis to the plot.
private static void displaychart ( jfreechart chart ) {	Displays a chart in a frame.
private void removeexceedingticks ( ) { int tickcount = ticks . size ( ) ; if ( tickcount > maximumtickcount ) {	Removes the N first ticks which exceed the maximum tick count.
private static list < tick > buildemptyticks ( zoneddatetime begintime , zoneddatetime endtime , int duration ) { list < tick > emptyticks = new arraylist < > ( ) ; duration tickduration = duration . ofseconds ( duration ) ; zoneddatetime tickendtime = begintime ; do { tickendtime = tickendtime . plus ( tickduration ) ; emptyticks . add ( new basetick ( tickduration , tickendtime ) ) ; } while ( tickendtime . isbefore ( endtime ) ) ; return emptyticks ; }	Builds a list of empty ticks.
void destroy ( ) { destroyed = bool_ ; for ( map < string , managedobservable < ? > > observablemap : groupmap . values ( ) ) { for ( managedobservable < ? > managedobservable : observablemap . values ( ) ) { managedobservable . cancel ( ) ; } observablemap . clear ( ) ; } groupmap . clear ( ) ; }	Cancels all subscriptions and releases references to Observables and Observers.
public void onsaveinstancestate ( bundle outstate ) { hassavedstate = bool_ ; outstate . putparcelable ( key_state , new state ( observablemanager . id ( ) , group . id ( ) ) ) ; }	Call this method from your Activity or Fragment's onSaveInstanceState method.
final void signalevent ( watchevent . kind < path > kind , path context ) { post ( new event < > ( kind , num_ , context ) ) ; signal ( ) ; }	WatchEvent not WatchEvent.Kind.
public completablefuture < void > watchasync ( executor executor ) { return completablefuture . supplyasync ( ( ) -> { watch ( ) ; return null ; } , executor ) ; }	Asynchronously watch the directories.
private void register ( path directory , boolean usefiletreemodifier ) throws ioexception { logger . debug ( str_ , directory ) ; watchable watchable = ismac ? new watchablepath ( directory ) : directory ; watchevent . modifier [ ] modifiers = usefiletreemodifier ? new watchevent . modifier [ ] { extendedwatcheventmodifier . file_tree } : new watchevent . modifier [ ] { } ; watchevent . kind < ? > [ ] kinds = new watchevent . kind < ? > [ ] { entry_create , entry_delete , entry_modify } ; watchkey watchkey = watchable . register ( watchservice , kinds , modifiers ) ; keyroots . put ( watchkey , directory ) ; }	Internal method to be used by registerAll.
private classloader getclassloader ( ) throws mojoexecutionexception { list < path > classpathurls = new arraylist < > ( ) ; this . addrelevantplugindependenciestoclasspath ( classpathurls ) ; this . addrelevantprojectdependenciestoclasspath ( classpathurls ) ; this . addadditionalclasspathelements ( classpathurls ) ; try { return loaderfinder . find ( classpathurls , mainclass ) ; } catch ( nullpointerexception | ioexception e ) { throw new mojoexecutionexception ( e . getmessage ( ) , e ) ; } }	Set up a classloader for the execution of the main class.
private void addrelevantplugindependenciestoclasspath ( list < path > path ) throws mojoexecutionexception { if ( hascommandlineargs ( ) ) { arguments = parsecommandlineargs ( ) ; } for ( artifact classpathelement : this . determinerelevantplugindependencies ( ) ) { getlog ( ) . debug ( str_ + classpathelement . getartifactid ( ) + str_ ) ; path . add ( classpathelement . getfile ( ) . topath ( ) ) ; } }	Add any relevant project dependencies to the classpath.
private void addrelevantprojectdependenciestoclasspath ( list < path > path ) throws mojoexecutionexception { if ( this . includeprojectdependencies ) { getlog ( ) . debug ( str_ ) ; list < artifact > artifacts = new arraylist < > ( ) ; list < path > theclasspathfiles = new arraylist < > ( ) ; collectprojectartifactsandclasspath ( artifacts , theclasspathfiles ) ; for ( path classpathfile : theclasspathfiles ) { getlog ( ) . debug ( str_ + classpathfile ) ; path . add ( classpathfile ) ; } for ( artifact classpathelement : artifacts ) { getlog ( ) . debug ( str_ + classpathelement . getartifactid ( ) + str_ ) ; path . add ( classpathelement . getfile ( ) . topath ( ) ) ; } } else { getlog ( ) . debug ( str_ ) ; } }	Add any relevant project dependencies to the classpath.
private set < artifact > resolveexecutabledependencies ( artifact executablepomartifact ) throws mojoexecutionexception { set < artifact > executabledependencies = new linkedhashset < > ( ) ; try { projectbuildingrequest buildingrequest = getsession ( ) . getprojectbuildingrequest ( ) ; mavenproject executableproject = this . projectbuilder . build ( executablepomartifact , buildingrequest ) . getproject ( ) ; for ( artifactresult artifactresult : dependencyresolver . resolvedependencies ( buildingrequest , executableproject . getmodel ( ) , null ) ) { executabledependencies . add ( artifactresult . getartifact ( ) ) ; } } catch ( exception ex ) { throw new mojoexecutionexception ( str_ + str_ , ex ) ; } return executabledependencies ; }	Resolve the executable dependencies for the specified project.
protected artifact findexecutableartifact ( ) throws mojoexecutionexception {	Examine the plugin dependencies to find the executable artifact.
private void handleworkingdirectory ( ) throws mojoexecutionexception { if ( workingdirectory == null ) { workingdirectory = basedir ; } if ( ! workingdirectory . exists ( ) ) { getlog ( ) . debug ( str_ + workingdirectory . getabsolutepath ( ) + str_ ) ; if ( ! workingdirectory . mkdirs ( ) ) { throw new mojoexecutionexception ( str_ + workingdirectory . getabsolutepath ( ) + str_ ) ; } } }	This is a convenient method to make the execute method a little bit more readable.
public localdate getcalendarservicerangestart ( ) { int startdate = num_ ; for ( service service : feed . services . values ( ) ) { if ( service . calendar == null ) continue ;	returns null for schedules without calendar service schedules.
public rectangle2d getbounds ( ) { rectangle2d ret = null ; for ( stop stop : feed . stops . values ( ) ) {	Get the bounding box of this GTFS feed.We use a Rectangle2D rather than a Geotools envelope because GTFS is always in WGS 84.Note that stops do not have agencies in GTFS.
private boolean checkdistanceandtime ( double distancemeters , double traveltimeseconds , stoptime stoptime ) { boolean good = bool_ ;	This just pulls some of the range checking logic out of the main trip checking loop so it's more readable.
private tableloadresult load ( table table ) {	This wraps the main internal table loader method to catch exceptions and figure out how many errors happened.
private int gettablesize ( table table ) { zipentry zipentry = zip . getentry ( table . name + str_ ) ; if ( zipentry == null ) return num_ ; return ( int ) zipentry . getsize ( ) ; }	Get the uncompressed file size in bytes for the specified GTFS table.
private void setfieldtonull ( boolean postgrestext , string [ ] transformedstrings , int fieldindex , field field ) { if ( postgrestext ) transformedstrings [ fieldindex + num_ ] = postgres_null_text ;	Sets field to null in statement or string array depending on whether postgres is being used.
public snapshotresult copytables ( ) {	Copy primary entity tables as well as Pattern and PatternStops tables.
private boolean tableexists ( string namespace , string tablename ) {	Helper method to determine if a table exists within a namespace.
private void addeditorspecificfields ( connection connection , string tableprefix , table table ) throws sqlexception { log . info ( str_ , tableprefix + table . name ) ; statement statement = connection . createstatement ( ) ; for ( field field : table . editorfields ( ) ) {	Add columns for any required, optional, or editor fields that don't already exist as columns on the table.This method contains a SQL statement that requires PostgreSQL 9.6+.
private void registersnapshot ( ) { try {	Add a line to the list of loaded feeds to record the snapshot and which feed the snapshot replicates.
public string getid ( ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( trip_id ) ; sb . append ( str_ ) ; sb . append ( converttogtfstime ( start_time ) ) ; sb . append ( str_ ) ; sb . append ( converttogtfstime ( end_time ) ) ; sb . append ( str_ ) ; sb . append ( string . format ( str_ , headway_secs / num_ , headway_secs % num_ ) ) ; if ( exact_times == num_ ) sb . append ( str_ ) ; return sb . tostring ( ) ; }	Frequency entries have no ID in GTFS so we define one based on the fields in the frequency entry.It is possible to have two identical frequency entries in the GTFS, which under our understanding of the situationwould mean that two sets of vehicles were randomly running the same trip at the same headway, but uncorrelatedwith each other, which is almost certain to be an error.
public int executeremaining ( ) throws sqlexception { if ( currentbatchsize > num_ ) { totalrecordsprocessed += currentbatchsize ; preparedstatement . executebatch ( ) ; currentbatchsize = num_ ; }	Execute any remaining statements and return the total records processed.
private void cleanupzipfile ( ) { long starttime = system . currenttimemillis ( ) ;	Removes any empty zip files from the final zip file.
private tableloadresult export ( table table , string filtersql ) { long starttime = system . currenttimemillis ( ) ; tableloadresult tableloadresult = new tableloadresult ( ) ; try { if ( filtersql == null ) { throw new illegalargumentexception ( str_ ) ; } else {	Export a table to the zipOutputStream to be written to the GTFS.
public void registererror ( entity entity , newgtfserrortype errortype ) { errorstorage . storeerror ( newgtfserror . forentity ( entity , errortype ) ) ; }	Store an error that affects a single line of a single table.
public void registererror ( entity entity , newgtfserrortype errortype , object badvalue ) { errorstorage . storeerror ( newgtfserror . forentity ( entity , errortype ) . setbadvalue ( badvalue . tostring ( ) ) ) ; }	Store an error that affects a single line of a single table.Add a bad value to it.
public static feedloadresult export ( string feedid , string outfile , datasource datasource , boolean fromeditor ) { jdbcgtfsexporter exporter = new jdbcgtfsexporter ( feedid , outfile , datasource , fromeditor ) ; feedloadresult result = exporter . exporttables ( ) ; return result ; }	Export a feed ID from the database to a zipped GTFS file in the specified export directory.
public static validationresult validate ( string feedid , datasource datasource ) { feed feed = new feed ( datasource , feedid ) ; validationresult result = feed . validate ( ) ; return result ; }	Once a feed has been loaded into the database, examine its contents looking for various problems and errors.
public static void delete ( string feedid , datasource datasource ) throws sqlexception , invalidnamespaceexception { log . info ( str_ , feedid ) ; connection connection = null ; try { connection = datasource . getconnection ( ) ; ensurevalidnamespace ( feedid ) ;	Deletes all tables for the specified feed.
public newgtfserror addinfo ( string key , string value ) { errorinfo . put ( key , value ) ; return this ; }	Add a single key-value pair of supplemental info to this error.
public static newgtfserror forline ( table table , int linenumber , newgtfserrortype errortype , string badvalue ) { newgtfserror error = new newgtfserror ( table . getentityclass ( ) , errortype ) ; error . linenumber = linenumber ; error . badvalue = badvalue ; return error ; }	Factory Builder for cases where an entity has not yet been constructed, but we know the line number.
public static newgtfserror forentity ( entity entity , newgtfserrortype errortype ) { newgtfserror error = new newgtfserror ( entity . getclass ( ) , errortype ) ; error . linenumber = entity . id ; error . entityid = entity . getid ( ) ; error . entitysequencenumber = entity . getsequencenumber ( ) ; return error ; }	Factory Builder for cases where the entity has already been decoded and an error is discovered during validation.
public static newgtfserror forfeed ( newgtfserrortype errortype , string badvalue ) { return new newgtfserror ( null , errortype ) . setbadvalue ( badvalue ) ; }	Factory Builder for feed-wide error.
public double getpatternspeed ( string pattern_id , localdate date , localtime from , localtime to ) { list < trip > trips = gettripsfordate ( pattern_id , date ) ; return getaveragespeedfortrips ( trips , from , to ) ; }	Gets the pattern speed for a given pattern for a specified date and time window.
public double getaveragespeedfortrips ( collection < trip > trips , localtime from , localtime to ) { tdoublelist speeds = new tdoublearraylist ( ) ; for ( trip trip : trips ) { stoptime firststoptime = feed . stop_times . ceilingentry ( fun . t2 ( trip . trip_id , null ) ) . getvalue ( ) ; localtime tripbegintime = localtime . ofsecondofday ( firststoptime . departure_time % num_ ) ;	Get average speed for set of trips that begin within the time window in meters per second.
public localtime getstarttimefortrips ( collection < trip > trips ) { int earliestdeparture = integer . max_value ; for ( trip trip : trips ) { stoptime st = feed . getorderedstoptimesfortrip ( trip . trip_id ) . iterator ( ) . next ( ) ; int dep = st . departure_time ;	Get earliest departure time for a set of trips.
public localtime getendtimefortrips ( collection < trip > trips ) { int latestarrival = integer . min_value ; for ( trip trip : trips ) { stoptime st = feed . getorderedstoptimesfortrip ( trip . trip_id ) . iterator ( ) . next ( ) ; if ( st . arrival_time >= latestarrival ) { latestarrival = st . arrival_time ; } }	Get last arrival time for a set of trips.
public double getpatterndistance ( string pattern_id ) { pattern pattern = feed . patterns . get ( pattern_id ) ; return feed . gettripdistance ( pattern . associatedtrips . iterator ( ) . next ( ) , bool_ ) ; }	Get distance for a pattern.
public double getaveragestopspacing ( string pattern_id ) { pattern pattern = feed . patterns . get ( pattern_id ) ; return getpatterndistance ( pattern_id ) / pattern . orderedstops . size ( ) ; }	Get average stop spacing for a pattern.
private < e extends entity > void copyentitytosql ( iterable < e > entities , table table ) throws sqlexception { table . createsqltable ( connection , namespace , bool_ ) ; string entityinsertsql = table . generateinsertsql ( namespace , bool_ ) ; preparedstatement insertstatement = connection . preparestatement ( entityinsertsql ) ;	Creates table for the specified Table, inserts all entities for the iterable in batches, and, finally, createsindexes on the table.
public static validatefieldresult < string > from ( validatefieldresult result ) { validatefieldresult < string > stringresult = new validatefieldresult < > ( ) ; stringresult . clean = string . valueof ( result . clean ) ; stringresult . errors . addall ( result . errors ) ; return stringresult ; }	Builder method that constructs a ValidateFieldResult with type String from the input result.
public int geterrorcount ( ) { try {	Commits any outstanding error inserts and returns the error count via a SQL query.
private void commit ( ) { try {	This executes any remaining inserts and commits the transaction.
@ override public validatefieldresult < string > validateandconvert ( string hhmmss ) { return validatefieldresult . from ( getseconds ( hhmmss ) ) ; }	Actually this is converting the string. Can we use some JDBC existing functions for this?.
@ override public int compareto ( gtfserror o ) { int compare = super . compareto ( o ) ; if ( compare != num_ ) return compare ; return this . badreference . compareto ( ( ( ( referentialintegrityerror ) o ) . badreference ) ) ; }	must be comparable to put into mapdb.
public static double getdistance ( linestring tripgeometry ) { double distance = num_ ; for ( int i = num_ ; i < tripgeometry . getnumpoints ( ) - num_ ; i ++ ) { try { distance += jts . orthodromicdistance ( tripgeometry . getcoordinaten ( i ) , tripgeometry . getcoordinaten ( i + num_ ) , defaultgeographiccrs . wgs84 ) ; } catch ( transformexception e ) { throw new runtimeexception ( e ) ; } } return distance ; }	Get the length of a linestring in meters.
public static graphqlfielddefinition field ( string fieldname , string tablename ) { return newfielddefinition ( ) . name ( fieldname ) . type ( graphqlint ) . datafetcher ( new rowcountfetcher ( tablename ) ) . build ( ) ; }	Convenience method to create a field in a GraphQL schema that fetches the number of rows in a table.Must be on a type that has a "namespace" field for context.
public static graphqlfielddefinition groupedfield ( string tablename , string groupbycolumn ) { return newfielddefinition ( ) . name ( groupbycolumn ) . type ( groupcounttype ) . argument ( stringarg ( str_ ) ) . type ( new graphqllist ( groupcounttype ) ) . datafetcher ( new rowcountfetcher ( tablename , null , groupbycolumn ) ) . build ( ) ; }	A GraphQL field used to deliver lists of group counts.
public int [ ] deduplicateintarray ( int [ ] original ) { if ( original == null ) return null ; intarray intarray = new intarray ( original ) ; intarray canonical = canonicalintarrays . get ( intarray ) ; if ( canonical == null ) { canonical = intarray ; canonicalintarrays . put ( canonical , canonical ) ; } return canonical . array ; }	Used to deduplicate time and stop sequence arrays.
public list < trip > gettripsfordate ( string stop_id , localdate date ) { list < string > tripids = stats . gettripsfordate ( date ) . stream ( ) . map ( trip -> trip . trip_id ) . collect ( collectors . tolist ( ) ) ; return feed . getdistincttripsforstop ( stop_id ) . stream ( ) . filter ( t -> tripids . contains ( t . trip_id ) )	Get list of trips that visit a stop for a specified date of service.
public int getaverageheadwayforstop ( string stop_id , localdate date , localtime from , localtime to ) { list < trip > tripsforstop = gettripsfordate ( stop_id , date ) ; return getstopheadwayfortrips ( stop_id , tripsforstop , from , to ) ; }	Get the average headway, in seconds, for all trips at a stop over a time window.
public map < string , integer > getrouteheadwaysforstop ( string stop_id , localdate date , localtime from , localtime to ) { map < string , integer > routeheadwaymap = new hashmap < > ( ) ; list < route > routes = feed . patterns . values ( ) . stream ( ) . filter ( p -> p . orderedstops . contains ( stop_id ) ) . map ( p -> feed . routes . get ( p . route_id ) ) . collect ( collectors . tolist ( ) ) ; for ( route route : routes ) { routeheadwaymap . put ( route . route_id , getheadwayforstopbyroute ( stop_id , route . route_id , date , from , to ) ) ; } return routeheadwaymap ; }	Get the route headway for a given service date at a stop over a time window, in seconds.
public int getheadwayforstopbyroute ( string stop_id , string route_id , localdate date , localtime from , localtime to ) { list < trip > tripsforstop = feed . getdistincttripsforstop ( stop_id ) . stream ( ) . filter ( trip -> feed . trips . get ( trip . trip_id ) . route_id . equals ( route_id ) ) . filter ( trip -> feed . services . get ( trip . service_id ) . activeon ( date ) ) . collect ( collectors . tolist ( ) ) ; return getstopheadwayfortrips ( stop_id , tripsforstop , from , to ) ; }	Get the average headway, in seconds, for a route at a stop over a time window.
private static jsonnode getjsonnode ( string json ) throws ioexception { try { return mapper . readtree ( json ) ; } catch ( ioexception e ) { log . error ( str_ , e ) ; throw e ; } }	Wrapper method to call Jackson to deserialize a JSON string into JsonNode.
@ override public string create ( string json , boolean autocommit ) throws sqlexception , ioexception { return update ( null , json , autocommit ) ; }	Create a new entity in the database from the provided JSON string.
private int updatestoptimesforpatternstop ( objectnode patternstop , int previoustraveltime ) throws sqlexception { string sql = string . format ( str_ + str_ , tableprefix , tableprefix ) ;	Updates the stop times that reference the specified pattern stop.
private void verifyreferencesexist ( string referringtablename , multimap < table , string > referencespertable ) throws sqlexception { for ( table referencedtable : referencespertable . keyset ( ) ) { log . info ( str_ , referringtablename , referencedtable . name ) ; collection < string > referencestrings = referencespertable . get ( referencedtable ) ; string referencefieldname = referencedtable . getkeyfieldname ( ) ; string questionmarks = string . join ( str_ , collections . ncopies ( referencestrings . size ( ) , str_ ) ) ; string checkcountsql = string . format ( str_ , referencefieldname , tableprefix , referencedtable . name , referencefieldname , questionmarks ) ; preparedstatement preparedstatement = connection . preparestatement ( checkcountsql ) ; int onebasedindex = num_ ; for ( string ref : referencestrings ) { preparedstatement . setstring ( onebasedindex ++ , ref ) ; } log . info ( preparedstatement . tostring ( ) ) ; resultset resultset = preparedstatement . executequery ( ) ; set < string > foundreferences = new hashset < > ( ) ; while ( resultset . next ( ) ) { string referencevalue = resultset . getstring ( num_ ) ; foundreferences . add ( referencevalue ) ; }	Checks that a set of string references to a set of reference tables are all valid.
private static void verifyinteriorstopsareunchanged ( list < string > originalstopids , list < patternstop > newstops , int firstdifferentindex , int lastdifferentindex , boolean movedright ) {	Check the stops in the changed region to ensure they remain in the same order.
private void insertblankstoptimes ( list < string > tripids , list < patternstop > newstops , int startingstopsequence , int stoptimestoadd , connection connection ) throws sqlexception { if ( tripids . isempty ( ) ) {	You must call this method after updating sequences for any stop times following the starting stop sequence toavoid overwriting these other stop times.
@ override public int delete ( integer id , boolean autocommit ) throws sqlexception { try {	Deletes an entity for the specified ID.
private static long handlestatementexecution ( preparedstatement statement , boolean iscreating ) throws sqlexception {	Handle executing a prepared statement and return the ID for the newly-generated or updated entity.
private static int getrowcount ( string tablename , connection connection ) throws sqlexception { string rowcountsql = string . format ( str_ , tablename ) ; log . info ( rowcountsql ) ;	Get number of rows for a table.
private static set < table > getreferencingtables ( table table ) { set < table > referencingtables = new hashset < > ( ) ; for ( table gtfstable : table . tablesinorder ) {	Finds the set of tables that reference the parent entity being updated.
private static string getvalueforid ( int id , string fieldname , string namespace , table table , connection connection ) throws sqlexception { string tablename = string . join ( str_ , namespace , table . name ) ; string selectidsql = string . format ( str_ , fieldname , tablename , id ) ; log . info ( selectidsql ) ; statement selectidstatement = connection . createstatement ( ) ; resultset selectresults = selectidstatement . executequery ( selectidsql ) ; string value = null ; while ( selectresults . next ( ) ) { value = selectresults . getstring ( num_ ) ; } return value ; }	For a given integer ID, return the value for the specified field name for that entity.
public t put ( string id , file feedfile ) throws exception { return put ( id , feedfile , null ) ; }	Add a GTFS feed to this cache with the given ID.
public t put ( function < gtfsfeed , string > idgenerator , file feedfile ) throws exception { return put ( null , feedfile , idgenerator ) ; }	Add a GTFS feed to this cache where the ID is calculated from the feed itself.
public boolean activeon ( localdate date ) {	Is this service active on the specified date?.
public static void initialize ( datasource datasource ) { gtfsgraphql . datasource = datasource ; graphql = graphql . newgraphql ( graphqlgtfsschema . feedbasedschema ) . build ( ) ; }	Username and password can be null if connecting to a local instance with host-based authentication.
public list < field > editorfields ( ) { list < field > editorfields = new arraylist < > ( ) ; for ( field f : fields ) if ( f . requirement == required || f . requirement == optional || f . requirement == editor ) { editorfields . add ( f ) ; } return editorfields ; }	Get only those fields included in the official GTFS specification for this table or used by the editor.
public list < field > requiredfields ( ) {	Get only those fields marked as required in the official GTFS specification for this table.
public list < field > specfields ( ) { list < field > specfields = new arraylist < > ( ) ; for ( field f : fields ) if ( f . requirement == required || f . requirement == optional ) specfields . add ( f ) ; return specfields ; }	Get only those fields included in the official GTFS specification for this table, i.e., filter out fields usedin the editor or extensions.
public boolean createsqltable ( connection connection , string namespace , boolean makeidserial , string [ ] primarykeyfields ) {	Create an SQL table with all the fields specified by this table object,plus an integer CSV line number field in the first position.
public string generateinsertsql ( string namespace , boolean setdefaultid ) { string tablename = namespace == null ? name : string . join ( str_ , namespace , name ) ; string joinedfieldnames = commaseparatednames ( editorfields ( ) ) ; string idvalue = setdefaultid ? str_ : str_ ; return string . format ( str_ , tablename , joinedfieldnames , idvalue , string . join ( str_ , collections . ncopies ( editorfields ( ) . size ( ) , str_ ) ) ) ; }	Create SQL string for use in insert statement.
public static string commaseparatednames ( list < field > fieldstojoin , string prefix , boolean csvoutput ) { return fieldstojoin . stream ( )	Prepend a prefix string to each field and join them with a comma + space separator.Also, if an export to GTFS is being performed, certain fields need a translation from the database format to theGTFS format.
public string generateupdatesql ( string namespace , int id ) {	Create SQL string for use in update statement.
public string generateselectsql ( string namespace , requirement minimumrequirement ) { string fieldsstring ; string tablename = string . join ( str_ , namespace , name ) ; string fieldprefix = tablename + str_ ; if ( minimumrequirement . equals ( editor ) ) { fieldsstring = commaseparatednames ( editorfields ( ) , fieldprefix , bool_ ) ; } else if ( minimumrequirement . equals ( optional ) ) { fieldsstring = commaseparatednames ( specfields ( ) , fieldprefix , bool_ ) ; } else if ( minimumrequirement . equals ( required ) ) { fieldsstring = commaseparatednames ( requiredfields ( ) , fieldprefix , bool_ ) ; } else fieldsstring = str_ ; return string . format ( str_ , fieldsstring , tablename ) ; }	Generate select all SQL string.
public string generateselectallexistingfieldssql ( connection connection , string namespace ) throws sqlexception {	Generate a select statement from the columns that actually exist in the database table.
public string generatedeletesql ( string namespace , string fieldname ) { string wherefield = fieldname == null ? str_ : fieldname ; return string . format ( str_ , string . join ( str_ , namespace , name ) , wherefield ) ; }	Generate delete SQL string.
public boolean createsqltablefrom ( connection connection , string tabletoclone ) { long starttime = system . currenttimemillis ( ) ; try { statement statement = connection . createstatement ( ) ;	Creates a SQL table from the table to clone.
public int getkeyfieldindex ( field [ ] fields ) { string keyfield = getkeyfieldname ( ) ; return field . getfieldindex ( fields , keyfield ) ; }	Returns the index of the key field within the array of fields provided for a given table.
public static void ensurevalidnamespace ( string namespace ) throws invalidnamespaceexception { pattern pattern = pattern . compile ( str_ ) ; matcher matcher = pattern . matcher ( namespace ) ; if ( matcher . find ( ) ) { throw new invalidnamespaceexception ( ) ; } }	Ensures namespace is valid by ensuring it only has alphanumeric characters or the underscorefor all characters in the string.
public static int getfieldindex ( field [ ] fields , string name ) {	Finds the index of the field given a string name.
@ override public set < integer > keyset ( ) {	We currently just expose them as immutable sets in RAM, since all of the modification operations are optional.
public static gtfsfeed fromfile ( string file , string feedid ) { gtfsfeed feed = new gtfsfeed ( ) ; zipfile zip ; try { zip = new zipfile ( file ) ; if ( feedid == null ) { feed . loadfromfile ( zip ) ; } else { feed . loadfromfile ( zip , feedid ) ; } zip . close ( ) ; return feed ; } catch ( exception e ) { log . error ( str_ , e . getmessage ( ) ) ; throw new runtimeexception ( e ) ; } }	Static factory method returning a new instance of GTFSFeed containing the contents ofthe GTFS file at the supplied filesystem path.
public void findpatterns ( ) { patternfinder patternfinder = new patternfinder ( ) ;	MapDB-based implementation to find patterns.FIXME: Remove and make pattern finding happen during validation? We want to share the pattern finder between thetwo implementations (MapDB and RDBMS), apply the same validation process to both kinds of storage, and producePatterns in the same way in both cases, during validation.
public double gettripdistance ( string trip_id , boolean straightline ) { return straightline ? geoutils . getdistance ( this . getstraightlineforstops ( trip_id ) ) : geoutils . getdistance ( this . gettripgeometry ( trip_id ) ) ; }	Get the length of a trip in meters.
public double gettripspeed ( string trip_id , boolean straightline ) { stoptime firststoptime = this . stop_times . ceilingentry ( fun . t2 ( trip_id , null ) ) . getvalue ( ) ; stoptime laststoptime = this . stop_times . floorentry ( fun . t2 ( trip_id , fun . hi ) ) . getvalue ( ) ;	Get trip speed in meters per second.
public list < stoptime > getstoptimesforstop ( string stop_id ) { sortedset < tuple2 < string , tuple2 > > index = this . stopstoptimeset . subset ( new tuple2 < > ( stop_id , null ) , new tuple2 ( stop_id , fun . hi ) ) ; return index . stream ( ) . map ( tuple -> this . stop_times . get ( tuple . b ) ) . collect ( collectors . tolist ( ) ) ; }	Get list of stop_times for a given stop_id.
public list < service > getservicesfordate ( localdate date ) { string datestring = date . format ( dateformatter ) ; sortedset < tuple2 < string , string > > index = this . servicesperdate . subset ( new tuple2 < > ( datestring , null ) , new tuple2 ( datestring , fun . hi ) ) ; return index . stream ( ) . map ( tuple -> this . services . get ( tuple . b ) ) . collect ( collectors . tolist ( ) ) ; }	Get list of services for each date of service.
public zoneid getagencytimezoneforstop ( string stop_id ) { stoptime stoptime = getstoptimesforstop ( stop_id ) . iterator ( ) . next ( ) ; trip trip = this . trips . get ( stoptime . trip_id ) ; route route = this . routes . get ( trip . route_id ) ; agency agency = route . agency_id != null ? this . agency . get ( route . agency_id ) : this . agency . get ( num_ ) ; return zoneid . of ( agency . agency_timezone ) ; }	Get the likely time zone for a stop using the agency of the first stop time encountered for the stop.
public map < trippatternkey , pattern > createpatternobjects ( map < string , stop > stopbyid , sqlerrorstorage errorstorage ) {	Once all trips have been processed, call this method to produce the final Pattern objects representing all theunique sequences of stops encountered.
private static void setanywaytimer ( context context ) { alarmmanager am = ( alarmmanager ) context . getsystemservice ( context . alarm_service ) ; intent intent = new intent ( context , idlereceiver . class ) ; intent . setaction ( action_trigger_idle ) ; pendingintent pendingintent = pendingintent . getbroadcast ( context , num_ , intent , num_ ) ; final long nowelapsed = systemclock . elapsedrealtime ( ) ; final long when = nowelapsed + inactivity_anyway_threshold ; compatsetwindow ( am , alarmmanager . elapsed_realtime_wakeup , when , idle_window_slop , pendingintent ) ; }	We can't get idle broadcasts while the app is not running.
public static void enablereceiver ( context context ) { intentfilter filter = getfilter ( ) ; sreceiver = new idlereceiver ( ) ; context . getapplicationcontext ( ) . registerreceiver ( sreceiver , filter ) ; }	Call this as soon as we get a chance, it will be unregistered whenever our app is killed.
void reportnewidlestate ( context context , boolean isidle ) { jobstore jobstore = jobstore . initandget ( context ) ; synchronized ( jobstore ) { arrayset < jobstatus > jobs = jobstore . getjobs ( ) ; for ( int i = num_ ; i < jobs . size ( ) ; i ++ ) { jobstatus ts = jobs . valueat ( i ) ; ts . idleconstraintsatisfied . set ( isidle ) ; } } startwakefulservice ( context , jobservicecompat . mayberunjobs ( context ) ) ; }	Interaction with the task manager service.
public boolean add ( jobstatus jobstatus ) { boolean replaced = mjobset . remove ( jobstatus ) ; mjobset . add ( jobstatus ) ; if ( ! jobstatus . ispersisted ( ) ) { markforbootsession ( jobstatus ) ; } maybewritestatustodiskasync ( ) ; return replaced ; }	Add a job to the master list, persisting it if necessary.
public boolean containsjobid ( int jobid ) { for ( int i = mjobset . size ( ) - num_ ; i >= num_ ; i -- ) { jobstatus ts = mjobset . valueat ( i ) ; if ( ts . matches ( jobid ) ) { return bool_ ; } } return bool_ ; }	Whether this jobStatus object already exists in the JobStore.
public boolean remove ( jobstatus jobstatus ) { boolean removed = mjobset . remove ( jobstatus ) ; if ( ! removed ) { return bool_ ; } if ( ! jobstatus . ispersisted ( ) ) { unmarkforbootsession ( jobstatus ) ; } maybewritestatustodiskasync ( ) ; return removed ; }	Remove the provided job.
private jobstatus reschedulefailedjob ( jobstatus job ) { if ( job . hasidleconstraint ( ) ) {	A job is rescheduled with exponential back-off if the client requests this from theirexecution logic.A caveat is for idle-mode jobs, for which the idle-mode constraint will usurp thetimeliness of the reschedule.
@ override public void clear ( ) { if ( msize != num_ ) { freearrays ( mhashes , marray , msize ) ; mhashes = emptyarray . int ; marray = emptyarray . object ; msize = num_ ; } }	Make the array map empty.
public void onreceivedstartjob ( jobparameters params ) { mshowstartview . setbackgroundcolor ( startjobcolor ) ; message m = message . obtain ( mhandler , msg_uncolour_start ) ; mhandler . sendmessagedelayed ( m , num_ ) ;	Receives callback from the service when a job has landed on the app.
public void onreceivedstopjob ( ) { mshowstopview . setbackgroundcolor ( stopjobcolor ) ; message m = message . obtain ( mhandler , msg_uncolour_stop ) ; mhandler . sendmessagedelayed ( m , num_ ) ;	Receives callback from the service when a job that previously landed on the app must stopexecuting.
private static boolean canstoptrackingjob ( jobstatus job ) { return ( ! job . hastimingdelayconstraint ( ) || job . timedelayconstraintsatisfied . get ( ) ) && ( ! job . hasdeadlineconstraint ( ) || job . deadlineconstraintsatisfied . get ( ) ) ; }	Determines whether this controller can stop tracking the given job.The controller is no longer interested in a job once its time constraint is satisfied, andthe job's deadline is fulfilled - unlike other controllers a time constraint can't toggleback and forth.
public void putstring ( string key , string value ) { persistablebundlecompat . putstring ( bundle , key , value ) ; }	Inserts a String value into the mapping of this Bundle, replacing any existing value for thegiven key.
public void putstringarray ( string key , string [ ] value ) { persistablebundlecompat . putstringarray ( bundle , key , value ) ; }	Inserts a String array value into the mapping of this Bundle, replacing any existing valuefor the given key.
public string getstring ( string key , string defaultvalue ) { return persistablebundlecompat . getstring ( bundle , key , defaultvalue ) ; }	Returns the value associated with the given key, or defaultValue if no mapping of the desiredtype exists for the given key or if a null value is explicitly associated with the givenkey.
public void putpersistablebundle ( string key , persistablebundle value ) { persistablebundlecompat . putpersistablebundle ( bundle , key , value . bundle ) ; }	Inserts a PersistableBundle value into the mapping of this Bundle, replacing any existingvalue for the given key.
public void writetoparcel ( parcel out , int flags ) { out . writestring ( mmessage ) ; out . writestring ( mactionmessage ) ; out . writeint ( mactionicon ) ; out . writeparcelable ( mtoken , num_ ) ; out . writeint ( ( int ) mduration ) ; out . writeparcelable ( mbtntextcolor , num_ ) ; out . writeparcelable ( mbackgroundcolor , num_ ) ; out . writeint ( mheight ) ; out . writevalue ( mtypeface ) ; }	writes data to parcel.
public int getheight ( ) { mparentview . measure ( view . measurespec . makemeasurespec ( mparentview . getwidth ( ) , view . measurespec . exactly ) , view . measurespec . makemeasurespec ( mparentview . getheight ( ) , view . measurespec . at_most ) ) ; return mparentview . getmeasuredheight ( ) ; }	Calculates the height of the SnackBar.
public static void dprint ( string str ) { if ( verboseprint ) { system . out . println ( str ) ; } m_log . fine ( str ) ; }	Simple Debug Print Mechanism.
public static boolean checkproperties ( properties postprop , string url , string method , string oauth_consumer_key , string oauth_consumer_secret ) { return checkproperties ( converttomap ( postprop ) , url , method , oauth_consumer_key , oauth_consumer_secret ) ; }	Check if the properties are properly signed.
public static boolean checkproperties ( map < string , string > postprop , string url , string method , string oauth_consumer_key , string oauth_consumer_secret ) { oauthmessage oam = new oauthmessage ( method , url , postprop . entryset ( ) ) ; oauthconsumer cons = new oauthconsumer ( str_ , oauth_consumer_key , oauth_consumer_secret , null ) ; oauthvalidator oav = new simpleoauthvalidator ( ) ; oauthaccessor acc = new oauthaccessor ( cons ) ; string base_string = null ; try { base_string = oauthsignaturemethod . getbasestring ( oam ) ; } catch ( exception e ) { m_log . warning ( e . getlocalizedmessage ( ) ) ; base_string = null ; return bool_ ; } try { oav . validatemessage ( oam , acc ) ; } catch ( exception e ) { m_log . warning ( str_ ) ; m_log . warning ( e . getlocalizedmessage ( ) ) ; if ( base_string != null ) { m_log . warning ( base_string ) ; } return bool_ ; } return bool_ ; }	Check if the fields are properly signed.
public static string prepareforexport ( string descriptor ) { map < string , object > tm = null ; try { tm = xmlmap . getfullmap ( descriptor . trim ( ) ) ; } catch ( exception e ) { m_log . warning ( str_ + e . getmessage ( ) ) ; return null ; } if ( tm == null ) { m_log . warning ( str_ ) ; return null ; } xmlmap . removesubmap ( tm , str_ ) ; string retval = xmlmap . getxml ( tm , bool_ ) ; return retval ; }	Remove fields that should not be exported.
public static void setproperty ( properties props , string key , string value ) { if ( value == null ) { return ; } if ( value . trim ( ) . length ( ) < num_ ) { return ; } props . setproperty ( key , value ) ; }	Mutates the passed Properties props variable.
public static string htmlspecialchars ( string input ) { if ( input == null ) { return null ; } string retval = input . replace ( str_ , str_ ) ; retval = retval . replace ( str_ , str_ ) ; retval = retval . replace ( str_ , str_ ) ; retval = retval . replace ( str_ , str_ ) ; retval = retval . replace ( str_ , str_ ) ; retval = retval . replace ( str_ , str_ ) ; return retval ; }	Basic utility to encode form text - handle the "safe cases".
static public string getrealpath ( string servleturl , string exturl ) { pattern pat = pattern . compile ( str_ ) ;	Simple utility method deal with a request that has the wrong URL whenbehind a proxy.
@ override public ltiverificationresult verify ( httpservletrequest request , string secret ) throws ltiverificationexception { oauthmessage oam = oauthservlet . getmessage ( request , oauthservlet . getrequesturl ( request ) ) ; string oauth_consumer_key = null ; try { oauth_consumer_key = oam . getconsumerkey ( ) ; } catch ( exception e ) { return new ltiverificationresult ( bool_ , ltierror . bad_request , str_ ) ; } oauthvalidator oav = new simpleoauthvalidator ( ) ; oauthconsumer cons = new oauthconsumer ( null , oauth_consumer_key , secret , null ) ; oauthaccessor acc = new oauthaccessor ( cons ) ; try { oav . validatemessage ( oam , acc ) ; } catch ( exception e ) { return new ltiverificationresult ( bool_ , ltierror . bad_request , str_ + e . getlocalizedmessage ( ) ) ; } return new ltiverificationresult ( bool_ , new ltilaunch ( request ) ) ; }	This method verifies the signed HttpServletRequest.
@ override public ltiverificationresult verifyparameters ( map < string , string > parameters , string url , string method , string secret ) throws ltiverificationexception { oauthmessage oam = new oauthmessage ( method , url , parameters . entryset ( ) ) ; oauthconsumer cons = new oauthconsumer ( null , parameters . get ( oauth_key_parameter ) , secret , null ) ; oauthvalidator oav = new simpleoauthvalidator ( ) ; oauthaccessor acc = new oauthaccessor ( cons ) ; try { oav . validatemessage ( oam , acc ) ; } catch ( exception e ) { return new ltiverificationresult ( bool_ , ltierror . bad_request , str_ + e . getlocalizedmessage ( ) + str_ + arrays . tostring ( parameters . entryset ( ) . toarray ( ) ) ) ; } return new ltiverificationresult ( bool_ , new ltilaunch ( parameters ) ) ; }	This method will verify a collection of parameters.
public void validaterequest ( string oauth_consumer_key , string oauth_secret , httpservletrequest request ) { validaterequest ( oauth_consumer_key , oauth_secret , request , null ) ; }	Assumes data is all loaded.
protected toolconsumer buildtoolconsumerprofile ( httpservletrequest request , map < string , object > deploy , string profile_id ) {	it is always null and we allow everything.
public static string validateservices ( toolconsumer consumer , jsonobject providerprofile ) {	Validate the incoming tool_services against a tool consumer.
public static string validatecapabilities ( toolconsumer consumer , jsonobject providerprofile ) { list < properties > thetools = new arraylist < properties > ( ) ; properties info = new properties ( ) ;	Validate incoming capabilities requested against out ToolConsumer.
public static void addcustomtolaunch ( properties ltiprops , properties custom ) { enumeration < ? > e = custom . propertynames ( ) ; while ( e . hasmoreelements ( ) ) { string keystr = ( string ) e . nextelement ( ) ; string value = custom . getproperty ( keystr ) ; setproperty ( ltiprops , str_ + keystr , value ) ; } }	Place the custom values into the launch.
private void tooglelistview ( view v ) { if ( mlastviewtouchid != v . getid ( ) ) { if ( mlastviewtouchid == mlistviewleft . getid ( ) ) { isleftlistenabled = bool_ ; isrightlistenabled = bool_ ; } else { isleftlistenabled = bool_ ; isrightlistenabled = bool_ ; } } }	Each time we touch the opposite ListView than the last one we have selectedwe need to activate it as the enable one.
@ override public void onlistscroll ( view view , float deltay ) { int speed ; if ( view . getid ( ) == mlistviewleft . getid ( ) && ! isleftlistenabled ) { speed = getspeed ( bool_ , deltay ) ; mlistviewright . smoothscrollby ( speed , num_ ) ; } else if ( view . getid ( ) == mlistviewright . getid ( ) && ! isrightlistenabled ) { speed = getspeed ( bool_ , deltay ) ; mlistviewleft . smoothscrollby ( speed , num_ ) ; } }	Receives the distance scroll on listView.
public static safeurlproto toproto ( safeurl url ) { return safeurlproto . newbuilder ( ) . setprivatedonotaccessorelsesafeurlwrappedvalue ( url . getsafeurlstring ( ) ) . build ( ) ; }	Serializes a SafeUrl into its opaque protocol message representation.
public static safestyleproto toproto ( safestyle style ) { return safestyleproto . newbuilder ( ) . setprivatedonotaccessorelsesafestylewrappedvalue ( style . getsafestylestring ( ) ) . build ( ) ; }	Serializes a SafeStyle into its opaque protocol message representation.
public static safescriptproto toproto ( safescript script ) { return safescriptproto . newbuilder ( ) . setprivatedonotaccessorelsesafescriptwrappedvalue ( script . getsafescriptstring ( ) ) . build ( ) ; }	Serializes a SafeScript into its opaque protocol message representation.
public static safestylesheetproto toproto ( safestylesheet style ) { return safestylesheetproto . newbuilder ( ) . setprivatedonotaccessorelsesafestylesheetwrappedvalue ( style . getsafestylesheetstring ( ) ) . build ( ) ; }	Serializes a SafeStyleSheet into its opaque protocol message representation.
public static trustedresourceurlproto toproto ( trustedresourceurl url ) { return trustedresourceurlproto . newbuilder ( ) . setprivatedonotaccessorelsetrustedresourceurlwrappedvalue ( url . gettrustedresourceurlstring ( ) ) . build ( ) ; }	Serializes a TrustedResourceUrl into its opaque protocol message representation.
public static safehtmlproto toproto ( safehtml safehtml ) { return safehtmlproto . newbuilder ( ) . setprivatedonotaccessorelsesafehtmlwrappedvalue ( safehtml . getsafehtmlstring ( ) ) . build ( ) ; }	Serializes a SafeHtml into its opaque protocol message representation.
public static double wrapanglerad ( double angle ) { angle %= trigmath . two_pi ; if ( angle <= - trigmath . pi ) { return angle + trigmath . two_pi ; } if ( angle > trigmath . pi ) { return angle - trigmath . two_pi ; } return angle ; }	Wraps the radian between -PI and PI.
public static double round ( double input , int decimals ) { final double p = math . pow ( num_ , decimals ) ; return math . round ( input * p ) / p ; }	Rounds a number to the amount of decimals specified.
public static double lerp ( double x , double x1 , double x2 , double q0 , double q1 ) { return ( ( x2 - x ) / ( x2 - x1 ) ) * q0 + ( ( x - x1 ) / ( x2 - x1 ) ) * q1 ; }	Calculates the value at x using linear interpolation.
public static quaternionf slerp ( quaternionf a , quaternionf b , float percent ) { final float inverted ; float cosinetheta = a . dot ( b ) ; if ( cosinetheta < num_ ) { cosinetheta = - cosinetheta ; inverted = - num_ ; } else { inverted = num_ ; } if ( num_ - cosinetheta < genericmath . flt_epsilon ) { return a . mul ( num_ - percent ) . add ( b . mul ( percent * inverted ) ) ; } final float theta = ( float ) trigmath . acos ( cosinetheta ) ; final float sinetheta = trigmath . sin ( theta ) ; final float coefficient1 = trigmath . sin ( ( num_ - percent ) * theta ) / sinetheta ; final float coefficient2 = trigmath . sin ( percent * theta ) / sinetheta * inverted ; return a . mul ( coefficient1 ) . add ( b . mul ( coefficient2 ) ) ; }	Interpolates a quaternion between two others using spherical linear interpolation.
public static double bilerp ( double x , double y , double q00 , double q01 , double q10 , double q11 , double x1 , double x2 , double y1 , double y2 ) { double q0 = lerp ( x , x1 , x2 , q00 , q10 ) ; double q1 = lerp ( x , x1 , x2 , q01 , q11 ) ; return lerp ( y , y1 , y2 , q0 , q1 ) ; }	Calculates the value at x,y using bilinear interpolation.
public static color blend ( color a , color b ) { return lerp ( a , b , a . getalpha ( ) / num_ ) ; }	Blends two colors into one.
public static double clamp ( double value , double low , double high ) { if ( value < low ) { return low ; } if ( value > high ) { return high ; } return value ; }	Clamps the value between the low and high boundaries.
public static double inversesqrt ( double a ) { final double halfa = num_ * a ; a = double . longbitstodouble ( num_ - ( double . doubletorawlongbits ( a ) > > num_ ) ) ; return a * ( num_ - halfa * a * a ) ; }	Returns a fast estimate of the inverse square root of the value.
public static float castfloat ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . floatvalue ( ) ; } try { return float . valueof ( o . tostring ( ) ) ; } catch ( numberformatexception e ) { return null ; } }	Casts a value to a float.
public static byte castbyte ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . bytevalue ( ) ; } try { return byte . valueof ( o . tostring ( ) ) ; } catch ( numberformatexception e ) { return null ; } }	Casts a value to a byte.
public static short castshort ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . shortvalue ( ) ; } try { return short . valueof ( o . tostring ( ) ) ; } catch ( numberformatexception e ) { return null ; } }	Casts a value to a short.
public static integer castint ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . intvalue ( ) ; } try { return integer . valueof ( o . tostring ( ) ) ; } catch ( numberformatexception e ) { return null ; } }	Casts a value to an integer.
public static double castdouble ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . doublevalue ( ) ; } try { return double . valueof ( o . tostring ( ) ) ; } catch ( numberformatexception e ) { return null ; } }	Casts a value to a double.
public static long castlong ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . longvalue ( ) ; } try { return long . valueof ( o . tostring ( ) ) ; } catch ( numberformatexception e ) { return null ; } }	Casts a value to a long.
public static boolean castboolean ( object o ) { if ( o == null ) { return null ; } if ( o instanceof boolean ) { return ( boolean ) o ; } else if ( o instanceof string ) { try { return boolean . parseboolean ( ( string ) o ) ; } catch ( illegalargumentexception e ) { return null ; } } return null ; }	Casts a value to a boolean.
public static int mean ( int ... values ) { int sum = num_ ; for ( int v : values ) { sum += v ; } return sum / values . length ; }	Calculates the mean of a set of values.
public static double mod ( double a , double div ) { final double remainder = a % div ; return remainder < num_ ? remainder + div : remainder ; }	Returns the modulo of 'a' by 'div' with corrections for negative numbers.
public static int multiplytoshift ( int a ) { if ( a < num_ ) { throw new illegalargumentexception ( str_ ) ; } int shift = num_ - integer . numberofleadingzeros ( a ) ; if ( ( num_ << shift ) != a ) { throw new illegalargumentexception ( str_ ) ; } return shift ; }	Converts a multiplication into a shift.
@ override public quaterniond mul ( double a ) { return new quaterniond ( x * a , y * a , z * a , w * a ) ; }	Multiplies the components of this quaternion by a double scalar.
@ override public quaterniond div ( double a ) { return new quaterniond ( x / a , y / a , z / a , w / a ) ; }	Divides the components of this quaternion by a double scalar.
public vector3d rotate ( double x , double y , double z ) { final double length = length ( ) ; if ( math . abs ( length ) < genericmath . dbl_epsilon ) { throw new arithmeticexception ( str_ ) ; } final double nx = this . x / length ; final double ny = this . y / length ; final double nz = this . z / length ; final double nw = this . w / length ; final double px = nw * x + ny * z - nz * y ; final double py = nw * y + nz * x - nx * z ; final double pz = nw * z + nx * y - ny * x ; final double pw = - nx * x - ny * y - nz * z ; return new vector3d ( pw * - nx + px * nw - py * nz + pz * ny , pw * - ny + py * nw - pz * nx + px * nz , pw * - nz + pz * nw - px * ny + py * nx ) ; }	Rotates the double components of a vector by this quaternion.
@ override public double lengthsquared ( ) { return x * x + y * y + z * z + w * w ; }	Returns the square of the length of this quaternion.
@ override public quaterniond normalize ( ) { final double length = length ( ) ; if ( math . abs ( length ) < genericmath . dbl_epsilon ) { throw new arithmeticexception ( str_ ) ; } return new quaterniond ( x / length , y / length , z / length , w / length ) ; }	Normalizes this quaternion.
public static quaterniond fromimaginary ( double x , double y , double z ) { return x == num_ && y == num_ && z == num_ ? zero : new quaterniond ( x , y , z , num_ ) ; }	Creates a new quaternion from the double imaginary components. The {.
public static quaterniond from ( double x , double y , double z , double w ) { return x == num_ && y == num_ && z == num_ && w == num_ ? zero : new quaterniond ( x , y , z , w ) ; }	Creates a new quaternion from the double components. The {.
public static quaterniond fromaxesanglesdeg ( double pitch , double yaw , double roll ) { return quaterniond . fromangledegaxis ( yaw , vector3d . unit_y ) . mul ( quaterniond . fromangledegaxis ( pitch , vector3d . unit_x ) ) . mul ( quaterniond . fromangledegaxis ( roll , vector3d . unit_z ) ) ; }	Creates a new quaternion from the double angles in degrees around the x, y and z axes.
public static quaterniond fromaxesanglesrad ( double pitch , double yaw , double roll ) { return quaterniond . fromangleradaxis ( yaw , vector3d . unit_y ) . mul ( quaterniond . fromangleradaxis ( pitch , vector3d . unit_x ) ) . mul ( quaterniond . fromangleradaxis ( roll , vector3d . unit_z ) ) ; }	Creates a new quaternion from the double angles in radians around the x, y and z axes.
public static quaterniond fromangleradaxis ( double angle , vector3d axis ) { return fromangleradaxis ( angle , axis . getx ( ) , axis . gety ( ) , axis . getz ( ) ) ; }	Creates a new quaternion from the rotation double angle in radians around the axis vector.
public static quaterniond fromangledegaxis ( float angle , float x , float y , float z ) { return fromangleradaxis ( math . toradians ( angle ) , x , y , z ) ; }	Creates a new quaternion from the rotation float angle in degrees around the axis vector float components.
@ override public int getminaxis ( ) { int value = x ; int axis = num_ ; if ( y < value ) { value = y ; axis = num_ ; } if ( z < value ) { value = z ; axis = num_ ; } if ( w < value ) { axis = num_ ; } return axis ; }	Return the axis with the minimal value.
public complexf mul ( float x , float y ) { return new complexf ( this . x * x - this . y * y , this . x * y + this . y * x ) ; }	Multiplies the float components of another complex with this one.
public complexf div ( float x , float y ) { final float d = x * x + y * y ; return new complexf ( ( this . x * x + this . y * y ) / d , ( this . y * x - this . x * y ) / d ) ; }	Divides this complex by the float components of another one.
public vector2f rotate ( float x , float y ) { final float length = length ( ) ; if ( math . abs ( length ) < genericmath . flt_epsilon ) { throw new arithmeticexception ( str_ ) ; } final float nx = this . x / length ; final float ny = this . y / length ; return new vector2f ( x * nx - y * ny , y * nx + x * ny ) ; }	Rotates the float components of a vector by this complex.
@ override public complexf normalize ( ) { final float length = length ( ) ; if ( math . abs ( length ) < genericmath . flt_epsilon ) { throw new arithmeticexception ( str_ ) ; } return new complexf ( x / length , y / length ) ; }	Normalizes this complex.
public quaternionf toquaternion ( float x , float y , float z ) { return quaternionf . fromangleradaxis ( getanglerad ( ) , x , y , z ) ; }	Converts this complex to a quaternion byusing the provided float components vectoras a rotation axis.
public static complexf from ( float x , float y ) { return x == num_ && y == num_ ? zero : new complexf ( x , y ) ; }	Creates a new complex from the float components. The {.
public static complexf fromanglerad ( float angle ) { return new complexf ( trigmath . cos ( angle ) , trigmath . sin ( angle ) ) ; }	Creates a new complex from the float angle in radians.
@ override public int getmaxaxis ( ) { long value = x ; int axis = num_ ; if ( y > value ) { value = y ; axis = num_ ; } if ( z > value ) { value = z ; axis = num_ ; } if ( w > value ) { axis = num_ ; } return axis ; }	Return the axis with the maximum value.
public static int hash ( double value ) { assert ! double . isnan ( value ) : str_ ; long bits = double . doubletolongbits ( value ) ; return ( int ) ( bits ^ ( bits > > > num_ ) ) ;	Returns a hashcode for the specified value.
public quaternionf add ( float x , float y , float z , float w ) { return new quaternionf ( this . x + x , this . y + y , this . z + z , this . w + w ) ; }	Adds the float components of another quaternion to this one.
@ override public quaternionf mul ( float a ) { return new quaternionf ( x * a , y * a , z * a , w * a ) ; }	Multiplies the components of this quaternion by a float scalar.
@ override public quaternionf div ( float a ) { return new quaternionf ( x / a , y / a , z / a , w / a ) ; }	Divides the components of this quaternion by a float scalar.
public vector3f getaxis ( ) { final float q = ( float ) math . sqrt ( num_ - w * w ) ; return new vector3f ( x / q , y / q , z / q ) ; }	Returns the axis of rotation for this quaternion.
public vector3f getaxesanglesrad ( ) { final double roll ; final double pitch ; double yaw ; final double test = w * x - y * z ; if ( math . abs ( test ) < num_ ) { roll = trigmath . atan2 ( num_ * ( w * z + x * y ) , num_ - num_ * ( x * x + z * z ) ) ; pitch = trigmath . asin ( num_ * test ) ; yaw = trigmath . atan2 ( num_ * ( w * y + z * x ) , num_ - num_ * ( x * x + y * y ) ) ; } else { final int sign = ( test < num_ ) ? - num_ : num_ ; roll = num_ ; pitch = sign * math . pi / num_ ; yaw = - sign * num_ * trigmath . atan2 ( z , w ) ; } return new vector3f ( pitch , yaw , roll ) ; }	Returns the angles in radians around the x, y and z axes that correspond to the rotation represented by this quaternion.
public static quaternionf fromimaginary ( float x , float y , float z ) { return x == num_ && y == num_ && z == num_ ? zero : new quaternionf ( x , y , z , num_ ) ; }	Creates a new quaternion from the float imaginary components. The {.
public static quaternionf from ( float x , float y , float z , float w ) { return x == num_ && y == num_ && z == num_ && w == num_ ? zero : new quaternionf ( x , y , z , w ) ; }	Creates a new quaternion from the float components. The {.
public static quaternionf fromaxesanglesdeg ( float pitch , float yaw , float roll ) { return quaternionf . fromangledegaxis ( yaw , vector3f . unit_y ) . mul ( quaternionf . fromangledegaxis ( pitch , vector3f . unit_x ) ) . mul ( quaternionf . fromangledegaxis ( roll , vector3f . unit_z ) ) ; }	Creates a new quaternion from the float angles in degrees around the x, y and z axes.
public static quaternionf fromaxesanglesrad ( float pitch , float yaw , float roll ) { return quaternionf . fromangleradaxis ( yaw , vector3f . unit_y ) . mul ( quaternionf . fromangleradaxis ( pitch , vector3f . unit_x ) ) . mul ( quaternionf . fromangleradaxis ( roll , vector3f . unit_z ) ) ; }	Creates a new quaternion from the float angles in radians around the x, y and z axes.
public static quaternionf fromangleradaxis ( float angle , vector3f axis ) { return fromangleradaxis ( angle , axis . getx ( ) , axis . gety ( ) , axis . getz ( ) ) ; }	Creates a new quaternion from the rotation float angle in radians around the axis vector.
public static quaternionf fromangleradaxis ( double angle , double x , double y , double z ) { return fromangleradaxis ( ( float ) angle , ( float ) x , ( float ) y , ( float ) z ) ; }	Creates a new quaternion from the rotation double angle in radians around the axis vector double components.
public complexd mul ( double x , double y ) { return new complexd ( this . x * x - this . y * y , this . x * y + this . y * x ) ; }	Multiplies the double components of another complex with this one.
public complexd div ( double x , double y ) { final double d = x * x + y * y ; return new complexd ( ( this . x * x + this . y * y ) / d , ( this . y * x - this . x * y ) / d ) ; }	Divides this complex by the double components of another one.
public vector2d rotate ( double x , double y ) { final double length = length ( ) ; if ( math . abs ( length ) < genericmath . dbl_epsilon ) { throw new arithmeticexception ( str_ ) ; } final double nx = this . x / length ; final double ny = this . y / length ; return new vector2d ( x * nx - y * ny , y * nx + x * ny ) ; }	Rotates the double components of a vector by this complex.
public quaterniond toquaternion ( double x , double y , double z ) { return quaterniond . fromangleradaxis ( getanglerad ( ) , x , y , z ) ; }	Converts this complex to a quaternion byusing the provided double components vectoras a rotation axis.
public static complexd from ( double x , double y ) { return x == num_ && y == num_ ? zero : new complexd ( x , y ) ; }	Creates a new complex from the double components. The {.
public static complexd fromanglerad ( double angle ) { return new complexd ( trigmath . cos ( angle ) , trigmath . sin ( angle ) ) ; }	Creates a new complex from the double angle in radians.
public void movechildview ( view pchildview , float pscale_left , float pscale_top ) { scalablelayout . layoutparams lsllp = getchildlayoutparams ( pchildview ) ; lsllp . mscale_left = pscale_left ; lsllp . mscale_top = pscale_top ; postinvalidate ( ) ; }	move childView inside ScalableLayout.
public void movechildview ( view pchildview , float pscale_left , float pscale_top , float pscale_width , float pscale_height ) { scalablelayout . layoutparams lsllp = getchildlayoutparams ( pchildview ) ; lsllp . mscale_left = pscale_left ; lsllp . mscale_top = pscale_top ; lsllp . mscale_width = pscale_width ; lsllp . mscale_height = pscale_height ; postinvalidate ( ) ; }	move and resize childView inside ScalableLayout.
private static void setblockspan ( spannablestringbuilder builder , object what ) { int length = math . max ( num_ , builder . length ( ) - num_ ) ; builder . setspan ( what , num_ , length , spannable . span_exclusive_exclusive ) ; }	These have trailing newlines that we want to avoid spanning.
public boundset reduce ( typesolver typesolver ) { list < constraintformula > constraints = new linkedlist < > ( constraintformulas ) ; boundset boundset = boundset . empty ( ) ; while ( constraints . size ( ) > num_ ) { constraintformula constraintformula = constraints . remove ( num_ ) ; constraintformula . reductionresult reductionresult = constraintformula . reduce ( boundset ) ; constraints . addall ( reductionresult . getconstraintformulas ( ) ) ; boundset . incorporate ( reductionresult . getboundset ( ) , typesolver ) ; } return boundset ; }	Takes a compatibility assertion about an expression or type, called a constraint formula, and reduces it to aset of bounds on inference variables.
@ override public resolvedtype transformtypeparameters ( resolvedtypetransformer transformer ) { resolvedtype result = this ; int i = num_ ; for ( resolvedtype tp : this . typeparametersvalues ( ) ) { resolvedtype transformedtp = transformer . transform ( tp ) ;	Execute a transformation on all the type parameters of this element.
public static < s extends resolveddeclaration , s2 extends s > symbolreference < s > solved ( s2 symboldeclaration ) { return new symbolreference < s > ( optional . of ( symboldeclaration ) ) ; }	Create a solve reference to the given symbol.
public static < s extends resolveddeclaration , s2 extends s > symbolreference < s > unsolved ( class < s2 > clazz ) { return new symbolreference < > ( optional . empty ( ) ) ; }	Create an unsolved reference specifying the type of the value expected.
public static boolean ispropertype ( resolvedtype type ) { if ( type instanceof inferencevariable ) { return bool_ ; } if ( type instanceof resolvedreferencetype ) { resolvedreferencetype referencetype = ( resolvedreferencetype ) type ; return referencetype . typeparametersvalues ( ) . stream ( ) . allmatch ( it -> ispropertype ( it ) ) ; } if ( type instanceof resolvedwildcard ) { resolvedwildcard wildcard = ( resolvedwildcard ) type ; if ( wildcard . isbounded ( ) ) { return ispropertype ( wildcard . getboundedtype ( ) ) ; } else { return bool_ ; } } if ( type . isprimitive ( ) ) { return bool_ ; } if ( type . istypevariable ( ) ) {	The term proper type excludes such "types" that mention inference variables.
public static resolvedtype glb ( set < resolvedtype > types ) { if ( types . size ( ) == num_ ) { throw new illegalargumentexception ( ) ; } if ( types . size ( ) == num_ ) { return types . iterator ( ) . next ( ) ; } return new resolvedintersectiontype ( types ) ; }	See JLS 5.1.10. Capture Conversion.
private resolvedtype solvedotexpressiontype ( resolvedreferencetypedeclaration parenttype , fieldaccessexpr node ) {	Java Parser can't differentiate between packages, internal types, and fields.All three are lumped together into FieldAccessExpr.
public symbolreference < resolvedconstructordeclaration > solve ( objectcreationexpr objectcreationexpr , boolean solvelambdas ) { list < resolvedtype > argumenttypes = new linkedlist < > ( ) ; list < lambdaargumenttypeplaceholder > placeholders = new linkedlist < > ( ) ; solvearguments ( objectcreationexpr , objectcreationexpr . getarguments ( ) , solvelambdas , argumenttypes , placeholders ) ; resolvedtype classdecl = javaparserfacade . get ( typesolver ) . convert ( objectcreationexpr . gettype ( ) , objectcreationexpr ) ; if ( ! classdecl . isreferencetype ( ) ) { return symbolreference . unsolved ( resolvedconstructordeclaration . class ) ; } symbolreference < resolvedconstructordeclaration > res = constructorresolutionlogic . findmostapplicable ( ( ( resolvedclassdeclaration ) classdecl . asreferencetype ( ) . gettypedeclaration ( ) ) . getconstructors ( ) , argumenttypes , typesolver ) ; for ( lambdaargumenttypeplaceholder placeholder : placeholders ) { placeholder . setmethod ( res ) ; } return res ; }	Given a constructor call find out to which constructor declaration it corresponds.
public symbolreference < resolvedmethoddeclaration > solve ( methodcallexpr methodcallexpr , boolean solvelambdas ) { list < resolvedtype > argumenttypes = new linkedlist < > ( ) ; list < lambdaargumenttypeplaceholder > placeholders = new linkedlist < > ( ) ; solvearguments ( methodcallexpr , methodcallexpr . getarguments ( ) , solvelambdas , argumenttypes , placeholders ) ; symbolreference < resolvedmethoddeclaration > res = javaparserfactory . getcontext ( methodcallexpr , typesolver ) . solvemethod ( methodcallexpr . getname ( ) . getid ( ) , argumenttypes , bool_ , typesolver ) ; for ( lambdaargumenttypeplaceholder placeholder : placeholders ) { placeholder . setmethod ( res ) ; } return res ; }	Given a method call find out to which method declaration it corresponds.
private optional < resolvedtype > find ( map < node , resolvedtype > map , lambdaexpr lambdaexpr ) { for ( node key : map . keyset ( ) ) { if ( key instanceof lambdaexpr ) { lambdaexpr keylambdaexpr = ( lambdaexpr ) key ; if ( keylambdaexpr . tostring ( ) . equals ( lambdaexpr . tostring ( ) ) && getparentnode ( keylambdaexpr ) == getparentnode ( lambdaexpr ) ) { return optional . of ( map . get ( keylambdaexpr ) ) ; } } } return optional . empty ( ) ; }	For some reasons LambdaExprs are duplicate and the equals method is not implemented correctly.
private string qname ( classorinterfacetype classorinterfacetype ) { string name = classorinterfacetype . getname ( ) . getid ( ) ; if ( classorinterfacetype . getscope ( ) . ispresent ( ) ) { return qname ( classorinterfacetype . getscope ( ) . get ( ) ) + str_ + name ; } else { return name ; } }	This is an hack around an issue in JavaParser.
public resolvedtype gettypeofthisin ( node node ) {	"this" inserted in the given point, which type would have?.
public boolean exitthestatement ( breakstmt breakstmt ) { if ( ! isreachable ( breakstmt ) ) { return bool_ ; } statement breaktarget = breaktarget ( breakstmt ) ; for ( trystmt trystmt : containedtrystmts ( breaktarget ) ) { if ( contains ( trystmt . gettryblock ( ) , breakstmt ) ) { if ( ! trystmt . getfinallyblock ( ) . ispresent ( ) && ! cancompletenormally ( trystmt . getfinallyblock ( ) . get ( ) ) ) { return bool_ ; } } } return bool_ ; }	A reachable break statement exits a statement if, within the break target, either there are no try statementswhose try blocks contain the break statement, or there are try statements whose try blocks contain the breakstatement and all finally clauses of those try statements can complete normally.
@ deprecated public symbolreference < resolvedtypedeclaration > solvetypeintype ( resolvedtypedeclaration typedeclaration , string name ) { if ( typedeclaration instanceof javaparserclassdeclaration ) { return ( ( javaparserclassdeclaration ) typedeclaration ) . solvetype ( name , typesolver ) ; } if ( typedeclaration instanceof javaparserinterfacedeclaration ) { return ( ( javaparserinterfacedeclaration ) typedeclaration ) . solvetype ( name , typesolver ) ; } return symbolreference . unsolved ( resolvedreferencetypedeclaration . class ) ; }	Try to solve a symbol just in the declaration, it does not delegate to the container.
public static value from ( resolvedvaluedeclaration decl ) { resolvedtype type = decl . gettype ( ) ; return new value ( type , decl . getname ( ) ) ; }	Create a Value from a ValueDeclaration.
public boolean invocationapplicabilityinference ( methodcallexpr methodcallexpr , resolvedmethoddeclaration methoddeclaration ) { if ( ! methodcallexpr . getnameasstring ( ) . equals ( methoddeclaration . getname ( ) ) ) { throw new illegalargumentexception ( ) ; } optional < instantiationset > partial = instantiationinference ( methodcallexpr , methoddeclaration ) ; if ( ! partial . ispresent ( ) ) { return bool_ ; } int nactualparams = methodcallexpr . getarguments ( ) . size ( ) ; int nformalparams = methoddeclaration . getnumberofparams ( ) ; if ( nactualparams != nformalparams ) { if ( methoddeclaration . hasvariadicparameter ( ) ) { if ( nactualparams < ( nformalparams - num_ ) ) { return bool_ ; } } else { return bool_ ; } }	Determine whether a potentially applicable generic method m is applicable for a method invocation thatprovides no explicit type arguments.
private static boolean appearsinassignmentcontext ( expression expression ) { if ( expression . getparentnode ( ) . ispresent ( ) ) { node parent = expression . getparentnode ( ) . get ( ) ; if ( parent instanceof expressionstmt ) { return bool_ ; } if ( parent instanceof methodcallexpr ) { return bool_ ; } if ( parent instanceof returnstmt ) { return bool_ ; } throw new unsupportedoperationexception ( parent . getclass ( ) . getcanonicalname ( ) ) ; } return bool_ ; }	Not sure if should look if the parent is an assignment context.
public float [ ] predict ( fvec feat , boolean output_margin , int ntree_limit ) { float [ ] preds = predictraw ( feat , ntree_limit ) ; if ( ! output_margin ) { preds = obj . predtransform ( preds ) ; } return preds ; }	Generates predictions for given feature vector.
public void loadmodel ( modelreader reader ) throws ioexception { param = new param ( reader ) ; nodes = new node [ param . num_nodes ] ; for ( int i = num_ ; i < param . num_nodes ; i ++ ) { nodes [ i ] = new node ( reader ) ; } stats = new rtreenodestat [ param . num_nodes ] ; for ( int i = num_ ; i < param . num_nodes ; i ++ ) { stats [ i ] = new rtreenodestat ( reader ) ; } }	Loads model from stream.
@ override public int getleafindex ( fvec feat , int root_id ) { int pid = root_id ; node n ; while ( ! ( n = nodes [ pid ] ) . _isleaf ) { pid = n . next ( feat ) ; } return pid ; }	Retrieves nodes from root to leaf and returns leaf index.
@ override public float getleafvalue ( fvec feat , int root_id ) { node n = nodes [ root_id ] ; while ( ! n . _isleaf ) { n = nodes [ n . next ( feat ) ] ; } return n . leaf_value ; }	Retrieves nodes from root to leaf and returns leaf value.
public string unflatten ( ) { stringwriter sw = new stringwriter ( ) ; if ( root . isarray ( ) ) { try { unflattenarray ( root . asarray ( ) ) . writeto ( sw , getwriterconfig ( ) ) ; } catch ( ioexception e ) { } return sw . tostring ( ) ; } if ( ! root . isobject ( ) ) { return root . tostring ( ) ; } jsonobject flattened = root . asobject ( ) ; jsonvalue unflattened = flattened . names ( ) . isempty ( ) ? json . object ( ) : null ; for ( string key : flattened . names ( ) ) { jsonvalue currentval = unflattened ; string objkey = null ; integer aryidx = null ; matcher matcher = keypartpattern ( ) . matcher ( key ) ; while ( matcher . find ( ) ) { string keypart = matcher . group ( ) ; if ( objkey != null ^ aryidx != null ) { if ( isjsonarray ( keypart ) ) { currentval = findorcreatejsonarray ( currentval , objkey , aryidx ) ; objkey = null ; aryidx = extractindex ( keypart ) ; } else {	Returns a JSON string of nested objects by the given flattened JSON string.
public string flatten ( ) { flattenasmap ( ) ; if ( source . isobject ( ) || isobjectifiablearray ( ) ) return flattenedmap . tostring ( printmode ) ; else return javaobj2json ( flattenedmap . get ( root ) ) ; }	Returns a flattened JSON string.
public map < string , object > flattenasmap ( ) { if ( flattenedmap != null ) return flattenedmap ; flattenedmap = newjsonifylinkedhashmap ( ) ; reduce ( source ) ; while ( ! elementiters . isempty ( ) ) { indexedpeekiterator < ? > deepestiter = elementiters . getlast ( ) ; if ( ! deepestiter . hasnext ( ) ) { elementiters . removelast ( ) ; } else if ( deepestiter . peek ( ) instanceof member ) { member mem = ( member ) deepestiter . next ( ) ; reduce ( mem . getvalue ( ) ) ; } else {	Returns a flattened JSON as Map.
public static < e > list < e > concatview ( list < list < ? extends e > > lists ) { if ( lists . isempty ( ) ) { return collections . emptylist ( ) ; } else { return concatview . create ( lists ) ; } }	Returns a list that is a concatenation of the given lists.
public static eventstream < void > invalidationsof ( observable observable ) { return new eventstreambase < void > ( ) { @ override protected subscription observeinputs ( ) { invalidationlistener listener = obs -> emit ( null ) ; observable . addlistener ( listener ) ; return ( ) -> observable . removelistener ( listener ) ; } } ; }	Creates an event stream that emits an impulse on every invalidationof the given observable.
public static < o extends observable > eventstream < o > repeatoninvalidation ( o observable ) { return new eventstreambase < o > ( ) { @ override protected subscription observeinputs ( ) { invalidationlistener listener = obs -> emit ( observable ) ; observable . addlistener ( listener ) ; return ( ) -> observable . removelistener ( listener ) ; } @ override protected void newobserver ( consumer < ? super o > subscriber ) { subscriber . accept ( observable ) ; } } ; }	Creates an event stream that emits the given observable immediately forevery subscriber and re-emits it on every subsequent invalidation of theobservable.
public static eventstream < long > animationframes ( ) { return animationticks ( ) . accumulate ( t ( num_ , - num_ ) , ( state , now ) -> state . map ( ( d , last ) -> { return t ( last == - num_ ? num_ : now - last , now ) ; } ) ) . map ( t -> t . _1 ) ; }	Returns a stream that, on each animation frame, emits the durationelapsed since the previous animation frame, in nanoseconds.
public static < t > eventstream < t > merge ( observableset < ? extends eventstream < t > > set ) { return new eventstreambase < t > ( ) { @ override protected subscription observeinputs ( ) { return subscription . dynamic ( set , s -> s . subscribe ( this :: emit ) ) ; } } ; }	Returns an event stream that emits all the events emitted from any ofthe event streams in the given observable set.
@ deprecated public static < e > observablelist < e > wrap ( javafx . collections . observablelist < e > delegate ) { return livelist . suspendable ( delegate ) ; }	Creates an ObservableList wrapper that is able to temporarily blocklist change notifications.
public < t > t onwhile ( supplier < t > f ) { try ( guard g = on ( ) ) { return f . get ( ) ; } }	Runs the given computation, making sure this indicator is on.When done, this indicator is reset to the previous state.
@ override public final subscription observe ( o observer ) { p adapted = adaptobserver ( observer ) ; underlying . addobserver ( adapted ) ; return ( ) -> underlying . removeobserver ( adapted ) ; }	Overridden to avoid second transformation on removeObserver.
public metadata copy ( ) { metadata result = new metadata ( ) ; result . setencoding ( encoding ) ; result . settrailingslash ( trailingslash ) ; result . setleadingslash ( leadingslash ) ; return result ; }	Return a copy of this Metadata.
protected string stripknownprefix ( string str , string prefix ) { int startindex = str . lastindexof ( prefix ) ; if ( startindex != - num_ ) { return str . substring ( startindex + prefix . length ( ) ) ; } return null ; }	Strip everything up to and including a given prefix from a string.
private digester configuredigester ( final digester digester ) { digester . setusecontextclassloader ( bool_ ) ; digester . addobjectcreate ( str_ , rewriterule . class ) ; digester . addsetproperties ( str_ ) ; digester . addsetnext ( str_ , str_ ) ; digester . addobjectcreate ( str_ , urlmapping . class ) ; digester . addsetproperties ( str_ ) ; digester . addcallmethod ( str_ , str_ , num_ ) ; digester . addcallparam ( str_ , num_ , str_ ) ; digester . addcallmethod ( str_ , str_ , num_ ) ; digester . addcallmethod ( str_ , str_ , num_ ) ; digester . addcallparam ( str_ , num_ , str_ ) ; digester . addcallmethod ( str_ , str_ , num_ ) ; digester . addobjectcreate ( str_ , pathvalidator . class ) ; digester . addsetproperties ( str_ ) ; digester . addsetnext ( str_ , str_ ) ; digester . addobjectcreate ( str_ , queryparameter . class ) ; digester . addsetproperties ( str_ ) ; digester . addcallmethod ( str_ , str_ , num_ ) ; digester . addsetnext ( str_ , str_ ) ; digester . addobjectcreate ( str_ , urlaction . class ) ; digester . addsetproperties ( str_ ) ; digester . addcallmethod ( str_ , str_ , num_ ) ; digester . addsetnext ( str_ , str_ ) ; digester . addsetnext ( str_ , str_ ) ; return digester ; }	Configure the digester. Assume that the builder object will be pushedafter this method is called.
public string [ ] processclassmappingannotations ( class < ? > clazz ) {	Checks for PrettyFaces mapping annotations on a single class.
private static string join ( string [ ] values , string separator ) { stringbuilder result = new stringbuilder ( ) ; if ( values != null ) { for ( int i = num_ ; i < values . length ; i ++ ) { if ( i > num_ ) { result . append ( separator ) ; } result . append ( values [ i ] ) ; } } return result . tostring ( ) ; }	Joins the list of values.
public void initdevicescan ( ) {	Initialize Key Stored Values.
public boolean detectiphone ( ) { if ( ( this . initcompleted == bool_ ) || ( this . isiphone == bool_ ) ) return this . isiphone ;	Detects if the current device is an iPhone.
public boolean detectwebkit ( ) { if ( ( this . initcompleted == bool_ ) || ( this . iswebkit == bool_ ) ) return this . iswebkit ; if ( useragent . indexof ( enginewebkit ) != - num_ ) { return bool_ ; } return bool_ ; }	Detects if the current browser is based on WebKit.
public boolean detectwindowsmobile ( ) { if ( detectwindowsphone ( ) ) { return bool_ ; }	Detects if the current browser is a Windows Mobile device.
public boolean detectblackberry ( ) { if ( useragent . indexof ( devicebb ) != - num_ || httpaccept . indexof ( vndrim ) != - num_ ) return bool_ ; if ( detectblackberry10phone ( ) ) return bool_ ; return bool_ ; }	Detects if the current browser is any BlackBerry.
public boolean detects60ossbrowser ( ) {	Detects if the current browser is the Symbian S60 Open Source Browser.
public boolean detectpalmos ( ) {	Detects if the current browser is on a PalmOS device.
public boolean detectoperaandroidphone ( ) { if ( useragent . indexof ( engineopera ) != - num_ && ( useragent . indexof ( deviceandroid ) != - num_ && useragent . indexof ( mobi ) != - num_ ) ) { return bool_ ; } return bool_ ; }	Detects Opera Mobile on an Android phone.
public boolean detectoperaandroidtablet ( ) { if ( useragent . indexof ( engineopera ) != - num_ && ( useragent . indexof ( deviceandroid ) != - num_ && useragent . indexof ( devicetablet ) != - num_ ) ) { return bool_ ; } return bool_ ; }	Detects Opera Mobile on an Android tablet.
public boolean detectmaemotablet ( ) { if ( useragent . indexof ( maemo ) != - num_ ) { return bool_ ; } else if ( useragent . indexof ( linux ) != - num_ && useragent . indexof ( devicetablet ) != - num_ && ! detectwebostablet ( ) && ! detectandroid ( ) ) { return bool_ ; } return bool_ ; }	Detects if the current device is on one of the Maemo-based Nokia Internet Tablets.
public boolean detectmobilequick ( ) {	Detects if the current device is a mobile device.
public boolean detecttieriphone ( ) { if ( ( this . initcompleted == bool_ ) || ( this . istieriphone == bool_ ) ) return this . istieriphone ; if ( detectiphoneoripod ( ) || detectandroidphone ( ) || detectwindowsphone ( ) || detectblackberry10phone ( ) || ( detectblackberrywebkit ( ) && detectblackberrytouch ( ) ) || detectpalmwebos ( ) || detectbada ( ) || detecttizen ( ) || detectgaminghandheld ( ) ) { return bool_ ; } return bool_ ; }	The quick way to detect for a tier of devices.
public boolean detecttierotherphones ( ) { if ( ( this . initcompleted == bool_ ) || ( this . istiergenericmobile == bool_ ) ) return this . istiergenericmobile ;	The quick way to detect for a tier of devices.
public static boolean isel ( final string value ) { if ( value == null ) { return bool_ ; } return elpattern . matcher ( value ) . matches ( ) ; }	Return true if the value is an EL expression.
public static boolean containsel ( final string value ) { if ( value == null ) { return bool_ ; } return elpattern . matcher ( value ) . find ( ) ; }	Return true if the value contains an EL expression.
private string buildscriptinternal ( final string url ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( str_ ) ; builder . append ( url ) ; builder . append ( str_ ) ; return builder . tostring ( ) ; }	Creates the required script for the supplied URL.
public static el method ( final string retrieve , final string submit ) { return new elmethod ( new constantexpression ( retrieve ) , new constantexpression ( submit ) ) ; }	Create a new EL Method binding using distinct expressions to submit and retrieve values.
private boolean containsfielddescriptor ( string str ) { for ( string descriptor : fielddescriptors ) { if ( str . contains ( descriptor ) ) { return bool_ ; } } return bool_ ; }	Returns true if the given string contains a field descriptor of one of the annotations we are looking for.
protected void copyresponseheaders ( httpresponse proxyresponse , httpservletresponse servletresponse ) { for ( header header : proxyresponse . getallheaders ( ) ) { if ( hopbyhopheaders . containsheader ( header . getname ( ) ) ) continue ; servletresponse . addheader ( header . getname ( ) , header . getvalue ( ) ) ; } }	Copy proxied response headers back to the servlet client.
protected static charsequence encodeuriquery ( charsequence in ) { stringbuilder outbuf = null ; formatter formatter = null ; for ( int i = num_ ; i < in . length ( ) ; i ++ ) { char c = in . charat ( i ) ; boolean escape = bool_ ; if ( c < num_ ) { if ( asciiquerychars . get ( c ) ) { escape = bool_ ; } } else if ( ! character . isisocontrol ( c ) && ! character . isspacechar ( c ) ) { escape = bool_ ; } if ( ! escape ) { if ( outbuf != null ) outbuf . append ( c ) ; } else { if ( outbuf == null ) { outbuf = new stringbuilder ( in . length ( ) + num_ * num_ ) ; outbuf . append ( in , num_ , i ) ; formatter = new formatter ( outbuf ) ; } formatter . format ( str_ , ( int ) c ) ;	Encodes characters in the query or fragment part of the URI.
public uri touri ( ) { try { uri uri = new uri ( tourl ( ) ) ; return uri ; } catch ( urisyntaxexception e ) { throw new illegalstateexception ( str_ , e ) ; } }	Return a URI representation of this URL including path and query string.
public static querystring build ( final string url ) { querystring querystring = new querystring ( ) ; querystring . addparameters ( url ) ; return querystring ; }	Build a query string from the given URL.
public string getparameter ( final string name ) { list < string > values = parameters . get ( name ) ; if ( values == null ) { return null ; } if ( values . size ( ) == num_ ) { return str_ ; } return values . get ( num_ ) ; }	Get the first value of given parameter name.
public string [ ] getparametervalues ( final string name ) { list < string > values = parameters . get ( name ) ; if ( values == null ) { return null ; } return values . toarray ( new string [ values . size ( ) ] ) ; }	Get the array of values for a given parameter name.
public void addparameters ( string url ) { if ( ( url != null ) && ! str_ . equals ( url ) ) { url = url . trim ( ) ; if ( url . length ( ) > num_ ) { if ( url . contains ( str_ ) ) { url = url . substring ( url . indexof ( str_ ) + num_ ) ; } string pairs [ ] = url . split ( str_ ) ; for ( string pair : pairs ) { string name ; string value ; int pos = pair . indexof ( str_ ) ;	Add parameters from the given URL.
@ override public string deriveviewid ( final facescontext context , final string rawviewid ) { string canonicalviewid = new urlduplicatepathcanonicalizer ( ) . canonicalize ( rawviewid ) ; return parent . deriveviewid ( context , canonicalviewid ) ; }	Canonicalize the given viewId, then pass that viewId to the next ViewHandler in the chain.
public urlpatternparser getpatternparser ( ) { if ( ( parser == null ) && ( pattern != null ) ) { this . parser = new urlpatternparser ( pattern ) ; } return parser ; }	Get this patterns pattern parser instance.
public list < pathvalidator > getvalidatorsforpathparam ( final pathparameter param ) { list < pathvalidator > result = new arraylist < pathvalidator > ( ) ; for ( pathvalidator pv : pathvalidators ) { if ( pv . getindex ( ) == param . getposition ( ) ) { result . add ( pv ) ; } } return result ; }	Return a list of validators that belong to the given parameter.
public static querystringbuilder createfromencoded ( final string parameters ) { querystringbuilder querystring = new querystringbuilder ( ) ; querystring . addparameters ( parameters ) ; return querystring ; }	Build a query string from the given URL.
public static string extractquery ( string url ) { if ( url != null ) { int index = url . indexof ( str_ ) ; if ( index >= num_ ) { url = url . substring ( index + num_ ) ; } } return url ; }	Get the query string portion of the given URL.
public void addparameter ( final string name , final string ... values ) { map < string , string [ ] > parameter = new linkedhashmap < string , string [ ] > ( ) ; parameter . put ( name , values ) ; addparameterarrays ( parameter ) ; }	Add a single parameter with the given values.
@ suppresswarnings ( str_ ) private list < dispatchertypeprovider > getdispatchertypeproviders ( httpservletrewrite event ) { list < dispatchertypeprovider > providers = ( list < dispatchertypeprovider > ) event . getrequest ( ) . getattribute ( provider_key ) ; if ( providers == null ) { providers = iterators . aslist ( serviceloader . loadtypesafe ( dispatchertypeprovider . class ) . iterator ( ) ) ; collections . sort ( providers , new weightedcomparator ( ) ) ; event . getrequest ( ) . setattribute ( provider_key , providers ) ; } return providers ; }	Simple caching mechanism for the providers on a per request basis.
public static int getnegationcount ( final evaluationcontext context ) { if ( context == null ) return num_ ; integer count = ( integer ) context . get ( negation_count_key ) ; return count == null ? num_ : count ; }	Returns the number of "Not"s that have been evaluated in the current evaluation process.For example, when(Not.any(MyCondition)) would have a "NotCount" of "1" during the evaluation of "MyCondition".when(Not.any(Not.any(MyCondition))) would have a "NotCount" of "2" during the evaluation of "MyCondition".This is useful for conditions that may have side effects, as they will know whether or not their condition is beingnegated.
public navigate with ( charsequence name , object value ) { assert . notnull ( name , str_ ) ; if ( value != null ) { parameters . put ( name . tostring ( ) , value . tostring ( ) ) ; } return this ; }	Set a query parameter to be passed to the specified View Id.
private string buildstandardoutcome ( ) { stringbuilder outcome = new stringbuilder ( ) ; outcome . append ( viewid ) ; boolean first = bool_ ; for ( entry < string , list < string > > param : parameters . entryset ( ) ) { for ( string value : param . getvalue ( ) ) { outcome . append ( first ? str_ : str_ ) ; outcome . append ( param . getkey ( ) ) ; outcome . append ( str_ ) ; outcome . append ( value ) ; first = bool_ ; } } return outcome . tostring ( ) ; }	Builds a standard JSF 2.0 implicit navigation outcome.
private void handleclassentry ( string entryname , classvisitor visitor ) {	Handles class entry in a WEB-INF.
addressbuilderquery queryliteral ( string query ) { if ( query != null ) { if ( query . startswith ( str_ ) ) query = query . substring ( num_ ) ; map < charsequence , list < charsequence > > params = new linkedhashmap < charsequence , list < charsequence > > ( ) ; query = decodehtmlampersands ( query ) ; int index = num_ ; while ( ( index = query . indexof ( str_ ) ) >= num_ || ! query . isempty ( ) ) { string pair = query ; if ( index >= num_ ) { pair = query . substring ( num_ , index ) ; query = query . substring ( index ) ; if ( ! query . isempty ( ) ) query = query . substring ( num_ ) ; } else query = str_ ; string name ; string value ; int pos = pair . indexof ( str_ ) ;	Set a literal query string without additional encoding or decoding.
public encodequery excluding ( final string ... params ) { if ( ( params != null ) && ( params . length > num_ ) ) this . excludedparams . addall ( arrays . aslist ( params ) ) ; return this ; }	Exclude the given query-parameter names from encoding.
public url buildurl ( final urlmapping mapping ) { url result = null ; string expression = str_ ; object value = null ; try { facescontext context = facescontext . getcurrentinstance ( ) ; urlpatternparser parser = mapping . getpatternparser ( ) ; list < pathparameter > parameters = parser . getpathparameters ( ) ; list < string > parametervalues = new arraylist < string > ( ) ; for ( pathparameter injection : parameters ) {	For all required values of the given PrettyUrlMapping, extract values from their mapped backing beans and create aURL based on the url-pattern.
public void senderror ( int code , string message , httpservletresponse response ) { assert . notnull ( response , str_ ) ; try { if ( message != null ) { response . senderror ( code , message ) ; } else { response . senderror ( code ) ; } } catch ( ioexception e ) { throw new illegalstateexception ( str_ + code , e ) ; } }	Sends an error response to the client using the specified HTTP statuscode.
@ override public void visit ( class < ? > clazz ) { classcontextimpl context = new classcontextimpl ( builder , clazz ) ; context . put ( clazz , payload ) ; if ( log . istraceenabled ( ) ) { log . trace ( str_ , clazz . getname ( ) ) ; }	Processes the annotation on the supplied class.
private string prependcontextpath ( externalcontext externalcontext , string url ) { string contextpath = externalcontext . getrequestcontextpath ( ) ; if ( str_ . equals ( contextpath ) || ( url . startswith ( contextpath ) ) ) { return url ; } return contextpath + url ; }	Adds the context path to the given context-relative URL.
private string stripcontextpath ( final string contextpath , string uri ) { if ( ! contextpath . equals ( str_ ) && uri . startswith ( contextpath ) ) { uri = uri . substring ( contextpath . length ( ) ) ; } return uri ; }	If the given URL is prefixed with this request's context-path, return the URI without the context path.
private string translate ( string lang , string value ) { string translatation = null ; if ( value != null ) { if ( ! bundlemap . containskey ( lang ) ) { locale locale = new locale ( lang ) ; try { resourcebundle loadedbundle = resourcebundle . getbundle ( bundlename , locale , resourcebundle . control . getnofallbackcontrol ( resourcebundle . control . format_default ) ) ; bundlemap . put ( lang , loadedbundle ) ; } catch ( missingresourceexception e ) { return null ; } } try {	Translate a value into the matching one from a resource bundle in specified language.
public string builddynaviewid ( final string facesservletmapping ) { stringbuffer result = new stringbuffer ( ) ; map < pattern , string > patterns = new linkedhashmap < pattern , string > ( ) ; pattern pathmapping = pattern . compile ( str_ ) ; pattern extensionmapping = pattern . compile ( str_ ) ; pattern defaultmapping = pattern . compile ( str_ ) ; patterns . put ( pathmapping , str_ + dynaview + str_ ) ; patterns . put ( extensionmapping , str_ + dynaview + str_ ) ; patterns . put ( defaultmapping , str_ + dynaview + str_ ) ; boolean matched = bool_ ; iterator < pattern > iterator = patterns . keyset ( ) . iterator ( ) ; while ( ( matched == bool_ ) && iterator . hasnext ( ) ) { pattern p = iterator . next ( ) ; matcher m = p . matcher ( facesservletmapping ) ; if ( m . matches ( ) ) { string replacement = patterns . get ( p ) ; m . appendreplacement ( result , replacement ) ; matched = bool_ ; } } if ( matched == bool_ ) {	Given the string value of the Faces Servlet mapping, return a string that is guaranteed to match when a servletforward is issued.
public void processdynaview ( final prettycontext prettycontext , final facescontext facescontext ) { log . trace ( str_ + prettycontext . getrequesturl ( ) ) ; string viewid = str_ ; try { viewid = prettycontext . getcurrentviewid ( ) ; log . trace ( str_ + viewid ) ; object result = computedynaviewid ( facescontext ) ; if ( result instanceof string ) { viewid = ( string ) result ; log . trace ( str_ + viewid ) ; prettycontext . setdynaviewprocessed ( bool_ ) ; facescontext . getexternalcontext ( ) . dispatch ( viewid ) ; facescontext . responsecomplete ( ) ; } } catch ( exception e ) { log . error ( str_ , e ) ; prettyredirector prettyredirector = new prettyredirector ( ) ; prettyredirector . send404 ( facescontext ) ; throw new prettyexception ( str_ + viewid + str_ , e ) ; } }	Handle DynaView processing. This method will end the Faces life-cycle.
private type getrequiredtype ( class < ? > clazz ) { typevariable < ? > [ ] typeparameters = clazz . gettypeparameters ( ) ; if ( typeparameters . length > num_ ) { type [ ] actualtypeparameters = new type [ typeparameters . length ] ; for ( int i = num_ ; i < typeparameters . length ; i ++ ) { actualtypeparameters [ i ] = new wildcardtypeimpl ( new type [ ] { object . class } , new type [ ] { } ) ; } return new parameterizedtypeimpl ( clazz , actualtypeparameters , null ) ; } return clazz ; }	Builds the correct "required type" including actual type arguments in case of parameterized types.
@ suppresswarnings ( str_ ) public static < t extends annotation > t getannotationproxy ( annotation customannotation , class < t > referenceannotation ) { invocationhandler handler = new annotationinvocationhandler ( customannotation ) ; return ( t ) proxy . newproxyinstance ( referenceannotation . getclassloader ( ) , new class [ ] { referenceannotation } , handler ) ; }	Returns a proxy on the customAnnotation, having the same type than the referenceAnnotation.
private collection < field > getfilteredfields ( class < ? > refclass ) { softreference < collection < field > > ref = fieldcache . get ( refclass ) ; collection < field > fieldlist = ref != null ? ref . get ( ) : null ; if ( fieldlist != null ) { return fieldlist ; } else { collection < field > result ; result = sizeoffilter . filterfields ( refclass , getallfields ( refclass ) ) ; if ( use_verbose_debug_logging && log . isdebugenabled ( ) ) { for ( field field : result ) { if ( modifier . istransient ( field . getmodifiers ( ) ) ) { log . debug ( str_ , field . getname ( ) , refclass . getname ( ) ) ; } } } fieldcache . put ( refclass , new softreference < > ( result ) ) ; return result ; } }	Returns the filtered fields for a particular type.
private static collection < field > getallfields ( class < ? > refclass ) { collection < field > fields = new arraylist < > ( ) ; for ( class < ? > klazz = refclass ; klazz != null ; klazz = klazz . getsuperclass ( ) ) { for ( field field : klazz . getdeclaredfields ( ) ) { if ( ! modifier . isstatic ( field . getmodifiers ( ) ) && ! field . gettype ( ) . isprimitive ( ) ) { try { field . setaccessible ( bool_ ) ; } catch ( securityexception e ) { log . error ( str_ + str_ , field , e ) ; continue ; } fields . add ( field ) ; } } } return fields ; }	Returns all non-primitive fields for the entire class hierarchy of a type.
public v put ( k key , v value ) { cleanup ( ) ; return map . put ( new identityweakreference < > ( key , queue ) , value ) ; }	Puts into the underlying.
public v remove ( k key ) { cleanup ( ) ; return map . remove ( new identityweakreference < > ( key , queue ) ) ; }	Remove from the underlying.
static boolean loadagent ( ) { synchronized ( agentloader . class . getname ( ) . intern ( ) ) { if ( ! agentisavailable ( ) && virtual_machine_load_agent != null ) { try { warnifosx ( ) ; string name = managementfactory . getruntimemxbean ( ) . getname ( ) ; object vm = virtual_machine_attach . invoke ( null , name . substring ( num_ , name . indexof ( str_ ) ) ) ; try { file agent = getagentfile ( ) ; logger . info ( str_ , agent ) ; if ( agent != null ) { virtual_machine_load_agent . invoke ( vm , agent . getabsolutepath ( ) ) ; } } finally { virtual_machine_detach . invoke ( vm ) ; } } catch ( invocationtargetexception ite ) { throwable cause = ite . getcause ( ) ; logger . info ( str_ , cause . getclass ( ) , cause . getmessage ( ) ) ; } catch ( throwable t ) { logger . info ( str_ , t . getclass ( ) , t . getmessage ( ) ) ; } } final boolean b = agentisavailable ( ) ; if ( b ) { logger . info ( str_ ) ; } return b ; } }	Attempts to load the agent through the Attach API.
static boolean agentisavailable ( ) { try { if ( instrumentation == null ) { instrumentation = ( instrumentation ) system . getproperties ( ) . get ( instrumentation_instance_system_property_name ) ; } if ( instrumentation == null ) { class < ? > sizeofagentclass = classloader . getsystemclassloader ( ) . loadclass ( sizeof_agent_classname ) ; method getinstrumentationmethod = sizeofagentclass . getmethod ( str_ ) ; instrumentation = ( instrumentation ) getinstrumentationmethod . invoke ( sizeofagentclass ) ; } return instrumentation != null ; } catch ( securityexception e ) { logger . warn ( str_ + str_ + str_ + str_ + str_ ) ; return bool_ ; } catch ( throwable e ) { return bool_ ; } }	Checks whether the agent is available.
public static void copyfile ( plexusioresource in , file outfile ) throws ioexception { inputstream input = null ; outputstream output = null ; try { input = in . getcontents ( ) ; output = new fileoutputstream ( outfile ) ; ioutil . copy ( input , output ) ; } finally { ioutil . close ( input ) ; ioutil . close ( output ) ; } }	Copies the sources contents to the given destination file.
public static boolean issame ( plexusioresource resource , file file ) { if ( resource instanceof filesupplier ) { file resourcefile = ( ( filesupplier ) resource ) . getfile ( ) ; return file . equals ( resourcefile ) ; } return bool_ ; }	Checks, whether the resource and the file are identical.
public void addwebinf ( file directoryname , string [ ] includes , string [ ] excludes ) throws archiverexception { adddirectory ( directoryname , str_ , includes , excludes ) ; }	files to add under WEB-INF;.
protected void initzipoutputstream ( ziparchiveoutputstream zout ) throws archiverexception , ioexception {	override of parent; validates configurationbefore initializing the output stream.
protected void zipfile ( archiveentry entry , ziparchiveoutputstream zout , string vpath ) throws ioexception , archiverexception {	Overridden from ZipArchiver class to deal with web.xml.
public static manifest getdefaultmanifest ( ) throws archiverexception { try { string defmanifest = str_ ; inputstream in = manifest . class . getresourceasstream ( defmanifest ) ; if ( in == null ) { throw new archiverexception ( str_ + defmanifest ) ; } try { manifest defaultmanifest = new manifest ( new inputstreamreader ( in , str_ ) ) ; defaultmanifest . getmainattributes ( ) . putvalue ( str_ , system . getproperty ( str_ ) + str_ + system . getproperty ( str_ ) + str_ ) ; return defaultmanifest ; } catch ( unsupportedencodingexception e ) { return new manifest ( new inputstreamreader ( in ) ) ; } finally { ioutil . close ( in ) ; } } catch ( manifestexception e ) { throw new archiverexception ( str_ , e ) ; } catch ( ioexception e ) { throw new archiverexception ( str_ , e ) ; } }	Construct a manifest from Ant's default manifest file.
public void addconfiguredsection ( section section ) throws manifestexception { string sectionname = section . getname ( ) ; if ( sectionname == null ) { throw new manifestexception ( str_ ) ; } attributes attributes = getorcreateattributes ( sectionname ) ; for ( string s : section . attributes . keyset ( ) ) { attribute attribute = section . getattribute ( s ) ; attributes . putvalue ( attribute . getname ( ) , attribute . getvalue ( ) ) ; } }	Add a section to the manifest.
public void write ( printwriter writer ) throws ioexception { bytearrayoutputstream bytearrayoutputstream = new bytearrayoutputstream ( ) ; super . write ( bytearrayoutputstream ) ; for ( byte b : bytearrayoutputstream . tobytearray ( ) ) { writer . write ( ( char ) b ) ; } }	Write the manifest out to a print writer.
enumeration < string > getwarnings ( ) { vector < string > warnings = new vector < string > ( ) ; enumeration < string > warnenum = mainsection . getwarnings ( ) ; while ( warnenum . hasmoreelements ( ) ) { warnings . addelement ( warnenum . nextelement ( ) ) ; } return warnings . elements ( ) ; }	Get the warnings for this manifest.
public existingsection getsection ( string name ) { attributes attributes = getattributes ( name ) ; if ( attributes != null ) { return new existingsection ( attributes , name ) ; } return null ; }	Get a particular section from the manifest.
protected void copyfile ( final archiveentry entry , final string vpath ) throws archiverexception , ioexception {	Copies the specified file to the specified path, creating any ancestor directory structure as necessary.
public void addconfiguredmanifest ( manifest newmanifest ) throws manifestexception { if ( configuredmanifest == null ) { configuredmanifest = newmanifest ; } else { jdkmanifestfactory . merge ( configuredmanifest , newmanifest , bool_ ) ; } savedconfiguredmanifest = configuredmanifest ; }	Allows the manifest for the archive file to be provided inlinein the build file rather than in an external file.
protected void zipfile ( inputstream is , ziparchiveoutputstream zout , string vpath , long lastmodified , file fromarchive , int mode , string symlinkdestination ) throws ioexception , archiverexception { if ( manifest_name . equalsignorecase ( vpath ) ) { if ( ! doublefilepass || skipwriting ) { filesetmanifest ( fromarchive , is ) ; } } else if ( index_name . equalsignorecase ( vpath ) && index ) { getlogger ( ) . warn ( str_ + archivetype + str_ + str_ ) ; } else { if ( index && ( ! vpath . contains ( str_ ) ) ) { rootentries . addelement ( vpath ) ; } super . zipfile ( is , zout , vpath , lastmodified , fromarchive , mode , symlinkdestination ) ; } }	Overridden from Zip class to deal with manifests and index lists.
protected void cleanup ( ) throws ioexception { super . cleanup ( ) ;	Make sure we don't think we already have a MANIFEST next time this taskgets executed.
public void reset ( ) { super . reset ( ) ; configuredmanifest = null ; filesetmanifestconfig = null ; mergemanifestsmain = bool_ ; manifestfile = null ; index = bool_ ; }	reset to default values.
protected final void writeindexlikelist ( list < string > dirs , list < string > files , printwriter writer ) {	Writes the directory entries from the first and the filenamesfrom the second list to the given writer, one entry per line.
protected static void grabfilesanddirs ( string file , list < string > dirs , list < string > files ) throws ioexception { file zipfile = new file ( file ) ; if ( ! zipfile . exists ( ) ) { logger logger = new consolelogger ( logger . level_info , str_ ) ; logger . error ( str_ + zipfile . getabsolutepath ( ) ) ; } else if ( zipfile . isdirectory ( ) ) { logger logger = new consolelogger ( logger . level_info , str_ ) ; logger . info ( str_ + zipfile + str_ ) ; } else { org . apache . commons . compress . archivers . zip . zipfile zf = null ; try { zf = new org . apache . commons . compress . archivers . zip . zipfile ( file , str_ ) ; enumeration < ziparchiveentry > entries = zf . getentries ( ) ; hashset < string > dirset = new hashset < string > ( ) ; while ( entries . hasmoreelements ( ) ) { ziparchiveentry ze = entries . nextelement ( ) ; string name = ze . getname ( ) ;	Grab lists of all root-level files and all directoriescontained in the given archive.
private inputstream decompress ( untarcompressionmethod compression , final file file , final inputstream istream ) throws ioexception , archiverexception { if ( compression == untarcompressionmethod . gzip ) { return new gzipinputstream ( istream ) ; } else if ( compression == untarcompressionmethod . bzip2 ) { return new bzip2compressorinputstream ( istream ) ; } else if ( compression == untarcompressionmethod . snappy ) { return new snappyinputstream ( istream ) ; } return istream ; }	This method wraps the input stream with thecorresponding decompression method.
public void compress ( ) throws archiverexception { try { zout = new gzipoutputstream ( streams . bufferedoutputstream ( new fileoutputstream ( getdestfile ( ) ) ) ) ; compress ( getsource ( ) , zout ) ; } catch ( ioexception ioe ) { string msg = str_ + ioe . getmessage ( ) ; throw new archiverexception ( msg , ioe ) ; } }	perform the GZip compression operation.
public static void mergeattributes ( java . util . jar . attributes target , java . util . jar . attributes section ) { for ( object o : section . keyset ( ) ) { java . util . jar . attributes . name key = ( attributes . name ) o ; final object value = section . get ( o ) ;	Merge in another section.
public void setappxml ( file descr ) throws archiverexception { deploymentdescriptor = descr ; if ( ! deploymentdescriptor . exists ( ) ) { throw new archiverexception ( str_ + deploymentdescriptor + str_ ) ; } addfile ( descr , str_ ) ; }	File to incorporate as application.xml.
public void compress ( ) throws archiverexception { try { zout = new snappyoutputstream ( bufferedoutputstream ( fileoutputstream ( getdestfile ( ) ) ) ) ; compress ( getsource ( ) , zout ) ; } catch ( ioexception ioe ) { string msg = str_ + ioe . getmessage ( ) ; throw new archiverexception ( msg , ioe ) ; } }	perform the Snappy compression operation.
@ suppresswarnings ( { str_ } ) protected final void addresources ( resourceiterator resources , ziparchiveoutputstream zout ) throws ioexception , archiverexception { file base = null ; while ( resources . hasnext ( ) ) { archiveentry entry = resources . next ( ) ; string name = entry . getname ( ) ; name = name . replace ( file . separatorchar , str_ ) ; if ( str_ . equals ( name ) ) { continue ; } if ( entry . getresource ( ) . isdirectory ( ) && ! name . endswith ( str_ ) ) { name = name + str_ ; } addparentdirs ( entry , base , name , zout , str_ ) ; if ( entry . getresource ( ) . isfile ( ) ) { zipfile ( entry , zout , name ) ; } else { zipdir ( entry . getresource ( ) , zout , name , entry . getmode ( ) ) ; } } }	Add the given resources.
@ suppresswarnings ( { str_ } ) private void addparentdirs ( archiveentry archiveentry , file basedir , string entry , ziparchiveoutputstream zout , string prefix ) throws ioexception { if ( ! dofilesonly && getincludeemptydirs ( ) ) { stack < string > directories = new stack < string > ( ) ;	Ensure all parent dirs of a given entry have been added.This method is computed in terms of the potentially remapped entry (that may be disconnected from the file system)we do not *relly* know the entry's connection to the file system so establishing the attributes of the parents canbe impossible and is not really supported.
@ suppresswarnings ( { str_ } ) protected boolean createemptyzip ( file zipfile ) throws archiverexception {	Create an empty zip file.
public void reset ( ) { setdestfile ( null ) ;	Makes this instance reset all attributes to their defaultvalues and forget all children.
private void compressfile ( inputstream in , outputstream zout ) throws ioexception { byte [ ] buffer = new byte [ num_ * num_ ] ; int count = num_ ; do { zout . write ( buffer , num_ , count ) ; count = in . read ( buffer , num_ , buffer . length ) ; } while ( count != - num_ ) ; }	compress a stream to an output stream.
protected void compress ( plexusioresource resource , outputstream zout ) throws ioexception { inputstream in = streams . bufferedinputstream ( resource . getcontents ( ) ) ; try { compressfile ( in , zout ) ; } finally { ioutil . close ( in ) ; } }	compress a resource to an output stream.
public void setmaxheadertablesize ( int maxheadertablesize ) { maxdynamictablesize = maxheadertablesize ; if ( maxdynamictablesize < encodermaxdynamictablesize ) {	Set the maximum table size.If this is below the maximum size of the dynamic table used by the encoder,the beginning of the next header block MUST signal this change.
private static int decodeule128 ( inputstream in ) throws ioexception { in . mark ( num_ ) ; int result = num_ ; int shift = num_ ; while ( shift < num_ ) { if ( in . available ( ) == num_ ) {	Unsigned Little Endian Base 128 Variable-Length Integer Encoding.
static int getindex ( byte [ ] name ) { string namestring = new string ( name , num_ , name . length , iso_8859_1 ) ; integer index = static_index_by_name . get ( namestring ) ; if ( index == null ) { return - num_ ; } return index ; }	Returns the lowest index value for the given header field name in the static table.Returns -1 if the header field name is not in the static table.
static int getindex ( byte [ ] name , byte [ ] value ) { int index = getindex ( name ) ; if ( index == - num_ ) { return - num_ ; }	Returns the index value for the given header field in the static table.Returns -1 if the header field is not in the static table.
private static map < string , integer > createmap ( ) { int length = static_table . size ( ) ; hashmap < string , integer > ret = new hashmap < string , integer > ( length ) ;	create a map of header name to index value to allow quick lookup.
public int getencodedlength ( byte [ ] data ) { if ( data == null ) { throw new nullpointerexception ( str_ ) ; } long len = num_ ; for ( byte b : data ) { len += lengths [ b & num_ ] ; } return ( int ) ( ( len + num_ ) > > num_ ) ; }	Returns the number of bytes required to Huffman encode the input string literal.
public int length ( ) { int length ; if ( head < tail ) { length = headerfields . length - tail + head ; } else { length = head - tail ; } return length ; }	Return the number of header fields in the dynamic table.
public void add ( headerfield header ) { int headersize = header . size ( ) ; if ( headersize > capacity ) { clear ( ) ; return ; } while ( size + headersize > capacity ) { remove ( ) ; } headerfields [ head ++ ] = header ; size += header . size ( ) ; if ( head == headerfields . length ) { head = num_ ; } }	Add the header field to the dynamic table.Entries are evicted from the dynamic table until the size of the tableand the new header field is less than or equal to the table's capacity.If the size of the new entry is larger than the table's capacity,the dynamic table will be cleared.
public void setcapacity ( int capacity ) { if ( capacity < num_ ) { throw new illegalargumentexception ( str_ + capacity ) ; }	Set the maximum size of the dynamic table.Entries are evicted from the dynamic table until the size of the tableis less than or equal to the maximum size.
public void encodeheader ( outputstream out , byte [ ] name , byte [ ] value , boolean sensitive ) throws ioexception {	Encode the header field into the header block.
public void setmaxheadertablesize ( outputstream out , int maxheadertablesize ) throws ioexception { if ( maxheadertablesize < num_ ) { throw new illegalargumentexception ( str_ + maxheadertablesize ) ; } if ( capacity == maxheadertablesize ) { return ; } capacity = maxheadertablesize ; ensurecapacity ( num_ ) ; encodeinteger ( out , num_ , num_ , maxheadertablesize ) ; }	Set the maximum table size.
private static void encodeinteger ( outputstream out , int mask , int n , int i ) throws ioexception { if ( n < num_ || n > num_ ) { throw new illegalargumentexception ( str_ + n ) ; } int nbits = num_ > > > ( num_ - n ) ; if ( i < nbits ) { out . write ( mask | i ) ; } else { out . write ( mask | nbits ) ; int length = i - nbits ; while ( bool_ ) { if ( ( length & ~ num_ ) == num_ ) { out . write ( length ) ; return ; } else { out . write ( ( length & num_ ) | num_ ) ; length >>>= num_ ; } } } }	Encode integer according to Section 5.1.
private void encodestringliteral ( outputstream out , byte [ ] string ) throws ioexception { int huffmanlength = huffman . encoder . getencodedlength ( string ) ; if ( ( huffmanlength < string . length && ! forcehuffmanoff ) || forcehuffmanon ) { encodeinteger ( out , num_ , num_ , huffmanlength ) ; huffman . encoder . encode ( out , string ) ; } else { encodeinteger ( out , num_ , num_ , string . length ) ; out . write ( string , num_ , string . length ) ; } }	Encode string literal according to Section 5.2.
private void encodeliteral ( outputstream out , byte [ ] name , byte [ ] value , indextype indextype , int nameindex ) throws ioexception { int mask ; int prefixbits ; switch ( indextype ) { case incremental : mask = num_ ; prefixbits = num_ ; break ; case none : mask = num_ ; prefixbits = num_ ; break ; case never : mask = num_ ; prefixbits = num_ ; break ; default : throw new illegalstateexception ( str_ ) ; } encodeinteger ( out , mask , prefixbits , nameindex == - num_ ? num_ : nameindex ) ; if ( nameindex == - num_ ) { encodestringliteral ( out , name ) ; } encodestringliteral ( out , value ) ; }	Encode literal header field according to Section 6.2.
private void ensurecapacity ( int headersize ) throws ioexception { while ( size + headersize > capacity ) { int index = length ( ) ; if ( index == num_ ) { break ; } remove ( ) ; } }	Ensure that the dynamic table has enough room to hold 'headerSize' more bytes.Removes the oldest entry from the dynamic table until sufficient space is available.
headerfield getheaderfield ( int index ) { headerentry entry = head ; while ( index -- >= num_ ) { entry = entry . before ; } return entry ; }	Return the header field at the given index.Exposed for testing.
private headerentry getentry ( byte [ ] name , byte [ ] value ) { if ( length ( ) == num_ || name == null || value == null ) { return null ; } int h = hash ( name ) ; int i = index ( h ) ; for ( headerentry e = headerfields [ i ] ; e != null ; e = e . next ) { if ( e . hash == h && hpackutil . equals ( name , e . name ) && hpackutil . equals ( value , e . value ) ) { return e ; } } return null ; }	Returns the header entry with the lowest index value for the header field.Returns null if header field is not in the dynamic table.
private int getindex ( byte [ ] name ) { if ( length ( ) == num_ || name == null ) { return - num_ ; } int h = hash ( name ) ; int i = index ( h ) ; int index = - num_ ; for ( headerentry e = headerfields [ i ] ; e != null ; e = e . next ) { if ( e . hash == h && hpackutil . equals ( name , e . name ) ) { index = e . index ; break ; } } return getindex ( index ) ; }	Returns the lowest index value for the header field name in the dynamic table.Returns -1 if the header field name is not in the dynamic table.
private void add ( byte [ ] name , byte [ ] value ) { int headersize = headerfield . sizeof ( name , value ) ;	Add the header field to the dynamic table.Entries are evicted from the dynamic table until the size of the tableand the new header field is less than the table's capacity.If the size of the new entry is larger than the table's capacity,the dynamic table will be cleared.
private static int hash ( byte [ ] name ) { int h = num_ ; for ( int i = num_ ; i < name . length ; i ++ ) { h = num_ * h + name [ i ] ; } if ( h > num_ ) { return h ; } else if ( h == integer . min_value ) { return integer . max_value ; } else { return - h ; } }	Returns the hash code for the given header field name.
public byte [ ] decode ( byte [ ] buf ) throws ioexception { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; node node = root ; int current = num_ ; int bits = num_ ; for ( int i = num_ ; i < buf . length ; i ++ ) { int b = buf [ i ] & num_ ; current = ( current << num_ ) | b ; bits += num_ ; while ( bits >= num_ ) { int c = ( current > > > ( bits - num_ ) ) & num_ ; node = node . children [ c ] ; bits -= node . bits ; if ( node . isterminal ( ) ) { if ( node . symbol == hpackutil . huffman_eos ) { throw eos_decoded ; } baos . write ( node . symbol ) ; node = root ; } } } while ( bits > num_ ) { int c = ( current << ( num_ - bits ) ) & num_ ; node = node . children [ c ] ; if ( node . isterminal ( ) && node . bits <= bits ) { bits -= node . bits ; baos . write ( node . symbol ) ; node = root ; } else { break ; } }	Decompresses the given Huffman coded string literal.
public void setdefaultscriptnames ( string scriptnames ) { if ( ! scriptnames . trim ( ) . isempty ( ) ) service . setdefaultscripts ( aslist ( scriptnames . split ( str_ ) ) ) ; }	Set the comma delimited list of default scripts.
public void assertequalto ( description description , short actual , short expected ) { assertnotnull ( description , actual ) ; if ( ! isequalto ( actual , expected ) ) { throw failures . failure ( description , shouldbeequal ( actual , expected ) ) ; } }	Verifies that two shorts are equal.
public void assertnotequalto ( description description , short actual , short expected ) { assertnotnull ( description , actual ) ; if ( isequalto ( actual , expected ) ) { throw failures . failure ( description , shouldnotbeequal ( actual , expected ) ) ; } }	Verifies that two integers are not equal.
public void assertgreaterthan ( description description , short actual , short expected ) { assertnotnull ( description , actual ) ; if ( ! isgreaterthan ( actual , expected ) ) { throw failures . failure ( description , shouldbegreaterthan . shouldbegreaterthan ( actual , expected ) ) ; } }	Verifies that the actual value is greater than the expected one.
public void assertgreaterthan ( description description , float actual , float expected ) { assertnotnull ( description , actual ) ; if ( ! isgreaterthan ( actual , expected ) ) { throw failures . failure ( description , shouldbegreaterthan ( actual , expected ) ) ; } }	Verifies that the actual value is great than the expected one.
public void assertequal ( description description , character actual , char expected ) { assertnotnull ( description , actual ) ; if ( actual . charvalue ( ) != expected ) { throw failures . failure ( description , shouldbeequal ( actual , expected ) ) ; } }	Asserts that two characters are equal.
public void assertnotequal ( description description , character actual , char other ) { assertnotnull ( description , actual ) ; if ( actual . charvalue ( ) == other ) { throw failures . failure ( description , shouldnotbeequal ( actual , other ) ) ; } }	Asserts that two characters are not equal.
public void assertlessthan ( description description , character actual , char other ) { assertnotnull ( description , actual ) ; if ( ! islessthan ( actual , other ) ) { throw failures . failure ( description , shouldbelessthan ( actual , other ) ) ; } }	Asserts that the actual value is less than the other one.
public void assertnotgreaterthan ( description description , character actual , char other ) { assertnotnull ( description , actual ) ; if ( isgreaterthan ( actual , other ) ) { throw failures . failure ( description , shouldnotbegreaterthan ( actual , other ) ) ; } }	Asserts that the actual value is less than or equal to the other one.
public void assertgreaterthan ( description description , character actual , char other ) { assertnotnull ( description , actual ) ; if ( ! isgreaterthan ( actual , other ) ) { throw failures . failure ( description , shouldbegreaterthan ( actual , other ) ) ; } }	Asserts that the actual value is greater than the other one.
public void assertnotlessthan ( description description , character actual , char other ) { assertnotnull ( description , actual ) ; if ( islessthan ( actual , other ) ) { throw failures . failure ( description , shouldnotbelessthan . shouldnotbelessthan ( actual , other ) ) ; } }	Asserts that the actual value is greater than or equal to the other one.
public void assertlowercase ( description description , character actual ) { assertnotnull ( description , actual ) ; if ( ! islowercase ( actual ) ) { throw failures . failure ( description , shouldbelowercase ( actual ) ) ; } }	Asserts that the actual value is a lowercase character.
public void assertuppercase ( description description , character actual ) { assertnotnull ( description , actual ) ; if ( ! isuppercase ( actual ) ) { throw failures . failure ( description , shouldbeuppercase ( actual ) ) ; } }	Asserts that the actual value is a uppercase character.
public void asserthassize ( description description , int [ ] actual , int expectedsize ) { arrays . asserthassize ( description , actual , expectedsize ) ; }	Asserts that the number of elements in the given array is equal to the expected one.
public void assertcontains ( description description , int [ ] actual , int [ ] values ) { arrays . assertcontains ( description , actual , values ) ; }	Asserts that the given array contains the given values, in any order.
public < k > void assertcontainskey ( description description , map < ? , ? > actual , k key ) { assertnotnull ( description , actual ) ; if ( ! actual . containskey ( key ) ) { throw failures . failure ( description , shouldcontainkey ( actual , key ) ) ; } }	Asserts that the actual map contain the given key.
public < k > void assertdoesnotcontainkey ( description description , map < ? , ? > actual , k key ) { assertnotnull ( description , actual ) ; if ( actual . containskey ( key ) ) { throw failures . failure ( description , shouldnotcontainkey ( actual , key ) ) ; } }	Asserts that the actual map not contains the given key.
public < v > void assertcontainsvalue ( description description , map < ? , ? > actual , v value ) { assertnotnull ( description , actual ) ; if ( ! actual . containsvalue ( value ) ) { throw failures . failure ( description , shouldcontainvalue ( actual , value ) ) ; } }	Asserts that the actual map contain the given value.
public < v > void assertdoesnotcontainvalue ( description description , map < ? , ? > actual , v value ) { assertnotnull ( description , actual ) ; if ( actual . containsvalue ( value ) ) { throw failures . failure ( description , shouldnotcontainvalue ( actual , value ) ) ; } }	Asserts that the actual map does not contain the given value.
public < k , v > void assertdoesnotcontainduplicatevalues ( description description , map < k , v > actual ) { assertnotnull ( description , actual ) ; collection < ? > duplicates = duplicatesfrom ( actual . values ( ) ) ; if ( ! duplicates . isempty ( ) ) { throw failures . failure ( description , shouldnothaveduplicates ( actual , duplicates ) ) ; } }	Asserts that the actual map does not contain the duplicate values.
public void assertequal ( description description , bigdecimal actual , bigdecimal expected ) { checknumberisnotnull ( expected ) ; assertnotnull ( description , actual ) ; comparables . assertequal ( description , actual , expected ) ; }	Verifies that two BigDecimals are equal.
public void assertiszero ( description description , bigdecimal actual ) { comparables . assertequal ( description , actual , zero ) ; }	Verifies that the actual value is zero.
public void assertisnotzero ( description description , bigdecimal actual ) { comparables . assertnotequal ( description , actual , zero ) ; }	Verifies that the actual value is not zero.
public void assertispositive ( description description , bigdecimal actual ) { comparables . assertgreaterthan ( description , actual , zero ) ; }	Verifies that the actual value is positive.
public void assertisnegative ( description description , bigdecimal actual ) { comparables . assertlessthan ( description , actual , zero ) ; }	Verifies that the actual value is negative.
public floatassert isequalto ( float expected , offset < float > offset ) { floats . assertequal ( description , actual , expected , offset ) ; return this ; }	Verifies that the actual value is equal to the given one, within a positive offset.
public bytearrayassert contains ( byte value , index index ) { arrays . assertcontains ( description , actual , value , index ) ; return this ; }	Verifies that the given array contains the given value at the given index.
public void assertnotequal ( description description , double actual , double expected , offset < double > offset ) { checkoffsetisnotnull ( offset ) ; checknumberisnotnull ( expected ) ; assertnotnull ( description , actual ) ; if ( isequalto ( actual , expected , offset ) ) { throw failures . failure ( description , shouldnotbeequal ( actual , expected ) ) ; } }	Verifies that two doubles are not equal.
public void assertnotgreaterthan ( description description , double actual , double expected ) { assertnotnull ( description , actual ) ; if ( isgreaterthan ( actual , expected ) ) { throw failures . failure ( description , shouldnotbegreaterthan ( actual , expected ) ) ; } }	Verifies that the actual value is not greater than the expected.
public void assertlessthan ( description description , double actual , double expected ) { assertnotnull ( description , actual ) ; if ( ! islessthan ( actual , expected ) ) { throw failures . failure ( description , shouldbelessthan ( actual , expected ) ) ; } }	Verifies that the actual value is less than the expected.
public void assertnotlessthan ( description description , double actual , double expected ) { assertnotnull ( description , actual ) ; if ( islessthan ( actual , expected ) ) { throw failures . failure ( description , shouldnotbelessthan ( actual , expected ) ) ; } }	Verifies that the actual value is not less than the expected.
public void assertcontainsonly ( description description , byte [ ] actual , byte [ ] values ) { arrays . assertcontainsonly ( description , actual , values ) ; }	Asserts that the given array contains only the given values and nothing else, in any order.
public void assertcontainssequence ( description description , byte [ ] actual , byte [ ] sequence ) { arrays . assertcontainssequence ( description , actual , sequence ) ; }	Verifies that the given array contains the given sequence of values, without any other values between them.
public void assertequal ( description description , object actual , object expected ) { if ( ! areequal ( actual , expected ) ) { throw shouldbeequal ( actual , expected ) . newassertionerror ( description ) ; } }	Asserts that two objects are equal.
public void assertnotequal ( description description , object actual , object other ) { if ( areequal ( actual , other ) ) { throw failures . failure ( description , shouldnotbeequal ( actual , other ) ) ; } }	Asserts that two objects are not equal.
public void assertsame ( description description , object actual , object expected ) { if ( actual != expected ) { string format = str_ ; throw failures . failure ( description , new basicerrormessagefactory ( format , expected , actual ) ) ; } }	Asserts that two objects refer to the same instance.
public void assertnotsame ( description description , object actual , object other ) { if ( actual == other ) { string format = str_ ; throw failures . failure ( description , new basicerrormessagefactory ( format , actual ) ) ; } }	Asserts that two objects do not refer to the same instance.
public void assertdoesnotcontain ( description description , char [ ] actual , char [ ] values ) { arrays . assertdoesnotcontain ( description , actual , values ) ; }	Asserts that the given array does not contain the given values.
public void assertissorted ( description description , char [ ] actual ) { if ( actual == null ) { throw failures . failure ( str_ ) ; } if ( actual . length == num_ ) { return ; } for ( int i = num_ ; i < actual . length - num_ ; i ++ ) { if ( actual [ i ] > actual [ i + num_ ] ) { throw failures . failure ( description , shouldbesorted ( i , actual ) ) ; } } }	Verifies that the actual is sorted into ascending order according to the natural ordering of its elements.Empty arrays are considered sorted.
@ factory public static < t > matcher < t > named ( string name , matcher < t > matcher ) { return describedas ( str_ , matcher , name , matcher ) ; }	Wraps an existing matcher, decorating its description with the name specified.
@ factory public static matcher < string > notemptystring ( ) { return new customtypesafematcher < string > ( str_ ) { @ override protected boolean matchessafely ( string s ) { return ! s . isempty ( ) ; } } ; }	A matcher matching non-null and non-empty stringsExample: assertThat("this is not an empty string", notEmptyString()) .
static string getmiddlenameforprefixingasaccessormutatorjavabeansspeccompliance ( string fieldname ) { if ( fieldname . length ( ) > num_ && character . isuppercase ( fieldname . charat ( num_ ) ) ) { return fieldname ; } return fieldname . substring ( num_ , num_ ) . touppercase ( ) + fieldname . substring ( num_ ) ; }	Get the middle part of the method name in compliance with the naming convention in the JavaBeans APIspecification.
private boolean exists ( jclasstype type , jfield field , string fieldname , boolean issetter ) { if ( field instanceof dummyjfield ) { return bool_ ; } jtype [ ] args ; if ( issetter ) { args = new jtype [ ] { field . gettype ( ) } ; } else { args = new jtype [ ] { } ; } jmethod m = type . findmethod ( fieldname , args ) ; if ( null != m ) { if ( isignored ( m ) ) { return bool_ ; } if ( issetter ) { return bool_ ; } jclasstype returntype = m . getreturntype ( ) . isclassorinterface ( ) ; jclasstype fieldtype = field . gettype ( ) . isclassorinterface ( ) ; if ( returntype == null || fieldtype == null ) {	checks whether a getter or setter exists on the specified type or any ofits super classes excluding Object.
public static list < annotationresolver > getannotationresolvers ( generatorcontext context , treelogger logger ) {	access all annotationresolvers that are registered.
public method expect ( int ... statuses ) { if ( statuses . length == num_ && statuses [ num_ ] < num_ ) { anystatus = bool_ ; } else { anystatus = bool_ ; expectedstatuses . clear ( ) ; for ( int status : statuses ) { expectedstatuses . add ( status ) ; } } return this ; }	sets the expected response status code.
private string reducename ( string newclassname , string suffix ) { if ( newclassname . length ( ) < max_file_name_length ) { return newclassname ; }	Lets have class name less than 200 to allow new generators safelly to add more sufixes there if needed.
protected static boolean getbooleanproperty ( treelogger logger , propertyoracle propertyoracle , string propertyname , boolean defaultvalue ) { try { selectionproperty prop = propertyoracle . getselectionproperty ( logger , propertyname ) ; string propval = prop . getcurrentvalue ( ) ; return boolean . parseboolean ( propval ) ; } catch ( badpropertyvalueexception e ) {	Returns the boolean value of the property or the default value.
@ override public requestcallback filter ( method method , response response , requestcallback callback ) { int code = response . getstatuscode ( ) ; final cachekey ck = cachekey ( method . builder ) ; final list < requestcallback > removedcallbacks = cache . removecallbacks ( ck ) ; if ( removedcallbacks != null ) { callback = new requestcallback ( ) { @ override public void onresponsereceived ( request request , response response ) { if ( gwt . isclient ( ) && logconfiguration . loggingisenabled ( ) ) { logger . getlogger ( cachingcallbackfilter . class . getname ( ) ) . finer ( str_ + removedcallbacks . size ( ) + str_ + ck ) ; }	the real filter method, called independent of the response codeTODO method.getResponse() is not equal to response.
@ suppresswarnings ( str_ ) private string [ ] getannotationsasstringarray ( class [ ] classes ) { if ( null == classes ) { return null ; } list < string > ret = new arraylist < string > ( ) ; for ( class c : classes ) { ret . add ( c . getname ( ) ) ; } return ret . toarray ( new string [ ret . size ( ) ] ) ; }	convert an array of classes to an array of strings to be usable in js context.
public object send ( asynccallback < javascriptobject > callback ) { return jsonpbuilder . requestobject ( resource . geturi ( ) , callback ) ; }	helper method to make RestServiceClassCreator easier to maintain.
private response process ( multivaluedmap < string , string > parameters , string clientid , string clientsecret , string [ ] clientcertificatepath ) {	Process the parameters of the token request.
private response handlepassword ( tokenresponse response ) {	Process the token request whose flow is "Resource Owner Password Credentials".
private response process ( string ticket , string [ ] claimnames , string [ ] claimlocales ) {	Process the end-user's decision.
private map < string , object > collectclaims ( string subject , string [ ] claimnames , string [ ] claimlocales ) {	Collect claims of the end-user.
public response userinfoissue ( string accesstoken , map < string , object > claims ) {	Issue a JSON or a JWT containing user information.
private static string computeloginid ( authorizationresponse info ) { if ( info . getsubject ( ) != null ) { return info . getsubject ( ) ; } return info . getloginhint ( ) ; }	Compute the initial value for the login ID field in theauthorization page.
private string createserviceownercredentials ( authleteconfiguration configuration ) { if ( configuration . getserviceowneraccesstoken ( ) != null ) { return str_ + configuration . getserviceowneraccesstoken ( ) ; } else { string key = configuration . getserviceownerapikey ( ) ; string secret = configuration . getserviceownerapisecret ( ) ; return new basiccredentials ( key , secret ) . format ( ) ; } }	Create an authorization header for the service owner.
private string createservicecredentials ( authleteconfiguration configuration ) { if ( configuration . getserviceaccesstoken ( ) != null ) { return str_ + configuration . getserviceaccesstoken ( ) ; } else { string key = configuration . getserviceapikey ( ) ; string secret = configuration . getserviceapisecret ( ) ; return new basiccredentials ( key , secret ) . format ( ) ; } }	Create an authorization header for the service.
private javax . ws . rs . client . client getjaxrsclient ( ) {	Get an instance of JAX-RS client.
private javax . ws . rs . client . client createjaxrsclient ( ) { if ( getjaxrsclientbuilder ( ) != null ) {	Create an instance of JAX-RS client.
private void setconnectiontimeout ( javax . ws . rs . client . client client ) {	Set a connection timeout.
private void setreadtimeout ( javax . ws . rs . client . client client ) {	Set a read timeout.
private < tresponse > tresponse executeapicall ( authleteapicall < tresponse > apicall ) throws authleteapiexception { try {	Execute an Authlete API call.
private response process ( multivaluedmap < string , string > parameters ) {	Process the parameters of the introspection request.
private response process ( string accesstoken ) {	Process the userinfo request with the access token.
private response process ( multivaluedmap < string , string > parameters ) {	Process the authorization request.
private void nointeractioncheckauthentication ( authorizationresponse response ) {	Check whether an end-user has already logged in or not.
private response process ( multivaluedmap < string , string > parameters , string clientid , string clientsecret ) {	Process the parameters of the revocation request.
protected string extractclientcertificate ( httpservletrequest request ) { string [ ] certs = extractclientcertificatechain ( request ) ; if ( certs != null && certs . length > num_ ) { return certs [ num_ ] ; } else { return null ; } }	Utility method for extracting a single client certificate from the defaultcertificate extractors.
public void updateimpliedstores ( @ observes final artifactstorepreupdateevent event ) { if ( ! storemanager . isstarted ( ) ) { return ; } if ( ! config . isenabled ( ) ) { logger . debug ( str_ ) ; return ; } try {	We cannot currently remove formerly implied repos because we can't distinguish between the above states.
public static x509certificate generatex509certificate ( keypair pair , string dn , int days , string algorithm ) throws generalsecurityexception , ioexception { privatekey privatekey = pair . getprivate ( ) ; x509certinfo info = new x509certinfo ( ) ; date from = new date ( ) ; date to = new date ( from . gettime ( ) + timeunit . days . tomillis ( days ) ) ; certificatevalidity interval = new certificatevalidity ( from , to ) ; biginteger sn = new biginteger ( num_ , new securerandom ( ) ) ; x500name owner = new x500name ( dn ) ; info . set ( x509certinfo . validity , interval ) ; info . set ( x509certinfo . serial_number , new certificateserialnumber ( sn ) ) ; info . set ( x509certinfo . subject , owner ) ; info . set ( x509certinfo . issuer , owner ) ; info . set ( x509certinfo . key , new certificatex509key ( pair . getpublic ( ) ) ) ; info . set ( x509certinfo . version , new certificateversion ( certificateversion . v3 ) ) ; algorithmid algo = new algorithmid ( algorithmid . sha256withrsaencryption_oid ) ; info . set ( x509certinfo . algorithm_id , new certificatealgorithmid ( algo ) ) ;	Create a self-signed X.509 cert.
public static string getname ( string nodeprefix , string name , string defaultname , string ... suffix ) { if ( isblank ( name ) || name . equals ( default ) ) { name = defaultname ; } return name ( name ( nodeprefix , name ) , suffix ) ; }	Get the metric fullname.
public transfer generaterelationshipfile ( transfer transfer , transferoperation op ) { final logger logger = loggerfactory . getlogger ( getclass ( ) ) ; if ( ! config . isenabled ( ) ) { logger . debug ( str_ ) ; return null ; } logger . debug ( str_ , transfer ) ; if ( transfer == null ) { logger . debug ( str_ ) ; return null ; } string txfrpath = transfer . getpath ( ) ; if ( ! txfrpath . endswith ( str_ ) ) { logger . debug ( str_ ) ; return null ; } artifactpathinfo artpathinfo = artifactpathinfo . parse ( txfrpath ) ; if ( artpathinfo == null ) { logger . debug ( str_ , txfrpath ) ; return null ; } concreteresource pomresource = transfer . getresource ( ) ; storekey storekey = storekey . fromstring ( transfer . getlocation ( ) . getname ( ) ) ; artifactstore store ; try { store = storemanager . getartifactstore ( storekey ) ; } catch ( final indydataexception ex ) { logger . error ( str_ + storekey , ex ) ; return null ; } logger . debug ( str_ , storekey , pomresource . getpath ( ) ) ; try { uri source = new uri ( pomresource . getlocation ( ) . geturi ( ) + rel_suffix ) ; projectversionref ref = artpathinfo . getprojectid ( ) ;	Generate relationship file for pom transfer.
public int commit ( ) throws gitsubsystemexception { int committed = lockand ( me -> { final int size = changelogentries . size ( ) ; if ( ! changelogentries . isempty ( ) ) { try { commitcommand commit = git . commit ( ) ; stringbuilder sb = new stringbuilder ( ) . append ( commit_changelog_entries + str_ ) ; for ( changelogentry et : changelogentries ) { sb . append ( et . getusername ( ) + str_ + et . gettimestamp ( ) + str_ + et . getmessage ( ) ) ; sb . append ( str_ ) ; } string message = sb . tostring ( ) ; logger . info ( message ) ; commit . setmessage ( message ) . setauthor ( system_user , email ) . call ( ) ; changelogentries . clear ( ) ; } catch ( final jgitinternalexception | gitapiexception e ) { throw new gitsubsystemexception ( str_ + e . getmessage ( ) , e ) ; } } return size ; } ) ; return committed ; }	Commit the changelog entries.
private void addsnapshotdataobject ( string key , snapshot snapshot , long clock , list < dataobject > dataobjectlist ) { dataobjectlist . add ( todataobject ( key , str_ , snapshot . getmin ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . getmax ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . getmean ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . getstddev ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . getmedian ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . get75thpercentile ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . get95thpercentile ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . get98thpercentile ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . get99thpercentile ( ) , clock ) ) ; dataobjectlist . add ( todataobject ( key , str_ , snapshot . get999thpercentile ( ) , clock ) ) ; }	for histograms.
private string getremoterepositoryname ( url url ) throws indydataexception { final string name = repocreator . formatid ( url . gethost ( ) , getport ( url ) , num_ , null , storetype . remote ) ; logger . debug ( str_ , name ) ; abstractproxyrepositorycreator abstractproxyrepositorycreator = null ; if ( repocreator instanceof abstractproxyrepositorycreator ) { abstractproxyrepositorycreator = ( abstractproxyrepositorycreator ) repocreator ; } if ( abstractproxyrepositorycreator == null ) { return name ; } predicate < artifactstore > filter = abstractproxyrepositorycreator . getnamefilter ( name ) ; list < string > l = storemanager . query ( ) . packagetype ( generic_pkg_key ) . storetype ( remoterepository . class ) . stream ( filter ) . map ( repository -> repository . getname ( ) ) . collect ( collectors . tolist ( ) ) ; if ( l . isempty ( ) ) { return name ; } return abstractproxyrepositorycreator . getnextname ( l ) ; }	if repo with this name already exists, we need to use a different name.
public string getnextname ( list < string > names ) { if ( names . isempty ( ) ) { return null ; } string name0 = names . get ( num_ ) ; if ( names . size ( ) == num_ ) { return name0 + str_ ; } collections . sort ( names ) ; string last = names . get ( names . size ( ) - num_ ) ; string index = last . substring ( last . lastindexof ( str_ ) + num_ ) ; return name0 + str_ + ( integer . parseint ( index ) + num_ ) ; }	Get the next distinct name based on the query result by filter of getNameFilter.
public void send ( string topic , string message , logbackformatter formatter ) throws ioexception { dokafkasend ( topic , message , formatter ) ; }	Non-blocking send with a logback formatter to format the message.
public void send ( string topic , string message , long timeoutmillis ) throws ioexception , interruptedexception , executionexception , timeoutexception { send ( topic , message , null , timeoutmillis ) ; }	Blocking send. The message will be available to consumers immediately. Wait for at most the given timefor the operation to complete.
public void send ( string topic , string message , logbackformatter formatter , long timeoutmillis ) throws ioexception , interruptedexception , executionexception , timeoutexception { future future = dokafkasend ( topic , message , formatter ) ; if ( future != null ) { future . get ( timeoutmillis , timeunit . milliseconds ) ; } }	Blocking send with a logback formatter to format the message.
public set < string > getcachenames ( ) { set < string > ret = new hashset < > ( ) ; if ( kojiconfig . isenabled ( ) && kojiconfig . isquerycacheenabled ( ) ) { ret . add ( koji_tags ) ; ret . add ( koji_build_info ) ; ret . add ( koji_build_info_containing_artifact ) ; ret . add ( koji_archives_for_build ) ; ret . add ( koji_archives_matching_ga ) ; } return ret ; }	This is to register ISPN caches produced by this provider so that the Metrics knows them.
public static void ziptrackedcontent ( file out , set < trackedcontent > sealed ) throws ioexception { logger . info ( str_ , out . getabsolutepath ( ) ) ; try ( zipoutputstream zip = new zipoutputstream ( new fileoutputstream ( out ) ) ) { for ( trackedcontent f : sealed ) { string name = sealed . getvalue ( ) + str_ + f . getkey ( ) . getid ( ) ; logger . trace ( str_ , name ) ; zip . putnextentry ( new zipentry ( name ) ) ; copy ( toinputstream ( f ) , zip ) ; } } }	Write sealed records to a zip file.
public static int readzipinputstreamand ( inputstream inputstream , consumer < trackedcontent > consumer ) throws ioexception , classnotfoundexception { int count = num_ ; try ( zipinputstream stream = new zipinputstream ( inputstream ) ) { zipentry entry ; while ( ( entry = stream . getnextentry ( ) ) != null ) { logger . trace ( str_ , entry . getname ( ) , entry . getsize ( ) ) ; bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; int len ; byte [ ] buffer = new byte [ num_ ] ; while ( ( len = stream . read ( buffer ) ) > num_ ) { bos . write ( buffer , num_ , len ) ; } bos . close ( ) ; objectinputstream ois = new objectinputstream ( new bytearrayinputstream ( bos . tobytearray ( ) ) ) ; trackedcontent record = ( trackedcontent ) ois . readobject ( ) ; consumer . accept ( record ) ; count ++ ; } } return count ; }	Read records from input stream and execute consumer function.
private storekey gettargetkey ( final string targetname ) { return targetgroupkeymap . computeifabsent ( targetname , k -> new storekey ( mavenpackagetypedescriptor . maven_pkg_key , storetype . group , targetname ) ) ; }	Provides target group store key for a given group name.
private void clearobsoletefiles ( transfer item ) { transfer httpmeta = item . getsiblingmeta ( http_metadata_ext ) ; try { httpmeta . delete ( ) ; } catch ( ioexception e ) { logger . warn ( str_ , httpmeta . getresource ( ) ) ; } }	Clear obsolete files after a meta is generated.
public string parse ( string reponame ) { string prefix = null ; if ( reponame . startswith ( koji_binary_ ) ) { prefix = koji_binary_ ; } else if ( reponame . startswith ( koji_ ) ) { prefix = koji_ ; } if ( prefix != null ) { return reponame . substring ( prefix . length ( ) ) ; } return null ; }	Retrieve what is behind koji- or koji-binary-.
@ apioperation ( str_ ) @ apiresponses ( { @ apiresponse ( code = num_ , message = str_ ) , @ apiresponse ( code = num_ , message = str_ ) } ) @ path ( str_ ) @ head public response exists ( final @ pathparam ( str_ ) string packagetype , final @ apiparam ( allowablevalues = str_ , required = bool_ ) @ pathparam ( str_ ) string type , @ apiparam ( required = bool_ ) @ pathparam ( str_ ) final string name ) { response response ; final storetype st = storetype . get ( type ) ; logger . info ( str_ , packagetype , st , name ) ; if ( admincontroller . exists ( new storekey ( packagetype , st , name ) ) ) { logger . info ( str_ ) ; response = response . ok ( ) . build ( ) ; } else { logger . info ( str_ ) ; response = response . status ( status . not_found ) . build ( ) ; } return response ; }	private HttpServletRequest request;.
public static void loadfromdiskand ( datafilemanager manager , indyobjectmapper serializer , final changesummary summary , consumer < artifactstore > consumer ) { loadfromdiskand ( manager , serializer , null , summary , consumer ) ; }	Load all store definitions from disk and apply consumer function.
public static void loadfromdiskand ( datafilemanager manager , indyobjectmapper serializer , storekey key , final changesummary summary , consumer < artifactstore > consumer ) { if ( key != null )	Load store definitions from disk and apply consumer function.
public hostedrepository createstorebyarc ( final inputstream fileinput , final string reponame , final string user , final string ignoredprefix ) throws indyworkflowexception { final hostedrepository repo = createhostedbyname ( reponame , user , str_ ) ; storezipcontentinhosted ( fileinput , ignoredprefix , repo ) ; return repo ; }	private ExecutorService executors;.
public httpclientcontext createcontext ( final string siteid ) throws indyhttpexception { try { return httpfactory . createcontext ( siteconfiglookup . lookup ( siteid ) ) ; } catch ( jhttpcexception e ) { throw new indyhttpexception ( str_ , e , e . getmessage ( ) ) ; } }	Create http request context and apply site config.
public closeablehttpclient createclient ( final string siteid ) throws indyhttpexception { try { return httpfactory . createclient ( siteconfiglookup . lookup ( siteid ) ) ; } catch ( jhttpcexception e ) { throw new indyhttpexception ( str_ , e , e . getmessage ( ) ) ; } }	Create http client and apply site config.
private kojirepairresult . repairresult dorepair ( string packagetype , remoterepository repository , kojibuildinfo buildinfo , string user , boolean isdryrun ) throws kojirepairexception { storekey storekey ; if ( repository != null ) { storekey = repository . getkey ( ) ; } else { string name = kojiutils . getrepositoryname ( buildinfo ) ; storekey = new storekey ( packagetype , storetype . remote , name ) ; try { repository = ( remoterepository ) storemanager . getartifactstore ( storekey ) ; } catch ( indydataexception e ) { throw new kojirepairexception ( str_ , e , storekey , e . getmessage ( ) ) ; } } kojirepairresult . repairresult repairresult = new kojirepairresult . repairresult ( storekey ) ; string url = repository . geturl ( ) ; string newurl ; try { newurl = kojiutils . formatstorageurl ( config . getstoragerooturl ( ) , buildinfo ) ;	Repair one remote repository.
private void handlegroupmemberschanged ( final artifactstore store , final map < artifactstore , artifactstore > changemap ) { final storekey key = store . getkey ( ) ; if ( storetype . group == key . gettype ( ) ) { final list < storekey > newmembers = ( ( group ) store ) . getconstituents ( ) ; logger . trace ( str_ , store . getkey ( ) , newmembers ) ; final group group = ( group ) changemap . get ( store ) ; final list < storekey > oldmembers = group . getconstituents ( ) ; logger . trace ( str_ , group . getname ( ) , oldmembers ) ; boolean memberschanged = bool_ ; if ( newmembers . size ( ) != oldmembers . size ( ) ) { memberschanged = bool_ ; } else { for ( storekey storekey : newmembers ) { if ( ! oldmembers . contains ( storekey ) ) { memberschanged = bool_ ; } } } if ( memberschanged ) { logger . trace ( str_ , group . getkey ( ) ) ; cleargroupmetacache ( group , group ) ; try { storemanager . query ( ) . getgroupsaffectedby ( group . getkey ( ) ) . foreach ( g -> cleargroupmetacache ( g , group ) ) ; } catch ( indydataexception e ) { logger . error ( string . format ( str_ , group . getkey ( ) ) , e ) ; } } else { logger . trace ( str_ ) ; } } }	If group members changed, should clear the cascading groups metadata cache.
public keycloakconfig setsystemproperties ( ) { if ( ! isenabled ( ) ) { return this ; } final properties properties = system . getproperties ( ) ; properties . setproperty ( keycloak_realm , getrealm ( ) ) ; properties . setproperty ( keycloak_url , geturl ( ) ) ; if ( getserverresource ( ) != null ) { properties . setproperty ( keycloak_server_resource , getserverresource ( ) ) ; } if ( getservercredentialsecret ( ) != null ) { properties . setproperty ( keycloak_server_credential_secret , getservercredentialsecret ( ) ) ; } if ( getrealmpublickey ( ) != null ) { properties . setproperty ( keycloak_realm_public_key , getrealmpublickey ( ) ) ; } system . setproperties ( properties ) ; return this ; }	Set system properties for keycloak to use when filtering keycloak.json...
protected static arraylist < filerange > getfileranges ( inputstream streamref ) throws parserconfigurationexception , saxexception , ioexception { saxparser saxparser = utility . getsaxparser ( ) ; filerangehandler handler = new filerangehandler ( ) ; saxparser . parse ( streamref , handler ) ; return handler . fileranges ; }	Returns an ArrayList of File Ranges for the given stream.
public static arraylist < cloudqueuemessage > readmessages ( final inputstream stream , final boolean shouldencodemessage ) throws saxexception , ioexception , parserconfigurationexception { saxparser saxparser = utility . getsaxparser ( ) ; queuemessagehandler handler = new queuemessagehandler ( shouldencodemessage ) ; saxparser . parse ( stream , handler ) ; return handler . messages ; }	Populates CloudQueueMessage objects from the XMLStreamReader; the reader must be at the Start element ofQueuesElement.
@ doesservicerequest public void delete ( tablerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = tablerequestoptions . populateandapplydefaults ( options , this . tableserviceclient ) ; utility . assertnotnullorempty ( str_ , this . name ) ; final dynamictableentity tableentry = new dynamictableentity ( ) ; tableentry . getproperties ( ) . put ( tableconstants . table_name , new entityproperty ( this . name ) ) ; tableoperation deleteop = new tableoperation ( tableentry , tableoperationtype . delete ) ; deleteop . execute ( this . tableserviceclient , tableconstants . tables_service_tables_name , options , opcontext ) ; }	Deletes the table from the storage service, using the specified request options and operation context.
@ doesservicerequest public void uploadpermissions ( final tablepermissions permissions , tablerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = tablerequestoptions . populateandapplydefaults ( options , this . tableserviceclient ) ; executionengine . executewithretry ( this . tableserviceclient , this , this . uploadpermissionsimpl ( permissions , options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Uploads the table's permissions using the specified request options and operation context.
@ doesservicerequest public tablepermissions downloadpermissions ( tablerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = tablerequestoptions . populateandapplydefaults ( options , this . tableserviceclient ) ; return executionengine . executewithretry ( this . tableserviceclient , this , this . downloadpermissionsimpl ( options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Downloads the permissions settings for the table using the specified request options and operation context.
protected static void applybasedefaultsinternal ( final requestoptions modifiedoptions ) { utility . assertnotnull ( str_ , modifiedoptions ) ; if ( modifiedoptions . getretrypolicyfactory ( ) == null ) { modifiedoptions . setretrypolicyfactory ( new retryexponentialretry ( ) ) ; } if ( modifiedoptions . getlocationmode ( ) == null ) { modifiedoptions . setlocationmode ( locationmode . primary_only ) ; } }	Populates the default timeout, retry policy, and location mode from client if they are null.
public static storageextendederrorinformation getextendederrorinformation ( final inputstream stream ) throws saxexception , ioexception , parserconfigurationexception { saxparser saxparser = utility . getsaxparser ( ) ; storageerrorhandler handler = new storageerrorhandler ( ) ; saxparser . parse ( stream , handler ) ; return handler . errorinfo ; }	Gets the Extended Error information from the response stream.
public static accesscondition generateifsequencenumberlessthanorequalcondition ( long sequencenumber ) { accesscondition retcondition = new accesscondition ( ) ; retcondition . ifsequencenumberlessthanorequal = sequencenumber ; return retcondition ; }	Returns an access condition such that an operation will be performed only if resource's current sequencenumber is less than or equal to the specified value.
public static accesscondition generateifsequencenumberlessthancondition ( long sequencenumber ) { accesscondition retcondition = new accesscondition ( ) ; retcondition . ifsequencenumberlessthan = sequencenumber ; return retcondition ; }	Returns an access condition such that an operation will be performed only if resource's current sequencenumber is less than the specified value.
public static accesscondition generateifsequencenumberequalcondition ( long sequencenumber ) { accesscondition retcondition = new accesscondition ( ) ; retcondition . ifsequencenumberequal = sequencenumber ; return retcondition ; }	Returns an access condition such that an operation will be performed only if resource's current sequencenumber is equal to the specified value.
public void applyconditiontorequest ( final httpurlconnection request ) { applyleaseconditiontorequest ( request ) ; if ( this . ifmodifiedsincedate != null ) { request . setrequestproperty ( constants . headerconstants . if_modified_since , utility . getgmttime ( this . ifmodifiedsincedate ) ) ; } if ( this . ifunmodifiedsincedate != null ) { request . setrequestproperty ( constants . headerconstants . if_unmodified_since , utility . getgmttime ( this . ifunmodifiedsincedate ) ) ; } if ( ! utility . isnullorempty ( this . ifmatchetag ) ) { request . setrequestproperty ( constants . headerconstants . if_match , this . ifmatchetag ) ; } if ( ! utility . isnullorempty ( this . ifnonematchetag ) ) { request . setrequestproperty ( constants . headerconstants . if_none_match , this . ifnonematchetag ) ; } }	RESERVED FOR INTERNAL USE.
public void applysourceconditiontorequest ( final httpurlconnection request ) { if ( ! utility . isnullorempty ( this . leaseid ) ) {	RESERVED FOR INTERNAL USE.
public void applyappendconditiontorequest ( final httpurlconnection request ) { if ( this . ifmaxsizelessthanorequal != null ) { request . setrequestproperty ( constants . headerconstants . if_max_size_less_than_or_equal , this . ifmaxsizelessthanorequal . tostring ( ) ) ; } if ( this . ifappendpositionequal != null ) { request . setrequestproperty ( constants . headerconstants . if_append_position_equal_header , this . ifappendpositionequal . tostring ( ) ) ; } }	RESERVED FOR INTERNAL USE.
public void applyleaseconditiontorequest ( final httpurlconnection request ) { if ( ! utility . isnullorempty ( this . leaseid ) ) { request . setrequestproperty ( constants . headerconstants . lease_id_header , this . leaseid ) ; } }	RESERVED FOR INTERNAL USE.
public void applysequenceconditiontorequest ( final httpurlconnection request ) { if ( this . ifsequencenumberlessthanorequal != null ) { request . setrequestproperty ( constants . headerconstants . if_sequence_number_less_than_or_equal , this . ifsequencenumberlessthanorequal . tostring ( ) ) ; } if ( this . ifsequencenumberlessthan != null ) { request . setrequestproperty ( constants . headerconstants . if_sequence_number_less_than , this . ifsequencenumberlessthan . tostring ( ) ) ; } if ( this . ifsequencenumberequal != null ) { request . setrequestproperty ( constants . headerconstants . if_sequence_number_equal , this . ifsequencenumberequal . tostring ( ) ) ; } }	RESERVED FOR INTERNAL USE.
public boolean verifyconditional ( final string etag , final date lastmodified ) { if ( this . ifmodifiedsincedate != null ) {	RESERVED FOR INTERNAL USE.
public static string combinefilters ( string filtera , string operator , string filterb ) { return string . format ( str_ , filtera , operator , filterb ) ; }	Creates a filter condition using the specified logical operator on two filter conditions.
protected final void setstorageuri ( final storageuri storageuri ) { this . usepathstyleuris = utility . determinepathstylefromuri ( storageuri . getprimaryuri ( ) ) ; this . storageuri = storageuri ; }	Sets the list of URIs for all locations.
public static < t extends sharedaccesspolicy > void writesharedaccessidentifierstostream ( final hashmap < string , t > sharedaccesspolicies , final stringwriter outwriter ) throws illegalargumentexception , illegalstateexception , ioexception { utility . assertnotnull ( str_ , sharedaccesspolicies ) ; utility . assertnotnull ( str_ , outwriter ) ; final xmlserializer xmlw = utility . getxmlserializer ( outwriter ) ; if ( sharedaccesspolicies . keyset ( ) . size ( ) > constants . max_shared_access_policy_identifiers ) { final string errormessage = string . format ( sr . too_many_shared_access_policy_identifiers , sharedaccesspolicies . keyset ( ) . size ( ) , constants . max_shared_access_policy_identifiers ) ; throw new illegalargumentexception ( errormessage ) ; }	RESERVED FOR INTERNAL USE.
public static byte [ ] generatemessagerequestbody ( final string message ) throws illegalargumentexception , illegalstateexception , ioexception { final stringwriter outwriter = new stringwriter ( ) ; final xmlserializer xmlw = utility . getxmlserializer ( outwriter ) ;	Generates the message request body from a string containing the message.The message must be encodable as UTF-8.
private static void addcanonicalizedheaders ( final httpurlconnection conn , final stringbuilder canonicalizedstring ) {	Add x-ms- prefixed headers in a fixed order.
protected static void appendcanonicalizedelement ( final stringbuilder builder , final string element ) { builder . append ( str_ ) ; builder . append ( element ) ; }	Append a string to a string builder with a newline constant.
protected static string canonicalizehttprequest ( final java . net . url address , final string accountname , final string method , final string contenttype , final long contentlength , final string date , final httpurlconnection conn ) throws storageexception {	Constructs a canonicalized string from the request's headers that will be used to construct the signature stringfor signing a Blob or Queue service request under the Shared Key Full authentication scheme.
protected static string canonicalizetablehttprequest ( final java . net . url address , final string accountname , final string method , final string contenttype , final long contentlength , final string date , final httpurlconnection conn ) throws storageexception {	Constructs a canonicalized string that will be used to construct the signature stringfor signing a Table service request under the Shared Key authentication scheme.
public static synchronized string computehmac256 ( final storagecredentials creds , final string value ) throws invalidkeyexception { if ( creds . getclass ( ) . equals ( storagecredentialsaccountandkey . class ) ) { byte [ ] utf8bytes = null ; try { utf8bytes = value . getbytes ( constants . utf8_charset ) ; } catch ( final unsupportedencodingexception e ) { throw new illegalargumentexception ( e ) ; } return base64 . encode ( ( ( storagecredentialsaccountandkey ) creds ) . gethmac256 ( ) . dofinal ( utf8bytes ) ) ; } else { return null ; } }	Computes a signature for the specified string using the HMAC-SHA256 algorithm.
public static void signtablerequest ( final storagecredentials creds , final java . net . httpurlconnection request , final long contentlength , operationcontext opcontext ) throws invalidkeyexception , storageexception { if ( creds . getclass ( ) . equals ( storagecredentialsaccountandkey . class ) ) { opcontext = opcontext == null ? new operationcontext ( ) : opcontext ; request . setrequestproperty ( constants . headerconstants . date , utility . getgmttime ( ) ) ; final canonicalizer canonicalizer = canonicalizerfactory . gettablecanonicalizer ( request ) ; final string stringtosign = canonicalizer . canonicalize ( request , creds . getaccountname ( ) , contentlength ) ; final string computedbase64signature = storagecredentialshelper . computehmac256 ( creds , stringtosign ) ; logger . debug ( opcontext , logconstants . signing , stringtosign ) ; request . setrequestproperty ( constants . headerconstants . authorization , string . format ( str_ , str_ , creds . getaccountname ( ) , computedbase64signature ) ) ; } }	Signs a request using the specified operation context under the Shared Key authentication scheme.
private static cloudqueuemessage getfirstornull ( final iterable < cloudqueuemessage > messages ) { for ( final cloudqueuemessage m : messages ) { return m ; } return null ; }	Gets the first message from a list of queue messages, if any.
@ doesservicerequest public void clear ( queuerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = queuerequestoptions . populateandapplydefaults ( options , this . queueserviceclient ) ; executionengine . executewithretry ( this . queueserviceclient , this , this . clearimpl ( options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Clears all messages from the queue, using the specified request options and operation context.
@ doesservicerequest public void create ( queuerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = queuerequestoptions . populateandapplydefaults ( options , this . queueserviceclient ) ; executionengine . executewithretry ( this . queueserviceclient , this , this . createimpl ( options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Creates the queue, using the specified request options and operation context.
@ doesservicerequest public void delete ( queuerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = queuerequestoptions . populateandapplydefaults ( options , this . queueserviceclient ) ; executionengine . executewithretry ( this . queueserviceclient , this , this . deleteimpl ( options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Deletes the queue, using the specified request options and operation context.
@ doesservicerequest public void downloadattributes ( queuerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = queuerequestoptions . populateandapplydefaults ( options , this . queueserviceclient ) ; executionengine . executewithretry ( this . queueserviceclient , this , this . downloadattributesimpl ( options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Downloads the queue's metadata and approximate message count value, using the specified request options andoperation context.
@ doesservicerequest public iterable < cloudqueuemessage > peekmessages ( final int numberofmessages ) throws storageexception { return this . peekmessages ( numberofmessages , null , null ) ; }	Peeks a specified number of messages from the queue.
@ doesservicerequest public iterable < cloudqueuemessage > retrievemessages ( final int numberofmessages ) throws storageexception { return this . retrievemessages ( numberofmessages , queueconstants . default_visibility_message_timeout_in_seconds , null , null ) ; }	Retrieves the specified number of messages from the front of the queue using the default request options.
public void updatemessage ( final cloudqueuemessage message , final int visibilitytimeoutinseconds ) throws storageexception { this . updatemessage ( message , visibilitytimeoutinseconds , enumset . of ( messageupdatefields . visibility ) , null , null ) ; }	Updates the specified message in the queue with a new visibility timeout value in seconds.
@ doesservicerequest public void uploadpermissions ( final queuepermissions permissions , queuerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = queuerequestoptions . populateandapplydefaults ( options , this . queueserviceclient ) ; executionengine . executewithretry ( this . queueserviceclient , this , this . uploadpermissionsimpl ( permissions , options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Uploads the queue's permissions using the specified request options and operation context.
@ doesservicerequest public queuepermissions downloadpermissions ( queuerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } opcontext . initialize ( ) ; options = queuerequestoptions . populateandapplydefaults ( options , this . queueserviceclient ) ; return executionengine . executewithretry ( this . queueserviceclient , this , this . downloadpermissionsimpl ( options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Downloads the permissions settings for the queue using the specified request options and operation context.
private final storageuri gettransformedaddress ( final operationcontext opcontext ) throws urisyntaxexception , storageexception { return this . queueserviceclient . getcredentials ( ) . transformuri ( this . getstorageuri ( ) , opcontext ) ; }	Returns the transformed URI for the resource if the given credentials require transformation.
public cloudtable gethourmetricstable ( storageservice service , storagelocation location ) throws urisyntaxexception , storageexception { utility . assertnotnull ( str_ , service ) ; if ( location == null ) { location = storagelocation . primary ; } switch ( service ) { case blob : if ( location == storagelocation . primary ) { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_hour_primary_transactions_blob ) ; } else { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_hour_secondary_transactions_blob ) ; } case file : if ( location == storagelocation . primary ) { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_hour_primary_transactions_file ) ; } else { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_hour_secondary_transactions_file ) ; } case queue : if ( location == storagelocation . primary ) { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_hour_primary_transactions_queue ) ; } else { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_hour_secondary_transactions_queue ) ; } case table : if ( location == storagelocation . primary ) { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_hour_primary_transactions_table ) ; } else { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_hour_secondary_transactions_table ) ; } default : throw new illegalargumentexception ( sr . invalid_storage_service ) ; } }	Gets the hour metrics table for a specific storage service.
public cloudtable getminutemetricstable ( storageservice service , storagelocation location ) throws urisyntaxexception , storageexception { utility . assertnotnull ( str_ , service ) ; if ( location == null ) { location = storagelocation . primary ; } switch ( service ) { case blob : if ( location == storagelocation . primary ) { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_minute_primary_transactions_blob ) ; } else { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_minute_secondary_transactions_blob ) ; } case file : if ( location == storagelocation . primary ) { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_minute_primary_transactions_file ) ; } else { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_minute_secondary_transactions_file ) ; } case queue : if ( location == storagelocation . primary ) { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_minute_primary_transactions_queue ) ; } else { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_minute_secondary_transactions_queue ) ; } case table : if ( location == storagelocation . primary ) { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_minute_primary_transactions_table ) ; } else { return this . tableclient . gettablereference ( constants . analyticsconstants . metrics_minute_secondary_transactions_table ) ; } default : throw new illegalargumentexception ( sr . invalid_storage_service ) ; } }	Gets the minute metrics table for a specific storage service.
public final byte [ ] getmessagecontentasbyte ( ) throws storageexception { if ( utility . isnullorempty ( this . messagecontent ) ) { return new byte [ num_ ] ; } if ( this . messagetype == queuemessagetype . raw_string ) { try { return this . messagecontent . getbytes ( constants . utf8_charset ) ; } catch ( final unsupportedencodingexception e ) { throw utility . generatenewunexpectedstorageexception ( e ) ; } } else { return base64 . decode ( this . messagecontent ) ; } }	Gets the content of the message as a byte array.
public final string getmessagecontentasstring ( ) throws storageexception { if ( this . messagetype == queuemessagetype . raw_string ) { return this . messagecontent ; } else { if ( utility . isnullorempty ( this . messagecontent ) ) { return null ; } try { return new string ( base64 . decode ( this . messagecontent ) , constants . utf8_charset ) ; } catch ( final unsupportedencodingexception e ) { throw utility . generatenewunexpectedstorageexception ( e ) ; } } }	Gets the content of the message as a string.
public static listresponse < listfileitem > getfileanddirectorylist ( final inputstream stream , final cloudfiledirectory directory ) throws parserconfigurationexception , saxexception , ioexception { saxparser saxparser = utility . getsaxparser ( ) ; filelisthandler handler = new filelisthandler ( directory ) ; saxparser . parse ( stream , handler ) ; return handler . response ; }	Parse and return the response.
private static void applycontinuationtoquerybuilder ( final uriquerybuilder builder , final resultcontinuation continuationtoken ) throws storageexception { if ( continuationtoken != null ) { if ( continuationtoken . getnextpartitionkey ( ) != null ) { builder . add ( tableconstants . table_service_next_partition_key , continuationtoken . getnextpartitionkey ( ) ) ; } if ( continuationtoken . getnextrowkey ( ) != null ) { builder . add ( tableconstants . table_service_next_row_key , continuationtoken . getnextrowkey ( ) ) ; } if ( continuationtoken . getnexttablename ( ) != null ) { builder . add ( tableconstants . table_service_next_table_name , continuationtoken . getnexttablename ( ) ) ; } } }	Reserved for internal use.
public static httpurlconnection setacl ( final uri rooturi , final tablerequestoptions options , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { uriquerybuilder querybuilder = new uriquerybuilder ( ) ; querybuilder . add ( constants . queryconstants . component , str_ ) ; final httpurlconnection retconnection = baserequest . createurlconnection ( rooturi , options , querybuilder , opcontext ) ; retconnection . setrequestmethod ( str_ ) ; retconnection . setdooutput ( bool_ ) ; return retconnection ; }	Sets the ACL for the table.
public static byte [ ] serializetobytearray ( final serviceproperties properties ) throws illegalargumentexception , illegalstateexception , ioexception { final stringwriter outwriter = new stringwriter ( ) ; final xmlserializer xmlw = utility . getxmlserializer ( outwriter ) ;	Writes the contents of the ServiceProperties to the stream in xml format.
private static void writeretentionpolicy ( final xmlserializer xmlw , final integer val ) throws illegalargumentexception , illegalstateexception , ioexception { xmlw . starttag ( constants . empty_string , constants . analyticsconstants . retention_policy_element ) ;	Writes the retention policy to the XMLStreamWriter.
private static void writecorsproperties ( final xmlserializer xmlw , final corsproperties cors ) throws illegalargumentexception , illegalstateexception , ioexception { utility . assertnotnull ( str_ , cors . getcorsrules ( ) ) ;	Writes the given CORS properties to the XMLStreamWriter.
private static void writemetricsproperties ( final xmlserializer xmlw , final metricsproperties metrics , final string metricsname ) throws illegalargumentexception , illegalstateexception , ioexception { utility . assertnotnull ( str_ , metrics . getmetricslevel ( ) ) ;	Writes the given metrics properties to the XMLStreamWriter.
private static void writeloggingproperties ( final xmlserializer xmlw , final loggingproperties logging ) throws illegalargumentexception , illegalstateexception , ioexception { utility . assertnotnull ( str_ , logging . getlogoperationtypes ( ) ) ;	Writes the given logging properties to the XMLStreamWriter.
public static void addsharesnapshot ( final uriquerybuilder builder , final string snapshotversion ) throws storageexception { if ( snapshotversion != null ) { builder . add ( constants . queryconstants . share_snapshot , snapshotversion ) ; } }	Adds the share snapshot if present.Only for listing files and directories which requires a different query param.
private static uriquerybuilder getshareuriquerybuilder ( ) throws storageexception { final uriquerybuilder uribuilder = new uriquerybuilder ( ) ; try { uribuilder . add ( constants . queryconstants . resourcetype , str_ ) ; } catch ( final illegalargumentexception e ) { throw utility . generatenewunexpectedstorageexception ( e ) ; } return uribuilder ; }	Gets the share Uri query builder.A UriQueryBuilder for the share.
public static httpurlconnection createdirectory ( final uri uri , final filerequestoptions fileoptions , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { final uriquerybuilder directorybuilder = getdirectoryuriquerybuilder ( ) ; return baserequest . create ( uri , fileoptions , directorybuilder , opcontext ) ; }	Constructs a web request to create a new directory.
@ override public synchronized void close ( ) throws ioexception { this . currentbuffer = null ; this . streamfaulted = bool_ ; this . lasterror = new ioexception ( sr . stream_closed ) ; }	Closes this input stream and releases any system resources associated with the stream.
@ doesservicerequest private synchronized void dispatchread ( final int readlength ) throws ioexception { try { final byte [ ] bytebuffer = new byte [ readlength ] ; this . parentfileref . downloadrangeinternal ( this . currentabsolutereadposition , ( long ) readlength , bytebuffer , num_ , null , this . options , this . opcontext ) ;	Dispatches a read operation of N bytes.
@ override public synchronized void reset ( ) throws ioexception { if ( this . markedposition + this . markexpiry < this . currentabsolutereadposition ) { throw new ioexception ( sr . mark_expired ) ; } this . validatefilemd5 = bool_ ; this . md5digest = null ; this . reposition ( this . markedposition ) ; }	Repositions this stream to the position at the time the mark method was last called on this input stream.
public void runblobgettingstartedsample ( view view ) { new blobgettingstartedtask ( this , ( textview ) findviewbyid ( r . id . textview ) ) . execute ( ) ; }	Runs the blob getting started sample.
public void runqueuegettingstartedsample ( view view ) { new queuegettingstartedtask ( this , ( textview ) findviewbyid ( r . id . textview ) ) . execute ( ) ; }	Runs the queue getting started sample.
public void runtablegettingstartedsample ( view view ) { new tablegettingstartedtask ( this , ( textview ) findviewbyid ( r . id . textview ) ) . execute ( ) ; }	Runs the table getting started sample.
public void runtablepayloadformatsample ( view view ) { new tablepayloadformattask ( this , ( textview ) findviewbyid ( r . id . textview ) ) . execute ( ) ; }	Runs the table payload format sample.
public void outputtext ( final textview view , final string value ) { runonuithread ( new runnable ( ) { @ override public void run ( ) { view . append ( value + str_ ) ; system . out . println ( view ) ; } } ) ; }	Prints the specified text value to the view and to LogCat.
public void printexception ( throwable t ) { stringwriter stringwriter = new stringwriter ( ) ; printwriter printwriter = new printwriter ( stringwriter ) ; t . printstacktrace ( printwriter ) ; outputtext ( ( textview ) findviewbyid ( r . id . textview ) , string . format ( str_ , stringwriter . tostring ( ) ) ) ; }	Prints out the exception information .
public void printsamplestartinfo ( string samplename ) { textview view = ( textview ) findviewbyid ( r . id . textview ) ; cleartext ( view ) ; outputtext ( view , string . format ( str_ , samplename ) ) ; }	Prints out the sample start information .
public void printsamplecompleteinfo ( string samplename ) { outputtext ( ( textview ) findviewbyid ( r . id . textview ) , string . format ( str_ , samplename ) ) ; }	Prints out the sample complete information .
@ override protected string canonicalize ( final httpurlconnection conn , final string accountname , final long contentlength ) throws storageexception { if ( contentlength < - num_ ) { throw new invalidparameterexception ( sr . invalid_content_length ) ; } return canonicalizetablehttprequest ( conn . geturl ( ) , accountname , conn . getrequestmethod ( ) , utility . getstandardheadervalue ( conn , constants . headerconstants . content_type ) , contentlength , null , conn ) ; }	Constructs a canonicalized string for signing a request.
public synchronized requestresult getlastresult ( ) { if ( this . requestresults == null || this . requestresults . size ( ) == num_ ) { return null ; } else { return this . requestresults . get ( this . requestresults . size ( ) - num_ ) ; } }	Gets the last request result encountered for the operation.
private boolean iscorrectlogtype ( listblobitem current ) { hashmap < string , string > metadata = ( ( cloudblob ) current ) . getmetadata ( ) ; string logtype = metadata . get ( str_ ) ; if ( logtype == null ) { return bool_ ; } if ( this . operations . contains ( loggingoperations . read ) && logtype . contains ( str_ ) ) { return bool_ ; } if ( this . operations . contains ( loggingoperations . write ) && logtype . contains ( str_ ) ) { return bool_ ; } if ( this . operations . contains ( loggingoperations . delete ) && logtype . contains ( str_ ) ) { return bool_ ; } return bool_ ; }	Validates that the log given is of the correct log type.
private void updateiterator ( ) throws storageexception , urisyntaxexception { if ( this . currentprefixtime != null && this . currentprefixtime . isempty ( ) ) {	Makes the next listBlob call if necessary and updates the currentIterator.
@ doesservicerequest public final string startcopy ( final cloudblob sourceblob ) throws storageexception , urisyntaxexception { return this . startcopy ( sourceblob , null , null , null , null ) ; }	Requests the service to start copying a blob's contents, properties, and metadata to a new file.
@ doesservicerequest public final string startcopy ( final cloudfile sourcefile ) throws storageexception , urisyntaxexception { return this . startcopy ( sourcefile , null , null , null , null ) ; }	Requests the service to start copying an Azure File's contents, properties, and metadata to a new Azure File.
@ doesservicerequest public final string startcopy ( final uri source ) throws storageexception , urisyntaxexception { return this . startcopy ( source , null , null , null , null ) ; }	Requests the service to start copying a URI's contents, properties, and metadata to a new Azure File.
@ doesservicerequest public void create ( final long size ) throws storageexception , urisyntaxexception { this . create ( size , null , null , null ) ; }	Creates a file. If the file already exists, this will replace it.
private void deleteemptyfileonexception ( outputstream outputstream , string path ) { try { outputstream . close ( ) ; file filetodelete = new file ( path ) ; filetodelete . delete ( ) ; } catch ( exception e ) {	Helper to delete an empty file in the case of an exception.
@ doesservicerequest public fileoutputstream openwriteexisting ( ) throws storageexception , urisyntaxexception { return this . openoutputstreaminternal ( null , null , null , null ) ; }	Opens an output stream object to write data to the file.
public void uploadfromfile ( final string path ) throws storageexception , ioexception , urisyntaxexception { uploadfromfile ( path , null , null , null ) ; }	Uploads a local file.
public void uploadtext ( final string content ) throws storageexception , ioexception , urisyntaxexception { this . uploadtext ( content , null , null , null , null ) ; }	Uploads a file from a string using the platform's default encoding.
@ doesservicerequest public void uploadrange ( final inputstream sourcestream , final long offset , final long length ) throws storageexception , ioexception , urisyntaxexception { this . uploadrange ( sourcestream , offset , length , null , null , null ) ; }	Uploads a range to a file.
@ doesservicerequest public void upload ( final inputstream sourcestream , final long length ) throws storageexception , ioexception , urisyntaxexception { this . upload ( sourcestream , length , null , null , null ) ; }	Uploads the source stream data to the file.
protected static string getparentnamefromuri ( final storageuri resourceaddress , final cloudfileshare share ) throws urisyntaxexception { utility . assertnotnull ( str_ , resourceaddress ) ; utility . assertnotnull ( str_ , share ) ; string delimiter = str_ ; string sharename = share . getname ( ) + delimiter ; string relativeuristring = utility . saferelativize ( share . getstorageuri ( ) . getprimaryuri ( ) , resourceaddress . getprimaryuri ( ) ) ; if ( relativeuristring . endswith ( delimiter ) ) { relativeuristring = relativeuristring . substring ( num_ , relativeuristring . length ( ) - delimiter . length ( ) ) ; } string parentname ; if ( utility . isnullorempty ( relativeuristring ) ) {	Retrieves the parent name for a file URI.
@ override public final cloudfileshare getshare ( ) throws storageexception , urisyntaxexception { if ( this . share == null ) { final storageuri shareuri = pathutility . getshareuri ( this . getstorageuri ( ) , this . fileserviceclient . isusepathstyleuris ( ) ) ; this . share = new cloudfileshare ( shareuri , this . fileserviceclient . getcredentials ( ) ) ; } return this . share ; }	Returns the file's share.
public static uri appendpathtosingleuri ( final uri uri , final string relativeuri , final string separator ) throws urisyntaxexception { if ( uri == null ) { return null ; } if ( relativeuri == null || relativeuri . isempty ( ) ) { return uri ; } if ( uri . getpath ( ) . length ( ) == num_ && relativeuri . startswith ( separator ) ) { return new uri ( uri . getscheme ( ) , uri . getauthority ( ) , relativeuri , uri . getrawquery ( ) , uri . getrawfragment ( ) ) ; } final stringbuilder pathstring = new stringbuilder ( uri . getpath ( ) ) ; if ( uri . getpath ( ) . endswith ( separator ) ) { pathstring . append ( relativeuri ) ; } else { pathstring . append ( separator ) ; pathstring . append ( relativeuri ) ; } return new uri ( uri . getscheme ( ) , uri . getauthority ( ) , pathstring . tostring ( ) , uri . getquery ( ) , uri . getfragment ( ) ) ; }	Appends a path to a URI correctly using the given separator.
public static string getblobnamefromuri ( final uri inuri , final boolean usepathstyleuris ) throws urisyntaxexception { return utility . saferelativize ( new uri ( getcontaineruri ( new storageuri ( inuri ) , usepathstyleuris ) . getprimaryuri ( ) . tostring ( ) . concat ( str_ ) ) , inuri ) ; }	Gets the blob name from the URI.
public static string getcanonicalpathfromcredentials ( final storagecredentials credentials , final string absolutepath ) { final string account = credentials . getaccountname ( ) ; if ( account == null ) { final string errormessage = sr . cannot_create_sas_for_given_credentials ; throw new illegalargumentexception ( errormessage ) ; } final stringbuilder builder = new stringbuilder ( str_ ) ; builder . append ( account ) ; builder . append ( absolutepath ) ; return builder . tostring ( ) ; }	Gets the canonical path for an object from the credentials.
public static string getcontainernamefromuri ( final uri resourceaddress , final boolean usepathstyleuris ) { return getresourcenamefromuri ( resourceaddress , usepathstyleuris , string . format ( str_ , resourceaddress ) ) ; }	Get the container name from address from the URI.
public static string getfilenamefromuri ( final uri resourceaddress , final boolean usepathstyleuris ) {	Gets the file name from the URI.
public static string getsharenamefromuri ( final uri resourceaddress , final boolean usepathstyleuris ) { return getresourcenamefromuri ( resourceaddress , usepathstyleuris , string . format ( str_ , resourceaddress ) ) ; }	Get the share name from address from the URI.
public static string gettablenamefromuri ( final uri resourceaddress , final boolean usepathstyleuris ) { return getresourcenamefromuri ( resourceaddress , usepathstyleuris , string . format ( str_ , resourceaddress ) ) ; }	Get the table name from address from the URI.
private static string getresourcenamefromuri ( final uri resourceaddress , final boolean usepathstyleuris , final string error ) { utility . assertnotnull ( str_ , resourceaddress ) ; final string [ ] pathsegments = resourceaddress . getrawpath ( ) . split ( str_ ) ; final int expectedpartslength = usepathstyleuris ? num_ : num_ ; if ( pathsegments . length < expectedpartslength ) { throw new illegalargumentexception ( error ) ; } final string resourcename = usepathstyleuris ? pathsegments [ num_ ] : pathsegments [ num_ ] ; return utility . trimend ( resourcename , str_ ) ; }	Get the container, queue or table name from address from the URI.
public static storageuri getcontaineruri ( final storageuri blobaddress , final boolean usepathstyleuris ) throws urisyntaxexception { final string containername = getcontainernamefromuri ( blobaddress . getprimaryuri ( ) , usepathstyleuris ) ; final storageuri containeruri = appendpathtouri ( getserviceclientbaseaddress ( blobaddress , usepathstyleuris ) , containername ) ; return containeruri ; }	Gets the container URI from a blob address.
public static storageuri getshareuri ( final storageuri fileaddress , final boolean usepathstyleuris ) throws urisyntaxexception { final string sharename = getsharenamefromuri ( fileaddress . getprimaryuri ( ) , usepathstyleuris ) ; final storageuri shareuri = appendpathtouri ( getserviceclientbaseaddress ( fileaddress , usepathstyleuris ) , sharename ) ; return shareuri ; }	Gets the share URI from a file address.
public static hashmap < string , string [ ] > parsequerystring ( string parsestring ) throws storageexception { final hashmap < string , string [ ] > retvals = new hashmap < string , string [ ] > ( ) ; if ( utility . isnullorempty ( parsestring ) ) { return retvals ; }	Parses a query string into a one to many hashmap.
public static string generatesharedaccesssignaturehashforblobandfile ( final sharedaccesspolicy policy , sharedaccessheaders headers , final string accesspolicyidentifier , final string resourcename , final iprange iprange , final sharedaccessprotocols protocols , final serviceclient client ) throws invalidkeyexception , storageexception { string stringtosign = generatesharedaccesssignaturestringtosign ( policy , resourcename , iprange , protocols , accesspolicyidentifier ) ; string cachecontrol = null ; string contentdisposition = null ; string contentencoding = null ; string contentlanguage = null ; string contenttype = null ; if ( headers != null ) { cachecontrol = headers . getcachecontrol ( ) ; contentdisposition = headers . getcontentdisposition ( ) ; contentencoding = headers . getcontentencoding ( ) ; contentlanguage = headers . getcontentlanguage ( ) ; contenttype = headers . getcontenttype ( ) ; } stringtosign = string . format ( str_ , stringtosign , cachecontrol == null ? constants . empty_string : cachecontrol , contentdisposition == null ? constants . empty_string : contentdisposition , contentencoding == null ? constants . empty_string : contentencoding , contentlanguage == null ? constants . empty_string : contentlanguage , contenttype == null ? constants . empty_string : contenttype ) ; return generatesharedaccesssignaturehashhelper ( stringtosign , client . getcredentials ( ) ) ; }	Get the signature hash embedded inside the Shared Access Signature for the blob or file service.
public static string generatesharedaccesssignaturehashforqueue ( final sharedaccessqueuepolicy policy , final string accesspolicyidentifier , final string resourcename , final iprange iprange , final sharedaccessprotocols protocols , final serviceclient client ) throws invalidkeyexception , storageexception { final string stringtosign = generatesharedaccesssignaturestringtosign ( policy , resourcename , iprange , protocols , accesspolicyidentifier ) ; return generatesharedaccesssignaturehashhelper ( stringtosign , client . getcredentials ( ) ) ; }	Get the signature hash embedded inside the Shared Access Signature for queue service.
@ doesservicerequest public void create ( filerequestoptions options , operationcontext opcontext ) throws storageexception , urisyntaxexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } this . getshare ( ) . assertnosnapshot ( ) ; opcontext . initialize ( ) ; options = filerequestoptions . populateandapplydefaults ( options , this . fileserviceclient ) ; executionengine . executewithretry ( this . fileserviceclient , this , createdirectoryimpl ( options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Creates the directory using the specified options and operation context.
@ doesservicerequest public resultsegment < listfileitem > listfilesanddirectoriessegmented ( ) throws storageexception { return this . listfilesanddirectoriessegmented ( null , null , null , null , null ) ; }	Returns a result segment of an enumerable collection of files and directories for this File service client.
@ override public cloudfileshare getshare ( ) throws storageexception , urisyntaxexception { if ( this . share == null ) { this . share = this . fileserviceclient . getsharereference ( pathutility . getsharenamefromuri ( this . geturi ( ) , this . fileserviceclient . isusepathstyleuris ( ) ) ) ; } return this . share ; }	Returns the share for this directory.
public static httpurlconnection setacl ( final uri uri , final queuerequestoptions queueoptions , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { final uriquerybuilder builder = new uriquerybuilder ( ) ; builder . add ( constants . queryconstants . component , constants . queryconstants . acl ) ; final httpurlconnection request = baserequest . createurlconnection ( uri , queueoptions , builder , opcontext ) ; request . setdooutput ( bool_ ) ; request . setrequestmethod ( constants . http_put ) ; return request ; }	Sets the ACL for the queue.
public static httpurlconnection getacl ( final uri uri , final queuerequestoptions queueoptions , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { final uriquerybuilder builder = new uriquerybuilder ( ) ; builder . add ( constants . queryconstants . component , constants . queryconstants . acl ) ; final httpurlconnection request = baserequest . createurlconnection ( uri , queueoptions , builder , opcontext ) ; request . setrequestmethod ( constants . http_get ) ; return request ; }	Constructs a web request to return the ACL for this queue.
private static list < string > splittolist ( string str , string delimiter ) { arraylist < string > list = new arraylist < string > ( ) ; stringtokenizer st = new stringtokenizer ( str , delimiter ) ; while ( st . hasmoreelements ( ) ) { list . add ( st . nexttoken ( ) ) ; } return list ; }	Split a delimiter separated string into an ArrayList.
private static enumset < corshttpmethods > splittoenumset ( string str , string delimiter ) { enumset < corshttpmethods > set = enumset . noneof ( corshttpmethods . class ) ; stringtokenizer st = new stringtokenizer ( str , delimiter ) ; while ( st . hasmoreelements ( ) ) { set . add ( corshttpmethods . valueof ( st . nexttoken ( ) ) ) ; } return set ; }	Split a delimiter separated string into a EnumSet of CorsHttpMethods.
public synchronized void updatekey ( final byte [ ] key ) { if ( key == null || key . length == num_ ) { throw new illegalargumentexception ( sr . invalid_key ) ; } this . key = key ; this . hmacsha256 = null ; }	Sets the name of the access key to be used when signing the request.
public synchronized mac gethmac256 ( ) throws invalidkeyexception { if ( this . hmacsha256 == null ) {	Gets the HmacSha256 associated with the account key.
private static void validateipaddress ( string ipaddress ) { try { @ suppresswarnings ( str_ ) inet4address address = ( inet4address ) inet4address . getbyname ( ipaddress ) ; } catch ( exception ex ) { throw new illegalargumentexception ( string . format ( sr . invalid_ip_address , ipaddress ) , ex ) ; } }	Validate that the IP address is IPv4.
public static byte [ ] decode ( final string data ) { if ( data == null ) { throw new illegalargumentexception ( sr . string_not_valid ) ; } int bytearraylength = num_ * data . length ( ) / num_ ; if ( data . endswith ( str_ ) ) { bytearraylength -= num_ ; } else if ( data . endswith ( str_ ) ) { bytearraylength -= num_ ; } final byte [ ] retarray = new byte [ bytearraylength ] ; int bytedex = num_ ; int chardex = num_ ; for ( ; chardex < data . length ( ) ; chardex += num_ ) {	Decodes a given Base64 string into its corresponding byte array.
public static string encode ( final byte [ ] data ) { final stringbuilder builder = new stringbuilder ( ) ; final int dataremainder = data . length % num_ ; int j = num_ ; int n = num_ ; for ( ; j < data . length ; j += num_ ) { if ( j < data . length - dataremainder ) { n = ( ( data [ j ] & num_ ) << num_ ) + ( ( data [ j + num_ ] & num_ ) << num_ ) + ( data [ j + num_ ] & num_ ) ; } else { if ( dataremainder == num_ ) { n = ( data [ j ] & num_ ) << num_ ; } else if ( dataremainder == num_ ) { n = ( ( data [ j ] & num_ ) << num_ ) + ( ( data [ j + num_ ] & num_ ) << num_ ) ; } }	Encodes a byte array as a Base64 string.
public static boolean validateisbase64string ( final string data ) { if ( data == null || data . length ( ) % num_ != num_ ) { return bool_ ; } for ( int m = num_ ; m < data . length ( ) ; m ++ ) { final byte charbyte = ( byte ) data . charat ( m ) ;	Determines whether the given string contains only Base64 characters.
public static void validatecontainername ( string containername ) { if ( ! ( str_ . equals ( containername ) || str_ . equals ( containername ) ) ) { namevalidator . validatesharecontainerqueuehelper ( containername , sr . container ) ; } }	Checks if a container name is valid.
public static void validateblobname ( string blobname ) { if ( utility . isnulloremptyorwhitespace ( blobname ) ) { throw new illegalargumentexception ( string . format ( utility . locale_us , sr . resource_name_empty , sr . blob ) ) ; } if ( blobname . length ( ) < namevalidator . blob_file_directory_min_length || blobname . length ( ) > namevalidator . blob_max_length ) { throw new illegalargumentexception ( string . format ( utility . locale_us , sr . invalid_resource_name_length , sr . blob , namevalidator . blob_file_directory_min_length , namevalidator . blob_max_length ) ) ; } int slashcount = num_ ; for ( int i = num_ ; i < blobname . length ( ) ; i ++ ) { if ( blobname . charat ( i ) == str_ ) { slashcount ++ ; } } if ( slashcount >= num_ ) { throw new illegalargumentexception ( sr . too_many_path_segments ) ; } }	Checks if a blob name is valid.
public static void validatefilename ( string filename ) { namevalidator . validatefiledirectoryhelper ( filename , sr . file ) ; if ( filename . endswith ( str_ ) ) { throw new illegalargumentexception ( string . format ( utility . locale_us , sr . invalid_resource_name , sr . file ) ) ; } for ( string s : namevalidator . reserved_file_names ) { if ( s . equalsignorecase ( filename ) ) { throw new illegalargumentexception ( string . format ( utility . locale_us , sr . invalid_resource_reserved_name , sr . file ) ) ; } } }	Checks if a file name is valid.
public static void validatetablename ( string tablename ) { if ( utility . isnulloremptyorwhitespace ( tablename ) ) { throw new illegalargumentexception ( string . format ( utility . locale_us , sr . resource_name_empty , sr . table ) ) ; } if ( tablename . length ( ) < namevalidator . container_share_queue_table_min_length || tablename . length ( ) > namevalidator . container_share_queue_table_max_length ) { throw new illegalargumentexception ( string . format ( utility . locale_us , sr . invalid_resource_name_length , sr . table , namevalidator . container_share_queue_table_min_length , namevalidator . container_share_queue_table_max_length ) ) ; } if ( ! ( namevalidator . table_regex . matcher ( tablename ) . matches ( ) || namevalidator . metrics_table_regex . matcher ( tablename ) . matches ( ) || tablename . equalsignorecase ( str_ ) ) ) { throw new illegalargumentexception ( string . format ( utility . locale_us , sr . invalid_resource_name , sr . table ) ) ; } }	Checks if a table name is valid.
@ doesservicerequest public iterable < cloudfileshare > listshares ( final string prefix ) { return this . listshareswithprefix ( prefix , enumset . noneof ( sharelistingdetails . class ) , null , null ) ; }	Returns an enumerable collection of shares whose names begin with the specified prefix for this File serviceclient.
@ doesservicerequest public resultsegment < cloudfileshare > listsharessegmented ( ) throws storageexception { return this . listsharessegmented ( null , enumset . noneof ( sharelistingdetails . class ) , null , null , null , null ) ; }	Returns a result segment of an enumerable collection of shares for this File service client.
@ doesservicerequest public resultsegment < cloudfileshare > listsharessegmented ( final string prefix ) throws storageexception { return this . listshareswithprefixsegmented ( prefix , enumset . noneof ( sharelistingdetails . class ) , null , null , null , null ) ; }	Returns a result segment of an enumerable collection of shares whose names begin with the specifiedprefix for this File service client.
public static void setreflectedentitycachedisabled ( boolean disablereflectedentitycache ) { if ( tableserviceentity . reflectedentitycache != null && disablereflectedentitycache ) { tableserviceentity . reflectedentitycache . clear ( ) ; } tableserviceentity . disablereflectedentitycache = disablereflectedentitycache ; }	Sets a boolean representing whether or not the reflected entity cache is disabled.
public static string getdate ( final httpurlconnection request ) { final string retstring = request . getheaderfield ( str_ ) ; return retstring == null ? request . getheaderfield ( constants . headerconstants . date ) : retstring ; }	Gets the Date.
public static hashmap < string , string > getmetadata ( final httpurlconnection request ) { return getvaluesbyheaderprefix ( request , constants . headerconstants . prefix_for_storage_metadata ) ; }	Gets the metadata from the request The response from server.
public static boolean isserverrequestencrypted ( httpurlconnection request ) { return constants . true . equals ( request . getheaderfield ( constants . headerconstants . server_request_encrypted ) ) ; }	Gets if the request was encrypted by the server.
public static storageextendederrorinformation getextendederrorinformation ( final reader reader , final tablepayloadformat format ) throws jsonparseexception , ioexception { jsonfactory jsonfactory = new jsonfactory ( ) ; jsonparser parser = jsonfactory . createparser ( reader ) ; try { final storageextendederrorinformation errorinfo = new storageextendederrorinformation ( ) ; if ( ! parser . hascurrenttoken ( ) ) { parser . nexttoken ( ) ; } jsonutilities . assertisstartobjectjsontoken ( parser ) ; parser . nexttoken ( ) ; jsonutilities . assertisfieldnamejsontoken ( parser ) ; jsonutilities . assertisexpectedfieldname ( parser , str_ ) ;	Gets the Extended Error information.
public static storageextendederrorinformation parseerrordetails ( storagerequest < cloudtableclient , ? , ? > request ) { try { if ( request == null || request . getconnection ( ) . geterrorstream ( ) == null ) { return null ; } return getextendederrorinformation ( new inputstreamreader ( request . getconnection ( ) . geterrorstream ( ) ) , tablepayloadformat . json ) ; } catch ( exception e ) { return null ; } }	Parse the table extended error information from the response body.
private static hashmap < string , string [ ] > parsejsonerrorexception ( jsonparser parser ) throws jsonparseexception , ioexception { hashmap < string , string [ ] > additionaldetails = new hashmap < string , string [ ] > ( ) ; parser . nexttoken ( ) ; jsonutilities . assertisstartobjectjsontoken ( parser ) ; parser . nexttoken ( ) ; jsonutilities . assertisfieldnamejsontoken ( parser ) ; while ( parser . getcurrenttoken ( ) != jsontoken . end_object ) { if ( parser . getcurrentname ( ) . equals ( tableconstants . errorconstants . error_message ) ) { parser . nexttoken ( ) ; additionaldetails . put ( tableconstants . errorconstants . error_message , new string [ ] { parser . getvalueasstring ( ) } ) ; } else if ( parser . getcurrentname ( ) . equals ( tableconstants . errorconstants . error_exception_type ) ) { parser . nexttoken ( ) ; additionaldetails . put ( tableconstants . errorconstants . error_exception_type , new string [ ] { parser . getvalueasstring ( ) } ) ; } else if ( parser . getcurrentname ( ) . equals ( tableconstants . errorconstants . error_exception_stack_trace ) ) { parser . nexttoken ( ) ; additionaldetails . put ( constants . error_exception_stack_trace , new string [ ] { parser . getvalueasstring ( ) } ) ; } parser . nexttoken ( ) ; } return additionaldetails ; }	Parses the error exception details from the Json-formatted response.
public static < t extends sharedaccesspolicy > hashmap < string , t > getaccessidentifiers ( final inputstream stream , final class < t > cls ) throws parserconfigurationexception , saxexception , ioexception { saxparser saxparser = utility . getsaxparser ( ) ; sharedaccesspolicyhandler < t > handler = new sharedaccesspolicyhandler < t > ( cls ) ; saxparser . parse ( stream , handler ) ; return handler . policies ; }	RESERVED FOR INTERNAL USE.
public static copystate getcopystate ( final httpurlconnection request ) throws urisyntaxexception , parseexception { string copystatusstring = request . getheaderfield ( constants . headerconstants . copy_status ) ; if ( ! utility . isnullorempty ( copystatusstring ) ) { final copystate copystate = new copystate ( ) ; copystate . setstatus ( copystatus . parse ( copystatusstring ) ) ; copystate . setcopyid ( request . getheaderfield ( constants . headerconstants . copy_id ) ) ; copystate . setstatusdescription ( request . getheaderfield ( constants . headerconstants . copy_status_description ) ) ; final string copyprogressstring = request . getheaderfield ( constants . headerconstants . copy_progress ) ; if ( ! utility . isnullorempty ( copyprogressstring ) ) { string [ ] progresssequence = copyprogressstring . split ( str_ ) ; copystate . setbytescopied ( long . parselong ( progresssequence [ num_ ] ) ) ; copystate . settotalbytes ( long . parselong ( progresssequence [ num_ ] ) ) ; } final string copysourcestring = request . getheaderfield ( constants . headerconstants . copy_source ) ; if ( ! utility . isnullorempty ( copysourcestring ) ) { copystate . setsource ( new uri ( copysourcestring ) ) ; } final string copycompletiontimestring = request . getheaderfield ( constants . headerconstants . copy_completion_time ) ; if ( ! utility . isnullorempty ( copycompletiontimestring ) ) { copystate . setcompletiontime ( utility . parserfc1123datefromstringingmt ( copycompletiontimestring ) ) ; } return copystate ; } else { return null ; } }	Gets the copyState.
public static fileshareattributes getfileshareattributes ( final httpurlconnection request , final boolean usepathstyleuris ) throws storageexception { final fileshareattributes shareattributes = new fileshareattributes ( ) ; final fileshareproperties shareproperties = shareattributes . getproperties ( ) ; shareproperties . setetag ( baseresponse . getetag ( request ) ) ; shareproperties . setsharequota ( parsesharequota ( request ) ) ; shareproperties . setlastmodified ( new date ( request . getlastmodified ( ) ) ) ; shareattributes . setmetadata ( getmetadata ( request ) ) ; return shareattributes ; }	Gets the FileShareAttributes from the given request.
public static filedirectoryattributes getfiledirectoryattributes ( final httpurlconnection request , final boolean usepathstyleuris ) throws storageexception { final filedirectoryattributes directoryattributes = new filedirectoryattributes ( ) ; uri tempuri ; try { tempuri = pathutility . stripsingleuriqueryandfragment ( request . geturl ( ) . touri ( ) ) ; } catch ( final urisyntaxexception e ) { final storageexception wrappedunexpectedexception = utility . generatenewunexpectedstorageexception ( e ) ; throw wrappedunexpectedexception ; } directoryattributes . setname ( pathutility . getdirectorynamefromuri ( tempuri , usepathstyleuris ) ) ; final filedirectoryproperties directoryproperties = directoryattributes . getproperties ( ) ; directoryproperties . setetag ( baseresponse . getetag ( request ) ) ; directoryproperties . setlastmodified ( new date ( request . getlastmodified ( ) ) ) ; directoryattributes . setmetadata ( getmetadata ( request ) ) ; directoryproperties . setserverencrypted ( constants . true . equals ( request . getheaderfield ( constants . headerconstants . server_encrypted ) ) ) ; return directoryattributes ; }	Gets the FileDirectoryAttributes from the given request.
public static fileattributes getfileattributes ( final httpurlconnection request , final storageuri resourceuri ) throws urisyntaxexception , parseexception { final fileattributes fileattributes = new fileattributes ( ) ; final fileproperties properties = fileattributes . getproperties ( ) ; properties . setcachecontrol ( request . getheaderfield ( constants . headerconstants . cache_control ) ) ; properties . setcontentdisposition ( request . getheaderfield ( constants . headerconstants . content_disposition ) ) ; properties . setcontentencoding ( request . getheaderfield ( constants . headerconstants . content_encoding ) ) ; properties . setcontentlanguage ( request . getheaderfield ( constants . headerconstants . content_language ) ) ;	Gets the CloudFileAttributes from the given request.
static string gethttpverbforoperation ( final tableoperationtype operationtype ) { if ( operationtype == tableoperationtype . insert ) { return str_ ; } else if ( operationtype == tableoperationtype . delete ) { return str_ ; } else if ( operationtype == tableoperationtype . merge || operationtype == tableoperationtype . insert_or_merge ) { return str_ ; } else if ( operationtype == tableoperationtype . replace || operationtype == tableoperationtype . insert_or_replace ) { return str_ ; } else if ( operationtype == tableoperationtype . retrieve ) { return str_ ; } else { throw new illegalargumentexception ( sr . unknown_table_operation ) ; } }	Reserved for internal use.
public void fireevent ( final event_type event ) { for ( final storageevent < event_type > listener : this . listeners ) { listener . eventoccurred ( event ) ; } }	Fires the event to all subscribed event listeners.
private static void firesendingrequestevent ( operationcontext opcontext , httpurlconnection request , requestresult result ) { if ( opcontext . getsendingrequesteventhandler ( ) . haslisteners ( ) || operationcontext . getglobalsendingrequesteventhandler ( ) . haslisteners ( ) ) { sendingrequestevent event = new sendingrequestevent ( opcontext , request , result ) ; opcontext . getsendingrequesteventhandler ( ) . fireevent ( event ) ; operationcontext . getglobalsendingrequesteventhandler ( ) . fireevent ( event ) ; } }	Fires events representing that a request will be sent.
private static void fireresponsereceivedevent ( operationcontext opcontext , httpurlconnection request , requestresult result ) { if ( opcontext . getresponsereceivedeventhandler ( ) . haslisteners ( ) || operationcontext . getglobalresponsereceivedeventhandler ( ) . haslisteners ( ) ) { responsereceivedevent event = new responsereceivedevent ( opcontext , request , result ) ; opcontext . getresponsereceivedeventhandler ( ) . fireevent ( event ) ; operationcontext . getglobalresponsereceivedeventhandler ( ) . fireevent ( event ) ; } }	Fires events representing that a response has been received.
private static void fireerrorreceivingresponseevent ( operationcontext opcontext , httpurlconnection request , requestresult result ) { if ( opcontext . geterrorreceivingresponseeventhandler ( ) . haslisteners ( ) || operationcontext . getglobalerrorreceivingresponseeventhandler ( ) . haslisteners ( ) ) { errorreceivingresponseevent event = new errorreceivingresponseevent ( opcontext , request , result ) ; opcontext . geterrorreceivingresponseeventhandler ( ) . fireevent ( event ) ; operationcontext . getglobalerrorreceivingresponseeventhandler ( ) . fireevent ( event ) ; } }	Fires events representing that an error occurred when receiving the response.
private static void firerequestcompletedevent ( operationcontext opcontext , httpurlconnection request , requestresult result ) { if ( opcontext . getrequestcompletedeventhandler ( ) . haslisteners ( ) || operationcontext . getglobalrequestcompletedeventhandler ( ) . haslisteners ( ) ) { requestcompletedevent event = new requestcompletedevent ( opcontext , request , result ) ; opcontext . getrequestcompletedeventhandler ( ) . fireevent ( event ) ; operationcontext . getglobalrequestcompletedeventhandler ( ) . fireevent ( event ) ; } }	Fires events representing that a response received from the service is fully processed.
private static void fireretryingevent ( operationcontext opcontext , httpurlconnection request , requestresult result , retrycontext retrycontext ) { if ( opcontext . getretryingeventhandler ( ) . haslisteners ( ) || operationcontext . getglobalretryingeventhandler ( ) . haslisteners ( ) ) { retryingevent event = new retryingevent ( opcontext , request , result , retrycontext ) ; opcontext . getretryingeventhandler ( ) . fireevent ( event ) ; operationcontext . getglobalretryingeventhandler ( ) . fireevent ( event ) ; } }	Fires events representing that a request will be retried.
public static void assertcontinuationtype ( final resultcontinuation continuationtoken , final resultcontinuationtype continuationtype ) { if ( continuationtoken != null ) { if ( ! ( continuationtoken . getcontinuationtype ( ) == resultcontinuationtype . none || continuationtoken . getcontinuationtype ( ) == continuationtype ) ) { final string errormessage = string . format ( utility . locale_us , sr . unexpected_continuation_type , continuationtoken . getcontinuationtype ( ) , continuationtype ) ; throw new illegalargumentexception ( errormessage ) ; } } }	Asserts a continuation token is of the specified type.
public static void assertinbounds ( final string param , final long value , final long min , final long max ) { if ( value < min || value > max ) { throw new illegalargumentexception ( string . format ( sr . parameter_not_in_range , param , min , max ) ) ; } }	Asserts that the specified integer is in the valid range.
public static void assertgreaterthanorequal ( final string param , final long value , final long min ) { if ( value < min ) { throw new illegalargumentexception ( string . format ( sr . parameter_should_be_greater_or_equal , param , min ) ) ; } }	Asserts that the specified value is greater than or equal to the min value.
public static boolean validatemaxexecutiontimeout ( long operationexpirytimeinms , long additionalinterval ) { if ( operationexpirytimeinms != null ) { long currenttime = new date ( ) . gettime ( ) ; return operationexpirytimeinms < currenttime + additionalinterval ; } return bool_ ; }	Returns a value representing whether the maximum execution time would be surpassed.
public static int getremainingtimeout ( long operationexpirytimeinms , integer timeoutintervalinms ) throws storageexception { if ( operationexpirytimeinms != null ) { long remainingtime = operationexpirytimeinms - new date ( ) . gettime ( ) ; if ( remainingtime > integer . max_value ) { return integer . max_value ; } else if ( remainingtime > num_ ) { return ( int ) remainingtime ; } else { timeoutexception timeoutexception = new timeoutexception ( sr . maximum_execution_timeout_exception ) ; storageexception translatedexception = new storageexception ( storageerrorcodestrings . operation_timed_out , sr . maximum_execution_timeout_exception , constants . headerconstants . http_unused_306 , null , timeoutexception ) ; throw translatedexception ; } } else if ( timeoutintervalinms != null ) { return timeoutintervalinms + constants . default_read_timeout ; } else { return constants . default_read_timeout ; } }	Returns a value representing the remaining time before the operation expires.
public static boolean determinepathstylefromuri ( final uri baseuri ) { string path = baseuri . getpath ( ) ; if ( path != null && path . startswith ( str_ ) ) { path = path . substring ( num_ ) ; }	Returns a value that indicates whether a specified URI is a path-style URI.
private static boolean ishostdnsname ( uri uri ) { string host = uri . gethost ( ) ; for ( int i = num_ ; i < host . length ( ) ; i ++ ) { char hostchar = host . charat ( i ) ; if ( ! character . isdigit ( hostchar ) && ! ( hostchar == str_ ) ) { return bool_ ; } } return bool_ ; }	Returns a boolean indicating whether the host of the specified URI is DNS.
public static string formatetag ( final string etag ) { if ( etag . startswith ( str_ ) && etag . endswith ( str_ ) ) { return etag ; } else { return string . format ( str_ , etag ) ; } }	Reads character data for the Etag element from an XML stream reader.
public static storageexception generatenewunexpectedstorageexception ( final exception cause ) { final storageexception exceptionref = new storageexception ( storageerrorcode . none . tostring ( ) , str_ , num_ ,	Returns an unexpected storage exception.
public static string getstandardheadervalue ( final httpurlconnection conn , final string headername ) { final string headervalue = conn . getrequestproperty ( headername ) ;	Returns the standard header value from the specified connection request, or an empty string if no header valuehas been specified for the request.
public static date parsedatefromstring ( final string value , final string pattern , final timezone timezone ) throws parseexception { final dateformat rfc1123format = new simpledateformat ( pattern , utility . locale_us ) ; rfc1123format . settimezone ( timezone ) ; return rfc1123format . parse ( value ) ; }	Returns a GMT date in the specified format.
public static date parserfc1123datefromstringingmt ( final string value ) throws parseexception { final dateformat format = new simpledateformat ( rfc1123_gmt_pattern , utility . locale_us ) ; format . settimezone ( gmt_zone ) ; return format . parse ( value ) ; }	Returns a GMT date for the specified string in the RFC1123 pattern.
public static void loghttperror ( storageexception ex , operationcontext opcontext ) { if ( logger . shouldlog ( opcontext , log . debug ) ) { try { stringbuilder bld = new stringbuilder ( ) ; bld . append ( str_ ) ; bld . append ( str_ ) ; bld . append ( ex . gethttpstatuscode ( ) ) ; bld . append ( str_ ) ; bld . append ( ex . getmessage ( ) ) ; bld . append ( str_ ) ; bld . append ( ex . geterrorcode ( ) ) ; storageextendederrorinformation extendederror = ex . getextendederrorinformation ( ) ; if ( extendederror != null ) { bld . append ( str_ ) ; bld . append ( extendederror . geterrormessage ( ) ) ; hashmap < string , string [ ] > details = extendederror . getadditionaldetails ( ) ; if ( details != null ) { bld . append ( str_ ) ; for ( entry < string , string [ ] > detail : details . entryset ( ) ) { bld . append ( detail . getkey ( ) ) ; bld . append ( str_ ) ; for ( string value : detail . getvalue ( ) ) { bld . append ( value ) ; } bld . append ( str_ ) ; } bld . setcharat ( bld . length ( ) - num_ , str_ ) ; } bld . append ( str_ ) ; } logger . debug ( opcontext , bld . tostring ( ) ) ; } catch ( exception e ) {	Serializes the parsed StorageException.
public static void loghttpresponse ( httpurlconnection conn , operationcontext opcontext ) throws ioexception { if ( logger . shouldlog ( opcontext , log . verbose ) ) { try { stringbuilder bld = new stringbuilder ( ) ;	Logs the HttpURLConnection response.
protected static string trimend ( final string value , final char trimchar ) { int stopdex = value . length ( ) - num_ ; while ( stopdex > num_ && value . charat ( stopdex ) == trimchar ) { stopdex -- ; } return stopdex == value . length ( ) - num_ ? value : value . substring ( stopdex ) ; }	Trims the specified character from the end of a string.
public static string trimstart ( final string value ) { int spacedex = num_ ; while ( spacedex < value . length ( ) && value . charat ( spacedex ) == str_ ) { spacedex ++ ; } return value . substring ( spacedex ) ; }	Trims whitespace from the beginning of a string.
public static date parsedate ( string datestring ) { string pattern = max_precision_pattern ; switch ( datestring . length ( ) ) { case num_ :	Given a String representing a date in a form of the ISO8601 pattern, generates a Date representing itwith up to millisecond precision.
public static requestlocationmode getlistinglocationmode ( resultcontinuation token ) { if ( ( token != null ) && token . gettargetlocation ( ) != null ) { switch ( token . gettargetlocation ( ) ) { case primary : return requestlocationmode . primary_only ; case secondary : return requestlocationmode . secondary_only ; default : throw new illegalargumentexception ( string . format ( sr . argument_out_of_range_error , str_ , token . gettargetlocation ( ) ) ) ; } } return requestlocationmode . primary_or_secondary ; }	Determines which location can the listing command target by looking at thecontinuation token.
protected static final queuerequestoptions populateandapplydefaults ( queuerequestoptions options , final cloudqueueclient client ) { queuerequestoptions modifiedoptions = new queuerequestoptions ( options ) ; requestoptions . populaterequestoptions ( modifiedoptions , client . getdefaultrequestoptions ( ) , bool_ ) ; queuerequestoptions . applydefaults ( modifiedoptions ) ; return modifiedoptions ; }	Populates the default timeout and retry policy from client if they are not set.
public string readstring ( ) throws ioexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return temp ; } }	Read a String from the stream.
public string readquotedstring ( ) throws ioexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return temp ; } }	Read a quoted String from the stream.
public boolean readboolean ( ) throws ioexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return boolean . parseboolean ( temp ) ; } }	Read a Boolean from the stream.
public date readdate ( dateformat format ) throws ioexception , parseexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return format . parse ( temp ) ; } }	Read a Date from the stream.
public double readdouble ( ) throws ioexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return double . parsedouble ( temp ) ; } }	Read a Double from the stream.
public uuid readuuid ( ) throws ioexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return uuid . fromstring ( temp ) ; } }	Read a UUID from the stream.
public integer readinteger ( ) throws ioexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return integer . parseint ( temp ) ; } }	Read an Integer from the stream.
public long readlong ( ) throws ioexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return long . parselong ( temp ) ; } }	Read a Long from the stream.
public uri readuri ( ) throws urisyntaxexception , ioexception { string temp = this . readfield ( bool_ ) ; if ( utility . isnullorempty ( temp ) ) { return null ; } else { return new uri ( html . fromhtml ( temp ) . tostring ( ) ) ; } }	Read a URI from the stream.
private void readdelimiter ( char delimiter ) throws ioexception { if ( this . isendoffile ( ) ) { throw new eofexception ( sr . log_stream_end_error ) ; } else { int read = this . read ( ) ; if ( read == - num_ || ( char ) read != delimiter ) { throw new illegalstateexception ( sr . log_stream_delimiter_error ) ; } } }	Read a delimiter from the stream.
private boolean trypeekdelimiter ( char delimiter ) throws ioexception { if ( this . isendoffile ( ) ) { throw new eofexception ( sr . log_stream_end_error ) ; } else { if ( ( char ) this . peek ( ) != delimiter ) { return bool_ ; } else { return bool_ ; } } }	Checks to see if the next character is the delimiter expected.
private string readfield ( boolean isquotedstring ) throws ioexception { if ( ! this . isfirstfieldinrecord ) { this . readdelimiter ( logrecordstreamreader . field_delimiter ) ; } else { this . isfirstfieldinrecord = bool_ ; }	Read a field from the stream.
@ override public retrypolicy createinstance ( final operationcontext opcontext ) { return new retryexponentialretry ( this . resolvedminbackoff , this . deltabackoffintervalinms , this . resolvedmaxbackoff , this . maximumattempts ) ; }	Generates a new retry policy for the current request attempt.
@ override @ doesservicerequest public boolean hasnext ( ) { while ( this . currentsegment == null || ( ! this . currentsegmentiterator . hasnext ( ) && this . currentsegment != null && this . currentsegment . gethasmoreresults ( ) ) ) { try { this . currentsegment = executionengine . executewithretry ( this . client , this . parentobject , this . segmentgenerator , this . policyfactory , this . opcontext ) ; } catch ( final storageexception e ) { final nosuchelementexception ex = new nosuchelementexception ( sr . enumeration_error ) ; ex . initcause ( e ) ; throw ex ; } this . currentsegmentiterator = this . currentsegment . getresults ( ) . iterator ( ) ; if ( ! this . currentsegmentiterator . hasnext ( ) && ! this . currentsegment . gethasmoreresults ( ) ) { return bool_ ; } } return this . currentsegmentiterator . hasnext ( ) ; }	Indicates if the iterator has another element.
protected void setclazztype ( final class < ? extends tableentity > clazztype ) { utility . assertnotnull ( str_ , clazztype ) ; utility . checknullaryctor ( clazztype ) ; this . clazztype = clazztype ; }	Reserved for internal use.
protected void setresolver ( final entityresolver < ? > resolver ) { utility . assertnotnull ( sr . query_requires_valid_classtype_or_resolver , resolver ) ; this . resolver = resolver ; }	Reserved for internal use.
private static void writemimeboundary ( final outputstreamwriter outwriter , final string boundaryid ) throws ioexception { outwriter . write ( string . format ( str_ , boundaryid ) ) ; }	Reserved for internal use.
private static void writemimeboundaryclosure ( final outputstreamwriter outwriter , final string boundaryid ) throws ioexception { outwriter . write ( string . format ( str_ , boundaryid ) ) ; }	Reserved for internal use.
private static void writemimecontenttype ( final outputstreamwriter outwriter , final string boundaryname ) throws ioexception { outwriter . write ( string . format ( str_ , boundaryname ) ) ; }	Reserved for internal use.
public void add ( final string name , final string value ) throws storageexception { if ( utility . isnullorempty ( name ) ) { throw new illegalargumentexception ( sr . query_parameter_null_or_empty ) ; } this . insertkeyvalue ( name , value ) ; }	Adds a value to the URI with escaping.
public uri addtouri ( final uri uri ) throws urisyntaxexception , storageexception { final string origrawquery = uri . getrawquery ( ) ; final string rawfragment = uri . getrawfragment ( ) ; final string uristring = uri . resolve ( uri ) . toasciistring ( ) ; final hashmap < string , string [ ] > origquerymap = pathutility . parsequerystring ( origrawquery ) ;	Add query parameter to an existing Uri.
public static void addoptionalheader ( final httpurlconnection request , final string name , final string value ) { if ( value != null && ! value . equals ( constants . empty_string ) ) { request . setrequestproperty ( name , value ) ; } }	Adds the optional header.
public static httpurlconnection createurlconnection ( final uri uri , final requestoptions options , uriquerybuilder builder , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { if ( builder == null ) { builder = new uriquerybuilder ( ) ; } if ( options . gettimeoutintervalinms ( ) != null && options . gettimeoutintervalinms ( ) != num_ ) { builder . add ( timeout , string . valueof ( options . gettimeoutintervalinms ( ) / num_ ) ) ; } final url resourceurl = builder . addtouri ( uri ) . tourl ( ) ;	Creates the web request.
public static httpurlconnection delete ( final uri uri , final requestoptions options , uriquerybuilder builder , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { if ( builder == null ) { builder = new uriquerybuilder ( ) ; } final httpurlconnection retconnection = createurlconnection ( uri , options , builder , opcontext ) ; retconnection . setrequestmethod ( constants . http_delete ) ; return retconnection ; }	Deletes the specified resource.
public static httpurlconnection getserviceproperties ( final uri uri , final requestoptions options , uriquerybuilder builder , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { if ( builder == null ) { builder = new uriquerybuilder ( ) ; } builder . add ( constants . queryconstants . component , constants . queryconstants . properties ) ; builder . add ( constants . queryconstants . resourcetype , service ) ; final httpurlconnection retconnection = createurlconnection ( uri , options , builder , opcontext ) ; retconnection . setrequestmethod ( constants . http_get ) ; return retconnection ; }	Creates a HttpURLConnection used to retrieve the Analytics service properties from the storage service.
public static string getuseragent ( ) { if ( useragent == null ) { string useragentcomment = string . format ( utility . locale_us , str_ , android . os . build . version . release , android . os . build . brand , android . os . build . model ) ; useragent = string . format ( str_ , constants . headerconstants . user_agent_prefix , constants . headerconstants . user_agent_version , useragentcomment ) ; } return useragent ; }	Gets the user agent to send over the wire to identify the client.
public static httpurlconnection setmetadata ( final uri uri , final requestoptions options , uriquerybuilder builder , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { if ( builder == null ) { builder = new uriquerybuilder ( ) ; } builder . add ( constants . queryconstants . component , metadata ) ; final httpurlconnection retconnection = createurlconnection ( uri , options , builder , opcontext ) ; retconnection . setfixedlengthstreamingmode ( num_ ) ; retconnection . setdooutput ( bool_ ) ; retconnection . setrequestmethod ( constants . http_put ) ; return retconnection ; }	Sets the metadata. Sign with 0 length.
public static httpurlconnection setserviceproperties ( final uri uri , final requestoptions options , uriquerybuilder builder , final operationcontext opcontext ) throws ioexception , urisyntaxexception , storageexception { if ( builder == null ) { builder = new uriquerybuilder ( ) ; } builder . add ( constants . queryconstants . component , constants . queryconstants . properties ) ; builder . add ( constants . queryconstants . resourcetype , service ) ; final httpurlconnection retconnection = createurlconnection ( uri , options , builder , opcontext ) ; retconnection . setdooutput ( bool_ ) ; retconnection . setrequestmethod ( constants . http_put ) ; return retconnection ; }	Creates a HttpURLConnection used to set the Analytics service properties on the storage service.
@ override @ doesservicerequest public void close ( ) throws ioexception { try {	Closes this output stream and releases any system resources associated with this stream.
@ doesservicerequest private void commit ( ) throws storageexception , urisyntaxexception { if ( this . options . getstorefilecontentmd5 ( ) ) { this . parentfileref . getproperties ( ) . setcontentmd5 ( base64 . encode ( this . md5digest . digest ( ) ) ) ; } this . parentfileref . uploadproperties ( this . accesscondition , this . options , this . opcontext ) ; }	Commits the file.
@ doesservicerequest private synchronized void dispatchwrite ( final int writelength ) throws ioexception { if ( writelength == num_ ) { return ; } callable < void > worker = null ; if ( this . outstandingrequests > this . options . getconcurrentrequestcount ( ) * num_ ) { this . waitfortasktocomplete ( ) ; } final bytearrayinputstream bufferref = new bytearrayinputstream ( this . outbuffer . tobytearray ( ) ) ; final cloudfile fileref = this . parentfileref ; long tempoffset = this . currentoffset ; long templength = writelength ; final long opwritelength = templength ; final long opoffset = tempoffset ; this . currentoffset += writelength ; worker = new callable < void > ( ) { @ override public void call ( ) { try { fileref . uploadrange ( bufferref , opoffset , opwritelength , fileoutputstream . this . accesscondition , fileoutputstream . this . options , fileoutputstream . this . opcontext ) ; } catch ( final ioexception e ) { synchronized ( fileoutputstream . this . lasterrorlock ) { fileoutputstream . this . streamfaulted = bool_ ; fileoutputstream . this . lasterror = e ; } } catch ( final storageexception e ) { synchronized ( fileoutputstream . this . lasterrorlock ) { fileoutputstream . this . streamfaulted = bool_ ; fileoutputstream . this . lasterror = utility . initioexception ( e ) ; } } catch ( urisyntaxexception e ) { synchronized ( fileoutputstream . this . lasterrorlock ) { fileoutputstream . this . streamfaulted = bool_ ; fileoutputstream . this . lasterror = utility . initioexception ( e ) ; } } return null ; } } ;	Dispatches a write operation for a given length.
@ override @ doesservicerequest public synchronized void flush ( ) throws ioexception { this . checkstreamstate ( ) ;	Flushes this output stream and forces any buffered output bytes to be written out.
private void waitfortasktocomplete ( ) throws ioexception { try { final future < void > future = this . completionservice . take ( ) ; future . get ( ) ; } catch ( final interruptedexception e ) { throw utility . initioexception ( e ) ; } catch ( final executionexception e ) { throw utility . initioexception ( e ) ; } this . outstandingrequests -- ; }	Waits for one task to complete.
@ override @ doesservicerequest public void write ( final byte [ ] data , final int offset , final int length ) throws ioexception { if ( offset < num_ || length < num_ || length > data . length - offset ) { throw new indexoutofboundsexception ( ) ; } this . writeinternal ( data , offset , length ) ; }	Writes length bytes from the specified byte array starting at offset to this output stream.
@ doesservicerequest public void write ( final inputstream sourcestream , final long writelength ) throws ioexception , storageexception { utility . writetooutputstream ( sourcestream , this , writelength , bool_ , bool_ , this . opcontext , this . options , bool_ ) ; }	Writes all data from the InputStream to the File.
@ doesservicerequest private synchronized void writeinternal ( final byte [ ] data , int offset , int length ) throws ioexception { while ( length > num_ ) { this . checkstreamstate ( ) ; final int availablebufferbytes = this . internalwritethreshold - this . currentbufferedbytes ; final int nextwrite = math . min ( availablebufferbytes , length ) ;	Writes the data to the buffer and triggers writes to the service as needed.
private static string getdns ( string service , string base ) { if ( base == null ) { base = default_dns ; } return string . format ( dns_name_format , service , base ) ; }	This generates a domain name for the given service.
private static cloudstorageaccount tryconfiguredevstore ( final map < string , string > settings ) throws urisyntaxexception { if ( matchesspecification ( settings , allrequired ( use_development_storage_name ) , optional ( development_storage_proxy_uri_name ) ) ) { if ( ! boolean . parseboolean ( settings . get ( use_development_storage_name ) ) ) { throw new illegalargumentexception ( sr . invalid_connection_string_dev_store_not_true ) ; } uri devstoreproxyuri = null ; if ( settings . containskey ( development_storage_proxy_uri_name ) ) { devstoreproxyuri = new uri ( settings . get ( development_storage_proxy_uri_name ) ) ; } return getdevelopmentstorageaccount ( devstoreproxyuri ) ; } else { return null ; } }	Evaluates connection settings and returns a CloudStorageAccount representing Development Storage.
private static cloudstorageaccount tryconfigureserviceaccount ( final map < string , string > settings ) throws urisyntaxexception , invalidkeyexception { connectionstringfilter endpointsoptional = optional ( blob_endpoint_name , blob_secondary_endpoint_name , queue_endpoint_name , queue_secondary_endpoint_name , table_endpoint_name , table_secondary_endpoint_name , file_endpoint_name , file_secondary_endpoint_name ) ; connectionstringfilter primaryendpointrequired = atleastone ( blob_endpoint_name , queue_endpoint_name , table_endpoint_name , file_endpoint_name ) ; connectionstringfilter secondaryendpointsoptional = optional ( blob_secondary_endpoint_name , queue_secondary_endpoint_name , table_secondary_endpoint_name , file_secondary_endpoint_name ) ; connectionstringfilter automaticendpointsmatchspec = matchesexactly ( matchesall ( matchesone ( matchesall ( allrequired ( account_key_name ) ) ,	Evaluates connection settings and configures a CloudStorageAccount accordingly.
public cloudanalyticsclient createcloudanalyticsclient ( ) { if ( this . getblobstorageuri ( ) == null ) { throw new illegalargumentexception ( sr . blob_endpoint_not_configured ) ; } if ( this . gettablestorageuri ( ) == null ) { throw new illegalargumentexception ( sr . table_endpoint_not_configured ) ; } if ( this . credentials == null ) { throw new illegalargumentexception ( sr . missing_credentials ) ; } return new cloudanalyticsclient ( this . getblobstorageuri ( ) , this . gettablestorageuri ( ) , this . getcredentials ( ) ) ; }	Creates a new Analytics service client.
public cloudblobclient createcloudblobclient ( ) { if ( this . getblobstorageuri ( ) == null ) { throw new illegalargumentexception ( sr . blob_endpoint_not_configured ) ; } if ( this . credentials == null ) { throw new illegalargumentexception ( sr . missing_credentials ) ; } return new cloudblobclient ( this . getblobstorageuri ( ) , this . getcredentials ( ) ) ; }	Creates a new Blob service client.
public cloudfileclient createcloudfileclient ( ) { if ( this . getfilestorageuri ( ) == null ) { throw new illegalargumentexception ( sr . file_endpoint_not_configured ) ; } if ( this . credentials == null ) { throw new illegalargumentexception ( sr . missing_credentials ) ; } if ( ! storagecredentialshelper . cancredentialsgenerateclient ( this . credentials ) ) { throw new illegalargumentexception ( sr . credentials_cannot_sign_request ) ; } return new cloudfileclient ( this . getfilestorageuri ( ) , this . getcredentials ( ) ) ; }	Creates a new File service client.
public cloudqueueclient createcloudqueueclient ( ) { if ( this . getqueuestorageuri ( ) == null ) { throw new illegalargumentexception ( sr . queue_endpoint_not_configured ) ; } if ( this . credentials == null ) { throw new illegalargumentexception ( sr . missing_credentials ) ; } if ( ! storagecredentialshelper . cancredentialsgenerateclient ( this . credentials ) ) { throw new illegalargumentexception ( sr . credentials_cannot_sign_request ) ; } return new cloudqueueclient ( this . getqueuestorageuri ( ) , this . getcredentials ( ) ) ; }	Creates a new Queue service client.
public cloudtableclient createcloudtableclient ( ) { if ( this . gettablestorageuri ( ) == null ) { throw new illegalargumentexception ( sr . table_endpoint_not_configured ) ; } if ( this . credentials == null ) { throw new illegalargumentexception ( sr . missing_credentials ) ; } if ( ! storagecredentialshelper . cancredentialsgenerateclient ( this . credentials ) ) { throw new illegalargumentexception ( sr . credentials_cannot_sign_request ) ; } return new cloudtableclient ( this . gettablestorageuri ( ) , this . getcredentials ( ) ) ; }	Creates a new Table service client.
public string generatesharedaccesssignature ( sharedaccessaccountpolicy policy ) throws invalidkeyexception , storageexception { if ( ! storagecredentialshelper . cancredentialssignrequest ( this . getcredentials ( ) ) ) { throw new illegalargumentexception ( sr . cannot_create_sas_without_account_key ) ; } final string sig = sharedaccesssignaturehelper . generatesharedaccesssignaturehashforaccount ( this . credentials . getaccountname ( ) , policy , this . getcredentials ( ) ) ; final uriquerybuilder sasbuilder = sharedaccesssignaturehelper . generatesharedaccesssignatureforaccount ( policy , sig ) ; return sasbuilder . tostring ( ) ; }	Returns a shared access signature for the account.
protected string generaterequestidentity ( boolean issingleindexentry , final string entryname ) throws storageexception { if ( issingleindexentry ) { return string . format ( str_ , entryname . replace ( str_ , str_ ) ) ; } if ( this . optype == tableoperationtype . insert ) { return constants . empty_string ; } else { string pk = null ; string rk = null ; if ( this . optype == tableoperationtype . retrieve ) { final querytableoperation qop = ( querytableoperation ) this ; pk = qop . getpartitionkey ( ) ; rk = qop . getrowkey ( ) ; } else { pk = this . getentity ( ) . getpartitionkey ( ) ; rk = this . getentity ( ) . getrowkey ( ) ; } return string . format ( str_ , tableconstants . partition_key , pk . replace ( str_ , str_ ) , tableconstants . row_key , rk . replace ( str_ , str_ ) ) ; } }	Reserved for internal use.
protected string generaterequestidentitywithtable ( final string tablename ) throws storageexception { return string . format ( str_ , tablename , generaterequestidentity ( bool_ , null ) ) ; }	Reserved for internal use.
protected final void initialize ( operationcontext opcontext ) { requestresult currresult = new requestresult ( ) ; this . setresult ( currresult ) ; opcontext . appendrequestresult ( currresult ) ; this . setexception ( null ) ; this . setnonexceptionedretryablefailure ( bool_ ) ; this . setissent ( bool_ ) ; }	Resets the operation status flags between operations.
protected final storageexception materializeexception ( final operationcontext opcontext ) { if ( this . getexception ( ) != null ) { return this . getexception ( ) ; } return storageexception . translateexception ( this , null , opcontext ) ; }	Returns either the held exception from the operation if it is set, otherwise the translated exception.
public r postprocessresponse ( httpurlconnection connection , p parentobject , c client , operationcontext context , r storageobject ) throws exception { return storageobject ; }	Post-Stream Retrieval function.
public storageextendederrorinformation parseerrordetails ( ) { try { if ( this . getconnection ( ) == null || this . getconnection ( ) . geterrorstream ( ) == null ) { return null ; } return storageerrorhandler . getextendederrorinformation ( this . getconnection ( ) . geterrorstream ( ) ) ; } catch ( final exception e ) { return null ; } }	Returns extended error information for this request.
public void delete ( final tableentity entity ) { this . locktopartitionkey ( entity . getpartitionkey ( ) ) ; this . add ( tableoperation . delete ( entity ) ) ; }	Adds a table operation to delete the specified entity to the batch operation.
public void insert ( final tableentity entity , boolean echocontent ) { this . locktopartitionkey ( entity . getpartitionkey ( ) ) ; this . add ( tableoperation . insert ( entity , echocontent ) ) ; }	Adds a table operation to insert the specified entity to the batch operation.
public void insertormerge ( final tableentity entity ) { this . locktopartitionkey ( entity . getpartitionkey ( ) ) ; this . add ( tableoperation . insertormerge ( entity ) ) ; }	Adds a table operation to insert or merge the specified entity to the batch operation.
public void insertorreplace ( final tableentity entity ) { this . locktopartitionkey ( entity . getpartitionkey ( ) ) ; this . add ( tableoperation . insertorreplace ( entity ) ) ; }	Adds a table operation to insert or replace the specified entity to the batch operation.
public void merge ( final tableentity entity ) { this . locktopartitionkey ( entity . getpartitionkey ( ) ) ; this . add ( tableoperation . merge ( entity ) ) ; }	Adds a table operation to merge the specified entity to the batch operation.
@ override public tableoperation remove ( int index ) { tableoperation op = super . remove ( index ) ; checkresetentitylocks ( ) ; return op ; }	Removes the table operation at the specified index from the batch operation.
@ override public boolean removeall ( java . util . collection < ? > c ) { boolean ret = super . removeall ( c ) ; checkresetentitylocks ( ) ; return ret ; }	Removes all elements of the specified collection from the batch operation.
public void replace ( final tableentity entity ) { this . locktopartitionkey ( entity . getpartitionkey ( ) ) ; this . add ( tableoperation . replace ( entity ) ) ; }	Adds a table operation to replace the specified entity to the batch operation.
private void checksinglequeryperbatch ( final tableoperation op , final int size ) {	Reserved for internal use.
private void locktopartitionkey ( final string partitionkey ) { if ( this . partitionkey == null ) { this . partitionkey = partitionkey ; } else { if ( partitionkey . length ( ) != partitionkey . length ( ) || ! this . partitionkey . equals ( partitionkey ) ) { throw new illegalargumentexception ( sr . ops_in_batch_must_have_same_partition_key ) ; } } }	Reserved for internal use.
@ doesservicerequest public void create ( filerequestoptions options , operationcontext opcontext ) throws storageexception { if ( opcontext == null ) { opcontext = new operationcontext ( ) ; } assertnosnapshot ( ) ; if ( this . properties != null && this . properties . getsharequota ( ) != null ) { utility . assertinbounds ( str_ , this . properties . getsharequota ( ) , num_ , fileconstants . max_share_quota ) ; } opcontext . initialize ( ) ; options = filerequestoptions . populateandapplydefaults ( options , this . fileserviceclient ) ; executionengine . executewithretry ( this . fileserviceclient , this , createimpl ( options ) , options . getretrypolicyfactory ( ) , opcontext ) ; }	Creates the share using the specified options and operation context.
public string generatesharedaccesssignature ( final sharedaccessfilepolicy policy , final string grouppolicyidentifier , final iprange iprange , final sharedaccessprotocols protocols ) throws invalidkeyexception , storageexception { if ( ! storagecredentialshelper . cancredentialssignrequest ( this . fileserviceclient . getcredentials ( ) ) ) { final string errormessage = sr . cannot_create_sas_without_account_key ; throw new illegalargumentexception ( errormessage ) ; } final string resourcename = this . getsharedaccesscanonicalname ( ) ; final string signature = sharedaccesssignaturehelper . generatesharedaccesssignaturehashforblobandfile ( policy , null , grouppolicyidentifier , resourcename , iprange , protocols , this . fileserviceclient ) ; final uriquerybuilder builder = sharedaccesssignaturehelper . generatesharedaccesssignatureforblobandfile ( policy , null , grouppolicyidentifier , str_ , iprange , protocols , signature ) ; return builder . tostring ( ) ; }	Returns a shared access signature for the share.
@ doesservicerequest public void uploadpermissions ( final filesharepermissions permissions ) throws storageexception { this . uploadpermissions ( permissions , null , null , null ) ; }	Uploads the share's permissions.
public final uri getqualifieduri ( ) throws urisyntaxexception , storageexception { if ( this . issnapshot ( ) ) { return pathutility . addtoquery ( this . geturi ( ) , string . format ( str_ , this . snapshotid ) ) ; } return this . fileserviceclient . getcredentials ( ) . transformuri ( this . geturi ( ) ) ; }	Returns the snapshot or shared access signature qualified URI for this share.
public void basicinsertentity ( ) throws storageexception {	Illustrates how to form and execute a single insert operation.
public void basicbatch ( ) throws storageexception {	Illustrates how to form and execute a batch operation.
public void basicquery ( ) throws storageexception {	Illustrates how to form and execute a query operation.
public void basicupsert ( ) throws storageexception {	Illustrates how to form and execute an upsert operation.
public void basicdeleteentity ( ) throws storageexception {	Illustrates how to form and execute an entity delete operation.
public void basiclisting ( ) {	Illustrates how to list the tables.
private tablequery < tableserviceentity > generatelisttablesquery ( final string prefix ) { tablequery < tableserviceentity > listquery = tablequery . < tableserviceentity > from ( tableserviceentity . class ) ; listquery . setsourcetablename ( tableconstants . tables_service_tables_name ) ; if ( ! utility . isnullorempty ( prefix ) ) {	Reserved for internal use.
public static listresponse < cloudqueue > getqueues ( final inputstream stream , final cloudqueueclient serviceclient ) throws saxexception , ioexception , parserconfigurationexception { saxparser saxparser = utility . getsaxparser ( ) ; queuelisthandler handler = new queuelisthandler ( serviceclient ) ; saxparser . parse ( stream , handler ) ; return handler . response ; }	Parses the input stream containing the response body of the list queues request result and populates the classdata.
protected static storageexception translatefromhttpstatus ( final int statuscode , final string statusdescription , final exception inner ) { string errorcode ; switch ( statuscode ) { case httpurlconnection . http_forbidden : errorcode = storageerrorcode . access_denied . tostring ( ) ; break ; case httpurlconnection . http_gone : case httpurlconnection . http_not_found : errorcode = storageerrorcode . resource_not_found . tostring ( ) ; break ; case num_ : case httpurlconnection . http_bad_request :	Translates the specified HTTP status code into a storage exception.
@ doesservicerequest public iterable < cloudqueue > listqueues ( ) { return this . listqueues ( null , queuelistingdetails . none , null , null ) ; }	Gets an iterable collection of queues for this queue service client.
@ doesservicerequest public iterable < cloudqueue > listqueues ( final string prefix ) { return this . listqueues ( prefix , queuelistingdetails . none , null , null ) ; }	Returns an iterable collection of queues whose names begin with thespecified prefix in this Queue service client.
@ doesservicerequest public resultsegment < cloudqueue > listqueuessegmented ( ) throws storageexception { return this . listqueuessegmented ( null , queuelistingdetails . none , null , null , null , null ) ; }	Gets a result segment of an iterable collection of queues for this Queueservice client.
public void addconfiguredxmlcatalog ( @ nonnull final xmlcatalog axmlcatalog ) { m_axmlcatalog . addconfiguredxmlcatalog ( axmlcatalog ) ; log ( str_ + axmlcatalog , project . msg_debug ) ; }	Add the catalog to our internal catalog.
@ nullable public string getuniqueid ( @ nullable final string sid ) { if ( sid == null ) return null ; if ( m_ausedids . add ( sid ) ) {	Create a unique ID based on the passed one.
@ nonnull public schematronresourcepure setphase ( @ nullable final string sphase ) { if ( m_aboundschema != null ) throw new illegalstateexception ( str_ ) ; m_sphase = sphase ; return this ; }	Set the Schematron phase to be evaluated. Changing the phase will result ina newly bound schema!.
@ nonnull public schematronresourcepure seterrorhandler ( @ nullable final ipserrorhandler aerrorhandler ) { if ( m_aboundschema != null ) throw new illegalstateexception ( str_ ) ; m_aerrorhandler = aerrorhandler ; return this ; }	Set the error handler to be used during binding.
@ nonnull public schematronresourcepure setvariableresolver ( @ nullable final xpathvariableresolver avariableresolver ) { if ( m_aboundschema != null ) throw new illegalstateexception ( str_ ) ; m_avariableresolver = avariableresolver ; return this ; }	Set the variable resolver to be used in the XPath statements.
@ nonnull public schematronresourcepure setfunctionresolver ( @ nullable final xpathfunctionresolver afunctionresolver ) { if ( m_aboundschema != null ) throw new illegalstateexception ( str_ ) ; m_afunctionresolver = afunctionresolver ; return this ; }	Set the function resolver to be used in the XPath statements.
@ nonnull public schematronresourcepure setentityresolver ( @ nullable final entityresolver aentityresolver ) { if ( m_aboundschema != null ) throw new illegalstateexception ( str_ ) ; internalsetentityresolver ( aentityresolver ) ; return this ; }	Set the XML entity resolver to be used when reading the Schematron or theXML to be validated.
@ nonnull public ipsboundschema getorcreateboundschema ( ) { if ( m_aboundschema == null ) try { m_aboundschema = createboundschema ( ) ; } catch ( final runtimeexception ex ) { if ( m_aerrorhandler != null ) m_aerrorhandler . error ( getresource ( ) , null , str_ , ex ) ; throw ex ; } return m_aboundschema ; }	Get the cached bound schema or create a new one.
public void validatecompletely ( @ nonnull final ipserrorhandler aerrorhandler ) { valueenforcer . notnull ( aerrorhandler , str_ ) ; try { getorcreateboundschema ( ) . getoriginalschema ( ) . validatecompletely ( aerrorhandler ) ; } catch ( final runtimeexception ex ) {	Use the provided error handler to validate all elements in the schematron.It tries to catch as many errors as possible.
@ nonnull public schematronoutputtype applyschematronvalidationtosvrl ( @ nonnull final node axmlnode , @ nullable final string sbaseuri ) throws schematronexception { valueenforcer . notnull ( axmlnode , str_ ) ; final schematronoutputtype asot = getorcreateboundschema ( ) . validatecomplete ( axmlnode , sbaseuri ) ;	The main method to convert a node to an SVRL document.
private void _resolverulecontent ( @ nonnull final icommonslist < ipselement > arulecontent , @ nonnull final preprocessorlookup alookup , @ nonnull final preprocessoridpool aidpool , @ nullable final icommonsmap < string , string > aparamvaluemap , @ nonnull final psrule atargetrule ) throws schematronpreprocessexception { for ( final ipselement aelement : arulecontent ) { if ( aelement instanceof psassertreport ) { final psassertreport aassertreport = ( psassertreport ) aelement ; atargetrule . addassertreport ( _getpreprocessedassert ( aassertreport , aidpool , aparamvaluemap ) ) ; } else { final psextends aextends = ( psextends ) aelement ; final string sruleid = aextends . getrule ( ) ; final psrule abaserule = alookup . getabstractruleofid ( sruleid ) ; if ( abaserule == null ) throw new schematronpreprocessexception ( str_ + sruleid + str_ + alookup . getallabstractruleids ( ) ) ;	Resolve all &lt;extends&gt; elements.
@ nullable public psschema getasminimalschema ( @ nonnull final psschema aschema ) throws schematronpreprocessexception { valueenforcer . notnull ( aschema , str_ ) ;	Convert the passed schema to a minimal schema.
@ nullable public psschema getaspreprocessedschema ( @ nonnull final psschema aschema ) throws schematronpreprocessexception { valueenforcer . notnull ( aschema , str_ ) ;	Convert the passed schema to a pre-processed schema.
@ nullable public psschema getforcedpreprocessedschema ( @ nonnull final psschema aschema ) throws schematronpreprocessexception { valueenforcer . notnull ( aschema , str_ ) ; final preprocessorlookup alookup = new preprocessorlookup ( aschema ) ; final preprocessoridpool aidpool = new preprocessoridpool ( ) ; final psschema ret = new psschema ( aschema . getresource ( ) ) ; ret . setid ( aidpool . getuniqueid ( aschema . getid ( ) ) ) ; ret . setrich ( aschema . getrichclone ( ) ) ; ret . setschemaversion ( aschema . getschemaversion ( ) ) ; ret . setdefaultphase ( aschema . getdefaultphase ( ) ) ; ret . setquerybinding ( aschema . getquerybinding ( ) ) ; if ( m_bkeeptitles && aschema . hastitle ( ) ) ret . settitle ( aschema . gettitle ( ) . getclone ( ) ) ; if ( aschema . hasanyinclude ( ) ) throw new schematronpreprocessexception ( str_ ) ; for ( final psns ans : aschema . getallnss ( ) ) ret . addns ( ans . getclone ( ) ) ;	Convert the passed schema to a pre-processed schema independent if it isalready minimal or not.
@ nonnull @ overrideondemand public psschema readschema ( @ nonnull final ireadableresource aresource , @ nullable final ipserrorhandler aerrorhandler , @ nullable final entityresolver aentityresolver ) throws schematronexception { return new psreader ( aresource , aerrorhandler , aentityresolver ) . readschema ( ) ; }	Read the specified schema from the passed resource.
@ nonnull @ overrideondemand public ipsquerybinding getquerybinding ( @ nonnull final psschema aschema ) throws schematronexception { return psquerybindingregistry . getquerybindingofnameorthrow ( aschema . getquerybinding ( ) ) ; }	Determine the query binding for the read schema.
@ nonnull @ overrideondemand public psschema createpreprocessedschema ( @ nonnull final psschema aschema , @ nonnull final ipsquerybinding aquerybinding ) throws schematronexception { final pspreprocessor apreprocessor = createpreprocessor ( aquerybinding ) ; final psschema apreprocessedschema = apreprocessor . getaspreprocessedschema ( aschema ) ; if ( apreprocessedschema == null ) throw new schematronpreprocessexception ( str_ + aschema + str_ + aquerybinding ) ; if ( schematrondebug . isshowpreprocessedschematron ( ) ) logger . info ( str_ + microwriter . getnodeasstring ( apreprocessedschema . getasmicroelement ( ) ) ) ; return apreprocessedschema ; }	Pre-process the read schema, using the determined query binding.
@ nonnull public esuccess writetofile ( @ nonnull final ipselement apselement , @ nonnull final file afile ) { valueenforcer . notnull ( apselement , str_ ) ; final imicroelement exml = apselement . getasmicroelement ( ) ; return microwriter . writetofile ( getasdocument ( exml ) , afile , m_awritersettings . getxmlwritersettings ( ) ) ; }	Write the passed Schematron element to the passed file.
@ nonnull public esuccess writetostream ( @ nonnull final ipselement apselement , @ nonnull @ willclose final outputstream aos ) { valueenforcer . notnull ( apselement , str_ ) ; final imicroelement exml = apselement . getasmicroelement ( ) ; return microwriter . writetostream ( getasdocument ( exml ) , aos , m_awritersettings . getxmlwritersettings ( ) ) ; }	Write the passed Schematron element to the passed output stream.
@ nonnull public esuccess writetowriter ( @ nonnull final ipselement apselement , @ nonnull @ willclose final writer awriter ) { valueenforcer . notnull ( apselement , str_ ) ; final imicroelement exml = apselement . getasmicroelement ( ) ; return microwriter . writetowriter ( getasdocument ( exml ) , awriter , m_awritersettings . getxmlwritersettings ( ) ) ; }	Write the passed Schematron element to the passed writer.
@ nullable public static schematronoutputtype applyschematron ( @ nonnull final ischematronresource aschematron , @ nonnull final ireadableresource axml ) { valueenforcer . notnull ( aschematron , str_ ) ; valueenforcer . notnull ( axml , str_ ) ; try {	Apply the passed schematron on the passed XML resource using a custom errorhandler.
@ nullable public static schematronoutputtype applyschematron ( @ nonnull final ischematronresource aschematron , @ nonnull final node anode ) { valueenforcer . notnull ( aschematron , str_ ) ; valueenforcer . notnull ( anode , str_ ) ; return applyschematron ( aschematron , new domsource ( anode ) ) ; }	Apply the passed schematron on the passed XML node.
@ nonnull public echange remove ( @ nullable final string svarname ) { if ( stringhelper . hastext ( svarname ) ) if ( m_amap . remove ( psxpathquerybinding . param_variable_prefix + svarname ) == null ) return echange . changed ; return echange . unchanged ; }	Remove the variable with the specified name.
@ nonnull public echange removeall ( @ nullable final iterable < string > avars ) { echange echange = echange . unchanged ; if ( avars != null ) for ( final string sname : avars ) echange = echange . or ( remove ( sname ) ) ; return echange ; } @ nonnull @ returnsmutablecopy public icommonsnavigablemap < string , string > getall ( ) { return m_amap . getclone ( ) ; } public boolean contains ( @ nullable final string sname ) { if ( stringhelper . hasnotext ( sname ) ) return bool_ ; return m_amap . containskey ( sname ) ; }	Remove all variables with the specified names.
@ nonnull @ returnsmutablecopy public static icommonslist < svrlfailedassert > getallfailedassertions ( @ nullable final schematronoutputtype aschematronoutput ) { final icommonslist < svrlfailedassert > ret = new commonsarraylist < > ( ) ; if ( aschematronoutput != null ) for ( final object aobj : aschematronoutput . getactivepatternandfiredruleandfailedassert ( ) ) if ( aobj instanceof failedassert ) ret . add ( new svrlfailedassert ( ( failedassert ) aobj ) ) ; return ret ; }	Get a list of all failed assertions in a given schematron output.
@ nonnull @ returnsmutablecopy public static icommonslist < svrlfailedassert > getallfailedassertionsmoreorequalseverethan ( @ nullable final schematronoutputtype aschematronoutput , @ nonnull final ierrorlevel aerrorlevel ) { final icommonslist < svrlfailedassert > ret = new commonsarraylist < > ( ) ; if ( aschematronoutput != null ) for ( final object aobj : aschematronoutput . getactivepatternandfiredruleandfailedassert ( ) ) if ( aobj instanceof failedassert ) { final svrlfailedassert afa = new svrlfailedassert ( ( failedassert ) aobj ) ; if ( afa . getflag ( ) . isge ( aerrorlevel ) ) ret . add ( afa ) ; } return ret ; }	Get a list of all failed assertions in a given schematron output, with anerror level equally or more severe than the passed error level.
@ nonnull @ returnsmutablecopy public static icommonslist < svrlsuccessfulreport > getallsuccessfulreports ( @ nullable final schematronoutputtype aschematronoutput ) { final icommonslist < svrlsuccessfulreport > ret = new commonsarraylist < > ( ) ; if ( aschematronoutput != null ) for ( final object aobj : aschematronoutput . getactivepatternandfiredruleandfailedassert ( ) ) if ( aobj instanceof successfulreport ) ret . add ( new svrlsuccessfulreport ( ( successfulreport ) aobj ) ) ; return ret ; }	Get a list of all successful reports in a given schematron output.
@ nonnull @ returnsmutablecopy public static icommonslist < svrlsuccessfulreport > getallsuccessfulreportsmoreorequalseverethan ( @ nullable final schematronoutputtype aschematronoutput , @ nonnull final ierrorlevel aerrorlevel ) { final icommonslist < svrlsuccessfulreport > ret = new commonsarraylist < > ( ) ; if ( aschematronoutput != null ) for ( final object aobj : aschematronoutput . getactivepatternandfiredruleandfailedassert ( ) ) if ( aobj instanceof successfulreport ) { final svrlsuccessfulreport asr = new svrlsuccessfulreport ( ( successfulreport ) aobj ) ; if ( asr . getflag ( ) . isge ( aerrorlevel ) ) ret . add ( asr ) ; } return ret ; }	Get a list of all successful reports in a given schematron output, with anerror level equally or more severe than the passed error level.
@ nonnull @ returnsmutablecopy public static icommonslist < abstractsvrlmessage > getallfailedassertionsandsuccessfulreports ( @ nullable final schematronoutputtype aschematronoutput ) { final icommonslist < abstractsvrlmessage > ret = new commonsarraylist < > ( ) ; if ( aschematronoutput != null ) for ( final object aobj : aschematronoutput . getactivepatternandfiredruleandfailedassert ( ) ) if ( aobj instanceof failedassert ) ret . add ( new svrlfailedassert ( ( failedassert ) aobj ) ) ; else if ( aobj instanceof successfulreport ) ret . add ( new svrlsuccessfulreport ( ( successfulreport ) aobj ) ) ; return ret ; }	Get a list of all failed assertions and successful reports in a givenschematron output.
public static void seterrorleveldeterminator ( @ nonnull final isvrlerrorleveldeterminator aeld ) { valueenforcer . notnull ( aeld , str_ ) ; s_arwlock . readlocked ( ( ) -> s_aeld = aeld ) ; }	Set the global error level determinator.
@ nullable public static ipsquerybinding getquerybindingofname ( @ nullable final string sname ) { if ( sname == null ) return default_query_binding ; return s_arwlock . readlocked ( ( ) -> s_amap . get ( sname ) ) ; }	Get the query binding with the specified name.
@ nonnull public static ipsquerybinding getquerybindingofnameorthrow ( @ nullable final string sname ) throws schematronbindexception { final ipsquerybinding aqb = getquerybindingofname ( sname ) ; if ( aqb == null ) throw new schematronbindexception ( str_ + sname + str_ ) ; return aqb ; }	Get the query binding with the specified name.
@ nonnull public mapbasedxpathfunctionresolver loadxquery ( @ nonnull @ willclose final inputstream axqueryis ) throws xpathexception , ioexception { valueenforcer . notnull ( axqueryis , str_ ) ; try { final mapbasedxpathfunctionresolver afunctionresolver = new mapbasedxpathfunctionresolver ( ) ;	Load XQuery functions from an input stream.
private string _format ( final string format , final object arg ) { final formattingtuple tuple = messageformatter . format ( format , arg ) ; return tuple . getmessage ( ) ; }	Format with one object.
private string _format ( final string format , final object first , final object second ) { final formattingtuple tuple = messageformatter . format ( format , first , second ) ; return tuple . getmessage ( ) ; }	Format with two objects.
public static boolean isvalidschematron ( @ nullable final imicronode anode ) { if ( anode == null ) return bool_ ; return isvalidschematron ( transformsourcefactory . create ( microwriter . getnodeasstring ( anode ) ) ) ; }	Check if the passed micro node is a valid schematron instance.
public static boolean isvalidschematron ( @ nullable final node anode ) { if ( anode == null ) return bool_ ; return isvalidschematron ( transformsourcefactory . create ( anode ) ) ; }	Check if the passed DOM node is a valid schematron instance.
public static boolean isvalidschematron ( @ nullable final ireadableresource ares ) { if ( ares == null ) return bool_ ; return isvalidschematron ( transformsourcefactory . create ( ares ) ) ; }	Check if the passed resource is a valid schematron instance.
public static boolean isvalidschematron ( @ nullable final source asource ) { if ( asource == null ) return bool_ ; try {	Check if the passed source is a valid schematron instance.
@ nullable public static schematronproviderxsltfromsch createschematronxsltprovider ( @ nonnull final ireadableresource aschematronresource , @ nonnull final schtransformercustomizer atransformercustomizer ) { if ( logger . isdebugenabled ( ) ) logger . debug ( str_ + aschematronresource . tostring ( ) ) ; final schematronproviderxsltfromsch axsltpreprocessor = new schematronproviderxsltfromsch ( aschematronresource , atransformercustomizer ) ; if ( ! axsltpreprocessor . isvalidschematron ( ) ) {	Create a new Schematron validator for the passed resource.
@ nullable public static schematronproviderxsltfromsch getschematronxsltprovider ( @ nonnull final ireadableresource aschematronresource , @ nonnull final schtransformercustomizer atransformercustomizer ) { valueenforcer . notnull ( aschematronresource , str_ ) ; valueenforcer . notnull ( atransformercustomizer , str_ ) ; if ( ! aschematronresource . exists ( ) ) { logger . warn ( str_ + aschematronresource + str_ ) ; return null ; } if ( ! atransformercustomizer . cancacheresult ( ) ) {	Get the Schematron validator for the passed resource.
@ nonnull private string _geterrortext ( @ nonnull final list < psxpathboundelement > aboundcontentelements , @ nonnull final node asourcenode ) throws schematronvalidationexception { final stringbuilder asb = new stringbuilder ( ) ; for ( final psxpathboundelement aboundelement : aboundcontentelements ) { final object acontent = aboundelement . getelement ( ) ; if ( acontent instanceof string ) asb . append ( ( string ) acontent ) ; else if ( acontent instanceof psname ) { final psname aname = ( psname ) acontent ; if ( aname . haspath ( ) ) {	Get the error text from an assert or report element.
@ nullable public static string getbeautifiedlocation ( @ nonnull final string snamespaceuri , @ nonnull final string slocalname ) { for ( final isvrllocationbeautifierspi abeautifier : s_alist ) { final string sbeautified = abeautifier . getreplacementtext ( snamespaceuri , slocalname ) ; if ( sbeautified != null ) return sbeautified ; } if ( logger . isdebugenabled ( ) ) logger . debug ( str_ + snamespaceuri + str_ + slocalname ) ; return null ; }	Get the beautified location for the given namespace and local name.
private void _warn ( @ nonnull final ipselement asourceelement , @ nonnull final string smessage ) { valueenforcer . notnull ( asourceelement , str_ ) ; valueenforcer . notnull ( smessage , str_ ) ; m_aerrorhandler . warn ( m_aresource , asourceelement , smessage ) ; }	Emit a warning with the registered error handler.
@ nonnull public psactive readactivefromxml ( @ nonnull final imicroelement eactive ) { final psactive ret = new psactive ( ) ; eactive . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_pattern ) ) ret . setpattern ( sattrvalue ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; eactive . forallchildren ( aactivechild -> { switch ( aactivechild . gettype ( ) ) { case text : ret . addtext ( ( ( imicrotext ) aactivechild ) . getnodevalue ( ) ) ; break ; case element : final imicroelement eelement = ( imicroelement ) aactivechild ; if ( cschematron . namespace_schematron . equals ( eelement . getnamespaceuri ( ) ) ) { final string slocalname = eelement . getlocalname ( ) ; if ( slocalname . equals ( cschematronxml . element_dir ) ) ret . adddir ( readdirfromxml ( eelement ) ) ; else if ( slocalname . equals ( cschematronxml . element_emph ) ) ret . addemph ( reademphfromxml ( eelement ) ) ; else if ( slocalname . equals ( cschematronxml . element_span ) ) ret . addspan ( readspanfromxml ( eelement ) ) ; else _warn ( ret , str_ + slocalname + str_ ) ; } else ret . addforeignelement ( eelement . getclone ( ) ) ; break ; case comment :	Read an &lt;active&gt; element.
@ nonnull public psdiagnostics readdiagnosticsfromxml ( @ nonnull final imicroelement ediagnostics ) { final psdiagnostics ret = new psdiagnostics ( ) ; ediagnostics . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; ediagnostics . forallchildelements ( ediagnosticschild -> { if ( cschematron . namespace_schematron . equals ( ediagnosticschild . getnamespaceuri ( ) ) ) { if ( ediagnosticschild . getlocalname ( ) . equals ( cschematronxml . element_include ) ) ret . addinclude ( readincludefromxml ( ediagnosticschild ) ) ; else if ( ediagnosticschild . getlocalname ( ) . equals ( cschematronxml . element_diagnostic ) ) ret . adddiagnostic ( readdiagnosticfromxml ( ediagnosticschild ) ) ; else _warn ( ret , str_ + ediagnosticschild . getlocalname ( ) + str_ ) ; } else ret . addforeignelement ( ediagnosticschild . getclone ( ) ) ; } ) ; return ret ; }	Read a &lt;diagnostics&gt; element.
@ nonnull public psdir readdirfromxml ( @ nonnull final imicroelement edir ) { final psdir ret = new psdir ( ) ; edir . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_value ) ) ret . setvalue ( edirvalue . getfromidornull ( sattrvalue ) ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; edir . forallchildren ( adirchild -> { switch ( adirchild . gettype ( ) ) { case text : ret . addtext ( ( ( imicrotext ) adirchild ) . getnodevalue ( ) ) ; break ; case element : final imicroelement eelement = ( imicroelement ) adirchild ; if ( cschematron . namespace_schematron . equals ( eelement . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + eelement . getlocalname ( ) + str_ ) ; } else ret . addforeignelement ( eelement . getclone ( ) ) ; break ; case comment :	Read a &lt;dir&gt; element.
@ nonnull public psemph reademphfromxml ( @ nonnull final imicroelement eemph ) { final psemph ret = new psemph ( ) ; eemph . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; _warn ( ret , str_ + sattrname + str_ + sattrvalue + str_ ) ; } ) ; eemph . forallchildren ( aemphchild -> { switch ( aemphchild . gettype ( ) ) { case text : ret . addtext ( ( ( imicrotext ) aemphchild ) . getnodevalue ( ) ) ; break ; case element : final imicroelement eelement = ( imicroelement ) aemphchild ; if ( cschematron . namespace_schematron . equals ( eelement . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + eelement . getlocalname ( ) + str_ ) ; } else _warn ( ret , str_ + eelement . getnamespaceuri ( ) + str_ ) ; break ; case comment :	Read an &lt;emph&gt; element.
@ nonnull public psextends readextendsfromxml ( @ nonnull final imicroelement eextends ) { final psextends ret = new psextends ( ) ; eextends . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_rule ) ) ret . setrule ( sattrvalue ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; eextends . forallchildelements ( echild -> { if ( cschematron . namespace_schematron . equals ( echild . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + echild . getlocalname ( ) + str_ ) ; } else _warn ( ret , str_ + echild . getnamespaceuri ( ) + str_ ) ; } ) ; return ret ; }	Read an &lt;extends&gt; element.
@ nonnull public psinclude readincludefromxml ( @ nonnull final imicroelement einclude ) { final psinclude ret = new psinclude ( ) ; einclude . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_href ) ) ret . sethref ( sattrvalue ) ; else _warn ( ret , str_ + sattrname + str_ + sattrvalue + str_ ) ; } ) ; einclude . forallchildelements ( evalueofchild -> { if ( cschematron . namespace_schematron . equals ( evalueofchild . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + evalueofchild . getlocalname ( ) + str_ ) ; } else _warn ( ret , str_ + evalueofchild . getnamespaceuri ( ) + str_ ) ; } ) ; return ret ; }	Read an &lt;include&gt; element.
@ nonnull public pslet readletfromxml ( @ nonnull final imicroelement elet ) { final pslet ret = new pslet ( ) ; elet . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_name ) ) ret . setname ( sattrvalue ) ; else if ( sattrname . equals ( cschematronxml . attr_value ) ) ret . setvalue ( sattrvalue ) ; else _warn ( ret , str_ + sattrname + str_ + sattrvalue + str_ ) ; } ) ; elet . forallchildelements ( eletchild -> { if ( cschematron . namespace_schematron . equals ( eletchild . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + eletchild . getlocalname ( ) + str_ ) ; } else _warn ( ret , str_ + eletchild . getnamespaceuri ( ) + str_ ) ; } ) ; return ret ; }	Read a &lt;let&gt; element.
@ nonnull public psname readnamefromxml ( @ nonnull final imicroelement ename ) { final psname ret = new psname ( ) ; ename . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_path ) ) ret . setpath ( sattrvalue ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; ename . forallchildelements ( enamechild -> { if ( cschematron . namespace_schematron . equals ( enamechild . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + enamechild . getlocalname ( ) + str_ ) ; } else _warn ( ret , str_ + enamechild . getnamespaceuri ( ) + str_ ) ; } ) ; return ret ; }	Read a &lt;name&gt; element.
@ nonnull public psns readnsfromxml ( @ nonnull final imicroelement ens ) { final psns ret = new psns ( ) ; ens . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_uri ) ) ret . seturi ( sattrvalue ) ; else if ( sattrname . equals ( cschematronxml . attr_prefix ) ) ret . setprefix ( sattrvalue ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; ens . forallchildelements ( eletchild -> { if ( cschematron . namespace_schematron . equals ( eletchild . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + eletchild . getlocalname ( ) + str_ ) ; } else _warn ( ret , str_ + eletchild . getnamespaceuri ( ) + str_ ) ; } ) ; return ret ; }	Read a &lt;ns&gt; element.
@ nonnull public psp readpfromxml ( @ nonnull final imicroelement ep ) { final psp ret = new psp ( ) ; ep . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_id ) ) ret . setid ( sattrvalue ) ; else if ( sattrname . equals ( cschematronxml . attr_class ) ) ret . setclazz ( sattrvalue ) ; else if ( sattrname . equals ( cschematronxml . attr_icon ) ) ret . seticon ( sattrvalue ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; ep . forallchildren ( achild -> { switch ( achild . gettype ( ) ) { case text : ret . addtext ( ( ( imicrotext ) achild ) . getnodevalue ( ) ) ; break ; case element : final imicroelement eelement = ( imicroelement ) achild ; if ( cschematron . namespace_schematron . equals ( eelement . getnamespaceuri ( ) ) ) { final string slocalname = eelement . getlocalname ( ) ; if ( slocalname . equals ( cschematronxml . element_dir ) ) ret . adddir ( readdirfromxml ( eelement ) ) ; else if ( slocalname . equals ( cschematronxml . element_emph ) ) ret . addemph ( reademphfromxml ( eelement ) ) ; else if ( slocalname . equals ( cschematronxml . element_span ) ) ret . addspan ( readspanfromxml ( eelement ) ) ; else _warn ( ret , str_ + slocalname + str_ ) ; } else ret . addforeignelement ( eelement . getclone ( ) ) ; break ; case comment :	Read a &lt;p&gt; element.
@ nonnull public psparam readparamfromxml ( @ nonnull final imicroelement eparam ) { final psparam ret = new psparam ( ) ; eparam . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_name ) ) ret . setname ( sattrvalue ) ; else if ( sattrname . equals ( cschematronxml . attr_value ) ) ret . setvalue ( sattrvalue ) ; else _warn ( ret , str_ + sattrname + str_ + sattrvalue + str_ ) ; } ) ; eparam . forallchildelements ( eparamchild -> { if ( cschematron . namespace_schematron . equals ( eparamchild . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + eparamchild . getlocalname ( ) + str_ ) ; } else _warn ( ret , str_ + eparamchild . getnamespaceuri ( ) + str_ ) ; } ) ; return ret ; }	Read a &lt;param&gt; element.
@ nonnull public psphase readphasefromxml ( @ nonnull final imicroelement ephase ) { final psphase ret = new psphase ( ) ; final psrichgroup arichgroup = new psrichgroup ( ) ; ephase . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_id ) ) ret . setid ( sattrvalue ) ; else if ( psrichgroup . isrichattribute ( sattrname ) ) _handlerichgroup ( sattrname , sattrvalue , arichgroup ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; ret . setrich ( arichgroup ) ; ephase . forallchildelements ( ephasechild -> { if ( cschematron . namespace_schematron . equals ( ephasechild . getnamespaceuri ( ) ) ) { if ( ephasechild . getlocalname ( ) . equals ( cschematronxml . element_include ) ) ret . addinclude ( readincludefromxml ( ephasechild ) ) ; else if ( ephasechild . getlocalname ( ) . equals ( cschematronxml . element_p ) ) ret . addp ( readpfromxml ( ephasechild ) ) ; else if ( ephasechild . getlocalname ( ) . equals ( cschematronxml . element_let ) ) ret . addlet ( readletfromxml ( ephasechild ) ) ; else if ( ephasechild . getlocalname ( ) . equals ( cschematronxml . element_active ) ) ret . addactive ( readactivefromxml ( ephasechild ) ) ; else _warn ( ret , str_ + ephasechild . getlocalname ( ) + str_ ) ; } else ret . addforeignelement ( ephasechild . getclone ( ) ) ; } ) ; return ret ; }	Read a &lt;phase&gt; element.
@ nonnull public psspan readspanfromxml ( @ nonnull final imicroelement espan ) { final psspan ret = new psspan ( ) ; espan . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_class ) ) ret . setclazz ( sattrvalue ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; espan . forallchildren ( aspanchild -> { switch ( aspanchild . gettype ( ) ) { case text : ret . addtext ( ( ( imicrotext ) aspanchild ) . getnodevalue ( ) ) ; break ; case element : final imicroelement eelement = ( imicroelement ) aspanchild ; if ( cschematron . namespace_schematron . equals ( eelement . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + eelement . getlocalname ( ) + str_ ) ; } else ret . addforeignelement ( eelement . getclone ( ) ) ; break ; case comment :	Read a &lt;span&gt; element.
@ nonnull public pstitle readtitlefromxml ( @ nonnull final imicroelement etitle ) { final pstitle ret = new pstitle ( ) ; etitle . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; _warn ( ret , str_ + sattrname + str_ + sattrvalue + str_ ) ; } ) ; etitle . forallchildren ( atitlechild -> { switch ( atitlechild . gettype ( ) ) { case text : ret . addtext ( ( ( imicrotext ) atitlechild ) . getnodevalue ( ) ) ; break ; case element : final imicroelement eelement = ( imicroelement ) atitlechild ; if ( cschematron . namespace_schematron . equals ( eelement . getnamespaceuri ( ) ) ) { final string slocalname = eelement . getlocalname ( ) ; if ( slocalname . equals ( cschematronxml . element_dir ) ) ret . adddir ( readdirfromxml ( eelement ) ) ; else _warn ( ret , str_ + slocalname + str_ ) ; } else _warn ( ret , str_ + eelement . getnamespaceuri ( ) + str_ ) ; break ; case comment :	Read a &lt;title&gt; element.
@ nonnull public psvalueof readvalueoffromxml ( @ nonnull final imicroelement evalueof ) { final psvalueof ret = new psvalueof ( ) ; evalueof . forallattributes ( ( sns , sattrname , sval ) -> { final string sattrvalue = _getattributevalue ( sval ) ; if ( sattrname . equals ( cschematronxml . attr_select ) ) ret . setselect ( sattrvalue ) ; else ret . addforeignattribute ( sattrname , sattrvalue ) ; } ) ; evalueof . forallchildelements ( evalueofchild -> { if ( cschematron . namespace_schematron . equals ( evalueofchild . getnamespaceuri ( ) ) ) { _warn ( ret , str_ + evalueofchild . getlocalname ( ) + str_ ) ; } else _warn ( ret , str_ + evalueofchild . getnamespaceuri ( ) + str_ ) ; } ) ; return ret ; }	Read a &lt;value-of&gt; element.
@ nonnull @ returnsmutablecopy public static mapbasednamespacecontext createnamespacemapping ( @ nonnull final psschema aschema ) { final mapbasednamespacecontext ret = new mapbasednamespacecontext ( ) ; ret . adddefaultnamespaceuri ( cschematron . namespace_schematron ) ; for ( final psns aitem : aschema . getallnss ( ) ) ret . addmapping ( aitem . getprefix ( ) , aitem . geturi ( ) ) ; return ret ; }	Helper method to extract the namespace mapping from the providedSchematron.
private < t > completionstage < t > regex ( final http . requestheader requestheader , final deadbolthandler deadbolthandler , final optional < string > content , final string [ ] values , final int valueindex , final constraintmode mode , final boolean invert , final function < http . requestheader , completionstage < t > > pass , final trifunction < http . requestheader , deadbolthandler , optional < string > , completionstage < t > > fail , final constraintpoint constraintpoint ) { return completablefuture . completedfuture ( patterncache . apply ( values [ valueindex ] ) ) . thencombine ( getsubject ( requestheader , deadbolthandler ) , ( patternvalue , subject ) -> f . tuple ( subject . _1 . ispresent ( ) ? analyzer . checkregexpattern ( subject . _1 , optional . ofnullable ( patternvalue ) ) : invert , subject . _2 ) )	Checks access to the resource based on the regex.
private http . requestheader markasauthorised ( final http . requestheader request ) { this . authorised = bool_ ; return request . addattr ( action_authorised , bool_ ) ; }	Marks the current action as authorised.
protected static boolean isauthorised ( final http . requestheader request ) { return request . attrs ( ) . getoptional ( action_authorised ) . orelse ( bool_ ) ; }	Checks if an action is authorised.
protected http . requestheader defer ( final http . requestheader request , final abstractdeadboltaction < t > action ) { if ( action != null ) { logger . info ( str_ , this . getclass ( ) . getname ( ) ) ; return request . addattr ( action_deferred , action ) ; } return request ; }	Defer execution until a later point.
@ suppresswarnings ( str_ ) public f . tuple < abstractdeadboltaction < ? > , http . requestheader > getdeferredaction ( final http . requestheader request ) { return request . attrs ( ) . getoptional ( action_deferred ) . map ( action -> { action . delegate = this ; return f . < abstractdeadboltaction < ? > , http . requestheader > tuple ( action , request . removeattr ( action_deferred ) . addattr ( ignore_deferred_flag , bool_ ) ) ; } ) . orelseget ( ( ) -> f . tuple ( null , request ) ) ; }	Get the deferred action from the request.
protected completionstage < result > authorizeandexecute ( final http . requestheader request ) { if ( constraintannotationmode != constraintannotationmode . and ) {	Add a flag to the request to indicate the action has passed the constraintand call the delegate.
private static boolean deadboltactionleftinactionchain ( final action < ? > action ) { if ( action != null ) { if ( action . delegate instanceof abstractdeadboltaction ) { return bool_ ;	Recursive method to determine if there is another deadbolt action further down the action chain.
public list < string > getrolenames ( final optional < ? extends subject > subjectoption ) { final list < string > rolenames = new arraylist < > ( ) ; subjectoption . ifpresent ( subject -> { final list < ? extends role > roles = subject . getroles ( ) ; if ( roles != null ) { rolenames . addall ( roles . stream ( ) . filter ( objects :: nonnull ) . map ( role :: getname ) . collect ( collectors . tolist ( ) ) ) ; } } ) ; return rolenames ; }	Gets the role name of each role held.
public boolean hasrole ( final optional < ? extends subject > subjectoption , final string rolename ) { return getrolenames ( subjectoption ) . contains ( rolename ) ; }	Check if the subject has the given role.
public filterfunction subjectpresent ( final optional < string > content ) { return ( http . requestheader requestheader , deadbolthandler handler , function < http . requestheader , completionstage < result > > next ) -> beforeauthcheckcache . apply ( handler , requestheader , content ) . thencompose ( maybepreauth -> maybepreauth . _1 . map ( preauthresult -> ( completionstage < result > ) completablefuture . completedfuture ( preauthresult ) ) . orelseget ( ( ) -> constraintlogic . subjectpresent ( maybepreauth . _2 , handler , content , ( rh , hdlr , cntent ) -> next . apply ( rh ) , ( rh , hdlr , cntent ) -> hdlr . onauthfailure ( rh , cntent ) , constraintpoint . filter ) ) ) ; }	A constraint that requires a subject to be present.
public static string [ ] roles ( final role ... roles ) { final list < string > names = new arraylist < > ( roles . length ) ; for ( role role : roles ) { names . add ( role . getname ( ) ) ; } return names . toarray ( new string [ names . size ( ) ] ) ; }	Converts the roles into a String array.
public static string [ ] permissions ( final permission ... permissions ) { final list < string > values = new arraylist < > ( permissions . length ) ; for ( permission permission : permissions ) { values . add ( permission . getvalue ( ) ) ; } return values . toarray ( new string [ values . size ( ) ] ) ; }	Converts the permissions into a String array.
public static list < string [ ] > allofgroup ( final string ... args ) { return collections . singletonlist ( args == null ? new string [ num_ ] : args ) ; }	Converts the arguments into a String array wrapped in a list.
public boolean viewrestrict ( final list < string [ ] > roles , final deadbolthandler handler , final optional < string > content , final long timeoutinmillis , final http . requestheader requestheader ) throws throwable { boolean allowed ; try { allowed = constraintlogic . restrict ( requestheader , handler ( handler ) , content , ( ) -> roles , rh -> completablefuture . completedfuture ( boolean . true ) , ( rh , dh , cnt ) -> completablefuture . completedfuture ( boolean . false ) , constraintpoint . template ) . tocompletablefuture ( ) . get ( timeoutinmillis , timeunit . milliseconds ) ; } catch ( timeoutexception e ) { allowed = timeouthandler . apply ( timeoutinmillis , e ) ; } return allowed ; }	Used for restrict tags in the template.
static coderresult overflow ( charbuffer input , int i , charbuffer output , int j ) { input . position ( i - input . arrayoffset ( ) ) ; output . position ( j - output . arrayoffset ( ) ) ; return coderresult . overflow ; }	Internal helper method to properly position buffers after encoding upuntil an overflow.
static coderresult underflow ( charbuffer input , int i , charbuffer output , int j ) { input . position ( i - input . arrayoffset ( ) ) ; output . position ( j - output . arrayoffset ( ) ) ; return coderresult . underflow ; }	Internal helper method to properly position buffers after encoding upuntil an underflow.
asciibits set ( int min , int max ) {	Sets a range of characters to 1s in the masks.
static string encode ( encoder encoder , string str ) { if ( str == null ) {	Core encoding loop shared by public methods.
static void encode ( encoder encoder , writer out , string str ) throws ioexception { if ( str == null ) {	Core encoding loop shared by public methods.
private static < t extends encoder > t map ( string name , t encoder ) { encoder old = encoders_map . put ( name , encoder ) ; assert old == null ; return encoder ; }	Internal method to setup and map encoder singletons.
public static encoder forname ( string contextname ) throws nullpointerexception , unsupportedcontextexception { if ( contextname == null ) { throw new nullpointerexception ( ) ; } encoder encoder = encoders_map . get ( contextname ) ; if ( encoder == null ) { throw new unsupportedcontextexception ( contextname ) ; } return encoder ; }	Returns a new instance of an Encoder for the specified context.
static int append ( char [ ] src , char [ ] out , int j ) { system . arraycopy ( src , num_ , out , j , src . length ) ; return j + src . length ; }	Appends a source array verbatim to the output array.
public string encode ( string str ) { if ( str == null ) { str = str_ ; } int n = str . length ( ) ; int j = _first . firstencodedoffset ( str , num_ , n ) ; if ( j == n ) {	Encodes an input string to an output string.
private void flushbuffertowriter ( ) throws ioexception { _out . write ( _buffer . array ( ) , num_ , _buffer . position ( ) ) ; _buffer . clear ( ) ; }	Flushes the contents of the buffer to the writer and resets the buffer to make room for more input.
private void flushleftover ( charbuffer input ) throws ioexception { if ( ! _hasleftover ) { return ; } for ( ; ; ) { if ( input != null && input . hasremaining ( ) ) { _leftoverbuffer . put ( input . get ( ) ) ; } _leftoverbuffer . flip ( ) ; coderresult cr = _encoder . encode ( _leftoverbuffer , _buffer , input == null ) ; if ( cr . isunderflow ( ) ) { if ( _leftoverbuffer . hasremaining ( ) ) { _leftoverbuffer . compact ( ) ; } else { break ; } } if ( cr . isoverflow ( ) ) { flushbuffertowriter ( ) ; } } _hasleftover = bool_ ; _leftoverbuffer . clear ( ) ; }	Flushes the left-over buffer.
public flowable < reactivesensorevent > observesensor ( int sensortype , final int samplingperiodinus , final handler handler , final backpressurestrategy strategy ) { if ( ! hassensor ( sensortype ) ) { string format = str_ ; string message = string . format ( locale . getdefault ( ) , format , sensortype ) ; return flowable . error ( new sensornotfoundexception ( message ) ) ; } final sensor sensor = sensormanager . getdefaultsensor ( sensortype ) ; final sensoreventlistenerwrapper wrapper = new sensoreventlistenerwrapper ( ) ; final sensoreventlistener listener = wrapper . create ( ) ; return flowable . create ( new flowableonsubscribe < reactivesensorevent > ( ) { @ override public void subscribe ( final flowableemitter < reactivesensorevent > emitter ) throws exception { wrapper . setemitter ( emitter ) ; if ( handler == null ) { sensormanager . registerlistener ( listener , sensor , samplingperiodinus ) ; } else { sensormanager . registerlistener ( listener , sensor , samplingperiodinus , handler ) ; } } } , strategy ) . dooncancel ( new action ( ) { @ override public void run ( ) throws exception { sensormanager . unregisterlistener ( listener ) ; } } ) ; }	Returns RxJava Observable, which allows to monitor hardware sensorsas a stream of ReactiveSensorEvent object with defined sampling period.
private string gettext ( jsonnode node , string propertyname ) { jsonnode childnode = node . get ( propertyname ) ; if ( childnode == null ) { return null ; } return childnode . astext ( ) ; }	Get the text from child node with the given name.
public result execute ( query query ) throws sonarbreakexception , ioexception { url queryurl = buildurl ( sonarurl , query ) ; log . debug ( str_ + queryurl . tostring ( ) ) ; if ( ! isurlavailable ( sonarurl , sonar_connection_retries ) ) { throw new sonarbreakexception ( string . format ( str_ , sonar_connection_retries ) ) ; } return fetchsonarstatuswithretries ( queryurl , query . getversion ( ) ) ; }	Execute the given query on the specified sonar server.
protected static url buildurl ( url sonarurl , query query ) throws malformedurlexception , illegalargumentexception { if ( query . getsonarkey ( ) == null || query . getsonarkey ( ) . length ( ) == num_ ) { throw new illegalargumentexception ( str_ ) ; } string sonarpathwithresource = string . format ( sonar_format_path , query . getsonarkey ( ) ) ; return new url ( sonarurl , sonarpathwithresource ) ; }	Creates a url for the specified quality gate query.
private result fetchsonarstatuswithretries ( url queryurl , string version ) throws ioexception , sonarbreakexception { datetime oneminuteago = datetime . now ( ) . minusseconds ( sonarlookbackseconds ) ; datetime waituntil = datetime . now ( ) . plusseconds ( waitforprocessingseconds ) ; do {	Get the status from sonar for the currently executing build.
private result fetchsonarstatus ( url queryurl ) throws ioexception , sonarbreakexception { inputstream in = null ; try { urlconnection connection = queryurl . openconnection ( ) ; connection . setrequestproperty ( str_ , str_ ) ; in = connection . getinputstream ( ) ; string response = ioutils . tostring ( in ) ; return parseresponse ( response ) ; } finally { ioutils . closequietly ( in ) ; } }	Get the status of a build project from sonar. This returns the current status that sonar has and does notdo any checking to ensure it matches the current project.
protected static result parseresponse ( string response ) throws sonarbreakexception { objectmapper mapper = new objectmapper ( ) ; final dateformat df = new simpledateformat ( str_ ) ; mapper . setdateformat ( df ) ; list < result > results ; try { results = mapper . readvalue ( response , new typereference < list < result > > ( ) { } ) ; } catch ( ioexception e ) { throw new sonarbreakexception ( str_ + response , e ) ; } if ( results == null || results . size ( ) != num_ ) { throw new sonarbreakexception ( str_ + response ) ; } return results . get ( num_ ) ; }	Parses the string response from sonar into POJOs.
private string computeidentifier ( final trackedcontententrydto transfer ) { string identifier = null ; switch ( transfer . getstorekey ( ) . getpackagetype ( ) ) { case maven_pkg_key : artifactpathinfo pathinfo = artifactpathinfo . parse ( transfer . getpath ( ) ) ; if ( pathinfo != null ) { artifactref aref = new simpleartifactref ( pathinfo . getprojectid ( ) , pathinfo . gettype ( ) , pathinfo . getclassifier ( ) ) ; identifier = aref . tostring ( ) ; } break ; case npm_pkg_key : npmpackagepathinfo npmpathinfo = npmpackagepathinfo . parse ( transfer . getpath ( ) ) ; if ( npmpathinfo != null ) { npmpackageref packageref = new npmpackageref ( npmpathinfo . getname ( ) , npmpathinfo . getversion ( ) ) ; identifier = packageref . tostring ( ) ; } break ; case generic_pkg_key :	Computes identifier string for an artifact.
private string computegenericidentifier ( string originurl , string localurl , string sha256 ) { string identifier = originurl ; if ( identifier == null ) {	Compute the identifier string for a generic download, that does not match package type specific files structure.It prefers to use the origin URL if it is not empty.
private artifact validateartifact ( artifact artifact ) throws repositorymanagerexception { set < constraintviolation < artifact > > violations = validator . validate ( artifact ) ; if ( ! violations . isempty ( ) ) { throw new repositorymanagerexception ( str_ + artifact . tostring ( ) + str_ , violations ) ; } return artifact ; }	Check artifact for any validation errors.
public boolean hasconfigdependencyon ( buildtask buildtask ) { if ( buildtask == null || this . equals ( buildtask ) ) { return bool_ ; } buildconfiguration buildconfiguration = buildconfigurationaudited . getbuildconfiguration ( ) ; if ( buildconfiguration == null || buildconfiguration . getalldependencies ( ) == null ) { return bool_ ; } return buildconfiguration . dependson ( buildtask . getbuildconfigurationaudited ( ) . getbuildconfiguration ( ) ) ; }	Check if this build task has a build configuration dependency on the given build task.The search include transitive dependencies.
public boolean hasdirectconfigdependencyon ( buildtask buildtask ) { if ( buildtask == null || this . equals ( buildtask ) ) { return bool_ ; } buildconfiguration buildconfiguration = buildconfigurationaudited . getbuildconfiguration ( ) ; if ( buildconfiguration == null || buildconfiguration . getdependencies ( ) == null ) { return bool_ ; } return buildconfiguration . getdependencies ( ) . contains ( buildtask . getbuildconfigurationaudited ( ) . getbuildconfiguration ( ) ) ; }	Check if this build task has a direct build configuration dependency on the given build task.
public < t extends abstractmoduleconfig > t parsejsonpncconfig ( string configcontent , configprovider < t > provider ) throws configurationparseexception { try { objectmapper mapper = new objectmapper ( ) ; provider . registerprovider ( mapper ) ; pncmodulegroup pncgroup = getmodulegroup ( mapper , configcontent , pncmodulegroup . class ) ; for ( abstractmoduleconfig config : pncgroup . getconfigs ( ) ) { if ( config . getclass ( ) . isassignablefrom ( provider . gettype ( ) ) ) { return ( t ) config ; } } throw new configurationparseexception ( str_ + provider . gettype ( ) . getsimplename ( ) + str_ ) ; } catch ( ioexception | runtimeexception e ) { log . error ( e . getmessage ( ) ) ; throw new configurationparseexception ( str_ , e ) ; } }	Loads JSON configuration to the module configuration object.
@ override public void monitor ( consumer < completedrepositorydeletion > oncomplete , consumer < exception > onerror ) { try { storekey fromkey = new storekey ( pakagetype , fromtype , fromid ) ; if ( indy . stores ( ) . exists ( fromkey ) ) { indy . stores ( ) . delete ( fromkey , str_ ) ; } oncomplete . accept ( new indycompleteddeletion ( bool_ ) ) ; } catch ( indyclientexception e ) { onerror . accept ( e ) ; } }	Trigger the repository deletion configured for this instance, and send the result to the appropriate consumer.
public void taskstatusupdatedtofinalstate ( ) {	Notify the set that the state of one of it's tasks has changed.
public buildtask getbuildtask ( buildconfigurationaudited buildconfigurationaudited ) { return buildtasks . stream ( ) . filter ( ( bt ) -> bt . getbuildconfigurationaudited ( ) . equals ( buildconfigurationaudited ) ) . findfirst ( ) . orelse ( null ) ; }	Get the build task which contains the given audited build configuration.
@ override public void monitor ( consumer < completedrepositorypromotion > oncomplete , consumer < exception > onerror ) { try { storekey fromkey = new storekey ( pakagetype , fromtype , fromid ) ; if ( ! indy . stores ( ) . exists ( fromkey ) ) { throw new repositorymanagerexception ( str_ , fromtype . singularendpointname ( ) , fromid ) ; } storekey tokey = new storekey ( pakagetype , storetype . group , toid ) ; group recordsetgroup = indy . stores ( ) . load ( tokey , group . class ) ; if ( recordsetgroup == null ) { throw new repositorymanagerexception ( str_ , toid ) ; } recordsetgroup . addconstituent ( fromkey ) ; boolean result = indy . stores ( ) . update ( recordsetgroup , str_ + fromtype . singularendpointname ( ) + str_ + fromid + str_ + toid ) ; oncomplete . accept ( new indycompletedpromotion ( result ) ) ; } catch ( indyclientexception | repositorymanagerexception e ) { onerror . accept ( e ) ; } }	Trigger the repository promotion configured for this instance, and send the result to the appropriate consumer.
public static < t > void merge ( graph < t > target , graph < t > tomerge ) { for ( vertex < t > vertex : tomerge . getverticies ( ) ) { target . addvertex ( vertex ) ; }	Adds all elements from toMerge to target.
public static string readfileasstring ( file filename ) throws ioexception { try ( scanner sc = new scanner ( filename , charset . defaultcharset ( ) . name ( ) ) ) { sc . usedelimiter ( str_ ) ; return sc . next ( ) ; } }	Reads whole content of file to String.
public static string readstreamasstring ( inputstream stream ) throws ioexception { try ( scanner sc = new scanner ( stream , charset . defaultcharset ( ) . name ( ) ) ) { sc . usedelimiter ( str_ ) ; return sc . next ( ) ; } }	Reads whole content of input stream to String.
public void startrelease ( productmilestone milestone , string accesstoken ) { productmilestonerelease release = triggerrelease ( milestone , accesstoken ) ; productmilestonereleaserepository . save ( release ) ; }	Starts milestone release process.
public void cleanup ( ) {	Regularly cleans finished BPM tasks asynchronouslyImmediate cleanup is not usable because of NCL-2300.
@ deprecated public integer gettaskidbybuildid ( int buildid ) { list < integer > result = tasks . values ( ) . stream ( ) . filter ( t -> t instanceof bpmbuildtask ) . filter ( t -> ( ( bpmbuildtask ) t ) . getbuildtask ( ) . getid ( ) == buildid ) . map ( bpmtask :: gettaskid ) . collect ( collectors . tolist ( ) ) ; if ( result . size ( ) > num_ ) throw new illegalstateexception ( str_ + result ) ; return result . size ( ) == num_ ? result . get ( num_ ) : null ; }	This method solves backwards compatibility problem.It will be removed soon.
public static < t > collector < collection < t > , list < t > , list < t > > toflatlist ( ) { return collector . of ( arraylist :: new , list :: addall , ( left , right ) -> { left . addall ( right ) ; return left ; } ) ; }	Flattening collector.Look at StreamCollectorsTest for example usage.
@ schedule public void cleanupexpiredtemporarybuilds ( ) throws validationexception { log . info ( str_ + temporary_build_lifespan + str_ ) ; date expirationthreshold = timeutils . getdatexdaysago ( temporary_build_lifespan ) ; string authtoken = serviceclient . getauthtoken ( ) ; deleteexpiredbuildconfigsetrecords ( expirationthreshold , authtoken ) ; deleteexpiredbuildrecords ( expirationthreshold , authtoken ) ; log . info ( str_ ) ; }	Cleanup old temporary builds every midnight.
private void setupbuildrepos ( buildexecution execution , string packagetype , indy indy , map < string , string > genericparameters ) throws indyclientexception { string buildcontentid = execution . getbuildcontentid ( ) ; int id = execution . getid ( ) ;	Create the hosted repository and group necessary to support a single build.
private void onrccreationsuccess ( bpmnotificationrest notification , buildconfigurationrest buildconfigurationrest ) { log . debug ( str_ + notification ) ; bpmstringmapnotificationrest repositorycreationtaskresult = ( bpmstringmapnotificationrest ) notification ; int repositoryconfigurationid = - num_ ; int buildconfigurationsavedid = - num_ ; try { repositoryconfigurationid = integer . valueof ( repositorycreationtaskresult . getdata ( ) . get ( str_ ) ) ; } catch ( numberformatexception ex ) { string errormessage = str_ + repositorycreationtaskresult + str_ + repositorycreationtaskresult . getdata ( ) . get ( str_ ) + str_ ; log . error ( errormessage , ex ) ; senderrormessage ( repositoryconfigurationid , buildconfigurationsavedid , errormessage ) ; return ; } repositoryconfiguration repositoryconfiguration = repositoryconfigurationrepository . querybyid ( repositoryconfigurationid ) ; if ( repositoryconfiguration == null ) { string errormessage = str_ ; log . error ( errormessage ) ; senderrormessage ( repositoryconfigurationid , buildconfigurationsavedid , errormessage ) ; return ; } if ( buildconfigurationrest != null ) {	Given the successful BC creation, add the BC into the BC sets.
private void addwebsocketforwardinglisteners ( repositorycreationtask task ) { consumer < ? extends bpmnotificationrest > donotify = ( e ) -> wsnotifier . sendmessage ( e ) ; task . addlistener ( bpmeventtype . rc_repo_creation_success , donotify ) ; task . addlistener ( bpmeventtype . rc_repo_creation_error , donotify ) ; task . addlistener ( bpmeventtype . rc_repo_clone_success , donotify ) ; task . addlistener ( bpmeventtype . rc_repo_clone_error , donotify ) ;	This method will add listeners to all important RCC event typesand forward the event to WS clients.
public static artifact mockimportedartifact ( int id ) { return getartifactbuilder ( id ) . importdate ( date . from ( instant . now ( ) ) ) . originurl ( str_ + id + str_ ) . build ( ) ; }	Create an artifact with an import date and origin url.
public static void setsslrequired ( boolean sslrequired ) { if ( httputil . sslrequired != sslrequired ) { httputil . sslrequired = sslrequired ; httputil . httpclient = null ; } }	Sets flag telling if SSL hostname validation should be done which also clears the cached httpClient.
public result deletetemporarybuild ( integer buildrecordid , string authtoken ) throws validationexception { buildrecord buildrecord = buildrecordrepository . findbyidfetchallproperties ( buildrecordid ) ; if ( ! buildrecord . istemporarybuild ( ) ) { throw new validationexception ( str_ ) ; } log . info ( str_ + buildrecord + str_ + buildrecord . getbuiltartifacts ( ) + str_ + buildrecord . getdependencies ( ) ) ; result result = remotebuildscleaner . deleteremotebuilds ( buildrecord , authtoken ) ; if ( ! result . issuccess ( ) ) { log . error ( str_ , buildrecord . getid ( ) ) ; return new result ( buildrecordid . tostring ( ) , result . status . failed , str_ ) ; } set < artifact > artifactstobedeleted = new hashset < > ( ) ; removerelationbuildrecordartifact ( buildrecord , artifactstobedeleted ) ; deleteartifacts ( artifactstobedeleted ) ; deletedependencies ( buildrecord ) ; buildrecordrepository . delete ( buildrecord . getid ( ) ) ; log . info ( str_ , buildrecord ) ; return new result ( buildrecordid . tostring ( ) , result . status . success ) ; }	Deletes a temporary build and artifacts created during the build or orphan dependencies used.
public result deletetemporarybuildconfigsetrecord ( integer buildconfigsetrecordid , string authtoken ) throws validationexception { buildconfigsetrecord buildconfigsetrecord = buildconfigsetrecordrepository . querybyid ( buildconfigsetrecordid ) ; if ( ! buildconfigsetrecord . istemporarybuild ( ) ) { throw new validationexception ( str_ ) ; } log . info ( str_ + buildconfigsetrecord ) ; for ( buildrecord br : buildconfigsetrecord . getbuildrecords ( ) ) { result result = deletetemporarybuild ( br . getid ( ) , authtoken ) ; if ( ! result . issuccess ( ) ) { return result ; } } buildconfigsetrecordrepository . delete ( buildconfigsetrecord . getid ( ) ) ; log . info ( str_ , buildconfigsetrecord ) ; return new result ( buildconfigsetrecordid . tostring ( ) , result . status . success ) ; }	Deletes a BuildConfigSetRecord and BuildRecords produced in the build.
@ override public buildsettask build ( buildconfigurationaudited buildconfigurationaudited , user user , buildoptions buildoptions ) throws buildconflictexception { return build0 ( user , buildoptions , buildconfigurationaudited ) ; }	Run a single build.
private void checkforemptybuildsettask ( buildsettask buildsettask ) { if ( buildsettask . getbuildtasks ( ) == null || buildsettask . getbuildtasks ( ) . isempty ( ) ) { updatebuildsettaskstatus ( buildsettask , buildsetstatus . rejected , str_ ) ; } }	Check if the given build set task is empty and update the status message appropriately.
public environmentdriver getdriver ( systemimagetype systemimagetype ) throws executorexception { for ( environmentdriver driver : availabledrivers ) { if ( driver . canrunimagetype ( systemimagetype ) ) return driver ; } throw new executorexception ( str_ + systemimagetype + str_ ) ; }	Gets environment driver, which can manage requested environment.
public static predicate < buildconfiguration > isnotarchived ( ) { return ( root , query , cb ) -> cb . istrue ( root . get ( buildconfiguration_ . active ) ) ; }	Return a predicate which excludes all archived build configurations.
private void loadbuildconfigurations ( buildconfigurationaudited buildconfigaudited ) { project project = buildconfigaudited . getproject ( ) ; project . getbuildconfigurations ( ) . foreach ( buildconfiguration :: getid ) ; }	Fetch build configurations of project to be able access it outside transaction.
private buildrecord . builder initbuildrecordbuilder ( buildtask buildtask ) { buildoptions buildoptions = buildtask . getbuildoptions ( ) ; buildrecord . builder builder = buildrecord . builder . newbuilder ( ) . id ( buildtask . getid ( ) ) . buildconfigurationaudited ( buildtask . getbuildconfigurationaudited ( ) ) . user ( buildtask . getuser ( ) ) . submittime ( buildtask . getsubmittime ( ) ) . starttime ( buildtask . getstarttime ( ) ) . productmilestone ( buildtask . getproductmilestone ( ) ) . temporarybuild ( buildoptions . istemporarybuild ( ) ) ; if ( buildtask . getendtime ( ) == null ) { buildtask . setendtime ( date . from ( instant . now ( ) ) ) ; } builder . endtime ( buildtask . getendtime ( ) ) ; if ( buildtask . getbuildconfigsetrecordid ( ) != null ) { buildconfigsetrecord buildconfigsetrecord = datastore . getbuildconfigsetrecordbyid ( buildtask . getbuildconfigsetrecordid ( ) ) ; builder . buildconfigsetrecord ( buildconfigsetrecord ) ; } list < integer > dependencies = buildtask . getdependencies ( ) . stream ( ) . map ( t -> t . getid ( ) ) . collect ( collectors . tolist ( ) ) ; builder . dependencybuildrecordids ( dependencies . toarray ( new integer [ dependencies . size ( ) ] ) ) ; list < integer > dependants = buildtask . getdependants ( ) . stream ( ) . map ( t -> t . getid ( ) ) . collect ( collectors . tolist ( ) ) ; builder . dependentbuildrecordids ( dependants . toarray ( new integer [ dependants . size ( ) ] ) ) ; return builder ; }	Initialize a new BuildRecord.Builder based on the data contained in the BuildTask.Note, this must be done inside a transaction because it fetches the BuildRecordSet entities fromthe database.
public static predicate < productversion > withbuildconfigurationid ( integer buildconfigurationid ) { return ( root , query , cb ) -> { setjoin < productversion , buildconfiguration > buildconfigurationjoin = root . join ( productversion_ . buildconfigurations ) ; return cb . equal ( buildconfigurationjoin . get ( buildconfiguration_ . id ) , buildconfigurationid ) ; } ; }	This predicate returns all the ProductVersions linked to a specified BuildConfiguration.
boolean isjenkinsserversecuredwithcsrf ( string url ) throws builddriverexception { try { jenkinsbuilddrivermoduleconfig config = configuration . getmoduleconfig ( new pncconfigprovider < jenkinsbuilddrivermoduleconfig > ( jenkinsbuilddrivermoduleconfig . class ) ) ; string username = config . getusername ( ) ; string password = config . getpassword ( ) ; if ( url == null || username == null || password == null ) { throw new builddriverexception ( str_ + jenkinsbuilddriver . driver_id + str_ ) ; } try { jenkinshttpclient jenkinshttpclient = new jenkinshttpclient ( new uri ( url ) , username , password ) ; try { jenkinshttpclient . get ( str_ ) ; return bool_ ; } catch ( ioexception e ) { return bool_ ; } } catch ( urisyntaxexception e ) { throw new builddriverexception ( str_ + jenkinsbuilddriver . driver_id + str_ + url , e ) ; } } catch ( configurationparseexception e ) { throw new builddriverexception ( str_ + jenkinsbuilddriver . driver_id + str_ , e ) ; } }	This checks if jenkins does not use option Prevent Cross Site Request Forgery exploitsmnovotny: TODO: see NCL-669 this method should be placed in producing JenkinsServer, but as CSRF is not propagatedout from JenkinsServer instance, we need to figure out the setting by special API call through JenkinsHttpClient.
private set < artifact > saveartifacts ( collection < artifact > artifacts , map < string , targetrepository > repositoriescache , map < artifact . identifiersha256 , artifact > artifactcache ) { logger . debug ( str_ , artifacts . size ( ) ) ; set < artifact > savedartifacts = new hashset < > ( ) ; set < artifact . identifiersha256 > artifactconstraints = new hashset < > ( ) ; for ( artifact artifact : artifacts ) { artifactconstraints . add ( new artifact . identifiersha256 ( artifact . getidentifier ( ) , artifact . getsha256 ( ) ) ) ; } set < artifact > artifactsindb = null ; if ( artifactconstraints . size ( ) > num_ ) { artifactsindb = artifactrepository . withidentifierandsha256s ( artifactconstraints ) ; } if ( artifactsindb != null ) { for ( artifact artifact : artifactsindb ) { logger . trace ( str_ , artifact ) ; artifactcache . put ( artifact . getidentifiersha256 ( ) , artifact ) ; } } for ( artifact artifact : artifacts ) { targetrepository targetrepository = artifact . gettargetrepository ( ) ; linktargetrepository ( repositoriescache , artifact , targetrepository ) ; artifact artifactfromdb ; if ( repositorytype . generic_proxy . equals ( targetrepository . getrepositorytype ( ) ) ) { artifactfromdb = savehttpartifact ( artifact ) ; } else { artifactfromdb = getorsaverepositoryartifact ( artifact , artifactcache ) ; } savedartifacts . add ( artifactfromdb ) ; } logger . debug ( str_ , artifacts ) ; return savedartifacts ; }	Checks the given list against the existing database and creates a new list containingartifacts which have been saved to or loaded from the database.
@ override @ transactionattribute ( transactionattributetype . requires_new ) public buildconfigsetrecord savebuildconfigsetrecord ( buildconfigsetrecord buildconfigsetrecord ) { return buildconfigsetrecordrepository . save ( buildconfigsetrecord ) ; }	Save a build config set record to the db.
@ override public set < buildconfiguration > getbuildconfigurations ( buildconfigurationset buildconfigurationset ) { return new hashset < > ( buildconfigurationrepository . querywithpredicates ( withbuildconfigurationsetid ( buildconfigurationset . getid ( ) ) ) ) ; }	Rebuild is required if Build Configuration has been modified or a dependency has been rebuilt since last successful build.
private boolean hasarebuiltimplicitdependency ( buildrecord latestsuccessfulbuildrecord , boolean temporarybuild ) { collection < buildrecord > lastbuiltfrom = getrecordsusedfor ( latestsuccessfulbuildrecord ) ; return lastbuiltfrom . stream ( ) . anymatch ( br -> hasnewerversion ( br , temporarybuild ) ) ; }	Check is some of the dependencies from the previous build were rebuild.Checking is done based on captured dependencies which are stored in the Build Record.
private boolean hasarebuiltexplicitdependency ( buildrecord latestsuccessfulbuildrecord , set < buildconfiguration > dependencies , boolean temporarybuild ) { for ( buildconfiguration dependencybuildconfiguration : dependencies ) { buildrecord dependencylatestsuccessfulbuildrecord = buildrecordrepository . getlatestsuccessfulbuildrecord ( dependencybuildconfiguration . getid ( ) , temporarybuild ) ; if ( dependencylatestsuccessfulbuildrecord == null ) { return bool_ ; } boolean newer = dependencylatestsuccessfulbuildrecord . getendtime ( ) . after ( latestsuccessfulbuildrecord . getendtime ( ) ) ; if ( newer ) { return bool_ ; } } return bool_ ; }	Check is some of the dependencies defined on BuildConfiguration has newer version.
public < t extends bpmnotificationrest > void addlistener ( bpmeventtype eventtype , consumer < t > listener ) { list < consumer < ? > > consumers = listeners . computeifabsent ( eventtype , ( k ) -> new arraylist < > ( ) ) ; consumers . add ( listener ) ; }	Listen to notifications from BPM process for this task.
map < string , object > getextendedprocessparameters ( ) throws coreexception { serializable processparameters = getprocessparameters ( ) ; requirenonnull ( processparameters ) ; map < string , object > actualparameters = new hashmap < > ( ) ; try { actualparameters . put ( str_ , mapper . writevalueasstring ( processparameters ) ) ; } catch ( jsonprocessingexception e ) { throw new coreexception ( str_ + processparameters + str_ , e ) ; }	Extend process parameters from the task with additional useful information,such as pncBaseUrl and taskId, needed for notifications.Before use, taskId MUST be assigned.
private boolean collectdependentconfigurations ( buildconfiguration buildconfiguration , buildconfigurationaudited buildconfigurationaudited , set < buildconfigurationaudited > tobuild , set < buildconfiguration > visited , boolean checkimplicitdependencies , boolean forcerebuild , boolean temporarybuild ) { if ( visited . contains ( buildconfiguration ) ) { return tobuild . contains ( buildconfigurationaudited ) ; } visited . add ( buildconfiguration ) ; boolean requiresrebuild = forcerebuild || datastoreadapter . requiresrebuild ( buildconfigurationaudited , checkimplicitdependencies , temporarybuild ) ; for ( buildconfiguration dependency : buildconfiguration . getdependencies ( ) ) { boolean dependencyrequiresrebuild = collectdependentconfigurations ( dependency , datastoreadapter . getlatestbuildconfigurationauditedinitializebcdependencies ( dependency . getid ( ) ) , tobuild , visited , checkimplicitdependencies , forcerebuild , temporarybuild ) ; requiresrebuild = requiresrebuild || dependencyrequiresrebuild ; } log . debug ( str_ , buildconfiguration . getid ( ) , requiresrebuild ) ; if ( requiresrebuild ) { tobuild . add ( buildconfigurationaudited ) ; } return requiresrebuild ; }	Collects all BuildConfigurationAudited entities, that needs to be built.
public buildsettask createbuildsettask ( buildconfigurationset buildconfigurationset , user user , buildoptions buildoptions , supplier < integer > buildtaskidprovider , set < buildtask > submittedbuildtasks ) throws coreexception { return createbuildsettask ( buildconfigurationset , collections . emptymap ( ) , user , buildoptions , buildtaskidprovider , submittedbuildtasks ) ; }	Create a BuildSetTask of latest revisions of BuildConfigurations contained in the BuildConfigurationSet.
public buildsettask createbuildsettask ( buildconfigurationset buildconfigurationset , map < integer , buildconfigurationaudited > buildconfigurationauditedsmap , user user , buildoptions buildoptions , supplier < integer > buildtaskidprovider , set < buildtask > submittedbuildtasks ) throws coreexception { buildsettask buildsettask = initbuildsettask ( buildconfigurationset , user , buildoptions ) ; set < buildconfigurationaudited > buildconfigurationauditeds = new hashset < > ( ) ; for ( buildconfiguration buildconfiguration : datastoreadapter . getbuildconfigurations ( buildconfigurationset ) ) { buildconfigurationaudited buildconfigurationaudited = buildconfigurationauditedsmap . get ( buildconfiguration . getid ( ) ) ; if ( buildconfigurationaudited == null ) { buildconfigurationaudited = datastoreadapter . getlatestbuildconfigurationauditedinitializebcdependencies ( buildconfiguration . getid ( ) ) ; } buildconfigurationauditeds . add ( buildconfigurationaudited ) ; }	Create a BuildSetTask of BuildConfigurations contained in the BuildConfigurationSet.A specific revision of the BuildConfigurations contained in the set is used,if it's available in the buildConfigurationAuditedsMap parameter.If it's not available, latest revision of the BuildConfiguration is used.
private void fillbuildtaskset ( buildsettask buildsettask , user user , supplier < integer > buildtaskidprovider , productmilestone productmilestone , set < buildconfigurationaudited > tobuild , set < buildtask > alreadysubmittedbuildtasks , buildoptions buildoptions ) { for ( buildconfigurationaudited buildconfigaudited : tobuild ) { optional < buildtask > taskoptional = alreadysubmittedbuildtasks . stream ( ) . filter ( bt -> bt . getbuildconfigurationaudited ( ) . equals ( buildconfigaudited ) ) . findany ( ) ; buildtask buildtask ; if ( taskoptional . ispresent ( ) ) { buildtask = taskoptional . get ( ) ; log . debug ( str_ , buildconfigaudited , buildtask ) ; } else { int buildid = buildtaskidprovider . get ( ) ; string buildcontentid = contentidentitymanager . getbuildcontentid ( buildid ) ; mdcutils . addbuildcontext ( buildcontentid , buildoptions . istemporarybuild ( ) , temporarybuildexpiredate ) ; buildtask = buildtask . build ( buildconfigaudited , buildsettask . getbuildoptions ( ) , user , buildid , buildsettask , buildsettask . getstarttime ( ) , productmilestone , buildcontentid ) ; log . debug ( str_ , buildtask , buildconfigaudited ) ; } buildsettask . addbuildtask ( buildtask ) ; }	Creates build tasks and sets up the appropriate dependency relations.
public collectioninfo < artifactrest > getbuiltartifactsforbuildrecord ( int pageindex , int pagesize , string sortingrsql , string query , int buildrecordid ) { return queryforcollection ( pageindex , pagesize , sortingrsql , query , withbuildrecordid ( buildrecordid ) ) ; }	Lookups built artifacts for the specified BuildRecord.
public static string addendingslash ( string string ) { if ( string == null ) { return null ; } if ( ! string . endswith ( str_ ) ) { string += str_ ; } return string ; }	Adds ending slash if it is not present.
public static integer [ ] deserializeint ( string string ) { if ( string == null ) { return new integer [ num_ ] ; } return arrays . stream ( string . split ( str_ ) ) . filter ( s -> ! s . equals ( str_ ) ) . map ( integer :: parseint ) . toarray ( integer [ ] :: new ) ; }	Parse comma separated string to Integer array.
public static string serializeint ( integer [ ] integers ) { if ( integers == null ) { return str_ ; } return arrays . stream ( integers ) . map ( i -> integer . tostring ( i ) ) . collect ( collectors . joining ( str_ ) ) ; }	Serialize Integer array to comma separated string.
public synchronized boolean addreadytask ( buildtask task ) { if ( ! task . readytobuild ( ) ) { throw new illegalargumentexception ( str_ + task ) ; } unfinishedtasks . add ( task ) ; log . debug ( str_ , task ) ; readytasks . add ( task ) ; return bool_ ; }	Add a new, ready to build task to queue.
public synchronized void addwaitingtask ( buildtask task , runnable taskreadycallback ) { unfinishedtasks . add ( task ) ; log . debug ( str_ , task ) ; waitingtaskswithcallbacks . put ( task , taskreadycallback ) ; }	Add a task that is waiting for dependencies.
public synchronized void executenewreadytasks ( ) { list < buildtask > newreadytasks = extractreadytasks ( ) ; log . debug ( str_ , newreadytasks ) ; readytasks . addall ( newreadytasks ) ; }	Trigger searching for ready tasks in the waiting queue.This method should be invoked if one task has finished and there's a possibility that other tasks became ready to be built.
public synchronized optional < buildtask > gettask ( buildconfigurationaudited buildconfigaudited ) { optional < buildtask > ready = readytasks . stream ( ) . filter ( bt -> bt . getbuildconfigurationaudited ( ) . equals ( buildconfigaudited ) ) . findany ( ) ; optional < buildtask > waiting = waitingtaskswithcallbacks . keyset ( ) . stream ( ) . filter ( bt -> bt . getbuildconfigurationaudited ( ) . equals ( buildconfigaudited ) ) . findany ( ) ; optional < buildtask > inprogress = tasksinprogress . stream ( ) . filter ( bt -> bt . getbuildconfigurationaudited ( ) . equals ( buildconfigaudited ) ) . findany ( ) ; return ready . ispresent ( ) ? ready : waiting . ispresent ( ) ? waiting : inprogress ; }	Get build task for given build configuration from the queue.
static boolean istrusted ( string artifactoriginurl , targetrepository targetrepository ) { if ( targetrepository . temporaryrepo ) { return bool_ ; } if ( artifactoriginurl == null || artifactoriginurl . isempty ( ) ) { return bool_ ; } for ( string trustedrepourl : trusted_repository_urls ) { if ( artifactoriginurl . startswith ( trustedrepourl ) ) { return bool_ ; } } return bool_ ; }	Check if a given artifact originates from a trusted source.
public buildrecord addbuildrecord ( buildrecord buildrecord ) { getbuildrecords ( ) . add ( buildrecord ) ; buildrecord . setuser ( this ) ; return buildrecord ; }	Adds the project build record.
public buildrecord removebuildrecord ( buildrecord buildrecord ) { getbuildrecords ( ) . remove ( buildrecord ) ; buildrecord . setuser ( null ) ; return buildrecord ; }	Removes the project build record.
public boolean deletetemporarybuild ( integer buildrecordid , string authtoken , consumer < result > oncomplete ) throws validationexception { buildrecord buildrecord = buildrecordrepository . findbyidfetchallproperties ( buildrecordid ) ; if ( buildrecord == null ) { return bool_ ; } if ( ! buildrecord . istemporarybuild ( ) ) { throw new validationexception ( str_ ) ; } executorservice . submit ( ( ) -> { try { result result = temporarybuildscleaner . deletetemporarybuild ( buildrecordid , authtoken ) ; oncomplete . accept ( result ) ; } catch ( validationexception e ) { logger . error ( str_ + buildrecordid + str_ , e ) ; oncomplete . accept ( new result ( buildrecordid . tostring ( ) , result . status . failed , str_ ) ) ; } } ) ; return bool_ ; }	Deletes a single temporary build.
public set < buildconfiguration > getalldependencies ( ) { set < buildconfiguration > alldependencies = new hashset < buildconfiguration > ( ) ; alldependencies . addall ( getdependencies ( ) ) ; alldependencies . addall ( getindirectdependencies ( ) ) ; return alldependencies ; }	Get the full set of both the direct and indirect dependencies.
private boolean adddependant ( buildconfiguration dependant ) { boolean result = dependants . add ( dependant ) ; if ( ! dependant . getdependencies ( ) . contains ( this ) ) { dependant . adddependency ( this ) ; } return result ; }	This method is private because a dependant should never be added externally. Instead the dependency relation should beset up using the addDependency method.
private boolean removedependant ( buildconfiguration dependant ) { boolean result = dependants . remove ( dependant ) ; if ( dependant . getdependencies ( ) . contains ( this ) ) { dependant . removedependency ( this ) ; } return result ; }	This method is private because a dependant should never be removed externally. Instead the dependency relation should beset up using the removeDependency method.
public static string retrieveclonename ( string bcname , date now ) { string bcnametoappend = str_ ; int index = bcname . indexof ( str_ ) ; if ( index == - num_ ) {	Change the BC clone name into date_original-BC-name where date will be for every clone updated and for original BC nameswill be added.Example: clone1 of pslegr-BC on Wednesday October,21st, 2015: 20151021095415_pslegr-BCclone2 of 20151021095415_pslegr-BC on Thursday October,22nd, 2015: 20151022nnnnnn_pslegr-BCclone3 of pslegr-BC on Friday October,23rd, 2015: 20151023nnnnnn_pslegr-BC.
@ suppresswarnings ( str_ ) public < t extends abstractmoduleconfig > t getmoduleconfig ( configprovider < t > provider ) throws configurationparseexception { class < t > moduleclass = provider . gettype ( ) ; if ( configcache . containskey ( moduleclass ) ) return ( t ) configcache . get ( moduleclass ) ; synchronized ( this ) { if ( configcache . containskey ( moduleclass ) ) { return ( t ) configcache . get ( moduleclass ) ; } t config = configurationjsonparser . parsejsonpncconfig ( config_string , provider ) ; configcache . put ( moduleclass , config ) ; return config ; } }	Reads configuration for module.
private static embeddedtomcat instantiate ( class < ? > klass ) { embeddedtomcatconfiguration configuration = extractconfiguration ( klass ) ; return configuration == null ? new embeddedtomcat ( ) : new embeddedtomcat ( configuration ) ; }	Instantiate embedded tomcat to be used in tests.
private void unregisterembeddedserver ( extensioncontext context , boolean staticmode ) { boolean registeredasstatic = findinstore ( context , server_runner_static_mode ) ; if ( registeredasstatic == staticmode ) { try { embeddedserverrunner serveradapter = findembeddedserveradapterinstore ( context ) ; serveradapter . afterall ( ) ; } finally { removeembeddedserveradapterfromstore ( context ) ; } } }	Stop and remove from the store the started embedded server.
@ suppresswarnings ( str_ ) private static < t > void putinstore ( extensioncontext context , string name , t value ) { getstore ( context ) . put ( name , value ) ; }	Put value in the internal store.
@ suppresswarnings ( str_ ) private static < t > t findinstore ( extensioncontext context , string name ) { return ( t ) getstore ( context ) . get ( name ) ; }	Find value in the internal store.
public static string concatenatepath ( string path , string endpoint ) { string firstsegment = ensureabsolutepath ( path ) ; if ( endpoint == null || endpoint . isempty ( ) ) { return firstsegment ; } stringbuilder sb = new stringbuilder ( firstsegment ) ; if ( path . charat ( path . length ( ) - num_ ) != path_separator ) { sb . append ( path_separator ) ; } if ( endpoint . charat ( num_ ) == path_separator ) { sb . append ( endpoint . substring ( num_ ) ) ; } else { sb . append ( endpoint ) ; } return sb . tostring ( ) ; }	Concatenate two path value.
@ deprecated protected context createcontext ( ) throws exception { context context = null ; final string webapp = configuration . getwebapp ( ) ; final string path = configuration . getpath ( ) ; final string classpath = configuration . getclasspath ( ) ; final boolean forcemetainf = configuration . isforcemetainf ( ) ; final classloader parentclassloader = configuration . getparentclasspath ( ) ; final string descriptor = configuration . getoverridedescriptor ( ) ; file webappdirectory = new file ( webapp ) ; if ( webappdirectory . exists ( ) ) { string webappabsolutepath = webappdirectory . getabsolutepath ( ) ; tomcat . gethost ( ) . setappbase ( webappabsolutepath ) ; context = tomcat . addwebapp ( path , webappabsolutepath ) ;	Create tomcat context.May be override by subclasses.
public static cookie read ( string rawvalue ) { notblank ( rawvalue , str_ ) ; final string [ ] parts = rawvalue . split ( field_separator ) ;	Create a cookie from header value.
public static httpheader header ( string name , string value ) { return new httpheader ( name , singletonlist ( value ) ) ; }	Create a header with a single value.
public static httpheader header ( string name , collection < string > values ) { return new httpheader ( name , values ) ; }	Create a header with multiple values.
private webappcontext createdwebappcontext ( ) throws exception { final string path = configuration . getpath ( ) ; final string webapp = configuration . getwebapp ( ) ; final string classpath = configuration . getclasspath ( ) ; final classloader parentclassloader = configuration . getparentclassloader ( ) ; final string overridedescriptor = configuration . getoverridedescriptor ( ) ; final resource baseresource = configuration . getbaseresource ( ) ; final string containerjarpattern = configuration . getcontainerjarpattern ( ) ; final string webinfjarpattern = configuration . getwebinfjarpattern ( ) ; webappcontext ctx = new webappcontext ( ) ; if ( containerjarpattern != null ) { ctx . setattribute ( webinfconfiguration . container_jar_pattern , containerjarpattern ) ; } else if ( javautils . ispostjdk9 ( ) ) {	Build web app context used to launch server.May be override by subclasses.
private void exechooks ( boolean pre ) { for ( hook hook : configuration . gethooks ( ) ) { if ( pre ) { hook . pre ( this ) ; } else { hook . post ( this ) ; } } }	Exec hooks phase.
private void process ( object target , boolean before ) { list < field > fields = findallfields ( target . getclass ( ) ) ; for ( field field : fields ) { for ( annotationhandler handler : handlers ) { processfield ( target , handler , field , before ) ; } } }	Process handlers.
private void processfield ( object target , annotationhandler handler , field field , boolean before ) { for ( annotation annotation : field . getannotations ( ) ) { if ( handler . support ( annotation ) ) { if ( before ) { handler . before ( target , field ) ; } else { handler . after ( target , field ) ; } } } }	Process field for given handler.
@ deprecated public static apachehttpclient newapachehttpclient ( embeddedserver < ? > server , closeablehttpclient client ) { return new apachehttpclient ( httpclientconfiguration . defaultconfiguration ( ) , server , client ) ; }	Create new http client using internal with custom internal client.
public static apachehttpclient defaultapachehttpclient ( embeddedserver < ? > server ) { httpclientconfiguration configuration = httpclientconfiguration . defaultconfiguration ( ) ; return newapachehttpclient ( configuration , server ) ; }	Create new http client using default internal client.
private void handlebody ( httprequestbase httprequest ) { if ( hasbody ( ) ) { httpentityenclosingrequestbase rq = ( httpentityenclosingrequestbase ) httprequest ; if ( ! formparams . isempty ( ) ) { handleformparameters ( rq ) ; } else if ( body != null ) { handlerequestbody ( rq ) ; } } }	Add request body.
private uri createrequesturi ( ) throws urisyntaxexception { uri uri = getendpoint ( ) . touri ( ) ; uribuilder builder = new uribuilder ( uri ) . setcharset ( standardcharsets . utf_8 ) ; for ( httpparameter parameter : queryparams . values ( ) ) { builder . addparameter ( parameter . getname ( ) , parameter . getvalue ( ) ) ; } return builder . build ( ) ; }	Create request URI.Each additional query parameters will be appended to final URI.
private void handleheaders ( httprequestbase httprequest ) { for ( httpheader header : headers . values ( ) ) { httprequest . addheader ( header . getname ( ) , header . serializevalues ( ) ) ; } }	Add headers to http request.
private void handleformparameters ( httpentityenclosingrequestbase httprequest ) { list < namevaluepair > pairs = map ( formparams . values ( ) , param_mapper ) ; httpentity entity = new urlencodedformentity ( pairs , charset . defaultcharset ( ) ) ; httprequest . setentity ( entity ) ; }	Add parameters as form url encoded content.Each parameter is set as a key value entry to requestbody.
private void handlerequestbody ( httpentityenclosingrequestbase httprequest ) { httpentity entity = new stringentity ( body , charset . defaultcharset ( ) ) ; httprequest . setentity ( entity ) ; }	Set request body value to http request.
private void handlecookies ( httprequestbase httprequest ) { if ( ! cookies . isempty ( ) ) { httprequest . addheader ( cookie , cookies . serialize ( cookies ) ) ; } }	Add cookies to http request.
public static asynchttpclient defaultasynchttpclient ( embeddedserver < ? > server ) { httpclientconfiguration configuration = httpclientconfiguration . defaultconfiguration ( ) ; return newasynchttpclient ( configuration , server ) ; }	Create new http client using default internal http client.
private static int parsejavaversion ( ) { string [ ] parts = java_specification_version . split ( str_ ) ; int nbparts = parts . length ; int majorindex = nbparts > num_ ? num_ : num_ ; return integer . parseint ( parts [ majorindex ] ) ; }	Parse java version.
public static < t , u > list < u > map ( collection < t > inputs , mapper < t , u > mapper ) { if ( inputs == null ) { return null ; } list < u > outputs = new arraylist < > ( inputs . size ( ) ) ; for ( t input : inputs ) { outputs . add ( mapper . apply ( input ) ) ; } return outputs ; }	Map input values to output values.
public static < t > list < t > concat ( list < t > inputs , t newvalue ) { list < t > outputs = new arraylist < > ( inputs . size ( ) + num_ ) ; outputs . addall ( inputs ) ; outputs . add ( newvalue ) ; return outputs ; }	Concat new value to existing inputs and returns new outputs.Note that input is not modified.
static < t > list < t > filter ( list < t > list , predicate < t > predicate ) { list < t > results = new arraylist < > ( ) ; for ( t current : list ) { if ( predicate . apply ( current ) ) { results . add ( current ) ; } } return results ; }	Filter input by using given predicate and returnfiltered outputs.
public static defaulthttpresponse of ( long duration , int status , string body , collection < httpheader > headers ) { return new defaulthttpresponse ( duration , status , body , headers ) ; }	Create a default HTTP Response from given values.
private static embeddedjetty instantiate ( class < ? > klass ) { final embeddedjettyconfiguration configuration = extractconfiguration ( klass ) ; return configuration == null ? new embeddedjetty ( ) : new embeddedjetty ( configuration ) ; }	Instantiate embedded jetty to be used in tests.
public static okhttpclient defaultokhttpclient ( embeddedserver < ? > server ) { httpclientconfiguration configuration = httpclientconfiguration . defaultconfiguration ( ) ; return newokhttpclient ( configuration , server ) ; }	Create new http client using internalhttp client from ok-http library.
@ deprecated public static okhttpclient newokhttpclient ( embeddedserver < ? > server , okhttp3 . okhttpclient client ) { return new okhttpclient ( httpclientconfiguration . defaultconfiguration ( ) , server , client ) ; }	Create new http client using custom internalhttp client from ok-http library.
public static list < field > findallfields ( class < ? > type ) { list < field > fields = new linkedlist < > ( ) ; if ( type != null ) { addall ( fields , type . getdeclaredfields ( ) ) ; if ( type . getsuperclass ( ) != null ) { fields . addall ( findallfields ( type . getsuperclass ( ) ) ) ; } } return fields ; }	Get all fields on given object and look for fields ofsuper classes.
private static list < field > findstaticfields ( class < ? > type ) { return filter ( aslist ( type . getdeclaredfields ( ) ) , static_field_predicate ) ; }	Get all static fields on given class object.
private static list < method > findstaticmethods ( class < ? > type ) { return filter ( aslist ( type . getdeclaredmethods ( ) ) , static_method_predicate ) ; }	Get all static methods on given class object.
public static list < field > findstaticfieldsannotatedwith ( class < ? > type , class < ? extends annotation > klass ) { list < field > fields = findstaticfields ( type ) ; return filter ( fields , new fieldannotatedwithpredicate ( klass ) ) ; }	Get all static fields on given class objectannotated with given annotation.
public static list < method > findstaticmethodsannotatedwith ( class < ? > type , class < ? extends annotation > klass ) { list < method > methods = findstaticmethods ( type ) ; return filter ( methods , new methodannotatedwithpredicate ( klass ) ) ; }	Get all static methods on given class objectannotated with given annotation.
public static void setter ( object instance , field field , object value ) { boolean forceaccess = bool_ ; try { if ( ! field . isaccessible ( ) ) { forceaccess = bool_ ; field . setaccessible ( bool_ ) ; } field . set ( instance , value ) ; } catch ( illegalaccessexception ex ) { throw new reflectionexception ( ex ) ; } finally { if ( forceaccess ) { field . setaccessible ( bool_ ) ; } } }	Set value of given field on given instance.
@ suppresswarnings ( str_ ) public static < t > t getter ( object target , field field ) { boolean forceaccess = bool_ ; try { if ( ! field . isaccessible ( ) ) { field . setaccessible ( bool_ ) ; forceaccess = bool_ ; } return ( t ) field . get ( target ) ; } catch ( illegalaccessexception ex ) { throw new reflectionexception ( ex ) ; } finally { if ( forceaccess ) { field . setaccessible ( bool_ ) ; } } }	Get value of field on target object.If target is null, it means that field is static and do notneed any target instance.
@ suppresswarnings ( str_ ) public static < t > t invoke ( method method ) { boolean forceaccess = bool_ ; try { if ( ! method . isaccessible ( ) ) { method . setaccessible ( bool_ ) ; forceaccess = bool_ ; } return ( t ) method . invoke ( null ) ; } catch ( invocationtargetexception | illegalaccessexception ex ) { throw new reflectionexception ( ex ) ; } finally { if ( forceaccess ) { method . setaccessible ( bool_ ) ; } } }	Invoke the static method without any arguments.
public static string format ( date date , string pattern ) { return df ( pattern ) . format ( date ) ; }	Format date according to given pattern.
static string formattime ( long time , string pattern ) { date date = new date ( ) ; date . settime ( time ) ; return format ( date , pattern ) ; }	Format timestamp according to given pattern.
private void handleheaders ( request . builder builder ) { for ( httpheader h : headers . values ( ) ) { builder . addheader ( h . getname ( ) , h . serializevalues ( ) ) ; } }	Add all HTTP headers to the final request.
static boolean isblank ( string value ) { if ( value == null ) { return bool_ ; } for ( char character : value . tochararray ( ) ) { if ( ! character . iswhitespace ( character ) ) { return bool_ ; } } return bool_ ; }	Check that given string is blank.
public static string removeprefix ( string value , string prefix ) { if ( value == null || prefix == null || prefix . length ( ) > value . length ( ) ) { return value ; } return value . startswith ( prefix ) ? value . substring ( prefix . length ( ) ) : value ; }	Remove string prefix if and only if string value starts withthe prefix, otherwise original string is returned.
public static string join ( string separator , collection < string > values ) { stringbuilder builder = new stringbuilder ( ) ; boolean first = bool_ ; for ( string value : values ) { if ( ! first ) { builder . append ( separator ) ; } builder . append ( value ) ; first = bool_ ; } return builder . tostring ( ) ; }	Join all strings to a single one using given separator.
private void handlequeryparameters ( requestbuilder builder ) { for ( httpparameter p : queryparams . values ( ) ) { builder . addqueryparam ( p . getencodedname ( ) , p . getencodedvalue ( ) ) ; } }	Add query parameter to the final HTTP request.
private void handlebody ( requestbuilder builder ) { if ( ! hasbody ( ) ) { return ; } if ( body != null ) { handlerequestbody ( builder ) ; } else { handleformparameters ( builder ) ; } }	Add body entity to the final HTTP request.
private void handleformparameters ( requestbuilder builder ) { for ( httpparameter p : formparams . values ( ) ) { builder . addformparam ( p . getname ( ) , p . getvalue ( ) ) ; } }	Serialize form parameters to the request body.
private void handlecookies ( requestbuilder builder ) { if ( ! cookies . isempty ( ) ) { builder . addheader ( httpheaders . cookie , cookies . serialize ( cookies ) ) ; } }	Add cookies to the final HTTP request.
private void handleheaders ( requestbuilder builder ) { for ( httpheader header : headers . values ( ) ) { builder . addheader ( header . getname ( ) , header . serializevalues ( ) ) ; } }	Add request headers.
public tostringbuilder append ( string name , map < ? , ? > map ) { stringbuilder sb = new stringbuilder ( start_obj ) ; for ( map . entry < ? , ? > entry : map . entryset ( ) ) { sb . append ( entry . getkey ( ) ) . append ( field_value_separator ) . append ( formatvalue ( entry . getvalue ( ) ) ) ; } sb . append ( end_obj ) ; return appendformattedvalue ( name , sb . tostring ( ) ) ; }	Append new map value.
public < t > tostringbuilder append ( string name , iterable < t > values ) { stringbuilder pending = new stringbuilder ( ) . append ( open_array ) ; boolean firstitem = bool_ ; for ( t value : values ) { if ( ! firstitem ) { pending . append ( separator ) ; } pending . append ( formatvalue ( value ) ) ; firstitem = bool_ ; } return appendformattedvalue ( name , pending . append ( close_array ) . tostring ( ) ) ; }	Append new boolean value.
private tostringbuilder appendformattedvalue ( string name , object value ) { if ( ! first ) { sb . append ( separator ) ; } sb . append ( name ) . append ( field_value_separator ) . append ( value ) ; first = bool_ ; return this ; }	Append formatted value to the final output.
protected sipdialog getdialogfromdistributedcache ( string dialogid ) { if ( getstacklogger ( ) . isloggingenabled ( stacklogger . trace_debug ) ) { getstacklogger ( ) . logdebug ( str_ + this + str_ + dialogid + str_ ) ; }	Retrieve the dialog from the distributed cache.
protected void putdialogintodistributedcache ( sipdialog dialog ) { string dialogid = dialog . getdialogid ( ) ; if ( getstacklogger ( ) . isloggingenabled ( stacklogger . trace_debug ) ) { getstacklogger ( ) . logdebug ( str_ + this + str_ + dialogid + str_ ) ; }	Store the dialog into the distributed cache.
protected void removedialogfromdistributedcache ( string dialogid ) { if ( getstacklogger ( ) . isloggingenabled ( stacklogger . trace_debug ) ) { getstacklogger ( ) . logdebug ( str_ + this + str_ + dialogid + str_ ) ; }	Remove the dialog from the distributed cache.
public void initafterload ( clusteredsipstack sipstackimpl ) { string transport = getlastresponsetopmostvia ( ) . gettransport ( ) ; iterator < sipproviderimpl > providers = sipstackimpl . getsipproviders ( ) ; boolean providernotfound = bool_ ; while ( providers . hasnext ( ) ) { sipproviderimpl providerimpl = providers . next ( ) ; if ( providerimpl . getlisteningpoint ( transport ) != null ) { setsipprovider ( providerimpl ) ; providernotfound = bool_ ; } } if ( providernotfound ) { throw new runtimeexception ( str_ + transport + str_ ) ; } setstack ( ( siptransactionstack ) sipstackimpl ) ; setassigned ( ) ; firsttransactionport = getsipprovider ( ) . getlisteningpoint ( getlastresponsetopmostvia ( ) . gettransport ( ) ) . getport ( ) ; ackprocessed = bool_ ;	Updates the local dialog transient attributes that were not serialized during the replication.
@ override public boolean addtransaction ( siptransaction transaction ) { if ( transaction instanceof servertransaction ) { islatesttxserver = bool_ ; } else { islatesttxserver = bool_ ; } return super . addtransaction ( transaction ) ; }	From and To Uris switch places in certain conditions.
public void printentry ( final entry entry ) throws ioexception { if ( entry != null ) { final bytestringbuffer buffer = new bytestringbuffer ( ) ; entry . toldif ( buffer , num_ ) ; if ( ! first ) { ldifoutputstream . write ( eol ) ; } else { first = bool_ ; } ldifoutputstream . write ( buffer . tobytearray ( ) ) ; } }	Write the LDAP entry to the underlying output stream in LDIF format.
public final void load ( final ldapinterface connection , final inputstream inputstream , final boolean ignoreerrors , final formatlogger logger ) { final formatreader reader = openreader ( inputstream , logger ) ; if ( reader != null ) { try { boolean keepreading = bool_ ; do { try { final ldifchangerecord record = reader . nextrecord ( ) ; if ( record == null ) { keepreading = bool_ ; } else { record . processchange ( connection ) ; } } catch ( final ldifexception e ) { if ( ! ignoreerrors || ! e . maycontinuereading ( ) ) { logger . logerror ( str_ , e ) ; keepreading = bool_ ; } } catch ( final ldapexception e ) { if ( ! ignoreerrors ) { logger . logerror ( str_ , e ) ; keepreading = bool_ ; } } } while ( keepreading ) ; } catch ( final ioexception e ) { logger . logerror ( str_ , e ) ; } finally { try { reader . close ( ) ; } catch ( final ioexception e ) { logger . logerror ( str_ , e ) ; } } } }	Reads directory entries from the input stream and loads them in the LDAP directory server.
public final void dump ( final ldapinterface connection , final string base , final string filter , final outputstream outputstream , final formatlogger logger ) { final formatwriter ldapwriter = createwriter ( outputstream , logger ) ; if ( ldapwriter == null ) { logger . logerror ( str_ ) ; } else { try { try { final searchrequest request = new searchrequest ( base , searchscope . sub , filter . create ( filter ) ) ; final searchresult result = connection . search ( request ) ; if ( result . getresultcode ( ) == resultcode . success ) { final list < searchresultentry > entries = result . getsearchentries ( ) ; if ( entries != null ) { for ( final searchresultentry entry : entries ) { ldapwriter . printentry ( entry ) ; } } else { logger . loginfo ( str_ ) ; } } else { logger . logerror ( str_ ) ; } } catch ( final ldapexception e ) { logger . logerror ( str_ , e ) ; } finally { ldapwriter . close ( ) ; } } catch ( final ioexception e ) { logger . logerror ( str_ , e ) ; } } }	Dump the results of a search against the LDAP directory server to an output stream.
public final void execute ( ) throws mojoexecutionexception { final file outputfile = new file ( outputdirectory , filename ) ; if ( outputdirectory . exists ( ) || outputdirectory . mkdirs ( ) ) { try { final outputstream outputstream = new fileoutputstream ( outputfile ) ; try { final ldapconnection connection = connect ( ) ; try { final formathandler handler = getformathandler ( ) ; if ( handler != null ) { handler . dump ( connection , searchbase , searchfilter , outputstream , this ) ; } } finally { connection . close ( ) ; } } finally { try { outputstream . close ( ) ; } catch ( final ioexception e ) { } } } catch ( final filenotfoundexception e ) { } } }	Execute the plugin goal by dumping the matching directory entries to a file in the specified format.
@ override public void configurecomponent ( final object component , final plexusconfiguration configuration , final expressionevaluator expressionevaluator , final classrealm containerrealm , final configurationlistener listener ) throws componentconfigurationexception { final string servertype = getservertype ( configuration ) ; if ( ! servertype . startswith ( str_ ) ) { addserverdependenciestoclassrealm ( servertype , expressionevaluator , containerrealm ) ; } converterlookup . registerconverter ( new classrealmconverter ( containerrealm ) ) ; final objectwithfieldsconverter converter = new objectwithfieldsconverter ( ) ; converter . processconfiguration ( converterlookup , component , containerrealm , configuration , expressionevaluator , listener ) ; }	Configure the Mojo by adding the dependencies for the LDAP server type to the class loader.
private void addserverdependenciestoclassrealm ( final string servertype , final expressionevaluator expressionevaluator , final classrealm containerrealm ) throws componentconfigurationexception { final collection < artifact > classpathelements = getserverdependencies ( servertype , expressionevaluator ) ; if ( classpathelements != null ) { for ( final url url : buildurls ( classpathelements ) ) { containerrealm . addurl ( url ) ; } } }	Resolve the dependencies for an LDAP server type and add them to the class loader.
private list < url > buildurls ( final collection < artifact > classpathelements ) throws componentconfigurationexception { final list < url > urls = new arraylist < url > ( classpathelements . size ( ) ) ; for ( final artifact classpathelement : classpathelements ) { try { final url url = classpathelement . getfile ( ) . touri ( ) . tourl ( ) ; urls . add ( url ) ; } catch ( final malformedurlexception e ) { throw new componentconfigurationexception ( str_ + classpathelement , e ) ; } } return urls ; }	Retrive the URLs used to locate the JAR files for a list of artifacts.
private collection < artifact > getserverdependencies ( final string servertype , final expressionevaluator expressionevaluator ) throws componentconfigurationexception { try { final mavenproject project = ( mavenproject ) expressionevaluator . evaluate ( str_ ) ; final string localrepo = ( string ) expressionevaluator . evaluate ( str_ ) ; final artifactrepository localrepository = repositorysystem . createlocalrepository ( new file ( localrepo ) ) ; final repositoryrequest repositoryrequest = new defaultrepositoryrequest ( ) ; repositoryrequest . setremoterepositories ( project . getremoteartifactrepositories ( ) ) ; repositoryrequest . setlocalrepository ( localrepository ) ; final artifactresolutionrequest request = new artifactresolutionrequest ( repositoryrequest ) ; request . setartifact ( getserverartifact ( servertype ) ) ; request . setresolvetransitively ( bool_ ) ; final artifactresolutionresult result = repositorysystem . resolve ( request ) ; if ( result . issuccess ( ) ) { return result . getartifacts ( ) ; } boolean first = bool_ ; final stringbuilder builder = new stringbuilder ( str_ ) ; for ( final artifact artifact : result . getmissingartifacts ( ) ) { if ( ! first ) { builder . append ( str_ ) ; } else { first = bool_ ; } builder . append ( artifact . getgroupid ( ) ) ; builder . append ( str_ ) ; builder . append ( artifact . getartifactid ( ) ) ; builder . append ( str_ ) ; builder . append ( artifact . getversion ( ) ) ; } builder . append ( str_ ) ; throw new componentconfigurationexception ( builder . tostring ( ) ) ; } catch ( final expressionevaluationexception e ) { throw new componentconfigurationexception ( str_ , e ) ; } catch ( final invalidrepositoryexception e ) { throw new componentconfigurationexception ( str_ , e ) ; } }	Resolve the LDAP server type artifact and its dependencies.
private artifact getserverartifact ( final string servertype ) throws componentconfigurationexception { if ( servertype . startswith ( str_ ) ) { int index = servertype . indexof ( str_ , num_ ) ; if ( index > num_ ) { string [ ] gav = servertype . substring ( index + num_ ) . split ( str_ ) ; if ( gav . length == num_ ) { return repositorysystem . createartifact ( gav [ num_ ] , gav [ num_ ] , gav [ num_ ] , str_ , str_ ) ; } } throw new componentconfigurationexception ( str_ + servertype ) ; } else { return repositorysystem . createartifact ( default_group_id , messageformat . format ( default_artifact_id_format , servertype ) , getclass ( ) . getpackage ( ) . getimplementationversion ( ) , str_ , str_ ) ; } }	Get the artifact descriptor for the JAR file that implements support for the LDAP server type.
private string getservertype ( final plexusconfiguration configuration ) { final pattern pattern = pattern . compile ( str_ ) ; for ( final plexusconfiguration cfg : configuration . getchildren ( ) ) { if ( cfg . getname ( ) . equals ( server_type_attribute ) ) { if ( pattern . matcher ( cfg . getvalue ( ) ) . matches ( ) ) { return default_server_type_value ; } else { return cfg . getvalue ( ) ; } } } return default_server_type_value ; }	Determine the configured LDAP server type.
@ override protected formatwriter createwriter ( final outputstream outputstream , final formatlogger logger ) { try { return new dsmlformatwriter ( outputstream ) ; } catch ( final ioexception e ) { logger . logerror ( str_ , e ) ; } return null ; }	Create the LDAP writer that will dump LDAP entries to a DSML file.
@ override protected formatreader openreader ( final inputstream inputstream , final formatlogger logger ) { try { return new dsmlformatreader ( inputstream ) ; } catch ( final documentexception e ) { logger . logerror ( str_ , e ) ; } catch ( final jaxenexception e ) { logger . logerror ( str_ , e ) ; } catch ( final ioexception e ) { logger . logerror ( str_ , e ) ; } return null ; }	Create the LDAP reader that will load LDAP entries from a DSML file.
@ override public void configure ( final string name , final object value , final logger logger ) { if ( root . equals ( name ) ) { if ( value instanceof string ) { root = ( string ) value ; logger . loginfo ( str_ + root ) ; } } else if ( object_classes . equals ( name ) ) { if ( value instanceof string [ ] ) { objectclasses = ( string [ ] ) value ; logger . loginfo ( str_ + objectclasses ) ; } } else if ( auth_dn . equals ( name ) ) { if ( value instanceof string ) { authdn = ( string ) value ; logger . loginfo ( str_ + authdn ) ; } } else if ( passwd . equals ( name ) ) { if ( value instanceof string ) { passwd = ( string ) value ; logger . loginfo ( str_ + passwd ) ; } } else if ( work_dir . equals ( name ) ) { if ( value instanceof file ) { workingdirectory = ( file ) value ; logger . loginfo ( str_ + workingdirectory ) ; } } else if ( ldif_file . equals ( name ) ) { if ( value instanceof file ) { ldiffile = ( file ) value ; logger . loginfo ( str_ + ldiffile ) ; } } else if ( ldap_port . equals ( name ) ) { if ( value instanceof integer ) { serverport = ( integer ) value ; logger . loginfo ( str_ + serverport ) ; } } }	Used to configure the root DN of the LDAP directory, the working directory used by the directory service tostore the directory data, the LDIF file used to seed the directory or the TCP port number on which the serverwill listening for LDAP traffic.
@ override public void start ( final logger logger ) { try { logger . loginfo ( str_ ) ; final inmemorylistenerconfig listenerconfig = inmemorylistenerconfig . createldapconfig ( str_ , getserverport ( ) ) ; final inmemorydirectoryserverconfig config = new inmemorydirectoryserverconfig ( new dn ( getroot ( ) ) ) ; config . setlistenerconfigs ( listenerconfig ) ; if ( getauthdn ( ) != null ) { config . addadditionalbindcredentials ( getauthdn ( ) , getpasswd ( ) ) ; } server = new inmemorydirectoryserver ( config ) ; string [ ] objectclasses = getobjectclasses ( ) ; if ( objectclasses == null ) { objectclasses = default_root_object_classes ; } server . add ( new entry ( getroot ( ) , new attribute ( str_ , objectclasses ) ) ) ; if ( getldiffile ( ) != null ) { final inputstream in = new fileinputstream ( getldiffile ( ) ) ; try { final ldifreader reader = new ldifreader ( in ) ; server . importfromldif ( bool_ , reader ) ; } finally { in . close ( ) ; } } server . startlistening ( ) ; logger . loginfo ( str_ ) ; } catch ( final ldapexception e ) { e . printstacktrace ( ) ; logger . logerror ( str_ , e ) ; } catch ( final ioexception e ) { e . printstacktrace ( ) ; logger . logerror ( str_ , e ) ; } }	Configure and start the embedded UnboundID server creating the root DN and loading the LDIF seed data.
@ override public void stop ( final logger logger ) { logger . loginfo ( str_ ) ; server . shutdown ( bool_ ) ; logger . loginfo ( str_ ) ; }	Shutdown the the embedded UnboundID server.
public void execute ( ) throws mojoexecutionexception { if ( ! isskip ( ) ) { final ldapconnection connection = connect ( ) ; try { for ( final source source : sources ) { try { getlog ( ) . info ( str_ + source ) ; final formathandler handler = getformathandler ( source ) ; if ( handler == null ) { getlog ( ) . warn ( str_ + source ) ; } else { final inputstream inputstream = source . open ( ) ; if ( inputstream == null ) { if ( ! this . continueonerror ) { throw new mojoexecutionexception ( str_ + source ) ; } else { getlog ( ) . warn ( str_ + source ) ; } } else { try { handler . load ( connection , source . open ( ) , continueonerror , this ) ; } finally { inputstream . close ( ) ; } } } } catch ( final ioexception e ) { if ( ! this . continueonerror ) { throw new mojoexecutionexception ( str_ + source , e ) ; } else { this . getlog ( ) . warn ( str_ + source , e ) ; } } } } finally { connection . close ( ) ; } } }	Execute the plugin goal iterating over the list of source files and loading the LDAP directory entries fromeach file using the appropriate handler.
@ override public void start ( final logger logger ) { try { logger . loginfo ( str_ ) ; service = new defaultdirectoryservice ( ) ; final list < interceptor > list = new arraylist < interceptor > ( ) ; list . add ( new normalizationinterceptor ( ) ) ; list . add ( new authenticationinterceptor ( ) ) ; list . add ( new referralinterceptor ( ) ) ;	Configure and start the embedded ApacheDS server creating the root DN and loading the LDIF seed data.
@ override public void stop ( final logger logger ) { try { logger . loginfo ( str_ ) ; server . stop ( ) ; service . shutdown ( ) ; logger . loginfo ( str_ ) ; } catch ( final exception e ) { logger . logerror ( str_ , e ) ; } }	Shutdown the the embedded ApacheDS server.
private void createroot ( final partition partition ) throws exception { try { service . getadminsession ( ) . lookup ( partition . getsuffixdn ( ) ) ; } catch ( final ldapnamenotfoundexception e ) { final ldapdn dn = new ldapdn ( getroot ( ) ) ; final string dc = getroot ( ) . substring ( num_ , getroot ( ) . indexof ( str_ ) ) ; final serverentry entry = service . newentry ( dn ) ; entry . add ( str_ , str_ , str_ , str_ ) ; entry . add ( str_ , dc ) ; service . getadminsession ( ) . add ( entry ) ; } }	Create the root DN.
@ override public void start ( final logger logger ) { try { logger . loginfo ( str_ ) ; final memorybackend backend ; if ( getldiffile ( ) == null ) { backend = new memorybackend ( ) ; } else { final inputstream inputstream = new fileinputstream ( getldiffile ( ) ) ; final ldifentryreader reader = new ldifentryreader ( inputstream ) ; backend = new memorybackend ( reader ) ; } final serverconnectionfactory < ldapclientcontext , integer > connectionhandler = connections . newserverconnectionfactory ( backend ) ; final ldaplisteneroptions options = new ldaplisteneroptions ( ) . setbacklog ( num_ ) ; listener = new ldaplistener ( str_ , getserverport ( ) , connectionhandler , options ) ; logger . loginfo ( str_ ) ; } catch ( final ioexception e ) { logger . logerror ( str_ , e ) ; } }	Start the OpenDJ in-memory directory server.
@ override public void stop ( final logger logger ) { logger . loginfo ( str_ ) ; if ( listener != null ) { listener . close ( ) ; } logger . loginfo ( str_ ) ; }	Stop the OpenDJ in-memory directory server.
public void printentry ( final entry entry ) throws ioexception { final bytestringbuffer buffer = new bytestringbuffer ( ) ; buffer . append ( str_ ) ; buffer . append ( entry . getdn ( ) ) ; buffer . append ( str_ ) ; buffer . append ( eol ) ; final string [ ] values = entry . getattributevalues ( str_ ) ; if ( values != null ) { buffer . append ( str_ ) ; buffer . append ( eol ) ; for ( final string value : values ) { buffer . append ( str_ ) ; buffer . append ( value ) ; buffer . append ( str_ ) ; buffer . append ( eol ) ; } buffer . append ( str_ ) ; buffer . append ( eol ) ; } for ( final attribute attribute : entry . getattributes ( ) ) { final string name = attribute . getname ( ) ; if ( ! name . equals ( str_ ) ) { buffer . append ( str_ ) ; buffer . append ( name ) ; buffer . append ( str_ ) ; buffer . append ( eol ) ; for ( final string value : attribute . getvalues ( ) ) { buffer . append ( str_ ) ; buffer . append ( value ) ; buffer . append ( str_ ) ; buffer . append ( eol ) ; } buffer . append ( str_ ) ; buffer . append ( eol ) ; } } buffer . append ( str_ ) ; buffer . append ( eol ) ; ldifoutputstream . write ( buffer . tobytearray ( ) ) ; }	Writes an individual LDAP directory entry to the DSML file.
@ override public string getservertype ( ) { if ( servertype . startswith ( str_ ) ) { return servertype . substring ( num_ ) ; } if ( servertype . startswith ( str_ ) ) { int index = servertype . indexof ( str_ , num_ ) ; if ( index > num_ ) { return servertype . substring ( num_ , index ) ; } } return servertype ; }	Get the server type.
@ override public map < string , object > getserverconfig ( ) { final map < string , object > config = new hashmap < string , object > ( ) ; config . put ( ldapserver . root , rootdn ) ; if ( objectclasses != null ) { config . put ( ldapserver . object_classes , objectclasses . split ( str_ ) ) ; } config . put ( ldapserver . work_dir , new file ( outputdirectory , servertype ) ) ; if ( ldiffile != null ) { config . put ( ldapserver . ldif_file , ldiffile ) ; } config . put ( ldapserver . ldap_port , ldapport ) ; config . put ( ldapserver . auth_dn , authdn ) ; config . put ( ldapserver . passwd , passwd ) ; return config ; }	Get the embedded LDAP directory server configuration.
protected void sendmetric ( metricbuilder metricbuilder ) throws reportingexception { try { httpclient client = new httpclient ( str_ + this . server + str_ + this . port ) ; response response = client . pushmetrics ( metricbuilder ) ;	Sends a metric to the kairos server.
@ override public void report ( metric metric ) throws reportingexception { kairosmetricconverter kairosmetricconverter = new kairosmetricconverter ( ) ; try { kairosmetricconverter . add ( metric ) ; } catch ( kairosmetricconversionexception e ) { throw new reportingexception ( e ) ; } this . sendmetric ( kairosmetricconverter . convert ( ) ) ; }	Report method. Converts the given metric to a metric kairos understands and sends them.
public static geometrytypeinfo readgeometrytype ( bytereader reader ) {	Read the geometry type info.
public static point readpoint ( bytereader reader , boolean hasz , boolean hasm ) { double x = reader . readdouble ( ) ; double y = reader . readdouble ( ) ; point point = new point ( hasz , hasm , x , y ) ; if ( hasz ) { double z = reader . readdouble ( ) ; point . setz ( z ) ; } if ( hasm ) { double m = reader . readdouble ( ) ; point . setm ( m ) ; } return point ; }	Read a Point.
public static linestring readlinestring ( bytereader reader , boolean hasz , boolean hasm ) { linestring linestring = new linestring ( hasz , hasm ) ; int numpoints = reader . readint ( ) ; for ( int i = num_ ; i < numpoints ; i ++ ) { point point = readpoint ( reader , hasz , hasm ) ; linestring . addpoint ( point ) ; } return linestring ; }	Read a Line String.
public static polygon readpolygon ( bytereader reader , boolean hasz , boolean hasm ) { polygon polygon = new polygon ( hasz , hasm ) ; int numrings = reader . readint ( ) ; for ( int i = num_ ; i < numrings ; i ++ ) { linestring ring = readlinestring ( reader , hasz , hasm ) ; polygon . addring ( ring ) ; } return polygon ; }	Read a Polygon.
public static multipoint readmultipoint ( bytereader reader , boolean hasz , boolean hasm ) { multipoint multipoint = new multipoint ( hasz , hasm ) ; int numpoints = reader . readint ( ) ; for ( int i = num_ ; i < numpoints ; i ++ ) { point point = readgeometry ( reader , point . class ) ; multipoint . addpoint ( point ) ; } return multipoint ; }	Read a Multi Point.
public static multilinestring readmultilinestring ( bytereader reader , boolean hasz , boolean hasm ) { multilinestring multilinestring = new multilinestring ( hasz , hasm ) ; int numlinestrings = reader . readint ( ) ; for ( int i = num_ ; i < numlinestrings ; i ++ ) { linestring linestring = readgeometry ( reader , linestring . class ) ; multilinestring . addlinestring ( linestring ) ; } return multilinestring ; }	Read a Multi Line String.
public static multipolygon readmultipolygon ( bytereader reader , boolean hasz , boolean hasm ) { multipolygon multipolygon = new multipolygon ( hasz , hasm ) ; int numpolygons = reader . readint ( ) ; for ( int i = num_ ; i < numpolygons ; i ++ ) { polygon polygon = readgeometry ( reader , polygon . class ) ; multipolygon . addpolygon ( polygon ) ; } return multipolygon ; }	Read a Multi Polygon.
public static geometrycollection < geometry > readgeometrycollection ( bytereader reader , boolean hasz , boolean hasm ) { geometrycollection < geometry > geometrycollection = new geometrycollection < geometry > ( hasz , hasm ) ; int numgeometries = reader . readint ( ) ; for ( int i = num_ ; i < numgeometries ; i ++ ) { geometry geometry = readgeometry ( reader , geometry . class ) ; geometrycollection . addgeometry ( geometry ) ; } return geometrycollection ; }	Read a Geometry Collection.
public static circularstring readcircularstring ( bytereader reader , boolean hasz , boolean hasm ) { circularstring circularstring = new circularstring ( hasz , hasm ) ; int numpoints = reader . readint ( ) ; for ( int i = num_ ; i < numpoints ; i ++ ) { point point = readpoint ( reader , hasz , hasm ) ; circularstring . addpoint ( point ) ; } return circularstring ; }	Read a Circular String.
public static compoundcurve readcompoundcurve ( bytereader reader , boolean hasz , boolean hasm ) { compoundcurve compoundcurve = new compoundcurve ( hasz , hasm ) ; int numlinestrings = reader . readint ( ) ; for ( int i = num_ ; i < numlinestrings ; i ++ ) { linestring linestring = readgeometry ( reader , linestring . class ) ; compoundcurve . addlinestring ( linestring ) ; } return compoundcurve ; }	Read a Compound Curve.
public static curvepolygon < curve > readcurvepolygon ( bytereader reader , boolean hasz , boolean hasm ) { curvepolygon < curve > curvepolygon = new curvepolygon < curve > ( hasz , hasm ) ; int numrings = reader . readint ( ) ; for ( int i = num_ ; i < numrings ; i ++ ) { curve ring = readgeometry ( reader , curve . class ) ; curvepolygon . addring ( ring ) ; } return curvepolygon ; }	Read a Curve Polygon.
public static polyhedralsurface readpolyhedralsurface ( bytereader reader , boolean hasz , boolean hasm ) { polyhedralsurface polyhedralsurface = new polyhedralsurface ( hasz , hasm ) ; int numpolygons = reader . readint ( ) ; for ( int i = num_ ; i < numpolygons ; i ++ ) { polygon polygon = readgeometry ( reader , polygon . class ) ; polyhedralsurface . addpolygon ( polygon ) ; } return polyhedralsurface ; }	Read a Polyhedral Surface.
public static tin readtin ( bytereader reader , boolean hasz , boolean hasm ) { tin tin = new tin ( hasz , hasm ) ; int numpolygons = reader . readint ( ) ; for ( int i = num_ ; i < numpolygons ; i ++ ) { polygon polygon = readgeometry ( reader , polygon . class ) ; tin . addpolygon ( polygon ) ; } return tin ; }	Read a TIN.
public static triangle readtriangle ( bytereader reader , boolean hasz , boolean hasm ) { triangle triangle = new triangle ( hasz , hasm ) ; int numrings = reader . readint ( ) ; for ( int i = num_ ; i < numrings ; i ++ ) { linestring ring = readlinestring ( reader , hasz , hasm ) ; triangle . addring ( ring ) ; } return triangle ; }	Read a Triangle.
public static void writegeometry ( bytewriter writer , geometry geometry ) throws ioexception {	Write a geometry to the byte writer.
public static void writepoint ( bytewriter writer , point point ) throws ioexception { writer . writedouble ( point . getx ( ) ) ; writer . writedouble ( point . gety ( ) ) ; if ( point . hasz ( ) ) { writer . writedouble ( point . getz ( ) ) ; } if ( point . hasm ( ) ) { writer . writedouble ( point . getm ( ) ) ; } }	Write a Point.
public static void writelinestring ( bytewriter writer , linestring linestring ) throws ioexception { writer . writeint ( linestring . numpoints ( ) ) ; for ( point point : linestring . getpoints ( ) ) { writepoint ( writer , point ) ; } }	Write a Line String.
public static void writepolygon ( bytewriter writer , polygon polygon ) throws ioexception { writer . writeint ( polygon . numrings ( ) ) ; for ( linestring ring : polygon . getrings ( ) ) { writelinestring ( writer , ring ) ; } }	Write a Polygon.
public static void writemultipoint ( bytewriter writer , multipoint multipoint ) throws ioexception { writer . writeint ( multipoint . numpoints ( ) ) ; for ( point point : multipoint . getpoints ( ) ) { writegeometry ( writer , point ) ; } }	Write a Multi Point.
public static void writemultilinestring ( bytewriter writer , multilinestring multilinestring ) throws ioexception { writer . writeint ( multilinestring . numlinestrings ( ) ) ; for ( linestring linestring : multilinestring . getlinestrings ( ) ) { writegeometry ( writer , linestring ) ; } }	Write a Multi Line String.
public static void writemultipolygon ( bytewriter writer , multipolygon multipolygon ) throws ioexception { writer . writeint ( multipolygon . numpolygons ( ) ) ; for ( polygon polygon : multipolygon . getpolygons ( ) ) { writegeometry ( writer , polygon ) ; } }	Write a Multi Polygon.
public static void writegeometrycollection ( bytewriter writer , geometrycollection < ? > geometrycollection ) throws ioexception { writer . writeint ( geometrycollection . numgeometries ( ) ) ; for ( geometry geometry : geometrycollection . getgeometries ( ) ) { writegeometry ( writer , geometry ) ; } }	Write a Geometry Collection.
public static void writecircularstring ( bytewriter writer , circularstring circularstring ) throws ioexception { writer . writeint ( circularstring . numpoints ( ) ) ; for ( point point : circularstring . getpoints ( ) ) { writepoint ( writer , point ) ; } }	Write a Circular String.
public static void writecompoundcurve ( bytewriter writer , compoundcurve compoundcurve ) throws ioexception { writer . writeint ( compoundcurve . numlinestrings ( ) ) ; for ( linestring linestring : compoundcurve . getlinestrings ( ) ) { writegeometry ( writer , linestring ) ; } }	Write a Compound Curve.
public static void writecurvepolygon ( bytewriter writer , curvepolygon < ? > curvepolygon ) throws ioexception { writer . writeint ( curvepolygon . numrings ( ) ) ; for ( curve ring : curvepolygon . getrings ( ) ) { writegeometry ( writer , ring ) ; } }	Write a Curve Polygon.
public static void writepolyhedralsurface ( bytewriter writer , polyhedralsurface polyhedralsurface ) throws ioexception { writer . writeint ( polyhedralsurface . numpolygons ( ) ) ; for ( polygon polygon : polyhedralsurface . getpolygons ( ) ) { writegeometry ( writer , polygon ) ; } }	Write a Polyhedral Surface.
public static void writetin ( bytewriter writer , tin tin ) throws ioexception { writer . writeint ( tin . numpolygons ( ) ) ; for ( polygon polygon : tin . getpolygons ( ) ) { writegeometry ( writer , polygon ) ; } }	Write a TIN.
public static void writetriangle ( bytewriter writer , triangle triangle ) throws ioexception { writer . writeint ( triangle . numrings ( ) ) ; for ( linestring ring : triangle . getrings ( ) ) { writelinestring ( writer , ring ) ; } }	Write a Triangle.
public static int getcode ( geometry geometry ) { int code = getcode ( geometry . getgeometrytype ( ) ) ; if ( geometry . hasz ( ) ) { code += num_ ; } if ( geometry . hasm ( ) ) { code += num_ ; } return code ; }	Get the geometry code from the geometry.
public static int getcode ( geometrytype geometrytype ) { int code ; switch ( geometrytype ) { case geometry : code = num_ ; break ; case point : code = num_ ; break ; case linestring : code = num_ ; break ; case polygon : code = num_ ; break ; case multipoint : code = num_ ; break ; case multilinestring : code = num_ ; break ; case multipolygon : code = num_ ; break ; case geometrycollection : code = num_ ; break ; case circularstring : code = num_ ; break ; case compoundcurve : code = num_ ; break ; case curvepolygon : code = num_ ; break ; case multicurve : code = num_ ; break ; case multisurface : code = num_ ; break ; case curve : code = num_ ; break ; case surface : code = num_ ; break ; case polyhedralsurface : code = num_ ; break ; case tin : code = num_ ; break ; case triangle : code = num_ ; break ; default : throw new sfexception ( str_ + geometrytype ) ; } return code ; }	Get the geometry code from the geometry type.
public static geometrytype getgeometrytype ( int code ) {	Get the Geometry Type from the code.
@ override public boolean exists ( ) {	This implementation checks whether a File can be opened,falling back to whether an InputStream can be opened.This will cover both directories and content resources.
public static long gcd ( list < long > l ) { if ( l . isempty ( ) ) { throw new illegalargumentexception ( str_ ) ; } biginteger gcd = biginteger . valueof ( l . get ( num_ ) ) ; for ( long num : l . sublist ( num_ , l . size ( ) ) ) { gcd = gcd . gcd ( biginteger . valueof ( num ) ) ; } return gcd . longvalue ( ) ; }	Finds the greatest common divisor of all numbers in the list.
@ nonnull public static string abbreviate ( string str , int max ) { if ( str == null ) { return str_ ; } else if ( str . length ( ) <= max ) { return str ; } else { return str . substring ( num_ , max - num_ ) + str_ ; } }	Abbreviates a String using ellipses.
public static org . jmxtrans . agent . util . json . jsonvalue value ( string string ) { return string == null ? null : new jsonstring ( string ) ; }	Returns a JsonValue instance that represents the given string.
public static org . jmxtrans . agent . util . json . jsonobject object ( ) { return new org . jmxtrans . agent . util . json . jsonobject ( ) ; }	Creates a new empty JsonObject.
public static org . jmxtrans . agent . util . json . jsonvalue parse ( string string ) { if ( string == null ) { throw new nullpointerexception ( str_ ) ; } defaulthandler handler = new defaulthandler ( ) ; new jsonparser ( handler ) . parse ( string ) ; return handler . getvalue ( ) ; }	Parses the given input string as JSON.
public static string getstring ( map < string , string > settings , string name , string defaultvalue ) { if ( settings . containskey ( name ) ) { return settings . get ( name ) ; } else { return defaultvalue ; } }	Return the value of the given property.If the property is not found, the defaultValue is returned.
@ deprecated public static jsonobject readfrom ( string string ) { return org . jmxtrans . agent . util . json . jsonvalue . readfrom ( string ) . asobject ( ) ; }	Reads a JSON object from the given string.
public org . jmxtrans . agent . util . json . jsonvalue get ( string name ) { if ( name == null ) { throw new nullpointerexception ( str_ ) ; } int index = indexof ( name ) ; return index != - num_ ? values . get ( index ) : null ; }	Returns the value of the member with the specified name in this object.
public iterator < member > iterator ( ) { final iterator < string > namesiterator = names . iterator ( ) ; final iterator < org . jmxtrans . agent . util . json . jsonvalue > valuesiterator = values . iterator ( ) ; return new iterator < jsonobject . member > ( ) { public boolean hasnext ( ) { return namesiterator . hasnext ( ) ; } public member next ( ) { string name = namesiterator . next ( ) ; org . jmxtrans . agent . util . json . jsonvalue value = valuesiterator . next ( ) ; return new member ( name , value ) ; } public void remove ( ) { throw new unsupportedoperationexception ( ) ; } } ; }	Returns an iterator over the members of this object in document order.
protected string resolveplaceholder ( string property , string defaultvalue ) throws illegalstateexception {	Search for the given placeholder in system properties then in environment variables.
@ nonnull public static string getversioninfo ( ) { package pkg = jmxtransagent . class . getpackage ( ) ; if ( pkg == null ) { return str_ ; } else { return pkg . getimplementationtitle ( ) + str_ + pkg . getimplementationversion ( ) ; } }	Human readable name and version.
@ deprecated public static jsonarray readfrom ( string string ) { return org . jmxtrans . agent . util . json . jsonvalue . readfrom ( string ) . asarray ( ) ; }	Reads a JSON array from the given string.
public jsonarray add ( org . jmxtrans . agent . util . json . jsonvalue value ) { if ( value == null ) { throw new nullpointerexception ( str_ ) ; } values . add ( value ) ; return this ; }	Appends the specified JSON value to the end of this array.
public jsonarray set ( int index , org . jmxtrans . agent . util . json . jsonvalue value ) { if ( value == null ) { throw new nullpointerexception ( str_ ) ; } values . set ( index , value ) ; return this ; }	Replaces the element at the specified position in this array with the specified JSON value.
public org . jmxtrans . agent . util . json . jsonvalue get ( int index ) { return values . get ( index ) ; }	Returns the value of the element at the specified position in this array.
public list < org . jmxtrans . agent . util . json . jsonvalue > values ( ) { return collections . unmodifiablelist ( values ) ; }	Returns a list of the values in this array in document order.
public iterator < org . jmxtrans . agent . util . json . jsonvalue > iterator ( ) { final iterator < org . jmxtrans . agent . util . json . jsonvalue > iterator = values . iterator ( ) ; return new iterator < org . jmxtrans . agent . util . json . jsonvalue > ( ) { public boolean hasnext ( ) { return iterator . hasnext ( ) ; } public org . jmxtrans . agent . util . json . jsonvalue next ( ) { return iterator . next ( ) ; } public void remove ( ) { throw new unsupportedoperationexception ( ) ; } } ; }	Returns an iterator over the values of this array in document order.
private void processevent ( final object event ) { system . out . println ( str_ + event . tostring ( ) ) ; for ( final eventhandler handler : getconsumersfor ( event . getclass ( ) ) ) { event_executor . execute ( new runnable ( ) { @ override public void run ( ) { try { handler . handle ( event ) ; } catch ( exception e ) { e . printstacktrace ( ) ; if ( shouldreraiseonerror ) { system . out . println ( str_ + event . tostring ( ) ) ; eventqueue . publish ( event ) ; } } } } ) ; } }	Runs each appropriate EventHandler in an Executor.
private void publishevent ( object event ) { assert ( haseventbusses ( ) ) ; for ( eventbus eventbus : eventbusses . values ( ) ) { eventbus . publish ( event ) ; } }	Raise an event on all event busses, passing it to applicable consumers asynchronously.
private void publishevent ( string name , object event ) { assert ( haseventbusses ( ) ) ; eventbus eventbus = geteventbus ( name ) ; if ( eventbus == null ) { throw new runtimeexception ( str_ + name ) ; } eventbus . publish ( event ) ; }	Raise an event on a named event bus, passing it to applicable consumers asynchronously.
public void removechild ( final string child ) { final stringbuilder htmlmiddlesb = gethtmlmiddlesb ( ) ; final string sb = htmlmiddlesb . tostring ( ) ; final string replaced = sb . replace ( child , str_ ) ; final int lastindex = htmlmiddlesb . length ( ) - num_ ; htmlmiddlesb . delete ( num_ , lastindex ) ; htmlmiddlesb . append ( replaced ) ; }	removes the the child content.
private void addinwffidmap ( final abstracthtml tag ) { final deque < set < abstracthtml > > childrenstack = new arraydeque < > ( ) ;	adds to wffid map.
protected boolean addtoattributevaluemap ( final string key , final string value ) { final collection < abstracthtml5sharedobject > sharedobjects = getsharedobjects ( ) ; boolean listenerinvoked = bool_ ; final collection < writelock > writelocks = lockandgetwritelocks ( ) ; try { final map < string , string > attributevaluemap = getattributevaluemap ( ) ; final string previousvalue = attributevaluemap . put ( key , value ) ; if ( ! objects . equals ( previousvalue , value ) ) { setmodified ( bool_ ) ; invokevaluechangelisteners ( sharedobjects ) ; listenerinvoked = bool_ ; } } finally { for ( final lock lock : writelocks ) { lock . unlock ( ) ; } } pushqueues ( sharedobjects , listenerinvoked ) ; return listenerinvoked ; }	adds the given key value.
private void invokevaluechangelisteners ( final collection < abstracthtml5sharedobject > sharedobjects ) { for ( final abstracthtml5sharedobject sharedobject : sharedobjects ) { final attributevaluechangelistener valuechangelistener = sharedobject . getvaluechangelistener ( access_object ) ; if ( valuechangelistener != null ) {	this method should be called after changing of attribute value not beforechanging value.
protected boolean addalltoattributevaluemap ( final map < string , string > map ) { if ( map != null && map . size ( ) > num_ ) { final collection < abstracthtml5sharedobject > sharedobjects = getsharedobjects ( ) ; boolean listenerinvoked = bool_ ; final collection < writelock > writelocks = lockandgetwritelocks ( ) ; try { getattributevaluemap ( ) . putall ( map ) ; setmodified ( bool_ ) ; invokevaluechangelisteners ( sharedobjects ) ; listenerinvoked = bool_ ; } finally { for ( final lock lock : writelocks ) { lock . unlock ( ) ; } } pushqueues ( sharedobjects , listenerinvoked ) ; return listenerinvoked ; } return bool_ ; }	adds all to the attribute value map.
protected boolean removefromattributevaluemapbykeys ( final string ... keys ) { final collection < abstracthtml5sharedobject > sharedobjects = getsharedobjects ( ) ; boolean listenerinvoked = bool_ ; final collection < writelock > writelocks = lockandgetwritelocks ( ) ; boolean result = bool_ ; try { final map < string , string > valuemap = getattributevaluemap ( ) ; if ( nullableattrvaluemapvalue ) { for ( final string key : keys ) { result = valuemap . containskey ( key ) ; if ( result ) { break ; } } } for ( final string key : keys ) { final string previous = valuemap . remove ( key ) ; if ( previous != null ) { result = bool_ ; } } if ( result ) { setmodified ( bool_ ) ; invokevaluechangelisteners ( sharedobjects ) ; listenerinvoked = bool_ ; } } finally { for ( final lock lock : writelocks ) { lock . unlock ( ) ; } } pushqueues ( sharedobjects , listenerinvoked ) ; return result ; }	removes the key value for the input key.
private void pushqueues ( final collection < abstracthtml5sharedobject > sharedobjects , final boolean listenerinvoked ) { if ( listenerinvoked ) { for ( final abstracthtml5sharedobject sharedobject : sharedobjects ) { final pushqueue pushqueue = sharedobject . getpushqueue ( access_object ) ; if ( pushqueue != null ) { pushqueue . push ( ) ; } } } }	pushes PushQueue from all shared object of parent tags.
protected boolean removefromattributevaluemap ( final string key , final string value ) { final collection < abstracthtml5sharedobject > sharedobjects = getsharedobjects ( ) ; final collection < writelock > writelocks = lockandgetwritelocks ( ) ; boolean listenerinvoked = bool_ ; try { final boolean removed = getattributevaluemap ( ) . remove ( key , value ) ; if ( removed ) { setmodified ( bool_ ) ; invokevaluechangelisteners ( sharedobjects ) ; listenerinvoked = bool_ ; } } finally { for ( final lock lock : writelocks ) { lock . unlock ( ) ; } } pushqueues ( sharedobjects , listenerinvoked ) ; return listenerinvoked ; }	removes only if the key and value matches in the map for any particularentry.
protected boolean addtoattributevalueset ( final string value ) { final collection < abstracthtml5sharedobject > sharedobjects = getsharedobjects ( ) ; boolean listenerinvoked = bool_ ; final collection < writelock > writelocks = lockandgetwritelocks ( ) ; try { final boolean added = getattributevalueset ( ) . add ( value ) ; if ( added ) { setmodified ( bool_ ) ; invokevaluechangelisteners ( sharedobjects ) ; listenerinvoked = bool_ ; } } finally { for ( final lock lock : writelocks ) { lock . unlock ( ) ; } } pushqueues ( sharedobjects , listenerinvoked ) ; return listenerinvoked ; }	adds to the attribute value set.
protected void addalltoattributevalueset ( final collection < string > values ) { if ( values != null ) { final collection < abstracthtml5sharedobject > sharedobjects = getsharedobjects ( ) ; boolean listenerinvoked = bool_ ; final collection < writelock > writelocks = lockandgetwritelocks ( ) ; try { final boolean added = getattributevalueset ( ) . addall ( values ) ; if ( added ) { setmodified ( bool_ ) ; invokevaluechangelisteners ( sharedobjects ) ; listenerinvoked = bool_ ; } } finally { for ( final lock lock : writelocks ) { lock . unlock ( ) ; } } pushqueues ( sharedobjects , listenerinvoked ) ; } }	adds all to the attribute value set.
protected void removeallfromattributevalueset ( final collection < string > values ) { final collection < abstracthtml5sharedobject > sharedobjects = getsharedobjects ( ) ; boolean listenerinvoked = bool_ ; final collection < writelock > writelocks = lockandgetwritelocks ( ) ; try { final boolean removedall = getattributevalueset ( ) . removeall ( values ) ; if ( removedall ) { setmodified ( bool_ ) ; invokevaluechangelisteners ( sharedobjects ) ; listenerinvoked = bool_ ; } } finally { for ( final lock lock : writelocks ) { lock . unlock ( ) ; } } pushqueues ( sharedobjects , listenerinvoked ) ; }	removes the value from the the attribute set.
protected void removeallfromattributevalueset ( ) { final collection < abstracthtml5sharedobject > sharedobjects = getsharedobjects ( ) ; boolean listenerinvoked = bool_ ; final collection < writelock > writelocks = lockandgetwritelocks ( ) ; try { getattributevalueset ( ) . clear ( ) ; setmodified ( bool_ ) ; invokevaluechangelisteners ( sharedobjects ) ; listenerinvoked = bool_ ; } finally { for ( final lock lock : writelocks ) { lock . unlock ( ) ; } } pushqueues ( sharedobjects , listenerinvoked ) ; }	clears all values from the value set.
public void addvaluechangelistener ( final attributevaluechangelistener valuechangelistener ) { if ( valuechangelisteners == null ) { synchronized ( this ) { if ( valuechangelisteners == null ) { valuechangelisteners = new linkedhashset < > ( ) ; } } } valuechangelisteners . add ( valuechangelistener ) ; }	adds value change lister which will be invoked when the value changed.
public boolean containsvalidregex ( ) { try { java . util . regex . pattern . compile ( super . getattributevalue ( ) ) ; return bool_ ; } catch ( final patternsyntaxexception e ) {	checks the value in this attribute contains a valid regex.
public void setr ( final int r ) { if ( r < num_ || r > num_ ) { throw new invalidvalueexception ( str_ ) ; } this . r = r ; rgba = str_ + r + str_ + g + str_ + b + str_ + a + str_ ; if ( getstatechangeinformer ( ) != null ) { getstatechangeinformer ( ) . statechanged ( this ) ; } }	to set the red value which is in between 0 to 255.
public void setg ( final int g ) { if ( g < num_ || g > num_ ) { throw new invalidvalueexception ( str_ ) ; } this . g = g ; rgba = str_ + r + str_ + g + str_ + b + str_ + a + str_ ; if ( getstatechangeinformer ( ) != null ) { getstatechangeinformer ( ) . statechanged ( this ) ; } }	to set the green value which is in between 0 to 255.
public void setb ( final int b ) { if ( b < num_ || b > num_ ) { throw new invalidvalueexception ( str_ ) ; } this . b = b ; rgba = str_ + r + str_ + g + str_ + b + str_ + a + str_ ; if ( getstatechangeinformer ( ) != null ) { getstatechangeinformer ( ) . statechanged ( this ) ; } }	to set the blue value which is in between 0 to 255.
public void seta ( final float a ) { if ( a < num_ || a > num_ ) { throw new invalidvalueexception ( str_ ) ; } this . a = a ; rgba = str_ + r + str_ + g + str_ + b + str_ + a + str_ ; if ( getstatechangeinformer ( ) != null ) { getstatechangeinformer ( ) . statechanged ( this ) ; } }	to set alpha. The default value is 0.
public static void loadalltagclasses ( ) { final map < string , class < ? > > unloadedclasses = new hashmap < > ( ) ; for ( final entry < string , class < ? > > entry : tagclassbytagnametmp . entryset ( ) ) { try { class . forname ( entry . getvalue ( ) . getname ( ) ) ; } catch ( final classnotfoundexception e ) { unloadedclasses . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; if ( logger . isloggable ( level . warning ) ) { logger . warning ( str_ + entry . getvalue ( ) . getname ( ) ) ; } } } tagclassbytagnametmp . clear ( ) ; if ( unloadedclasses . size ( ) > num_ ) { tagclassbytagnametmp . putall ( unloadedclasses ) ; } else { tagclassbytagnametmp = null ; } }	Loads all tag classes.
public static string getfirstsubstring ( final string inputstring , final string startingwith , final string endingwith ) { if ( ! inputstring . contains ( startingwith ) || ! inputstring . contains ( endingwith ) ) { return null ; } final int startindex = inputstring . indexof ( startingwith ) ; if ( ! ( ( startindex + num_ ) < inputstring . length ( ) ) ) { return null ; } final int endindex = inputstring . indexof ( endingwith , startindex + num_ ) + num_ ; if ( startindex > endindex || startindex < num_ || endindex < num_ ) { return null ; } return inputstring . substring ( startindex , endindex ) ; }	gets the first substring which starts and ends with the given values.
public static string [ ] clonearray ( final string [ ] inputarray ) { final string [ ] array = new string [ inputarray . length ] ; system . arraycopy ( inputarray , num_ , array , num_ , inputarray . length ) ; return array ; }	To make the clone copy of the given String array.
public static boolean containswhitespace ( final string string ) { for ( int i = num_ ; i < string . length ( ) ; i ++ ) { if ( character . iswhitespace ( string . charat ( i ) ) ) { return bool_ ; } } return bool_ ; }	Checks if the given string contains whitespace.
public static string strip ( final string s ) { int first ; int last ; for ( first = num_ ; first < s . length ( ) ; first ++ ) { if ( ! character . iswhitespace ( s . charat ( first ) ) ) { break ; } } for ( last = s . length ( ) ; last > first ; last -- ) { if ( ! character . iswhitespace ( s . charat ( last - num_ ) ) ) { break ; } } return s . substring ( first , last ) ; }	Removes the trailing and leading whitespaces.
public void removeallchildren ( ) { boolean listenerinvoked = bool_ ; final lock lock = sharedobject . getlock ( access_object ) . writelock ( ) ; try { lock . lock ( ) ; final abstracthtml [ ] removedabstracthtmls = children . toarray ( new abstracthtml [ children . size ( ) ] ) ; children . clear ( ) ; initnewsharedobjectinallnestedtagsandsetsuperparentnull ( removedabstracthtmls ) ; final childtagremovelistener listener = sharedobject . getchildtagremovelistener ( access_object ) ; if ( listener != null ) { listener . allchildrenremoved ( new childtagremovelistener . event ( this , removedabstracthtmls ) ) ; listenerinvoked = bool_ ; } } finally { lock . unlock ( ) ; } if ( listenerinvoked ) { final pushqueue pushqueue = sharedobject . getpushqueue ( access_object ) ; if ( pushqueue != null ) { pushqueue . push ( ) ; } } }	Removes all children from this tag.
protected void addinnerhtmls ( final boolean updateclient , final abstracthtml ... innerhtmls ) { boolean listenerinvoked = bool_ ; final lock lock = sharedobject . getlock ( access_object ) . writelock ( ) ; try { lock . lock ( ) ; final abstracthtml [ ] removedabstracthtmls = children . toarray ( new abstracthtml [ children . size ( ) ] ) ; children . clear ( ) ; initnewsharedobjectinallnestedtagsandsetsuperparentnull ( removedabstracthtmls ) ; final innerhtmladdlistener listener = sharedobject . getinnerhtmladdlistener ( access_object ) ; if ( listener != null && updateclient ) { final innerhtmladdlistener . event [ ] events = new innerhtmladdlistener . event [ innerhtmls . length ] ; int index = num_ ; for ( final abstracthtml innerhtml : innerhtmls ) { abstracthtml previousparenttag = null ; if ( innerhtml . parent != null && innerhtml . parent . sharedobject == sharedobject ) { previousparenttag = innerhtml . parent ; } addchild ( innerhtml , bool_ ) ; events [ index ] = new innerhtmladdlistener . event ( this , innerhtml , previousparenttag ) ; index ++ ; } listener . innerhtmlsadded ( this , events ) ; listenerinvoked = bool_ ; } else { for ( final abstracthtml innerhtml : innerhtmls ) { addchild ( innerhtml , bool_ ) ; } } } finally { lock . unlock ( ) ; } if ( listenerinvoked ) { final pushqueue pushqueue = sharedobject . getpushqueue ( access_object ) ; if ( pushqueue != null ) { pushqueue . push ( ) ; } } }	Removes all children and adds the given tags as children.
public boolean removechildren ( final collection < abstracthtml > children ) { final lock lock = sharedobject . getlock ( access_object ) . writelock ( ) ; boolean result = bool_ ; try { lock . lock ( ) ; result = this . children . removeall ( children ) ; } finally { lock . unlock ( ) ; } final pushqueue pushqueue = sharedobject . getpushqueue ( access_object ) ; if ( pushqueue != null ) { pushqueue . push ( ) ; } return result ; }	Removes the given tags from its children tags.
public boolean removechild ( final abstracthtml child ) { boolean listenerinvoked = bool_ ; final lock lock = sharedobject . getlock ( access_object ) . writelock ( ) ; boolean removed = bool_ ; try { lock . lock ( ) ; removed = children . remove ( child ) ; if ( removed ) {	Removes the given tag from its children only if the given tag is a childof this tag.
public void appendchildren ( final collection < abstracthtml > children ) { boolean listenerinvoked = bool_ ; final lock lock = sharedobject . getlock ( access_object ) . writelock ( ) ; try { lock . lock ( ) ; final collection < childmovedevent > movedorappended = new arraydeque < > ( children . size ( ) ) ; for ( final abstracthtml child : children ) { final abstracthtml previousparent = child . parent ; addchild ( child , bool_ ) ; final childmovedevent event = new childmovedevent ( previousparent , this , child ) ; movedorappended . add ( event ) ; } final childtagappendlistener listener = sharedobject . getchildtagappendlistener ( access_object ) ; if ( listener != null ) { listener . childrendappendedormoved ( movedorappended ) ; listenerinvoked = bool_ ; } } finally { lock . unlock ( ) ; } if ( listenerinvoked ) { final pushqueue pushqueue = sharedobject . getpushqueue ( access_object ) ; if ( pushqueue != null ) { pushqueue . push ( ) ; } } }	adds the given children to the last position of the current children ofthis object.
private void initattributes ( final abstractattribute ... attributes ) { if ( attributes == null || attributes . length == num_ ) { return ; }	initializes attributes in this.attributes and also in attributesMap.
public abstractattribute getattributebyname ( final string attributename ) { final lock lock = sharedobject . getlock ( access_object ) . readlock ( ) ; abstractattribute result = null ; try { lock . lock ( ) ; if ( attributesmap != null ) { result = attributesmap . get ( attributename ) ; } } finally { lock . unlock ( ) ; } return result ; }	gets the attribute by attribute name.
private void markownertag ( final abstractattribute [ ] attributes ) { if ( attributes == null ) { return ; } for ( final abstractattribute abstractattribute : attributes ) { abstractattribute . setownertag ( this ) ; } }	marks the owner tag in the attributes.
private void initinconstructor ( ) { htmlstartsb = new stringbuilder ( tagname == null ? num_ : tagname . length ( ) + num_ + ( ( attributes == null ? num_ : attributes . length ) * num_ ) ) ; htmlendsb = new stringbuilder ( tagname == null ? num_ : tagname . length ( ) + num_ ) ; }	to initialize objects in the constructor.
public abstracthtml [ ] getchildrenasarray ( ) { final lock lock = sharedobject . getlock ( access_object ) . readlock ( ) ; try { lock . lock ( ) ; return children . toarray ( new abstracthtml [ children . size ( ) ] ) ; } finally { lock . unlock ( ) ; } }	Gets the children of this tag as an array.
public abstracthtml getfirstchild ( ) {	Gets the first child of this tag.
public int getchildrensize ( ) { final lock lock = sharedobject . getlock ( access_object ) . readlock ( ) ; try { lock . lock ( ) ; return children . size ( ) ; } finally { lock . unlock ( ) ; } }	Gets the number of children in this tag.
public boolean containschild ( final abstracthtml childtag ) { final lock lock = sharedobject . getlock ( access_object ) . readlock ( ) ; try { lock . lock ( ) ; return children . contains ( childtag ) ; } finally { lock . unlock ( ) ; } }	Checks whether a tag is contained in its direct children.
public final string getopeningtag ( ) { if ( isrebuild ( ) || ismodified ( ) ) { final lock lock = sharedobject . getlock ( access_object ) . writelock ( ) ; try { lock . lock ( ) ; buildopeningtag ( bool_ ) ; } finally { lock . unlock ( ) ; } } return openingtag ; }	For internal purpose. Not recommended for external purpose.
public boolean insertbefore ( final abstracthtml ... abstracthtmls ) { if ( parent == null ) { throw new noparentexception ( str_ ) ; } final lock lock = sharedobject . getlock ( access_object ) . writelock ( ) ; boolean result = bool_ ; try { lock . lock ( ) ; final abstracthtml [ ] removedparentchildren = parent . children . toarray ( new abstracthtml [ parent . children . size ( ) ] ) ; result = insertbefore ( removedparentchildren , abstracthtmls ) ; } finally { lock . unlock ( ) ; } final pushqueue pushqueue = sharedobject . getpushqueue ( access_object ) ; if ( pushqueue != null ) { pushqueue . push ( ) ; } return result ; }	Inserts the given tags before this tag.
@ override protected void setattributevalue ( final boolean updateclient , final string value ) { if ( value != null ) { final collection < string > allvalues = extractvalues ( value ) ; super . replaceallinattributevalueset ( updateclient , allvalues ) ; } }	sets the value for this attribute.
protected void replaceallinattributevalueset ( final boolean updateclient , final string ... attrvalues ) { if ( attrvalues != null ) { final collection < string > allvalues = new arraydeque < > ( ) ; for ( final string attrvalue : attrvalues ) { if ( attrvalue != null ) { allvalues . addall ( extractvalues ( attrvalue ) ) ; } } super . replaceallinattributevalueset ( updateclient , allvalues ) ; } }	Removes all values from the attributeValueSet and adds the givenattribute values.
public final void addwebsocketpushlistener ( final string sessionid , final websocketpushlistener wslistener ) { sessionidwslisteners . put ( sessionid , wslistener ) ; wslisteners . push ( wslistener ) ; this . wslistener = wslistener ; if ( pushqueueonnewwebsocketlistener ) { pushwffbmbytesqueue ( ) ; } }	adds the WebSocket listener for the given WebSocket session.
public final void removewebsocketpushlistener ( final string sessionid ) { final websocketpushlistener removed = sessionidwslisteners . remove ( sessionid ) ; wslisteners . remove ( removed ) ; wslistener = wslisteners . peek ( ) ; }	removes the WebSocket listener added for this WebSocket session.
public final void removefromcontext ( final boolean enable , final on ... ons ) { for ( final on on : ons ) { if ( on . tab_close . equals ( on ) ) { removefrombrowsercontextontabclose = enable ; } else if ( on . init_remove_previous . equals ( on ) ) { removeprevfrombrowsercontextontabinit = enable ; } } }	By default On.TAB_CLOSE and On.INIT_REMOVE_PREVIOUS are enabled.
public final tagrepository gettagrepository ( ) { if ( tagrepository == null && roottag != null ) { synchronized ( this ) { if ( tagrepository == null ) { tagrepository = new tagrepository ( access_object , this , tagbywffid , roottag ) ; } } } return tagrepository ; }	Gets the TagRepository to do different tag operations.
protected final void setnonceforwffscript ( final string value ) { if ( autoremovewffscript ) { throw new invalidusageexception ( str_ ) ; } if ( value != null ) { if ( nonceforwffscripttag == null ) { nonceforwffscripttag = new nonce ( value ) ; if ( wffscripttagid != null ) { final abstracthtml [ ] ownertags = wffscripttagid . getownertags ( ) ; if ( ownertags . length > num_ ) { final abstracthtml wffscript = ownertags [ num_ ] ; wffscript . addattributes ( nonceforwffscripttag ) ; } } } else { nonceforwffscripttag . setvalue ( value ) ; } } else { if ( wffscripttagid != null && nonceforwffscripttag != null ) { final abstracthtml [ ] ownertags = wffscripttagid . getownertags ( ) ; if ( ownertags . length > num_ ) { final abstracthtml wffscript = ownertags [ num_ ] ; wffscript . removeattributes ( nonceforwffscripttag ) ; } } nonceforwffscripttag = null ; } }	Sets nonce attribute value for wff script.
public border setborderstyle ( final borderstyle borderstyle ) { if ( borderstyle == borderstyle . initial || borderstyle == borderstyle . inherit ) { throw new invalidvalueexception ( str_ + borderstyle . getcssvalue ( ) ) ; } final stringbuilder cssvaluebuilder = new stringbuilder ( ) ; if ( borderwidthvalue != null ) { cssvaluebuilder . append ( borderwidthvalue ) . append ( str_ ) ; } if ( borderstyle != null ) { cssvaluebuilder . append ( borderstyle . getcssvalue ( ) ) . append ( str_ ) ; } if ( bordercolorcssvalues != null ) { cssvaluebuilder . append ( bordercolorcssvalues . getvalue ( ) ) . append ( str_ ) ; } final string trimmedcssvalue = stringbuilderutil . gettrimmedstring ( cssvaluebuilder ) . tostring ( ) ; cssvalue = trimmedcssvalue . isempty ( ) ? inherit : trimmedcssvalue ; this . borderstyle = borderstyle ; if ( getstatechangeinformer ( ) != null ) { getstatechangeinformer ( ) . statechanged ( this ) ; } return this ; }	to set the border style.
public void setvalue ( final uuid uuid ) { if ( uuid != null ) { super . setattributevalue ( uuid . tostring ( ) ) ; this . uuid = uuid ; } }	value for the id attribute.
public static bytebuffer merge ( final bytebuffer ... dataarray ) { int totalcapacity = num_ ; for ( final bytebuffer data : dataarray ) { totalcapacity += data . capacity ( ) ; } final bytebuffer wholedata = bytebuffer . allocate ( totalcapacity ) ; for ( final bytebuffer data : dataarray ) { wholedata . put ( data ) ; } wholedata . flip ( ) ; return wholedata ; }	Merges and returns ByteBuffer from the given dataArray.
public void removeallcssproperties ( ) { final long stamp = lock . writelock ( ) ; try { cssproperties . clear ( ) ; abstractcsspropertyclassobjects . clear ( ) ; super . removeallfromattributevaluemap ( ) ; } finally { lock . unlockwrite ( stamp ) ; } }	Removes all css properties.
public boolean contains ( final cssproperty cssproperty ) { final long stamp = lock . readlock ( ) ; try { return cssproperties . contains ( cssproperty ) ; } finally { lock . unlockread ( stamp ) ; } }	Checks if the given cssProperty object exists in this style object.
map < string , cssproperty > getcsspropertiesasmap ( final boolean rebuild ) { if ( rebuild || ! loadedonce ) { synchronized ( cssproperties ) { if ( rebuild || ! loadedonce ) { cssproperties . clear ( ) ; load ( cssproperties ) ; loadedonce = bool_ ; setmodified ( bool_ ) ; } } } return csspropertiesasmap ; }	rebuild true to rebuild, the load method will be invoked again.
public collection < abstracthtml > findtagsbyattribute ( final abstractattribute attribute ) throws nullvalueexception { if ( attribute == null ) { throw new nullvalueexception ( str_ ) ; } final collection < abstracthtml > tags = new hashset < > ( ) ; for ( final abstracthtml ownertag : attribute . getownertags ( ) ) { if ( browserpage . contains ( ownertag ) ) { tags . add ( ownertag ) ; } } return tags ; }	Finds tags by attribute instance.
public abstracthtml findonetagbyattribute ( final abstractattribute attribute ) { if ( attribute == null ) { throw new nullvalueexception ( str_ ) ; } for ( final abstracthtml ownertag : attribute . getownertags ( ) ) { if ( browserpage . contains ( ownertag ) ) { return ownertag ; } } return null ; }	Finds one tag by attribute instance.
public collection < abstractattribute > findallattributes ( final boolean parallel ) { final collection < lock > locks = getreadlocks ( roottags ) ; for ( final lock lock : locks ) { lock . lock ( ) ; } try { return buildallattributesstream ( parallel ) . collect ( collectors . toset ( ) ) ; } finally { for ( final lock lock : locks ) { lock . unlock ( ) ; } } }	Finds all attributes from all tags.
public stream < abstractattribute > buildallattributesstream ( final boolean parallel ) { final stream < abstractattribute > attributesstream = buildalltagsstream ( parallel ) . filter ( tag -> tag . getattributes ( ) != null ) . map ( tag -> { return tag . getattributes ( ) ; } ) . flatmap ( attributes -> attributes . stream ( ) ) ; return attributesstream ; }	Finds all attributes as stream from all tags.
public static collection < abstractattribute > findallattributes ( final boolean parallel , final abstracthtml ... fromtags ) throws nullvalueexception { if ( fromtags == null ) { throw new nullvalueexception ( str_ ) ; } final collection < lock > locks = getreadlocks ( fromtags ) ; for ( final lock lock : locks ) { lock . lock ( ) ; } try { return getallnestedchildrenincludingparent ( parallel , fromtags ) . filter ( tag -> tag . getattributes ( ) != null ) . map ( tag -> { return tag . getattributes ( ) ; } ) . flatmap ( attributes -> attributes . stream ( ) ) . collect ( collectors . toset ( ) ) ; } finally { for ( final lock lock : locks ) { lock . unlock ( ) ; } } }	Finds all attributes from the given tags.
public boolean exists ( final abstracthtml tag ) throws nullvalueexception , invalidtagexception { if ( tag == null ) { throw new nullvalueexception ( str_ ) ; } if ( notag . class . isassignablefrom ( tag . getclass ( ) ) ) { throw new invalidtagexception ( str_ ) ; } return browserpage . contains ( tag ) ; }	Checks the existence of a tag instance.
public boolean exists ( final abstractattribute attribute ) throws nullvalueexception { if ( attribute == null ) { throw new nullvalueexception ( str_ ) ; } for ( final abstracthtml ownertag : attribute . getownertags ( ) ) { if ( browserpage . contains ( ownertag ) ) { return bool_ ; } } return bool_ ; }	Checks the existence of an attribute instance.
public static stream < abstractattribute > buildallattributesstream ( final boolean parallel , final abstracthtml ... fromtags ) { final stream < abstractattribute > attributesstream = getallnestedchildrenincludingparent ( parallel , fromtags ) . filter ( tag -> tag . getattributes ( ) != null ) . map ( tag -> { return tag . getattributes ( ) ; } ) . flatmap ( attributes -> attributes . stream ( ) ) ; return attributesstream ; }	Builds all attributes stream from the given tags.
public string getchildtext ( ) { final list < abstracthtml > children = getchildren ( ) ; if ( children . size ( ) > num_ ) { final stringbuilder builder = new stringbuilder ( ) ; for ( final abstracthtml child : children ) { builder . append ( child . tohtmlstring ( ) ) ; } return builder . tostring ( ) ; } return str_ ; }	gets the child text set for this tag.
private void writebychunk ( final byte [ ] bytes ) throws ioexception { final int chunksize = this . chunksize ; if ( bytes . length == num_ ) { return ; } if ( chunksize < bytes . length && chunksize > num_ ) { int remaining = bytes . length ; int offset = num_ ; while ( remaining > num_ ) { if ( chunksize < remaining ) { os . write ( bytes , offset , chunksize ) ; remaining -= chunksize ; offset += chunksize ; } else { os . write ( bytes , offset , remaining ) ; remaining = num_ ; } } } else { os . write ( bytes ) ; } }	writes maximum bytes at chuckSize.
public embeddedtomcat setcontextpath ( string contextpath ) { if ( contextpath == null || ! contextpath . equals ( str_ ) && ! contextpath . startswith ( str_ ) ) { throw new illegalargumentexception ( str_ ) ; } this . contextpath = contextpath ; return this ; }	Sets the contextPath for the webapplication.
public embeddedtomcat setcontextfile ( string contextfile ) { try { this . contextfileurl = new file ( contextfile ) . touri ( ) . tourl ( ) ; } catch ( malformedurlexception e ) { throw new runtimeexception ( e ) ; } return this ; }	Sets the location of the context file that configures this web application.
@ deprecated public embeddedtomcat addcontextenvironmentandresourcefromfile ( string contextfile ) { try { setcontextfile ( new file ( contextfile ) . touri ( ) . tourl ( ) ) ; } catch ( malformedurlexception e ) { throw new runtimeexception ( e ) ; } return this ; }	Read ContextEnvironment and ContextResource definition from a text file.
public static < t > filter < t > filter ( final path . filter filter , final content . type < t > contenttype ) { return new filter < t > ( ) { @ override public boolean matches ( path . id id , content . type < t > ct ) { return ct == contenttype && filter . matches ( id ) ; } @ override public boolean matchessubpath ( path . id id ) { return filter . matchessubpath ( id ) ; } @ override public string tostring ( ) { return filter . tostring ( ) ; } } ; }	Construct a content filter from a path filter and a content type.
public static < t > filter < t > or ( final filter < t > f1 , final filter < t > f2 ) { return new filter < t > ( ) { @ override public boolean matches ( path . id id , content . type < t > ct ) { return f1 . matches ( id , ct ) || f2 . matches ( id , ct ) ; } @ override public boolean matchessubpath ( path . id id ) { return f1 . matchessubpath ( id ) || f2 . matchessubpath ( id ) ; } @ override public string tostring ( ) { return f1 . tostring ( ) + str_ + f2 . tostring ( ) ; } } ; }	Combine two filters together produce one filter whose items must bematched by at least one of the original filters.
private void checknoteof ( ) { skipwhitespace ( ) ; if ( index >= tokens . size ( ) ) { if ( index > num_ ) { syntaxerror ( str_ , tokens . get ( index - num_ ) ) ; } else {	Check that the End-Of-File has not been reached.
private boolean islinespace ( token token ) { return token . kind == token . kind . indent || token . kind == token . kind . linecomment ; }	Define what is considered to be linespace.
protected string parsestring ( string v ) { v = v . substring ( num_ , v . length ( ) - num_ ) ; stringbuffer result = new stringbuffer ( ) ;	Parse a string constant whilst interpreting all escape characters.
public list < token > scan ( ) throws error { arraylist < token > tokens = new arraylist < > ( ) ; int pos = num_ ; while ( pos < input . length ( ) ) { int start = pos ; for ( int i = num_ ; i != rules . length ; ++ i ) { rule rule = rules [ i ] ; int left = input . length ( ) - pos ; if ( left >= rule . lookahead ( ) ) { token t = rule . match ( input , pos ) ; if ( t != null ) { tokens . add ( t ) ; pos = pos + t . text . length ( ) ; break ;	Scan the given input stream and produce a list of tokens, or an error.
protected command . template parse ( command . descriptor root , string [ ] args , int index ) { arraylist < command . option > options = new arraylist < > ( ) ; arraylist < string > arguments = new arraylist < > ( ) ;	Parse a given set of command-line arguments starting from a given indexposition to produce an appropriate command template.
private static object parsedata ( string str ) { if ( str . equals ( str_ ) ) { return bool_ ; } else if ( str . equals ( str_ ) ) { return bool_ ; } else if ( character . isdigit ( str . charat ( num_ ) ) ) {	Parse a given string representing a data value into an instance of Data.
protected void printusage ( ) { list < command . descriptor > descriptors = project . getparent ( ) . getcommanddescriptors ( ) ;	Print usage information to the console.
private static int determinecommandnamewidth ( list < command . descriptor > descriptors ) { int max = num_ ; for ( command . descriptor d : descriptors ) { max = math . max ( max , d . getname ( ) . length ( ) ) ; } return max ; }	Determine the maximum width of any configured command name.
private zipfile createzipfile ( list < path . entry < ? > > files ) throws ioexception {	Given a list of files construct a corresponding ZipFile containing them.
private byte [ ] readfilecontents ( path . entry < ? > file ) throws ioexception { inputstream in = file . inputstream ( ) ; bytearrayoutputstream buffer = new bytearrayoutputstream ( ) ; int nread ;	Read the contents of a given file into a byte array.
private content . filter createfilter ( string filter ) { string [ ] split = filter . split ( str_ ) ;	Create a content filter from the string representation.
@ override public void write ( int i ) throws ioexception { if ( count == num_ ) { output . write ( i & num_ ) ; } else { write_un ( i & num_ , num_ ) ; } }	Write an unsigned integer value using 8bits using a big-endian encoding.
public void write_u32 ( int w ) throws ioexception { write_u8 ( ( w > > num_ ) & num_ ) ; write_u8 ( ( w > > num_ ) & num_ ) ; write_u8 ( ( w > > num_ ) & num_ ) ; write_u8 ( w & num_ ) ; }	Write an unsigned integer value using 32bits using a big-endian encoding.
public void write_un ( int bits , int n ) throws ioexception { int mask = num_ ; for ( int i = num_ ; i < n ; ++ i ) { boolean bit = ( bits & mask ) != num_ ; write_bit ( bit ) ; mask = mask << num_ ; } }	Write an unsigned integer value using n bits using a big-endian encoding.
public static void printsyntacticmarkers ( printstream output , collection < path . entry < ? > > sources , path . entry < ? > target ) throws ioexception {	Print out syntactic markers for all entries in the build graph.
private static void printsyntacticmarkers ( printstream output , collection < path . entry < ? > > sources , syntacticitem . marker marker ) {	Print out an individual syntactic markers.
private static list < syntacticitem . marker > extractsyntacticmarkers ( path . entry < ? > ... binaries ) throws ioexception { list < syntacticitem . marker > annotated = new arraylist < > ( ) ;	Traverse the various binaries which have been generated looking for errormessages.
@ override public < t extends syntacticitem > t getparent ( class < t > kind ) { return parent . getparent ( this , kind ) ; }	Get the first syntactic item of a given kind which refers to this item.
@ override public < t extends syntacticitem > list < t > getparents ( class < t > kind ) { return parent . getparents ( this , kind ) ; }	Get all syntactic items of a given kind which refer to this item.
@ override public < t extends syntacticitem > t getancestor ( class < t > kind ) { return parent . getancestor ( this , kind ) ; }	Get the first syntactic item of a given kind which refers to this item eitherindirectly or directly.
public static int [ ] append ( int lhs , int [ ] rhs ) { int [ ] rs = new int [ rhs . length + num_ ] ; rs [ num_ ] = lhs ; system . arraycopy ( rhs , num_ , rs , num_ , rhs . length ) ; return rs ; }	Append an integer item to the front of an array of integer type together,producing a fresh array whose length equals that the second plus one.
public static int [ ] append ( int first , int second , int [ ] rhs ) { int [ ] rs = new int [ rhs . length + num_ ] ; rs [ num_ ] = first ; rs [ num_ ] = second ; system . arraycopy ( rhs , num_ , rs , num_ , rhs . length ) ; return rs ; }	Append two integer items to the front of an array of integer typetogether, producing a fresh array whose length equals that of the thirdplus two.
public static int [ ] append ( int [ ] lhs , int [ ] rhs ) { int [ ] rs = java . util . arrays . copyof ( lhs , lhs . length + rhs . length ) ; system . arraycopy ( rhs , num_ , rs , lhs . length , rhs . length ) ; return rs ; }	Append two arrays of integer type together, producing a fresh array whoselength equals that of the first and second added together.
public static < t > t [ ] append ( class < t > type , t lhs , t ... rhs ) { t [ ] rs = ( t [ ] ) array . newinstance ( type , rhs . length + num_ ) ; system . arraycopy ( rhs , num_ , rs , num_ , rhs . length ) ; rs [ num_ ] = lhs ; return rs ; }	Append an element onto an array of unknown type together, producing afresh array whose length equals that of the second plus one.
public static < t > void addall ( t [ ] lhs , collection < t > rhs ) { for ( int i = num_ ; i != lhs . length ; ++ i ) { rhs . add ( lhs [ i ] ) ; } }	Add all elements from an array into a given collection of the same type.
public static string [ ] tostringarray ( collection < string > items ) { string [ ] result = new string [ items . size ( ) ] ; int i = num_ ; for ( string s : items ) { result [ i ++ ] = s ; } return result ; }	Convert a collection of strings into a string array.
public static int [ ] tointarray ( collection < integer > items ) { int [ ] result = new int [ items . size ( ) ] ; int i = num_ ; for ( integer v : items ) { result [ i ++ ] = v ; } return result ; }	Convert a collection of Integers into an int array.
public static < t extends s , s extends comparable < s > > t [ ] sortandremoveduplicates ( t [ ] children ) { int r = issortedandunique ( children ) ; switch ( r ) { case num_ :	Sort and remove duplicate items from a given array.
public static < t extends comparable < t > > int issortedandunique ( t [ ] children ) { int r = num_ ; for ( int i = num_ ; i < children . length ; ++ i ) { int c = children [ i - num_ ] . compareto ( children [ i ] ) ; if ( c == num_ ) {	Check whether or not the children of this array are sorted according totheir underlying order.
public static < s , t extends comparable < s > > int compareto ( t [ ] lhs , t [ ] rhs ) { if ( lhs . length != rhs . length ) { return lhs . length - rhs . length ; } else { for ( int i = num_ ; i != lhs . length ; ++ i ) { int r = lhs [ i ] . compareto ( ( s ) rhs [ i ] ) ; if ( r != num_ ) { return r ; } } return num_ ; } }	A default operator for comparing arrays.
public configuration . schema getbuildschema ( ) { configuration . schema [ ] schemas = new configuration . schema [ buildplatforms . size ( ) + num_ ] ; schemas [ num_ ] = local_config_schema ; for ( int i = num_ ; i != buildplatforms . size ( ) ; ++ i ) { wybs . lang . build . platform platform = buildplatforms . get ( i ) ; schemas [ i + num_ ] = platform . getconfigurationschema ( ) ; } return configuration . tocombinedschema ( schemas ) ; }	Get the appropriate configuration schema for a project.
private void createtemplateextensionpoint ( ) { context . create ( command . descriptor . class , new module . extensionpoint < command . descriptor > ( ) { @ override public void register ( command . descriptor command ) { commanddescriptors . add ( command ) ; } } ) ; }	Create the Build.Template extension point.
private void activatedefaultplugins ( configuration global ) {	Activate the default set of plugins which the tool uses.
private static string determinesystemroot ( ) throws ioexception { string whileyhome = system . getenv ( str_ ) ; if ( whileyhome == null ) { system . err . println ( str_ ) ; system . exit ( - num_ ) ; } return whileyhome ; }	Determine the system root.
private static string determinelocalroot ( ) throws ioexception {	Determine where the root of this project is.
private static configuration readconfigfile ( string name , string dir , configuration . schema ... schemas ) throws ioexception { directoryroot root = new directoryroot ( dir , boot_registry ) ; path . entry < configfile > config = root . get ( trie . fromstring ( name ) , configfile . contenttype ) ; if ( config == null ) { return configuration . empty ; } try {	Attempt to read a configuration file from a given root.
public < t extends module > t getinstance ( class < t > module ) { return ( t ) instances . get ( module ) ; }	Get instance of given module within this context, or null if noinstance available.
public void start ( ) {	Scan and activate all modules on the search path.
private void activatemodules ( urlclassloader loader ) { for ( int i = num_ ; i != modules . size ( ) ; ++ i ) { descriptor module = modules . get ( i ) ; try { class c = loader . loadclass ( module . getactivator ( ) ) ; module . activator self = ( module . activator ) c . newinstance ( ) ; module instance = self . start ( context ) ; instances . put ( c , instance ) ; logger . logtimedmessage ( str_ + module . getid ( ) + str_ + module . getversion ( ) + str_ , num_ , num_ ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } }	Activate all modules in the order of occurrence in the given list.
public void outputsourceerror ( printstream output , boolean brief ) { attribute . span span ; if ( entry == null || element == null ) { output . println ( str_ + getmessage ( ) ) ; return ; } else if ( element instanceof attribute . span ) { span = ( attribute . span ) element ; } else { syntacticheap parent = element . getheap ( ) ; span = parent . getparent ( element , attribute . span . class ) ; }	Output the syntax error to a given output stream in either full or briefform.
private boolean ready ( build . task task ) {	Check whether a given task is ready to be built.
public static map < string , object > parseoptions ( list < string > args , optarg ... options ) { hashmap < string , object > result = new hashmap < > ( ) ; hashmap < string , optarg > optmap = new hashmap < > ( ) ; for ( optarg opt : options ) { if ( opt . defaultvalue != null ) { result . put ( opt . option , opt . defaultvalue ) ; } optmap . put ( opt . option , opt ) ; optmap . put ( opt . shortform , opt ) ; } iterator < string > iter = args . iterator ( ) ; while ( iter . hasnext ( ) ) { string arg = iter . next ( ) ; if ( arg . startswith ( str_ ) ) { arg = arg . substring ( num_ , arg . length ( ) ) ; optarg opt = optmap . get ( arg ) ; if ( opt != null ) {	Parse options from the list of arguments, removing those which arerecognised.
private static map < string , object > splitconfig ( string str ) { hashmap < string , object > options = new hashmap < > ( ) ; string [ ] splits = str . split ( str_ ) ; for ( string s : splits ) { string [ ] p = s . split ( str_ ) ; options . put ( p [ num_ ] , parsevalue ( p [ num_ ] ) ) ; } return options ; }	This splits strings of the form "x=y,v=w" into distinct components andputs them into a map.
@ override public < t extends syntacticitem > t getparent ( syntacticitem child , class < t > kind ) {	Get first parent of a syntactic item matching the given kind.
@ override public < t extends syntacticitem > t getancestor ( syntacticitem child , class < t > kind ) {	Get first ancestor of a syntactic item matching the given kind.
private static syntacticitem substitute ( syntacticitem item , syntacticitem from , syntacticitem to , map < syntacticitem , syntacticitem > mapping ) { syntacticitem sitem = mapping . get ( item ) ; if ( sitem != null ) {	Helper method for above.
private content . type < ? > getcontenttype ( string file ) { list < content . type < ? > > cts = project . getparent ( ) . getcontenttypes ( ) ; for ( int i = num_ ; i != cts . size ( ) ; ++ i ) { content . type < ? > ct = cts . get ( i ) ; string suffix = str_ + ct . getsuffix ( ) ; if ( file . endswith ( suffix ) ) { return ct ; } }	Determine the content type for this file.
public path . entry < ? > getentry ( string file , content . type < ? > ct ) throws ioexception {	Get the entry associated with this file.
private void inspect ( path . entry < ? > entry , content . type < ? > ct , boolean garbage ) throws ioexception { object o = entry . read ( ) ; if ( o instanceof syntacticheap ) { new syntacticheapprinter ( new printwriter ( out ) , garbage ) . print ( ( syntacticheap ) o ) ; } else { inspectbinaryfile ( readallbytes ( entry . inputstream ( ) ) ) ; } }	Inspect a given path entry.
private void inspectbinaryfile ( byte [ ] bytes ) { for ( int i = num_ ; i < bytes . length ; i += width ) { out . print ( string . format ( str_ , i ) ) ;	Inspect a given binary file.
protected pair < integer , syntacticitem [ ] > readitems ( ) throws ioexception {	Read all the items in this heap, returning the identified root item and anarray of all items contained therein.
public static trie fromstring ( path . id id ) { if ( id instanceof trie ) { return ( ( trie ) id ) ; } trie r = root ; for ( int i = num_ ; i != id . size ( ) ; ++ i ) { r = r . append ( id . get ( i ) ) ; } return r ; }	Construct a Trie from a Path ID.
public static command . descriptor descriptor ( list < command . descriptor > descriptors ) { return new command . descriptor ( ) { @ override public schema getconfigurationschema ( ) {	The descriptor for this command.
public path . root getrepositoryroot ( ) throws ioexception { path . root root = environment . getglobalroot ( ) . createrelativeroot ( repository_path ) ;	Get the root of the package repository.
private void resolvepackagedependencies ( ) throws ioexception {	Add any declared dependencies to the set of project roots.
public list < token > scan ( ) { arraylist < token > tokens = new arraylist < > ( ) ; pos = num_ ; while ( pos < input . length ( ) ) { char c = input . charat ( pos ) ; if ( character . isdigit ( c ) ) { tokens . add ( scannumericconstant ( ) ) ; } else if ( c == str_ ) { tokens . add ( scanstringconstant ( ) ) ; } else if ( c == str_ ) { tokens . add ( scancharacterconstant ( ) ) ; } else if ( isoperatorstart ( c ) ) { tokens . add ( scanoperator ( ) ) ; } else if ( character . isletter ( c ) || c == str_ ) { tokens . add ( scanidentifier ( ) ) ; } else if ( character . iswhitespace ( c ) ) { scanwhitespace ( tokens ) ; } else { syntaxerror ( str_ , pos ) ; } } return tokens ; }	Scan all characters from the input stream and generate a correspondinglist of tokens, whilst discarding all whitespace and comments.
private void syntaxerror ( string msg , int index ) {	Raise a syntax error with a given message at given index.
public void logstacktrace ( ) { if ( enabled ) { throwable t = new throwable ( ) ; t . fillinstacktrace ( ) ; stacktraceelement [ ] ste_arr = t . getstacktrace ( ) ; for ( int ii = num_ ; ii < ste_arr . length ; ii ++ ) { stacktraceelement ste = ste_arr [ ii ] ; system . out . printf ( str_ , getindentstring ( ) , ste ) ; } } }	Print a stack trace to System.out.
private string getindentstring ( ) { assert enabled ; if ( indentstring == null ) { for ( int i = indentstrings . size ( ) ; i <= indentlevel ; i ++ ) { indentstrings . add ( indentstrings . get ( i - num_ ) + indent_str_one_level ) ; } indentstring = indentstrings . get ( indentlevel ) ; } return indentstring ; }	Return the current indentation string.
boolean execute ( instructioncontext ic , frame inframe , arraylist < instructioncontext > executionpredecessors , instconstraintvisitor icv , executionvisitor ev ) { stack_types . set ( ic . getinstruction ( ) . getposition ( ) , inframe ) ; return ic . execute ( inframe , executionpredecessors , icv , ev ) ; }	Like InstructionContext.execute, but also sets stack_types.
protected string [ ] add_string ( string [ ] arr , string new_string ) { string [ ] new_arr = new string [ arr . length + num_ ] ; for ( int ii = num_ ; ii < arr . length ; ii ++ ) { new_arr [ ii ] = arr [ ii ] ; } new_arr [ arr . length ] = new_string ; return new_arr ; }	Returns a String array with new_string added to the end of arr.
@ pure protected final string get_attribute_name ( attribute a ) { int con_index = a . getnameindex ( ) ; constant c = pool . getconstant ( con_index ) ; string att_name = ( ( constantutf8 ) c ) . getbytes ( ) ; return att_name ; }	Return the attribute name for the specified attribute.
@ pure protected final @ nullable attribute get_stack_map_table_attribute ( methodgen mgen ) { for ( attribute a : mgen . getcodeattributes ( ) ) { if ( is_stack_map_table ( a ) ) { return a ; } } return null ; }	Find the StackMapTable attribute for a method.
@ pure protected final @ nullable attribute get_local_variable_type_table_attribute ( methodgen mgen ) { for ( attribute a : mgen . getcodeattributes ( ) ) { if ( is_local_variable_type_table ( a ) ) { return a ; } } return null ; }	Find the LocalVariableTypeTable attribute for a method.
protected final stackmapentry find_stack_map_equal ( int offset ) { running_offset = - num_ ;	Find the StackMap entry whose offset matches the input argument.
protected final int find_stack_map_index_before ( int offset ) { number_active_locals = initial_locals_count ; running_offset = - num_ ;	Find the index of the StackMap entry whose offset is the last one before the input argument.Return -1 if there isn't one.
protected final @ indexorlow ( str_ ) int find_stack_map_index_after ( int offset ) { running_offset = - num_ ;	Find the index of the StackMap entry whose offset is the first one after the input argument.Return -1 if there isn't one.
protected final void build_unitialized_new_map ( instructionlist il ) { uninitialized_new_map . clear ( ) ; il . setpositions ( ) ; for ( stackmapentry smte : stack_map_table ) { int frame_type = smte . getframetype ( ) ; if ( ( frame_type >= const . same_locals_1_stack_item_frame && frame_type <= const . same_locals_1_stack_item_frame_extended ) || ( frame_type >= const . append_frame && frame_type <= const . append_frame_max ) || ( frame_type == const . full_frame ) ) { if ( smte . getnumberoflocals ( ) > num_ ) { for ( stackmaptype smt : smte . gettypesoflocals ( ) ) { if ( smt . gettype ( ) == const . item_newobject ) { int i = smt . getindex ( ) ; uninitialized_new_map . put ( il . findhandle ( i ) , i ) ; } } } if ( smte . getnumberofstackitems ( ) > num_ ) { for ( stackmaptype smt : smte . gettypesofstackitems ( ) ) { if ( smt . gettype ( ) == const . item_newobject ) { int i = smt . getindex ( ) ; uninitialized_new_map . put ( il . findhandle ( i ) , i ) ; } } } } } }	We need to locate and remember any NEW instructions that create uninitialized objects.
private final void update_new_object_stack_map_entries ( int old_offset , int new_offset ) { for ( stackmapentry smte : stack_map_table ) { int frame_type = smte . getframetype ( ) ; if ( ( frame_type >= const . same_locals_1_stack_item_frame && frame_type <= const . same_locals_1_stack_item_frame_extended ) || ( frame_type >= const . append_frame && frame_type <= const . append_frame_max ) || ( frame_type == const . full_frame ) ) { if ( smte . getnumberoflocals ( ) > num_ ) { for ( stackmaptype smt : smte . gettypesoflocals ( ) ) { if ( smt . gettype ( ) == const . item_newobject ) { if ( old_offset == smt . getindex ( ) ) { smt . setindex ( new_offset ) ; } } } } if ( smte . getnumberofstackitems ( ) > num_ ) { for ( stackmaptype smt : smte . gettypesofstackitems ( ) ) { if ( smt . gettype ( ) == const . item_newobject ) { if ( old_offset == smt . getindex ( ) ) { smt . setindex ( new_offset ) ; } } } } } } }	One of uninitialized NEW instructions has moved.
protected final void update_uninitialized_new_offsets ( instructionlist il ) { il . setpositions ( ) ; for ( map . entry < instructionhandle , integer > e : uninitialized_new_map . entryset ( ) ) { instructionhandle ih = e . getkey ( ) ; int old_offset = e . getvalue ( ) . intvalue ( ) ; int new_offset = ih . getposition ( ) ; if ( old_offset != new_offset ) { update_new_object_stack_map_entries ( old_offset , new_offset ) ; e . setvalue ( new_offset ) ; } } }	Check to see if any of the uninitialized NEW instructions have moved.
@ ensuresnonnull ( { str_ } ) protected final void set_current_stack_map_table ( methodgen mgen , int java_class_version ) { smta = ( stackmap ) get_stack_map_table_attribute ( mgen ) ; if ( smta != null ) {	Get existing StackMapTable from the MethodGen argument.
protected final void print_stack_map_table ( string prefix ) { debug_instrument . log ( str_ , prefix , stack_map_table . length ) ; running_offset = - num_ ;	Print the contents of the StackMapTable to the debug_instrument.log.
protected final void create_new_stack_map_attribute ( methodgen mgen ) throws ioexception { if ( ! needstackmap ) { return ; } if ( stack_map_table == empty_stack_map_table ) { return ; } print_stack_map_table ( str_ ) ;	Create a new StackMap code attribute from stack_map_table.
@ suppresswarnings ( str_ )	Convert a Type name to a Class name.
protected final stackmaptype generate_stackmaptype_from_type ( type t ) { switch ( t . gettype ( ) ) { case const . t_boolean : case const . t_char : case const . t_byte : case const . t_short : case const . t_int : return new stackmaptype ( const . item_integer , - num_ , pool . getconstantpool ( ) ) ; case const . t_float : return new stackmaptype ( const . item_float , - num_ , pool . getconstantpool ( ) ) ; case const . t_double : return new stackmaptype ( const . item_double , - num_ , pool . getconstantpool ( ) ) ; case const . t_long : return new stackmaptype ( const . item_long , - num_ , pool . getconstantpool ( ) ) ; case const . t_array : case const . t_object : return new stackmaptype ( const . item_object , pool . addclass ( typetoclassgetname ( t ) ) , pool . getconstantpool ( ) ) ;	Convert a Type to a StackMapType.
protected final type generate_type_from_stackmaptype ( stackmaptype smt ) { switch ( smt . gettype ( ) ) { case const . item_integer : case const . item_bogus :	Convert a StackMapType to a Type.
protected final localvariablegen create_method_scope_local ( methodgen mgen , string local_name , type local_type ) {	Create a new local with a scope of the full method.
protected final stacktypes bcel_calc_stack_types ( methodgen mg ) { stackver stackver = new stackver ( ) ; verificationresult vr ; try { vr = stackver . do_stack_ver ( mg ) ; } catch ( throwable t ) { system . out . printf ( str_ , mg . getclassname ( ) , mg . getname ( ) ) ; system . out . printf ( str_ , t ) ; system . out . printf ( str_ ) ; return null ; } if ( vr != verificationresult . vr_ok ) { system . out . printf ( str_ , mg . getclassname ( ) , mg . getname ( ) , vr ) ; system . out . printf ( str_ ) ; return null ; } assert vr == verificationresult . vr_ok : str_ + vr ; return stackver . get_stack_types ( ) ; }	Calculates the types on the stack for each instruction using the BCEL stack verificationroutines.
static string accessflagstostring ( method m ) { int flags = m . getaccessflags ( ) ; stringbuilder buf = new stringbuilder ( ) ;	Return a string representation of the access flags of method m.
public static string instructionlisttostring ( instructionlist il , constantpoolgen pool ) { stringbuilder out = new stringbuilder ( ) ; for ( iterator < instructionhandle > i = il . iterator ( ) ; i . hasnext ( ) ; ) { instructionhandle handle = i . next ( ) ; out . append ( handle . getinstruction ( ) . tostring ( pool . getconstantpool ( ) ) + str_ ) ; } return out . tostring ( ) ; }	Return a printed description of the given instructions.
public static string attributenametostring ( attribute a ) { constantpool pool = a . getconstantpool ( ) ; int conindex = a . getnameindex ( ) ; constant c = pool . getconstant ( conindex ) ; string attname = ( ( constantutf8 ) c ) . getbytes ( ) ; return attname ; }	Return the attribute name for the specified attribute, looked up in the original class fileConstantPool.
public static void checkmgen ( methodgen mgen ) { if ( skipchecks ) { return ; } try { mgen . tostring ( ) ;	Checks the specified method for consistency. Does nothing if {.
public static void checkmgens ( final classgen gen ) { if ( skipchecks ) { return ; } method [ ] methods = gen . getmethods ( ) ; for ( int i = num_ ; i < methods . length ; i ++ ) { method method = methods [ i ] ;	Checks all of the methods in gen for consistency.
public static void dumpstacktrace ( ) { stacktraceelement [ ] ste = thread . currentthread ( ) . getstacktrace ( ) ;	Print the current java call stack.
static void dumpmethods ( classgen gen ) { system . out . printf ( str_ , gen . getclassname ( ) ) ; for ( method m : gen . getmethods ( ) ) { system . out . printf ( str_ , m ) ; } }	Print the methods in the class, to standard output.
public static void addtostart ( methodgen mg , instructionlist newlist ) {	Adds instructions to the start of a method.
public static string getconstantstring ( constantpool pool , int index ) { constant c = pool . getconstant ( index ) ; assert c != null : str_ + index + str_ ; if ( c instanceof constantutf8 ) { return ( ( constantutf8 ) c ) . getbytes ( ) ; } else if ( c instanceof constantclass ) { constantclass cc = ( constantclass ) c ; return cc . getbytes ( pool ) + str_ + cc . getnameindex ( ) + str_ ; } else { throw new error ( str_ + c + str_ + c . getclass ( ) ) ; } }	Returns the constant string at the specified offset.
public static void resetlocalstoformals ( methodgen mg ) {	Sets the locals to be the formal parameters.
public static class < ? > typetoclass ( type type ) { string classname = typetoclassgetname ( type ) ; try { return reflectionplume . classforname ( classname ) ; } catch ( exception e ) { throw new runtimeexception ( str_ + classname , e ) ; } }	Returns the class that corresponds to type.
public static type [ ] postpendtoarray ( type [ ] types , type newtype ) { if ( types . length == integer . max_value ) { throw new error ( str_ + types + str_ ) ; } type [ ] newtypes = new type [ types . length + num_ ] ; system . arraycopy ( types , num_ , newtypes , num_ , types . length ) ; newtypes [ types . length ] = newtype ; return newtypes ; }	Returns a copy of the given type array, with newType added to the end.
public void set ( @ indexfor ( { str_ , str_ } ) int offset , frame f ) { operandstack os = f . getstack ( ) ;	Sets the stack for the instruction at the specified offset to a copy of the information in thegiven frame.
protected final void insert_at_method_start ( methodgen mg , instructionlist new_il ) {	Inserts an instruction list at the beginning of a method.
private void print_il ( instructionhandle start , string label ) { if ( debug_instrument . enabled ( ) ) { print_stack_map_table ( label ) ; instructionhandle tih = start ; while ( tih != null ) { debug_instrument . log ( str_ , tih ) ; if ( tih . hastargeters ( ) ) { for ( instructiontargeter it : tih . gettargeters ( ) ) { debug_instrument . log ( str_ , it ) ; } } tih = tih . getnext ( ) ; } } }	Print a BCEL instruction list to the debug_instrument log.
protected final instructionlist build_il ( instruction ... instructions ) { instructionlist il = new instructionlist ( ) ; for ( instruction inst : instructions ) { append_inst ( il , inst ) ; } return il ; }	Convenience function to build an instruction list.
protected final stackmaptype [ ] calculate_live_stack_types ( operandstack stack ) { int ss = stack . size ( ) ; stackmaptype [ ] stack_map_types = new stackmaptype [ ss ] ; for ( int ii = num_ ; ii < ss ; ii ++ ) { stack_map_types [ ii ] = generate_stackmaptype_from_type ( stack . peek ( ss - ii - num_ ) ) ; } return stack_map_types ; }	Compute the StackMapTypes of the items on the execution stack as described by the OperandStackargument.
private static final int find ( boolean skipblocks , string s , char tofind , int from ) { int open = num_ ; boolean escaping = bool_ ; for ( int i = from ; i < s . length ( ) ; i ++ ) { if ( escaping ) { escaping = bool_ ; continue ; } char c = s . charat ( i ) ; if ( c == str_ ) { escaping = bool_ ; continue ; } if ( ( open == num_ ) && ( c == tofind ) ) { return i ; } else if ( skipblocks && ( c == str_ ) ) { open ++ ; } else if ( skipblocks && ( c == str_ ) ) { open -- ; } } return - num_ ; }	Beware, with the current algorithm, this function cannot find '\'.
@ override public int read ( final byte [ ] output , final int offset , final int length ) throws ttransportexception { int read = num_ ; int index = offset ; int space = length - offset ; while ( space > num_ ) { byte abyte = readasynchrously ( ) ; output [ index ] = abyte ; space -- ; index ++ ; read ++ ; } return read ; }	Reads from the shared input queue, blocking if there is not enough inputin the buffer.
@ override public void flush ( ) throws ttransportexception { channelbuffer flush = channelbuffers . dynamicbuffer ( ) ; flush . writebytes ( output ) ; channel . write ( flush ) . awaituninterruptibly ( ) ; }	We need data to be written and flushed at once.
public websocketclient newclient ( final uri url , final websocketcallback callback ) { clientbootstrap bootstrap = new clientbootstrap ( socketchannelfactory ) ; string protocol = url . getscheme ( ) ; if ( ! protocol . equals ( str_ ) && ! protocol . equals ( str_ ) ) { throw new illegalargumentexception ( str_ + protocol ) ; } final websocketclienthandler clienthandler = new websocketclienthandler ( bootstrap , url , callback ) ; bootstrap . setpipelinefactory ( new channelpipelinefactory ( ) { public channelpipeline getpipeline ( ) throws exception { channelpipeline pipeline = channels . pipeline ( ) ; pipeline . addlast ( str_ , new httpresponsedecoder ( ) ) ; pipeline . addlast ( str_ , new httprequestencoder ( ) ) ; pipeline . addlast ( str_ , clienthandler ) ; return pipeline ; } } ) ; return clienthandler ; }	Create a new WebSocket client.
private boolean canusethisad ( nativead adnative ) { if ( adnative != null ) { nativead . image logoimage = null ; charsequence header = null , body = null ; if ( adnative instanceof nativecontentad ) { nativecontentad ad = ( nativecontentad ) adnative ; logoimage = ad . getlogo ( ) ; header = ad . getheadline ( ) ; body = ad . getbody ( ) ; } else if ( adnative instanceof nativeappinstallad ) { nativeappinstallad ad = ( nativeappinstallad ) adnative ; logoimage = ad . geticon ( ) ; header = ad . getheadline ( ) ; body = ad . getbody ( ) ; } if ( ! textutils . isempty ( header ) && ! textutils . isempty ( body ) ) { return bool_ ; } } return bool_ ; }	Determines if the native ad can be used.
public synchronized adview getadforindex ( int adpos ) { if ( adpos >= num_ && mprefetchedads . size ( ) > adpos ) return mprefetchedads . get ( adpos ) ; return null ; }	Gets banner ad at a particular index in the fetched ads list.
private synchronized void onfailedtoload ( adview adview , int errorcode ) { log . i ( tag , str_ + errorcode ) ; mfetchfailcount ++ ; mnooffetchedads = math . max ( mnooffetchedads - num_ , num_ ) ;	A handler for failed banner ads.
protected synchronized adrequest getadrequest ( ) { adrequest . builder adbldr = new adrequest . builder ( ) ; for ( string id : gettestdeviceids ( ) ) { adbldr . addtestdevice ( id ) ; } return adbldr . build ( ) ; }	Setup and get an ads request.
public int getadscounttopublish ( int fetchedadscount , int sourceitemscount ) { if ( fetchedadscount <= num_ || getnoofdatabetweenads ( ) <= num_ ) return num_ ; int expected = num_ ; if ( sourceitemscount > num_ && sourceitemscount >= getoffsetvalue ( ) + num_ ) expected = ( sourceitemscount - getoffsetvalue ( ) ) / getnoofdatabetweenads ( ) + num_ ; expected = math . max ( num_ , expected ) ; expected = math . min ( fetchedadscount , expected ) ; return math . min ( expected , getlimitofads ( ) ) ; }	Gets the count of ads that could be published.
public int getoriginalcontentposition ( int position , int fetchedadscount , int sourceitemscount ) { int noofads = getadscounttopublish ( fetchedadscount , sourceitemscount ) ;	Translates an adapter position to an actual position within the underlying dataset.
public int getadindex ( int position ) { int index = - num_ ; if ( position >= getoffsetvalue ( ) ) index = ( position - getoffsetvalue ( ) ) / ( getnoofdatabetweenads ( ) + num_ ) ;	Gets the ad index for this adapter position within the list of currently fetched ads.
public boolean isadavailable ( int position , int fetchedadscount ) { if ( fetchedadscount == num_ ) return bool_ ; int adindex = getadindex ( position ) ; int firstadpos = getoffsetvalue ( ) ; return position >= firstadpos && adindex >= num_ && adindex < getlimitofads ( ) && adindex < fetchedadscount ; }	Checks if an ad is available for this position.
public boolean hastofetchad ( int position , int fetchingadscount ) { int adindex = getadindex ( position ) ; int firstadpos = getoffsetvalue ( ) ; return position >= firstadpos && adindex >= num_ && adindex < getlimitofads ( ) && adindex >= fetchingadscount ; }	Checks if we have to request the next ad block for this position.
public static typemirror hasgenericstypeargumentof ( element element , string typetocheck , elements elements , types types ) { if ( element . astype ( ) . getkind ( ) != typekind . declared || ! ( element . astype ( ) instanceof declaredtype ) ) { processormessage . error ( element , str_ , element . getsimplename ( ) , element . astype ( ) . tostring ( ) ) ; } declaredtype declaredtype = ( declaredtype ) element . astype ( ) ; list < ? extends typemirror > typearguments = declaredtype . gettypearguments ( ) ; if ( typearguments . isempty ( ) ) { processormessage . error ( element , str_ , element . getsimplename ( ) , element . astype ( ) . tostring ( ) ) ; } if ( typearguments . size ( ) > num_ ) { processormessage . error ( element , str_ , element . getsimplename ( ) , element . astype ( ) . tostring ( ) ) ; }	Checks if the variabel element has generics arguments that matches the expected type.
public javawriter emitpackage ( string packagename ) throws ioexception { if ( this . packageprefix != null ) { throw new illegalstateexception ( ) ; } if ( packagename . isempty ( ) ) { this . packageprefix = str_ ; } else { out . write ( str_ ) ; out . write ( packagename ) ; out . write ( str_ ) ; this . packageprefix = packagename + str_ ; } return this ; }	Emit a package declaration and empty line.
public string compresstype ( string type ) { stringbuilder sb = new stringbuilder ( ) ; if ( this . packageprefix == null ) { throw new illegalstateexception ( ) ; } matcher m = type_pattern . matcher ( type ) ; int pos = num_ ; while ( bool_ ) { boolean found = m . find ( pos ) ;	Try to compress a fully-qualified class name to only the class name.
public javawriter begininitializer ( boolean isstatic ) throws ioexception { indent ( ) ; if ( isstatic ) { out . write ( str_ ) ; out . write ( str_ ) ; } else { out . write ( str_ ) ; } scopes . push ( scope . initializer ) ; return this ; }	Emits an initializer declaration.
public javawriter endtype ( ) throws ioexception { popscope ( scope . type_declaration , scope . interface_declaration ) ; types . pop ( ) ; indent ( ) ; out . write ( str_ ) ; return this ; }	Completes the current type declaration.
public javawriter emitsinglelinecomment ( string comment , object ... args ) throws ioexception { indent ( ) ; out . write ( str_ ) ; out . write ( string . format ( comment , args ) ) ; out . write ( str_ ) ; return this ; }	Emits a single line comment.
private javawriter emitannotationvalue ( object value ) throws ioexception { if ( value instanceof object [ ] ) { out . write ( str_ ) ; boolean firstvalue = bool_ ; scopes . push ( scope . annotation_array_value ) ; for ( object o : ( ( object [ ] ) value ) ) { if ( firstvalue ) { firstvalue = bool_ ; out . write ( str_ ) ; } else { out . write ( str_ ) ; } indent ( ) ; out . write ( o . tostring ( ) ) ; } popscope ( scope . annotation_array_value ) ; out . write ( str_ ) ; indent ( ) ; out . write ( str_ ) ; } else { out . write ( value . tostring ( ) ) ; } return this ; }	Writes a single annotation value.
public javawriter endmethod ( ) throws ioexception { scope popped = scopes . pop ( ) ;	Completes the current method declaration.
public static string type ( class < ? > raw , string ... parameters ) { if ( parameters . length == num_ ) { return raw . getcanonicalname ( ) ; } if ( raw . gettypeparameters ( ) . length != parameters . length ) { throw new illegalargumentexception ( ) ; } stringbuilder result = new stringbuilder ( ) ; result . append ( raw . getcanonicalname ( ) ) ; result . append ( str_ ) ; result . append ( parameters [ num_ ] ) ; for ( int i = num_ ; i < parameters . length ; i ++ ) { result . append ( str_ ) ; result . append ( parameters [ i ] ) ; } result . append ( str_ ) ; return result . tostring ( ) ; }	Build a string representation of a type and optionally its generic type arguments.
private void emitmodifiers ( set < modifier > modifiers ) throws ioexception { if ( modifiers . isempty ( ) ) { return ; }	Emits the modifiers to the writer.
private psiclass getpsiclassfromcontext ( anactionevent e ) { psifile psifile = e . getdata ( langdatakeys . psi_file ) ; editor editor = e . getdata ( platformdatakeys . editor ) ; if ( psifile == null || editor == null ) { return null ; } int offset = editor . getcaretmodel ( ) . getoffset ( ) ; psielement element = psifile . findelementat ( offset ) ; return psitreeutil . getparentoftype ( element , psiclass . class ) ; }	Get the class where currently the curser is.
private void findandremovemethod ( string methodname , string ... arguments ) {	Finds and removes a given method.
public void generate ( ) { psielementfactory elementfactory = javapsifacade . getelementfactory ( psiclass . getproject ( ) ) ; javacodestylemanager stylemanager = javacodestylemanager . getinstance ( psiclass . getproject ( ) ) ;	Generate and insert the Parcel and ParcelablePlease code.
private void makeclassimplementparcelable ( psielementfactory elementfactory , javacodestylemanager stylemanager ) { final psiclasstype [ ] implementslisttypes = psiclass . getimplementslisttypes ( ) ; final string implementstype = str_ ; for ( psiclasstype implementslisttype : implementslisttypes ) { psiclass resolved = implementslisttype . resolve ( ) ;	Make the class implementing Parcelable.
private boolean isclass ( element element ) { if ( element . getkind ( ) == elementkind . class ) { if ( element . getmodifiers ( ) . contains ( modifier . abstract ) ) { processormessage . error ( element , str_ + str_ + str_ , element . getsimplename ( ) , parcelableplease . class . getsimplename ( ) , parcelableplease . class . getsimplename ( ) ) ; return bool_ ; } if ( element . getmodifiers ( ) . contains ( modifier . private ) ) { processormessage . error ( element , str_ + str_ , element . getsimplename ( ) , parcelableplease . class . getsimplename ( ) ) ; return bool_ ; }	Checks if the element is a class.
public static boolean istypeof ( typemirror type , class < ? > clazz ) { return type . tostring ( ) . equals ( clazz . getcanonicalname ( ) ) ; }	Checks if a TypeMirror equals a class.
public static class < ? > istypeof ( typemirror type , list < class < ? > > classlist ) { for ( class < ? > c : classlist ) { if ( istypeof ( type , c ) ) { return c ; } } return null ; }	Returns the class this element is part of.
public static string getpackagename ( elements elementutils , typeelement type ) throws ioexception { packageelement pkg = elementutils . getpackageof ( type ) ; if ( ! pkg . isunnamed ( ) ) { return pkg . getqualifiedname ( ) . tostring ( ) ; } else { return str_ ;	Get the Package name.
public static string getbinaryname ( elements elementutils , typeelement type ) throws ioexception { string packagename = getpackagename ( elementutils , type ) ; string qualifiedname = type . getqualifiedname ( ) . tostring ( ) ; if ( packagename . length ( ) > num_ ) { return packagename + str_ + qualifiedname . substring ( packagename . length ( ) + num_ ) . replace ( str_ , str_ ) ; } else { return qualifiedname . replace ( str_ , str_ ) ; } }	Get the qualified name of a class. Also respects innner classes.
private void generatewritetoparcel ( javawriter jw , string originclass , list < parcelablefield > fields ) throws ioexception { jw . beginmethod ( str_ , str_ , enumset . of ( modifier . public , modifier . static ) , originclass , param_source , str_ , param_parcel , str_ , param_flags ) ; for ( parcelablefield field : fields ) { fieldcodegen gen = field . getcodegenerator ( ) ; if ( gen == null ) {	Generate the writeToParcel method.
private boolean ispublicclass ( declaredtype type ) { element element = type . aselement ( ) ; return element . getmodifiers ( ) . contains ( javax . lang . model . element . modifier . public ) ; }	Checks if a class is public.
private boolean haspublicemptyconstructor ( declaredtype type ) { element element = type . aselement ( ) ; list < ? extends element > containing = element . getenclosedelements ( ) ; for ( element e : containing ) { if ( e . getkind ( ) == elementkind . constructor ) { executableelement c = ( executableelement ) e ; if ( ( c . getparameters ( ) == null || c . getparameters ( ) . isempty ( ) ) && c . getmodifiers ( ) . contains ( javax . lang . model . element . modifier . public ) ) { return bool_ ; } } } return bool_ ; }	Checks if an public empty constructor is available.
public static double determinant3x3 ( final double r0c0 , final double r0c1 , final double r0c2 , final double r1c0 , final double r1c1 , final double r1c2 , final double r2c0 , final double r2c1 , final double r2c2 ) { double sum = num_ ; sum += r0c0 * ( ( r1c1 * r2c2 ) - ( r1c2 * r2c1 ) ) ; sum -= r0c1 * ( ( r1c0 * r2c2 ) - ( r1c2 * r2c0 ) ) ; sum += r0c2 * ( ( r1c0 * r2c1 ) - ( r1c1 * r2c0 ) ) ; return sum ; }	Calculate the determinant of the given 3x3 matrix values.
public static generator < matrix4x4d > createorthogonal ( ) { return ( ) -> { final securerandom rng = new securerandom ( ) ; final double r0c0 = num_ ; final double r0c1 = num_ ; final double r0c2 = num_ ; final double r0c3 = rng . nextdouble ( ) ; final double r1c0 = num_ ; final double r1c1 = num_ ; final double r1c2 = num_ ; final double r1c3 = rng . nextdouble ( ) ; final double r2c0 = num_ ; final double r2c1 = num_ ; final double r2c2 = num_ ; final double r2c3 = rng . nextdouble ( ) ; final double r3c0 = num_ ; final double r3c1 = num_ ; final double r3c2 = num_ ; final double r3c3 = num_ ; return matrix4x4d . of ( r0c0 , r0c1 , r0c2 , r0c3 , r1c0 , r1c1 , r1c2 , r1c3 , r2c0 , r2c1 , r2c2 , r2c3 , r3c0 , r3c1 , r3c2 , r3c3 ) ; } ; }	Create a generator initialized with a default component generator that onlyproduces orthogonal matrices.
@ suppresswarnings ( str_ ) public static list < byte [ ] > getbinarymultibulkreply ( byte [ ] input ) { return ( list < byte [ ] > ) redisprotocol . read ( new redisinputstream ( new bytearrayinputstream ( input ) ) ) ; }	Gets the binary multi bulk reply.
private set < tuple > getbinarytupledset ( ) { list < byte [ ] > memberswithscores = client . getbinarymultibulkreply ( ) ; set < tuple > set = new linkedhashset < tuple > ( ) ; if ( memberswithscores == null ) { return set ; } iterator < byte [ ] > iterator = memberswithscores . iterator ( ) ; if ( iterator == null ) { return set ; } while ( iterator . hasnext ( ) ) { set . add ( new tuple ( iterator . next ( ) , double . valueof ( safeencoder . encode ( iterator . next ( ) ) ) ) ) ; } return set ; }	Gets the binary tupled set.
@ suppresswarnings ( str_ ) byte [ ] rawkey ( object key ) { assert . notnull ( key , str_ ) ; return keyserializer ( ) . serialize ( key ) ; }	Raw key.
@ suppresswarnings ( str_ ) < hk > byte [ ] rawhashkey ( hk hashkey ) { assert . notnull ( hashkey , str_ ) ; return hashkeyserializer ( ) . serialize ( hashkey ) ; }	Raw hash key.
@ suppresswarnings ( str_ ) set < typedtuple < v > > deserializetuplevalues ( set < tuple > rawvalues ) { set < typedtuple < v > > set = new linkedhashset < typedtuple < v > > ( rawvalues . size ( ) ) ; for ( tuple rawvalue : rawvalues ) { set . add ( new defaulttypedtuple ( valueserializer ( ) . deserialize ( rawvalue . getvalue ( ) ) , rawvalue . getscore ( ) ) ) ; } return set ; }	Deserialize tuple values.
@ suppresswarnings ( str_ ) < t > set < t > deserializehashkeys ( set < byte [ ] > rawkeys ) { return serializationutils . deserialize ( rawkeys , hashkeyserializer ( ) ) ; }	Deserialize hash keys.
@ suppresswarnings ( str_ ) < t > list < t > deserializehashvalues ( list < byte [ ] > rawvalues ) { return serializationutils . deserialize ( rawvalues , hashvalueserializer ( ) ) ; }	Deserialize hash values.
@ suppresswarnings ( str_ ) < hk , hv > map < hk , hv > deserializehashmap ( map < byte [ ] , byte [ ] > entries ) {	Deserialize hash map.
< hk , hv > map < hk , list < hv > > deserializehashlist ( map < byte [ ] , list < byte [ ] > > entries ) {	Deserialize hash list.
< hk , hv > map < hk , set < hv > > deserializehashset ( map < byte [ ] , set < byte [ ] > > entries ) {	Deserialize hash set.
public static list < gatewayaddress > aslistfromdomain ( final string domainaddress ) { if ( domainaddress == null ) { throw new illegalargumentexception ( str_ ) ; } gatewayaddress domain = new gatewayaddress ( num_ , domainaddress ) ; inetaddress [ ] addresses ; try { addresses = inetaddress . getallbyname ( domain . gethost ( ) ) ; } catch ( exception e ) { throw new illegalargumentexception ( str_ + domain + str_ + e . getmessage ( ) ) ; } list < gatewayaddress > list = new arraylist < gatewayaddress > ( ) ; int id = num_ ; for ( inetaddress address : addresses ) { list . add ( new gatewayaddress ( id ++ , address . gethostaddress ( ) , domain . getport ( ) ) ) ; } return list ; }	As list from domain.
public static string parsehost ( final string address ) { int ep = address . indexof ( str_ ) ; if ( ep == - num_ || ep == num_ ) { throw new illegalargumentexception ( str_ + address + str_ ) ; } return address . substring ( num_ , ep ) . trim ( ) ; }	Parses the host.
public static int parseport ( final string address ) { int sp = address . indexof ( str_ ) ; if ( sp == - num_ && sp + num_ >= address . length ( ) ) { throw new illegalargumentexception ( str_ + address + str_ ) ; } try { return integer . parseint ( address . substring ( sp + num_ , address . length ( ) ) . trim ( ) ) ; } catch ( numberformatexception nfe ) { throw new illegalargumentexception ( str_ + address + str_ ) ; } }	Parses the port.
public void set ( final string key , final string value ) { set ( safeencoder . encode ( key ) , safeencoder . encode ( value ) ) ; }	Sets the.
public void sync ( ) { if ( this . client == null ) { return ; } list < object > unformatted = null ; try { unformatted = this . client . getall ( ) ; } catch ( exception e ) { this . brokenresource = bool_ ; throw new gatewayexception ( str_ + this . server + str_ + this . redis . connectinfo ( ) , e ) ; } if ( unformatted == null ) { return ; } for ( object o : unformatted ) { try { generateresponse ( o ) ; } catch ( exception ignored ) { } } }	Synchronize pipeline by reading all responses.
private set < tuple > gettupledset ( ) { list < string > memberswithscores = client . getmultibulkreply ( ) ; set < tuple > set = new linkedhashset < tuple > ( ) ; iterator < string > iterator = memberswithscores . iterator ( ) ; while ( iterator . hasnext ( ) ) { set . add ( new tuple ( iterator . next ( ) , double . valueof ( iterator . next ( ) ) ) ) ; } return set ; }	Gets the tupled set.
public synchronized void stop ( ) { state = state . stop ; dispatchevent ( leaderelectioneventtype . stop_start ) ; logger . info ( str_ ) ; if ( leaderoffer != null ) { try { zookeeper . delete ( leaderoffer . getnodepath ( ) , - num_ ) ; logger . info ( str_ , leaderoffer . getnodepath ( ) ) ; } catch ( interruptedexception e ) { becomefailed ( e ) ; } catch ( keeperexception e ) { becomefailed ( e ) ; } } dispatchevent ( leaderelectioneventtype . stop_complete ) ; }	Stops all election services, revokes any outstanding leader offers, anddisconnects from ZooKeeper.
string toexecuteinfo ( final int trycount , final long startedtime , final gatewayserver server , final rediscluster redis ) { final stringbuilder sb = new stringbuilder ( ) ; final long executedtime = system . currenttimemillis ( ) - startedtime ; sb . append ( str_ ) . append ( executedtime ) . append ( str_ ) ; sb . append ( str_ ) . append ( trycount ) . append ( str_ ) ; sb . append ( str_ ) . append ( server ) ; if ( redis != null ) { sb . append ( str_ ) . append ( str_ ) . append ( redis . connectinfo ( ) ) ; } return sb . tostring ( ) ; }	time, retry, gateway server information.
public void setquorum ( partitiongroupserver master , int q , string quorummembers ) throws mgmtsetquorumexception , mgmtsmrcommandexception { master . setquorum ( q , quorummembers ) ; }	Since it is a singleton instance and represents a part of workflow logic running in multiple threads.
public static void checkpermission ( string path , locktype type ) throws mgmtzookeeperexception { if ( znodepermission . get ( ) != null ) { znodepermission . get ( ) . checkpermission ( path , type ) ; } }	Clear ZNodePermission of current-thread to null.If znodePermission.get() returns null, this method skip permission-check.
private byte [ ] [ ] joinparameters ( byte [ ] first , byte [ ] [ ] rest ) { byte [ ] [ ] result = new byte [ rest . length + num_ ] [ ] ; result [ num_ ] = first ; for ( int i = num_ ; i < rest . length ; i ++ ) { result [ i + num_ ] = rest [ i ] ; } return result ; }	Join parameters.
public void expireat ( final byte [ ] key , final long millisecondstimestamp ) { sendcommand ( command . expireat , key , redisprotocol . tobytearray ( millisecondstimestamp ) ) ; }	Expire at.
public void decrby ( final byte [ ] key , final long integer ) { sendcommand ( command . decrby , key , redisprotocol . tobytearray ( integer ) ) ; }	Decr by.
public void incrby ( final byte [ ] key , final long integer ) { sendcommand ( command . incrby , key , redisprotocol . tobytearray ( integer ) ) ; }	Incr by.
public void zaddbinary ( final byte [ ] key , map < double , byte [ ] > scoremembers ) { arraylist < byte [ ] > args = new arraylist < byte [ ] > ( scoremembers . size ( ) * num_ + num_ ) ; args . add ( key ) ; for ( map . entry < double , byte [ ] > entry : scoremembers . entryset ( ) ) { args . add ( redisprotocol . tobytearray ( entry . getkey ( ) ) ) ; args . add ( entry . getvalue ( ) ) ; } byte [ ] [ ] argsarray = new byte [ args . size ( ) ] [ ] ; args . toarray ( argsarray ) ; sendcommand ( command . zadd , argsarray ) ; }	Zadd binary.
public void zrangebyscore ( final byte [ ] key , final byte [ ] min , final byte [ ] max ) { sendcommand ( command . zrangebyscore , key , min , max ) ; }	Zrange by score.
public void zrangebyscorewithscores ( final byte [ ] key , final byte [ ] min , final byte [ ] max , final int offset , final int count ) { sendcommand ( command . zrangebyscore , key , min , max , keyword . limit . raw , redisprotocol . tobytearray ( offset ) , redisprotocol . tobytearray ( count ) , keyword . withscores . raw ) ; }	Zrange by score with scores.
public void slaveofnoone ( ) { sendcommand ( command . slaveof , keyword . no . raw , keyword . one . raw ) ; }	Slaveof no one.
public void configset ( final byte [ ] parameter , final byte [ ] value ) { sendcommand ( command . config , keyword . set . raw , parameter , value ) ; }	Config set.
public void getbit ( byte [ ] key , long offset ) { sendcommand ( command . getbit , key , redisprotocol . tobytearray ( offset ) ) ; }	Gets the bit.
public void getrange ( byte [ ] key , long startoffset , long endoffset ) { sendcommand ( command . getrange , key , redisprotocol . tobytearray ( startoffset ) , redisprotocol . tobytearray ( endoffset ) ) ; }	Gets the range.
public void shutdown ( ) throws ioexception { try { selector . close ( ) ; } catch ( ioexception e ) { logger . error ( str_ , e ) ; throw e ; } }	Shutdown a selector.
public elapsedtime process ( ) { try { long start = system . currenttimemillis ( ) ; ioprocess ( ) ; long iodone = system . currenttimemillis ( ) ; loopprocess ( ) ; long end = system . currenttimemillis ( ) ; return new elapsedtime ( start , iodone , end ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } return null ; }	Main loop of nio.
public void loopprocess ( ) { for ( session session : sessions . values ( ) ) { long timemillis = system . currenttimemillis ( ) ; try { session . callbackonloop ( timemillis ) ; } catch ( exception e ) { logger . error ( str_ , session , e ) ; } } }	to be called on each loop to process idle routines.
public void register ( session session , int ops ) throws closedchannelexception { if ( sessions . containskey ( session . getid ( ) ) ) { throw new illegalstateexception ( str_ ) ; } selectionkey selkey ; try { selkey = session . getchannel ( ) . register ( selector , ops , session ) ; } catch ( closedchannelexception e ) { logger . error ( str_ , session , e ) ; throw e ; } session . setselectionkey ( selkey ) ; }	register session to Selector in order to detect IO events.
public void adddefaultheader ( final string name , final string value ) { validate . notempty ( name , str_ ) ; validate . notnull ( value , str_ ) ; this . checkconfigurable ( ) ; this . defaultheaders . put ( name , value ) ; }	Adds a default header to be added to every stub http response.
public void receivedtimes ( final matcher < integer > nrrequestspredicate ) { validate . notnull ( nrrequestspredicate , str_ ) ; this . requestmanager . evaluateverification ( predicates , nrrequestspredicate ) ; }	Checks whether the number of requests described in this verifying object received so far matches the given predicate.
public string getvalue ( final string key ) { validate . notempty ( key , str_ ) ; final list < string > allvalues = this . getvalues ( key ) ; return allvalues != null ? allvalues . get ( num_ ) : null ; }	Returns the first value for the given key.
public list < string > getvalues ( final string key ) { validate . notempty ( key , str_ ) ; @ suppresswarnings ( str_ ) final list < string > result = ( list < string > ) values . get ( key . tolowercase ( ) ) ; return result == null || result . isempty ( ) ? null : new arraylist < string > ( result ) ; }	Returns all values for the given key.
static void addencoding ( final request . builder builder , final httpexchange httpexchange ) { final string contenttype = httpexchange . getrequestheaders ( ) . getfirst ( str_ ) ; if ( contenttype != null ) { final matcher matcher = charset_pattern . matcher ( contenttype ) ; if ( matcher . matches ( ) ) { try { builder . encoding ( charset . forname ( matcher . group ( num_ ) ) ) ; } catch ( unsupportedcharsetexception e ) {	package protected for testing purposes.
public stubbing createstubbing ( final charset defaultencoding , final int defaultstatus , final multimap defaultheaders ) { return new stubbing ( defaultencoding , defaultstatus , defaultheaders ) ; }	Creates new stubbing instance.
public static string encode ( jsonobject claims , string secret ) { string encodedheader = getcommonheader ( ) ; string encodedclaims = encodejson ( claims ) ; string securebits = new stringbuilder ( encodedheader ) . append ( token_sep ) . append ( encodedclaims ) . tostring ( ) ; string sig = sign ( secret , securebits ) ; return new stringbuilder ( securebits ) . append ( token_sep ) . append ( sig ) . tostring ( ) ; }	Encode and sign a set of claims.
private date copydate ( date date ) { return ( date != null ) ? new date ( date . gettime ( ) ) : null ; }	Copies the date, since Date objects are mutable.
public string createtoken ( map < string , object > data , tokenoptions options ) { if ( ( data == null || data . size ( ) == num_ ) && ( options == null || ( ! options . isadmin ( ) && ! options . isdebug ( ) ) ) ) { throw new illegalargumentexception ( str_ ) ; } jsonobject claims = new jsonobject ( ) ; try { claims . put ( str_ , token_version ) ; claims . put ( str_ , new date ( ) . gettime ( ) / num_ ) ; boolean isadmintoken = ( options != null && options . isadmin ( ) ) ; validatetoken ( str_ , data , isadmintoken ) ; if ( data != null && data . size ( ) > num_ ) { claims . put ( str_ , new jsonobject ( data ) ) ; }	Create a token for the given object and options.
dialog geterrordialog ( int errorcode , int requestcode ) { final dialog dialog = googleapiavailability . getinstance ( ) . geterrordialog ( activity , errorcode , requestcode ) ; dialog . setondismisslistener ( new dialoginterface . ondismisslistener ( ) { @ override public void ondismiss ( dialoginterface dialoginterface ) { resolvingerror = bool_ ; } } ) ; return dialog ; }	Helper to create a new dialog from an error code.
void connectandrequestgoogleaccount ( int signinrequestcode , int errorresolutionrequestcode ) { if ( client . isconnected ( ) ) { requestgoogleaccount ( signinrequestcode ) ; } else if ( ! client . isconnecting ( ) ) { this . signinrequestcode = signinrequestcode ; this . errorresolutionrequestcode = errorresolutionrequestcode ; client . connect ( ) ; } }	Checks if the Google API Client is connected and tries to request the user Account.
public void logoutandclearstate ( ) { if ( client != null && client . isconnected ( ) ) { logout ( ) ; client . disconnect ( ) ; } activity = null ; client = null ; }	Clears this helper state.
@ override public boolean invalidateifnecessary ( baragonrequest request ) { if ( request . getloadbalancerservice ( ) . getedgecachedomains ( ) . isempty ( ) ) { return bool_ ; } try { boolean allsucceeded = bool_ ; for ( string edgecachedns : request . getloadbalancerservice ( ) . getedgecachedomains ( ) ) { list < cloudflarezone > matchingzones = getcloudflarezone ( edgecachedns ) ; if ( matchingzones . isempty ( ) ) { log . warn ( str_ ) ; return bool_ ; } for ( cloudflarezone matchingzone : matchingzones ) { string zoneid = matchingzone . getid ( ) ; optional < cloudflarednsrecord > matchingdnsrecord = getcloudflarednsrecord ( edgecachedns , zoneid ) ; if ( ! matchingdnsrecord . ispresent ( ) ) { log . warn ( str_ ) ; return bool_ ; } if ( ! matchingdnsrecord . get ( ) . isproxied ( ) ) { log . warn ( str_ , edgecachedns ) ; return bool_ ; } string cachetag = string . format ( edgecacheconfiguration . getintegrationsettings ( ) . get ( str_ ) , request . getloadbalancerservice ( ) . getserviceid ( ) ) ; log . debug ( str_ , matchingdnsrecord . get ( ) . getname ( ) , cachetag ) ; allsucceeded = cf . purgeedgecache ( zoneid , collections . singletonlist ( cachetag ) ) && allsucceeded ; } } return allsucceeded ; } catch ( cloudflareclientexception e ) { log . error ( str_ , request , e ) ; return bool_ ; } }	Invalidation will eventually occur when the TTL expires, so it's not a showstopper if this fails.
public collection < string > getloadbalancergroups ( ) { final string requesturi = string . format ( load_balancer_format , getbaseurl ( ) ) ; return getcollection ( requesturi , str_ , string_collection ) ; }	BaragonService load balancer group actions.
public collection < string > getoccupiedbasepaths ( string loadbalancergroupname ) { final string requesturi = string . format ( load_balancer_all_base_paths_format , getbaseurl ( ) , loadbalancergroupname ) ; return getcollection ( requesturi , str_ , string_collection ) ; }	BaragonService base path actions.
public collection < queuedrequestid > getqueuedrequests ( ) { final string uri = string . format ( request_format , getbaseurl ( ) ) ; return getcollection ( uri , str_ , queued_request_collection ) ; }	BaragonService queued request actions.
private void guaranteeregistered ( trafficsource trafficsource , targetgroup targetgroup , collection < targetdescription > targets , collection < baragonagentmetadata > baragonagents , collection < loadbalancer > loadbalancers ) { if ( configuration . ispresent ( ) && configuration . get ( ) . ischeckforcorrectvpc ( ) ) { guaranteesamevpc ( targetgroup , baragonagents , loadbalancers ) ; } guaranteeazenabled ( baragonagents , loadbalancers ) ; guaranteehasalltargets ( trafficsource , targetgroup , targets , baragonagents ) ;	Ensure that the given baragon agent is attached to the given target group.
private void deregisterremovabletargets ( trafficsource trafficsource , baragongroup baragongroup , targetgroup targetgroup , collection < baragonagentmetadata > agents , collection < targetdescription > targets ) { collection < targetdescription > removabletargets = listremovabletargets ( trafficsource , baragongroup , targets , agents ) ; for ( targetdescription removabletarget : removabletargets ) { try { if ( configuration . ispresent ( ) && ! configuration . get ( ) . isremovelasthealthyenabled ( ) && islasthealthyinstance ( removabletarget , targetgroup ) ) { log . info ( str_ , removabletarget , targetgroup ) ; } else { elbclient . deregistertargets ( new deregistertargetsrequest ( ) . withtargetgrouparn ( targetgroup . gettargetgrouparn ( ) ) . withtargets ( removabletarget ) ) ; log . info ( str_ , removabletarget , targetgroup ) ; } } catch ( amazonclientexception acexn ) { log . error ( str_ , removabletarget , targetgroup , acexn ) ; exceptionnotifier . notify ( acexn , immutablemap . of ( str_ , targetgroup . gettargetgroupname ( ) ) ) ; } } }	De-register any targets representing agents that are not known to the BaragonService,or which otherwise need to be removed.
private void guaranteesamevpc ( targetgroup targetgroup , collection < baragonagentmetadata > agents , collection < loadbalancer > loadbalancers ) { string vpcid = targetgroup . getvpcid ( ) ; for ( baragonagentmetadata agent : agents ) { if ( agent . getec2 ( ) . getvpcid ( ) . ispresent ( ) ) { if ( ! agent . getec2 ( ) . getvpcid ( ) . get ( ) . equals ( vpcid ) ) { log . error ( str_ , agent , targetgroup ) ; throw new illegalstateexception ( string . format ( str_ , agent , targetgroup ) ) ; } } else { log . error ( str_ , agent ) ; throw new illegalstateexception ( string . format ( str_ , agent ) ) ; } } for ( loadbalancer loadbalancer : loadbalancers ) { if ( ! vpcid . equals ( loadbalancer . getvpcid ( ) ) ) { log . error ( str_ , loadbalancer , targetgroup ) ; throw new illegalstateexception ( string . format ( str_ , loadbalancer , targetgroup ) ) ; } } }	When this method completes, the target group, the agents, and the loadBalancers areall on the same VPC.The target group, each of the agents, and each of the load balancers should thinkthat they are on the same VPC, otherwise they won't be able to talk to each other.
public void sethref ( string href ) { if ( href . contains ( str_ ) ) { try { href = urldecoder . decode ( href , str_ ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } } this . href = new uritemplate ( href ) ; }	backwards compatibility, would be canged in next version.
static memberkey newinstance ( object contextobject , string name ) { if ( contextobject instanceof class < ? > ) { class < ? > clazz = ( class < ? > ) contextobject ; if ( clazz . isenum ( ) && ( str_ . equals ( name ) || reflections . isconstantname ( clazz , name ) ) ) {	Simple factory method to obtain a new instance for the given contextobject and name.
private void lineseparatorfound ( string lineseparator ) { flushtext ( ) ; flushlineseparator ( lineseparator ) ; line ++ ; state = state . text ; separatoridx = num_ ; }	Line separator end - flush.
private void flushtag ( ) { state = state . text ; handler . tag ( derivetag ( buffer . tostring ( ) ) ) ; delimiteridx = num_ ; clearbuffer ( ) ; }	Real tag end - flush.
private string extractcontent ( mustachetagtype tagtype , string buffer ) { switch ( tagtype ) { case variable : return buffer . trim ( ) ; case unescape_variable : return ( buffer . charat ( num_ ) == ( ( string ) engineconfigurationkey . start_delimiter . getdefaultvalue ( ) ) . charat ( num_ ) ? buffer . substring ( num_ , buffer . length ( ) - num_ ) . trim ( ) : buffer . substring ( num_ ) . trim ( ) ) ; case section : case inverted_section : case partial : case extend : case extend_section : case section_end : case nested_template : case comment : return buffer . substring ( num_ ) . trim ( ) ; case delimiter : return buffer . trim ( ) ; default : return null ; } }	Extract the tag content.
private static list < list < segmentbase > > readsegmentlines ( containersegmentbase container ) { list < list < segmentbase > > lines = new arraylist < > ( ) ;	Read segment lines recursively.
public static pattern newmustachetagpattern ( configuration configuration ) { stringbuilder regex = new stringbuilder ( ) ; regex . append ( pattern . quote ( configuration . getstringpropertyvalue ( engineconfigurationkey . start_delimiter ) ) ) ; regex . append ( str_ ) ; regex . append ( pattern . quote ( configuration . getstringpropertyvalue ( engineconfigurationkey . end_delimiter ) ) ) ; return pattern . compile ( regex . tostring ( ) ) ; }	Delimiters are quoted to avoid regexp reserved characters conflict.
public static < t > decorator < t > decorate ( t delegate , map < string , function < t , object > > mappings , string delegatekey , configuration configuration ) { return iterabledecorator . isiterable ( delegate ) ? new iterabledecorator < > ( delegate , immutablemap . copyof ( mappings ) , delegatekey , configuration ) : new decorator < > ( delegate , immutablemap . copyof ( mappings ) , delegatekey , configuration ) ; }	Returns a decorator instance for the specified delegate and mappings.
@ suppresswarnings ( str_ ) public static < t > t unwrap ( t instance ) { return instance instanceof decorator ? unwrap ( ( ( decorator < t > ) instance ) . delegate ) : instance ; }	This method is recursive.
public synchronized mustacheengine build ( ) { mustacheengine engine = new defaultmustacheengine ( this ) ; for ( enginebuiltcallback callback : enginereadycallbacks ) { callback . enginebuilt ( engine ) ; } buildinfo buildinfo = buildinfo . load ( ) ; logger . info ( str_ , buildinfo . getversion ( ) , buildinfo . gettimestampdate ( ) ) ; logger . debug ( str_ , engine . getconfiguration ( ) . getinfo ( ) ) ; isbuilt = bool_ ; return engine ; }	Builds the engine instance.
public mustacheenginebuilder addtemplatelocator ( templatelocator locator ) { checkargumentnotnull ( locator ) ; checknotbuilt ( ) ; this . templatelocators . add ( locator ) ; return this ; }	Adds a template locator.
public mustacheenginebuilder addresolver ( resolver resolver ) { checkargumentnotnull ( resolver ) ; checknotbuilt ( ) ; this . resolvers . add ( resolver ) ; return this ; }	Adds a value resolver.
public mustacheenginebuilder registercallback ( enginebuiltcallback callback ) { checkargumentnotnull ( callback ) ; checknotbuilt ( ) ; this . enginereadycallbacks . add ( callback ) ; return this ; }	Callback is useful to configure a component instantiated before theengine is built.
public mustacheenginebuilder addvalueconverter ( valueconverter converter ) { checkargumentnotnull ( converter ) ; checknotbuilt ( ) ; this . valueconverters . add ( converter ) ; return this ; }	Add a value converter.
public mustacheenginebuilder addcontextconverter ( contextconverter converter ) { checkargumentnotnull ( converter ) ; checknotbuilt ( ) ; this . contextconverters . add ( converter ) ; return this ; }	Add a context converter.
public static string capitalizefully ( string text , character delimiter ) { if ( isempty ( text ) ) { return text ; } text = text . tolowercase ( ) ; boolean capitalizenext = bool_ ; stringbuilder builder = new stringbuilder ( ) ; for ( int i = num_ ; i < text . length ( ) ; i ++ ) { final char ch = text . charat ( i ) ; if ( delimiter . equals ( ch ) ) { capitalizenext = bool_ ; builder . append ( ch ) ; } else if ( capitalizenext ) { builder . append ( character . totitlecase ( ch ) ) ; capitalizenext = bool_ ; } else { builder . append ( ch ) ; } } return builder . tostring ( ) ; }	Capitalizes all the delimiter separated words.
protected void append ( options options , charsequence sequence ) { textsupport textsupport = this . textsupport ; if ( textsupport == null || isunescapevariable ( options ) ) { options . append ( sequence ) ; } else { try { textsupport . appendescapedhtml ( sequence . tostring ( ) , options . getappendable ( ) ) ; } catch ( ioexception e ) { throw new mustacheexception ( mustacheproblem . render_io_error , e ) ; } } }	Escape appended sequence if needed.
private computingcache < string , optional < string > > buildsourcecache ( ) { return buildcache ( str_ , key -> optional . ofnullable ( locateandread ( key ) ) , ( key , cause ) -> logger . debug ( str_ , key , cause ) ) ; }	Properties of the source cache are dependent on that of the templatecache.
private void push ( containersegmentbase container ) { containerstack . addfirst ( container ) ; logger . trace ( str_ , container . gettype ( ) , container . getcontent ( ) ) ; }	Push the container wrapper on the stack.
private void addsegment ( segmentbase segment ) { containerstack . peekfirst ( ) . addsegment ( segment ) ; logger . trace ( str_ , segment ) ; }	Add the segment to the container on the stack.
private rootsegmentbase validate ( ) { containersegmentbase root = containerstack . peekfirst ( ) ; if ( ! ( root instanceof rootsegmentbase ) ) { throw new mustacheexception ( mustacheproblem . compile_invalid_template , str_ , containerstack . peekfirst ( ) . tostring ( ) , line ) ; } return ( rootsegmentbase ) root ; }	Validate the compiled template.
static iterator < string > splithelpername ( string name , segment segment ) { boolean stringliteral = bool_ ; boolean arrayliteral = bool_ ; boolean space = bool_ ; list < string > parts = new arraylist < > ( ) ; stringbuilder buffer = new stringbuilder ( ) ; for ( int i = num_ ; i < name . length ( ) ; i ++ ) { if ( name . charat ( i ) == str_ ) { if ( ! space ) { if ( ! stringliteral && ! arrayliteral ) { if ( buffer . length ( ) > num_ ) { parts . add ( buffer . tostring ( ) ) ; buffer = new stringbuilder ( ) ; } space = bool_ ; } else { buffer . append ( name . charat ( i ) ) ; } } } else { if ( ! arrayliteral && strings . isstringliteralseparator ( name . charat ( i ) ) ) { stringliteral = ! stringliteral ; } else if ( ! stringliteral && strings . islistliteralstart ( name . charat ( i ) ) ) { arrayliteral = bool_ ; } else if ( ! stringliteral && strings . islistliteralend ( name . charat ( i ) ) ) { arrayliteral = bool_ ; } space = bool_ ; buffer . append ( name . charat ( i ) ) ; } } if ( buffer . length ( ) > num_ ) { if ( stringliteral || arrayliteral ) { throw new mustacheexception ( mustacheproblem . compile_helper_validation_failure , str_ , segment ) ; } parts . add ( buffer . tostring ( ) ) ; } return parts . iterator ( ) ; }	Extracts parts from an input string.
public static < t > builder < t > decorate ( class < t > delegatetype ) { return decorate ( o -> ( delegatetype . isassignablefrom ( decorator . unwrap ( o ) . getclass ( ) ) ) ) ; }	Returns a decorator converter builder for the specified delegate type.
private void flush ( ) { try { parent . append ( future . get ( num_ , timeunit . seconds ) . collect ( this ) ) ; parent . append ( buffer ) ; if ( parent instanceof asyncappendable ) { ( ( asyncappendable ) parent ) . flush ( ) ; } } catch ( exception e ) { throw new mustacheexception ( mustacheproblem . render_async_processing_error , e ) ; } }	Append the result to the parent.
static field findfield ( class < ? > clazz , string name ) { checkargumentnotnull ( clazz ) ; checkargumentnotnull ( name ) ; field found = null ; for ( field field : securityactions . getfields ( clazz ) ) { if ( field . getname ( ) . equals ( name ) ) { found = field ; } } logger . debug ( str_ , name , found != null ? str_ : str_ , clazz . getname ( ) ) ; return found ; }	Tries to find a public field with the given name on the given class.
public static void registerhelpers ( configurationextensionbuilder builder , map < string , helper > helpers ) { checker . checkargumentsnotnull ( builder , helpers ) ; for ( entry < string , helper > entry : helpers . entryset ( ) ) { registerhelper ( builder , entry . getkey ( ) , entry . getvalue ( ) ) ; } }	Register helper and do nothing if a helper with the same name is already registered.
public static void registerhelper ( configurationextensionbuilder builder , string name , helper helper ) { checker . checkargumentsnotnull ( builder , name , helper ) ; try { builder . registerhelper ( name , helper ) ; } catch ( illegalargumentexception ignored ) { } }	Register helpers and do nothing if a helper with the same name is already registered.
static list < list < segment > > readsegmentlinesbeforerendering ( abstractcontainersegment container ) { list < list < segment > > lines = new arraylist < > ( ) ; list < segment > currentline = new arraylist < > ( ) ; for ( segment segment : container ) { if ( ! segmenttype . line_separator . equals ( segment . gettype ( ) ) ) { currentline . add ( segment ) ; } else {	Read segment lines before rendering.
public void invalidatefragments ( final string keypart ) { if ( fragments == null || keypart == null ) { return ; } fragments . invalidate ( fragmentkey -> fragmentkey . getkey ( ) . contains ( keypart ) ) ; }	Invalidate the cache fragments whose key contains the given part of thekey.
public static storageext getlocalstorage ( ) { if ( localstorage == null && storage . islocalstoragesupported ( ) ) { localstorage = new storageext ( storage . getlocalstorageifsupported ( ) ) ; } return localstorage ; }	Returns a Local Storage.
public static storageext getsessionstorage ( ) { if ( sessionstorage == null && storage . issessionstoragesupported ( ) ) { sessionstorage = new storageext ( storage . getsessionstorageifsupported ( ) ) ; } return sessionstorage ; }	Returns a Session Storage.
public void clear ( ) { storage . clear ( ) ; cache . clear ( ) ; fireevent ( storagechangeevent . changetype . clear , null , null , null , null , null ) ; }	Removes all items in the Storage, and its cache if activated.
public < t > boolean containskey ( storagekey < t > key ) { return storage . getitem ( key . name ( ) ) != null ; }	Test if this storage contains a value for the specified key. {.
public < t > void put ( storagekey < t > key , t value ) throws serializationexception , storagequotaexceededexception { if ( value == null ) { throw new nullpointerexception ( ) ; } try { string data = storageutils . serialize ( key . getclazz ( ) , value ) ;	Store the specified value with the specified key in this storage.
public < t extends serializable > void remove ( storagekey < t > key ) { string data = storage . getitem ( key . name ( ) ) ; storage . removeitem ( key . name ( ) ) ; t value = cache . remove ( key ) ; fireevent ( storagechangeevent . changetype . remove , key , null , value , null , data ) ; }	Removes the record for the specified key from this storage if present. {.
@ deprecated public static < t > storagekey < t > objectkey ( string keyname ) { return new storagekey < > ( keyname , object . class ) ; }	Returns non-primitive type value's storage key.
public static < t extends isserializable > storagekey < t > isserializablekey ( string keyname ) { return new storagekey < > ( keyname , isserializable . class ) ; }	Returns IsSerializable type value's storage key.
public static < t extends serializable > storagekey < t > serializablekey ( string keyname ) { return new storagekey < > ( keyname , serializable . class ) ; }	Returns Serializable type value's storage key.
private void obtainsize ( @ nonnull final typedarray typedarray ) { size defaultsize = size . normal ; size = size . fromvalue ( typedarray . getint ( r . styleable . floatingactionbutton_size , defaultsize . getvalue ( ) ) ) ; }	Obtains the floating action button's size from a specific typed array.
private void obtaincolor ( @ nonnull final typedarray typedarray ) { int defaultcolor = themeutil . getcolor ( getcontext ( ) , r . attr . coloraccent ) ; color = typedarray . getcolor ( r . styleable . floatingactionbutton_android_color , defaultcolor ) ; }	Obtains the floating action button's color from a specific typed array.
private void obtainactivatedcolor ( @ nonnull final typedarray typedarray ) { int defaultactivatedcolor = getcontrolactivatedcolor ( ) ; activatedcolor = typedarray . getcolor ( r . styleable . floatingactionbutton_activatedcolor , defaultactivatedcolor ) ; }	Obtains the floating action button's activated color from a specific typed array.
private void obtainpressedcolor ( @ nonnull final typedarray typedarray ) { int defaultpressedcolor = getcontrolhighlightcolor ( ) ; pressedcolor = typedarray . getcolor ( r . styleable . floatingactionbutton_pressedcolor , defaultpressedcolor ) ; }	Obtains the floating action button's pressed color from a specific typed array.
private void obtaindisabledcolor ( @ nonnull final typedarray typedarray ) { int defaultdisabledcolor = contextcompat . getcolor ( getcontext ( ) , r . color . floating_action_button_disabled_color ) ; disabledcolor = typedarray . getcolor ( r . styleable . floatingactionbutton_disabledcolor , defaultdisabledcolor ) ; }	Obtains the floating action button's disabled color from a specific typed array.
private void obtainicon ( @ nonnull final typedarray typedarray ) { drawable icon = typedarray . getdrawable ( r . styleable . floatingactionbutton_android_icon ) ; seticon ( icon ) ; }	Obtains the floating action button's icon from a specific typed array.
private void obtainvisibilityanimationduration ( @ nonnull final typedarray typedarray ) { int defaultanimationduration = getresources ( ) . getinteger ( r . integer . floating_action_button_visibility_animation_duration ) ; int duration = typedarray . getinteger ( r . styleable . floatingactionbutton_visibilityanimationduration , defaultanimationduration ) ; setvisibilityanimationduration ( duration ) ; }	Obtains the duration of the animation, which may be used to changed the visibility of thefloating action button, from a specific typed array.
private void adaptshadow ( ) { if ( getsize ( ) == size . normal ) { setbackgroundresource ( r . drawable . floating_action_button_shadow_normal ) ; } else if ( getsize ( ) == size . small ) { setbackgroundresource ( r . drawable . floating_action_button_shadow_small ) ; } else { setbackgroundresource ( r . drawable . floating_action_button_shadow_large ) ; } }	Adapts the shadow of the floating action button, depending on its size.
private void adaptimagebuttonsize ( ) { int pixelsize = getpixelsize ( ) ; layoutparams layoutparams = ( layoutparams ) imagebutton . getlayoutparams ( ) ; layoutparams . width = pixelsize ; layoutparams . height = pixelsize ; imagebutton . setlayoutparams ( layoutparams ) ; imagebutton . requestlayout ( ) ; }	Adapts the size of the image button, which is used to show the floating image button'sbackground and icon, depending on the floating button's size.
@ suppresslint ( str_ ) private void adaptimagebuttonbackground ( ) { drawable background = createstatelistbackgrounddrawable ( ) ; if ( build . version . sdk_int >= build . version_codes . lollipop ) { drawable rippledrawable = new rippledrawable ( new colorstatelist ( new int [ ] [ ] { { } } , new int [ ] { getpressedcolor ( ) } ) , background , null ) ; viewutil . setbackground ( imagebutton , rippledrawable ) ; } else { viewutil . setbackground ( imagebutton , background ) ; } }	Adapts the background of the image button, which is used to show the floating image button'sbackground and icon, depending on the floating button's colors.
private drawable createstatelistbackgrounddrawable ( ) { statelistdrawable drawable = new statelistdrawable ( ) ; if ( build . version . sdk_int < build . version_codes . lollipop ) { drawable . addstate ( new int [ ] { android . r . attr . state_enabled , android . r . attr . state_pressed } , createpressedbackgrounddrawable ( ) ) ; } drawable . addstate ( new int [ ] { android . r . attr . state_enabled , android . r . attr . state_activated } , createactivatedbackgrounddrawable ( ) ) ; drawable . addstate ( new int [ ] { android . r . attr . state_enabled } , createbackgrounddrawable ( getcolor ( ) ) ) ; drawable . addstate ( new int [ ] { } , createdisabledbackgrounddrawable ( ) ) ; return drawable ; }	Creates and returns a state list drawable, which can be used as the floating action buttonbackground and adapts the background color depending on the button's current state.
private drawable createactivatedbackgrounddrawable ( ) { drawable drawable = createbackgrounddrawable ( getcolor ( ) ) ; drawable hoverdrawable = createbackgrounddrawable ( getactivatedcolor ( ) ) ; return new layerdrawable ( new drawable [ ] { drawable , hoverdrawable } ) ; }	Creates and returns a drawable, which can be used as the floating action button's background,when it is activated.
private drawable createpressedbackgrounddrawable ( ) { drawable drawable = createbackgrounddrawable ( getcolor ( ) ) ; drawable hoverdrawable = createbackgrounddrawable ( getpressedcolor ( ) ) ; return new layerdrawable ( new drawable [ ] { drawable , hoverdrawable } ) ; }	Creates and returns a drawable, which can be used as the floating action button's background,when it is pressed.
private drawable createdisabledbackgrounddrawable ( ) { drawable drawable = createbackgrounddrawable ( getcolor ( ) ) ; drawable hoverdrawable = createbackgrounddrawable ( getdisabledcolor ( ) ) ; return new layerdrawable ( new drawable [ ] { drawable , hoverdrawable } ) ; }	Creates and returns a drawable, which can be used as the floating action button's background,when it is disabled.
private drawable createbackgrounddrawable ( @ colorint final int color ) { ovalshape shape = new ovalshape ( ) ; shapedrawable drawable = new shapedrawable ( shape ) ; drawable . getpaint ( ) . setcolor ( color ) ; return drawable ; }	Creates and returns a drawable with a specific color, which can be used as the floatingaction button's background.
private int getpixelsize ( ) { if ( getsize ( ) == size . normal ) { return getresources ( ) . getdimensionpixelsize ( r . dimen . floating_action_button_size_normal ) ; } else if ( getsize ( ) == size . small ) { return getresources ( ) . getdimensionpixelsize ( r . dimen . floating_action_button_size_small ) ; } else { return getresources ( ) . getdimensionpixelsize ( r . dimen . floating_action_button_size_large ) ; } }	Returns the size of the floating action button in pixels, depending on its current size.
private void animatevisibility ( final int visibility , final long duration ) { if ( visibilityanimator != null ) { visibilityanimator . cancel ( ) ; } animatorlistener listener = createvisibilityanimatorlistener ( visibility ) ; float targetscale = visibility == view . visible ? num_ : num_ ; long animationduration = math . round ( math . abs ( getscalex ( ) - targetscale ) * duration ) ; interpolator interpolator = new acceleratedecelerateinterpolator ( ) ; visibilityanimator = animate ( ) . setinterpolator ( interpolator ) . scalex ( targetscale ) . scaley ( targetscale ) . setduration ( animationduration ) . setlistener ( listener ) ; }	Animates changing the visibility of the floating action button.
private animatorlistener createvisibilityanimatorlistener ( final int visibility ) { return new animatorlistener ( ) { @ override public void onanimationstart ( final animator animation ) { if ( visibility == view . visible ) { floatingactionbutton . super . setvisibility ( visibility ) ; } } @ override public void onanimationrepeat ( final animator animation ) { } @ override public void onanimationend ( final animator animation ) { floatingactionbutton . super . setvisibility ( visibility ) ; visibilityanimator = null ; } @ override public void onanimationcancel ( final animator animation ) { visibilityanimator = null ; } } ; }	Creates and returns a listener, which allows to adapt the visibility of the floating actionbutton, depending on the progress of an animation, which is used to change the visibility.
public final void setsize ( @ nonnull final size size ) { condition . instance . ensurenotnull ( size , str_ ) ; this . size = size ; adaptshadow ( ) ; adaptimagebuttonsize ( ) ; requestlayout ( ) ; }	Sets the floating action button's size.
private void obtainthickness ( @ nonnull final typedarray typedarray ) { int defaultthickness = getcontext ( ) . getresources ( ) . getdimensionpixelsize ( r . dimen . circular_progress_bar_thickness_normal ) ; thickness = typedarray . getdimensionpixelsize ( r . styleable . circularprogressbar_android_thickness , defaultthickness ) ; }	Obtains the progress bar's thickness from a specific typed array.
private void initializepaint ( ) { paint = new paint ( ) ; paint . setantialias ( bool_ ) ; paint . setstyle ( paint . style . stroke ) ; paint . setstrokewidth ( getthickness ( ) ) ; paint . setcolor ( getcolor ( ) ) ; }	Initializes the paint, which is used for drawing.
private void initializeangleanimator ( ) { angleanimator = objectanimator . offloat ( this , createangleproperty ( ) , max_degrees ) ; angleanimator . setinterpolator ( new linearinterpolator ( ) ) ; angleanimator . setduration ( angle_animation_duration ) ; angleanimator . setrepeatmode ( valueanimator . restart ) ; angleanimator . setrepeatcount ( valueanimator . infinite ) ; }	Initializes the angle animator.
private property < circularprogressdrawable , float > createangleproperty ( ) { return new property < circularprogressdrawable , float > ( float . class , str_ ) { @ override public float get ( final circularprogressdrawable object ) { return currentglobalangle ; } @ override public void set ( final circularprogressdrawable object , final float value ) { currentglobalangle = value ; invalidateself ( ) ; } } ; }	Creates and returns a property, which allows to animate the global angle of the progressdrawable.
private void initializesweepanimator ( ) { sweepanimator = objectanimator . offloat ( this , createsweepproperty ( ) , max_degrees - min_sweep_angle * num_ ) ; sweepanimator . setinterpolator ( new decelerateinterpolator ( ) ) ; sweepanimator . setduration ( sweep_animation_duration ) ; sweepanimator . setrepeatmode ( valueanimator . restart ) ; sweepanimator . setrepeatcount ( valueanimator . infinite ) ; sweepanimator . addlistener ( createsweepanimatorlistener ( ) ) ; }	Initializes the sweep animator.
private property < circularprogressdrawable , float > createsweepproperty ( ) { return new property < circularprogressdrawable , float > ( float . class , str_ ) { @ override public float get ( final circularprogressdrawable object ) { return currentsweepangle ; } @ override public void set ( final circularprogressdrawable object , final float value ) { currentsweepangle = value ; invalidateself ( ) ; } } ; }	Creates and returns a property, which allows to animate the sweep angle of the progressdrawable.
private animatorlistener createsweepanimatorlistener ( ) { return new animatorlistener ( ) { @ override public void onanimationstart ( final animator animation ) { } @ override public void onanimationend ( final animator animation ) { } @ override public void onanimationcancel ( final animator animation ) { } @ override public void onanimationrepeat ( final animator animation ) { appearing = ! appearing ; if ( appearing ) { currentglobalangleoffset = ( currentglobalangleoffset + min_sweep_angle * num_ ) % max_degrees ; } } } ; }	Creates and returns a listener, which allows to restart the progress drawable's animation,when it has been finished.
private void initializefloatingactionbuttons ( ) { smallfloatingactionbutton = findviewbyid ( r . id . floating_action_button_small ) ; smallfloatingactionbutton . setonclicklistener ( createfloatingactionbuttonlistener ( ) ) ; normalfloatingactionbutton = findviewbyid ( r . id . floating_action_button_normal ) ; normalfloatingactionbutton . setonclicklistener ( createfloatingactionbuttonlistener ( ) ) ; largefloatingactionbutton = findviewbyid ( r . id . floating_action_button_large ) ; largefloatingactionbutton . setonclicklistener ( createfloatingactionbuttonlistener ( ) ) ; }	Initializes the floating action buttons.
private onclicklistener createfloatingactionbuttonlistener ( ) { return new onclicklistener ( ) { @ override public void onclick ( final view v ) { toast toast = toast . maketext ( mainactivity . this , r . string . floating_action_button_toast , toast . length_short ) ; toast . show ( ) ; } } ; }	Creates and returns a listener, which allows to show a toast when a floating action buttonhas been clicked.
private void initializehidefloatingactionbuttonsbutton ( ) { button button = findviewbyid ( r . id . hide_floating_action_buttons ) ; button . setonclicklistener ( createhidefloatingactionbuttonslistener ( ) ) ; }	Initializes the button, which allows to show or hide the floating action buttons.
private onclicklistener createhidefloatingactionbuttonslistener ( ) { return new onclicklistener ( ) { @ override public void onclick ( final view v ) { int visibility = floatingactionbuttonsvisible ? view . invisible : view . visible ; smallfloatingactionbutton . setvisibility ( visibility , bool_ ) ; normalfloatingactionbutton . setvisibility ( visibility , bool_ ) ; largefloatingactionbutton . setvisibility ( visibility , bool_ ) ; floatingactionbuttonsvisible = ! floatingactionbuttonsvisible ; } } ; }	Creates and returns a listener, which allows to show or hide the floating action buttons.
private void initializechips ( ) { chip closablechiplight = findviewbyid ( r . id . chip_closable_light ) ; closablechiplight . addcloselistener ( createchipcloselistener ( ) ) ; chip closablechipdark = findviewbyid ( r . id . chip_closable_dark ) ; closablechipdark . addcloselistener ( createchipcloselistener ( ) ) ; chip closableiconchiplight = findviewbyid ( r . id . chip_icon_closable_light ) ; closableiconchiplight . addcloselistener ( createchipcloselistener ( ) ) ; chip closableiconchipdark = findviewbyid ( r . id . chip_icon_closable_dark ) ; closableiconchipdark . addcloselistener ( createchipcloselistener ( ) ) ; }	Initializes all closable chips.
private chip . closelistener createchipcloselistener ( ) { return new chip . closelistener ( ) { @ override public void onchipclosed ( @ nonnull final chip chip ) { chip . setvisibility ( view . gone ) ; toast . maketext ( mainactivity . this , r . string . chip_closed_toast , toast . length_short ) . show ( ) ; } } ; }	Creates and returns a listener, which allows to show a toast, when a chip has been closed.
private void handlesavedinstancestate ( @ nullable final bundle savedinstancestate ) { if ( savedinstancestate != null ) { floatingactionbuttonsvisible = savedinstancestate . getboolean ( floating_action_buttons_visible_extra ) ; int visibility = floatingactionbuttonsvisible ? view . visible : view . invisible ; smallfloatingactionbutton . setvisibility ( visibility ) ; normalfloatingactionbutton . setvisibility ( visibility ) ; largefloatingactionbutton . setvisibility ( visibility ) ; } }	Adapts the activity's views depending on the saved instance state, which has been passed tothe activity.
private void obtaintext ( @ nonnull final typedarray typedarray ) { settext ( typedarray . gettext ( r . styleable . chip_android_text ) ) ; }	Obtains the chip's text from a specific typed array.
private void obtaintextcolor ( @ nonnull final typedarray typedarray ) { int defaultcolor = contextcompat . getcolor ( getcontext ( ) , r . color . chip_text_color_light ) ; settextcolor ( typedarray . getcolor ( r . styleable . chip_android_textcolor , defaultcolor ) ) ; }	Obtains the chip's text color from a specific typed array.
private void obtaincolor ( @ nonnull final typedarray typedarray ) { int defaultcolor = contextcompat . getcolor ( getcontext ( ) , r . color . chip_color_light ) ; setcolor ( typedarray . getcolor ( r . styleable . chip_android_color , defaultcolor ) ) ; }	Obtains the chip's color from a specific typed array.
private void obtainicon ( @ nonnull final typedarray typedarray ) { seticon ( typedarray . getdrawable ( r . styleable . chip_android_icon ) ) ; }	Obtains the chip's icon from a specific typed array.
private void obtainclosable ( @ nonnull final typedarray typedarray ) { setclosable ( typedarray . getboolean ( r . styleable . chip_closable , bool_ ) ) ; }	Obtains, whether the chip should be closable, or not, from a specific typed array.
private void obtaincloseicon ( @ nonnull final typedarray typedarray ) { drawable icon = typedarray . getdrawable ( r . styleable . chip_closebuttonicon ) ; if ( icon != null ) { setclosebuttonicon ( icon ) ; } }	Obtains the icon of the button, which allows to close the chip, from a specific typed array.
public final void addcloselistener ( @ nonnull final closelistener listener ) { condition . instance . ensurenotnull ( listener , str_ ) ; listeners . add ( listener ) ; }	Adds a new listener, which should be notified, when the chip has been closed.
public final void removecloselistener ( @ nonnull final closelistener listener ) { condition . instance . ensurenotnull ( listener , str_ ) ; listeners . remove ( listener ) ; }	Removes a specific listener, which should not be notified, when the chip has been closed,anymore.
public final void setcolor ( @ colorint final int color ) { this . color = color ; getbackground ( ) . setcolorfilter ( color , porterduff . mode . src_in ) ; }	Sets the chip's color.
public final void setclosable ( final boolean closable ) { this . closable = closable ; if ( closable ) { closebutton . setvisibility ( view . visible ) ; textview . setpadding ( textview . getpaddingleft ( ) , textview . getpaddingtop ( ) , num_ , textview . getpaddingbottom ( ) ) ; } else { closebutton . setvisibility ( view . gone ) ; textview . setpadding ( textview . getpaddingleft ( ) , textview . getpaddingtop ( ) , getresources ( ) . getdimensionpixelsize ( r . dimen . chip_horizontal_padding ) , textview . getpaddingbottom ( ) ) ; } }	Sets, whether the chip is closable, or not.
@ suppresswarnings ( str_ ) public map < string , string > getpartials ( ) { final view view = this . getview ( ) ; if ( view != null && view instanceof mustacheview ) { mustacheview mustacheview = ( mustacheview ) view ; return mustacheview . getaliases ( ) ; } else { final object object = getmodelmap ( ) . get ( mustachesettings . partials_key ) ; if ( object != null && ! ( object instanceof map ) ) { throw new mustachepartialsmappingexception ( ) ; } final map < string , string > map ; if ( object == null ) { map = new hashmap < string , string > ( ) ; } else { map = ( map < string , string > ) object ; } return map ; } }	Get current partials stored in view.
public static scriptengine getengine ( collection < inputstream > scripts ) { scriptengine engine = getengine ( ) ; for ( inputstream script : scripts ) { evaluate ( engine , script ) ; } return engine ; }	Get new nashorn engine.
public map < string , string > getlayoutmappings ( ) { string mappingsvalues = environment . getproperty ( str_ , mustachesettings . layout_mappings ) . trim ( ) ; if ( mappingsvalues . isempty ( ) ) { return emptymap ( ) ; } map < string , string > mappings = new hashmap < string , string > ( ) ; string [ ] values = mappingsvalues . split ( str_ ) ; if ( values . length > num_ ) { for ( string value : values ) { string val = value == null ? str_ : value . trim ( ) ; if ( val . isempty ( ) ) { continue ; } string [ ] mapping = val . split ( str_ ) ; if ( mapping . length != num_ ) { throw new illegalargumentexception ( str_ ) ; } mappings . put ( mapping [ num_ ] . trim ( ) , mapping [ num_ ] . trim ( ) ) ; } } return unmodifiablemap ( mappings ) ; }	Get mappings to use with resolvers.
public static boolean ispresent ( string klass ) { hastext ( klass , str_ ) ; try { class . forname ( klass ) ; return bool_ ; } catch ( exception ex ) { return bool_ ; } }	Check that a given class is available onclasspath.
@ suppresswarnings ( str_ ) public static < t > t getannotationvalue ( annotationmetadata importingclassmetadata , class annotationclass , string name , t defaultvalue ) { map < string , object > attributes = importingclassmetadata . getannotationattributes ( annotationclass . getname ( ) ) ; return attributes != null && attributes . containskey ( name ) ? ( t ) attributes . get ( name ) : defaultvalue ; }	Get annotation method value.
public static inputstream getstream ( string name ) { resourcepatternresolver resolver = new pathmatchingresourcepatternresolver ( ioutils . class . getclassloader ( ) ) ; inputstream stream = getinputstreamwithresolver ( resolver , name ) ;	Return an input stream from given name.Name is searched into the classpath.Name can contains ant style pattern.
public static inputstream getfirstavailablestream ( collection < string > names ) { resourcepatternresolver resolver = new pathmatchingresourcepatternresolver ( ioutils . class . getclassloader ( ) ) ; for ( string name : names ) { try { inputstream stream = getinputstreamwithresolver ( resolver , name ) ; if ( stream != null ) { return stream ; } } catch ( mustacheioexception ex ) {	Return an input stream from given names.First result returning a valid stream is returned.Names are searched into the classpath.Names can contains ant style pattern.
public string render ( string template , map < string , object > model ) { try { invocable invocable = ( invocable ) engine ; return ( string ) invocable . invokefunction ( str_ , template , model , partials ) ; } catch ( scriptexception ex ) { throw new nashornexception ( ex ) ; } catch ( nosuchmethodexception ex ) { throw new nashornexception ( ex ) ; } }	Render template with given model object.
public void addaliases ( map < string , string > aliases ) { notnull ( aliases , str_ ) ; for ( map . entry < string , string > entry : aliases . entryset ( ) ) { addalias ( entry . getkey ( ) , entry . getvalue ( ) ) ; } }	Add partials mapping.
public void addalias ( string key , string value ) { this . aliases . put ( notnull ( key , str_ ) , notnull ( value , str_ ) ) ; }	Add alias mapping.
@ nonnull public final synchronized chronoslistener getlistener ( final int id ) { chronoslistener chronoslistener = mlisteners . get ( id ) ; if ( chronoslistener == null ) { chronoslistener = new chronoslistener ( id ) ; mlisteners . put ( id , chronoslistener ) ; } return chronoslistener ; }	Gets previously created ServiceConnector by its id.
@ nonnull public static < output > chronosoperationresult < output > run ( @ nonnull final chronosoperation < output > operation ) { return chronosservice . getinstance ( ) . runsync ( operation , bool_ ) ; }	Runs operation synchronously.
@ contract ( pure = bool_ ) private static boolean iscallback ( @ nonnull final method method , @ nonnull final class < ? > resultclass , @ nonnull final string methodname ) { if ( method . getname ( ) . equals ( methodname ) ) { if ( method . getreturntype ( ) == void . type ) { final class < ? > [ ] parameters = method . getparametertypes ( ) ; if ( parameters . length == num_ && parameters [ num_ ] . isassignablefrom ( resultclass ) ) { return bool_ ; } } } return bool_ ; }	Checks if a method can be used as a callback to handle operation result.
public final void onresume ( @ nonnull final object servicelistener ) { logd ( str_ ) ; mservicelistener = servicelistener ; mstate = state . resumed ; if ( ! mstoredresults . isempty ( ) ) { logd ( str_ ) ; final list < softreference < operationdelivery < ? > > > oldresults = new arraylist < > ( mstoredresults ) ; mstoredresults . clear ( ) ; for ( softreference < operationdelivery < ? > > result : oldresults ) { final operationdelivery < ? > delivery = result . get ( ) ; if ( delivery != null ) { deliverresult ( delivery ) ; } } logd ( str_ ) ; } else { logd ( str_ ) ; } }	This method must be called by a bound GUI element when it passes its own onResume state.
@ suppresswarnings ( str_ ) public final void oneventmainthread ( @ nullable final chronosoperationresult < ? > operationresult ) { if ( operationresult == null ) {	This method is used to listening to results stream and operate with them.
public final int invoke ( @ nonnull final chronosoperation < ? > operation , final boolean broadcastresult ) { logd ( str_ ) ; final int id = chronosservice . getinstance ( ) . runasync ( operation , broadcastresult ) ; muntaggedrequests . add ( id ) ; return id ; }	Launches an operation in background thread.
public final int invoke ( @ nonnull final chronosoperation < ? > operation , @ nonnull final string tag , final boolean broadcastresult ) { logd ( str_ + tag ) ; final integer savedid = mtaggedrequests . get ( tag ) ; if ( savedid != null && isrunning ( savedid ) ) { logd ( str_ + tag + str_ ) ; return savedid ; } logd ( str_ + tag + str_ ) ; final int id = chronosservice . getinstance ( ) . runasync ( operation , broadcastresult ) ; mtaggedrequests . put ( tag , id ) ; return id ; }	Launches an operation in background thread.
@ contract ( pure = bool_ ) public final boolean isrunning ( @ nonnull final string tag ) { final integer id = mtaggedrequests . get ( tag ) ;	Checks if an operation with given launch tag is running.
private void onoperationfinished ( @ nonnull final operationdelivery < ? > operationresult ) { logd ( str_ + operationresult ) ; switch ( mstate ) { case paused : storeresult ( operationresult ) ; break ; case resumed : deliverresult ( operationresult ) ; break ; default : throw new illegalstateexception ( str_ + mstate ) ; } }	A dispatcher method which decides what to do with an operation result.
private void storeresult ( @ nonnull final operationdelivery < ? > operationdelivery ) { logd ( str_ + operationdelivery ) ; mstoredresults . add ( new softreference < operationdelivery < ? > > ( operationdelivery ) ) ; }	Storing an operation result to use it later.
private void deliverresult ( @ nonnull final operationdelivery < ? > operationdelivery ) { logd ( str_ + operationdelivery ) ; switch ( operationdelivery . getdeliverymode ( ) ) { case normal : deliverresult ( operationdelivery . getresult ( ) , chronos . own_callback_method_name , bool_ ) ; break ; case broadcast : deliverresult ( operationdelivery . getresult ( ) , chronos . broadcast_callback_method_name , bool_ ) ; break ; default : break ; } }	Delivers an operation result to the bound client.
@ suppresswarnings ( str_ ) private void deliverresult ( @ nonnull final chronosoperationresult < ? > operationresult , @ nonnull final string methodname , final boolean warnifnocallback ) { final class listenerclass = mservicelistener . getclass ( ) ; final method [ ] listenermethods = listenerclass . getmethods ( ) ; method callbackmethod = null ; final class resultclass = operationresult . getclass ( ) ; for ( method method : listenermethods ) { if ( iscallback ( method , resultclass , methodname ) ) { callbackmethod = method ; try { callbackmethod . invoke ( mservicelistener , operationresult ) ; } catch ( illegalaccessexception e ) { log . w ( log_tag , log . getstacktracestring ( e ) ) ; } catch ( invocationtargetexception e ) { log . w ( log_tag , log . getstacktracestring ( e ) ) ; } } } if ( warnifnocallback && callbackmethod == null ) { log . w ( log_tag , str_ + operationresult . getid ( ) + str_ + operationresult . getclass ( ) . getname ( ) + str_ + mservicelistener + str_ ) ; log . w ( log_tag , str_ ) ; log . w ( log_tag , str_ + methodname + str_ + resultclass . getname ( ) + str_ ) ; } }	Call bound client methods to pass an operation result.
private synchronized boolean cancel ( final int id , final boolean mayinterrupt , final boolean removeoperation ) { final runningoperation runningoperation = mrunningoperations . get ( id ) ; if ( runningoperation != null ) { if ( removeoperation ) { mrunningoperations . remove ( id ) ; } mcancelledoperations . add ( id ) ; return runningoperation . cancel ( mayinterrupt ) ; } else { return bool_ ; } }	Cancels running operation.
synchronized final void operationstarted ( final int id , @ nonnull final chronosoperation < ? > operation , @ nonnull final future < ? > future ) { mrunningoperations . put ( id , new runningoperation ( operation , future ) ) ; }	Stores the future as a running operation with a given runs' id.
synchronized final void cancelall ( final boolean mayinterrupt ) { for ( final integer key : mrunningoperations . keyset ( ) ) { cancel ( key , mayinterrupt , bool_ ) ; } mrunningoperations . clear ( ) ; }	Cancels all running operations.
@ contract ( pure = bool_ ) synchronized final boolean isoperationcancelled ( final int id ) { return mcancelledoperations . contains ( integer . valueof ( id ) ) ; }	Checks if operation launch with given id was cancelled.
private static < output > void silentrun ( @ nonnull final chronosoperation < output > operation , @ nonnull final chronosoperationresult < output > operationresult ) { try { final output output = operation . run ( ) ; operationresult . setoutput ( output ) ; } catch ( exception e ) { operationresult . setexception ( e ) ; } }	Runs operation, handling all the exceptions that may ne thrown while running.
@ nonnull @ contract ( pure = bool_ ) private < output > chronosoperationresult < output > createemptyresult ( @ nonnull final chronosoperation < output > operation , final boolean broadcastresult ) { final chronosoperationresult < output > operationresult ; final class < ? extends chronosoperationresult < output > > resultclass = operation . getresultclass ( ) ; try { operationresult = resultclass . newinstance ( ) ; } catch ( instantiationexception e ) { throw new runtimeexception ( str_ + resultclass . getname ( ) ) ; } catch ( illegalaccessexception e ) { throw new runtimeexception ( resultclass . getname ( ) + str_ ) ; } operationresult . setid ( mlastoperationid . incrementandget ( ) ) ; operationresult . setoperation ( operation ) ; operationresult . setbroadcast ( broadcastresult ) ; return operationresult ; }	Creates a template object for storing operations' run result.
final < output > int runasync ( @ nonnull final chronosoperation < output > operation , final boolean broadcastresult ) { final chronosoperationresult < output > result = createemptyresult ( operation , broadcastresult ) ; final int id = result . getid ( ) ; synchronized ( chronosservice . this ) { runningoperationstorage . getinstance ( ) . operationstarted ( id , operation , mexecutorservice . submit ( new runnable ( ) { @ override public void run ( ) { silentrun ( operation , result ) ; meventbus . post ( result ) ; synchronized ( chronosservice . this ) { runningoperationstorage . getinstance ( ) . operationfinished ( id ) ; } } } ) ) ; } return id ; }	Runs operation in background.
@ nonnull final < output > chronosoperationresult < output > runsync ( @ nonnull final chronosoperation < output > operation , final boolean broadcastresult ) { final chronosoperationresult < output > result = createemptyresult ( operation , broadcastresult ) ; silentrun ( operation , result ) ; meventbus . post ( result ) ; return result ; }	Runs operation in the same thread.
public void onoperationfinished ( final simpleoperation . result result ) { if ( result . issuccessful ( ) ) { mdata = result . getoutput ( ) ; showdata ( ) ; } else { mtextoutput . settext ( result . geterrormessage ( ) ) ; } }	cancelling in the place it happened.
protected static void main ( main main , string ... args ) { main . getinjector ( ) . getinstance ( main . getmainclass ( ) ) . domain ( args ) ; }	Subclass specific entry point.
protected module [ ] getmodules ( ) { module [ ] modules = { new wiremodule ( new eventhandlermodule ( ) , new spacemodule ( new urlclassspace ( main . class . getclassloader ( ) ) ) ) } ; return modules ; }	Get the Guice modules to be used in injecting dependencies.
protected void domain ( string ... args ) { properties = new mergeableproperties ( ) ; properties . putall ( system . getproperties ( ) ) ; for ( string arg : args ) { properties . merge ( arg ) ; }	Actual main implementation.
private void checkline ( ) { string endstr = new string ( buf , count - line_seperator . length ( ) , line_seperator . length ( ) , charset ) ; if ( line_seperator . equals ( endstr ) ) { flush ( ) ; } }	Checks if the end of the buffer contains a newline and if so, flushes the stream.
public void initialize ( map < string , list < eventhandler > > eventhandlers , uri uri ) { this . eventhandlers = eventhandlers ; eventlistener listener = new eventlistener ( uri ) ; executorservice . submit ( listener ) ; logger . fine ( str_ ) ; }	Initialize the event poller.
protected mbeanserverconnection getmbeanserverconnection ( string childname ) { mbeanconnectioninfo conninfo = connections . get ( childname ) ; if ( conninfo == null ) { conninfo = new mbeanconnectioninfo ( ) ; connections . put ( childname , conninfo ) ; } long childpid = main . getfirstjavachildpid ( childname ) ; if ( childpid > num_ && childpid != conninfo . childpid && conninfo . connector != null ) { try { conninfo . connector . close ( ) ; } catch ( ioexception e ) { logger . log ( level . fine , str_ , e ) ; } conninfo . connector = null ; conninfo . server = null ; } if ( childpid > num_ ) { try { if ( conninfo . connector == null ) { conninfo . connector = deployercontrol . getjmxconnector ( childpid ) ; } if ( conninfo . connector != null && conninfo . server == null ) { conninfo . server = conninfo . connector . getmbeanserverconnection ( ) ; conninfo . childpid = childpid ; } } catch ( ioexception e ) { logger . log ( level . fine , str_ , e ) ; try { conninfo . connector . close ( ) ; } catch ( exception e2 ) { logger . log ( level . fine , str_ , e2 ) ; } conninfo . connector = null ; conninfo . server = null ; } } return conninfo . server ; }	Return the MBean server connection to the child process.
protected void closembeanserverconnection ( string childname ) { mbeanconnectioninfo conninfo = connections . get ( childname ) ; if ( conninfo != null && conninfo . connector != null ) { try { conninfo . connector . close ( ) ; } catch ( ioexception e ) { logger . log ( level . fine , str_ , e ) ; } conninfo . connector = null ; } }	Close the MBean server connection.
protected void init ( context context ) { layoutinflater . from ( context ) . inflate ( r . layout . fake_search_view , this , bool_ ) ; wrappededittext = ( edittext ) findviewbyid ( r . id . wrapped_search ) ; wrappededittext . addtextchangedlistener ( this ) ; wrappededittext . setoneditoractionlistener ( this ) ; }	Inflate the layout to this FrameLayout wrapper.
public static void main ( string [ ] args ) throws throwable { try { class < ? > initialclass ;	The main program which actually runs JMeter.
private com . github . fge . jsonschema . main . jsonschema getvalidator ( ) throws processingexception { if ( validator == null ) { synchronized ( this ) { if ( validator == null ) { validationconfigurationbuilder cfgbuilder = validationconfiguration . newbuilder ( ) ; cfgbuilder . addlibrary ( str_ , draftv3library . get ( ) ) ; validator = jsonschemafactory . newbuilder ( ) . setvalidationconfiguration ( cfgbuilder . freeze ( ) ) . freeze ( ) . getjsonschema ( getnode ( ) ) ; } } } return validator ; }	Lazy intialization of validator instance.
public list < column > getfindcolumnlist ( ) { list < column > findcolumnlist = new arraylist < column > ( ) ; list < column > tempcolumnlist = new arraylist < column > ( ) ; for ( int i = num_ ; i <= this . cardinality ; i ++ ) { if ( this . columns . get ( i ) . referencetable != null ) { tempcolumnlist = this . columns . get ( i ) . referencetable . getfindcolumnlist ( ) ; for ( int j = num_ ; j < tempcolumnlist . size ( ) ; j ++ ) { column column = new column ( ) ; column . name = columns . get ( i ) . name . replace ( str_ , str_ ) . replace ( str_ , str_ ) + tempcolumnlist . get ( j ) . name ; column . datatype = tempcolumnlist . get ( j ) . datatype ; column . nullable = this . columns . get ( i ) . nullable ; findcolumnlist . add ( column ) ; } } else { column column = new column ( ) ; column . name = columns . get ( i ) . name ; column . datatype = columns . get ( i ) . datatype ; column . nullable = this . columns . get ( i ) . nullable ; findcolumnlist . add ( column ) ; } } return findcolumnlist ; }	get the list of arguments used in find stored procedure.
public list < column > getinsertcolumnlist ( ) { list < column > result = new arraylist < > ( ) ; list < column > tempcolumnlist = new arraylist < > ( ) ; for ( column currentcolumn : this . columns ) { if ( currentcolumn . referencetable != null ) { tempcolumnlist = currentcolumn . referencetable . getfindcolumnlist ( ) ; for ( column tempcolumn : tempcolumnlist ) { column column = new column ( ) ; column . name = currentcolumn . name . replace ( str_ , str_ ) . replace ( str_ , str_ ) + tempcolumn . name ; column . datatype = tempcolumn . datatype ; column . nullable = currentcolumn . nullable ; result . add ( column ) ; } } else { column column = new column ( ) ; column . name = currentcolumn . name ; column . datatype = currentcolumn . datatype ; column . nullable = currentcolumn . nullable ; result . add ( column ) ; } } return result ; }	get the list of arguments used in insert by code stored procedure.
@ xmltransient public list < packagemetadata > getallpackages ( ) { list < packagemetadata > result = new arraylist < > ( ) ; if ( packages != null ) { for ( packagemetadata pack : packages ) { result . addall ( getpackages ( pack ) ) ; } } return result ; }	recursive method to get all packages including children packages.
private final string getnotoverridablecontent ( ) throws ioexception { if ( files . exists ( filepath ) ) { list < string > lines = files . readalllines ( filepath , filetype . getencoding ( ) ) ; boolean isnotoverridable = bool_ ; stringwriter notoverridablecontentwriter = new stringwriter ( ) ; for ( string line : lines ) { if ( line . contains ( filetype . getspecificcodestartmark ( ) ) ) { isnotoverridable = bool_ ; } else if ( line . contains ( filetype . getspecificcodeendmark ( ) ) ) { isnotoverridable = bool_ ; } else { if ( isnotoverridable ) { notoverridablecontentwriter . append ( line + skip_line ) ; } } } return notoverridablecontentwriter . tostring ( ) ; } return str_ ; }	extract non generated content from a file to keep it after next generation.
protected final void writenotoverridablecontent ( ) throws ioexception { string content = getnotoverridablecontent ( ) ; writeline ( filetype . getspecificcodestartmark ( ) ) ; write ( content ) ; writeline ( filetype . getspecificcodeendmark ( ) ) ; }	appends non generated content to be kept at next generation.
public table findtable ( string tablename ) { if ( tablename == null ) { return null ; } if ( tablename . isempty ( ) ) { return null ; } for ( package mypackage : this . packages ) { for ( table table : mypackage . tables ) { if ( table . originalname . equals ( tablename ) ) { return table ; } } } throw new tablenotfoundexception ( str_ + tablename ) ; }	run through all the tables until it is found.
public bean findbean ( string tableoriginalname ) { for ( package mypackage : this . packages ) { for ( bean bean : mypackage . beans ) { if ( bean . table . originalname . equals ( tableoriginalname ) ) { return bean ; } } } throw new beannotfoundexception ( str_ + tableoriginalname ) ; }	run through all the beans until it is found.
public list < viewproperty > getreferenceproperties ( bean bean ) { list < viewproperty > result = new arraylist < > ( ) ; for ( int i = num_ ; i < bean . cardinality ; i ++ ) { property property = bean . properties . get ( i ) ; result . addall ( property . viewproperties ) ; } return result ; }	get the list of properties that will be used in bean views to showreferences to other beans.
private list < viewproperty > getvisibleproperties ( onetomany onetomany ) { return getviewpropertiesexcludingfield ( onetomany . referencebean , onetomany . referenceproperty . name ) ; }	get the list of properties that will be available in a basic view bean.
public void update ( versionable target , versionable source ) { target . setdirty ( source . getdirty ( ) ) ; target . setmajorversion ( source . getmajorversion ( ) ) ; target . setmidversion ( source . getmidversion ( ) ) ; target . setminorversion ( source . getminorversion ( ) ) ; target . setmodifierid ( source . getmodifierid ( ) ) ; target . setreason ( source . getreason ( ) ) ; target . setmodificationtime ( source . getmodificationtime ( ) ) ; target . sethistorylist ( source . gethistorylist ( ) ) ; try { target . updatehistory ( ) ; } catch ( exception ex ) { log . log ( level . severe , ex . getlocalizedmessage ( ) , ex ) ; } }	Increase minor is done by default when updating a record.
public void addhistory ( history history ) { if ( gethistorylist ( ) == null ) { sethistorylist ( new arraylist < > ( ) ) ; } gethistorylist ( ) . add ( history ) ; }	Add history to this entity.
@ override public void customize ( session session ) throws exception { jndiconnector connector ;	Get a dataSource connection and set it on the session withlookupType=STRING_LOOKUP.
public requirementspecnodeserver addspecnode ( string name , string description , string scope ) throws exception { requirementspecnodeserver sns = new requirementspecnodeserver ( new requirementspecjpacontroller ( getentitymanagerfactory ( ) ) . findrequirementspec ( getrequirementspecpk ( ) ) , name , description , scope ) ; sns . write2db ( ) ; getrequirementspecnodelist ( ) . add ( new requirementspecnodejpacontroller ( getentitymanagerfactory ( ) ) . findrequirementspecnode ( sns . getrequirementspecnodepk ( ) ) ) ; write2db ( ) ; return sns ; }	Add a node to this spec.This is equivalent to a section in a document.Although database might allow a requirement being on different nodes,this constraint is imposed via software.
public static issuetype gettype ( string typename ) { issuetype result = null ; for ( issuetype type : new issuetypejpacontroller ( databasemanager . getentitymanagerfactory ( ) ) . findissuetypeentities ( ) ) { if ( type . gettypename ( ) . equals ( typename ) ) { result = type ; break ; } } return result ; }	Get an Issue Type by name.
@ suppresswarnings ( str_ ) public static vmsetting getsetting ( string s ) { parameters . clear ( ) ; parameters . put ( str_ , s ) ; result = namedquery ( str_ , parameters ) ; if ( result . isempty ( ) ) { return null ; } else { return ( vmsetting ) result . get ( num_ ) ; } }	Get setting from database.
public static dataentry getstringfield ( string name , string expected , boolean matchcase ) { dataentry de = new dataentry ( ) ; dataentrytype det = dataentrytypeserver . gettype ( str_ ) ; de . setentryname ( name ) ; de . setdataentrypropertylist ( getdefaultproperties ( det ) ) ; de . setdataentrytype ( det ) ; if ( expected != null ) { getproperty ( de , str_ ) . setpropertyvalue ( expected ) ; getproperty ( de , str_ ) . setpropertyvalue ( matchcase ? str_ : str_ ) ; } return de ; }	Create a default string field.
public static dataentry getbooleanfield ( string name ) { dataentry de = new dataentry ( ) ; de . setentryname ( name ) ; dataentrytype det = dataentrytypeserver . gettype ( str_ ) ; de . setdataentrypropertylist ( getdefaultproperties ( det ) ) ; de . setdataentrytype ( det ) ; return de ; }	Create a boolean field.
public static dataentry getnumericfield ( string name , float min , float max ) { dataentry de = new dataentry ( ) ; de . setentryname ( name ) ; dataentrytype det = dataentrytypeserver . gettype ( str_ ) ; de . setdataentrypropertylist ( getdefaultproperties ( det ) ) ; de . setdataentrytype ( det ) ; for ( dataentryproperty dep : de . getdataentrypropertylist ( ) ) { if ( dep . getpropertyname ( ) . equals ( str_ ) && min != null ) {	Create a numeric field.
private void displayworkflow ( workflow w ) { graph graph = new graph ( w . getworkflowname ( ) , graph . digraph ) ; nodes . clear ( ) ;	Create workflow from database.
private void refreshworkflow ( ) { graph graph = new graph ( ( ( workflow ) workflows . getvalue ( ) ) . getworkflowname ( ) , graph . digraph ) ; nodes . values ( ) . foreach ( node -> { graph . addnode ( node ) ; } ) ; edges . values ( ) . foreach ( edge -> { graph . addedge ( edge . getkey ( ) , edge . getvalue ( ) . getdest ( ) ) ; } ) ; diagram . drawgraph ( graph ) ; selected = null ; updatecontrols ( ) ; }	Recreate graph with the edited values.
private static void walkcomponenttree ( component c , consumer < component > visitor ) { visitor . accept ( c ) ; if ( c instanceof hascomponents ) { for ( component child : ( ( hascomponents ) c ) ) { walkcomponenttree ( child , visitor ) ; } } }	recursively walk the Component true.
@ override public outputstream receiveupload ( string filename , string mimetype ) { fileoutputstream fos ;	Callback method to begin receiving the upload.
@ nullable public resultstrength getaddressrisk ( ) { if ( addressrisk == null ) { return null ; } return resultstrength . toenum ( addressrisk . tolowercase ( ) ) ; }	Gets the risk of this particular address.
@ deprecated protected < d extends filedescriptor > d tofiledescriptor ( descriptor descriptor , class < d > type , string path , scannercontext context ) { if ( descriptor == null ) { d result = context . getstore ( ) . create ( type ) ; result . setfilename ( path ) ; return result ; } return migrateorcast ( descriptor , type , context ) ; }	Takes an optional descriptor and transforms it to file descriptor.
@ nullable public static blockscoreerror getblockscoreerror ( @ notnull final retrofiterror cause ) { object rawerror = cause . getbodyas ( blockscoreerror . class ) ; if ( rawerror instanceof blockscoreerror ) { return ( blockscoreerror ) rawerror ; } else { return null ; } }	Converts a Retrofit Error into a Blockscore Error.
@ notnull public void score ( @ notnull final answerset answers ) { questionset scoredset = restadapter . scorequestionset ( getid ( ) , answers ) ; expired = scoredset . isexpired ( ) ; score = scoredset . getscore ( ) ; }	Scores a question set.
public < d extends md5descriptor > d digest ( inputstream stream , digestoperation < d > digestoperation ) throws ioexception { digestinputstream digestinputstream = new digestinputstream ( stream , md5digest ) ; d md5descriptor = digestoperation . execute ( digestinputstream ) ; string md5 = datatypeconverter . printhexbinary ( md5digest . digest ( ) ) ; md5descriptor . setmd5 ( md5 ) ; return md5descriptor ; }	Calculate the MD5 hash sum for the given input stream using the givenoperation.
public boolean accepts ( string path ) { boolean result ; if ( includefilepatterns != null ) { result = matches ( path , includefilepatterns ) ; } else { result = bool_ ; } if ( excludefilepatterns != null ) { result = result && ! matches ( path , excludefilepatterns ) ; } return result ; }	Determines if the given path matches the configured include and excludepatterns.NOTE: The include pattern is evaluated before the exclude pattern.
public void addanswer ( int questionid , int answerid ) { questionanswerpair answerpair = new questionanswerpair ( questionid , answerid ) ; answers . add ( answerpair ) ; }	Adds an answer to a question to the AnswerSet.
@ notnull public string [ ] getmatchinginfo ( ) { if ( matchinginfo == null ) { return new string [ num_ ] ; } return arrays . copyof ( matchinginfo , matchinginfo . length ) ; }	Gets a list of elements in your request that match this watchlist hit.
@ nullable public address getaddress ( ) { return new address ( addressstreet1 , addressstreet2 , addresscity , addressstate , addresspostalcode , addresscountrycode ) ; }	Gets the address of the candidate.
public questionset createquestionset ( long timelimit ) { map < string , string > queryoptions = new hashmap < string , string > ( ) ; queryoptions . put ( str_ , getid ( ) ) ; queryoptions . put ( str_ , string . valueof ( timelimit ) ) ; questionset questionset = restadapter . createquestionset ( queryoptions ) ; questionset . setadapter ( restadapter ) ; return questionset ; }	Creates a question set with a set time limit in seconds.
public questionset retrievequestionset ( @ notnull final string questionsetid ) { questionset questionset = restadapter . retrievequestionset ( questionsetid ) ; questionset . setadapter ( restadapter ) ; return questionset ; }	Retrieve a question set you have created.
@ notnull public date getdateofbirth ( ) { gregoriancalendar calendar = new gregoriancalendar ( birthyear , birthmonth , birthday ) ; return calendar . gettime ( ) ; }	Gets the date of birth for this individual.
@ notnull public address getaddress ( ) { address addressobject = new address ( addressstreet1 , addressstreet2 , addresscity , addresssubdivision , addresspostalcode , addresscountrycode ) ; return addressobject ; }	Gets the address for this individual.
@ nullable public date getincorporationdate ( ) { if ( incorporationday == null || incorporationmonth == null || incorporationyear == null ) { return null ; } gregoriancalendar calendarday = new gregoriancalendar ( incorporationyear , incorporationmonth , incorporationday ) ; return calendarday . gettime ( ) ; }	Gets the date of incorporation.
public list < candidate > getrevisionhistory ( ) { list < candidate > candidates = restadapter . getcandidatehistory ( getid ( ) ) ; for ( candidate candidate : candidates ) { candidate . setadapter ( restadapter ) ; } return collections . unmodifiablelist ( candidates ) ; }	Returns a complete revision history of a candidate's edits.
public paginatedresult < watchlisthit > searchwatchlists ( entitytype entitytype , double similaritythreshold ) { map < string , string > queryoptions = new hashmap < string , string > ( ) ; queryoptions . put ( str_ , getid ( ) ) ; if ( entitytype != null ) { queryoptions . put ( str_ , string . valueof ( entitytype ) ) ; } if ( similaritythreshold != null ) { queryoptions . put ( str_ , string . valueof ( similaritythreshold ) ) ; } watchlistsearchresults results = restadapter . searchwatchlists ( queryoptions ) ;	Performs a watchlist search for this candidate.
@ notnull public candidate setdateofbirth ( @ nullable final date dateofbirth ) { if ( dateofbirth == null ) { this . dateofbirth = null ; return this ; } this . dateofbirth = new date ( dateofbirth . gettime ( ) ) ; return this ; }	Set the date of birth of your candidate.
public candidate setaddress ( @ notnull final address address ) { this . addressstreet1 = address . getstreet1 ( ) ; this . addressstreet2 = address . getstreet2 ( ) ; this . addresscity = address . getcity ( ) ; this . addresssubdivision = address . getsubdivision ( ) ; this . addresspostalcode = address . getpostalcode ( ) ; this . addresscountrycode = address . getcountrycode ( ) ; return this ; }	Sets the primary street address for this person.
@ notnull public person retrieveperson ( @ notnull final string id ) { person person = restadapter . retrieveperson ( id ) ; person . setadapter ( restadapter ) ; return person ; }	Gets a single person exactly as it was when you created it.This route is useful for auditing purposes as you can provide proof that a verification took placealong with all of its associated data.
@ notnull public candidate retrievecandidate ( @ notnull final string id ) { candidate candidate = restadapter . retrievecandidate ( id ) ; candidate . setadapter ( restadapter ) ; return candidate ; }	Retrieves a candidate.
@ notnull private string getencodedauthorization ( ) { try { return str_ + datatypeconverter . printbase64binary ( apikey . getbytes ( str_ ) ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } }	Encodes the API key for Basic authentication.
@ nullable public date getdateofbirthend ( ) { if ( birthdayend == null || birthmonthend == null || birthyearend == null ) { return null ; } gregoriancalendar calendar = new gregoriancalendar ( birthyearend , birthmonthend , birthdayend ) ; return calendar . gettime ( ) ; }	Returns the end of the date of birth range.
protected < t > class < t > gettypeparameter ( class < ? > expectedsuperclass , int generictypeparameterindex ) { class < ? extends abstractscannerplugin > thisclass = this . getclass ( ) ; if ( ! thisclass . getsuperclass ( ) . equals ( expectedsuperclass ) ) { throw new illegalstateexception ( str_ + thisclass . getname ( ) ) ; } type genericsuperclass = thisclass . getgenericsuperclass ( ) ; type typeparameter = ( ( parameterizedtype ) genericsuperclass ) . getactualtypearguments ( ) [ generictypeparameterindex ] ; if ( typeparameter instanceof parameterizedtype ) { return ( class < t > ) ( ( parameterizedtype ) typeparameter ) . getrawtype ( ) ; } return ( class < t > ) typeparameter ; }	Determines the type parameter for a generic super class.
protected string getstringproperty ( string name , string defaultvalue ) { object value = properties . get ( name ) ; return value != null ? value . tostring ( ) : defaultvalue ; }	Get a property as string.
protected boolean getbooleanproperty ( string name , boolean defaultvalue ) { object value = properties . get ( name ) ; return value != null ? boolean . valueof ( value . tostring ( ) ) : defaultvalue ; }	Get a property as boolean.
protected string getdirectorypath ( file directory , file entry ) { string relativepath ; if ( entry . equals ( directory ) ) { relativepath = str_ ; } else { string filepath = entry . getabsolutepath ( ) ; string directorypath = directory . getabsolutepath ( ) ; relativepath = filepath . substring ( directorypath . length ( ) ) . replace ( file . separator , str_ ) ; } return relativepath ; }	Return the relative path of a file within a directory.
@ notnull public blockscoreerrortype geterrortype ( ) { if ( type == null ) { return blockscoreerrortype . unknown ; } else { return blockscoreerrortype . toenum ( type ) ; } }	Gets the error type.
@ notnull public validationerrortype getvalidationerrorcode ( ) { if ( code == null ) { return validationerrortype . unknown ; } else { return validationerrortype . toenum ( code ) ; } }	Gets the validation error type.
public void flush ( ) { createhierarchy ( ) ; sync ( filecontainerdescriptor . getrequires ( ) , requiredfiles ) ; sync ( filecontainerdescriptor . getcontains ( ) , containedfiles ) ; }	Flush the caches to the store.
private void sync ( collection < filedescriptor > target , map < string , filedescriptor > after ) { map < string , filedescriptor > before = getcache ( target ) ; map < string , filedescriptor > all = new hashmap < > ( ) ; all . putall ( before ) ; all . putall ( after ) ; for ( map . entry < string , filedescriptor > entry : all . entryset ( ) ) { string key = entry . getkey ( ) ; filedescriptor filedescriptor = entry . getvalue ( ) ; boolean hasbefore = before . containskey ( key ) ; boolean hasafter = after . containskey ( key ) ; if ( hasbefore && ! hasafter ) { target . remove ( filedescriptor ) ; } else if ( ! hasbefore && hasafter ) { target . add ( filedescriptor ) ; } } }	Sync the given target collection with the new state from the cache map.
private map < string , filedescriptor > getcache ( iterable < filedescriptor > filedescriptors ) { map < string , filedescriptor > cache = new hashmap < > ( ) ; for ( filedescriptor filedescriptor : filedescriptors ) { cache . put ( filedescriptor . getfilename ( ) , filedescriptor ) ; } return cache ; }	Creates cache map from the given collection of file descriptors.
private void createhierarchy ( ) { for ( map . entry < string , filedescriptor > entry : containedfiles . entryset ( ) ) { string relativepath = entry . getkey ( ) ; filedescriptor filedescriptor = entry . getvalue ( ) ; int separatorindex = relativepath . lastindexof ( str_ ) ; if ( separatorindex != - num_ ) { string parentname = relativepath . substring ( num_ , separatorindex ) ; filedescriptor parentdescriptor = containedfiles . get ( parentname ) ; if ( parentdescriptor instanceof filecontainerdescriptor ) { ( ( filecontainerdescriptor ) parentdescriptor ) . getcontains ( ) . add ( filedescriptor ) ; } } } }	Build the hierarchy of the container entries, i.e.
public static int findunusedport ( ) throws ioexception { int port ; try ( serversocket socket = new serversocket ( ) ) { socket . bind ( new inetsocketaddress ( num_ ) ) ; port = socket . getlocalport ( ) ; } return port ; }	Find an unused port.
@ override public stringvalue getparametervalue ( final string _name ) { final list < stringvalue > values = this . parameters . get ( _name ) ; return ( values != null && ! values . isempty ( ) ) ? values . get ( num_ ) : stringvalue . valueof ( ( string ) null ) ; }	Returns single value for parameter with specified name.
@ override public void setparametervalues ( final string _name , final list < stringvalue > _value ) { this . parameters . put ( _name , _value ) ; try { context . getthreadcontext ( ) . getparameters ( ) . put ( _name , parameterutil . stringvalues2array ( _value ) ) ; } catch ( final efapsexception e ) { efapsrequestparametersadapter . log . error ( str_ , _name ) ; } }	Sets the values for given parameter.
public void setparametervalue ( final string _key , final string _value ) { final list < stringvalue > list = new arraylist < stringvalue > ( num_ ) ; list . add ( stringvalue . valueof ( _value ) ) ; setparametervalues ( _key , list ) ; }	Sets value for given key.
public void addparametervalue ( final string _key , final string _value ) { list < stringvalue > list = this . parameters . get ( _key ) ; if ( list == null ) { list = new arraylist < stringvalue > ( num_ ) ; this . parameters . put ( _key , list ) ; } list . add ( stringvalue . valueof ( _value ) ) ; try { context . getthreadcontext ( ) . getparameters ( ) . put ( _key , parameterutil . stringvalues2array ( list ) ) ; } catch ( final efapsexception e ) { efapsrequestparametersadapter . log . error ( str_ , _key ) ; } }	Adds a value for given key.
public abstractcommand gettargetcmd ( ) throws cachereloadexception { abstractcommand cmd = command . get ( this . targetcmduuid ) ; if ( cmd == null ) { cmd = menu . get ( this . targetcmduuid ) ; } return cmd ; }	Get the CommandAbstract that is the target of this Page.
protected object getvalue4wizard ( final string _key ) { object ret = null ; final map < string , string [ ] > para = this . wizard . getparameters ( ( iwizardelement ) this ) ; if ( para != null && para . containskey ( _key ) ) { final string [ ] value = para . get ( _key ) ; ret = value [ num_ ] ; } return ret ; }	Method to get the value for a key in case of wizard.
public string registeroid ( final string _oid ) { final string ret = randomutil . randomalphanumeric ( num_ ) ; getuiid2oid ( ) . put ( ret , _oid ) ; return ret ; }	Register oid.
@ override public component newnodecomponent ( final string _wicketid , final imodel < uistructurbrowser > _model ) { return new node < uistructurbrowser > ( _wicketid , this , _model ) { private static final long serialversionuid = num_ ; @ override protected component createcontent ( final string _wicketid , final imodel < uistructurbrowser > _model ) { return newcontentcomponent ( _wicketid , _model ) ; } @ override protected markupcontainer createjunctioncomponent ( final string _id ) { final uistructurbrowser strucbrws = ( uistructurbrowser ) getdefaultmodelobject ( ) ; final markupcontainer ret ; if ( strucbrws . haschildren ( ) && strucbrws . isforceexpanded ( ) ) { ret = new webmarkupcontainer ( _id ) ; } else { ret = super . createjunctioncomponent ( _id ) ; } if ( strucbrws . getlevel ( ) > num_ ) { ret . add ( attributemodifier . append ( str_ , str_ + num_ * ( strucbrws . getlevel ( ) - num_ ) + str_ ) ) ; } return ret ; } } ; }	Create a new component for a node.
@ override public component newsubtree ( final string _wicketid , final imodel < uistructurbrowser > _model ) { return new subelement ( _wicketid , this , _model ) ; }	Create a new subtree.
public static set < indexflavor > complementof ( final set < indexflavor > indexflavors ) { final set < indexflavor > set = allof ( ) ; set . removeall ( indexflavors ) ; return set ; }	Returns a set containing all the known index flavours, except those is the given set.
public static set < indexflavor > of ( final indexflavor first , final indexflavor ... rest ) { final set < indexflavor > set = new hashset < > ( ) ; set . add ( first ) ; set . addall ( arrays . aslist ( rest ) ) ; return set ; }	Returns a set containing the given index flavours.
@ override public v put ( final k key , final v value ) { entries . add ( new entry ( key , value ) ) ; return value ; }	Add an entry for the given key-value pair to the map.
@ override public v remove ( final object key ) { final iterator < map . entry < k , v > > iterator = entries . iterator ( ) ; v lastvalue = null ; while ( iterator . hasnext ( ) ) { final map . entry < k , v > entry = iterator . next ( ) ; lastvalue = entry . getvalue ( ) ; if ( key . equals ( entry . getkey ( ) ) ) { iterator . remove ( ) ; } } return lastvalue ; }	Remove all entries for the given key.
public string getrandom4id ( final long _id ) { final string rid = randomutil . randomalphanumeric ( num_ ) ; this . random2id . put ( rid , _id ) ; return rid ; }	Gets the random for ID.
protected list < integer > getuserwidths ( ) { list < integer > ret = null ; try { if ( context . getthreadcontext ( ) . containsuserattribute ( getcachekey ( uitable . usercachekey . columnwidth ) ) ) { setuserwidth ( bool_ ) ; final string widths = context . getthreadcontext ( ) . getuserattribute ( getcachekey ( uitable . usercachekey . columnwidth ) ) ; final stringtokenizer tokens = new stringtokenizer ( widths , str_ ) ; ret = new arraylist < > ( ) ; while ( tokens . hasmoretokens ( ) ) { final string token = tokens . nexttoken ( ) ; for ( int i = num_ ; i < token . length ( ) ; i ++ ) { if ( ! character . isdigit ( token . charat ( i ) ) ) { final int width = integer . parseint ( token . substring ( num_ , i ) ) ; ret . add ( width ) ; break ; } } } } } catch ( final numberformatexception e ) {	This method retieves the UserAttribute for the ColumnWidths and evaluatesthe string.
public void setsortdirection ( final sortdirection _sortdirection ) { this . sortdirection = _sortdirection ; try { context . getthreadcontext ( ) . setuserattribute ( getcachekey ( usercachekey . sortdirection ) , _sortdirection . getvalue ( ) ) ; } catch ( final efapsexception e ) {	Method to set he sort direction.
public void setcolumnorder ( final string _markupsids ) { final stringtokenizer tokens = new stringtokenizer ( _markupsids , str_ ) ; final stringbuilder columnorder = new stringbuilder ( ) ; while ( tokens . hasmoretokens ( ) ) { final string markupid = tokens . nexttoken ( ) ; for ( final uitableheader header : getheaders ( ) ) { if ( markupid . equals ( header . getmarkupid ( ) ) ) { columnorder . append ( header . getfieldname ( ) ) . append ( str_ ) ; break ; } } } try { context . getthreadcontext ( ) . setuserattribute ( getcachekey ( uitable . usercachekey . columnorder ) , columnorder . tostring ( ) ) ; } catch ( final efapsexception e ) {	Method to set the order of the columns.
protected list < field > getusersortedcolumns ( ) { list < field > ret = new arraylist < > ( ) ; try { final list < field > fields = gettable ( ) . getfields ( ) ; if ( context . getthreadcontext ( ) . containsuserattribute ( getcachekey ( uitable . usercachekey . columnorder ) ) ) { final string columnorder = context . getthreadcontext ( ) . getuserattribute ( getcachekey ( uitable . usercachekey . columnorder ) ) ; final stringtokenizer tokens = new stringtokenizer ( columnorder , str_ ) ; while ( tokens . hasmoretokens ( ) ) { final string fieldname = tokens . nexttoken ( ) ; for ( int i = num_ ; i < fields . size ( ) ; i ++ ) { if ( fieldname . equals ( fields . get ( i ) . getname ( ) ) ) { ret . add ( fields . get ( i ) ) ; fields . remove ( i ) ; } } } if ( ! fields . isempty ( ) ) { for ( final field field : fields ) { ret . add ( field ) ; } } } else { ret = fields ; } } catch ( final efapsexception e ) { abstractuiheaderobject . log . debug ( str_ ) ; } return ret ; }	This method looks if for this TableModel a UserAttribute for the sortingof the Columns exist.
@ override protected void oncomponenttag ( final componenttag _tag ) { super . oncomponenttag ( _tag ) ; final uistructurbrowser structurbrowser = ( uistructurbrowser ) getdefaultmodelobject ( ) ; if ( structurbrowser . getsortdirection ( ) . equals ( sortdirection . ascending ) ) { _tag . put ( str_ , str_ ) ; } else { _tag . put ( str_ , str_ ) ; } }	On the tag the class is set.
@ override public void oncomponenttagbody ( final markupstream _markupstream , final componenttag _opentag ) { replacecomponenttagbody ( _markupstream , _opentag , this . header ) ; }	The body of the component is filled with the header.
@ override public void onclick ( ) { final uistructurbrowser structurbrowser = ( uistructurbrowser ) getdefaultmodelobject ( ) ;	On click the model is sorted and a new page with this model as responserendered.
public static config getconfig ( string name , iconfigfactory factory ) { if ( configs == null ) { init ( ) ; } if ( name == null ) { name = default_config_name ; } config got = configs . get ( name ) ; if ( got == null ) { log ( bool_ , str_ + name + str_ , null ) ;	Returns a Config instance, instantiating it on first call. If no factoryimplementation is provided, one will be searched using Service Loader If aConfig with given name already exists, it will be simply returned.
private void renderefapsheaderitems ( ) { collections . sort ( this . efapsheaderitems , ( _item0 , _item1 ) -> _item0 . getsortweight ( ) . compareto ( _item1 . getsortweight ( ) ) ) ; final list < string > css = new arraylist < > ( ) ; final list < string > js = new arraylist < > ( ) ; for ( final abstractefapsheaderitem item : this . efapsheaderitems ) { if ( item instanceof efapsjavascriptheaderitem ) { js . add ( item . getreference ( ) . getname ( ) ) ; } else { css . add ( item . getreference ( ) . getname ( ) ) ; } } try { if ( ! css . isempty ( ) ) { final string key = bundlemaker . getbundlekey ( css , tempfilebundle . class ) ; final tempfilebundle bundle = ( tempfilebundle ) bundlemaker . getbundle ( key ) ; bundle . setcontenttype ( str_ ) ; super . render ( cssheaderitem . forurl ( efapsapplication . get ( ) . getservletcontext ( ) . getcontextpath ( ) + str_ + key ) ) ; } if ( ! js . isempty ( ) ) { final string key = bundlemaker . getbundlekey ( js , tempfilebundle . class ) ; final tempfilebundle bundle = ( tempfilebundle ) bundlemaker . getbundle ( key ) ; bundle . setcontenttype ( str_ ) ; super . render ( javascriptheaderitem . forurl ( efapsapplication . get ( ) . getservletcontext ( ) . getcontextpath ( ) + str_ + key ) ) ; } } catch ( final efapsexception e ) { efapsresourceaggregator . log . error ( str_ , e ) ; } }	render the eFaps Resource items.
private void rendercombinedrequirescripts ( ) { final set < dojoclass > dojoclasses = this . requireheaderitems . stream ( ) . flatmap ( o -> o . getdojoclasses ( ) . stream ( ) ) . collect ( collectors . toset ( ) ) ; if ( collectionutils . isnotempty ( dojoclasses ) ) { super . render ( new headeritem ( ) { private static final long serialversionuid = num_ ; @ override public iterable < ? > getrendertokens ( ) { return dojoclasses ; } @ override public void render ( final response _response ) { javascriptutils . writejavascript ( _response , dojowrapper . require ( null , dojoclasses . toarray ( new dojoclass [ dojoclasses . size ( ) ] ) ) , requireheaderitem . class . getname ( ) ) ; } } ) ; } }	Render combined requir scripts.
protected charsequence getcreatetreenodescript ( ) { final stringbuilder js = new stringbuilder ( ) ; js . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( inputname ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) ; return js ; }	Gets the creates the tree node script.
protected charsequence getdataline ( final classification _clazz , final iclassificationfilter _filter ) throws efapsexception { final stringbuilder js = new stringbuilder ( ) ; if ( _clazz . hasaccess ( null , accesstypeenums . show . getaccesstype ( ) ) ) { js . append ( str_ ) . append ( _clazz . getuuid ( ) ) . append ( str_ ) . append ( stringescapeutils . escapeecmascript ( _clazz . getlabel ( ) ) ) . append ( str_ ) . append ( _clazz . isroot ( ) ? str_ : _clazz . getparentclassification ( ) . getuuid ( ) ) . append ( str_ ) . append ( _filter . contains ( _clazz . getuuid ( ) ) ) . append ( str_ ) ; for ( final classification childclazz : _clazz . getchildclassifications ( ) ) { js . append ( getdataline ( childclazz , _filter ) ) ; } } return js ; }	Gets the data line.
public void execute ( final instance _instance ) throws efapsexception { uiclassification clazz = this ; while ( ! clazz . isroot ( ) ) { clazz = clazz . getparent ( ) ; } clazz . initialized = bool_ ; for ( final uiclassification child : clazz . getchildren ( ) ) { final classification type = ( classification ) type . get ( child . getclassificationuuid ( ) ) ; if ( clazz . selecteduuid . contains ( child . getclassificationuuid ( ) ) ) { child . setselected ( bool_ ) ; } child . addchildren ( child , type . getchildclassifications ( ) , clazz . selecteduuid , _instance ) ; clazz . expand ( ) ; } }	Execute the model.
@ suppresswarnings ( str_ ) private void expand ( ) { try { final string key = getcachekey ( ) ; if ( context . getthreadcontext ( ) . containssessionattribute ( key ) ) { final set < uuid > sessmap = ( set < uuid > ) context . getthreadcontext ( ) . getsessionattribute ( key ) ; setexpandedinternal ( sessmap . contains ( this . classificationuuid ) ) ; for ( final uiclassification uiclazz : getdescendants ( ) ) { if ( sessmap . contains ( uiclazz . classificationuuid ) ) { uiclazz . setexpandedinternal ( bool_ ) ; } } } } catch ( final efapsexception e ) { uiclassification . log . error ( str_ , this . fieldid , e ) ; } }	Expand the Tree.
private void addchildren ( final uiclassification _parent , final set < classification > _children , final set < uuid > _selecteduuid , final instance _instance ) throws efapsexception { for ( final classification child : _children ) { boolean access ; if ( ! child . isabstract ( ) ) { final instance inst = abstractinstanceobject . getinstance4create ( child ) ; access = child . hasaccess ( inst , getmode ( ) == targetmode . create || getmode ( ) == targetmode . edit ? accesstypeenums . create . getaccesstype ( ) : accesstypeenums . show . getaccesstype ( ) ) ; } else { access = bool_ ; } if ( access ) { final uiclassification childui = new uiclassification ( child . getuuid ( ) , _parent . mode , bool_ ) ; if ( _selecteduuid . contains ( child . getuuid ( ) ) ) { childui . selected = bool_ ; } childui . addchildren ( childui , child . getchildclassifications ( ) , _selecteduuid , _instance ) ; _parent . children . add ( childui ) ; childui . setparent ( _parent ) ; } } collections . sort ( _parent . children , new comparator < uiclassification > ( ) { @ override public int compare ( final uiclassification _class0 , final uiclassification _class2 ) { return _class0 . getlabel ( ) . compareto ( _class2 . getlabel ( ) ) ; } } ) ; }	Recursive method used to add the children to this UIClassification.
public map < uuid , string > getclassinstancekeys ( final instance _instance ) throws efapsexception { final map < uuid , string > ret = new hashmap < uuid , string > ( ) ; uiclassification clazz = this ; while ( ! clazz . isroot ( ) ) { clazz = clazz . getparent ( ) ; } type reltype = null ; for ( final uiclassification child : clazz . getchildren ( ) ) { final classification classtype = ( classification ) type . get ( child . getclassificationuuid ( ) ) ; if ( ! classtype . getclassifyrelationtype ( ) . equals ( reltype ) ) { final querybuilder querybldr = new querybuilder ( classtype . getclassifyrelationtype ( ) ) ; querybldr . addwhereattreqvalue ( classtype . getrellinkattributename ( ) , _instance . getid ( ) ) ; final multiprintquery multi = querybldr . getprint ( ) ; multi . addattribute ( classtype . getreltypeattributename ( ) ) ; multi . execute ( ) ; while ( multi . next ( ) ) { final long typeid = multi . < long > getattribute ( classtype . getreltypeattributename ( ) ) ; final classification subclasstype = ( classification ) type . get ( typeid ) ; final querybuilder subquerybldr = new querybuilder ( subclasstype ) ; subquerybldr . addwhereattreqvalue ( subclasstype . getlinkattributename ( ) , _instance . getid ( ) ) ; subquerybldr . addorderbyattributeasc ( str_ ) ; final instancequery query = subquerybldr . getquery ( ) ; query . execute ( ) ; if ( query . next ( ) ) {	Method to get the key to the instances related to this classification.
public string getcachekey ( ) { string ret = str_ ; uiclassification clazz = this ; while ( ! clazz . isroot ( ) ) { clazz = clazz . getparent ( ) ; } final field field = field . get ( clazz . getfieldid ( ) ) ; if ( field != null ) { try { ret = field . getcollection ( ) . getuuid ( ) . tostring ( ) + str_ + field . getname ( ) + str_ + uiclassification . usersessionkey ; } catch ( final cachereloadexception e ) { uiclassification . log . error ( str_ , e ) ; } } return ret ; }	This method generates the Key for a UserAttribute by using the UUID ofthe Command and the given static part, so that for every StruturBrowser aunique key for expand etc, is created.
public viewdocumentrequestbuilder addhighlightexpressions ( final string highlightexpression , final string ... highlightexpressions ) { this . highlightexpressions . add ( highlightexpression ) ; this . highlightexpressions . addall ( arrays . aslist ( highlightexpressions ) ) ; return this ; }	Adds values to the highlight_expression parameter.
public viewdocumentrequestbuilder addstarttags ( final string starttag , final string ... starttags ) { this . starttags . add ( starttag ) ; this . starttags . addall ( arrays . aslist ( starttags ) ) ; return this ; }	Adds values to the start_tag parameter.
public viewdocumentrequestbuilder addendtags ( final string endtag , final string ... endtags ) { this . endtags . add ( endtag ) ; this . endtags . addall ( arrays . aslist ( endtags ) ) ; return this ; }	Adds values to the end_tag parameter.
public component getlazyloadcomponent ( final string _markupid , final string _html ) { return new webmarkupcontainer ( _markupid ) { private static final long serialversionuid = num_ ; @ override public void oncomponenttagbody ( final markupstream _markupstream , final componenttag _opentag ) { replacecomponenttagbody ( _markupstream , _opentag , _html ) ; } } ; }	Gets the lazy load component.
public component getloadingcomponent ( final string _markupid ) { final irequesthandler handler = new resourcereferencerequesthandler ( abstractdefaultajaxbehavior . indicator ) ; return new label ( _markupid , str_ + requestcycle . get ( ) . urlfor ( handler ) + str_ ) . setescapemodelstrings ( bool_ ) ; }	Gets the loading component.
public void insertbefore ( final iwizardelement _element ) { int i = num_ ; for ( final iwizardelement uiobject : this . elements ) { if ( uiobject == this . current ) { this . elements . add ( i , _element ) ; break ; } i ++ ; } }	Insert a UIObject before the current one.
public iwizardelement getprevious ( ) { iwizardelement ret = null ; for ( final iwizardelement uiobject : this . elements ) { if ( uiobject == this . current ) { break ; } else { ret = uiobject ; } } this . current = ret ; return ret ; }	Method to get the previous object.
public void addparameters ( final iwizardelement _element , final map < string , string [ ] > _parameters ) { this . parameters . put ( _element , _parameters ) ; }	Add parameters.
protected boolean evaluate4instance ( ) throws efapsexception { boolean ret = bool_ ; if ( ! issearchmode ( ) ) { final list < return > returns = this . getcommand ( ) . executeevents ( eventtype . ui_table_evaluate , parametervalues . instance , getinstance ( ) , parametervalues . parameters , context . getthreadcontext ( ) . getparameters ( ) , parametervalues . class , this ) ; for ( final return retu : returns ) { if ( retu . contains ( returnvalues . instance ) ) { final object object = retu . get ( returnvalues . instance ) ; if ( object != null && object instanceof instance && ( ( instance ) object ) . isvalid ( ) ) { setinstancekey ( ( ( instance ) object ) . getoid ( ) ) ; } else { uiform . log . error ( str_ , this . getcommand ( ) . getname ( ) ) ; } } else { ret = bool_ ; } } } return ret ; }	This is a possibility to replace the current Instance for the form withanother one using an table evaluate esjp.
public void addclasselements ( final uiclassification _uiclass , final map < uuid , string > _instancekeys ) throws efapsexception { this . elements . addall ( getclasselements ( _uiclass , _instancekeys ) ) ; }	Method that adds the classification forms as elements to the form bywalking down the tree.
public void updateclasselements ( final uiclassification _uiclass ) throws efapsexception {	Method that removes all classifcations and afterwards adds theclassification forms as elements to the form by walking down the tree.
private boolean addcell2formrow ( final formelement _formelement , final printquery _query , final field _field ) throws efapsexception { boolean ret = bool_ ; attribute attr = null ; if ( _field . getattribute ( ) != null ) { attr = _query . getattribute4attribute ( _field . getattribute ( ) ) ; } else if ( _field . getselect ( ) != null ) { attr = _query . getattribute4select ( _field . getselect ( ) ) ; } final instance fieldinstance = evaluatefieldinstance ( _query , _field ) ; if ( _field . ishiddendisplay ( getmode ( ) ) ) { if ( _field . getattribute ( ) != null ) { _query . getattribute ( _field . getattribute ( ) ) ; } else if ( _field . getselect ( ) != null ) { _query . getselect ( _field . getselect ( ) ) ; } else if ( _field . getphrase ( ) != null ) { _query . getphrase ( _field . getname ( ) ) ; } addhidden ( evaluateuiprovider ( _query , _field , fieldinstance , attr ) ) ; ret = bool_ ; } else {	Method to add a Cell to the given Row.
private uifield evaluateuiprovider ( final printquery _print , final field _field , final instance _fieldinstance , final attribute _attr ) throws efapsexception { object value = null ; if ( _field . getattribute ( ) != null ) { value = _print . < object > getattribute ( _field . getattribute ( ) ) ; } else if ( _field . getselect ( ) != null ) { value = _print . < object > getselect ( _field . getselect ( ) ) ; } else if ( _field . getphrase ( ) != null ) { value = _print . getphrase ( _field . getname ( ) ) ; } else if ( _field . getmsgphrase ( ) != null ) { value = _print . getmsgphrase ( new selectbuilder ( getbaseselect4msgphrase ( _field ) ) , _field . getmsgphrase ( ) ) ; } final uifield uifield = new uifield ( this , _fieldinstance . getkey ( ) , uivalue . get ( _field , _attr , value ) . setinstance ( _fieldinstance ) . setcallinstance ( getinstance ( ) ) . setclassobject ( this ) ) ; return uifield ; }	Method evaluates a Field and adds it to the row.
private list < element > getclasselements ( final uiclassification _uiclass , final map < uuid , string > _uuid2instancekey ) throws efapsexception { final list < element > ret = new arraylist < > ( ) ; if ( _uiclass . isselected ( ) && ! _uiclass . isroot ( ) ) { final uifieldform fieldform ; if ( _uuid2instancekey . containskey ( _uiclass . getclassificationuuid ( ) ) ) { fieldform = new uifieldform ( getcommanduuid ( ) , _uuid2instancekey . get ( _uiclass . getclassificationuuid ( ) ) ) ; } else { fieldform = new uifieldform ( getcommanduuid ( ) , _uiclass ) ; if ( iseditmode ( ) ) {	Recursive method to add the children classification forms.
private charsequence getimage ( final uimenuitem _menuitem , final string _node ) { final string label = _menuitem . getlabel ( ) ; string content = str_ ; if ( stringutils . isnotempty ( label ) ) { content = stringutils . left ( label , num_ ) . touppercase ( ) ; } final stringbuilder js = new stringbuilder ( ) ; if ( stringutils . isnotempty ( _menuitem . getimage ( ) ) && _menuitem . getimage ( ) . endswith ( str_ ) ) { try { final querybuilder querbldr = new querybuilder ( ciadminuserinterface . image ) ; querbldr . addwhereattreqvalue ( ciadminuserinterface . image . name , _menuitem . getimage ( ) ) ; final instancequery query = querbldr . getquery ( ) ; query . execute ( ) ; if ( query . next ( ) ) { final checkout checkout = new checkout ( query . getcurrentvalue ( ) ) ; final bytearrayoutputstream os = new bytearrayoutputstream ( ) ; checkout . execute ( os ) ; final string svg = new string ( os . tobytearray ( ) , standardcharsets . utf_8 ) ; js . append ( str_ ) . append ( str_ ) . append ( stringescapeutils . escapeecmascript ( svg ) ) . append ( str_ ) . append ( str_ ) . append ( _node ) . append ( str_ ) ; } } catch ( final efapsexception e ) {	Gets the image.
protected ajaxeventbehavior getbehavior ( final class < ? extends behavior > _class ) { final slideinpanel panel = ( slideinpanel ) getparent ( ) ; return panel . visitchildren ( ajaxmenuitem . class , ( _item , _visit ) -> { final list < ? extends behavior > behaviors = _item . getbehaviors ( _class ) ; if ( collectionutils . isnotempty ( behaviors ) ) { _visit . stop ( ( ajaxeventbehavior ) behaviors . get ( num_ ) ) ; } else { _visit . stop ( ) ; } } ) ; }	Gets the behavior.
@ override public iterator < ? extends uistructurbrowser > getchildren ( final uistructurbrowser _node ) { if ( _node . isparent ( ) && ! _node . haschildren ( ) ) { _node . addchildren ( ) ; } return _node . getchildren ( ) . iterator ( ) ; }	Get the children of the given node.
public < u , be extends entitytype , bt extends tokentype > u makerequest ( final tokenproxy < be , bt > tokenproxy , final class < u > returntype , final backendcaller < ? super be , ? super bt > backendcaller ) throws hoderrorexception { return responseparser . parseresponse ( tokenproxy , returntype , backendcaller . makerequest ( getauthenticationtoken ( tokenproxy ) ) ) ; }	Makes a request to HP Haven OnDemand, converting the response body to the type specified by the Class object.
public < u , be extends entitytype , bt extends tokentype > u makerequest ( final tokenproxy < be , bt > tokenproxy , final typereference < u > typereference , final backendcaller < ? super be , ? super bt > backendcaller ) throws hoderrorexception { return responseparser . parseresponse ( tokenproxy , typereference , backendcaller . makerequest ( getauthenticationtoken ( tokenproxy ) ) ) ; }	Makes a request to HP Haven OnDemand, converting the response body to the type specified by the type reference.
public < be extends entitytype , bt extends tokentype > inputstream makerequest ( final tokenproxy < be , bt > tokenproxy , final backendcaller < ? super be , ? super bt > backendcaller ) throws hoderrorexception { return responseparser . parseresponse ( tokenproxy , backendcaller . makerequest ( getauthenticationtoken ( tokenproxy ) ) ) ; }	Makes a request to HP Haven OnDemand, returning the response body as an input stream.
@ override public object frombody ( final typedinput body , final type type ) throws conversionexception { try { return converter . frombody ( body , type ) ; } catch ( final conversionexception e ) { if ( e . getcause ( ) instanceof jsonparseexception ) { throw new hodunavailableexception ( e . getcause ( ) ) ; } else { throw e ; } } }	Returns the object returned by calling fromBody on the underlying converter.
@ override public void renderhead ( final component _component , final iheaderresponse _response ) { super . renderhead ( _component , _response ) ; _response . render ( abstractefapsheaderitem . forjavascript ( ajaxfieldupdatebehavior . js ) ) ; }	Render to the web response the eFapsContentReference.
@ override protected void onerror ( final ajaxrequesttarget _target ) { if ( this . errorhandling ) { final feedbackcollector collector = new feedbackcollector ( getform ( ) . getpage ( ) ) ; final list < feedbackmessage > msgs = collector . collect ( ) ; final stringbuilder html = new stringbuilder ( ) . append ( str_ ) ; for ( final feedbackmessage msg : msgs ) { msg . getreporter ( ) . add ( attributemodifier . append ( str_ , str_ ) ) ; _target . add ( msg . getreporter ( ) ) ; serializable warn = null ; if ( msg . getmessage ( ) instanceof validationerrorfeedback ) {	Default means nothing is done on error.
public executionbridge launch ( final ijob _job , final string _jobname ) throws efapsexception {	Launch a job.
public addtotextindexrequestbuilder addreferenceprefixes ( final string referenceprefix , final string ... referenceprefixes ) { this . referenceprefixes . add ( referenceprefix ) ; this . referenceprefixes . addall ( arrays . aslist ( referenceprefixes ) ) ; return this ; }	Adds values to the referencePrefixes parameter.
public addtotextindexrequestbuilder addadditionalmetadata ( final object metadatum , final object ... metadata ) { this . additionalmetadata . add ( metadatum ) ; this . additionalmetadata . addall ( arrays . aslist ( metadata ) ) ; return this ; }	Sets the value of the metadata parameter.
public queryprofilerequestbuilder addpromotioncategories ( final string category0 , final string ... categories ) { promotioncategories . add ( category0 ) ; promotioncategories . addall ( arrays . aslist ( categories ) ) ; return this ; }	Adds categories to the promotion_categories parameter.
public queryprofilerequestbuilder addsynonymcategories ( final string category0 , final string ... categories ) { synonymcategories . add ( category0 ) ; synonymcategories . addall ( arrays . aslist ( categories ) ) ; return this ; }	Adds categories to the synonym_categories parameter.
public queryprofilerequestbuilder addblacklistcategories ( final string category0 , final string ... categories ) { blacklistcategories . add ( category0 ) ; blacklistcategories . addall ( arrays . aslist ( categories ) ) ; return this ; }	Adds categories to the blacklist_categories parameter.
public void initiate ( final ipartialpagerequesthandler _target ) { final string url = getcallbackurl ( ) ; if ( url != null ) { _target . prependjavascript ( getcallbackscript ( url ) ) ; } }	Call this method to initiate the download.
@ override public void onrequest ( ) { final string filename = getfilename ( ) ; final iresourcestream stream = getresourcestream ( ) ; final resourcestreamrequesthandler handler = new resourcestreamrequesthandler ( stream , filename ) ; handler . setcontentdisposition ( contentdisposition . attachment ) ; getcomponent ( ) . getrequestcycle ( ) . schedulerequesthandleraftercurrent ( handler ) ; }	On request, respond with a ResourcStream.
protected iresourcestream getresourcestream ( ) { final file file = efapssession . get ( ) . getfile ( ) ; final fileresourcestream ret = new fileresourcestream ( file ) ; efapssession . get ( ) . setfile ( null ) ; return ret ; }	Hook method providing the actual resource stream.
protected charsequence getcallbackscript ( final string _url ) { final stringbuilder js = new stringbuilder ( ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( _url ) . append ( str_ ) . append ( str_ ) ; return dojowrapper . require ( js , dojoclasses . basewindow , dojoclasses . dom , dojoclasses . domconstruct ) ; }	Script that searches for an existing iframe to use it for the download of the frame.If it does not exist it will be created.
public void sendkeepalive ( final application _application ) { final long reference = new date ( ) . gettime ( ) ; final concurrentmap < string , ikey > sessionid2key = _application . getmetadata ( connectionregistry . session2key ) ; final concurrentmap < string , long > keepalive = _application . getmetadata ( connectionregistry . keepalive ) ; if ( keepalive != null ) { for ( final entry < string , long > entry : keepalive . entryset ( ) ) { if ( reference - entry . getvalue ( ) > configuration . getattributeasinteger ( configattribute . websocket_kath ) * num_ ) { final ikey key = sessionid2key . get ( entry . getkey ( ) ) ; if ( key != null ) { final iwebsocketconnectionregistry registry = websocketsettings . holder . get ( _application ) . getconnectionregistry ( ) ; final iwebsocketconnection conn = registry . getconnection ( _application , entry . getkey ( ) , key ) ; if ( conn != null ) { try { conn . sendmessage ( keepalivebehavior . msg ) ; connectionregistry . log . debug ( str_ , entry . getkey ( ) ) ; } catch ( final ioexception e ) { connectionregistry . log . error ( str_ , e ) ; } } } } } } }	Send the KeepAlive.
private void initkeepalive ( ) { if ( ! this . keepalive ) { this . keepalive = bool_ ; final keepalivetask keepalivetask = new keepalivetask ( efapsapplication . get ( ) . getapplicationkey ( ) ) ; final timer timer = new timer ( bool_ ) ;	Init the KeepAlive mechanism.
public static list < uiusersession > getuiusersessions ( ) { final list < uiusersession > ret = new arraylist < > ( ) ; final collection < usersession > usersessions = registrymanager . getusersessions ( ) ; for ( final usersession usersession : usersessions ) { ret . add ( new uiusersession ( usersession . getusername ( ) , usersession . getsessionid ( ) , usersession . getlastactivity ( ) ) ) ; } return ret ; }	Gets the UI user sessions.
@ override public void oncomponenttagbody ( final markupstream _markupstream , final componenttag _opentag ) { setescapemodelstrings ( bool_ ) ; string value = getdefaultmodelobjectasstring ( getdefaultmodelobject ( ) ) ;	Must be overwritten so that no replacing of html tags is done.
@ override protected void onrender ( ) { final imarkupfragment markup = getmarkup ( ) ; if ( markup == null ) { throw new markupexception ( str_ + tostring ( ) ) ; } final markupstream markupstream = new markupstream ( markup ) ;	Method is overwritten to prevent the annoing warnings from Component to come up.The warning come up due to the reason that this component moves the tags from parentelement to its child.
public static embeddedlink getdashboardlink ( final string _instancekey , final string _identifier ) { final embeddedlink ret = new embeddedlink ( _instancekey ) ; ret . settaghtml ( tag . dashboard . gethtml ( ) ) ; ret . setidentifier ( _identifier ) ; return ret ; }	Gets the dashboard link.
< t > t parseresponse ( final tokenproxy < ? , ? > tokenproxy , final class < t > clazz , final response response ) { return unsafeparseresponse ( tokenproxy , objectmapper . constructtype ( clazz ) , response ) ; }	Parse the response into a type represented by the Class object.
< t > t parseresponse ( final tokenproxy < ? , ? > tokenproxy , final typereference < t > typereference , final response response ) { return unsafeparseresponse ( tokenproxy , objectmapper . gettypefactory ( ) . constructtype ( typereference ) , response ) ; }	Parse the response into a type represented by the TypeReference object.
< t > t unsafeparseresponse ( final tokenproxy < ? , ? > tokenproxy , final javatype type , final response response ) { checkrefresh ( tokenproxy , response ) ; try { return objectmapper . readvalue ( response . getbody ( ) . in ( ) , type ) ; } catch ( final ioexception e ) { throw new runtimeexception ( e ) ; } }	Parse the response into a type represented by the JavaType object.
inputstream parseresponse ( final tokenproxy < ? , ? > tokenproxy , final response response ) { checkrefresh ( tokenproxy , response ) ; try { return response . getbody ( ) . in ( ) ; } catch ( final ioexception e ) { throw new runtimeexception ( e ) ; } }	Checks the response headers for a refreshed authentication token then returns the response body as an input stream.
@ override protected list < eventdefinition > getevents ( final eventtype _eventtype ) { return field . get ( this . fieldid ) . getevents ( _eventtype ) ; }	Method to get the events that are related to this UITable.
protected void oncomponenttaginternal ( final componenttag _tag ) { _tag . put ( str_ , getconfig ( ) . getname ( ) ) ; _tag . append ( str_ , str_ + getconfig ( ) . getalign ( ) , str_ ) ; }	Add to the tag.
@ override public void run ( ) { try { log . debug ( str_ , jobid ) ; final jobstatus < t > jobstatus ; if ( tokenproxy != null ) { jobstatus = jobservice . getjobstatus ( tokenproxy , jobid ) ; } else { jobstatus = jobservice . getjobstatus ( jobid ) ; } final status jobstatusstatus = jobstatus . getstatus ( ) ; if ( jobstatusstatus == status . finished || jobstatusstatus == status . failed ) { for ( final action < t > action : jobstatus . getactions ( ) ) { final status status = action . getstatus ( ) ; if ( status == status . finished ) { log . debug ( str_ ) ; callback . success ( action . getresult ( ) ) ; } else if ( status == status . failed ) { log . debug ( str_ ) ; for ( final hoderror error : action . geterrors ( ) ) { log . debug ( str_ , error ) ; callback . error ( error . geterrorcode ( ) ) ; } } } } else if ( timeout != null && timeout . isbefore ( localdatetime . now ( ) ) ) { callback . timeout ( ) ; log . debug ( str_ ) ; } else { log . debug ( str_ ) ;	Checks the status of the job. If the job has not finished, the runnable will schedule itself to run again after ashort wait.
@ override public void oncomponenttag ( final component _component , final componenttag _tag ) { super . oncomponenttag ( _component , _tag ) ; if ( this . type == dndbehavior . behaviortype . item ) { string value = str_ ; if ( _tag . getattribute ( str_ ) != null ) { value += _tag . getattribute ( str_ ) ; } _tag . put ( str_ , this . dndtype ) ; _tag . put ( str_ , value ) ; } }	The tag of the component must be altered, so that the dojo dnd will be rendered.
@ override public void renderhead ( final component _component , final iheaderresponse _response ) { super . renderhead ( _component , _response ) ; _response . render ( requireheaderitem . forclasses ( dojoclasses . dndsource , dojoclasses . parser ) ) ; if ( this . type == dndbehavior . behaviortype . source ) { final stringbuilder js = new stringbuilder ( ) . append ( str_ ) . append ( _component . getmarkupid ( bool_ ) ) . append ( str_ ) . append ( str_ + this . dndtype + str_ ) . append ( str_ ) . append ( this . appendjavascript ) . append ( str_ ) ; _response . render ( ondojoreadyheaderitem . forscript ( dojowrapper . require ( js , dojoclasses . aspect , dojoclasses . dom , dojoclasses . dndsource ) ) ) ; } }	Add the javascriupt to the head of the webpage.
public void setdefault ( final uuid _selectcmduuid ) { final uimenuitem menuitem = getprovider ( ) . getroots ( ) . next ( ) ; menuitem . setheader ( bool_ ) ; boolean hasdefault = bool_ ; for ( final uimenuitem childitem : menuitem . getchildren ( ) ) { if ( _selectcmduuid == null && childitem . isdefaultselected ( ) || _selectcmduuid != null && _selectcmduuid . equals ( childitem . getcommanduuid ( ) ) ) { hasdefault = bool_ ; childitem . setselected ( bool_ ) ; } } if ( ! hasdefault ) { menuitem . setselected ( bool_ ) ; } expand ( menuitem ) ; expandchildren ( menuitem ) ; }	Set the default selected item.
public static string getlabel ( final string _cmdname , final string _keytype ) { final string ret ; if ( dbproperties . hasproperty ( _cmdname + str_ + _keytype ) ) { ret = dbproperties . getproperty ( _cmdname + str_ + _keytype ) ; } else { ret = dbproperties . getproperty ( str_ + _keytype ) ; } return ret ; }	Method that gets the Value for the Buttons from the DBProperties.
@ override protected void onafterrender ( ) { super . onafterrender ( ) ; if ( getdefaultmodel ( ) != null ) { final uitableheader headermodel = ( uitableheader ) getdefaultmodelobject ( ) ; headermodel . setmarkupid ( this . getmarkupid ( ) ) ; } }	Set the markupid into the model.
public list < stringvalue > getdateasstring ( final list < stringvalue > _date , final list < stringvalue > _hour , final list < stringvalue > _minute , final list < stringvalue > _ampm ) throws efapsexception { final list < stringvalue > ret = new arraylist < > ( ) ; final list < datetime > dates = getdatelist ( _date , _hour , _minute , _ampm ) ; for ( final datetime date : dates ) { final datetimeformatter isofmt = isodatetimeformat . datetime ( ) ; ret . add ( stringvalue . valueof ( date . tostring ( isofmt ) ) ) ; } return ret ; }	Method to get for the parameters returned from the form as a valid string. for a datetime.
@ override protected void onafterrender ( ) { super . onafterrender ( ) ; final idatelistener container = this . findparent ( idatelistener . class ) ; if ( container != null ) { container . adddatecomponent ( this ) ; } }	After rendering the datefields are added to the parent.
public void destroy ( ) { log . debug ( str_ ) ; executorservice . shutdown ( ) ; try { if ( ! executorservice . awaittermination ( num_ , timeunit . seconds ) ) { log . debug ( str_ ) ; executorservice . shutdownnow ( ) ; } } catch ( final interruptedexception e ) { log . debug ( str_ ) ; executorservice . shutdownnow ( ) ; } }	Shuts down the executor service. This method should be called when the job service is no longer needed, if thedefault executor service was used.
@ override @ suppresswarnings ( str_ ) public void onclick ( final ajaxrequesttarget _target ) { instance instance = null ; try { if ( this . target . equals ( scripttarget . top ) ) { final pagereference reference = ( ( abstractcontentpage ) getpage ( ) ) . getcalledbypagereference ( ) ; if ( reference != null ) { final uimenuitem menuitem = ( uimenuitem ) ( ( contentcontainerpage ) reference . getpage ( ) ) . getmenutree ( ) . getselected ( ) . getdefaultmodelobject ( ) ; final recentobjectlink link = new recentobjectlink ( menuitem ) ; if ( link != null ) { ( ( efapssession ) getsession ( ) ) . addrecent ( link ) ; } } } final abstractuifield uifield = super . getmodelobject ( ) ; if ( uifield . getinstancekey ( ) != null ) { menu menu = null ; try { instance = uifield . getinstance ( ) ; menu = menu . gettypetreemenu ( instance . gettype ( ) ) ; } catch ( final exception e ) { if ( menu == null ) { throw new efapsexception ( loadintargetajaxlink . class , str_ , instance ) ; } } final contentcontainerpage page = new contentcontainerpage ( menu . getuuid ( ) , uifield . getinstancekey ( ) , uifield . getparent ( ) instanceof uistructurbrowser ) ; final charsequence url = urlfor ( new renderpagerequesthandler ( new pageprovider ( page ) ) ) ;	Method to load something inside the opener window.
@ override protected void oncomponenttag ( final componenttag _tag ) { if ( this . actionurl == null ) { this . actionurl = urlfor ( getrequestcycle ( ) . getactiverequesthandler ( ) ) . tostring ( ) ; } super . oncomponenttag ( _tag ) ; if ( getpage ( ) . getdefaultmodelobject ( ) != null ) {	On component tag.
private void resetsetcounter ( ) { if ( getpage ( ) . getdefaultmodelobject ( ) instanceof uiform ) { for ( final element element : ( ( uiform ) getpage ( ) . getdefaultmodelobject ( ) ) . getelements ( ) ) { if ( element . gettype ( ) . equals ( elementtype . form ) ) { final iterator < formrow > iter = ( ( uiform . formelement ) element . getelement ( ) ) . getrowmodels ( ) ; while ( iter . hasnext ( ) ) { final formrow row = iter . next ( ) ; for ( final iuielement uielement : row . getvalues ( ) ) { if ( uielement instanceof uifieldset ) { ( ( uifieldset ) uielement ) . resetindex ( ) ; } } } } else if ( element . gettype ( ) . equals ( elementtype . subform ) ) { for ( final element nelement : ( ( uifieldform ) element . getelement ( ) ) . getelements ( ) ) { if ( nelement . gettype ( ) . equals ( elementtype . form ) ) { final iterator < formrow > iter = ( ( uiform . formelement ) nelement . getelement ( ) ) . getrowmodels ( ) ; while ( iter . hasnext ( ) ) { final formrow row = iter . next ( ) ; for ( final iuielement uielement : row . getvalues ( ) ) { if ( uielement instanceof uifieldset ) { ( ( uifieldset ) uielement ) . resetindex ( ) ; } } } } } } } } }	Reset the counters for sets.
@ override public void init ( final filterconfig _filterconfig ) throws servletexception { super . init ( _filterconfig ) ; try { this . loginhandler = new loginhandler ( appaccesshandler . getapplicationkey ( ) ) ; } catch ( final efapsexception e ) { abstractauthenticationfilter . log . error ( str_ , e ) ; } }	Called by the web container to indicate to a filter that it is beingplaced into service.
@ override protected void dofilter ( final httpservletrequest _request , final httpservletresponse _response , final filterchain _chain ) throws ioexception , servletexception { if ( isloggedin ( _request ) ) { _chain . dofilter ( _request , _response ) ; } else { doauthenticate ( _request , _response , _chain ) ; } }	If the current user is already logged in, nothing is filtered.
protected boolean checklogin ( final string _name , final string _passwd ) { boolean loginok = bool_ ; context context = null ; try { context = context . begin ( ) ; boolean ok = bool_ ; try { if ( this . loginhandler . checklogin ( _name , _passwd ) != null ) { loginok = bool_ ; } ok = bool_ ; } finally { if ( ok && context . istmactive ( ) ) { context . commit ( ) ; } else { if ( context . istmmarkedrollback ( ) ) { abstractauthenticationfilter . log . error ( str_ ) ; } else { abstractauthenticationfilter . log . error ( str_ ) ; } context . rollback ( ) ; } } } catch ( final efapsexception e ) { abstractauthenticationfilter . log . error ( str_ , e ) ; } finally { context . close ( ) ; } return loginok ; }	Checks if the user with given name and password is allowed to login.
@ override public void onrequest ( final ajaxrequesttarget _target ) { final uicmdfield uiobject = ( uicmdfield ) getdefaultmodelobject ( ) ; final stringbuilder snip = new stringbuilder ( ) ; try { final abstractuipageobject pageobject = ( abstractuipageobject ) getpage ( ) . getdefaultmodelobject ( ) ; final map < string , string > uiid2oid = pageobject == null ? null : pageobject . getuiid2oid ( ) ; final list < return > returns = uiobject . executeevents ( null , uiid2oid ) ; for ( final return onereturn : returns ) { if ( onereturn . contains ( returnvalues . sniplett ) ) { snip . append ( onereturn . get ( returnvalues . sniplett ) ) ; } } } catch ( final efapsexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } _target . appendjavascript ( snip . tostring ( ) ) ; }	On submit.
protected charsequence getprintmenuitems ( final set < dojoclass > _dojoclasses ) { final stringbuilder ret = new stringbuilder ( ) ; collections . addall ( _dojoclasses , dojoclasses . menuitem ) ; final printbehavior printbehavior = ( printbehavior ) getbehavior ( printbehavior . class ) ; final string [ ] mimes = new string [ ] { str_ , str_ } ; for ( final string mime : mimes ) { if ( ret . length ( ) > num_ ) { ret . append ( str_ ) ; } ret . append ( str_ ) . append ( str_ ) . append ( mime ) . append ( str_ ) . append ( str_ ) . append ( mime . touppercase ( ) ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( str_ ) . append ( printbehavior . getcallbackfunctionbody ( callbackparameter . resolved ( str_ , str_ + mime + str_ ) , callbackparameter . explicit ( str_ ) , callbackparameter . explicit ( str_ ) ) ) . append ( str_ ) . append ( str_ ) ; } return ret ; }	Gets the prints the menu items.
protected charsequence getmenu ( final set < dojoclass > _dojoclasses ) throws efapsexception { final stringbuilder ret = new stringbuilder ( ) ; final uigrid uigrid = ( uigrid ) getdefaultmodelobject ( ) ; if ( ! ( uigrid instanceof uifieldgrid ) && uigrid . getcommand ( ) . gettargetmenu ( ) != null ) { collections . addall ( _dojoclasses , dojoclasses . menubar , dojoclasses . dropdownmenu , dojoclasses . menuitem , dojoclasses . popupmenubaritem , dojoclasses . menubaritem ) ; ret . append ( str_ ) ; for ( final abstractcommand child : uigrid . getcommand ( ) . gettargetmenu ( ) . getcommands ( ) ) { if ( child . hasaccess ( uigrid . getcommand ( ) . gettargetmode ( ) , uigrid . getinstance ( ) ) ) { if ( child instanceof abstractmenu ) { ret . append ( getsubmenu ( ( abstractmenu ) child , str_ ) ) ; } else { ret . append ( str_ ) . append ( getmenuitem ( child , bool_ ) ) . append ( str_ ) ; } } } } return ret ; }	Gets the menu.
protected charsequence getsubmenu ( final abstractmenu _menu , final string _parent ) throws efapsexception { final string var = randomutil . randomalphabetic ( num_ ) ; final stringbuilder js = new stringbuilder ( ) ; js . append ( str_ ) . append ( var ) . append ( str_ ) ; final uigrid uigrid = ( uigrid ) getdefaultmodelobject ( ) ; for ( final abstractcommand child : _menu . getcommands ( ) ) { if ( child . hasaccess ( uigrid . getcommand ( ) . gettargetmode ( ) , uigrid . getinstance ( ) ) ) { if ( child instanceof abstractmenu ) { js . append ( getsubmenu ( ( abstractmenu ) child , var ) ) ; } else { js . append ( var ) . append ( str_ ) . append ( getmenuitem ( child , bool_ ) ) . append ( str_ ) ; } } } js . append ( _parent ) . append ( str_ ) . append ( str_ ) . append ( stringescapeutils . escapeecmascript ( _menu . getlabelproperty ( ) ) ) . append ( str_ ) . append ( str_ ) . append ( var ) . append ( str_ ) . append ( str_ ) ; return js ; }	Gets the sub menu.
public static charsequence getdatajs ( final uigrid _uigrid ) throws efapsexception { final stringbuilder ret = new stringbuilder ( ) . append ( str_ ) ; int i = num_ ; for ( final gridrow row : _uigrid . getvalues ( ) ) { if ( i > num_ ) { ret . append ( str_ ) ; } ret . append ( getrowjs ( row , string . valueof ( i ) ) ) ; i ++ ; } ret . append ( str_ ) ; return ret ; }	Gets the data JS.
public static charsequence getdatareloadjs ( final uigrid _uigrid ) throws efapsexception { final stringbuilder js = new stringbuilder ( ) . append ( str_ ) . append ( str_ ) . append ( gridxcomponent . getdatajs ( _uigrid ) ) ; final stringbuilder dialogjs = new stringbuilder ( ) ; if ( ! _uigrid . iscolumnsuptodate ( ) ) {	Gets the javascript.
@ override protected void onevent ( final ajaxrequesttarget _target ) { final modalwindowcontainer modal = getcomponent ( ) . getpage ( ) . visitchildren ( modalwindowcontainer . class , new modalvisitor ( ) ) ; modal . show ( _target ) ; }	Show the modal window.
public void addvalue ( final instance _rowinstance , final uifieldsetvalue _uifieldsetvalue ) { this . instkey2row . get ( _rowinstance . getkey ( ) ) . add ( _uifieldsetvalue ) ; }	Adds the value.
public int getindex ( final string _inputname ) { integer ret = num_ ; if ( this . indexes . containskey ( _inputname ) ) { ret = this . indexes . get ( _inputname ) + num_ ; } this . indexes . put ( _inputname , ret ) ; return ret ; }	Gets the index.
public void addnewrow ( ) throws efapsexception { final uifieldsetrow row = new uifieldsetrow ( this ) ; this . rows . add ( row ) ; for ( final uifieldsetcolheader header : getheaders ( ) ) { final uivalue uivalue = uivalue . get ( field . get ( header . getfieldid ( ) ) , attribute . get ( header . getattrid ( ) ) , null ) ; final uifieldsetvalue cellsetvalue = new uifieldsetvalue ( getparent ( ) , null , this , uivalue ) ; row . add ( cellsetvalue ) ; } }	Add a new Row.
private void addchildren ( final uiclassification _uiclass , final boolean _force ) { if ( _force || _uiclass . isexpanded ( ) ) { getmodelobject ( ) . add ( _uiclass ) ; for ( final uiclassification child : _uiclass . getchildren ( ) ) { addchildren ( child , _force ) ; } } }	Recursive method to add child classifications.
public static charsequence gethelp ( final long _cmdid ) { charsequence ret ; try { final class < ? > clazz = class . forname ( configuration . getattribute ( configuration . configattribute . helpsnipprov ) , bool_ , efapsclassloader . getinstance ( ) ) ; final ihelpprovider provider = ( ihelpprovider ) clazz . newinstance ( ) ; ret = provider . gethelp ( _cmdid ) ; } catch ( final classnotfoundexception | instantiationexception | illegalaccessexception | efapsbaseexception e ) { helputil . log . error ( str_ , e ) ; ret = str_ ; } return ret ; }	Gets the help.
protected uistructurbrowser getnewstructurbrowser ( final instance _instance , final uistructurbrowser _strucbrwsr ) throws efapsexception { final uuid uuid ; if ( _strucbrwsr . gettable ( ) == null ) { uuid = menu . gettypetreemenu ( _instance . gettype ( ) ) . getuuid ( ) ; } else { uuid = _strucbrwsr . getcommanduuid ( ) ; } final uistructurbrowser ret = new uistructurbrowser ( uuid , _instance == null ? null : _instance . getkey ( ) , bool_ , _strucbrwsr . getsortdirection ( ) ) ; ret . setparentbrws ( this ) ; ret . setlevel ( getlevel ( ) + num_ ) ; return ret ; }	Internal method to call a constructor, it is used to set that thisStructurBrowserModel is not a root.
protected void initialise ( ) throws efapsexception { final abstractcommand command = getcommand ( ) ; if ( command != null && command . gettargettable ( ) != null ) { settableuuid ( command . gettargettable ( ) . getuuid ( ) ) ; this . browserfieldname = command . gettargetstructurbrowserfield ( ) ; setshowcheckboxes ( command . istargetshowcheckboxes ( ) ) ; } else if ( getinstance ( ) != null ) { final string tmplabel = menu . gettypetreemenu ( getinstance ( ) . gettype ( ) ) . getlabel ( ) ; this . valuelabel = dbproperties . getproperty ( tmplabel ) ; }	Method used to initialize this StructurBrowserModel.
@ suppresswarnings ( str_ ) protected void expand ( final boolean _expand ) { try {	Expand the tree with the information from the Session.
protected void sortmodel ( ) { setexecutionstatus ( uistructurbrowser . executionstatus . sort ) ; try { getobject4event ( ) . executeevents ( eventtype . ui_table_evaluate , parametervalues . class , this ) ; if ( getsortdirection ( ) == sortdirection . descending ) { collections . reverse ( this . children ) ; } } catch ( final efapsexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } }	Method to sort the data of this model.
public void checkhidecolumn4row ( ) { setexecutionstatus ( uistructurbrowser . executionstatus . checkhidecolumn4row ) ; try { getobject4event ( ) . executeevents ( eventtype . ui_table_evaluate , parametervalues . instance , getinstance ( ) , parametervalues . class , this ) ; } catch ( final efapsexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } }	Method is called from the StructurBrowser in edit mode before renderingthe columns for row to be able to hide the columns for different rows bysetting the cell model to hide.
protected boolean checkforallowchildren ( final instance _instance ) { setexecutionstatus ( uistructurbrowser . executionstatus . allowschildren ) ; try { final list < return > ret = getobject4event ( ) . executeevents ( eventtype . ui_table_evaluate , parametervalues . instance , _instance , parametervalues . class , this ) ; return ret . isempty ( ) ? bool_ : ret . get ( num_ ) . get ( returnvalues . true ) != null ; } catch ( final efapsexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } }	This method is used to check if a node has potential children.
public void executelistener ( final executionstatus _status , final map < string , string > _uiid2oid ) { setexecutionstatus ( _status ) ; try { getobject4event ( ) . executeevents ( eventtype . ui_table_evaluate , parametervalues . instance , getinstance ( ) , parametervalues . class , this , parametervalues . oidmap4ui , _uiid2oid ) ; } catch ( final efapsexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } }	This method is used to execute a listener with a specific event.
public void requerylabel ( ) { try { final valueparser parser = new valueparser ( new stringreader ( this . valuelabel ) ) ; final valuelist vallist = parser . expressionstring ( ) ; final printquery print = new printquery ( getinstance ( ) ) ; vallist . makeselect ( print ) ; if ( print . execute ( ) ) { setlabel ( vallist . makestring ( getinstance ( ) , print , getmode ( ) ) . tostring ( ) ) ; } } catch ( final efapsexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } catch ( final parseexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } }	This method is updating the Label, by querying the eFaps-DataBase.
@ override public final void bind ( final component _hostcomponent ) { args . notnull ( _hostcomponent , str_ ) ; if ( this . component != null ) { throw new illegalstateexception ( str_ + str_ + this . component + str_ + _hostcomponent + str_ ) ; } this . component = _hostcomponent ; this . component . setoutputmarkupid ( bool_ ) ; }	Bind this handler to the given component.
private datatable < element , void > getdatatable ( final indexsearch _indexsearch ) { final list < icolumn < element , void > > columns = new arraylist < > ( ) ; columns . add ( new abstractcolumn < element , void > ( new model < > ( str_ ) ) { private static final long serialversionuid = num_ ; @ override public void populateitem ( final item < icellpopulator < element > > _cellitem , final string _componentid , final imodel < element > _rowmodel ) { _cellitem . add ( new link ( _componentid , _rowmodel ) ) ; } } ) ; if ( _indexsearch . getsearch ( ) == null || _indexsearch . getsearch ( ) . getresultfields ( ) . isempty ( ) ) { columns . add ( new propertycolumn < element , void > ( new model < > ( str_ ) , str_ ) ) ; } else { for ( final entry < string , collection < string > > entry : _indexsearch . getsearch ( ) . getresultfields ( ) . entryset ( ) ) { columns . add ( new resultcolumn ( _indexsearch . getsearch ( ) . getresultlabel ( ) . get ( entry . getkey ( ) ) , entry . getvalue ( ) ) ) ; } } final datatable < element , void > ret = new datatable < > ( str_ , columns , _indexsearch . getdataprovider ( ) , _indexsearch . getsearch ( ) == null ? num_ : _indexsearch . getsearch ( ) . getnumhits ( ) ) ; ret . addtoptoolbar ( new headerstoolbar < > ( ret , null ) ) ; return ret ; }	Gets the data table.
public list < return > executeevents ( final object _others , final map < string , string > _uiid2oid ) throws efapsexception { if ( this . executionstatus == null ) { this . executionstatus = executionstatus . execute ; } final list < return > ret = executeevents ( eventtype . ui_field_cmd , _others , _uiid2oid ) ; if ( this . executionstatus == executionstatus . execute ) { this . executionstatus = null ; } return ret ; }	Execute the underlying events.
public string getrenderedcontent ( final string _script , final map < string , string > _uiid2oid ) throws efapsexception { this . executionstatus = uicmdfield . executionstatus . render ; final stringbuilder snip = new stringbuilder ( ) ; final list < return > returns = executeevents ( _script , _uiid2oid ) ; for ( final return onereturn : returns ) { if ( onereturn . contains ( returnvalues . sniplett ) ) { snip . append ( onereturn . get ( returnvalues . sniplett ) ) ; } } this . executionstatus = null ; return snip . tostring ( ) ; }	Get the script to render the content for the UserInterface in case thatnot a standard button should be rendered.
private abstractcommand getcommand ( final uuid _uuid ) throws cachereloadexception { abstractcommand cmd = command . get ( _uuid ) ; if ( cmd == null ) { cmd = menu . get ( _uuid ) ; if ( cmd == null ) { cmd = search . get ( _uuid ) ; } } return cmd ; }	Method to get a Command.
private string getlabel ( final icmduiobject _cmdobject , final string _keytype ) throws efapsexception { final string ret ; if ( dbproperties . hasproperty ( _cmdobject . getcommand ( ) . getname ( ) + str_ + _keytype ) ) { ret = dbproperties . getproperty ( _cmdobject . getcommand ( ) . getname ( ) + str_ + _keytype ) ; } else { ret = dbproperties . getproperty ( str_ + _keytype ) ; } return ret ; }	Method that searches a DBProperty for the Label.
public synchronized void prunefinishedtasks ( ) { final arraylist < iexecutionbridge > nonfinishedbridges = new arraylist < > ( ) ; for ( final iexecutionbridge bridge : this . executionbridges ) { if ( ! bridge . isfinished ( ) ) { nonfinishedbridges . add ( bridge ) ; } } this . executionbridges = nonfinishedbridges ; }	Prune finished tasks.
public iterator < iexecutionbridge > getjobspage ( final int _start , final int _size ) { final int min = math . min ( _size , this . executionbridges . size ( ) ) ; return new arraylist < > ( this . executionbridges . sublist ( _start , min ) ) . iterator ( ) ; }	Gets the tasks page.
public iexecutionbridge getbridge4job ( final string _jobname , final boolean _prune ) { iexecutionbridge ret = null ; for ( final iexecutionbridge bridge : this . executionbridges ) { if ( bridge . getjobname ( ) . equals ( _jobname ) ) { ret = bridge ; if ( _prune && ret . isfinished ( ) ) { this . executionbridges . remove ( ret ) ; } break ; } } return ret ; }	Gets the bridge for job.
public boolean islogedin ( ) { boolean ret = bool_ ; if ( this . username != null ) { ret = bool_ ; } else if ( ! issessioninvalidated ( ) ) { ret = lazylogin ( ) ; } return ret ; }	Method to check if a user is checked in.
private boolean lazylogin ( ) { boolean ret = bool_ ; final httpservletrequest httprequest = ( ( servletwebrequest ) requestcycle . get ( ) . getrequest ( ) ) . getcontainerrequest ( ) ; final httpsession httpsession = httprequest . getsession ( bool_ ) ; if ( httpsession != null && ! ( httpsession instanceof httpsessioncopy ) ) { for ( final iloginprovider loginprovider : efapsapplication . get ( ) . getloginproviders ( ) ) { this . username = loginprovider . login ( httpsession ) ; if ( this . username != null ) { break ; } } if ( this . username != null ) { opencontext ( ) ; try { setattribute ( efapssession . login_attribute_name , this . username ) ; this . sessionattributes . put ( userattributesset . contextmapkey , new userattributesset ( this . username ) ) ; } catch ( final efapsexception e ) { efapssession . log . error ( str_ , e ) ; } registrymanager . registerusersession ( this . username , getid ( ) ) ; ret = bool_ ; requestcycle . get ( ) . setresponsepage ( gatherinfopage . class ) ; } } return ret ; }	Lazy login is used in copmination with a Single Sign On mechanism.
public final void login ( ) { final irequestparameters paras = requestcycle . get ( ) . getrequest ( ) . getrequestparameters ( ) ; final stringvalue name = paras . getparametervalue ( str_ ) ; final stringvalue pwd = paras . getparametervalue ( str_ ) ; if ( checklogin ( name . tostring ( ) , pwd . tostring ( ) ) ) { this . username = name . tostring ( ) ;	Method to log a user with the Parameters from the Request in.
public final void logout ( ) { if ( this . sessionattributes . containskey ( userattributesset . contextmapkey ) ) { try { usageregistry . store ( ) ; ( ( userattributesset ) this . sessionattributes . get ( userattributesset . contextmapkey ) ) . storeindb ( ) ; accesscache . clean4person ( context . getthreadcontext ( ) . getpersonid ( ) ) ; } catch ( final efapsexception e ) { efapssession . log . error ( str_ , e ) ; } finally { this . sessionattributes . clear ( ) ; removeattribute ( efapssession . login_attribute_name ) ; invalidate ( ) ; } } closecontext ( ) ; this . username = null ; }	Logs a user out and stores the UserAttribues in the eFaps database.
public queryrequestbuilder addindexes ( final resourceidentifier index0 , final resourceidentifier ... indexes ) { this . indexes . add ( index0 ) ; this . indexes . addall ( arrays . aslist ( indexes ) ) ; return this ; }	Adds indexes to the indexes parameter.
public static imodel < icmduiobject > getmodel ( final long _cmdid , final instance _instance ) { return model . < icmduiobject > of ( uicmdobject . get ( _cmdid ) . setinstance ( _instance ) ) ; }	Gets the model.
@ suppresswarnings ( str_ ) protected void addcomponents ( final formcontainer _form ) throws efapsexception { this . form = _form ; add ( new keepalivebehavior ( ) ) ;	Method that adds the Components to the Page.
@ override public markupcontainer add ( final component ... _childs ) { markupcontainer ret = null ; for ( final component child : _childs ) { if ( child instanceof htmlheadercontainer ) { ret = add2page ( child ) ; } else { ret = body . add ( _childs ) ; } } return ret ; }	Adds a child component to this container or to the body.
private boolean convertdatefieldvalues ( final ajaxrequesttarget _target ) throws efapsexception { ajaxsubmitclosebutton . log . trace ( str_ ) ; boolean ret = bool_ ; final stringbuilder html = new stringbuilder ( ) ; html . append ( str_ ) ; final efapsrequestparametersadapter parameters = ( efapsrequestparametersadapter ) getrequest ( ) . getrequestparameters ( ) ; final set < string > names = parameters . getparameternames ( ) ; for ( final datetimepanel datepicker : ( ( formcontainer ) getform ( ) ) . getdatecomponents ( ) ) { if ( names . contains ( datepicker . getdatefieldname ( ) ) ) { final list < stringvalue > date = parameters . getparametervalues ( datepicker . getdatefieldname ( ) ) ; final list < stringvalue > hour = parameters . getparametervalues ( datepicker . gethourfieldname ( ) ) ; final list < stringvalue > minute = parameters . getparametervalues ( datepicker . getminutefieldname ( ) ) ; final list < stringvalue > ampm = parameters . getparametervalues ( datepicker . getampmfieldname ( ) ) ; ret = datepicker . validate ( date , hour , minute , ampm , html ) ; if ( ret ) { parameters . setparametervalues ( datepicker . getfieldname ( ) , datepicker . getdateasstring ( date , hour , minute , ampm ) ) ; } else { break ; } } } if ( ! ret ) { html . append ( str_ ) ; showdialog ( _target , html . tostring ( ) , bool_ , bool_ ) ; } return ret ; }	Method used to convert the date value from the ui in date values foreFaps.
private boolean convertfieldvalues ( final ajaxrequesttarget _target ) throws efapsexception { ajaxsubmitclosebutton . log . trace ( str_ ) ; final efapsrequestparametersadapter parameters = ( efapsrequestparametersadapter ) getrequest ( ) . getrequestparameters ( ) ; final formcontainer frmcontainer = ( formcontainer ) getform ( ) ; for ( final ivalueconverter converter : frmcontainer . getvalueconverters ( ) ) { converter . convertvalue ( parameters ) ; } return bool_ ; }	Method used to convert the values from the ui in values foreFaps.
@ override public void onerror ( final ajaxrequesttarget _target ) { final feedbackcollector collector = new feedbackcollector ( getform ( ) . getpage ( ) ) ; final list < feedbackmessage > msgs = collector . collect ( ) ; final errormessageresource msgresource = new errormessageresource ( ) ; final stringbuilder html = new stringbuilder ( ) . append ( str_ ) ; for ( final feedbackmessage msg : msgs ) { if ( ! ( msg . getreporter ( ) instanceof form ) ) { if ( msg . getreporter ( ) instanceof autocompletecombobox ) { final stringbuilder js = new stringbuilder ( ) . append ( str_ ) . append ( msg . getreporter ( ) . getmarkupid ( ) ) . append ( str_ ) ; _target . prependjavascript ( dojowrapper . require ( js , dojoclasses . dom , dojoclasses . domclass ) ) ; } else { msg . getreporter ( ) . add ( attributemodifier . append ( str_ , str_ ) ) ; _target . add ( msg . getreporter ( ) ) ; } } serializable warn = null ; if ( msg . getmessage ( ) instanceof validationerrorfeedback ) {	Method is not used, but needed from the api.
private boolean validatefieldvalues ( final ajaxrequesttarget _target ) throws efapsexception { ajaxsubmitclosebutton . log . trace ( str_ ) ; boolean ret = bool_ ; final icmduiobject uiobject = ( icmduiobject ) getpage ( ) . getdefaultmodelobject ( ) ; final stringbuilder html = new stringbuilder ( ) ; html . append ( str_ ) ; if ( uiobject instanceof uiform ) { final uiform uiform = ( uiform ) uiobject ; ret = evalformelement ( _target , html , uiform ) ; } if ( ! ret ) { html . append ( str_ ) ; showdialog ( _target , html . tostring ( ) , bool_ , bool_ ) ; } return ret ; }	Method to validate the values for fields.
private boolean evalformelement ( final ajaxrequesttarget _target , final stringbuilder _html , final uiform _uiform ) throws efapsexception { ajaxsubmitclosebutton . log . trace ( str_ ) ; boolean ret = bool_ ; for ( final element element : _uiform . getelements ( ) ) { if ( element . gettype ( ) . equals ( elementtype . form ) ) { final formelement formelement = ( formelement ) element . getelement ( ) ; for ( final iterator < formrow > uirowiter = formelement . getrowmodels ( ) ; uirowiter . hasnext ( ) ; ) { for ( final iuielement object : uirowiter . next ( ) . getvalues ( ) ) { } } } else if ( element . gettype ( ) . equals ( elementtype . subform ) ) { final uifieldform uifieldform = ( uifieldform ) element . getelement ( ) ; final boolean tmp = evalformelement ( _target , _html , uifieldform ) ; ret = ret ? tmp : ret ; } else if ( element . gettype ( ) . equals ( elementtype . table ) ) { final uifieldtable uifieldtable = ( uifieldtable ) element . getelement ( ) ; final list < uitableheader > headers = uifieldtable . getheaders ( ) ; for ( final uirow uirow : uifieldtable . getvalues ( ) ) { uirow . getuserinterfaceid ( ) ; final iterator < uitableheader > headeriter = headers . iterator ( ) ; for ( final ifilterable filterable : uirow . getcells ( ) ) { headeriter . next ( ) ; } } } } return ret ; }	Recursive method to validate the elements of the form.
private boolean checkforrequired ( final ajaxrequesttarget _target ) { ajaxsubmitclosebutton . log . trace ( str_ ) ; boolean ret = bool_ ; if ( ! ( getform ( ) . getparent ( ) . getdefaultmodel ( ) instanceof tablemodel ) ) { final irequestparameters parameters = getrequest ( ) . getrequestparameters ( ) ; final list < formpanel > panels = getformpanels ( ) ; for ( final formpanel panel : panels ) { for ( final entry < string , label > entry : panel . getrequiredcomponents ( ) . entryset ( ) ) { final stringvalue value = parameters . getparametervalue ( entry . getkey ( ) ) ; if ( value . isnull ( ) || value . isempty ( ) ) { final label label = entry . getvalue ( ) ; label . add ( attributemodifier . replace ( str_ , str_ ) ) ; _target . add ( label ) ; ret = bool_ ; } } } if ( ! ret ) { showdialog ( _target , str_ , bool_ , bool_ ) ; } } return ret ; }	Method checking if the mandatory field of the Form are filled with a value,and if not opens a WarnDialog and marks the fields in the Form via Ajax.
private list < formpanel > getformpanels ( ) { ajaxsubmitclosebutton . log . trace ( str_ ) ; final list < formpanel > ret = new arraylist < > ( ) ; final iterator < ? > iterator = getform ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { final object object = iterator . next ( ) ; if ( object instanceof webmarkupcontainer ) { final iterator < ? > iterator2 = ( ( webmarkupcontainer ) object ) . iterator ( ) ; while ( iterator2 . hasnext ( ) ) { final object object2 = iterator2 . next ( ) ; if ( object2 instanceof formpanel ) { ret . add ( ( formpanel ) object2 ) ; } } } } return ret ; }	Method to get the FormPanel of this Page.
private void showdialog ( final ajaxrequesttarget _target , final string _key , final boolean _issniplett , final boolean _goonbutton ) { final modalwindowcontainer modal = ( ( abstractcontentpage ) getpage ( ) ) . getmodal ( ) ; modal . setinitialwidth ( num_ ) ; modal . setinitialheight ( num_ ) ; modal . setpagecreator ( new modalwindow . pagecreator ( ) { private static final long serialversionuid = num_ ; @ override public page createpage ( ) { return new dialogpage ( ( ( abstractcontentpage ) getpage ( ) ) . getpagereference ( ) , _key , _issniplett , _goonbutton ) ; } } ) ; if ( _goonbutton ) { modal . setwindowclosedcallback ( new windowclosedcallback ( ) { private static final long serialversionuid = num_ ; @ override public void onclose ( final ajaxrequesttarget _target ) { if ( ajaxsubmitclosebutton . this . validated ) { _target . appendjavascript ( getexecutescript ( ) ) ; } } } ) ; } modal . show ( _target ) ; }	Shows a modal DialogPage.
@ override public void init ( final filterconfig _filterconfig ) throws servletexception { super . init ( _filterconfig ) ; final string root = str_ + _filterconfig . getservletcontext ( ) . getservletcontextname ( ) + str_ ; this . notloggedinforward = str_ + _filterconfig . getinitparameter ( transactionfilter . init_param_url_login_page ) ; if ( this . notloggedinforward == null || this . notloggedinforward . length ( ) == num_ ) { throw new servletexception ( str_ + str_ + transactionfilter . init_param_url_login_page + str_ ) ; } this . exludeuris . add ( ( root + this . notloggedinforward ) . replaceall ( str_ , str_ ) ) ; this . exludeuris . add ( ( root + str_ ) . replaceall ( str_ , str_ ) ) ; final serviceloader < iloginprovider > serviceloaderlogins = serviceloader . load ( iloginprovider . class ) ; for ( final iloginprovider loginprovider : serviceloaderlogins ) { log . info ( str_ , loginprovider ) ; this . loginproviders . add ( loginprovider ) ; } }	Called by the web container to indicate to a filter that it is beingplaced into service.
public static set < resourcetype > complementof ( final set < resourcetype > resourcetypes ) { final set < resourcetype > set = allof ( ) ; set . removeall ( resourcetypes ) ; return set ; }	Returns a set containing all the known resource types, except those is the given set.
public static set < resourcetype > of ( final resourcetype first , final resourcetype ... rest ) { final set < resourcetype > set = new hashset < > ( ) ; set . add ( first ) ; set . addall ( arrays . aslist ( rest ) ) ; return set ; }	Returns a set containing the given resource types.
private boolean ischeckout ( final abstractuifield _uifield ) { return stringutils . containsignorecase ( _uifield . getfieldconfiguration ( ) . getfield ( ) . getreference ( ) , href . checkout . tostring ( ) ) ; }	Checks if is a check out.
private boolean hasaccess2menu ( final abstractuifield _uifield ) throws efapsexception { final menu menu = menu . gettypetreemenu ( _uifield . getinstance ( ) . gettype ( ) ) ; return menu != null && menu . hasaccess ( _uifield . getparent ( ) . getmode ( ) , _uifield . getinstance ( ) ) && ( ! ( ( abstractuipageobject ) _uifield . getparent ( ) ) . getaccessmap ( ) . containskey ( _uifield . getinstance ( ) ) || ( ( abstractuipageobject ) _uifield . getparent ( ) ) . getaccessmap ( ) . containskey ( _uifield . getinstance ( ) ) && ( ( abstractuipageobject ) _uifield . getparent ( ) ) . getaccessmap ( ) . get ( _uifield . getinstance ( ) ) ) ; }	Checks for access to menu.
public string gettypeimage ( ) throws efapsexception { string ret = null ; if ( getinstance ( ) != null ) { final image imagetmp = image . gettypeicon ( getinstance ( ) . gettype ( ) ) ; if ( imagetmp != null ) { ret = imagetmp . getname ( ) ; } } return ret ; }	This method returns the URL to the Image of this MenuItem.
public boolean requerylabel ( ) { boolean ret = bool_ ; try { string labeltmp = dbproperties . getproperty ( getcommand ( ) . getlabel ( ) ) ; if ( getinstance ( ) != null ) { final valueparser parser = new valueparser ( new stringreader ( labeltmp ) ) ; final valuelist list = parser . expressionstring ( ) ; if ( list . getexpressions ( ) . size ( ) > num_ ) { final printquery print = new printquery ( getinstance ( ) ) ; list . makeselect ( print ) ; if ( print . execute ( ) ) { labeltmp = list . makestring ( getinstance ( ) , print , getmode ( ) ) ; } } } ret = ! labeltmp . equals ( this . label ) ; this . label = labeltmp ; } catch ( final efapsexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } catch ( final parseexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } return ret ; }	Requery the Label.
public static void removepages4session ( final string _sessionid ) { final advancedcache < string , storedpage > cache = infinispancache . get ( ) . < string , storedpage > getignrecache ( infinispanpagestore . pagecache ) ; final queryfactory queryfactory = search . getqueryfactory ( cache ) ; final query query = queryfactory . from ( storedpage . class ) . having ( str_ ) . eq ( _sessionid ) . build ( ) ; query . < storedpage > list ( ) . foreach ( storedpage -> cache . remove ( storedpage . getsessionid ( ) + str_ + storedpage . getpage ( ) . getpageid ( ) ) ) ; }	Removes the session.
@ override protected void oncomponenttag ( final componenttag _tag ) { _tag . setname ( str_ ) ; super . oncomponenttag ( _tag ) ; oncomponenttaginternal ( _tag ) ; }	The tag must be overwritten.
@ override public void onclick ( ) { instance instance = null ; final abstractuifield uifield = super . getmodelobject ( ) ; if ( uifield . getinstancekey ( ) != null ) { menu menu = null ; try { instance = uifield . getinstance ( ) ; menu = menu . gettypetreemenu ( instance . gettype ( ) ) ; } catch ( final efapsexception e ) { throw new restartresponseexception ( new errorpage ( e ) ) ; } if ( menu == null ) { final exception ex = new exception ( str_ + instance . gettype ( ) . getname ( ) ) ; throw new restartresponseexception ( new errorpage ( ex ) ) ; } page page ; try { page = new contentcontainerpage ( menu . getuuid ( ) , uifield . getinstancekey ( ) , getpage ( ) instanceof structurbrowserpage ) ; } catch ( final efapsexception e ) { page = new errorpage ( e ) ; } this . setresponsepage ( page ) ; } }	Method is executed on click.
private efapssession getefapssession ( final request _request ) { final isessionstore sessionstore = webapplication . get ( ) . getsessionstore ( ) ; final efapssession session = ( efapssession ) sessionstore . lookup ( _request ) ; return session ; }	Method to get the EFapsSession.
@ override public void onbeginrequest ( final requestcycle _cycle ) { final efapssession session = getefapssession ( _cycle . getrequest ( ) ) ; if ( session != null ) { session . opencontext ( ) ; registrymanager . registeractivity ( session ) ; } efapsrequestcyclelistener . log . debug ( str_ ) ; }	Called when the request cycle object is beginning its response.
@ override public void onendrequest ( final requestcycle _cycle ) { final efapssession session = getefapssession ( _cycle . getrequest ( ) ) ; if ( session != null ) { session . closecontext ( ) ; } efapsrequestcyclelistener . log . debug ( str_ ) ; }	Called when the request cycle object has finished its response.
public static void registerusersession ( final string _username , final string _sessionid ) { if ( efapsapplication . getmaxinactiveinterval ( ) > num_ ) { registrymanager . getcache ( ) . put ( _sessionid , new usersession ( ) . setusername ( _username ) . setsessionid ( _sessionid ) , - num_ , timeunit . minutes , efapsapplication . getmaxinactiveinterval ( ) + num_ , timeunit . seconds ) ; } else { registrymanager . getcache ( ) . put ( _sessionid , new usersession ( ) . setusername ( _username ) . setsessionid ( _sessionid ) ) ; } registrymanager . registerlogin4history ( _username , _sessionid ) ; }	Register user session.
public static void registeractivity ( final efapssession _session ) { if ( _session . islogedin ( ) && registrymanager . getcache ( ) . containskey ( _session . getid ( ) ) ) { final usersession usersession = registrymanager . getcache ( ) . get ( _session . getid ( ) ) ; if ( usersession . isinvalidated ( ) ) { _session . invalidate ( ) ; } else { usersession . registeractivity ( ) ; } } }	Register activity.
public static void addmsgconnection ( final string _sessionid , final ikey _key ) { if ( registrymanager . getcache ( ) . containskey ( _sessionid ) ) { registrymanager . getcache ( ) . get ( _sessionid ) . setconnectionkey ( _key ) ; } registrymanager . log . debug ( str_ , _sessionid ) ; }	Adds the msg connection.
public static void invalidatesession ( final string _sessionid ) { if ( registrymanager . getcache ( ) . containskey ( _sessionid ) ) { registrymanager . getcache ( ) . get ( _sessionid ) . markinvalid ( ) ; } }	Invalidate session.
public static void removeusersession ( final string _sessionid ) { if ( registrymanager . getcache ( ) . containskey ( _sessionid ) ) { registrymanager . registerlogout4history ( registrymanager . getcache ( ) . get ( _sessionid ) . getusername ( ) , _sessionid ) ; registrymanager . getcache ( ) . remove ( _sessionid ) ; } }	Removes the user session.
public static set < string > getusers ( ) { final set < string > ret = new hashset < > ( ) ; for ( final usersession usersession : registrymanager . getcache ( ) . values ( ) ) { ret . add ( usersession . getusername ( ) ) ; } return ret ; }	Gets the users.
public static list < iwebsocketconnection > getconnections4user ( final string _login ) { final list < iwebsocketconnection > ret = new arraylist < > ( ) ; final searchmanager searchmanager = search . getsearchmanager ( registrymanager . getcache ( ) ) ; final querybuilder qbldr = searchmanager . buildquerybuilderforclass ( usersession . class ) . get ( ) ; final cachequery < ? > query = searchmanager . getquery ( qbldr . keyword ( ) . onfield ( str_ ) . matching ( _login ) . createquery ( ) ) ; try ( resultiterator < ? > iter = query . iterator ( ) ) { while ( iter . hasnext ( ) ) { final usersession usersession = ( usersession ) iter . next ( ) ; if ( usersession . getconnectionkey ( ) != null ) { final iwebsocketconnectionregistry registry = websocketsettings . holder . get ( efapsapplication . get ( ) ) . getconnectionregistry ( ) ; final iwebsocketconnection conn = registry . getconnection ( efapsapplication . get ( ) , usersession . getsessionid ( ) , usersession . getconnectionkey ( ) ) ; if ( conn != null ) { ret . add ( conn ) ; } } } } return ret ; }	Gets the connections 4 user.
public static iwebsocketconnection getconnection4session ( final string _sessionid ) { iwebsocketconnection ret = null ; if ( registrymanager . getcache ( ) . containskey ( _sessionid ) ) { final usersession usersession = registrymanager . getcache ( ) . get ( _sessionid ) ; if ( usersession . getconnectionkey ( ) != null ) { final iwebsocketconnectionregistry registry = websocketsettings . holder . get ( efapsapplication . get ( ) ) . getconnectionregistry ( ) ; ret = registry . getconnection ( efapsapplication . get ( ) , usersession . getsessionid ( ) , usersession . getconnectionkey ( ) ) ; } } return ret ; }	Gets the connection 4 session.
private static cache < string , usersession > getcache ( ) {	Gets the cache.
protected void initialize ( final uuid _commanduuid , final string _openerid ) throws cachereloadexception { this . openerid = _openerid ; if ( _commanduuid != null ) { final abstractcommand command = getcommand ( _commanduuid ) ; this . cmduuid = command . getuuid ( ) ; setmode ( command . gettargetmode ( ) ) ; this . target = command . gettarget ( ) ; this . submit = command . issubmit ( ) ; if ( command . gettargetsearch ( ) != null && ! ( this instanceof uimenuitem ) ) { this . callingcmduuid = this . cmduuid ; this . cmduuid = command . gettargetsearch ( ) . getdefaultcommand ( ) . getuuid ( ) ; setmode ( targetmode . search ) ; if ( command . hasevents ( eventtype . ui_command_execute ) ) { this . submit = bool_ ; } } } }	Method initializes the model.
public abstractcommand getcallingcommand ( ) throws cachereloadexception { abstractcommand cmd = null ; if ( getcallingcommanduuid ( ) != null ) { cmd = command . get ( getcallingcommanduuid ( ) ) ; if ( cmd == null ) { cmd = menu . get ( getcallingcommanduuid ( ) ) ; } } return cmd ; }	Get the CommandAbstract which was originally called from the Frontend andlet to the construction of this model.
public list < return > executeevents ( final eventtype _eventtype , final object ... _objecttuples ) throws efapsexception { list < return > ret = new arraylist < > ( ) ; final abstractcommand command ; if ( this . callingcmduuid == null ) { command = this . getcommand ( ) ; } else { command = getcallingcommand ( ) ; } if ( command . hasevents ( _eventtype ) ) { final parameter param = new parameter ( ) ; if ( _objecttuples != null ) {	Execute the events.
private void addbehaviors ( ) { if ( this . uifield . getfieldconfiguration ( ) . getfield ( ) . hasevents ( eventtype . ui_field_update ) ) { final list < eventdefinition > events = this . uifield . getfieldconfiguration ( ) . getfield ( ) . getevents ( eventtype . ui_field_update ) ; string eventname = str_ ; for ( final eventdefinition event : events ) { eventname = event . getproperty ( str_ ) == null ? str_ : event . getproperty ( str_ ) ; } add ( new ajaxfieldupdatebehavior ( eventname , model . of ( this . uifield ) , bool_ ) { private static final long serialversionuid = num_ ; @ override protected void onsubmit ( final ajaxrequesttarget _target ) {	Adds the behaviors.
public int getwidthweight ( ) { int ret = num_ ; if ( ! isfixedwidth ( ) && hasproperty ( uiformfieldproperty . width ) ) { ret = integer . valueof ( getproperty ( uiformfieldproperty . width ) ) ; } return ret ; }	Gets the width weight.
public string evallabel ( final uivalue _uivalue , final instance _fieldinst ) throws cachereloadexception { final string key ; if ( getfield ( ) . getlabel ( ) == null ) { if ( _uivalue != null && _uivalue . getattribute ( ) != null ) { if ( _fieldinst != null && _fieldinst . isvalid ( ) && _fieldinst . gettype ( ) . getattribute ( _uivalue . getattribute ( ) . getname ( ) ) != null ) { key = _fieldinst . gettype ( ) . getattribute ( _uivalue . getattribute ( ) . getname ( ) ) . getlabelkey ( ) ; } else if ( _uivalue . getinstance ( ) != null && _uivalue . getinstance ( ) . gettype ( ) . getattribute ( _uivalue . getattribute ( ) . getname ( ) ) != null ) { key = _uivalue . getinstance ( ) . gettype ( ) . getattribute ( _uivalue . getattribute ( ) . getname ( ) ) . getlabelkey ( ) ; } else { key = _uivalue . getattribute ( ) . getlabelkey ( ) ; } } else { key = fieldconfiguration . class . getname ( ) + str_ ; } } else { key = getfield ( ) . getlabel ( ) ; } this . label = dbproperties . getproperty ( key ) ; return this . label ; }	Evaluate the label.
public boolean istablefield ( ) { boolean ret = bool_ ; try { ret = getfield ( ) . getcollection ( ) instanceof table ; } catch ( final cachereloadexception e ) { log . error ( str_ , e ) ; } return ret ; }	Checks if is table.
public static fieldconfiguration getsimfieldconfig ( final string _fieldname ) { final field field = new field ( num_ , str_ , _fieldname ) ; final fieldconfiguration ret = new fieldconfiguration ( num_ ) { private static final long serialversionuid = num_ ; @ override public field getfield ( ) { return field ; } } ; return ret ; }	Gets the field config.
public boolean isvisible ( ) { initialize ( ) ; boolean ret = bool_ ; try { ret = this . snipplet . isvisible ( ) ; } catch ( final efapsbaseexception e ) { esjpinvoker . log . error ( str_ , e ) ; } return ret ; }	Checks if is visible.
@ override protected void respond ( final ajaxrequesttarget _target ) { final stringvalue horizontal = getcomponent ( ) . getrequest ( ) . getrequestparameters ( ) . getparametervalue ( ajaxstorepositionbehavior . parameter_horizontalposition ) ; final stringvalue verticaltmp = getcomponent ( ) . getrequest ( ) . getrequestparameters ( ) . getparametervalue ( ajaxstorepositionbehavior . parameter_verticalposition ) ; if ( ! horizontal . isnull ( ) ) { configuration . setattribute ( configattribute . splitterposhorizontal , horizontal . tostring ( ) ) ; } if ( ! verticaltmp . isnull ( ) ) { configuration . setattribute ( configattribute . splitterposvertical , verticaltmp . tostring ( ) ) ; } }	On request the values are stored.
protected void initialize ( final imodel < t > _model , final efapscontentreference _reference , final string _label ) { final buttonlink < t > link ; if ( _model == null ) { link = new buttonlink < > ( str_ ) ; } else { link = new buttonlink < > ( str_ , _model ) ; } add ( link ) ; link . add ( new buttonimage ( str_ , _reference ) ) ; link . add ( new label ( str_ , _label == null ? str_ : _label ) ) ; }	Init the component.
@ suppresswarnings ( str_ ) @ override public iterator < map < string , string > > getchoices ( final string _input ) { final list < map < string , string > > retlist = new arraylist < map < string , string > > ( ) ; try { final abstractuipageobject pageobject = ( abstractuipageobject ) getpage ( ) . getdefaultmodelobject ( ) ; final map < string , string > uiid2oid = pageobject == null ? null : pageobject . getuiid2oid ( ) ; final list < return > returns = this . autocomplete . getautocompletion ( _input , uiid2oid ) ; for ( final return areturn : returns ) { final object ob = areturn . get ( returnvalues . values ) ; if ( ob instanceof list ) { retlist . addall ( ( collection < ? extends map < string , string > > ) ob ) ; } } } catch ( final efapsexception e ) { autocompletecombobox . log . error ( str_ , e ) ; } return retlist . iterator ( ) ; }	Method to get the values from the esjp.
public static datetimeformatter getdatetimeformatter ( ) throws efapsexception { final string formatstr = configuration . getattribute ( configuration . configattribute . format_datetime ) ; final datetimeformatter ret ; if ( formatstr . matches ( str_ ) ) { ret = datetimeformat . forstyle ( formatstr ) ; } else { ret = datetimeformat . forpattern ( formatstr ) ; } return ret . withlocale ( context . getthreadcontext ( ) . getlocale ( ) ) ; }	Gets the date time formatter.
@ override protected void doget ( final httpservletrequest _req , final httpservletresponse _resp ) throws servletexception { string filename = _req . getrequesturi ( ) ; filename = filename . substring ( filename . lastindexof ( str_ ) + num_ ) ; try { final person pers = context . getthreadcontext ( ) . getperson ( ) ; if ( pers != null ) { final file file = getfile ( pers . getid ( ) , filename ) ; if ( file != null && file . exists ( ) ) { _resp . setcontenttype ( getservletcontext ( ) . getmimetype ( file . getname ( ) ) ) ; _resp . setcontentlength ( ( int ) file . length ( ) ) ; _resp . setdateheader ( str_ , system . currenttimemillis ( ) ) ; _resp . setdateheader ( str_ , system . currenttimemillis ( ) ) ; _resp . addheader ( str_ , str_ + file . getname ( ) + str_ ) ; _resp . setheader ( str_ , str_ ) ; final fileinputstream input = new fileinputstream ( file ) ; ioutils . copy ( input , _resp . getoutputstream ( ) ) ; } } } catch ( final efapsexception e ) { fileservlet . log . error ( str_ , e ) ; throw new servletexception ( e ) ; } catch ( final ioexception e ) { fileservlet . log . error ( str_ , e ) ; throw new servletexception ( e ) ; } }	Search for the requested file in the folder corresponding to the user of the context.
private string getmenu ( ) throws efapsexception { helpservlet . log . debug ( str_ ) ; final stringbuilder ret = new stringbuilder ( ) ; ret . append ( str_ ) ; final querybuilder querybldr = new querybuilder ( type . get ( str_ ) ) ;	get the CharSequence for the menu.
private void initialise ( ) throws efapsexception { final abstractcommand command = getcommand ( ) ; if ( command == null ) { setshowcheckboxes ( bool_ ) ; } else {	Method that initializes the TableModel.
@ suppresswarnings ( str_ ) protected list < instance > getinstancelist ( ) throws efapsexception {	Method to get the list of instance.
public void addfilterlist ( final uitableheader _uitableheader , final set < ? > _list ) { final tablefilter filter = new tablefilter ( _uitableheader , _list ) ; this . filters . put ( _uitableheader . getfieldname ( ) , filter ) ; final uitableheader orig = getheader4id ( _uitableheader . getfieldid ( ) ) ; if ( orig != null ) { orig . setfilterapplied ( bool_ ) ; } storefilters ( ) ; }	Add a filterlist to the filters of this UiTable.
public void addfilterclassifcation ( final uitableheader _uitableheader , final uiclassification _uiclassification ) throws efapsexception { final tablefilter filter = new tablefilter ( _uitableheader , _uiclassification ) ; this . filters . put ( _uitableheader . getfieldname ( ) , filter ) ; final uitableheader orig = getheader4id ( _uitableheader . getfieldid ( ) ) ; if ( orig != null ) { orig . setfilterapplied ( bool_ ) ; } storefilters ( ) ; }	Add a classification based filters of this UiTable.
public tablefilter getfilter ( final uitableheader _uitableheader ) throws efapsexception { tablefilter ret = this . filters . get ( _uitableheader . getfieldname ( ) ) ; if ( ret != null && ret . getuitableheader ( ) == null ) { ret = new tablefilter ( _uitableheader ) ; this . filters . put ( _uitableheader . getfieldname ( ) , ret ) ; } return ret ; }	Method to get a Filter from the list of filters belonging to thisUITable.
public list < string > getfilterpicklist ( final uitableheader _uitableheader ) throws efapsexception { final list < string > ret = new arraylist < > ( ) ; for ( final uirow rowmodel : this . values ) { for ( final ifilterable cell : rowmodel . getcells ( ) ) { if ( cell . belongsto ( _uitableheader . getfieldid ( ) ) ) { final string value = cell . getpicklistvalue ( ) ; if ( ! ret . contains ( value ) ) { ret . add ( value ) ; } break ; } } } collections . sort ( ret ) ; return ret ; }	Get the List of values for a PICKERLIST.
private list < status > getstatus4type ( final type _type ) throws cachereloadexception { final list < status > ret = new arraylist < > ( ) ; final statusgroup grp = status . get ( _type . getuuid ( ) ) ; if ( grp != null ) { ret . addall ( grp . values ( ) ) ; } else { for ( final type type : _type . getchildtypes ( ) ) { ret . addall ( getstatus4type ( type ) ) ; } } return ret ; }	Recursive method to get all status for a Type representing a StatusGrp.
private void storefilters ( ) { final map < string , tablefilter > sessfilter = new hashmap < > ( ) ; for ( final entry < string , tablefilter > entry : this . filters . entryset ( ) ) { sessfilter . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; } try { context . getthreadcontext ( ) . setsessionattribute ( getcachekey ( uitable . usercachekey . filter ) , sessfilter ) ; } catch ( final efapsexception e ) { uitable . log . error ( str_ , getcommanduuid ( ) , e ) ; } }	Store the Filter in the Session.
public void removefilter ( final uitableheader _uitableheader ) { this . filters . remove ( _uitableheader . getfieldname ( ) ) ; final uitableheader orig = getheader4id ( _uitableheader . getfieldid ( ) ) ; if ( orig != null ) { orig . setfilterapplied ( bool_ ) ; } storefilters ( ) ; }	Method to remove a filter from the filters.
@ suppresswarnings ( str_ ) protected list < instance > getinstances ( ) throws efapsexception { final list < return > returns = geteventobject ( ) . executeevents ( eventtype . ui_table_evaluate , parametervalues . instance , getcallinstance ( ) , parametervalues . call_instance , getcallinstance ( ) , parametervalues . parameters , context . getthreadcontext ( ) . getparameters ( ) , parametervalues . class , this , parametervalues . others , this . filterlist ) ; list < instance > ret = null ; if ( returns . size ( ) < num_ ) { throw new efapsexception ( uigrid . class , str_ ) ; } else { final object result = returns . get ( num_ ) . get ( returnvalues . values ) ; if ( result instanceof list ) { ret = ( list < instance > ) result ; } } return ret ; }	Gets the instances.
protected ifilter getfilter4field ( final field _field ) { final ifilter ret ; switch ( _field . getfilter ( ) . gettype ( ) ) { case status : case picklist : ret = new listfilter ( _field . getid ( ) ) ; break ; case freetext : case form : ret = new mapfilter ( _field . getid ( ) ) ; break ; case classification : ret = new classificationfilter ( _field . getid ( ) ) ; break ; case none : default : ret = new ifilter ( ) { private static final long serialversionuid = num_ ; @ override public long getfieldid ( ) { return _field . getid ( ) ; } } ; break ; } return ret ; }	Gets the filter for field.
@ override public abstractcommand getcommand ( ) throws cachereloadexception { abstractcommand cmd = command . get ( getcmduuid ( ) ) ; if ( cmd == null ) { cmd = menu . get ( getcmduuid ( ) ) ; } return cmd ; }	Gets the command.
public string gettitle ( ) { string title = str_ ; try { final string key = getcommand ( ) . gettargettitle ( ) == null ? getcommand ( ) . getname ( ) + str_ : getcommand ( ) . gettargettitle ( ) ; title = dbproperties . getproperty ( key ) ; if ( title != null && getcallinstance ( ) != null ) { final printquery print = new printquery ( getcallinstance ( ) ) ; final valueparser parser = new valueparser ( new stringreader ( title ) ) ; final valuelist list = parser . expressionstring ( ) ; list . makeselect ( print ) ; if ( print . execute ( ) ) { title = list . makestring ( getcallinstance ( ) , print , targetmode . view ) ; }	This method retrieves the Value for the Title from the eFaps Database.
public boolean isdatefilter ( final ifilter _filter ) throws efapsexception { final boolean ret ; final field field = field . get ( _filter . getfieldid ( ) ) ;	Checks if is date filter.
public gridrow getrow4id ( final string _rowid ) throws efapsexception { final string [ ] rowids = _rowid . split ( str_ ) ; gridrow row = null ; for ( final string id : rowids ) { if ( row == null ) { row = getvalues ( ) . get ( integer . parseint ( id ) ) ; } else { row = row . getchildren ( ) . get ( integer . parseint ( id ) ) ; } } return row ; }	Gets the row for id.
public static file print ( final uigrid _uigrid ) { file ret = null ; final string clazzname = configuration . getattribute ( configattribute . gridprintesjp ) ; try { uigrid . log . debug ( str_ , _uigrid ) ; final class < ? > clazz = class . forname ( clazzname , bool_ , efapsclassloader . getinstance ( ) ) ; final eventexecution event = ( eventexecution ) clazz . newinstance ( ) ; final parameter param = new parameter ( ) ; param . put ( parametervalues . parameters , context . getthreadcontext ( ) . getparameters ( ) ) ; param . put ( parametervalues . class , _uigrid ) ; final return retu = event . execute ( param ) ; if ( retu != null ) { ret = ( file ) retu . get ( returnvalues . values ) ; } } catch ( final classnotfoundexception | instantiationexception | illegalaccessexception e ) { uigrid . log . error ( str_ , e ) ; } catch ( final efapsexception e ) { uigrid . log . error ( str_ , e ) ; } return ret ; }	Prints the.
protected string getquery ( ) { final stringbuilder ret = new stringbuilder ( ) ; try { final string clazzname ; if ( efapssystemconfiguration . get ( ) . containsattributevalue ( str_ ) ) { clazzname = efapssystemconfiguration . get ( ) . getattributevalue ( str_ ) ; } else { clazzname = str_ ; } final class < ? > clazz = class . forname ( clazzname , bool_ , efapsclassloader . getinstance ( ) ) ; final object obj = clazz . newinstance ( ) ; final method method = clazz . getmethod ( str_ , string . class , list . class , list . class ) ; final object newquery = method . invoke ( obj , getcurrentquery ( ) , getincluded ( ) , getexcluded ( ) ) ; ret . append ( newquery ) ; } catch ( final efapsexception | classnotfoundexception | instantiationexception | illegalaccessexception | nosuchmethodexception | securityexception | illegalargumentexception | invocationtargetexception e ) { indexsearch . log . error ( str_ , e ) ; ret . append ( getcurrentquery ( ) ) ; } return ret . tostring ( ) ; }	Gets the query.
private list < dimvalue > getexcluded ( ) { final list < dimvalue > ret = new arraylist < > ( ) ; for ( final dimtreenode node : getdimensionprovider ( ) . getrootlist ( ) ) { ret . addall ( node . getexcluded ( ) ) ; } return ret ; }	Gets the excluded.
private boolean dimfilterapplied ( final list < dimtreenode > _nodes ) { final list < dimtreenode > nodes = _nodes == null ? getdimensionprovider ( ) . getrootlist ( ) : _nodes ; boolean ret = bool_ ; for ( final dimtreenode node : nodes ) { if ( node . getstatus ( ) != null ) { ret = bool_ ; break ; } ret = dimfilterapplied ( node . getchildren ( ) ) ; if ( ret ) { break ; } } return ret ; }	Check if a dimension filter applied.
private void filldimensionprovider ( final boolean _updatedim ) { final dimensionprovider provider = getdimensionprovider ( ) ; final iterator < ? extends dimtreenode > currentiter = provider . getroots ( ) ; final list < dimension > dims = getdimensions ( ) ; if ( _updatedim && dims . isempty ( ) ) { provider . getrootlist ( ) . clear ( ) ; } else { collections . sort ( dims , new comparator < dimension > ( ) { @ override public int compare ( final dimension _arg0 , final dimension _arg1 ) { final string dim0 = dbproperties . getproperty ( dimensionpanel . class . getname ( ) + str_ + _arg0 . getkey ( ) ) ; final string dim1 = dbproperties . getproperty ( dimensionpanel . class . getname ( ) + str_ + _arg1 . getkey ( ) ) ; return dim0 . compareto ( dim1 ) ; } } ) ; final iterator < dimension > newdimsiter = dims . iterator ( ) ; while ( currentiter . hasnext ( ) ) { final dimtreenode current = currentiter . next ( ) ; if ( newdimsiter . hasnext ( ) ) { final dimension newdim = newdimsiter . next ( ) ; if ( ! newdim . getkey ( ) . equals ( ( ( dimension ) current . getvalue ( ) ) . getkey ( ) ) ) { currentiter . remove ( ) ; } else if ( _updatedim ) { current . update ( newdim . getvalues ( ) ) ; } } }	Fill dimension provider.
private map < string , object > buildhierarchyparameters ( final list < string > parents , final list < string > children ) { final multimap < string , object > parameters = new multimap < > ( ) ; if ( parents != null ) { for ( final string parent : parents ) { parameters . put ( str_ , parent ) ; } } if ( children != null ) { for ( final string child : children ) { parameters . put ( str_ , child ) ; } } return parameters ; }	Build the hierarchy parameters map for a create group request.
public static boolean rootelementmatches ( fileresource fileresource , string path , string expectedrootelement ) throws ioexception { try ( inputstream stream = fileresource . createstream ( ) ) { xmlstreamreader reader = factory . createxmlstreamreader ( stream ) ; while ( reader . hasnext ( ) ) { int event = reader . next ( ) ; switch ( event ) { case xmlstreamconstants . start_element : string rootelement = reader . getlocalname ( ) ; return expectedrootelement . equals ( rootelement ) ; } } } catch ( xmlstreamexception e ) { logger . warn ( str_ , path ) ; } return bool_ ; }	Matches a file resource for being an XML file with a specific rootelement.
public boolean touch ( ) { if ( expireafteraccess > num_ ) { long now = system . currenttimemillis ( ) ; if ( lastaccesstimestampms + last_access_threshold_ms < now ) { lastaccesstimestampms = now ; return bool_ ; } } return bool_ ; }	"Touch" the cache entry.
protected void refreshttl ( string key , cacheentry ce ) { final string key = calccachekey ( key ) ; final long ttl = ce . getexpireafteraccess ( ) ; try ( shardedjedis jedis = getjedis ( ) ) { if ( ttl > num_ ) { if ( keymode == keymode . hash ) { jedis . expire ( getname ( ) , ( int ) ttl ) ; } else { jedis . expire ( safeencoder . encode ( key ) , ( int ) ttl ) ; } } } catch ( exception e ) { throw e instanceof cacheexception ? ( cacheexception ) e : new cacheexception ( e ) ; } }	Refresh TTL of a cache entry.
public static object tryclone ( object tobecloned ) { if ( tobecloned == null ) { return null ; } object clonedobj = null ; if ( tobecloned instanceof cloneable ) { try { method method = object . class . getdeclaredmethod ( str_ ) ; method . setaccessible ( bool_ ) ; clonedobj = method . invoke ( tobecloned ) ; } catch ( exception e ) { if ( e instanceof clonenotsupportedexception ) { clonedobj = tobecloned ; } else { throw e instanceof runtimeexception ? ( runtimeexception ) e : new runtimeexception ( e ) ; } } } else { clonedobj = tobecloned ; } return clonedobj ; }	Try cloning an object.
public abstractcache init ( ) { long oldcapacity = this . capacity ; try { string entry = getcacheproperty ( cache_prop_capacity ) ; if ( entry != null ) { this . capacity = long . parselong ( entry ) ; } } catch ( exception e ) { this . capacity = oldcapacity ; logger . warn ( e . getmessage ( ) , e ) ; } if ( capacity < - num_ ) { setcapacity ( - num_ ) ; } long oldexpireafteraccess = this . expireafteraccess ; try { string entry = getcacheproperty ( cache_prop_expire_after_access ) ; if ( entry != null ) { this . expireafteraccess = long . parselong ( entry ) ; } } catch ( exception e ) { this . expireafteraccess = oldexpireafteraccess ; logger . warn ( e . getmessage ( ) , e ) ; } if ( expireafteraccess < - num_ ) { setexpireafteraccess ( - num_ ) ; } long oldexpireafterwrite = this . expireafterwrite ; try { string entry = getcacheproperty ( cache_prop_expire_after_write ) ; if ( entry != null ) { this . expireafterwrite = long . parselong ( entry ) ; } } catch ( exception e ) { this . expireafterwrite = oldexpireafterwrite ; logger . warn ( e . getmessage ( ) , e ) ; } if ( expireafterwrite < - num_ ) { setexpireafterwrite ( - num_ ) ; } return this ; }	Initializes the cache before use.
public abstractcache setcacheproperties ( properties cacheprops ) { this . cacheprops = cacheprops != null ? new properties ( cacheprops ) : new properties ( ) ; return this ; }	Cache's custom properties.
protected string getcacheproperty ( string key ) { return cacheprops != null ? cacheprops . getproperty ( key ) : null ; }	Get cache's custom property.
protected string calccachekey ( string key ) { switch ( keymode ) { case hash : case monopolistic : return key ; case namespace : return getname ( ) + str_ + key ; default : throw new illegalstateexception ( str_ + keymode ) ; } }	Calculates cache key based on the key mode. HASH & MONOPOLISTIC mode: return the key as-is NAMESPACE mode: return {.
protected properties getcacheproperties ( string name ) { return cacheproperties != null ? cacheproperties . get ( name ) : null ; }	Gets a cache's properties.
@ override public void set ( string key , object entry , long expireafterwrite , long expireafteraccess ) { try { if ( localcache != null ) { localcache . set ( key , entry , expireafterwrite , expireafteraccess ) ; } if ( remotecache != null ) { remotecache . set ( key , entry , expireafterwrite , expireafteraccess ) ; } } catch ( exception e ) { throw e instanceof cacheexception ? ( cacheexception ) e : new cacheexception ( e ) ; } }	Puts an entry to both local and remote caches, with specified expiries.
@ override public void delete ( string key ) { try { if ( localcache != null ) { localcache . delete ( key ) ; } if ( remotecache != null ) { remotecache . delete ( key ) ; } } catch ( exception e ) { throw e instanceof cacheexception ? ( cacheexception ) e : new cacheexception ( e ) ; } }	Delete an entry from both local and remote caches.
public void deletelocal ( string key ) { if ( localcache != null ) { try { localcache . delete ( key ) ; } catch ( exception e ) { throw e instanceof cacheexception ? ( cacheexception ) e : new cacheexception ( e ) ; } } }	Delete an entry from the local cache.
@ override public void deleteall ( ) { try { if ( localcache != null ) { localcache . deleteall ( ) ; } if ( remotecache != null ) { remotecache . deleteall ( ) ; } } catch ( exception e ) { throw e instanceof cacheexception ? ( cacheexception ) e : new cacheexception ( e ) ; } }	Deletes all entries in both local and remote caches.
public void deletealllocal ( ) { if ( localcache != null ) { try { localcache . deleteall ( ) ; } catch ( exception e ) { throw e instanceof cacheexception ? ( cacheexception ) e : new cacheexception ( e ) ; } } }	Deletes all entries in the local cache.
private void sorttabindexes ( ) { int tabindex = num_ ; for ( formcheckerelement elem : form . getelements ( ) ) { elem . settabindex ( tabindex ) ; tabindex = elem . getlasttabindex ( ) ; tabindex ++ ; } }	resort tab-indexes.
@ deprecated final public string generategenericform ( string formaction , boolean firstrun , formcheckerform form , request req , formcheckerconfig config ) { return this . generategenericform ( formaction , firstrun , form , req , config . properties ) ; }	Renders the html for the complete form with all elements within.
string generatehtmlforelement ( boolean firstrun , messagesource messagesource , formcheckerelement elem , boolean html5validation ) { inputelementstructure inputstruct = new inputelementstructure ( ) ;	builds the html for one element.
public string getcompleterenderedinput ( inputelementstructure inputstruct , formcheckerelement elem , boolean firstrun ) { stringbuilder elemhtml = new stringbuilder ( ) ; wrapper elementwrapper = getwrapperforelem ( elem , firstrun ) ; elemhtml . append ( elementwrapper . start ) ; elemhtml . append ( inputstruct . geterrors ( ) ) ; wrapper labelwrapper = getwrapperforlabel ( elem ) ; elemhtml . append ( labelwrapper . start ) . append ( inputstruct . getlabel ( ) ) . append ( labelwrapper . end ) ; wrapper inputwrapper = getwrapperforinput ( elem ) ; elemhtml . append ( inputwrapper . start ) ; elemhtml . append ( inputstruct . getinput ( ) ) ; elemhtml . append ( inputstruct . gethelp ( ) ) ; elemhtml . append ( inputwrapper . end ) ; elemhtml . append ( elementwrapper . end ) ; return elemhtml . tostring ( ) ; }	override this, if you want to have a different order of the elements.
public string getelement ( string name ) { return formbuilder . generatehtmlforelement ( fc . firstrun , fc . config . getproperties ( ) , form . getelement ( name ) , this . form . ishtml5validation ( ) ) ; }	input-element via a macro!.
public static applicationcontext registerappcontext ( string embeddedwebcontext , applicationcontext appcontext ) { return appcontextmap . put ( embeddedwebcontext , appcontext ) ; }	Registers the specified embedded web context.
@ deprecated public static selectinput build ( string name , linkedhashmap < string , string > possiblenames ) { selectinput si = selectinput . build ( name ) ; si . setpossiblevalues ( possiblenames ) ; return si ; }	a map is not a good structure for that, because keys may be used more than once.
protected string buildallattributes ( tagattributes tagattributes , messagesource messagesource , boolean html5validation ) { stringbuilder allattribs = new stringbuilder ( ) ; allattribs . append ( attributeutils . buildattributes ( tagattributes ) ) ; allattribs . append ( getelementid ( ) ) ; allattribs . append ( gettabindextag ( ) ) ; if ( html5validation ) { allattribs . append ( buildrequiredattribute ( ) ) ; allattribs . append ( buildfcrequiredmessage ( messagesource ) ) ; } allattribs . append ( buildsizeattribute ( ) ) ;	builds attribs, elementId, TabIndex.
public string buildmaxlen ( ) { list < criterion > criteria = this . getcriteria ( ) ; if ( criteria != null ) { for ( criterion criterion : criteria ) { if ( criterion instanceof maxlength ) { return attributeutils . buildsingleattribute ( str_ , integer . tostring ( ( ( maxlength ) criterion ) . getmaxlength ( ) ) ) ; } } } return str_ ; }	builds the maxlen attribute.
private list < contenttype > getacceptedcontenttypes ( ) { annotation consumesannotation = referencedmethod . getannotation ( consumes . class ) ; if ( null == consumesannotation ) consumesannotation = referencedclass . getannotation ( consumes . class ) ; final list < contenttype > acceptedcontenttypes = lists . newarraylist ( ) ; if ( null != consumesannotation ) { for ( final string cts : ( ( consumes ) consumesannotation ) . value ( ) ) { try { acceptedcontenttypes . add ( contenttype . valueof ( cts ) ) ; } catch ( illegalargumentexception e ) { } } } return acceptedcontenttypes ; }	Ensure most optimal match works.
public boolean issamesession ( ) { string sessionid = sessionidprovider . get ( ) ; if ( callbackstartsessionid == null ) { return sessionid == null ; } return callbackstartsessionid . equals ( sessionid ) ; }	Checks if currently we are during same session that we were duringcallback creation.
public static < d > cursorconverter < list < d > > listconverter ( final cursorconverter < d > converter ) { return new listconverter < > ( converter ) ; }	Wrap a provided converter.Returns a converter that creates of list of elements obtained with a provider converter.
void initstartedloaders ( ) { loadermanager lm = operatorcontext . loadermanager ; sparsearray < loadercookies > listenersmap = this . listenersmap ; int count = listenersmap . size ( ) ; for ( int i = num_ ; i < count ; i ++ ) { int loaderid = listenersmap . keyat ( i ) ; loader < ? > loader = lm . getloader ( loaderid ) ; if ( loader != null && loader . isstarted ( ) ) { loadercookies cookies = listenersmap . valueat ( i ) ; boolean notinit = ( cookies . options & loadercookies . already_init ) == num_ ; if ( notinit ) { utils . initloader ( operatorcontext , loaderid , stub_provider , ( cookies . options & loadercookies . destroy_on_finish ) == loadercookies . destroy_on_finish , this ) ; } } } }	Initialize already started loaders.
public remoteprofile getprofileof ( spfperson p ) { if ( p == null ) { throw new nullpointerexception ( ) ; } return new remoteprofile ( p , minterface ) ; }	Provides a reference to a remote profile.
public void setchangelistener ( onchangelistener listener ) { changelistener = listener ; if ( changelistener != null ) {	Set the change listener.
public static documentbuilderfactory getdocumentbuilderfactory ( final string schema ) { system . setproperty ( document_builder_factory_key , document_builder_factory_value ) ; final documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; factory . setnamespaceaware ( bool_ ) ; factory . setvalidating ( bool_ ) ; factory . setattribute ( schema_language_key , http_www_w3_org_2001_xml_schema ) ; factory . setattribute ( schema_source_key , schema ) ; return factory ; }	Gets the document builder factory.
public static domsource getdomsource ( final file xml , final errorhandler errorhandler ) throws saxexception , parserconfigurationexception , ioexception { return new domsource ( parse ( xml , errorhandler ) ) ; }	Gets the dOM source.
public static schema getschema ( final file xsd , final errorhandler errorhandler ) throws saxexception {	Gets the schema.
public static document parse ( final file xml , final errorhandler errorhandler ) throws saxexception , parserconfigurationexception , ioexception { final documentbuilderfactory factory = getdocumentbuilderfactory ( xml . getname ( ) ) ; final documentbuilder builder = factory . newdocumentbuilder ( ) ; builder . seterrorhandler ( errorhandler ) ; return builder . parse ( xml ) ; }	Parses the.
public static void validateschema ( final file xsd , final file xml , final errorhandler errorhandler ) throws saxexception , parserconfigurationexception , ioexception { final schema schemaxsd = getschema ( xsd , errorhandler ) ;	Validate xml through xsd.
public static boolean validateschema ( final string schemaurl , final string xmldocumenturl ) throws saxexception , parserconfigurationexception , ioexception { system . setproperty ( document_builder_factory_key , document_builder_factory_value ) ; final documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; factory . setnamespaceaware ( bool_ ) ; factory . setvalidating ( bool_ ) ; factory . setattribute ( schema_language_key , http_www_w3_org_2001_xml_schema ) ; factory . setattribute ( schema_source_key , schemaurl ) ; final documentbuilder builder = factory . newdocumentbuilder ( ) ; final validatorhandler handler = new validatorhandler ( ) ; builder . seterrorhandler ( handler ) ; builder . parse ( xmldocumenturl ) ; if ( handler . isvalid ( ) ) { return bool_ ; } return bool_ ; }	Validate given xml schema.
public boolean addchild ( final simpletag child ) { if ( getchildren ( ) == null ) { setchildren ( listfactory . newarraylist ( ) ) ; } return getchildren ( ) . add ( child ) ; }	Adds the given child.
public string removeattribute ( final string name ) { if ( getattributes ( ) != null ) { getattributes ( ) . remove ( name ) ; } return null ; }	Removes the attribute with the given name.
public stringbuilder tovelocitytemplate ( ) { final stringbuilder buffer = new stringbuilder ( ) ; buffer . append ( str_ ) ; buffer . append ( str_ ) . append ( getname ( ) ) . append ( str_ ) ; if ( getattributes ( ) != null && ! getattributes ( ) . isempty ( ) ) { buffer . append ( str_ + str_ ) . append ( getname ( ) ) . append ( str_ + str_ ) ; buffer . append ( str_ ) . append ( getname ( ) ) . append ( str_ ) ; buffer . append ( str_ ) ; } buffer . append ( str_ ) . append ( getname ( ) ) . append ( str_ ) . append ( getname ( ) ) . append ( str_ ) ; if ( getchildren ( ) != null && ! getchildren ( ) . isempty ( ) ) { buffer . append ( str_ ) . append ( getchildren ( ) . get ( num_ ) . getname ( ) ) . append ( str_ ) . append ( getname ( ) ) . append ( str_ ) ; for ( final simpletag child : getchildren ( ) ) { buffer . append ( child . tovelocitytemplate ( ) . tostring ( ) ) ; } buffer . append ( str_ ) ; } buffer . append ( str_ ) . append ( getname ( ) ) . append ( str_ ) ; buffer . append ( str_ + str_ ) ; return buffer ; }	Creates from this Tag object an velocity template as String object.
public string toxmlstring ( ) { final stringbuilder buffer = new stringbuilder ( ) ; buffer . append ( str_ ) ; buffer . append ( getname ( ) ) ; optional < string > attr = tagextensions . attributestostring ( getattributes ( ) ) ; if ( attr . ispresent ( ) ) { buffer . append ( attr . get ( ) ) ; } if ( isendtag ( ) ) { buffer . append ( str_ ) ; buffer . append ( getcontent ( ) ) ; if ( getchildren ( ) != null && ! getchildren ( ) . isempty ( ) ) { for ( final simpletag child : getchildren ( ) ) { buffer . append ( child . toxmlstring ( ) ) ; } } buffer . append ( str_ ) ; buffer . append ( getname ( ) ) ; buffer . append ( str_ ) ; } else { buffer . append ( str_ ) ; } return buffer . tostring ( ) ; }	Creates from this Tag object an xml string.
public void addserviceifnotpresent ( wifip2pservice service ) { wfdlog . d ( tag , str_ + servicelist . size ( ) ) ; if ( service == null ) { wfdlog . e ( tag , str_ ) ; return ; } boolean add = bool_ ; for ( wifip2pservice element : servicelist ) { if ( element != null && element . getdevice ( ) . equals ( service . getdevice ( ) ) && element . getinstancename ( ) . equals ( service . getinstancename ( ) ) ) { add = bool_ ;	Method to add a service inside the list in a secure way.The service is added only if isn't already inside the list.
public wifip2pservice getservicebydevice ( wifip2pdevice device ) { if ( device == null ) { return null ; } wfdlog . d ( tag , str_ + device . devicename + str_ + device . deviceaddress ) ; wfdlog . d ( tag , str_ + servicelist . size ( ) ) ; for ( wifip2pservice element : servicelist ) { wfdlog . d ( tag , str_ + element . getdevice ( ) . devicename + str_ + element . getdevice ( ) . deviceaddress ) ; wfdlog . d ( tag , str_ + device . devicename + str_ + device . deviceaddress ) ; if ( element . getdevice ( ) . deviceaddress . equals ( device . deviceaddress ) ) { wfdlog . d ( tag , str_ + device . deviceaddress + str_ + element . getdevice ( ) . deviceaddress ) ; return element ; } } wfdlog . d ( tag , str_ + servicelist . size ( ) ) ; return null ; }	Method to get a service from the list, using only the device.This method use only the deviceAddress, not the device name, because sometimes Android doesn'tget the name, but only the mac address.
@ override public int onstartcommand ( intent intent , int flags , int startid ) { if ( intent == null ) { return start_sticky ; } string action = intent . getaction ( ) ; if ( action_start_foreground . equals ( action ) ) { if ( ! spf . get ( ) . isconnected ( ) ) { spf . get ( ) . connect ( ) ; } spf . get ( ) . notifyproximitystatus ( bool_ ) ;	Triggered by the front end to keep spf service active in foreground.
list < spftrigger > getalltriggers ( string appidentifier ) { string where = contract . column_app_identifier + str_ ; string [ ] whereargs = { appidentifier } ; cursor c = getreadabledatabase ( ) . query ( contract . table_name , null , where , whereargs , null , null , null ) ; list < spftrigger > triggers = new arraylist < spftrigger > ( ) ; while ( c . movetonext ( ) ) { triggers . add ( triggerfromcursor ( c ) ) ; } c . close ( ) ; return triggers ; }	Return all the triggers of the specified application.
boolean deletealltriggerof ( string apppackagename ) { string where = contract . column_app_identifier + str_ ; string [ ] whereargs = { apppackagename } ; int c = getreadabledatabase ( ) . delete ( contract . table_name , where , whereargs ) ; return c > num_ ; }	Delete all the triggers registered with the given application identifier.
boolean deletetrigger ( long id , string apppackagename ) { string where = contract . column_app_identifier + str_ + contract . _id + str_ ; string [ ] whereargs = { apppackagename , long . tostring ( id ) } ; int count = getreadabledatabase ( ) . delete ( contract . table_name , where , whereargs ) ; return count > num_ ; }	Delete the trigger with the given id.
spftrigger gettrigger ( long triggerid , string apppackagename ) { string where = contract . _id + str_ + contract . column_app_identifier + str_ ; string [ ] whereargs = { long . tostring ( triggerid ) , apppackagename } ; cursor c = getreadabledatabase ( ) . query ( contract . table_name , null , where , whereargs , null , null , null ) ; if ( ! c . movetofirst ( ) ) { return null ; } spftrigger t = triggerfromcursor ( c ) ; c . close ( ) ; return t ; }	Return the trigger with the specified id.
public static < t > t toobjectwithxstream ( final string xmlstring , final map < string , class < ? > > aliases ) { return toobjectwithxstream ( null , xmlstring , aliases ) ; }	Creates from the given xml string an Object.
@ suppresswarnings ( str_ ) public static < t > t toobjectwithxstream ( xstream xstream , final string xmlstring , final map < string , class < ? > > aliases ) { if ( xstream == null ) { xstream = new xstream ( ) ; } if ( aliases != null ) { for ( final map . entry < string , class < ? > > alias : aliases . entryset ( ) ) { xstream . alias ( alias . getkey ( ) , alias . getvalue ( ) ) ; } } return ( t ) xstream . fromxml ( xmlstring ) ; }	Creates from the given xml string an java object.
public static string tojson ( final string xmlstring , final map < string , class < ? > > aliases ) { final object object = xmltoobjectextensions . toobjectwithxstream ( xmlstring ) ; final xstream xstream = new xstream ( new jettisonmappedxmldriver ( ) ) ; if ( aliases != null ) { for ( final map . entry < string , class < ? > > alias : aliases . entryset ( ) ) { xstream . alias ( alias . getkey ( ) , alias . getvalue ( ) ) ; } } final string json = xstream . toxml ( object ) ; return json ; }	Creates from the given xml string a json string.
public object invokemethod ( string methodname , object [ ] args , type rettype ) throws serviceinvocationexception { checkcurrentthread ( methodname ) ; utils . notnull ( methodname ) ; utils . notnull ( args ) ;	Invokes a remote service providing the name of the method to invoke nameand the list of parameters.
private void checkcurrentthread ( string methodname ) { if ( looper . mylooper ( ) == looper . getmainlooper ( ) ) { log . w ( tag , string . format ( wrong_thread_msg , mservicedescriptor . getservicename ( ) , methodname ) ) ; } }	Checks if the current thread is the main thread, if so it logs a wrning.
public static void logcall ( string tag , string methodname , object ... args ) { if ( spfconfig . debug ) { log . d ( tag , str_ + methodname + str_ + ( args != null ? textutils . join ( str_ , args ) : str_ ) + str_ ) ; } }	Helper to log a call to a method.
private static < t > t loadobject ( final inputstream is ) throws ioexception { final string xmlstring = readfileextensions . inputstream2string ( is ) ; final t object = xmltoobjectextensions . toobjectwithxstream ( xmlstring ) ; return object ; }	Load from the given input stream that should represent an xml file and transform it to thegeneric type object.
public static string newtag ( final string tagname , final string value , final map < string , string > attributes ) { final stringbuilder xmltag = new stringbuilder ( ) ; xmltag . append ( str_ ) . append ( tagname ) ; if ( attributes != null && ! attributes . isempty ( ) ) { xmltag . append ( str_ ) ; int count = num_ ; for ( final map . entry < string , string > attributte : attributes . entryset ( ) ) { xmltag . append ( attributte . getkey ( ) ) ; xmltag . append ( str_ ) ; xmltag . append ( str_ ) . append ( attributte . getvalue ( ) ) . append ( str_ ) ; if ( count != attributes . size ( ) ) { xmltag . append ( str_ ) ; } count ++ ; } } xmltag . append ( str_ ) ; xmltag . append ( value ) ; xmltag . append ( str_ ) . append ( tagname ) . append ( str_ ) ; return xmltag . tostring ( ) ; }	Creates a tag from the given string values.
public boolean matches ( string queryjson ) { querycontainer querycontainer ; try { querycontainer = querycontainer . fromjson ( queryjson ) ; } catch ( jsonexception e ) { return bool_ ; } spfquery query = querycontainer . getquery ( ) ; string callerapp = querycontainer . getcallerappid ( ) ; string useruid = querycontainer . getuseruid ( ) ; return analyzewith ( query , callerapp , useruid ) ; }	Verifies if the local profile matches the given query.
public invocationresponse dispatchinvocation ( invocationrequest request ) { string appname = request . getappname ( ) ; string servicename = request . getservicename ( ) ; string componentname = mservicetable . getcomponentforservice ( appname , servicename ) ; if ( componentname == null ) { return invocationresponse . error ( str_ + appname + str_ + servicename ) ; } appserviceproxy proxy = mcommunicationagent . getproxy ( componentname ) ; if ( proxy == null ) { return invocationresponse . error ( str_ ) ; } try { return proxy . executeservice ( request ) ; } catch ( throwable t ) { log . e ( str_ , str_ , t ) ; return invocationresponse . error ( str_ + t . getmessage ( ) ) ; } }	Dispatches an invocation request to the right application.
public < t > void unregisterservice ( class < ? super t > serviceinterface ) { utils . notnull ( serviceinterface , str_ ) ; servicevalidator . validateinterface ( serviceinterface , servicevalidator . type_published ) ; serviceinterface svcinterface = serviceinterface . getannotation ( serviceinterface . class ) ; spfservicedescriptor svcdesc = serviceinterface . convert . toservicedescriptor ( svcinterface ) ; string token = getaccesstoken ( ) ; try { spferror error = new spferror ( ) ; getservice ( ) . unregisterservice ( token , svcdesc , error ) ; if ( ! error . isok ( ) ) { handleerror ( error ) ; } } catch ( remoteexception e ) { catchremoteexception ( e ) ; } }	Allows to unregister a previously registered service.
private string generatequeryid ( queryinfo queryinfo ) { string queryid = spf . get ( ) . getuniqueidentifier ( ) + ( ++ id ) ; queryinfo . setqueryid ( queryid ) ; return queryid ; }	Generate a query id for the specified query.
void oninstancelost ( string uniqueidentifier ) { log ( tag , str_ + uniqueidentifier ) ; list < string > queriesids = results . get ( uniqueidentifier ) ; if ( queriesids == null ) { return ; } for ( string queryid : queriesids ) { string [ ] args = new string [ num_ ] ; args [ num_ ] = queryid ; args [ num_ ] = uniqueidentifier ; message msg = handler . obtainmessage ( searchmessages . result_lost , args ) ; log ( tag , str_ + queryid ) ; handler . sendmessage ( msg ) ; } }	Call this method when the middleware notify that a spf instance is lost.It will notify the event to all the active searches that have the lostinstance in their results.
void stopsearch ( string queryid ) { queryinfo info = queries . get ( queryid ) ; if ( info != null ) { stopsearch ( info ) ; } }	Call this method to stop the search and release the associated resources.The application will not be notified about the event;.
void stopallsearches ( string appidentifier ) { list < queryinfo > qinfos ; synchronized ( queries ) { qinfos = new arraylist < queryinfo > ( queries . values ( ) ) ; } for ( queryinfo queryinfo : qinfos ) { if ( queryinfo . getappname ( ) . equals ( appidentifier ) ) { stopsearch ( queryinfo ) ; } } }	Unregister all the active queries associated with the givenappIdentifier.
public static void connect ( final context context , final connectionlistener listener ) { component . load ( context , descriptor , asbase ( listener ) ) ; }	Creates a connection to SPF asynchronously.
private < e > view createstandarddisplayview ( profilefield < e > field , e currentvalue , viewgroup viewcontainer ) { view result = minflater . inflate ( r . layout . profileview_field_listelement , viewcontainer , bool_ ) ; string friendlyfieldname = mhelper . getfriendlynameoffield ( field ) ; ( ( textview ) result . findviewbyid ( r . id . profile_field_key ) ) . settext ( friendlyfieldname ) ; string fieldvalue = mhelper . converttofriendlystring ( field , currentvalue ) ; ( ( textview ) result . findviewbyid ( r . id . profile_field_value ) ) . settext ( fieldvalue ) ; setupcircleview ( result , field , null ) ; return result ; }	Standard display view for all profile fields except tags.
private < e > view createspinner ( multiplechoicheprofilefield < e > field , e currentvalue , fieldvaluelistener < e > listener , viewgroup container ) { view result = minflater . inflate ( r . layout . profileedit_field_multiplechoiche , container , bool_ ) ; string friendlyname = mhelper . getfriendlynameoffield ( field ) ; ( ( textview ) result . findviewbyid ( r . id . profileedit_field_identifier ) ) . settext ( friendlyname ) ; spinner spinner = ( spinner ) result . findviewbyid ( r . id . profileedit_field_multiple_value ) ; arrayadapter < e > adapter = new arrayadapter < e > ( mcontext , android . r . layout . simple_list_item_1 , field . getchoiches ( ) ) ; spinner . setadapter ( adapter ) ; int index = indexof ( field . getchoiches ( ) , currentvalue ) ; if ( index >= num_ ) { spinner . setselection ( index , bool_ ) ; } spinner . setonitemselectedlistener ( new onitemselectedadapter < e > ( field , listener , adapter ) ) ; setupcircleview ( result , field , listener ) ; return result ; }	Edit view for multiple choiche fields.
@ suppresswarnings ( str_ ) private < e > view createtagview ( tagprofilefield field , string [ ] currentvalue , fieldvaluelistener < e > listener , viewgroup container , boolean editable ) { view result = minflater . inflate ( editable ? r . layout . profileedit_field_tag : r . layout . profileview_tag_field , container , bool_ ) ; string friendlyname = mhelper . getfriendlynameoffield ( field ) ; ( ( textview ) result . findviewbyid ( r . id . profileedit_field_identifier ) ) . settext ( friendlyname ) ; tagspicker picker = ( tagspicker ) result . findviewbyid ( r . id . profileedit_tags_picker ) ; picker . seteditable ( editable ) ; if ( currentvalue != null ) { picker . setinitialtags ( arrays . aslist ( currentvalue ) ) ; } if ( editable ) { picker . setchangelistener ( new onchangelisteneradapter ( field , ( fieldvaluelistener < string [ ] > ) listener ) ) ; } setupcircleview ( result , ( profilefield < e > ) field , listener ) ; return result ; }	Edit and display view for tags.
private < e > view createstandardeditview ( profilefield < e > field , e currentvalue , fieldvaluelistener < e > listener , viewgroup container ) { view result = minflater . inflate ( r . layout . profileedit_field_standard , container , bool_ ) ; string friendlyname = mhelper . getfriendlynameoffield ( field ) ; ( ( textview ) result . findviewbyid ( r . id . profileedit_field_identifier ) ) . settext ( friendlyname ) ; edittext edittext = ( edittext ) result . findviewbyid ( r . id . profileedit_field_value ) ; edittext . addtextchangedlistener ( new oneditoractionadapter < > ( listener , field ) ) ; if ( currentvalue != null ) { edittext . settext ( mhelper . converttofriendlystring ( field , currentvalue ) ) ; } setupcircleview ( result , field , listener ) ; return result ; }	Edit view for all other fields.
public final void sendnotification ( string uniqueidentifier , spfactionsendnotification action ) { if ( uniqueidentifier == null || action == null ) { throw new nullpointerexception ( ) ; } string actionjson = action . tojson ( ) ; sendnotification ( uniqueidentifier , actionjson ) ; }	Sends a notification to the remote SPF instance.
public string toxml ( ) { final string lqsimplename = this . getclass ( ) . getsimplename ( ) . tolowercase ( ) ; final map < string , class < ? > > aliases = new hashmap < > ( ) ; aliases . put ( lqsimplename , this . getclass ( ) ) ; return objecttoxmlextensions . toxmlwithxstream ( this , aliases ) ; }	To xml.
private void setcontentviewwithminimalelements ( ) {	Method to set the contentview with Title, Text and Image.
public string getfriendlynameoffield ( profilefield < ? > field ) { string name = getstringfromresource ( profile_field_prefix + field . getidentifier ( ) ) ; if ( name == null ) { return field . getidentifier ( ) ; } return name ; }	Provides the localized friendly name of a field.
private void killscheduler ( ) { if ( scheduler != null ) { wfdlog . d ( tag , str_ ) ; scheduler . shutdown ( ) ; scheduler = null ; } }	Kill the scheduler to stop the Eternal Connect in any case.
public static synchronized void initialize ( context context , int gointent , boolean isautonomous , proximitymiddleware . factory factory ) { if ( context == null || factory == null ) { throw new nullpointerexception ( str_ ) ; } spf . initialize ( context , gointent , isautonomous , factory ) ; sinstance = new spfcontext ( ) ; }	Initializes SPFContext. After this method has been called, you can getreferences to SPFContext and SPF.
public void broadcastevent ( final int code , final bundle payload ) { if ( spfconfig . debug ) { log . d ( tag , str_ + code + str_ + payload ) ; } for ( final oneventlistener listener : meventlisteners ) {	Broadcasts an event to all registered listeners.
public static profilefragment createviewselfprofilefragment ( ) { bundle b = new bundle ( ) ; b . putint ( extra_view_mode , mode . self . ordinal ( ) ) ; profilefragment fragment = new profilefragment ( ) ; fragment . setarguments ( b ) ; return fragment ; }	Creates a new instance of ProfileFragment to show the local profile.
public void begincrop ( uri source ) { uri destination = uri . fromfile ( new file ( this . getactivity ( ) . getcachedir ( ) , str_ ) ) ; crop . of ( source , destination ) . assquare ( ) . start ( this . getactivity ( ) ) ; }	Method to start the activity to crop an image.
public void handlecrop ( int resultcode , intent result ) { if ( resultcode == activity . result_ok ) { uri uri = crop . getoutput ( result ) ; resultview . setimageuri ( uri ) ; inputstream inputstream = null ; try { inputstream = new fileinputstream ( uri . getpath ( ) ) ; bitmap mybitmap = bitmapfactory . decodestream ( inputstream ) ; mybitmap = bitmap . createscaledbitmap ( mybitmap , num_ , num_ , bool_ ) ; mcontainer . setfieldvalue ( profilefield . photo , mybitmap ) ; showpicture ( mybitmap ) ; } catch ( filenotfoundexception e ) { log . e ( tag , str_ , e ) ; } finally { if ( inputstream != null ) { try { inputstream . close ( ) ; } catch ( ioexception e ) { log . e ( tag , str_ , e ) ; } } } } else if ( resultcode == crop . result_error ) { toast . maketext ( this . getactivity ( ) , crop . geterror ( result ) . getmessage ( ) , toast . length_short ) . show ( ) ; } }	Method to set an show a cropped imaged.
public static < t > string tojson ( final t object , final boolean newmapper ) throws jsonprocessingexception { final objectmapper mapper = objectmapperfactory . getobjectmapper ( newmapper ) ; final string json = mapper . writevalueasstring ( object ) ; return json ; }	To json.
public void addtag ( string tag ) { tagbubble tb = new tagbubble ( getcontext ( ) ) ; tb . settext ( tag ) ; tb . seteditable ( editable ) ; tb . setonremovetaglistener ( bubbleclicklistener ) ; tags . add ( tag . tostring ( ) ) ; addview ( tb ) ; }	Adds and shows a new tag.
public void settags ( list < string > tags ) { this . tags . clear ( ) ; removeallviews ( ) ; for ( string tag : tags ) { addtag ( tag ) ; } }	Set the list of tags to be displayed.
public long savetrigger ( spftrigger trigger , string apppackagename ) { trigger = mtriggertable . savetrigger ( trigger , apppackagename ) ; if ( trigger != null ) { if ( mhandler != null ) mhandler . postaddtrigger ( trigger ) ; return trigger . getid ( ) ; } else { return - num_ ; } }	Saves the trigger on the database.
public boolean deletetrigger ( long id , string apppackagename ) { boolean success = mtriggertable . deletetrigger ( id , apppackagename ) ; if ( success ) { if ( mhandler != null ) mhandler . postremovetrigger ( id ) ; } return success ; }	Deletes the trigger specified by its id.
public void start ( ) { this . mhandlerthread = new handlerthread ( str_ ) ; this . mhandlerthread . start ( ) ; this . mhandler = new spfnotificationhandler ( mhandlerthread . getlooper ( ) ) ; mhandler . postsetup ( this ) ; isrunning = bool_ ; }	Initialize and start all the threads and resources used bySPFNotification service.
private void startregistration ( ) {	Registers a local service.
public string addattribute ( final string name , final string value ) { if ( getattributes ( ) == null ) { this . attributes = mapfactory . newlinkedhashmap ( ) ; } return getattributes ( ) . put ( name , value ) ; }	Adds the attribute with the given name and value.
public invocationresponse invokemethod ( invocationrequest request ) { string methodname = request . getmethodname ( ) ; if ( ! mmethodindex . containskey ( methodname ) ) { string msg = string . format ( errormsg . method_not_found , methodname , mservicedescriptor . getservicename ( ) ) ; return invocationresponse . error ( msg ) ; } method m = mmethodindex . get ( methodname ) ; object [ ] params ; try { params = deserializeparameters ( request . getpayload ( ) , m . getgenericparametertypes ( ) ) ; } catch ( serviceinvocationexception e ) { return invocationresponse . error ( str_ + e . getmessage ( ) ) ; } try { object result = m . invoke ( mimplementation , params ) ; string json = gsonhelper . gson . tojson ( result ) ; return invocationresponse . result ( json ) ; } catch ( illegalaccessexception e ) { return invocationresponse . error ( e ) ; } catch ( illegalargumentexception e ) { return invocationresponse . error ( errormsg . illegal_argument ) ; } catch ( invocationtargetexception e ) { return invocationresponse . error ( e . getcause ( ) ) ; } }	Invokes a method of the service.
public void setselection ( string [ ] selection ) { for ( string sel : selection ) { for ( int j = num_ ; j < mitems . length ; ++ j ) { if ( mitems [ j ] . equals ( sel ) ) { mselection [ j ] = bool_ ; } } } refreshdisplayvalue ( ) ; }	Sets the selected options based on an array of string.
public void setselection ( int [ ] selectedindicies ) { for ( int index : selectedindicies ) { if ( index >= num_ && index < mselection . length ) { mselection [ index ] = bool_ ; } else { throw new illegalargumentexception ( str_ + index + str_ ) ; } } refreshdisplayvalue ( ) ; }	Sets the selected options based on an array of positions.
public list < string > getselectedstrings ( ) { list < string > selection = new linkedlist < string > ( ) ; for ( int i = num_ ; i < mitems . length ; ++ i ) { if ( mselection [ i ] ) { selection . add ( mitems [ i ] ) ; } } return selection ; }	Returns a list of strings, one for each selected item.
public list < integer > getselectedindicies ( ) { list < integer > selection = new linkedlist < integer > ( ) ; for ( int i = num_ ; i < mitems . length ; ++ i ) { if ( mselection [ i ] ) { selection . add ( i ) ; } } return selection ; }	Returns a list of positions, one for each selected item.
public void onrefresh ( ) { mviewcontainer . removeallviews ( ) ; for ( profilefield < ? > field : mfieldstoshow ) { view child = mparent . createviewfor ( field , mviewcontainer ) ; mviewcontainer . addview ( child ) ; } }	Refreshes the values of displayed fields.
public void shutdown ( ) { synchronized ( this ) { if ( mshutdown ) { return ; } for ( appserviceproxy p : mproxies . values ( ) ) { if ( p . isconnected ( ) ) { mcontext . unbindservice ( p ) ; mproxies . remove ( p ) ; } } mshutdown = bool_ ; } }	Unbinds all proxies available in caches and prevents the creation of newones.
private void insertnewline ( ) throws saxexception { try { writer . write ( system . getproperty ( str_ ) ) ; } catch ( final ioexception e ) { throw new saxexception ( str_ , e ) ; } }	Insert a new line to the writer.
private void writetobuffer ( ) throws saxexception { if ( stringbuilder == null ) { return ; } final string string = stringbuilder . tostring ( ) . trim ( ) ; write ( string ) ; stringbuilder = null ; }	Write to buffer.
public static < t > string tojsonquietly ( final t object ) { try { return objecttojsonextensions . tojson ( object ) ; } catch ( final jsonprocessingexception e ) { log . log ( level . severe , str_ + object . tostring ( ) + str_ , e ) ; } return null ; }	Creates from the given Object a json string.
protected static < c extends component < c , i > , i extends iinterface > void load ( final context context , final descriptor < c , i > descriptor , final connectioncallback < c > callback ) { utils . notnull ( context , str_ ) ; utils . notnull ( descriptor , str_ ) ; if ( accesstokenmanager . get ( context ) . hastoken ( ) ) { bindtoservice ( context , descriptor , callback ) ; } else { accesstokenmanager . get ( context ) . requireaccesstoken ( context , new accesstokenmanager . registrationcallback ( ) { @ override public void onregistrationsuccessful ( ) { log . d ( str_ , str_ + descriptor ) ; bindtoservice ( context , descriptor , callback ) ; } @ override public void onregistrationerror ( spferror errormsg ) { callback . onerror ( errormsg ) ; } } ) ; } }	Loads a local component asynchronously.
private static < c extends component < c , i > , i extends iinterface > void bindtoservice ( final context context , final descriptor < c , i > descriptor , final connectioncallback < c > callback ) { intent intent = new intent ( ) ; intent . setcomponent ( spfinfo . getspfservicecomponentname ( ) ) ; intent . setaction ( descriptor . getactionname ( ) ) ; serviceconnection connection = new serviceconnection ( ) { @ override public void onserviceconnected ( componentname name , ibinder binder ) { i service = descriptor . castinterface ( binder ) ; c instance = descriptor . createinstance ( context , service , this , callback ) ; callback . onserviceready ( instance ) ; } @ override public void onservicedisconnected ( componentname name ) { callback . ondisconnect ( ) ; } } ; if ( ! context . bindservice ( intent , connection , context . bind_auto_create ) ) { callback . onerror ( new spferror ( spferror . spf_not_installed_error_code ) ) ; } }	Performs the binding to the remote service.
public void disconnect ( ) { try { mcontext . unbindservice ( mconnection ) ; } catch ( exception e ) { log . w ( getclass ( ) . getsimplename ( ) , str_ , e ) ; } }	Disconnects the component from the remote service.
protected void handleerror ( spferror err ) { if ( err . codeequals ( spferror . token_not_valid_error_code ) ) { accesstokenmanager . get ( mcontext ) . invalidatetoken ( ) ; } mcallback . onerror ( err ) ; }	Performs common error handling operations.
public void refreshtriggers ( list < spftrigger > triggers2 ) { triggers . clear ( ) ; for ( spftrigger trg : triggers2 ) { triggers . put ( trg . getid ( ) , trg ) ; } }	Update the current set of triggers with the given list.
boolean addpersona ( spfpersona persona ) { sqlitedatabase db = getwritabledatabase ( ) ; string table = contract . table_personas ; string nullcolumnhack = null ; contentvalues values = new contentvalues ( ) ; values . put ( contract . column_persona , persona . getidentifier ( ) ) ; if ( db . insert ( table , nullcolumnhack , values ) > num_ ) {	Creates a new SPFPersona.
boolean removepersona ( spfpersona persona ) { sqlitedatabase db = getwritabledatabase ( ) ; if ( persona . getidentifier ( ) . equals ( str_ ) ) { return bool_ ; } string table = contract . table_personas ; string selection = contract . column_persona + str_ ; string [ ] selectionargs = { persona . getidentifier ( ) } ; if ( db . delete ( table , selection , selectionargs ) > num_ ) { deletefieldsof ( persona , db ) ; deletevisibilityof ( persona , db ) ; } return bool_ ; }	Delete a SPFPersona. All the information related to the specified personawill be erased.
public boolean registerservice ( spfservicedescriptor descriptor ) { string appid = descriptor . getappidentifier ( ) ; string servicename = descriptor . getservicename ( ) ; for ( string verb : descriptor . getconsumedverbs ( ) ) { if ( ! registerserviceinternal ( verb , servicename , appid ) ) { return bool_ ; } log . v ( tag , str_ + descriptor . getservicename ( ) ) ; } return bool_ ; }	Registers the capabilities of a service to consume activities.
appauth getappauthorizationbyappid ( string appid ) { string where = contract . column_app_identifier + str_ ; string args [ ] = { appid } ; cursor c = mregistrytable . getreadabledatabase ( ) . query ( contract . table_name , null , where , args , null , null , null ) ; appauth auth = null ; if ( c . movetofirst ( ) ) { auth = appauthfromcursor ( c ) ; } c . close ( ) ; return auth ; }	Retrieves an appauth given the identifier of an application.
public string registerapplication ( appdescriptor descriptor , spfpersona persona ) { string token = mtokengenerator . generateaccesstoken ( ) ; contentvalues cv = new contentvalues ( ) ; cv . put ( contract . column_app_name , descriptor . getappname ( ) ) ; cv . put ( contract . column_access_token , token ) ; cv . put ( contract . column_app_identifier , descriptor . getappidentifier ( ) ) ; cv . put ( contract . column_permission_code , descriptor . getpermissioncode ( ) ) ; cv . put ( contract . column_persona , persona . getidentifier ( ) ) ; sqlitedatabase db = mregistrytable . getwritabledatabase ( ) ; if ( db . insert ( contract . table_name , null , cv ) == - num_ ) { return null ;	Low level method to register applications.
public boolean unregisterapplication ( string appidentifier ) { string where = contract . column_app_identifier + str_ ; string [ ] whereargs = { appidentifier } ; if ( mregistrytable . getwritabledatabase ( ) . delete ( contract . table_name , where , whereargs ) == num_ ) { return bool_ ; } if ( spf . get ( ) . getserviceregistry ( ) . unregisterallservicesofapp ( appidentifier ) ) { intent i = new intent ( deregistration_intent ) ; i . putextra ( deregistered_app , appidentifier ) ; mcontext . sendbroadcast ( i ) ; return bool_ ; } return bool_ ; }	To be called from application uninstall monitor.
public spfpersona getpersonaof ( string appidentifier ) { sqlitedatabase db = mregistrytable . getreadabledatabase ( ) ; string table = contract . table_name ; string [ ] columns = { contract . column_persona } ; string selection = contract . column_app_identifier + str_ ; string [ ] selectionargs = { appidentifier } ; string groupby = null ; string having = null ; string orderby = null ; cursor c = db . query ( table , columns , selection , selectionargs , groupby , having , orderby ) ; if ( c . movetonext ( ) ) { string persona = c . getstring ( c . getcolumnindex ( contract . column_persona ) ) ; return new spfpersona ( persona ) ; } c . close ( ) ; return spfpersona . default ; }	Returns the SPFPersona associated to the specified application.
void onmessagereceived ( final wfdmessage msg ) { threadpool . execute ( new runnable ( ) { @ override public void run ( ) { if ( msg . getreceiverid ( ) . equals ( myidentifier ) ) { handle ( msg ) ; } else { route ( msg ) ; } } } ) ; }	called from the GOInternalClient.
public void addclientifnotpresent ( deviceguielement device ) { boolean add = bool_ ; for ( deviceguielement element : clients ) { if ( element != null && element . getname ( ) . equals ( device . getname ( ) ) && element . getaddress ( ) . equals ( device . getaddress ( ) ) ) { add = bool_ ;	Method to add a client inside the list in a secure way.The client is added only if isn't already inside the list.
public void connect ( ) { if ( ! mmiddleware . isconnected ( ) ) { mmiddleware . connect ( ) ; } if ( ! mnotificationmanager . isrunning ( ) ) { mnotificationmanager . start ( ) ; } if ( madvertisemanager . isadvertisingenabled ( ) ) { mmiddleware . registeradvertisement ( madvertisemanager . generateadvprofile ( ) . tojson ( ) , num_ ) ; } }	Life-cycle methods.
public < e > e getfieldvalue ( profilefield < e > field ) { if ( field == null ) { throw new nullpointerexception ( ) ; } string val = mfields . getstring ( field . getidentifier ( ) ) ; return val == null ? null : profilefieldconverter . forfield ( field ) . fromstoragestring ( val ) ; }	Gets the value of a field from the container.
public boolean ismodified ( ) { for ( string key : mstatus . keyset ( ) ) { fieldstatus status = getstatus ( key ) ; if ( status == fieldstatus . deleted || status == fieldstatus . modified ) { return bool_ ; } } return bool_ ; }	Returns whether at least one field in the container has been modified.
public void stopsearch ( int tag ) { string queryid = mtagtoid . get ( tag ) ; mtagtoid . delete ( tag ) ; if ( queryid != null && mcallbacks . remove ( queryid ) != null ) { msearchinterface . stopsearch ( queryid ) ; } }	Stops a previously registered search request performed by theapplication.
public void stopallsearches ( ) { mtagtoid . clear ( ) ; string [ ] queryids = mcallbacks . keyset ( ) . toarray ( new string [ ] { } ) ; mcallbacks . clear ( ) ; for ( string queryid : queryids ) { msearchinterface . stopsearch ( queryid ) ; } }	Stops all searches registered by the application.
public spfperson lookup ( string identifier ) { boolean isreachable = msearchinterface . lookup ( identifier ) ; if ( isreachable ) { return new spfperson ( identifier ) ; } else { return null ; } }	Allows to retrieve a reference to a remote person given its identifier.This reference is valid until the given person is reachable from theproximity middleware.
public profilefieldcontainer getprofilefieldbulk ( personauth auth , spfpersona persona , string [ ] fields ) { return mprofiletable . getprofilefieldbulk ( persona , fields , auth ) ; }	Method for proximity interface to provide access to local profile toremote spf instances.
public baseinfo getbaseinfo ( spfpersona persona ) { profilefieldcontainer pfc = getprofilefieldbulk ( persona , profilefield . identifier , profilefield . display_name ) ; return new baseinfo ( pfc . getfieldvalue ( profilefield . identifier ) , pfc . getfieldvalue ( profilefield . display_name ) ) ; }	Returns the display_name of the user.
public static nodelist getnodelist ( final string xml , final string xpathexpression ) throws xpathexpressionexception , parserconfigurationexception , saxexception , ioexception { final documentbuilderfactory domfactory = documentbuilderfactory . newinstance ( ) ; domfactory . setnamespaceaware ( bool_ ) ; final documentbuilder builder = domfactory . newdocumentbuilder ( ) ; final document doc = builder . parse ( xml ) ; final xpath xpath = xpathfactory . newinstance ( ) . newxpath ( ) ; final xpathexpression expr = xpath . compile ( xpathexpression ) ; final object result = expr . evaluate ( doc , xpathconstants . nodeset ) ; final nodelist nodes = ( nodelist ) result ; return nodes ; }	Gets the node list from the given xml file and the given xpath expression.
public static < e > e onmainthread ( class < e > callbackinterface , final e callback ) { utils . notnull ( callbackinterface , str_ ) ; utils . notnull ( callback , str_ ) ; final handler handler = new handler ( looper . getmainlooper ( ) ) ; final string tag = callback . getclass ( ) . getsimplename ( ) ; object proxy = proxy . newproxyinstance ( callbackinterface . getclassloader ( ) , new class < ? > [ ] { callbackinterface } , new invocationhandler ( ) { @ override public object invoke ( object proxy , final method method , final object [ ] args ) throws throwable { handler . post ( new runnable ( ) { @ override public void run ( ) { try { method . invoke ( callback , args ) ; } catch ( illegalaccessexception e ) { log . e ( tag , str_ + method . getname ( ) + str_ , e ) ; } catch ( illegalargumentexception e ) { log . e ( tag , str_ + method . getname ( ) + str_ , e ) ; } catch ( invocationtargetexception e ) { log . e ( tag , str_ + method . getname ( ) + str_ , e ) ; } } } ) ; return null ; } } ) ; return callbackinterface . cast ( proxy ) ; }	Wraps a callback into a proxy that executes its methods on the mainthread.
public personauth getpersonauthfrom ( string receivedtkn ) { if ( receivedtkn . equals ( str_ ) ) { return personauth . getpublicauth ( ) ; } string selection = relationshipentry . column_tkn + str_ + relationshipentry . column_request_status + str_ ; string [ ] selectionargs = { receivedtkn , integer . tostring ( request_accepted ) } ; string [ ] columns = { relationshipentry . column_user_uuid } ; sqlitedatabase db = getreadabledatabase ( ) ; cursor cursor = db . query ( relationshipentry . table_person_auth , columns , selection , selectionargs , null , null , null ) ; personauth auth ; if ( cursor . movetonext ( ) ) { string uniqueidentifier = cursor . getstring ( cursor . getcolumnindex ( relationshipentry . column_user_uuid ) ) ; auth = generatepermissionfor ( uniqueidentifier , db ) ; } else { auth = personauth . getpublicauth ( ) ; } cursor . close ( ) ; return auth ; }	Call this method every time you receive a remote request.
public string createentryforsentrequest ( string targetuid , string password ) throws generalsecurityexception {	Creates a pending request associated to the target id.
public boolean createentryforreceivedrequest ( contactrequest fr ) { string user_uuid = fr . getuseridentifier ( ) ; string receive_token = fr . getaccesstoken ( ) ; int request_status = request_pending ; if ( insertnewentry ( user_uuid , receive_token , request_status ) ) { return bool_ ; } return bool_ ; }	Creates a pending request with the information contained in the message.
public int entryexistsfor ( string useruid ) { string selection = relationshipentry . column_user_uuid + str_ ; string [ ] selectionargs = { useruid } ; string [ ] columns = { relationshipentry . column_request_status } ; sqlitedatabase db = getreadabledatabase ( ) ; cursor cursor = db . query ( relationshipentry . table_person_auth , columns , selection , selectionargs , null , null , null ) ; if ( cursor . movetonext ( ) ) { return cursor . getint ( cursor . getcolumnindex ( relationshipentry . column_request_status ) ) ; } cursor . close ( ) ; return request_not_exist ; }	check if an entry for the specified user id exists.
public boolean confirmrequest ( string targetuid , string password ) throws generalsecurityexception , wrongpassphraseexception { sqlitedatabase db = getwritabledatabase ( ) ; string table = relationshipentry . table_person_auth ; string [ ] columns = { relationshipentry . column_tkn , relationshipentry . column_request_status , relationshipentry . column_password } ; string selection = relationshipentry . column_user_uuid + str_ ; string [ ] selectionargs = { targetuid } ; string groupby = null ; string having = null ; string orderby = null ; string limit = null ; cursor c = db . query ( table , columns , selection , selectionargs , groupby , having , orderby , limit ) ; if ( c . movetonext ( ) ) { string token = c . getstring ( c . getcolumnindex ( relationshipentry . column_tkn ) ) ; string decryptedtkn = tokencipher . decrypttoken ( token , password ) ; if ( decryptedtkn != null ) { return commitconfirmation ( targetuid , password , decryptedtkn ) ; } else { return bool_ ; } } return bool_ ; }	Confirm a friendship request. the status of the entry associated with thespecified person, will be REQUEST_ACCEPTED.
@ override public void addclosingtag ( string tagname ) { _indent . dec ( ) ; _xml . addxml ( _indent . tostring ( ) ) ; _xml . addclosingtag ( tagname ) ; _xml . addxml ( str_ ) ; }	Adds a closing tag.
@ override public void addemptytag ( string tagname ) { _xml . addxml ( _indent . tostring ( ) ) ; _xml . addemptytag ( tagname ) ; _xml . addxml ( str_ ) ; }	Adds an empty tag.
@ override public void addopeningtag ( string tagname , map attributes ) { _xml . addxml ( _indent . tostring ( ) ) ; _xml . addopeningtag ( tagname , attributes ) ; _xml . addxml ( str_ ) ; _indent . inc ( ) ; }	Adds an opening tag which contains the attributes specified.
public static boolean deletefile ( file file ) throws ioexception { if ( ! file . exists ( ) ) return bool_ ; file [ ] files = file . listfiles ( ) ; if ( files != null ) { for ( int i = num_ ; i < files . length ; i ++ ) { file childfile = files [ i ] ; if ( childfile . equals ( file ) ) continue ; if ( childfile . isdirectory ( ) ) deletefile ( childfile ) ; else childfile . delete ( ) ; } } return file . delete ( ) ; }	Deletes the file provided.
public static file createtempdirectory ( string namespace , string name ) throws ioexception { file dir = file . createtempfile ( namespace , str_ ) ; if ( dir . exists ( ) ) deletefile ( dir ) ; createnewdirectory ( dir ) ; file tempdir = new file ( dir , name ) ; createnewdirectory ( tempdir ) ; return tempdir . getcanonicalfile ( ) ; }	Creates a temporary directory.
@ suppresswarnings ( str_ ) public static object getproxiedobject ( object proxy ) { if ( proxy . isproxyclass ( proxy . getclass ( ) ) ) { invocationhandler invocationhandler = proxy . getinvocationhandler ( proxy ) ; if ( invocationhandler instanceof objectproxy ) { objectproxy objectproxy = ( objectproxy ) invocationhandler ;	Given a proxy returns the object proxied.
public static class forname ( class clazz , classloader classloader ) throws classnotfoundexception , linkageerror { if ( clazz == null ) return null ; if ( classloader == null ) { classloader = getdefaultclassloader ( ) ; } if ( clazz . getclassloader ( ) == null || clazz . getclassloader ( ) . equals ( classloader ) ) return clazz ; else return forname ( clazz . getname ( ) , classloader ) ; }	Convenient call to return a class in a different class loader..
@ suppresswarnings ( str_ ) public static string computesignature ( method m ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( m . getname ( ) ) . append ( str_ ) ; class [ ] parametertypes = m . getparametertypes ( ) ; for ( int i = num_ ; i < parametertypes . length ; i ++ ) { if ( i > num_ ) sb . append ( str_ ) ; class parametertype = parametertypes [ i ] ; sb . append ( parametertype . getname ( ) ) ; } sb . append ( str_ ) ; return sb . tostring ( ) ; }	Computes the signature of a method.
private static onewaymessagedigestcodec createwellknowninstance ( string algorithm , string password , onewaycodec codec ) { try { return new onewaymessagedigestcodec ( algorithm , password , codec ) ; } catch ( nosuchalgorithmexception e ) { throw new runtimeexception ( e ) ; } catch ( clonenotsupportedexception e ) { throw new runtimeexception ( e ) ; } }	This creates a well known instance.
public void reset ( ) { _scheme = null ; _userinfo = null ; _host = null ; _port = - num_ ; _path = null ; _query = new querybuilder ( ) ; _fragment = null ; _escapefragment = bool_ ; }	Call this method when you want to reset the internal string to startfrom scratch again.
public static urlbuilder createfrompath ( string path ) { urlbuilder res = new urlbuilder ( ) ; res . setpath ( path ) ; return res ; }	Factory method from a path.
public static url addqueryparameter ( url url , string name , string value ) { urlbuilder ub = createfromurl ( url ) ; ub . addqueryparameter ( name , value ) ; return ub ; }	Convenient call which adds a query parameter to the give url.
@ override public string getparameter ( string name ) { string [ ] params = getparametervalues ( name ) ; if ( params == null ) return null ; return params [ num_ ] ; }	Get the first parameter given its name.
private void addqueryparameter ( string name , string value ) { if ( _query . length ( ) > num_ ) _query . append ( str_ ) ; _query . append ( encode ( name ) ) ; _query . append ( str_ ) ; _query . append ( encode ( value ) ) ; }	Add query parameter to query string.
public void addparameters ( map < string , string [ ] > parameters ) { for ( map . entry < string , string [ ] > entry : parameters . entryset ( ) ) { addparameters ( entry . getkey ( ) , entry . getvalue ( ) ) ; } }	Adds the map of parameters.
public void addindexedparameter ( string name , int value , int index ) { addparameter ( getindexedparamname ( name , index ) , value ) ; }	Adds a parameter that comes from an array at the provided index.
public void addquery ( uri uri ) { try { addquery ( uri . getrawquery ( ) , bool_ ) ; } catch ( urisyntaxexception e ) {	Adds the query extracted from the URI.
private void validatequery ( string query ) throws urisyntaxexception { if ( query . length ( ) == num_ ) return ; iterator < string > iter = ss . splittoiterator ( query ) ; while ( iter . hasnext ( ) ) { string s = iter . next ( ) ; if ( s . length ( ) > num_ ) { int idx = s . indexof ( str_ ) ; if ( idx == - num_ ) throw new urisyntaxexception ( query , str_ + s ) ; if ( s . lastindexof ( str_ ) != idx ) throw new urisyntaxexception ( query , str_ + s ) ; } } }	Internal method in charge of validating the query provided.
public void addquery ( query query ) { if ( query == null ) return ; try { if ( ! query . getencoding ( ) . equals ( getencoding ( ) ) ) throw new runtimeexception ( str_ ) ; addquery ( query . getquery ( ) , bool_ ) ; } catch ( urisyntaxexception e ) {	Simply adds the query provided.
private void rebuildquery ( ) { map < string , string [ ] > map = getmap ( ) ;	Rebuild query instance with values in the map.
public string [ ] replaceparameter ( string name , string value ) { map < string , string [ ] > map = getmap ( ) ; string [ ] v = map . put ( name , new string [ ] { value } ) ; rebuildquery ( ) ; return v ; }	Replace existing or add new parameter with givenvalue.
@ override public object invoke ( object o , method method , object [ ] objects ) throws throwable {	Method from the interface. Checks for shutdown then dispatches the call.
public static object createshutdownproxy ( object o , class [ ] interfaces , shutdown shutdown ) { if ( interfaces == null ) interfaces = reflectutils . extractallinterfaces ( o ) ; return proxy . newproxyinstance ( o . getclass ( ) . getclassloader ( ) , interfaces , new shutdownproxy ( o , shutdown ) ) ; }	Creates the proxy to check for shutdown.
public static boolean converttoboolean ( object o ) { if ( o == null ) return bool_ ; if ( o instanceof boolean ) { return ( boolean ) o ; } return converttoboolean ( o . tostring ( ) ) ; }	Converts the object into a boolean value.
public static string getstacktrace ( throwable th ) { stringwriter sw = new stringwriter ( ) ; printwriter pw = new printwriter ( sw ) ; th . printstacktrace ( pw ) ; return sw . tostring ( ) ; }	Returns the stack trace of the throwable as a string.
public static string removetrailingslash ( string path ) { if ( path . endswith ( str_ ) ) return path . substring ( num_ , path . length ( ) - num_ ) ; else return path ; }	Removes a trailing slash if exists.
@ override public void waitforshutdown ( object timeout ) throws interruptedexception , illegalstateexception , timeoutexception { if ( ! _shutdown ) throw new illegalstateexception ( str_ ) ; pendingcallscount . waitforcounter ( timeout ) ; }	Waits for shutdown to be completed.
@ override public void addemptytag ( string tagname , map attributes ) { _xml . append ( str_ ) . append ( tagname ) ; addattributes ( attributes ) ; _xml . append ( str_ ) ; }	Adds an empty tag which contains the attributes specified.
private void addattribute ( string attrname , string attrvalue ) { if ( attrname == null ) return ; _xml . append ( str_ ) ; _xml . append ( attrname ) . append ( str_ ) ; _xml . append ( xmlutils . xmlencode ( attrvalue ) ) . append ( str_ ) ; }	Adds the attribute.
private void addattributes ( map attributes ) { if ( attributes == null ) return ; iterator iter = attributes . keyset ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { string attrname = ( string ) iter . next ( ) ; object attrvalue = attributes . get ( attrname ) ; if ( attrvalue != null ) addattribute ( attrname , attrvalue . tostring ( ) ) ; } }	Adds the attributes. All the properties will be used as attributes.
public static resourceinfo extractinfo ( url url ) throws ioexception { urlconnection urlconnection = url . openconnection ( ) ; urlconnection . setdoinput ( bool_ ) ; urlconnection . setdooutput ( bool_ ) ; urlconnection . setusecaches ( bool_ ) ; urlconnection . connect ( ) ; inputstream is = urlconnection . getinputstream ( ) ; try { return new staticinfo ( urlconnection . getcontentlength ( ) , urlconnection . getlastmodified ( ) ) ; } finally { is . close ( ) ; } }	Extracts the info from the url.
@ override public internalresource chroot ( internalresource resource ) { string path = resource . getpath ( ) ;	Returns a new resource with the root resource set to this resource.
@ override public internalresource [ ] list ( internalresource resource , final resourcefilter filter ) throws ioexception { final list < resource > resources = new arraylist < resource > ( ) ; string path = pathutils . addtrailingslash ( resource . getpath ( ) ) ; if ( dolist ( path , new resourcefilter ( ) { @ override public boolean accept ( resource resource ) { boolean res = filter . accept ( resource ) ; if ( res ) resources . add ( resource ) ; return res ; } } ) ) { return resources . toarray ( new internalresource [ resources . size ( ) ] ) ; } else return null ; }	If this resource denotes a directory, then it will return all resources that are contained inthe directory.
@ override public resource chroot ( string relativepath ) { return _resourceprovider . chroot ( ( internalresource ) createrelative ( relativepath ) ) ; }	Returns a new resource with the root resource set to the relative path provided.
public static resource create ( file file ) { try { string path = file . getcanonicalpath ( ) ; if ( file . isdirectory ( ) ) path = pathutils . addtrailingslash ( path ) ; return create ( new file ( str_ ) , path ) ; } catch ( ioexception e ) { throw new illegalargumentexception ( str_ + file , e ) ; } }	Creates a file resource from a file.
public void start ( ) throws ioexception { _process = _processbuilder . start ( ) ; _out = new inputreader ( new bufferedinputstream ( _process . getinputstream ( ) ) ) ; _err = new inputreader ( new bufferedinputstream ( _process . geterrorstream ( ) ) ) ; _out . start ( ) ; _err . start ( ) ; }	After creating the command, you have to start it...
public static externalcommand create ( list < string > commands ) { externalcommand ec = new externalcommand ( new processbuilder ( commands ) ) ; return ec ; }	Creates an external process from the command. It is not started and you have to callstart on it!.
public static externalcommand start ( string ... commands ) throws ioexception { externalcommand ec = new externalcommand ( new processbuilder ( commands ) ) ; ec . start ( ) ; return ec ; }	Creates an external process from the command.
public static externalcommand execute ( file workingdirectory , string command , string ... args ) throws ioexception , interruptedexception { try { return executewithtimeout ( workingdirectory , command , num_ , args ) ; } catch ( timeoutexception e ) {	Executes the external command in the given working directory and waits for it to befinished.
public long tick ( ) { long tick = _clock . currenttimemillis ( ) ; long diff = tick - _tick ; _tick = tick ; return diff ; }	Returns the number of milliseconds ellapsed since the last call tothis function.
public string getelapsedtime ( ) { stringbuilder sb = new stringbuilder ( str_ ) ; sb . append ( this . tick ( ) ) ; sb . append ( str_ ) ; return sb . tostring ( ) ; }	Returns a string that represents the time elapsed.
@ override public void addtag ( string tagname , int value , string attrname , string attrvalue ) { addtag ( tagname , string . valueof ( value ) , attrname , attrvalue ) ; }	Adds a tag which contains an attribute.
@ override public void addtag ( string tagname , int value , map attributes ) { addtag ( tagname , string . valueof ( value ) , attributes ) ; }	Adds a tag which contains the attributes specified.
public static string indentblock ( string block , indent indent ) { stringbuilder sb = new stringbuilder ( ) ; bufferedreader br = new bufferedreader ( new stringreader ( block ) ) ; string line ; try { while ( ( line = br . readline ( ) ) != null ) sb . append ( indent ) . append ( line ) . append ( str_ ) ; } catch ( ioexception ex ) {	Indents a block of text.
public static long toendtime ( clock clock , object timeout ) { timespan t = totimespan ( timeout ) ; if ( t == null ) return num_ ; if ( clock == null ) clock = systemclock . instance ; if ( t . getdurationinmilliseconds ( ) == num_ ) return num_ ; return t . futuretimemillis ( clock ) ; }	Computes the end time = now + timeout.
public ramentry add ( ramentry entry ) { touch ( ) ; _directorycontent . put ( entry . name ( ) , entry ) ; return entry ; }	Copy the entry in this directory with the provided name.
public ramdirectory mkdir ( string name ) throws ioexception { ramentry entry = getentry ( name ) ; if ( entry instanceof ramdirectory ) { ramdirectory ramdirectory = ( ramdirectory ) entry ; return ramdirectory ; } else { if ( entry == null ) { ramdirectory directory = new ramdirectory ( _clock , name ) ; return ( ramdirectory ) add ( directory ) ; } else { throw new ioexception ( str_ + name ) ; } } }	Creates an empty directory and add it to this directory with this name.
public static string encodestring ( onewaycodec codec , string s ) { try { return codec . encode ( s . getbytes ( str_ ) ) ; } catch ( unsupportedencodingexception ex ) {	Encodes the string using the codec provided.
public static string decodestring ( codec codec , string s ) throws codec . cannotdecodeexception { try { return new string ( codec . decode ( s ) , str_ ) ; } catch ( unsupportedencodingexception ex ) {	Decodes the string using the codec provided. Returns a string.
public static leafresource create ( resource resource ) { try {	Decorates the resource to implement a caching strategy.
public static < t > t [ ] reverse ( t [ ] array ) { if ( array == null ) return array ; int s = num_ ; int e = array . length - num_ ; while ( s < e ) {	Reverses the array in place.
public static < t extends enum < t > > enumset < t > toenumset ( class < t > clazz , t ... ts ) { if ( ts == null ) return null ; enumset < t > res = enumset . noneof ( clazz ) ; for ( t t : ts ) { res . add ( t ) ; } return res ; }	Turns an array of enumeration values into an enum set.
public static properties loadproperties ( file file ) throws ioexception { if ( file == null ) return null ; filereader reader = new filereader ( file ) ; try { return loadproperties ( reader ) ; } finally { reader . close ( ) ; } }	Convenient call to load a properties file from the provided file.
public static properties loadproperties ( reader reader ) throws ioexception { if ( reader == null ) return null ; properties properties = new properties ( ) ; properties . load ( reader ) ; return properties ; }	Convenient call to load a properties file from the provided reader.
public string getasstring ( enumset < timeunit > timeunits ) { stringbuilder sb = new stringbuilder ( ) ; enummap < timeunit , timespan > canonicaltimespans = getastimespans ( timeunits ) ; for ( timeunit timeunit : time_unit_order ) { if ( canonicaltimespans . containskey ( timeunit ) ) { long duration = canonicaltimespans . get ( timeunit ) . getduration ( ) ; if ( duration > num_ ) { sb . append ( duration ) . append ( timeunit . getdisplaychar ( ) ) ; } } } if ( sb . length ( ) == num_ ) { sb . append ( num_ ) ; if ( timeunits . contains ( gettimeunit ( ) ) ) sb . append ( gettimeunit ( ) . getdisplaychar ( ) ) ; } return sb . tostring ( ) ; }	Returns a string representing this timespan expressed with the units provided.
@ override public int compareto ( timespan timespan ) { if ( timespan . gettimeunit ( ) == gettimeunit ( ) ) return langutils . compare ( getduration ( ) , timespan . getduration ( ) ) ; else return langutils . compare ( getdurationinmilliseconds ( ) , timespan . getdurationinmilliseconds ( ) ) ; }	Compares 2 timespan. Based on duration in milliseconds.
public memorysize truncate ( sizeunit sizeunit ) { if ( getsizeunit ( ) == sizeunit ) return this ; long sizeinbytes = getsizeinbytes ( ) ; if ( sizeinbytes >= sizeunit . getbytescount ( ) ) { return new memorysize ( sizeinbytes / sizeunit . getbytescount ( ) , sizeunit ) ; } else { return zero_sizes . get ( sizeunit ) ; } }	Return a new instance of MemorySize that is truncated to the given unit.
public memorysize add ( memorysize other ) { if ( other == null ) throw new nullpointerexception ( ) ; if ( getsizeunit ( ) == other . getsizeunit ( ) ) return new memorysize ( getsize ( ) + other . getsize ( ) , getsizeunit ( ) ) ; return new memorysize ( getsizeinbytes ( ) + other . getsizeinbytes ( ) , sizeunit . byte ) ; }	Return a new instance of MemorySize that adds up the size of this objectwith that of the 'other'.
@ override public int compareto ( memorysize memorysize ) {	Compare with another instance of MemorySize based on size in bytes.
public static memorysize create ( memorysize ... memorysizes ) { if ( memorysizes == null ) return null ; if ( memorysizes . length == num_ ) return zero_bytes ; memorysize res = memorysizes [ num_ ] ; for ( int i = num_ ; i < memorysizes . length ; i ++ ) { memorysize memorysize = memorysizes [ i ] ; if ( memorysize != null ) res = res . add ( memorysize ) ; } return res ; }	Create a new instance of MemorySize by adding up the givenarray of memorySizes.
public static < v > future < v > execute ( callable < v > callable ) { futuretask < v > futuretask = new futuretask < v > ( callable ) ; new thread ( futuretask ) . start ( ) ; return futuretask ; }	Executes the callable in a separate thread and return the future to get the result.
public void addmarker ( t marker ) { final markeroptions markeroptions = new markeroptions ( ) ; marker . setmarkermanager ( this ) ; marker . preparemarker ( markeroptions ) ; markercache . put ( marker , googlemap . addmarker ( markeroptions ) ) ; marker . onadd ( ) ; }	Add a marker to the map.
public void removemarker ( t marker ) { final marker realmarker = markercache . get ( marker ) ; if ( realmarker != null ) { realmarker . remove ( ) ; } markercache . remove ( marker ) ; }	Remove a marker from the map.
public static bitmapdescriptor fromview ( view view ) {	Returns a bitmap icon showing a screenshot of the view passed in.
private final static func1 < watchevent < ? > , boolean > onlyrelatedto ( final file file ) { return new func1 < watchevent < ? > , boolean > ( ) { @ override public boolean call ( watchevent < ? > event ) { final boolean ok ; if ( file . isdirectory ( ) ) ok = bool_ ; else if ( standardwatcheventkinds . overflow . equals ( event . kind ( ) ) ) ok = bool_ ; else { object context = event . context ( ) ; if ( context != null && context instanceof path ) { path p = ( path ) context ; path basepath = getbasepath ( file ) ; file pfile = new file ( basepath . tofile ( ) , p . tostring ( ) ) ; ok = pfile . getabsolutepath ( ) . equals ( file . getabsolutepath ( ) ) ; } else ok = bool_ ; } return ok ; } } ; }	Returns true if and only if the path corresponding to a WatchEventrepresents the given file.
private static boolean emitevents ( watchservice watchservice , subscriber < ? super watchevent < ? > > subscriber , long polldurationms , long pollintervalms ) {	returns true if and only there may be more events.
private statelistdrawable getselectordrawable ( ) { statelistdrawable d = null ; try { d = new statelistdrawable ( ) ; shapedrawable selecteddrawable = new shapedrawable ( new ovalshape ( ) ) ; selecteddrawable . getpaint ( ) . setcolor ( mitemselectedcolor ) ; selecteddrawable . setintrinsicheight ( mitemradius * num_ ) ; selecteddrawable . setintrinsicwidth ( mitemradius * num_ ) ; shapedrawable unselecteddrawable = new shapedrawable ( new ovalshape ( ) ) ; unselecteddrawable . getpaint ( ) . setcolor ( mitemunselectedcolor ) ; unselecteddrawable . setintrinsicheight ( mitemradius * num_ ) ; unselecteddrawable . setintrinsicwidth ( mitemradius * num_ ) ; d . addstate ( new int [ ] { android . r . attr . state_checked } , selecteddrawable ) ; d . addstate ( new int [ ] { } , unselecteddrawable ) ; } catch ( exception e ) { log . e ( tag , getmessagefor ( e ) ) ; } return d ; }	Create a StateListDrawable for the pager indicator.
public void initwithviewpager ( viewpager viewpager ) throws illegalstateexception { if ( viewpager == null ) return ; if ( viewpager . getadapter ( ) == null ) throw new illegalstateexception ( str_ ) ; try { mviewpager = viewpager ; mviewpager . addonpagechangelistener ( monpagechangelistener ) ; addviews ( ) ; } catch ( exception e ) { log . e ( tag , getmessagefor ( e ) ) ; } }	Initialize ViewPagerIndicator with a properly set up ViewPager.
private void addviews ( ) { try { if ( mviewpager == null || mviewpager . getadapter ( ) == null || mviewpager . getadapter ( ) . getcount ( ) == num_ ) return ; removeallviews ( ) ; appcompatradiobutton firstitem = new appcompatradiobutton ( getcontext ( ) ) ; firstitem . settext ( str_ ) ; firstitem . setbuttondrawable ( mbuttondrawable . getconstantstate ( ) . newdrawable ( ) ) ; viewpagerindicator . layoutparams params = new layoutparams ( layoutparams . wrap_content , layoutparams . wrap_content ) ; firstitem . setlayoutparams ( params ) ; firstitem . setclickable ( bool_ ) ; addview ( firstitem ) ; for ( int i = num_ ; i < mviewpager . getadapter ( ) . getcount ( ) ; i ++ ) { appcompatradiobutton item = new appcompatradiobutton ( getcontext ( ) ) ; item . settext ( str_ ) ; item . setbuttondrawable ( mbuttondrawable . getconstantstate ( ) . newdrawable ( ) ) ; params = new layoutparams ( layoutparams . wrap_content , layoutparams . wrap_content ) ; params . setmargins ( mitemdividerwidth , num_ , num_ , num_ ) ; item . setlayoutparams ( params ) ; item . setclickable ( bool_ ) ; addview ( item ) ; } check ( firstitem . getid ( ) ) ; } catch ( exception e ) { log . e ( tag , getmessagefor ( e ) ) ; } }	Add page indicators based on the attached ViewPager.
private string getmessagefor ( exception e ) { if ( e == null ) return tag + str_ ; return e != null && e . getmessage ( ) != null ? e . getmessage ( ) : e . getclass ( ) . getname ( ) + str_ ; }	Always get a message for an exception.
private static int intvalue ( char x ) { if ( x >= str_ && x <= str_ ) return x - str_ ; if ( x >= str_ && x <= str_ ) return x - str_ + num_ ; if ( x >= str_ && x <= str_ ) return x - str_ + num_ ; throw new runtimeexception ( str_ + x ) ; }	This method maps a hex character to its 4-bit representation in an int.
private static byte maptobyte ( char a , char b ) { int ai = intvalue ( a ) ; int bi = intvalue ( b ) ; return ( byte ) ( ( ai << num_ ) | bi ) ; }	Map two hex characters to 4-bit numbers and combine them to produce 8-bit number in byte.
public date gettimestamp ( ) { if ( getversion ( ) != version ) return null ; long time ; time = ( ( long ) content [ num_ ] & num_ ) << num_ ; time |= ( ( long ) content [ num_ ] & num_ ) << num_ ; time |= ( ( long ) content [ num_ ] & num_ ) << num_ ; time |= ( ( long ) content [ num_ ] & num_ ) << num_ ; time |= ( ( long ) content [ num_ ] & num_ ) << num_ ; time |= ( ( long ) content [ num_ ] & num_ ) ; return new date ( time ) ; }	Extract timestamp from raw UUID bytes and return as int.
public byte [ ] getmacfragment ( ) { if ( getversion ( ) != str_ ) return null ; byte [ ] x = new byte [ num_ ] ; x [ num_ ] = num_ ; x [ num_ ] = num_ ; x [ num_ ] = ( byte ) ( content [ num_ ] & num_ ) ; x [ num_ ] = content [ num_ ] ; x [ num_ ] = content [ num_ ] ; x [ num_ ] = content [ num_ ] ; return x ; }	Extract MAC address fragment from raw UUID bytes, setting missing values to 0, thus the first 2 and a half byteswill be 0, followed by 3 and a half bytes of the active MAC address when the UUID was generated.
public void setproperty ( string key , string value ) { if ( properties == null ) { properties = createproperties ( ) ; } if ( value != null ) { value = value . trim ( ) ; properties . put ( key , value ) ; } else { properties . remove ( key ) ; } }	Sets a custom property.
@ deprecated public void setfacebookusercredentials ( string userid , string token ) { setproperty ( socializeconfig . facebook_user_id , userid ) ; setproperty ( socializeconfig . facebook_user_token , token ) ; }	Sets the FB credentials for the current user if available.
public void setsocializecredentials ( string consumerkey , string consumersecret ) { setproperty ( socializeconfig . socialize_consumer_key , consumerkey ) ; setproperty ( socializeconfig . socialize_consumer_secret , consumersecret ) ; }	Sets the Socialize credentials for your App.
public void merge ( properties other , set < string > toberemoved ) { if ( properties == null ) { properties = createproperties ( ) ; } if ( other != null && other . size ( ) > num_ ) { set < entry < object , object > > entryset = other . entryset ( ) ; for ( entry < object , object > entry : entryset ) { properties . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } if ( toberemoved != null && toberemoved . size ( ) > num_ ) { for ( string key : toberemoved ) { properties . remove ( key ) ; } toberemoved . clear ( ) ; } }	Merge properties into the config.
protected void doshare ( final activity context , final entity entity , final sharetype sharetype , final shareaddlistener shareaddlistener ) { final socializesession session = getsocialize ( ) . getsession ( ) ; sharesystem . addshare ( context , session , entity , str_ , sharetype , null , new shareaddlistener ( ) { @ override public void onerror ( socializeexception error ) { if ( shareaddlistener != null ) { shareaddlistener . onerror ( error ) ; } } @ override public void oncreate ( share share ) { if ( share != null && sharesystem != null ) { handlenonnetworkshare ( context , session , sharetype , share , str_ , null , shareaddlistener ) ; } } } ) ; }	Creates the socialize share object.
protected void handlenonnetworkshare ( activity activity , final socializesession session , final sharetype sharetype , final share share , string sharetext , location location , final shareaddlistener shareaddlistener ) { socialnetworklistener snlistener = new socialnetworklistener ( ) { @ override public void onnetworkerror ( activity context , socialnetwork network , exception error ) { if ( shareaddlistener != null ) { shareaddlistener . onerror ( socializeexception . wrap ( error ) ) ; } } @ override public void oncancel ( ) { if ( shareaddlistener != null ) { shareaddlistener . oncancel ( ) ; } } @ override public boolean onbeforepost ( activity parent , socialnetwork socialnetwork , postdata postdata ) { return shareaddlistener instanceof socialnetworklistener && ( ( simplesharelistener ) shareaddlistener ) . onbeforepost ( parent , socialnetwork , postdata ) ; } @ override public void onafterpost ( activity parent , socialnetwork socialnetwork , jsonobject responseobject ) { if ( shareaddlistener != null ) { shareaddlistener . oncreate ( share ) ; } } } ; sharesystem . share ( activity , session , share , sharetext , location , sharetype , snlistener ) ; }	Handles a non-network share like email or SMS.
public static void addcomment ( activity context , entity entity , string text , commentaddlistener listener ) { proxy . addcomment ( context , entity , text , listener ) ; }	Adds a comment to the given entity.
public static void deletecomment ( activity context , long id , commentdeletelistener listener ) { proxy . deletecomment ( context , id , listener ) ; }	Deletes a comment. Only the person that created the comment can delete it.
public static void getcomment ( activity context , commentgetlistener listener , long id ) { proxy . getcomment ( context , id , listener ) ; }	Retrieves a single comment based on ID.
public static void getcomments ( activity context , commentlistlistener listener , long ... ids ) { proxy . getcomments ( context , listener , ids ) ; }	Retrieves comments based on a set of IDs.
public static void getcommentsbyuser ( activity context , user user , int start , int end , commentlistlistener listener ) { proxy . getcommentsbyuser ( context , user , start , end , listener ) ; }	Retrieves all comments made by the given user.
public static void getcommentsbyentity ( activity context , string entitykey , int start , int end , commentlistlistener listener ) { proxy . getcommentsbyentity ( context , entitykey , start , end , listener ) ; }	Retrieves all comments associated with the given entity.
public static void getcommentsbyapplication ( activity context , int start , int end , commentlistlistener listener ) { proxy . getcommentsbyapplication ( context , start , end , listener ) ; }	Retrieves all comments across all entities.
public static void showcommentview ( activity context , entity entity , oncommentviewactionlistener listener ) { proxy . showcommentview ( context , entity , listener ) ; }	Shows the comments for an entity.
public jsonobject parseobject ( string json ) throws jsonexception { json = json . trim ( ) ; if ( json . startswith ( str_ ) ) { jsonarray array = new jsonarray ( json ) ; jsonobject obj = new jsonobject ( ) ; obj . put ( str_ , array ) ; return obj ; } else { return new jsonobject ( json ) ; } }	Detects whether the inbound string is a JSONArray and if so wraps the array in an object with a single field called "data".
public static jsonobject parsejson ( string response ) throws jsonexception , facebookerror {	Parse a server response into a JSON Object.
public static void showalert ( context context , string title , string text ) { builder alertbuilder = new builder ( context ) ; alertbuilder . settitle ( title ) ; alertbuilder . setmessage ( text ) ; alertbuilder . create ( ) . show ( ) ; }	Display a simple alert dialog with the given text and title.
public static void logd ( string tag , string msg ) { if ( enable_log ) { log . d ( tag , msg ) ; } }	A proxy for Log.d api that kills log messages in release build.
private type getruntimetypeifmorespecific ( type type , object value ) { if ( value != null && ( type == object . class || type instanceof typevariable < ? > || type instanceof class < ? > ) ) { type = value . getclass ( ) ; } return type ; }	Finds a compatible runtime type if it is more specific.
public void setentitysafe ( entity entity ) { if ( stringutils . isempty ( entity . getname ( ) ) ) { setentitykey ( entity . getkey ( ) ) ; } else { setentity ( entity ) ; } }	Reverts to only set the entity key if the name is not defined.This ensures an existing entity name is not wiped out when the action is saved.
public string buildprofileimageurl ( string id ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( str_ ) ; builder . append ( id ) ; builder . append ( str_ ) ; return builder . tostring ( ) ; }	Constructs the URL to access the FB graph API and retrieve a profile image for theuser with the given facebook id.
public void onimagechange ( bitmap bitmap ) { if ( bitmap != null ) { bitmap scaled = bitmaputils . getscaledbitmap ( bitmap , num_ , num_ ) ; content . onprofilepicturechange ( scaled ) ; } }	Called when the profile picture has been changed by the user.
public string generate ( ) throws oauthmessagesignerexception { try { string normalizedurl = normalizerequesturl ( ) ; string normalizedparams = normalizerequestparameters ( ) ; return request . getmethod ( ) + str_ + oauth . percentencode ( normalizedurl ) + str_ + oauth . percentencode ( normalizedparams ) ; } catch ( exception e ) { throw new oauthmessagesignerexception ( e ) ; } }	Builds the signature base string from the data this instance wasconfigured with.
public string normalizerequestparameters ( ) throws ioexception { if ( requestparameters == null ) { return str_ ; } stringbuilder sb = new stringbuilder ( ) ; iterator < string > iter = requestparameters . keyset ( ) . iterator ( ) ; for ( int i = num_ ; iter . hasnext ( ) ; i ++ ) { string param = iter . next ( ) ; if ( oauth . oauth_signature . equals ( param ) || str_ . equals ( param ) ) { continue ; } if ( i > num_ ) { sb . append ( str_ ) ; } sb . append ( requestparameters . getasquerystring ( param ) ) ; } return sb . tostring ( ) ; }	Normalizes the set of request parameters this instance was configuredwith, as per OAuth spec section 9.1.1.
public void authorize ( activity activity , final dialoglistener listener ) { authorize ( activity , new string [ ] { } , default_auth_activity_code , listener ) ; }	Default authorize method. Grants only basic permissions.See authorize() below for .
private boolean validateactivityintent ( context context , intent intent ) { resolveinfo resolveinfo = context . getpackagemanager ( ) . resolveactivity ( intent , num_ ) ; if ( resolveinfo == null ) { return bool_ ; } return validateappsignatureforpackage ( context , resolveinfo . activityinfo . packagename ) ; }	Helper to validate an activity intent by resolving and checking theprovider's package signature.
public string logout ( context context ) throws malformedurlexception , ioexception { util . clearcookies ( context ) ; bundle b = new bundle ( ) ; b . putstring ( str_ , str_ ) ; string response = request ( b ) ; setaccesstoken ( null ) ; setaccessexpires ( num_ ) ; return response ; }	Invalidate the current user session by removing the access token inmemory, clearing the browser cookie, and calling auth.expireSessionthrough the API.Note that this method blocks waiting for a network response, so do notcall it in a UI thread.
public void dialog ( context context , string action , bundle parameters , final dialoglistener listener ) { string endpoint = dialog_base_url + action ; parameters . putstring ( str_ , str_ ) ; parameters . putstring ( str_ , redirect_uri ) ; if ( action . equals ( login ) ) { parameters . putstring ( str_ , str_ ) ; parameters . putstring ( str_ , mappid ) ; } else { parameters . putstring ( str_ , mappid ) ; } if ( issessionvalid ( ) ) { parameters . putstring ( token , getaccesstoken ( ) ) ; } string url = endpoint + str_ + util . encodeurl ( parameters ) ; if ( context . checkcallingorselfpermission ( manifest . permission . internet ) != packagemanager . permission_granted ) { util . showalert ( context , str_ , str_ ) ; } else { new fbdialog ( context , url , listener ) . show ( ) ; } }	Generate a UI dialog for the request action in the given Android contextwith the provided parameters.Note that this method is asynchronous and the callback will be invoked inthe original calling thread (not in a background thread).
@ deprecated public static void link ( activity context , socializeauthlistener listener ) { proxy . link ( context , listener ) ; }	Links the current user to a facebook account.
@ deprecated public static void link ( activity context , socializeauthlistener listener , string ... permissions ) { proxy . link ( context , listener , permissions ) ; }	Links the current user to a facebook account with custom FB permissions.
@ deprecated public static void link ( activity context , string token , boolean verifypermissions , socializeauthlistener listener ) { proxy . link ( context , token , verifypermissions , listener ) ; }	Links an existing Facebook access token with the current user.
public static void postentity ( final activity context , final entity entity , final string text , final socialnetworksharelistener listener ) { if ( proxy . islinkedforwrite ( context ) ) { proxy . postentity ( context , entity , text , listener ) ; } else { proxy . linkforwrite ( context , new socializeauthlistener ( ) { @ override public void onerror ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . facebook , error ) ; } } @ override public void oncancel ( ) { if ( listener != null ) { listener . oncancel ( ) ; } } @ override public void onauthsuccess ( socializesession session ) { proxy . postentity ( context , entity , text , listener ) ; } @ override public void onauthfail ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . facebook , error ) ; } } } ) ; } }	Posts an entity to the user's Facebook wall.
@ deprecated public static void extendaccesstoken ( activity context , socializeauthlistener listener ) { proxy . extendaccesstoken ( context , listener ) ; }	Extends the user's Facebook access token if needed.
public static void getcurrentpermissions ( activity context , string token , onpermissionresult callback ) { proxy . getcurrentpermissions ( context , token , callback ) ; }	Retrieves the current permissions for token provided.
public static string [ ] gethashkeys ( activity context ) throws nosuchalgorithmexception { packageinfo packageinfo = null ; string [ ] keys = null ; try { packageinfo = context . getpackagemanager ( ) . getpackageinfo ( context . getpackagename ( ) , packagemanager . get_signatures ) ; if ( packageinfo != null && packageinfo . signatures != null && packageinfo . signatures . length > num_ ) { keys = new string [ packageinfo . signatures . length ] ; for ( int i = num_ ; i < packageinfo . signatures . length ; i ++ ) { signature signature = packageinfo . signatures [ i ] ; messagedigest md = messagedigest . getinstance ( str_ ) ; md . update ( signature . tobytearray ( ) ) ; string hash = new string ( base64 . encode ( md . digest ( ) , num_ ) ) ; keys [ i ] = hash ; } } } catch ( packagemanager . namenotfoundexception e ) { e . printstacktrace ( ) ; } return keys ; }	Returns the hash key used to authenticate this application with Facebook.
public static void saveentity ( activity context , entity e , entityaddlistener listener ) { proxy . saveentity ( context , e , listener ) ; }	Saves or Creates an entity.
public static void getentity ( activity context , string key , entitygetlistener listener ) { proxy . getentity ( context , key , listener ) ; }	Retrieves an entity based on its key.
public static void getentity ( activity context , long id , entitygetlistener listener ) { proxy . getentity ( context , id , listener ) ; }	Retrieves an entity based on its id.
public static void getentities ( activity context , int start , int end , entitylistlistener listener ) { proxy . getentities ( context , start , end , sortorder . creation_date , listener ) ; }	Retrieves all entities sorted by creation date.
public static void getentities ( activity context , entitylistlistener listener , string ... keys ) { proxy . getentities ( context , sortorder . creation_date , listener , keys ) ; }	Retrieves the entities designated by the given keys.
@ override public boolean oncreatecontextmenu ( socializeuiactivity activity , contextmenu menu , view v , contextmenu . contextmenuinfo menuinfo ) { return bool_ ; }	Called BEFORE the default activity onCreateContextMenu event.
public static void subscribe ( activity context , entity e , subscriptiontype type , subscriptionresultlistener listener ) { subscriptionutils . subscribe ( context , e , type , listener ) ; }	Subscribes the current user to notifications for new comments on this entity.
public static void issubscribed ( activity context , entity e , subscriptiontype type , subscriptionchecklistener listener ) { subscriptionutils . issubscribed ( context , e , type , listener ) ; }	Determines if the current user is subscribed to notifications on new comments for the given entity.
public boolean checkregistrations ( context context , socializesession session ) { boolean checked = bool_ ; if ( ! checking ) { checking = bool_ ; try { if ( apputils . isnotificationsavailable ( context ) ) { if ( config . getbooleanproperty ( socializeconfig . socialize_check_notifications , bool_ ) ) { if ( logger != null && logger . isdebugenabled ( ) ) { logger . debug ( str_ ) ; } boolean c2dmregistered = notificationregistrationsystem . isregisteredc2dm ( context ) ; boolean socregistered = notificationregistrationsystem . isregisteredsocialize ( context , session . getuser ( ) ) ; if ( ! c2dmregistered || ! socregistered ) {	Called at application startup.
public jsontoken peek ( ) throws ioexception { if ( token != null ) { return token ; } switch ( stack [ stacksize - num_ ] ) { case empty_document : if ( lenient ) { consumenonexecuteprefix ( ) ; } stack [ stacksize - num_ ] = jsonscope . nonempty_document ; jsontoken firsttoken = nextvalue ( ) ; if ( ! lenient && token != jsontoken . begin_array && token != jsontoken . begin_object ) { throw new ioexception ( str_ + token + str_ + getlinenumber ( ) + str_ + getcolumnnumber ( ) ) ; } return firsttoken ; case empty_array : return nextinarray ( bool_ ) ; case nonempty_array : return nextinarray ( bool_ ) ; case empty_object : return nextinobject ( bool_ ) ; case dangling_name : return objectvalue ( ) ; case nonempty_object : return nextinobject ( bool_ ) ; case nonempty_document : int c = nextnonwhitespace ( bool_ ) ; if ( c == - num_ ) { return jsontoken . end_document ; } pos -- ; if ( ! lenient ) { throw syntaxerror ( str_ ) ; } return nextvalue ( ) ; case closed : throw new illegalstateexception ( str_ ) ; default : throw new assertionerror ( ) ; } }	Returns the type of the next token without consuming it.
public void nextnull ( ) throws ioexception { peek ( ) ; if ( token != jsontoken . null ) { throw new illegalstateexception ( str_ + token + str_ + getlinenumber ( ) + str_ + getcolumnnumber ( ) ) ; } advance ( ) ; }	Consumes the next token from the JSON stream and asserts that it is aliteral null.
private char readescapecharacter ( ) throws ioexception { if ( pos == limit && ! fillbuffer ( num_ ) ) { throw syntaxerror ( str_ ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case str_ : if ( pos + num_ > limit && ! fillbuffer ( num_ ) ) { throw syntaxerror ( str_ ) ; }	Unescapes the character identified by the character or characters thatimmediately follow a backslash.
public static void showsharedialog ( activity context , entity entity ) { proxy . showsharedialog ( context , entity , default , null , null ) ; }	Displays the default share dialog.
public static void showsharedialog ( activity context , entity entity , socialnetworkdialoglistener listener ) { proxy . showsharedialog ( context , entity , default , listener , listener ) ; }	Displays the default share dialog and allows for the handling of share dialog events.
public static void shareviaemail ( activity context , entity entity , shareaddlistener listener ) { proxy . shareviaemail ( context , entity , listener ) ; }	Shares the given entity via email.
public static void shareviagoogleplus ( activity context , entity entity , shareaddlistener listener ) { proxy . shareviagoogleplus ( context , entity , listener ) ; }	Shares the given entity via Google+.
public static void shareviaother ( activity context , entity entity , shareaddlistener listener ) { proxy . shareviaother ( context , entity , listener ) ; }	Shares the given entity via a user selected medium.
public static void shareviasms ( activity context , entity entity , shareaddlistener listener ) { proxy . shareviasms ( context , entity , listener ) ; }	Shares the given entity via SMS.
public static void shareviasocialnetworks ( activity context , entity entity , shareoptions shareoptions , socialnetworksharelistener listener , socialnetwork ... networks ) { proxy . shareviasocialnetworks ( context , entity , shareoptions , listener , networks ) ; }	Shares the given entity via a Social Network such as Twitter or Facebook.
public static void getshare ( activity context , sharegetlistener listener , long id ) { proxy . getshare ( context , listener , id ) ; }	Retrieves a single share event based on ID.
public static void getshares ( activity context , sharelistlistener listener , long ... ids ) { proxy . getshares ( context , listener , ids ) ; }	Retrieves multiple share events based on ID.
public static void getsharesbyuser ( activity context , user user , int start , int end , sharelistlistener listener ) { proxy . getsharesbyuser ( context , user , start , end , listener ) ; }	Retrieves all share events performed by the given user.
public static void getsharesbyentity ( activity context , string entitykey , int start , int end , sharelistlistener listener ) { proxy . getsharesbyentity ( context , entitykey , start , end , listener ) ; }	Retrieves all share events performed on the given entity.
public static void getsharesbyapplication ( activity context , int start , int end , sharelistlistener listener ) { proxy . getsharesbyapplication ( context , start , end , listener ) ; }	Retrieves all share events across all entities.
public static void like ( activity context , entity entity , likeaddlistener listener ) { proxy . like ( context , entity , listener ) ; }	Records a like against the given entity for the current user.
public static void like ( activity context , entity entity , likeoptions likeoptions , likeaddlistener listener , socialnetwork ... networks ) { proxy . like ( context , entity , likeoptions , listener , networks ) ; }	Records a like against the given entity for the current user.
public static void unlike ( activity context , string entitykey , likedeletelistener listener ) { proxy . unlike ( context , entitykey , listener ) ; }	Removes a like previously created for the current user.
public static void getlike ( activity context , string entitykey , likegetlistener listener ) { proxy . getlike ( context , entitykey , listener ) ; }	Retrieves a like for an entity and the current user.
public static void getlike ( activity context , long id , likegetlistener listener ) { proxy . getlike ( context , id , listener ) ; }	Retrieves a like based on its ID.
public static void isliked ( activity context , string entitykey , islikedlistener listener ) { proxy . getlike ( context , entitykey , listener ) ; }	Determines if the given entity has been liked by the current user.
public static void getlikesbyuser ( activity context , user user , int start , int end , likelistlistener listener ) { proxy . getlikesbyuser ( context , user , start , end , listener ) ; }	Lists all likes for the given user.
public static void getlikesbyentity ( activity context , string entitykey , int start , int end , likelistlistener listener ) { proxy . getlikesbyentity ( context , entitykey , start , end , listener ) ; }	Lists all likes for the given entity.
protected void collectheaderparameters ( httprequest request , httpparameters out ) { httpparameters headerparams = oauth . oauthheadertoparamsmap ( request . getheader ( oauth . http_authorization_header ) ) ; out . putall ( headerparams , bool_ ) ; }	Collects OAuth Authorization header parameters as per OAuth Core 1.0 specsection 9.1.1.
protected void collectbodyparameters ( httprequest request , httpparameters out ) throws ioexception {	Collects x-www-form-urlencoded body parameters as per OAuth Core 1.0 specsection 9.1.1.
protected void collectqueryparameters ( httprequest request , httpparameters out ) { string url = request . getrequesturl ( ) ; int q = url . indexof ( str_ ) ; if ( q >= num_ ) {	Collects HTTP GET query string parameters as per OAuth Core 1.0 specsection 9.1.1.
private jsonwriter newjsonwriter ( writer writer ) throws ioexception { if ( generatenonexecutablejson ) { writer . write ( json_non_executable_prefix ) ; } jsonwriter jsonwriter = new jsonwriter ( writer ) ; if ( prettyprinting ) { jsonwriter . setindent ( str_ ) ; } jsonwriter . setserializenulls ( serializenulls ) ; return jsonwriter ; }	Returns a new JSON writer configured for this GSON and with the non-executeprefix if that is configured.
@ suppresswarnings ( str_ )	Constructors for common interface types like Map and List and theirsubytpes.
public static string replacenewlines ( string src , int from , int to ) { if ( src != null && from > num_ && to < from ) { string strfrom = str_ ; string strto = str_ ; for ( int i = num_ ; i < from ; i ++ ) { strfrom += str_ ; } for ( int i = num_ ; i < to ; i ++ ) { strto += str_ ; } while ( src . contains ( strfrom ) ) { src = src . replaceall ( strfrom , strto ) ; } } return src ; }	Replaces successive new line characters.
public string getsimplelocation ( address address ) { stringbuilder builder = new stringbuilder ( ) ; string locality = address . getlocality ( ) ; string countryname = address . getcountryname ( ) ; if ( ! stringutils . isempty ( locality ) ) { builder . append ( locality ) ; } else if ( ! stringutils . isempty ( countryname ) ) { builder . append ( countryname ) ; } return builder . tostring ( ) ; }	Returns a simple one-line address based on city and country.
protected void getuser ( final session session , final authproviderlistener listener ) { request . executemerequestasync ( session , new request . graphusercallback ( ) {	so we can mock.
public static void getactionsbyapplication ( activity context , int start , int end , actionlistlistener listener ) { proxy . getactionsbyapplication ( context , start , end , listener ) ; }	Gets the application-wide actions.
public static void getactionsbyuser ( activity context , long userid , int start , int end , actionlistlistener listener ) { proxy . getactionsbyuser ( context , userid , start , end , listener ) ; }	Gets the actions of a single user.
public static void getactionsbyentity ( activity context , string entitykey , int start , int end , actionlistlistener listener ) { proxy . getactionsbyentity ( context , entitykey , start , end , listener ) ; }	Gets the actions for a given entity.
public static void getactionsbyuserandentity ( activity context , long userid , string entitykey , int start , int end , actionlistlistener listener ) { proxy . getactionsbyuserandentity ( context , userid , entitykey , start , end , listener ) ; }	Gets the actions of a single user on a single entity.
private jsonwriter close ( jsonscope empty , jsonscope nonempty , string closebracket ) throws ioexception { jsonscope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new illegalstateexception ( str_ + stack ) ; } if ( deferredname != null ) { throw new illegalstateexception ( str_ + deferredname ) ; } stack . remove ( stack . size ( ) - num_ ) ; if ( context == nonempty ) { newline ( ) ; } out . write ( closebracket ) ; return this ; }	Closes the current scope by appending any necessary whitespace and thegiven bracket.
public jsonwriter name ( string name ) throws ioexception { if ( name == null ) { throw new nullpointerexception ( str_ ) ; } if ( deferredname != null ) { throw new illegalstateexception ( ) ; } deferredname = name ; return this ; }	Encodes the property name.
public jsonelement parse ( reader json ) throws jsonioexception , jsonsyntaxexception { try { jsonreader jsonreader = new jsonreader ( json ) ; jsonelement element = parse ( jsonreader ) ; if ( ! element . isjsonnull ( ) && jsonreader . peek ( ) != jsontoken . end_document ) { throw new jsonsyntaxexception ( str_ ) ; } return element ; } catch ( malformedjsonexception e ) { throw new jsonsyntaxexception ( e ) ; } catch ( ioexception e ) { throw new jsonioexception ( e ) ; } catch ( numberformatexception e ) { throw new jsonsyntaxexception ( e ) ; } }	Parses the specified JSON string into a parse tree.
public jsonelement parse ( jsonreader json ) throws jsonioexception , jsonsyntaxexception { boolean lenient = json . islenient ( ) ; json . setlenient ( bool_ ) ; try { return streams . parse ( json ) ; } catch ( stackoverflowerror e ) { throw new jsonparseexception ( str_ + json + str_ , e ) ; } catch ( outofmemoryerror e ) { throw new jsonparseexception ( str_ + json + str_ , e ) ; } catch ( jsonparseexception e ) { if ( e . getcause ( ) instanceof eofexception ) { return jsonnull . instance ; } throw e ; } finally { json . setlenient ( lenient ) ; } }	Returns the next value from the JSON stream as a parse tree.
public static void link ( activity context , string token , string secret , socializeauthlistener listener ) { proxy . link ( context , token , secret , listener ) ; }	Links the current user to their Twitter account using an existing Twitter oAuth token and secret.
public static void setcredentials ( context context , string consumerkey , string consumersecret ) { proxy . setcredentials ( context , consumerkey , consumersecret ) ; }	Sets the Twitter App credentials for the application.
public static void tweetentity ( final activity context , final entity entity , final string text , final socialnetworksharelistener listener ) { if ( proxy . islinked ( context ) ) { proxy . tweetentity ( context , entity , text , listener ) ; } else { proxy . link ( context , new socializeauthlistener ( ) { @ override public void onerror ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . twitter , error ) ; } } @ override public void oncancel ( ) { if ( listener != null ) { listener . oncancel ( ) ; } } @ override public void onauthsuccess ( socializesession session ) { proxy . tweetentity ( context , entity , text , listener ) ; } @ override public void onauthfail ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . twitter , error ) ; } } } ) ; } }	"Tweets" an entity. A "share" event will be recorded in Socialize and the entity URL generated by Socialize will be posted to the user's Twitter feed.If the user is not currently linked to a Twitter account they will be prompted to authenticate.
public static void get ( final activity context , final string resource , final map < string , object > params , final socialnetworkpostlistener listener ) { if ( proxy . islinked ( context ) ) { proxy . get ( context , resource , params , listener ) ; } else { proxy . link ( context , new socializeauthlistener ( ) { @ override public void onerror ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . twitter , error ) ; } } @ override public void oncancel ( ) { if ( listener != null ) { listener . oncancel ( ) ; } } @ override public void onauthsuccess ( socializesession session ) { proxy . get ( context , resource , params , listener ) ; } @ override public void onauthfail ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . twitter , error ) ; } } } ) ; } }	Performs a simple HTTP GET to the Twitter resource endpoint specified.
public static void tweet ( final activity context , final tweet tweet , final socialnetworklistener listener ) { if ( proxy . islinked ( context ) ) { proxy . tweet ( context , tweet , listener ) ; } else { proxy . link ( context , new socializeauthlistener ( ) { @ override public void onerror ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . twitter , error ) ; } } @ override public void oncancel ( ) { if ( listener != null ) { listener . oncancel ( ) ; } } @ override public void onauthsuccess ( socializesession session ) { proxy . tweet ( context , tweet , listener ) ; } @ override public void onauthfail ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . twitter , error ) ; } } } ) ; } }	Performs a simple "tweet".
public static void tweetphoto ( final activity context , final phototweet photo , final socialnetworkpostlistener listener ) { if ( proxy . islinked ( context ) ) { proxy . tweetphoto ( context , photo , listener ) ; } else { proxy . link ( context , new socializeauthlistener ( ) { @ override public void onerror ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . twitter , error ) ; } } @ override public void oncancel ( ) { if ( listener != null ) { listener . oncancel ( ) ; } } @ override public void onauthsuccess ( socializesession session ) { proxy . tweetphoto ( context , photo , listener ) ; } @ override public void onauthfail ( socializeexception error ) { if ( listener != null ) { listener . onnetworkerror ( context , socialnetwork . twitter , error ) ; } } } ) ; } }	Publishes a photo to a user's Twitter feed.
public bitmap getscaledbitmap ( bitmap bitmap , int scaletowidth , int scaletoheight , boolean recycleoriginal , int density ) { bitmap . setdensity ( density ) ; bitmap original = bitmap ; if ( scaletowidth > num_ || scaletoheight > num_ ) { int width = bitmap . getwidth ( ) ; int height = bitmap . getheight ( ) ;	Returns a scaled bitmap, cropped if necessary.
@ suppresswarnings ( str_ ) public void putaspostasync ( socializesession session , string endpoint , t object , socializeactionlistener listener ) { asyncputter poster = new asyncputter ( session , listener ) ; socializeputrequest < t > request = new socializeputrequest < t > ( ) ; request . setrequesttype ( requesttype . put_as_post ) ; request . setendpoint ( endpoint ) ; request . setobject ( object ) ; poster . execute ( request ) ; }	Does a POST, but expects a single object in return.
public void settextsize ( int textsize ) { if ( textview != null ) { textview . settextsize ( android . util . typedvalue . complex_unit_dip , textsize ) ; } this . textsize = textsize ; }	Set the text size in DIP.
public void onimagechange ( bitmap bitmap , string localpath ) { if ( profilelayoutview != null ) { profilelayoutview . onimagechange ( bitmap ) ; }	Called when the user's profile image is changed.
public static void saveuserasync ( context context , user user , usersavelistener listener ) { proxy . saveuserasync ( context , user , listener ) ; }	Saves the given user.
public static void getuser ( context context , long id , usergetlistener listener ) { proxy . getuser ( context , id , listener ) ; }	Retrieves a User based on the given ID.
public static void saveusersettings ( context context , usersettings usersettings , usersavelistener listener ) { proxy . saveusersettings ( context , usersettings , listener ) ; }	Saves the profile for the given user.
@ deprecated public boolean setautopostpreferences ( socialnetwork ... networks ) { boolean tw = isautoposttotwitter ( ) ; boolean fb = isautoposttofacebook ( ) ; setautoposttofacebook ( bool_ ) ; setautoposttotwitter ( bool_ ) ; if ( networks != null ) { for ( socialnetwork network : networks ) { if ( network . equals ( socialnetwork . facebook ) ) { setautoposttofacebook ( bool_ ) ; } else if ( network . equals ( socialnetwork . twitter ) ) { setautoposttotwitter ( bool_ ) ; } } } return tw != isautoposttotwitter ( ) || fb != isautoposttofacebook ( ) ; }	Sets the auto post preferences for the user.
@ deprecated public void authenticate ( activity context ) { authenticate ( context , facebookfacade . default_permissions , bool_ , bool_ ) ; }	Authenticates with default permissions and Single Sign On.
public void authenticateforread ( activity context , boolean sso , string [ ] permissions ) { authenticate ( context , permissions , sso , bool_ ) ; }	Authenticates with Single Sign On.
@ suppresswarnings ( str_ ) public static final < e extends object > e getstaticfield ( string fieldname , class < ? > clazz ) throws exception { try { field field = clazz . getfield ( fieldname ) ; if ( field != null ) { return ( e ) field . get ( null ) ; } } catch ( exception e ) { throw e ; } return null ; }	Gets the value of the given static field from the given class.
public static final string getstaticfieldname ( object value , class < ? > clazz ) throws exception { field [ ] fields = clazz . getfields ( ) ; for ( field field : fields ) { object fval = field . get ( null ) ; if ( fval != null && fval . equals ( value ) ) { return field . getname ( ) ; } } return null ; }	Returns the name of the static field that corresponds to the given value.
public static boolean onmessage ( context context , intent intent ) { assertinitialized ( context ) ; bundle messagedata = intent . getextras ( ) ; if ( messagedata != null ) { string source = messagedata . getstring ( c2dmcallback . source_key ) ; if ( source != null && source . trim ( ) . equalsignorecase ( c2dmcallback . source_socialize ) ) { handler . onmessage ( context , intent ) ; return bool_ ; } } return bool_ ; }	Handles a GCM message.
public static boolean handlebroadcastintent ( context context , intent intent ) { return socialize . getsocialize ( ) . handlebroadcastintent ( context , intent ) ; }	Handles a broadcast intent received by a Broadcast Receiver on Android.Call this method if you already have a broadcast receiver defined but want to also utilize Socialize SmartAlerts.
public byte [ ] encode ( byte [ ] source , int off , int len , byte [ ] alphabet , int maxlinelength ) { int lendiv3 = ( len + num_ ) / num_ ;	Encodes a byte array into Base64 notation.
public byte [ ] decode ( byte [ ] source , int off , int len , byte [ ] decodabet ) throws base64decoderexception { int len34 = len * num_ / num_ ; byte [ ] outbuff = new byte [ num_ + len34 ] ;	Decodes Base64 content using the supplied decodabet and returnsthe decoded byte array.
public static void view ( activity context , entity e , viewaddlistener listener ) { proxy . view ( context , e , listener ) ; }	Records a view against the given entity for the current user.
public void onprofileupdate ( ) { commentadapter . notifydatasetchanged ( ) ; if ( commententryslider != null ) { commententryslider . updatecontent ( ) ; } if ( notifybox != null ) { try { usersettings user = userutils . getusersettings ( getcontext ( ) ) ; if ( user . isnotificationsenabled ( ) ) { notifybox . setvisibility ( view . visible ) ; } else { notifybox . setvisibility ( view . gone ) ; } } catch ( socializeexception e ) { if ( logger != null ) { logger . error ( str_ , e ) ; } else { e . printstacktrace ( ) ; } notifybox . setvisibility ( view . gone ) ; } } }	Called when the current logged in user updates their profile.
public static httpparameters decodeform ( string form ) { httpparameters params = new httpparameters ( ) ; if ( isempty ( form ) ) { return params ; } for ( string nvp : form . split ( str_ ) ) { int equals = nvp . indexof ( str_ ) ; string name ; string value ; if ( equals < num_ ) { name = percentdecode ( nvp ) ; value = null ; } else { name = percentdecode ( nvp . substring ( num_ , equals ) ) ; value = percentdecode ( nvp . substring ( equals + num_ ) ) ; } params . put ( name , value ) ; } return params ; }	Parse a form-urlencoded document.
public static < t extends map . entry < string , string > > map < string , string > tomap ( collection < t > from ) { hashmap < string , string > map = new hashmap < string , string > ( ) ; if ( from != null ) { for ( map . entry < string , string > entry : from ) { string key = entry . getkey ( ) ; if ( ! map . containskey ( key ) ) { map . put ( key , entry . getvalue ( ) ) ; } } } return map ; }	Construct a Map containing a copy of the given parameters.
public static string toheaderelement ( string name , string value ) { return oauth . percentencode ( name ) + str_ + oauth . percentencode ( value ) + str_ ; }	Helper method to concatenate a parameter and its value to a pair that canbe used in an HTTP header.
public boolean put ( k strkey , e object , long ttl ) { return put ( strkey , object , ttl , bool_ ) ; }	Adds an object to cache with the given time-to-live.
public boolean put ( k strkey , e object , boolean eternal ) { return put ( strkey , object , defaultttl , eternal ) ; }	Adds an object to cache that optionally lives forever.
protected synchronized boolean put ( k k , e object , long ttl , boolean eternal ) {	Adds an object to cache with the given Time To Live in milliseconds.
public synchronized e getraw ( k strkey ) { ttlobject < k , e > obj = getttlobject ( strkey ) ; if ( obj != null && ! isexpired ( obj ) ) { return obj . getobject ( ) ; } return null ; }	Ignores proxy and always returns raw object.
public synchronized e get ( k key ) { ttlobject < k , e > obj = getttlobject ( key ) ; if ( obj != null && ! isexpired ( obj ) ) { if ( extendonget ) { extendttl ( key ) ; } if ( eventlistener != null ) { eventlistener . onget ( obj . getobject ( ) ) ; } obj . getobject ( ) . onget ( ) ; return obj . getobject ( ) ; } else if ( obj != null ) {	Gets an object from cache.
public boolean exists ( k k ) { key < k > key = keys . get ( k ) ; if ( key != null ) { return objects . get ( key ) != null ; } return bool_ ; }	Returns true if the object with the given key resides in the cache.
public synchronized void extendttl ( k strkey ) { ttlobject < k , e > object = getttlobject ( strkey ) ; if ( object != null ) { object . setlifeexpectancy ( system . currenttimemillis ( ) + object . getttl ( ) ) ; } }	Extends the ttl of the object with the given key with the current system time.
public void loadimagebydata ( final string name , final string encodeddata , int width , int height , final imageloadlistener listener ) { imageloadrequest request = makerequest ( ) ; request . seturl ( name ) ; request . setencodedimagedata ( encodeddata ) ; request . settype ( imageloadtype . encoded ) ; loadimage ( request , listener ) ; }	Loads an image based on Base64 encoded bytes.
public void loadimagebyurl ( final string url , int width , int height , final imageloadlistener listener ) { imageloadrequest request = makerequest ( ) ; request . seturl ( url ) ; request . settype ( imageloadtype . url ) ; request . setscalewidth ( width ) ; request . setscaleheight ( height ) ; loadimage ( request , listener ) ; }	Asynchronously loads the image at the given url and calls the listener when it is loaded.
public static map < string , string > parsetags ( final string tagstring ) throws illegalargumentexception {	Convert a tag string into a tag map.
public static string formattags ( final map < string , string > tagmap ) { stringbuilder stringbuilder = new stringbuilder ( ) ; string delimeter = str_ ; for ( map . entry < string , string > tag : tagmap . entryset ( ) ) { stringbuilder . append ( delimeter ) . append ( sanitize ( tag . getkey ( ) ) ) . append ( str_ ) . append ( sanitize ( tag . getvalue ( ) ) ) ; delimeter = str_ ; } return stringbuilder . tostring ( ) ; }	Convert a tag map into a space-delimited string.
public static string fixencodedtagsinnameafterprefix ( final string name ) { if ( name == null ) return name ; int tagstart = name . indexof ( str_ ) ; if ( tagstart == - num_ ) return name ;	Call this function whenever a potentially tag-encoded name is prefixed.
public static builder named ( string name ) { if ( ! hasencodedtaginname ( name ) ) { return new builder ( name ) ; }	Creates a Builder for a metric name.
public string totelnetputstring ( ) { string tagstring = formattags ( tags ) ; return string . format ( str_ , metric , timestamp , value , tagstring ) ; }	Returns a put string version of this metric compatible with the telnet-style reporter.Format: put (metric-name) (timestamp) (value) (tags) Example: put sys.cpu.nice 1346846400 18 host=web01 dc=lga.
@ override public string tohumanstring ( ) { if ( unicode ) { return domain ; } final idna . info idnainfo = new idna . info ( ) ; final stringbuilder idnaoutput = new stringbuilder ( ) ; idna . getuts46instance ( idna . default ) . nametounicode ( domain , idnaoutput , idnainfo ) ; return idnaoutput . tostring ( ) ; }	Converts the domain to a Unicode representation suitable for human interpretation.
public static string percentdecode ( final string input ) { if ( input . isempty ( ) ) { return input ; } try { final bytearrayoutputstream bytes = new bytearrayoutputstream ( ) ; int idx = num_ ; while ( idx < input . length ( ) ) { boolean iseof = idx >= input . length ( ) ; int c = ( iseof ) ? num_ : input . codepointat ( idx ) ; while ( ! iseof && c != str_ ) { if ( c <= num_ ) {	Percent-decodes a string.Percent-encoded bytes are assumed to represent UTF-8 characters.
public string queryparameter ( final string name ) { if ( name == null ) { throw new nullpointerexception ( str_ ) ; } if ( query == null || query . isempty ( ) ) { return null ; } int start = num_ ; do { final int nextampersand = query . indexof ( str_ , start ) ; final int end = ( nextampersand == - num_ ) ? query . length ( ) : nextampersand ; int nextequals = query . indexof ( str_ , start ) ; if ( nextequals == - num_ || nextequals > end ) { nextequals = end ; } final int thisnamelength = nextequals - start ; final int thisvaluelength = end - nextequals ; if ( thisnamelength == name . length ( ) && query . regionmatches ( start , name , num_ , name . length ( ) ) ) { if ( thisvaluelength == num_ ) { return str_ ; } return query . substring ( nextequals + num_ , end ) ; } if ( nextampersand == - num_ ) { break ; } start = nextampersand + num_ ; } while ( bool_ ) ; return null ; }	Gets the first query parameter value for a given name.
public list < string > queryparameters ( final string name ) { if ( name == null ) { throw new nullpointerexception ( str_ ) ; } if ( query == null || query . isempty ( ) ) { return null ; } int start = num_ ; final list < string > result = new arraylist < string > ( ) ; do { final int nextampersand = query . indexof ( str_ , start ) ; final int end = ( nextampersand == - num_ ) ? query . length ( ) : nextampersand ; int nextequals = query . indexof ( str_ , start ) ; if ( nextequals == - num_ || nextequals > end ) { nextequals = end ; } final int thisnamelength = nextequals - start ; final int thisvaluelength = end - nextequals ; if ( thisnamelength == name . length ( ) && query . regionmatches ( start , name , num_ , name . length ( ) ) ) { if ( thisvaluelength == num_ ) { result . add ( str_ ) ; } else { result . add ( query . substring ( nextequals + num_ , end ) ) ; } } if ( nextampersand == - num_ ) { break ; } start = nextampersand + num_ ; } while ( bool_ ) ; return result ; }	Gets all query parameter values for a given name.
public string relativize ( final url url ) { if ( this . isopaque ( ) || url . isopaque ( ) ) { return url . tostring ( ) ; } if ( ! this . scheme ( ) . equals ( url . scheme ( ) ) ) { return url . tostring ( ) ; } if ( this . authority ( ) == null ^ url . authority ( ) == null ) { return url . tostring ( ) ; } if ( this . authority ( ) != null && ! this . authority ( ) . equals ( url . authority ( ) ) ) { return url . tostring ( ) ; } string prefixpath = ( this . path ( ) . endswith ( str_ ) ) ? this . path : this . path ( ) + str_ ; if ( ! url . path ( ) . startswith ( prefixpath ) && ! this . path ( ) . equals ( url . path ( ) ) ) { return url . tostring ( ) ; } stringbuilder output = new stringbuilder ( ) ; if ( ! this . path ( ) . equals ( url . path ( ) ) ) { output . append ( url . path ( ) . replacefirst ( prefixpath , str_ ) ) ; } if ( url . query ( ) != null ) { output . append ( str_ ) . append ( url . query ( ) ) ; } if ( url . fragment ( ) != null ) { output . append ( str_ ) . append ( url . fragment ( ) ) ; } return output . tostring ( ) ; }	Returns a relative URL reference for the given URL.Behaves as .
public static url buildhierarchical ( final string scheme , final string host ) throws galimatiasparseexception { if ( ! urlutils . isrelativescheme ( scheme ) ) { throw new galimatiasparseexception ( str_ + scheme ) ; } return new urlparser ( scheme + str_ + host ) . parse ( ) ; }	Gets a URL object from a relative scheme and a host.
public static url buildopaque ( final string scheme ) throws galimatiasparseexception { if ( urlutils . isrelativescheme ( scheme ) ) { throw new galimatiasparseexception ( str_ + scheme ) ; } return new urlparser ( scheme + str_ ) . parse ( ) ; }	Gets a URL object from a non-relative scheme.
public string tohumanstring ( ) { final stringbuilder output = new stringbuilder ( ) ; output . append ( scheme ) . append ( str_ ) ; if ( ishierarchical ) { output . append ( str_ ) ; final string userinfo = userinfo ( ) ; if ( ! userinfo . isempty ( ) ) { output . append ( urlutils . percentdecode ( userinfo ) ) . append ( str_ ) ; } if ( host != null ) { if ( host instanceof ipv6address ) { output . append ( host . tohoststring ( ) ) ; } else { output . append ( host . tohumanstring ( ) ) ; } } if ( port != - num_ ) { output . append ( str_ ) . append ( port ) ; } if ( path != null ) { output . append ( urlutils . percentdecode ( path ) ) ; } } else { output . append ( urlutils . percentdecode ( schemedata ) ) ; } if ( query != null ) { output . append ( str_ ) . append ( urlutils . percentdecode ( query ) ) ; } if ( fragment != null ) { output . append ( str_ ) . append ( urlutils . percentdecode ( fragment ) ) ; } return output . tostring ( ) ; }	Serializes the URL to a human-readable representation.
private < t , u > u querystreamwithordinalparams ( string sql , preparedstatementsetter pss , rowmapper < t > mapper , function < ? super stream < t > , u > handlestream ) { sqlexceptiontranslator exctranslator = jdbctemplate . getexceptiontranslator ( ) ; resultsetextractor < u > extractor = new streamresultsetextractor ( sql , mapper , handlestream , exctranslator ) ; return jdbctemplate . query ( sql , pss , extractor ) ; }	Executes a quey for stream with ordinal parameters.
private < t , u > u querystreamwithnamedparams ( string sql , sqlparametersource sps , rowmapper < t > mapper , function < ? super stream < t > , u > handlestream ) { sqlexceptiontranslator exctranslator = jdbctemplate . getexceptiontranslator ( ) ; resultsetextractor < u > extractor = new streamresultsetextractor ( sql , mapper , handlestream , exctranslator ) ; return namedjdbctemplate . query ( sql , sps , extractor ) ; }	Executes a query for stream with named parameters.
public static field [ ] get ( class < ? > clazz ) { field [ ] fields = cached_fields . get ( clazz ) ; if ( fields == null ) { fields = clazz . getfields ( ) ; cached_fields . putifabsent ( clazz , fields ) ; } return fields ; }	Get fields of the given class.
private optional < t > fetchrow ( ) { if ( this . row != null ) {	Fetches a row if not fetched yet.
protected static localdatetime getaslocaldatetime ( resultset rs , int index ) throws sqlexception { timestamp timestamp = rs . gettimestamp ( index ) ; if ( timestamp != null ) { return timestamp . tolocaldatetime ( ) ; } return null ; }	Get the column value as LocalDateTime.
protected static localdate getaslocaldate ( resultset rs , int index ) throws sqlexception { date date = rs . getdate ( index ) ; if ( date != null ) { return date . tolocaldate ( ) ; } return null ; }	Get the column value as LocalDate.
protected static localtime getaslocaltime ( resultset rs , int index ) throws sqlexception { time time = rs . gettime ( index ) ; if ( time != null ) { return time . tolocaltime ( ) ; } return null ; }	Get the column value as LocalTime.
protected static zoneddatetime getaszoneddatetime ( resultset rs , int index , zoneid zoneid ) throws sqlexception { timestamp timestamp = rs . gettimestamp ( index ) ; if ( timestamp != null ) { return timestamp . tolocaldatetime ( ) . atzone ( zoneid ) ; } return null ; }	Get the column value as ZonedDateTime.
protected static offsetdatetime getasoffsetdatetime ( resultset rs , int index , zoneid zoneid ) throws sqlexception { timestamp timestamp = rs . gettimestamp ( index ) ; if ( timestamp != null ) { return timestamp . tolocaldatetime ( ) . atzone ( zoneid ) . tooffsetdatetime ( ) ; } return null ; }	Get the column value as OffsetDateTime.
protected static offsettime getasoffsettime ( resultset rs , int index , zoneid zoneid ) throws sqlexception { time time = rs . gettime ( index ) ; if ( time != null ) { return time . tolocaltime ( ) . atoffset ( zoneid . getrules ( ) . getoffset ( instant . now ( ) ) ) ; } return null ; }	Get the column value as OffsetTime.
protected object getcolumnvalue ( resultset rs , int index , class < ? > requiredtype ) throws sqlexception { return jsr310jdbcutils . getresultsetvalue ( rs , index , requiredtype , zoneid ) ; }	Get the column value.
public cdnpathbuilder crop ( int width , int height ) { dimensionsguard ( width , height ) ; sb . append ( str_ ) . append ( width ) . append ( str_ ) . append ( height ) ; return this ; }	Adds top-left-aligned crop.
public cdnpathbuilder cropcenter ( int width , int height ) { dimensionsguard ( width , height ) ; sb . append ( str_ ) . append ( width ) . append ( str_ ) . append ( height ) . append ( str_ ) ; return this ; }	Adds center-aligned crop.
public cdnpathbuilder cropcolor ( int width , int height , color color ) { dimensionsguard ( width , height ) ; sb . append ( str_ ) . append ( width ) . append ( str_ ) . append ( height ) . append ( str_ ) . append ( colortohex ( color ) ) ; return this ; }	Adds top-left-aligned crop with a filled background.
public cdnpathbuilder resizewidth ( int width ) { dimensionguard ( width ) ; sb . append ( str_ ) . append ( width ) . append ( str_ ) ; return this ; }	Resizes width, keeping the aspect ratio.
public cdnpathbuilder resize ( int width , int height ) { dimensionsguard ( width , height ) ; sb . append ( str_ ) . append ( width ) . append ( str_ ) . append ( height ) ; return this ; }	Resizes width and height.
public cdnpathbuilder scalecrop ( int width , int height ) { dimensionsguard ( width , height ) ; sb . append ( str_ ) . append ( width ) . append ( str_ ) . append ( height ) ; return this ; }	Scales the image until one of the dimensions fits,then crops the bottom or right side.
public cdnpathbuilder scalecropcenter ( int width , int height ) { dimensionsguard ( width , height ) ; sb . append ( str_ ) . append ( width ) . append ( str_ ) . append ( height ) . append ( str_ ) ; return this ; }	Scales the image until one of the dimensions fits,centers it, then crops the rest.
public cdnpathbuilder blur ( int strength ) { if ( strength < num_ || strength > num_ ) { strength = num_ ; } sb . append ( str_ ) . append ( strength ) ; return this ; }	Performs Gaussian blur on result image.
public cdnpathbuilder sharp ( int strength ) { if ( strength < num_ || strength > num_ ) { strength = num_ ; } sb . append ( str_ ) . append ( strength ) ; return this ; }	Performs sharpening on result image.
public cdnpathbuilder preview ( int width , int height ) { dimensionsguard ( width , height ) ; sb . append ( str_ ) . append ( width ) . append ( str_ ) . append ( height ) ; return this ; }	Reduces an image proportionally in order to fit it into given dimensions.
public project getproject ( ) { uri url = urls . apiproject ( ) ; requesthelper requesthelper = getrequesthelper ( ) ; projectdata projectdata = requesthelper . executequery ( new httpget ( url ) , bool_ , projectdata . class ) ; return new project ( this , projectdata ) ; }	Requests project info from the API.
public file getfile ( string fileid ) { uri url = urls . apifile ( fileid ) ; requesthelper requesthelper = getrequesthelper ( ) ; filedata filedata = requesthelper . executequery ( new httpget ( url ) , bool_ , filedata . class ) ; return new file ( this , filedata ) ; }	Requests file data.
public void deletefile ( string fileid ) { uri url = urls . apifile ( fileid ) ; requesthelper requesthelper = getrequesthelper ( ) ; requesthelper . executecommand ( new httpdelete ( url ) , bool_ ) ; }	Marks a file as deleted.
public void savefile ( string fileid ) { uri url = urls . apifilestorage ( fileid ) ; requesthelper requesthelper = getrequesthelper ( ) ; requesthelper . executecommand ( new httppost ( url ) , bool_ ) ; }	Marks a file as saved.This has to be done for all files you want to keep.Unsaved files are eventually purged.
public httpresponse executecommand ( httpurirequest request , boolean apiheaders ) { if ( apiheaders ) { setapiheaders ( request ) ; } try { closeablehttpresponse response = client . gethttpclient ( ) . execute ( request ) ; try { checkresponsestatus ( response ) ; return response ; } finally { response . close ( ) ; } } catch ( ioexception e ) { throw new uploadcarenetworkexception ( e ) ; } }	Executes the request et the Uploadcare API and return the HTTP Response object.The existence of this method(and it's return type) enables the end user to extend thefunctionality of theUploadcare API client by creating a subclass of {.
private void checkresponsestatus ( httpresponse response ) throws ioexception { int statuscode = response . getstatusline ( ) . getstatuscode ( ) ; if ( statuscode >= num_ && statuscode < num_ ) { return ; } else if ( statuscode == num_ || statuscode == num_ ) { throw new uploadcareauthenticationexception ( streamtostring ( response . getentity ( ) . getcontent ( ) ) ) ; } else if ( statuscode == num_ || statuscode == num_ ) { throw new uploadcareinvalidrequestexception ( streamtostring ( response . getentity ( ) . getcontent ( ) ) ) ; } else { throw new uploadcareapiexception ( str_ + streamtostring ( response . getentity ( ) . getcontent ( ) ) ) ; } }	Verifies that the response status codes are within acceptable boundaries and throwscorresponding exceptionsotherwise.
public static uri uploadfromurl ( string sourceurl , string pubkey , string store ) { uribuilder builder = new uribuilder ( uri . create ( upload_base ) ) ; builder . setpath ( str_ ) . setparameter ( str_ , sourceurl ) . setparameter ( str_ , pubkey ) . setparameter ( str_ , store ) ; return trustedbuild ( builder ) ; }	Creates a URL for URL upload.
@ override public void inject ( object target ) { checkstate ( mobjectgraph != null , str_ ) ; mobjectgraph . inject ( target ) ; }	Injects a target object using this ActionBarActivity's object graph.
public static builder newbuilder ( context context , int themeresid ) { if ( build . version . sdk_int >= num_ ) { return new api21builder ( context , themeresid ) ; } return new api20builder ( context , themeresid ) ; }	Create new Builder.
@ nullable public class < ? > findclass ( final string classname ) { objects . requirenonnull ( classname ) ; try { return ( class < ? > ) findclass . invoke ( loader , classname ) ; } catch ( illegalaccessexception | invocationtargetexception e ) { throw new parsertransformexception ( str_ + classname + str_ , e ) ; } }	Returns the class with the given name if it has already been loaded bythe given class loader If the class has not been loaded yet, this method returns {.
public triebuilder addword ( @ nonnull final string word ) { objects . requirenonnull ( word ) ; final int length = word . length ( ) ; if ( length == num_ ) throw new illegalargumentexception ( str_ + str_ ) ; nrwords ++ ; maxlength = math . max ( maxlength , length ) ; nodebuilder . addword ( word ) ; return this ; }	Add one word to the trie.
public boolean append ( final char c ) { if ( get ( ) == null ) return set ( new stringbuilder ( ) . append ( c ) ) ; get ( ) . append ( c ) ; return bool_ ; }	Appends the given char.If this instance is currently uninitialized the given char is used for initialization.
public final t getandset ( final t value ) { final t ret = this . value ; this . value = value ; return ret ; }	Replaces this references value with the given one.
public static boolean isassignableto ( final string classinternalname , final class < ? > type ) { objects . requirenonnull ( classinternalname , str_ ) ; objects . requirenonnull ( type , str_ ) ; final class < ? > c = cache . loadclass ( classinternalname ) ;	Determines whether the class with the given descriptor is assignable tothe given type.
private void copyparseinfo ( final filesystem zipfs ) throws ioexception { final path path = zipfs . getpath ( info_path ) ; try ( final bufferedwriter writer = files . newbufferedwriter ( path , utf_8 ) ; ) { sb . setlength ( num_ ) ; sb . append ( starttime ) . append ( str_ ) . append ( prematchindices . size ( ) ) . append ( str_ ) . append ( nextmatcherid ) . append ( str_ ) . append ( nrlines ) . append ( str_ ) . append ( nrchars ) . append ( str_ ) . append ( nrcodepoints ) . append ( str_ ) . append ( nextnodeid ) . append ( str_ ) ; writer . append ( sb ) ; writer . flush ( ) ; } }	MUST be called after copyInputText!.
public static void hash ( @ nonnull final instructiongroup group , @ nonnull final string classname ) { final instructiongrouphasher grouphasher = new instructiongrouphasher ( group , classname ) ; final string name = grouphasher . hashandgetname ( ) ; group . setname ( name ) ; }	Generate a hash of the group, use it to name it.
@ cached @ dontlabel public rule ignorecase ( final char c ) { return character . islowercase ( c ) == character . isuppercase ( c ) ? ch ( c ) : new charignorecasematcher ( c ) ; }	Match a given character in a case-insensitive manner.
@ cached @ dontlabel public rule unicodechar ( final int codepoint ) { if ( ! character . isvalidcodepoint ( codepoint ) ) throw new invalidgrammarexception ( str_ + codepoint ) ; return new codepointmatcher ( codepoint ) ; }	Match one Unicode character.
@ cached @ dontlabel public rule unicoderange ( final int low , final int high ) { if ( ! character . isvalidcodepoint ( low ) ) throw new invalidgrammarexception ( str_ + low ) ; if ( ! character . isvalidcodepoint ( high ) ) throw new invalidgrammarexception ( str_ + high ) ; if ( low > high ) throw new invalidgrammarexception ( str_ + low + str_ + high ) ; return low == high ? new codepointmatcher ( low ) : new codepointrangematcher ( low , high ) ; }	Match a Unicode character range Note that this method will delegate to "regular" character matchers ifpart of, or all of, the specified range is into the basic multilingualplane. .
@ dontlabel public rule anyof ( final string characters ) { objects . requirenonnull ( characters ) ;	Match any of the characters in the given string This method delegates to {.
@ cached @ dontlabel public rule anyof ( final characters characters ) { objects . requirenonnull ( characters ) ; if ( ! characters . issubtractive ( ) && characters . getchars ( ) . length == num_ ) return ch ( characters . getchars ( ) [ num_ ] ) ; if ( characters . equals ( characters . none ) ) return nothing ; return new anyofmatcher ( characters ) ; }	Match any given character among a set of characters Both {.
@ dontlabel public rule string ( final string string ) { objects . requirenonnull ( string ) ; return string ( string . tochararray ( ) ) ; }	Match a string literal.
@ cached @ dontlabel public rule string ( final char ... characters ) { if ( characters . length == num_ ) return ch ( characters [ num_ ] ) ;	Match a given set of characters as a string literal.
@ dontlabel public rule ignorecase ( final string string ) { objects . requirenonnull ( string ) ; return ignorecase ( string . tochararray ( ) ) ; }	Match a string literal in a case insensitive manner.
@ cached @ dontlabel public rule optional ( final object rule ) { objects . requirenonnull ( rule ) ; return new optionalmatcher ( torule ( rule ) ) ; }	Try and match a rule zero or one time This rule therefore always succeeds. .
@ dontlabel public rule optional ( final object rule , final object rule2 , final object ... morerules ) { objects . requirenonnull ( morerules ) ; return optional ( sequence ( rule , rule2 , morerules ) ) ; }	Try and match a given set of rules once This rule will therefore never fail. .
@ dontlabel public final repeatmatcherbuilder < v > repeat ( final object rule , final object rule2 , final object ... morerules ) { objects . requirenonnull ( morerules ) ; return repeat ( sequence ( rule , rule2 , morerules ) ) ; }	Kickstart a repeat rule Like {.
@ dontlabel public rule zeroormore ( final object rule , final object rule2 , final object ... morerules ) { return repeat ( rule , rule2 , morerules ) . min ( num_ ) ; }	Try and match a set of rules zero or more times This is an alias for {.
@ dontextend protected rule fromstringliteral ( final string string ) { objects . requirenonnull ( string ) ; return fromchararray ( string . tochararray ( ) ) ; }	Convert a string literal to a parser rule.
@ dontextend public rule [ ] torules ( final object ... objects ) { return arrays . stream ( objects ) . map ( this :: torule ) . toarray ( rule [ ] :: new ) ; }	Convert the given object array to an array of rules.
@ dontextend public rule torule ( final object obj ) { objects . requirenonnull ( obj ) ; if ( obj instanceof rule ) return ( rule ) obj ; if ( obj instanceof character ) return fromcharliteral ( ( character ) obj ) ; if ( obj instanceof string ) return fromstringliteral ( ( string ) obj ) ; if ( obj instanceof char [ ] ) return fromchararray ( ( char [ ] ) obj ) ; if ( obj instanceof action ) { final action < ? > action = ( action < ? > ) obj ; return new actionmatcher ( action ) ; } final string errmsg = obj instanceof boolean ? str_ : str_ + obj + str_ ; throw new invalidgrammarexception ( errmsg ) ; }	Converts the given object to a rule.
public boolean push ( final int down , final v value ) { check ( ) ; context . getvaluestack ( ) . push ( down , value ) ; return bool_ ; }	Inserts the given value a given number of elements below the current topof the value stack.
public < e extends v > e popas ( @ nonnull final class < e > c ) { return c . cast ( pop ( ) ) ; }	Removes the value at the top of the value stack and casts it beforereturning it.
public < e extends v > e popas ( final class < e > c , final int down ) { return c . cast ( pop ( down ) ) ; }	Removes the value the given number of elements below the top of the valuestack and casts it before returning it.
public < e extends v > e peekas ( final class < e > c ) { return c . cast ( peek ( ) ) ; }	Returns and casts the value at the top of the value stack withoutremoving it.
public boolean poke ( final int down , final v value ) { check ( ) ; context . getvaluestack ( ) . poke ( down , value ) ; return bool_ ; }	Replaces the element the given number of elements below the current topof the value stack.
@ override public < t > boolean match ( final matchercontext < t > context ) { final matcher matcher = context . getmatcher ( ) ; final prematchevent < t > prematchevent = new prematchevent < > ( context ) ; bus . post ( prematchevent ) ; if ( throwable != null ) throw new grappaexception ( str_ , throwable ) ;	Internal method. DO NOT USE!.
public boolean overlapswith ( final indexrange other ) { objects . requirenonnull ( other , str_ ) ; return end > other . start && other . end > start ; }	Determines whether this range overlaps with the given other one.
public boolean touches ( final indexrange other ) { objects . requirenonnull ( other , str_ ) ; return other . end == start || end == other . start ; }	Determines whether this range immediated follows or precedes the given other one.
public indexrange mergedwith ( final indexrange other ) { objects . requirenonnull ( other , str_ ) ; return new indexrange ( math . min ( start , other . start ) , math . max ( end , other . end ) ) ; }	Created a new IndexRange that spans all characters between the smallest and the highest index of the two ranges.
public static < p extends baseparser < v > , v > byte [ ] getbytecode ( final class < p > parserclass ) { try { return parsertransformer . getbytecode ( parserclass ) ; } catch ( exception e ) { throw new runtimeexception ( str_ , e ) ; } }	Generate the byte code of a transformed parser class When you create a parser using {.
private void doaddword ( final charbuffer buffer ) { if ( ! buffer . hasremaining ( ) ) { fullword = bool_ ; return ; } final char c = buffer . get ( ) ; trienodebuilder builder = subnodes . get ( c ) ; if ( builder == null ) { builder = new trienodebuilder ( ) ; subnodes . put ( c , builder ) ; } builder . doaddword ( buffer ) ; }	Add a word Here also, a {.
public static matcher unwrap ( final matcher matcher ) { if ( matcher instanceof proxymatcher ) { final proxymatcher proxymatcher = ( proxymatcher ) matcher ; if ( proxymatcher . dirty ) proxymatcher . apply ( ) ; return proxymatcher . target == null ? proxymatcher : proxymatcher . target ; } return matcher ; }	Retrieves the innermost Matcher that is not a ProxyMatcher.
public final boolean register ( @ nonnull final object listener ) { bus . register ( objects . requirenonnull ( listener ) ) ; return bool_ ; }	Register a listener to the event bus.
public final boolean post ( @ nonnull final object object ) { objects . requirenonnull ( object ) ; bus . post ( object ) ; return bool_ ; }	Post an arbitrary, non null, object on the bus.
@ override public < v > matchercontext < v > getsubcontext ( final matchercontext < v > context ) { return context . getsubcontext ( this ) ; }	default implementation is to simply delegate to the context.
public rule min ( final int nrcycles ) { preconditions . checkargument ( nrcycles >= num_ , str_ + nrcycles + str_ ) ; return range ( range . atleast ( nrcycles ) ) ; }	Return a rule with a minimum number of cycles to run.
public rule max ( final int nrcycles ) { preconditions . checkargument ( nrcycles >= num_ , str_ + nrcycles + str_ ) ; return range ( range . atmost ( nrcycles ) ) ; }	Return a rule with a maximum number of cycles to run.
public rule times ( final int nrcycles ) { preconditions . checkargument ( nrcycles >= num_ , str_ + nrcycles + str_ ) ; return range ( range . singleton ( nrcycles ) ) ; }	Return a rule with an exact number of cycles to run.
public rule times ( final int mincycles , final int maxcycles ) { preconditions . checkargument ( mincycles >= num_ , str_ + mincycles + str_ ) ; preconditions . checkargument ( maxcycles >= mincycles , str_ + mincycles + str_ + maxcycles + str_ ) ; return range ( range . closed ( mincycles , maxcycles ) ) ; }	Return a rule with both lower and upper bounds on the number of cycles Note that the range of cycles to run is closed on both ends (that is,the minimum and maximum number of cycles) are inclusive . .
public static characters allbut ( final char ... chars ) { final int length = chars . length ; if ( length == num_ ) return all ; final char [ ] array = arrays . copyof ( chars , length ) ; arrays . sort ( array ) ; return new characters ( bool_ , array ) ; }	Creates a new Characters instance containing all characters minus the given ones.
private list < bw > getbwservices ( ) { list < bw > result = new arraylist < bw > ( ) ; for ( jaxbelement < ? extends servicetype > jaxbelement : application . getservices ( ) . getbaseservice ( ) ) { if ( jaxbelement . getname ( ) . getlocalpart ( ) . equals ( str_ ) ) { result . add ( ( bw ) jaxbelement . getvalue ( ) ) ; } } return result ; }	This method retrieves the list of objects of type "BWServiceType".
public void addmonitoringeventstoallservices ( events events ) { list < jaxbelement < ? extends eventtype > > events_ = events . getevent ( ) ; if ( events_ != null && ! events_ . isempty ( ) ) { for ( bw service : this . getbwservices ( ) ) { monitor monitor = service . getmonitor ( ) ; if ( monitor != null ) { monitor . setevents ( events ) ; } } } }	Add &lt;events> in &lt;monitor> element of all &lt;bw> elements.
public list < globalvariables . globalvariable > getglobalvariable ( ) { if ( globalvariable == null ) { globalvariable = new arraylist < globalvariables . globalvariable > ( ) ; } return this . globalvariable ; }	Gets the value of the globalVariable property.
private void checkbwproject ( ) throws mojoexecutionexception { if ( projectdirectory == null ) { projectnotfound ( ) ; } else if ( ! projectdirectory . exists ( ) || ! projectdirectory . isdirectory ( ) ) { projectnotfound ( ) ; } }	This will check that the BW project specified in the POM project exists.TODO : add additional checks about BW project integrity.
protected list < dependency > readdependenciesfromfile ( string resolvedfilename , string dependencytype ) throws ioexception { list < dependency > dependencies = new arraylist < dependency > ( ) ; file resolvedfile = new file ( resolvedfilename ) ; if ( ! resolvedfile . exists ( ) ) { return dependencies ; } fileinputstream fstream = new fileinputstream ( resolvedfile ) ; datainputstream ds = new datainputstream ( fstream ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( ds ) ) ; pattern p = pattern . compile ( str_ + dependencytype + str_ ) ;	This will read the dependencies from the 'resolved' file found in thebuild directory.
protected void launchtibcobinary ( file binary , list < file > tras , arraylist < string > arguments , file workingdir , string errormsg ) throws ioexception , mojoexecutionexception { launchtibcobinary ( binary , tras , arguments , workingdir , errormsg , bool_ , bool_ ) ; }	Same as launchTIBCOBinary with 'fork=false' and 'synchronous=true'.
protected boolean cleandirectory ( file directory ) { if ( directory . isdirectory ( ) && directory . listfiles ( ) . length != num_ ) { for ( file file : directory . listfiles ( ) ) { if ( file . isfile ( ) ) { file . delete ( ) ; } } } return directory . delete ( ) ; }	Delete all file of a directory and then delete this directory.
public java . util . list < string > getfinal ( ) { if ( _final == null ) { _final = new arraylist < string > ( ) ; } return this . _final ; }	Gets the value of the final property.
public list < rulebases . rulebase > getrulebase ( ) { if ( rulebase == null ) { rulebase = new arraylist < rulebases . rulebase > ( ) ; } return this . rulebase ; }	Gets the value of the rulebase property.
private void addalias ( arraylist < hashmap < string , object > > list , string aliasname ) { for ( hashmap < string , object > h : list ) { string name = ( string ) h . get ( str_ ) ; if ( name != null && name . equals ( aliasname ) ) { return ;	This method add an alias in the object used internally by TIBCOBusinessWorks.
public void processfile ( file f ) throws mojoexecutionexception { try { repositorymodel repositorymodel = new repositorymodel ( f ) ; arraylist < hashmap < string , object > > aliases = readxmlbean ( repositorymodel , f ) ;	This method adds the JAR aliases to a ".aliaslib" file.
public static void adddependency ( file pom , dependency dependency , log logger ) throws ioexception , xmlpullparserexception { model model = getmodelfrompom ( pom , logger ) ; model . adddependency ( dependency ) ; writemodeltopom ( model , pom , logger ) ; }	Add the Maven dependency to a POM file.
public static void removedependency ( file pom , dependency dependency , log logger ) throws ioexception , xmlpullparserexception { model model = getmodelfrompom ( pom , logger ) ; for ( iterator < dependency > it = model . getdependencies ( ) . iterator ( ) ; it . hasnext ( ) ; ) { if ( dependenciesequal ( it . next ( ) , dependency ) ) { it . remove ( ) ; } } writemodeltopom ( model , pom , logger ) ; }	Remove the Maven dependency from a POM file.
private static boolean dependencyexists ( dependency dependency , list < dependency > dependencies ) { for ( dependency d : dependencies ) { if ( dependenciesequal ( dependency , d ) ) { return bool_ ; } } return bool_ ; }	Check whether a dependency exists in a list of dependencies.
public static boolean dependencyexists ( file pom , dependency dependency , log logger ) throws ioexception , xmlpullparserexception { model model = getmodelfrompom ( pom , logger ) ; return dependencyexists ( dependency , model . getdependencies ( ) ) ; }	Check whether a dependency exists in a POM.
public static void addprojectasmodule ( file pom , string relativepath , string profileid , log logger ) throws ioexception , xmlpullparserexception { if ( relativepath == null ) return ; model model = getmodelfrompom ( pom , logger ) ; relativepath = relativepath . replace ( str_ , str_ ) ; if ( profileid != null && ! profileid . isempty ( ) ) { profile p = getprofile ( model , profileid ) ; if ( p != null ) { p . addmodule ( relativepath ) ; } } else { model . addmodule ( relativepath ) ; } writemodeltopom ( model , pom , logger ) ; }	Add a project as a module.
public static boolean moduleexists ( file pom , string relativepath , string profileid , log logger ) throws ioexception , xmlpullparserexception { if ( relativepath == null ) return bool_ ; model model = getmodelfrompom ( pom , logger ) ; relativepath = relativepath . replace ( str_ , str_ ) ; if ( profileid != null && ! profileid . isempty ( ) ) { profile p = getprofile ( model , profileid ) ; if ( p != null ) { return p . getmodules ( ) . indexof ( relativepath ) >= num_ ; } } else { return model . getmodules ( ) . indexof ( relativepath ) >= num_ ; } return bool_ ; }	Check whether a module exists in a POM.
protected file getartifactfile ( file basedir , string finalname , string classifier ) { if ( classifier == null ) { classifier = str_ ; } else if ( classifier . trim ( ) . length ( ) > num_ && ! classifier . startswith ( str_ ) ) { classifier = str_ + classifier ; } return new file ( basedir , finalname + classifier + getartifactfileextension ( ) ) ; }	Retrieves the full path of the artifact that will be created.
public void execute ( ) throws mojoexecutionexception { if ( this . resources . size ( ) == num_ ) { throw new mojoexecutionexception ( str_ ) ; }	MOJO execution method.
protected string extractfilecontent ( final string filename ) throws ioexception { final stringbuilder sb = new stringbuilder ( ) ; string temp = str_ ; final bufferedreader bufferedreader = new bufferedreader ( new filereader ( filename ) ) ; try { while ( temp != null ) { temp = bufferedreader . readline ( ) ; if ( temp != null ) { sb . append ( temp ) ; } } return sb . tostring ( ) ; } finally { bufferedreader . close ( ) ; } }	Reads the complete content of the javaxpath file.
private void updaterepoinstances ( ) { repoinstances repoinstances = application . getrepoinstances ( ) ; rvrepoinstance rvrepoinstance = repoinstances . getrvrepoinstance ( ) ; rvrepoinstance . setdiscoverytimout ( biginteger . valueof ( reporvdiscoverytimeout ) ) ; rvrepoinstance . settimeout ( biginteger . valueof ( reporvtimeout ) ) ; rvrepoinstance . setdaemon ( reporvdaemon ) ; rvrepoinstance . setservice ( reporvservice ) ; rvrepoinstance . setnetwork ( reporvnetwork ) ; rvrepoinstance . setregionalsubject ( reporvregionalsubject ) ; rvrepoinstance . setoperationretry ( biginteger . valueof ( reporvoperationretry ) ) ; rvrepoinstance . setextrapropertyfile ( reporvextrapropertyfile ) ; rvrepoinstance . setserver ( reporvserver ) ; rvrepoinstance . setuser ( reporvuser ) ; rvrepoinstance . setpassword ( reporvpassword ) ; httprepoinstance httprepoinstance = repoinstances . gethttprepoinstance ( ) ; httprepoinstance . settimeout ( biginteger . valueof ( repohttptimeout ) ) ; httprepoinstance . seturl ( repohttpurl ) ; httprepoinstance . setserver ( repohttpserver ) ; httprepoinstance . setuser ( repohttpuser ) ; httprepoinstance . setpassword ( repohttppassword ) ; httprepoinstance . setextrapropertyfile ( repohttpextrapropertyfile ) ; localrepoinstance localrepoinstance = repoinstances . getlocalrepoinstance ( ) ; encodingtype encoding ; try { encoding = encodingtype . valueof ( repolocalencoding ) ; } catch ( illegalargumentexception e ) { encoding = encodingtype . utf_8 ; } localrepoinstance . setencoding ( encoding ) ; repoinstances . setrvrepoinstance ( rvrepoinstance ) ; repoinstances . sethttprepoinstance ( httprepoinstance ) ; repoinstances . setlocalrepoinstance ( localrepoinstance ) ; repotype repotype ; try { repotype = repotype . valueof ( reposelectinstance . touppercase ( ) ) ; } catch ( illegalargumentexception e ) { repotype = repotype . local ; } repoinstances . setselected ( repotype ) ; }	This will update the &lt;repoInstances> element.
public list < java . lang . object > getany ( ) { if ( any == null ) { any = new arraylist < java . lang . object > ( ) ; } return this . any ; }	Gets the value of the any property.
private static < t > t newinstance ( class < t > clazz , object ... params ) throws sqlexception { try { if ( params == null || params . length == num_ ) { return clazz . newinstance ( ) ; } else { for ( constructor < ? > ctor : clazz . getconstructors ( ) ) { if ( ctor . getparametertypes ( ) . length != params . length ) { continue ; } int paramindex = num_ ; for ( class < ? > paramtype : ctor . getparametertypes ( ) ) { if ( ! paramtype . isinstance ( params [ paramindex ] ) ) { break ; } paramindex ++ ; } if ( paramindex != params . length ) { continue ; } @ suppresswarnings ( str_ ) constructor < t > thector = ( constructor < t > ) ctor ; return thector . newinstance ( params ) ; } throw new sqlexception ( str_ + clazz ) ; } } catch ( reflectiveoperationexception reflectiveoperationexception ) { throw new sqlexception ( reflectiveoperationexception ) ; } }	Instantiate a new object of type T.
public < t > class < t > createclass ( ) { return ( class < t > ) proxy . getproxyclass ( getclassloader ( ) , getinterfaces ( ) ) ; }	Create proxy class.
public < t > constructor < t > createconstructor ( ) { try { return this . < t > createclass ( ) . getconstructor ( invocationhandler . class ) ; } catch ( nosuchmethodexception nosuchmethodexception ) { throw new proxyexception ( nosuchmethodexception ) ; } }	Create proxy constructorCreate proxy class.
public timer . context startstatementexecutetimer ( query query ) { ensuresqlid ( query ) ; string name = metricnamingstrategy . getstatementexecutetimer ( query . getsql ( ) , query . getsqlid ( ) ) ; return starttimer ( name ) ; }	Start Timer when statement is executed.
public timer . context startcallablestatementlifetimer ( query query ) { ensuresqlid ( query ) ; string name = metricnamingstrategy . getcallablestatementlifetimer ( query . getsql ( ) , query . getsqlid ( ) ) ; return starttimer ( name ) ; }	Start Timer when callable statement is created.
public timer . context startresultsetlifetimer ( query query ) { ensuresqlid ( query ) ; string name = metricnamingstrategy . getresultsetlifetimer ( query . getsql ( ) , query . getsqlid ( ) ) ; return starttimer ( name ) ; }	Start Timer when result set is created.
public void markresultsetrowmeter ( query query ) { ensuresqlid ( query ) ; string name = metricnamingstrategy . getresultsetrowmeter ( query . getsql ( ) , query . getsqlid ( ) ) ; markmeter ( name ) ; }	Increment when result set row is read.
private < t > t newproxy ( jdbcproxyhandler < t > proxyhandler ) { return proxyfactory . newproxy ( proxyhandler , proxyhandler . getproxyclass ( ) ) ; }	Create a proxy for given JDBC proxy handler.
public connection wrapconnection ( connection wrappedconnection ) { timer . context lifetimercontext = metrichelper . startconnectionlifetimer ( ) ; return newproxy ( new connectionproxyhandler ( wrappedconnection , this , lifetimercontext ) ) ; }	Wrap a connection to monitor it.
public statement wrapstatement ( statement statement ) { timer . context lifetimercontext = getmetrichelper ( ) . startstatementlifetimer ( ) ; return newproxy ( new statementproxyhandler ( statement , this , lifetimercontext ) ) ; }	Wrap a simple statement to monitor it.
public preparedstatement wrappreparedstatement ( preparedstatement preparedstatement , string sql ) { query query = new query ( sql ) ; timer . context lifetimercontext = getmetrichelper ( ) . startpreparedstatementlifetimer ( query ) ; return newproxy ( new preparedstatementproxyhandler ( preparedstatement , this , query , lifetimercontext ) ) ; }	Wrap a prepared statement to monitor it.
public callablestatement wrapcallablestatement ( callablestatement callablestatement , string sql ) { query query = new query ( sql ) ; timer . context lifetimercontext = getmetrichelper ( ) . startcallablestatementlifetimer ( query ) ; return newproxy ( new callablestatementproxyhandler ( callablestatement , this , query , lifetimercontext ) ) ; }	Wrap a callable statement to monitor it.
private class < ? extends resultset > getresultsettype ( resultset resultset ) { class < ? extends resultset > resultsettype ; if ( resultset instanceof rowset ) { if ( resultset instanceof cachedrowset ) { if ( resultset instanceof webrowset ) { if ( resultset instanceof filteredrowset ) { resultsettype = filteredrowset . class ; } else if ( resultset instanceof joinrowset ) { resultsettype = joinrowset . class ; } else { resultsettype = webrowset . class ; } } else { resultsettype = cachedrowset . class ; } } else if ( resultset instanceof jdbcrowset ) { resultsettype = jdbcrowset . class ; } else { resultsettype = rowset . class ; } } else { resultsettype = resultset . class ; } return resultsettype ; }	Determine the interface implemented by this result set.
protected string [ ] buildargs ( ) { string result [ ] = new string [ num_ ] ; list < string > args = new arraylist < string > ( ) ; if ( lang != null && lang . length ( ) > num_ ) { args . add ( flagify ( cowsaycli . opt . lang . tostring ( ) ) ) ; args . add ( lang ) ; } if ( html ) { args . add ( flagify ( cowsaycli . opt . html . tostring ( ) ) ) ; } if ( alt != null && alt . length ( ) > num_ ) { args . add ( flagify ( cowsaycli . opt . alt . tostring ( ) ) ) ; args . add ( alt ) ; } if ( wrap != null ) { args . add ( flagify ( cowsaycli . opt . wrap_at . tostring ( ) ) ) ; args . add ( wrap ) ; } buildfaceargs ( args ) ; args . add ( message ) ; return args . toarray ( result ) ; }	Build an args array that can be passed to cowsay.
private void buildfaceargs ( final list < string > args ) { if ( mode != null && cowface . isknownmode ( mode ) ) { args . add ( flagify ( mode ) ) ; } else { if ( eyes != null ) { args . add ( flagify ( cowsaycli . opt . eyes . tostring ( ) ) ) ; args . add ( eyes ) ; } if ( tongue != null ) { args . add ( flagify ( cowsaycli . opt . tongue . tostring ( ) ) ) ; args . add ( tongue ) ; } if ( cowfile != null ) { args . add ( flagify ( cowsaycli . opt . cowfile . tostring ( ) ) ) ; args . add ( cowfile ) ; } } }	Face specific flags, either a face mode or face customizations.
public string execute ( ) throws illegalstateexception { validate ( ) ; string [ ] args = buildargs ( ) ; string result ; if ( think ) { result = cowsay . think ( args ) ; } else { result = cowsay . say ( args ) ; } return result ; }	Run cowsay with the provided properties.
@ override public void execute ( ) throws buildexception { try { string moo = executor . execute ( ) ; if ( this . property != null && this . property . length ( ) > num_ ) { getproject ( ) . setproperty ( this . property , moo ) ; } else { system . out . println ( moo ) ; } } catch ( illegalstateexception ex ) { throw new buildexception ( ex . getmessage ( ) , ex ) ; } }	Run cowsay with the provided attributes.
public static void setlanguage ( final string language ) { currentlocale = new locale ( language ) ; messages = resourcebundle . getbundle ( str_ , currentlocale ) ; }	Set the language.
protected static string getmessage ( final string key ) { if ( messages == null ) { setlanguage ( default_lang ) ; } return messages . getstring ( key ) ; }	Get a message in the correct language.
private static string sayorthink ( final string [ ] args , final boolean think ) { try { boolean isthought = think ; string wordwrap = null ; commandline commandline = cowsaycli . parsecmdargs ( args ) ; if ( commandline != null ) { if ( commandline . hasoption ( cowsaycli . opt . help . tostring ( ) ) ) { cowsaycli . showcmdlinehelp ( ) ; } else if ( commandline . hasoption ( cowsaycli . opt . list_cows . tostring ( ) ) ) { string [ ] files = cowloader . listallcowfiles ( ) ; if ( files != null ) { return stringutils . join ( files , system . getproperty ( str_ ) ) ; } } else { string cowfilespec = null ; cowface cowface = null ; if ( commandline . hasoption ( cowsaycli . opt . wrap_at . tostring ( ) ) ) { wordwrap = commandline . getoptionvalue ( cowsaycli . opt . wrap_at . tostring ( ) ) ; } else if ( commandline . hasoption ( cowsaycli . opt . nowrap . tostring ( ) ) ) { wordwrap = str_ ; } cowface = getcowfacebymode ( commandline ) ; if ( cowface == null ) {	Do some cowsaying or cowthinking.
private static string formathtml ( final commandline commandline , final string plaincow , final string moosage , final boolean isthought ) { string cow = plaincow ; if ( commandline . hasoption ( cowsaycli . opt . html . tostring ( ) ) ) { cow = stringescapeutils . escapehtml4 ( cow ) ; cow = str_ + cow + str_ ; string alt ; if ( commandline . hasoption ( cowsaycli . opt . alt . tostring ( ) ) ) { alt = commandline . getoptionvalue ( cowsaycli . opt . alt . tostring ( ) ) ; } else { alt = isthought ? i18n . getmessage ( str_ ) : i18n . getmessage ( str_ ) ; } string escaped = stringescapeutils . escapehtml4 ( moosage ) ; cow += string . format ( alt , escaped ) ; cow += str_ ; } return cow ; }	May apply HTML markup to the cow, if requested in the command line.
private static cowface getcowfacebymode ( final commandline commandline ) { cowface cowface = null ; set < string > modes = cowface . cow_modes . keyset ( ) ; for ( string mode : modes ) { if ( commandline . hasoption ( mode ) ) { cowface = cowface . getbymode ( mode ) ; break ; } } return cowface ; }	If a pre-defined cow mode has been set on the command line then use that face.
private static cowface getcowface ( final commandline commandline ) { cowface cowface ; cowface = new cowface ( ) ; if ( commandline . hasoption ( cowsaycli . opt . eyes . tostring ( ) ) ) { cowface . seteyes ( commandline . getoptionvalue ( cowsaycli . opt . eyes . tostring ( ) ) ) ; } if ( commandline . hasoption ( cowsaycli . opt . tongue . tostring ( ) ) ) { cowface . settongue ( commandline . getoptionvalue ( cowsaycli . opt . tongue . tostring ( ) ) ) ; } return cowface ; }	Get a regular cow face optionally formatted with custom eyes and tongue from the command line.
private static string extractcowtemplate ( final string cow ) throws cowparseexception { matcher matcher = cowstart_re . matcher ( cow ) ; if ( matcher . find ( num_ ) ) { string result = matcher . replacefirst ( str_ ) ; return result ; } else { throw new cowparseexception ( str_ + cow ) ; } }	Extracts the ascii art part of the cowfile, removing any before or after PERL comments, variable assignments, weird EOC markers etc.
public static string load ( final string cowfilespec ) { string effectivecowfilespec = ( cowfilespec != null ) ? cowfilespec . trim ( ) : default_cow ; if ( effectivecowfilespec . length ( ) > num_ ) { if ( ! effectivecowfilespec . endswith ( cowfile_ext ) ) { effectivecowfilespec += cowfile_ext ; } inputstream cowinputstream ; if ( effectivecowfilespec . indexof ( file . separatorchar ) >= num_ ) { cowinputstream = getcowfrompath ( effectivecowfilespec ) ; } else { cowinputstream = getcowfromcowpath ( effectivecowfilespec ) ; } if ( cowinputstream == null ) {	Call this with the provided cowfileSpec - that is the value passed to `-f` on the commandline.
private static string cowinputstreamtostring ( final inputstream cowinputstream ) { bufferedreader reader = new bufferedreader ( new inputstreamreader ( cowinputstream ) ) ; stringbuilder sb = new stringbuilder ( ) ; string line ; try { string newline = system . getproperty ( str_ ) ; while ( ( line = reader . readline ( ) ) != null ) { sb . append ( line ) ; sb . append ( newline ) ; } reader . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( cowloader . class . getname ( ) ) . log ( level . severe , null , ex ) ; } finally { if ( cowinputstream != null ) { try { cowinputstream . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( cowloader . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } return sb . tostring ( ) ; }	Reads a cowfile from an InputStream and returns a string.
private static inputstream getcowfrompath ( final string path ) { string cwd = system . getproperty ( str_ ) ;	In the case that the cowfileSpec is a filesystem path call this method to attempt to load the cowfile.It will attempt to load the cowfile relative to CWD and if that fails it will try as an absolute path.
private static inputstream getcowfromcowpath ( final string cowname ) { string cowpath = system . getenv ( str_ ) ; if ( cowpath != null ) { string [ ] paths = cowpath . split ( file . pathseparator ) ; if ( paths != null ) { for ( string path : paths ) { file cowfile = getcowfile ( path , cowname ) ; if ( cowfile != null ) { return cowfiletocowinputstream ( cowfile ) ; } } } } return getcowfromresources ( cowname ) ; }	This will attempt to load a cowfile, by name, from the COWPATH environment variable or bundled cowfiles.Note that bundled cowfiles are considered part of the COWPATH since this is how to original `cowsay` worked.COWPATH takes precedence and bundled cowfiles are only considered after searching the COWPATH.
private static boolean iscowfile ( final file cowfile ) { if ( cowfile != null && cowfile . exists ( ) ) { return cowfile . getname ( ) . endswith ( cowfile_ext ) ; } return bool_ ; }	Determine if this File appears to be a genuine cowfile.This is not a deep check, more rigor will be applied later.
private static inputstream cowfiletocowinputstream ( final file cowfile ) { inputstream cowinputstream = null ; try { cowinputstream = new fileinputstream ( cowfile ) ; } catch ( filenotfoundexception ex ) { logger . getlogger ( cowloader . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return cowinputstream ; }	Reads a File to an InputStream.Not sure why I thought this should be a separate method, I guess it made sense at the time.
private static file getcowfile ( final string folder , final string cowname ) { file [ ] cowfiles = getcowfiles ( folder ) ; for ( file cowfile : cowfiles ) { if ( cowfile . getname ( ) . equals ( cowname ) ) { return cowfile ; } } return null ; }	Get a cowfile, by name, from the given directory.
private static file [ ] getcowfiles ( final string folder ) { file dir = new file ( folder ) ; file [ ] files ; files = dir . listfiles ( new filenamefilter ( ) { @ override public boolean accept ( final file dir , final string name ) { return name . endswith ( str_ ) ; } } ) ; return files ; }	Gets all cowfiles found in the given directory.
protected static cowface getbymode ( final string mode ) { if ( mode != null ) { return cow_modes . get ( mode ) ; } return null ; }	Get cow args by mode.
public final void seteyes ( final string eyes ) { if ( eyes != null && eyes . length ( ) > num_ ) { if ( eyes . length ( ) > num_ ) { this . eyes = eyes . substring ( num_ , num_ ) ; } else { this . eyes = eyes ; } } }	Set custom cow eyes.
public final void settongue ( final string tongue ) { if ( tongue != null && tongue . length ( ) > num_ ) { if ( tongue . length ( ) > num_ ) { this . tongue = tongue . substring ( num_ , num_ ) ; } else { this . tongue = tongue ; } } }	Set custom cow tongue.
public static final boolean isknownmode ( final string mode ) { set < string > modes = cow_modes . keyset ( ) ; return modes . contains ( mode ) ; }	Determine if the given mode flag is known and mapped to a particular cow face.
public static commandline parsecmdargs ( final string [ ] argv ) { final commandlineparser cmdlineparser = new defaultparser ( ) ; try { commandline parsed = cmdlineparser . parse ( options , argv , bool_ ) ; if ( parsed . hasoption ( opt . lang . text ) ) { string language = parsed . getoptionvalue ( opt . lang . text ) ; if ( language != null ) { i18n . setlanguage ( language ) ; } } return parsed ; } catch ( missingargumentexception ex ) { option option = ex . getoption ( ) ; string flag = option . getopt ( ) ; if ( flag == null ) { flag = option . getlongopt ( ) ; } logger . getlogger ( cowsaycli . class . getname ( ) ) . log ( level . info , i18n . getmessage ( str_ ) , flag ) ; } catch ( parseexception ex ) { logger . getlogger ( cowsaycli . class . getname ( ) ) . log ( level . finest , null , ex ) ; } return null ; }	Parses an array of arguments.
public static void showcmdlinehelp ( ) { helpformatter formatter = new helpformatter ( ) ; updateoptiondescriptions ( ) ; formatter . printhelp ( i18n . getmessage ( str_ ) , options ) ; }	Displays help message to user.
private static string formatbubble ( final bubblewrap bubble , final string message , final int longestline ) { string newline = system . getproperty ( str_ ) ; string [ ] lines = message . split ( newline ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( bubble . buildtop ( longestline ) ) ; if ( lines . length > num_ ) { sb . append ( bubble . formatmultiopen ( lines [ num_ ] , longestline ) ) ; for ( int i = num_ ; i < ( lines . length - num_ ) ; i ++ ) { sb . append ( bubble . formatmultimid ( lines [ i ] , longestline ) ) ; } sb . append ( bubble . formatmultiend ( lines [ ( lines . length - num_ ) ] , longestline ) ) ; } else { sb . append ( bubble . formatsingle ( lines [ num_ ] ) ) ; } sb . append ( bubble . buildbottom ( longestline ) ) ; return sb . tostring ( ) ; }	Draws a complete bubble around a line-wrapped message.
private string wrapmessage ( final string message ) {	Applies word wrapping to the message to handle long lines.
private string formatmessage ( final string message ) { string result ; if ( message != null ) { result = wrapmessage ( message ) ; int longestline = getlongestlinelen ( result ) ; if ( ! isthought ) { result = bubble . formatspeech ( result , longestline ) ; } else { result = bubble . formatthought ( result , longestline ) ; } return result ; } return str_ ; }	Builds the bubble around the message.
public void setwordwrap ( final string wordwrap ) { try { int ww = integer . parseint ( wordwrap ) ; if ( ww >= num_ ) { this . wordwrap = ww ; } } catch ( throwable ignore ) {	Set the length of the wordwrap, default is "40", zero disables line-wrap.
private static int getlongestlinelen ( final string message ) { string newline = system . getproperty ( str_ ) ; string [ ] lines = message . split ( newline ) ; int maxlen = num_ ; for ( string line : lines ) { maxlen = math . max ( maxlen , line . length ( ) ) ; } return maxlen ; }	For a given multiline message determines the character count of the longest line.
public boolean log ( string message ) { if ( message == null ) return bool_ ; boolean ok ; try { ok = loggly . log ( token , tags , message ) . isexecuted ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; ok = bool_ ; } return ok ; }	Posts a log message to Loggly.
public void log ( string message , final callback callback ) { if ( message == null ) return ; loggly . log ( token , tags , message , new retrofit2 . callback < logglyresponse > ( ) { @ override public void onresponse ( call < logglyresponse > call , response < logglyresponse > response ) { callback . success ( ) ; } @ override public void onfailure ( call < logglyresponse > call , throwable throwable ) { callback . failure ( throwable . getmessage ( ) ) ; } } ) ; }	Posts a log message asynchronously to Loggly.
public void logbulk ( collection < string > messages , final callback callback ) { if ( messages == null ) return ; string parcel = joinstrings ( messages ) ; if ( parcel . isempty ( ) ) return ; loggly . logbulk ( token , tags , parcel , new retrofit2 . callback < logglyresponse > ( ) { @ override public void onresponse ( call < logglyresponse > call , response < logglyresponse > response ) { callback . success ( ) ; } @ override public void onfailure ( call < logglyresponse > call , throwable throwable ) { callback . failure ( throwable . getmessage ( ) ) ; } } ) ; }	Posts several log messages in bulk to Loggly asynchronously.
private string joinstrings ( collection < string > messages ) { stringbuilder b = new stringbuilder ( ) ; for ( string s : messages ) { if ( s == null || s . isempty ( ) ) { continue ; }	Combines a collection of messages to be sent to Loggly.In order to preserve event boundaries, the new lines ineach message are replaced with '\r', which get strippedby Loggly.
public sortedmap < string , schema > getschemas ( ) throws sqlexception { synchronized ( getschemaslock ) { if ( getschemascache == null ) { sortedmap < string , schema > newschemas = new treemap < > ( databasemetadata . getcollator ( ) ) ; try ( resultset results = metadata . getmetadata ( ) . getschemas ( ) ) { resultsetmetadata resultsmeta = results . getmetadata ( ) ; while ( results . next ( ) ) { int colcount = resultsmeta . getcolumncount ( ) ;	Gets all schemas for this catalog keyed by unique name.
public schema getschema ( string name ) throws norowexception , sqlexception { schema schema = getschemas ( ) . get ( name ) ; if ( schema == null ) throw new norowexception ( str_ + name ) ; return schema ; }	Gets the schema of the provided name.
@ override public void contextinitialized ( servletcontextevent sce ) { try { servletcontext sc ; synchronized ( servletcontextlock ) { servletcontext = sce . getservletcontext ( ) ; sc = servletcontext ; }	Set to null when context shutdown.
private void resync ( ) throws ioexception { path gtl ; synchronized ( gittoplevellock ) { gtl = gittoplevel ; } watchservice w ; synchronized ( watcherlock ) { w = watcher ; } if ( gtl != null && w != null ) { synchronized ( registered ) { set < path > extrakeys = new hashset < > ( registered . keyset ( ) ) ; resync ( w , gtl , extrakeys ) ; for ( path extrakey : extrakeys ) { if ( debug ) log ( str_ + extrakey ) ; registered . remove ( extrakey ) . cancel ( ) ; } } } }	Resyncs the entire directory recursively, registering and canceling anydiscrepancies found.
public sortedmap < string , table > gettables ( ) throws sqlexception { synchronized ( gettableslock ) { if ( gettablescache == null ) { sortedmap < string , table > newtables = new treemap < > ( databasemetadata . getcollator ( ) ) ; try ( resultset results = catalog . getmetadata ( ) . getmetadata ( ) . gettables ( catalog . getname ( ) , name , null , null ) ) { while ( results . next ( ) ) { table newtable = new table ( this , results . getstring ( str_ ) , results . getstring ( str_ ) ) ; if ( newtables . put ( newtable . getname ( ) , newtable ) != null ) throw new assertionerror ( str_ + newtable ) ; } } gettablescache = aocollections . optimalunmodifiablesortedmap ( newtables ) ; } return gettablescache ; } }	Gets all tables for this schema keyed by unique name.
public table gettable ( string name ) throws norowexception , sqlexception { table table = gettables ( ) . get ( name ) ; if ( table == null ) throw new norowexception ( ) ; return table ; }	Gets the table of the provided name.
private void writetoimpl ( writer out , long writestart , long writeend ) throws ioexception { try (	Implementation of writeTo.
public sortedmap < string , catalog > getcatalogs ( ) throws sqlexception { synchronized ( getcatalogslock ) { if ( getcatalogscache == null ) { sortedmap < string , catalog > newcatalogs = new treemap < > ( englishcollator ) ; try ( resultset results = metadata . getcatalogs ( ) ) { while ( results . next ( ) ) { catalog newcatalog = new catalog ( this , results . getstring ( num_ ) ) ; if ( newcatalogs . put ( newcatalog . getname ( ) , newcatalog ) != null ) throw new assertionerror ( str_ + newcatalog ) ; } } getcatalogscache = aocollections . optimalunmodifiablesortedmap ( newcatalogs ) ; } return getcatalogscache ; } }	Gets all catalogs for this database keyed by unique name.
public catalog getcatalog ( string name ) throws norowexception , sqlexception { catalog catalog = getcatalogs ( ) . get ( name ) ; if ( catalog == null ) throw new norowexception ( ) ; return catalog ; }	Gets the catalog of the provided name.
private char [ ] getbuffer ( int additional ) throws ioexception { long newlen = ( long ) length + additional ; if ( newlen > max_length ) throw new ioexception ( str_ + max_length + str_ + newlen + str_ ) ; char [ ] buf = this . buffer ; int buflen = buf . length ; if ( newlen > buflen ) {	Grows as-needed to fit the provided new capacity.
private void log ( encoder encoder ) throws ioexception { if ( encoder == null ) log . write ( str_ ) ; else { string classname = encoder . getclass ( ) . getname ( ) ;	Provides detailed logging for a media encoder.
private void log ( writer writer ) throws ioexception { if ( writer == null ) { log . write ( str_ ) ; } else if ( writer instanceof loggingwriter ) { loggingwriter loggingwriter = ( loggingwriter ) writer ; log . write ( str_ ) ; log . write ( long . tostring ( loggingwriter . getid ( ) ) ) ; log . write ( str_ ) ; } else if ( writer instanceof encoderwriter ) { encoderwriter encoderwriter = ( encoderwriter ) writer ; log . write ( str_ ) ; log ( encoderwriter . getencoder ( ) ) ; log . write ( str_ ) ; log ( encoderwriter . getout ( ) ) ; log . write ( str_ ) ; } else { string classname = writer . getclass ( ) . getname ( ) ; if ( classname . equals ( str_ ) ) log . write ( str_ ) ; else if ( classname . equals ( str_ ) ) log . write ( str_ ) ; else log . write ( classname ) ; } }	Provides detailed logging for a writer.
public static < f > lexicalposition < f > zerowithfile ( final f file ) { return lexicalposition . of ( num_ , num_ , optional . of ( file ) ) ; }	Construct a lexical position at line 0, column 0, with the given file.
private void append ( int segmentindex , int off , int len , stringbuilder buffer ) { switch ( segmenttypes [ segmentindex ] ) { case segmentedwriter . type_string : buffer . append ( ( string ) segmentvalues [ segmentindex ] , off , off + len ) ; break ; case segmentedwriter . type_char_newline : assert off == num_ ; assert len == num_ ; buffer . append ( str_ ) ; break ; case segmentedwriter . type_char_quote : assert off == num_ ; assert len == num_ ; buffer . append ( str_ ) ; break ; case segmentedwriter . type_char_apos : assert off == num_ ; assert len == num_ ; buffer . append ( str_ ) ; break ; case segmentedwriter . type_char_other : assert off == num_ ; assert len == num_ ; buffer . append ( ( ( character ) segmentvalues [ segmentindex ] ) . charvalue ( ) ) ; break ; default : throw new assertionerror ( ) ; } }	Appends the given range of a segment.
private void writesegment ( int segmentindex , int off , int len , encoder encoder , writer out ) throws ioexception { switch ( segmenttypes [ segmentindex ] ) { case segmentedwriter . type_string : encoder . write ( ( string ) segmentvalues [ segmentindex ] , off , len , out ) ; break ; case segmentedwriter . type_char_newline : assert off == num_ ; assert len == num_ ; encoder . write ( str_ , out ) ; break ; case segmentedwriter . type_char_quote : assert off == num_ ; assert len == num_ ; encoder . write ( str_ , out ) ; break ; case segmentedwriter . type_char_apos : assert off == num_ ; assert len == num_ ; encoder . write ( str_ , out ) ; break ; case segmentedwriter . type_char_other : assert off == num_ ; assert len == num_ ; encoder . write ( ( character ) segmentvalues [ segmentindex ] , out ) ; break ; default : throw new assertionerror ( ) ; } }	Writes the given range of a segment to the given writer using the given encoder.
private static char charat ( byte type , object value , int charindex ) { switch ( type ) { case segmentedwriter . type_string : return ( ( string ) value ) . charat ( charindex ) ; case segmentedwriter . type_char_newline : assert charindex == num_ ; return str_ ; case segmentedwriter . type_char_quote : assert charindex == num_ ; return str_ ; case segmentedwriter . type_char_apos : assert charindex == num_ ; return str_ ; case segmentedwriter . type_char_other : assert charindex == num_ ; return ( character ) value ; default : throw new assertionerror ( ) ; } }	Gets the character at the given index in a segment.This is the absolute index, the offset is not added-in.
private map < string , class < ? > > getsqldatatypes ( ) throws sqlexception { if ( sqldatatypes == null ) {	Loads the custom types when first needed and caches the results.
public sortedmap < string , column > getcolumnmap ( ) throws sqlexception { synchronized ( getcolumnmaplock ) { if ( getcolumnmapcache == null ) { sortedmap < string , column > newcolumnmap = new treemap < > ( databasemetadata . getcollator ( ) ) ; try ( resultset results = schema . getcatalog ( ) . getmetadata ( ) . getmetadata ( ) . getcolumns ( schema . getcatalog ( ) . getname ( ) , schema . getname ( ) , name , null ) ) { while ( results . next ( ) ) { column newcolumn = new column ( this , results . getstring ( str_ ) , results . getint ( str_ ) , results . getstring ( str_ ) , getinteger ( results , str_ ) , getinteger ( results , str_ ) , results . getint ( str_ ) , results . getstring ( str_ ) , getinteger ( results , str_ ) , results . getint ( str_ ) , results . getstring ( str_ ) , results . getstring ( str_ ) ) ; if ( newcolumnmap . put ( newcolumn . getname ( ) , newcolumn ) != null ) throw new assertionerror ( str_ + newcolumn ) ; } } getcolumnmapcache = aocollections . optimalunmodifiablesortedmap ( newcolumnmap ) ; } return getcolumnmapcache ; } }	Gets all columns for this schema keyed by unique name.
public column getcolumn ( string name ) throws norowexception , sqlexception { column column = getcolumnmap ( ) . get ( name ) ; if ( column == null ) throw new norowexception ( ) ; return column ; }	Gets the column of the provided name.
public list < column > getcolumns ( ) throws sqlexception { synchronized ( getcolumnslock ) { if ( getcolumnscache == null ) { sortedmap < string , column > columnmap = getcolumnmap ( ) ; list < column > newcolumns = new arraylist < > ( columnmap . size ( ) ) ; for ( int i = num_ ; i < columnmap . size ( ) ; i ++ ) newcolumns . add ( null ) ; for ( column column : columnmap . values ( ) ) { int ordinalposition = column . getordinalposition ( ) ; if ( newcolumns . set ( ordinalposition - num_ , column ) != null ) throw new sqlexception ( str_ + ordinalposition ) ; } for ( int i = num_ ; i < newcolumns . size ( ) ; i ++ ) { if ( newcolumns . get ( i ) == null ) throw new sqlexception ( str_ + ( i + num_ ) ) ; } getcolumnscache = aocollections . optimalunmodifiablelist ( newcolumns ) ; } return getcolumnscache ; } }	Gets all columns for this schema in their ordinal position order.Column with ordinal position one is at index zero.
public column getcolumn ( int ordinalposition ) throws norowexception , sqlexception { try { return getcolumns ( ) . get ( ordinalposition - num_ ) ; } catch ( indexoutofboundsexception exc ) { throw new norowexception ( exc ) ; } }	Gets the column of the provided ordinal position, where positions start at one.
public set < ? extends table > getimportedtables ( ) throws sqlexception { synchronized ( getimportedtableslock ) { if ( getimportedtablescache == null ) { set < table > newimportedtables = new linkedhashset < > ( ) ; catalog catalog = schema . getcatalog ( ) ; databasemetadata metadata = catalog . getmetadata ( ) ; try ( resultset results = schema . getcatalog ( ) . getmetadata ( ) . getmetadata ( ) . getimportedkeys ( schema . getcatalog ( ) . getname ( ) , schema . getname ( ) , name ) ) { while ( results . next ( ) ) { string pkcat = results . getstring ( str_ ) ; catalog pkcatalog = pkcat == null ? catalog : metadata . getcatalog ( pkcat ) ; newimportedtables . add ( pkcatalog . getschema ( results . getstring ( str_ ) ) . gettable ( results . getstring ( str_ ) ) ) ; } } getimportedtablescache = aocollections . optimalunmodifiableset ( newimportedtables ) ; } return getimportedtablescache ; } }	Gets the set of tables that this table depends on.This is based on getImportedKeys.
public set < ? extends table > getexportedtables ( ) throws sqlexception { synchronized ( getexportedtableslock ) { if ( getexportedtablescache == null ) { set < table > newexportedtables = new linkedhashset < > ( ) ; catalog catalog = schema . getcatalog ( ) ; databasemetadata metadata = catalog . getmetadata ( ) ; try ( resultset results = schema . getcatalog ( ) . getmetadata ( ) . getmetadata ( ) . getexportedkeys ( schema . getcatalog ( ) . getname ( ) , schema . getname ( ) , name ) ) { while ( results . next ( ) ) { string fkcat = results . getstring ( str_ ) ; catalog fkcatalog = fkcat == null ? catalog : metadata . getcatalog ( fkcat ) ; newexportedtables . add ( fkcatalog . getschema ( results . getstring ( str_ ) ) . gettable ( results . getstring ( str_ ) ) ) ; } } getexportedtablescache = aocollections . optimalunmodifiableset ( newexportedtables ) ; } return getexportedtablescache ; } }	Gets the set of tables that depend on this table.This is based on getExportedKeys.
private void addsegment ( byte type , object value , int off , int len ) { assert ! isclosed ; assert len > num_ : str_ ; final int arraylen = segmentvalues . length ; if ( segmentcount == arraylen ) {	Adds a new segment.
private void log ( char ch ) throws ioexception { if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch < str_ ) { log . write ( str_ ) ; string hex = integer . tohexstring ( ch ) ; for ( int l = hex . length ( ) ; l < num_ ; l ++ ) log . write ( str_ ) ; log . write ( hex ) ; log . write ( str_ ) ; } else { log . write ( str_ ) ; log . write ( ch ) ; log . write ( str_ ) ; } }	Writes a character, unicode escaping as needed.
private void log ( string value ) throws ioexception { if ( value == null ) { log . write ( str_ ) ; } else { log . write ( str_ ) ; for ( int i = num_ , len = value . length ( ) ; i < len ; i ++ ) { char ch = value . charat ( i ) ; if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch == str_ ) log . write ( str_ ) ; else if ( ch < str_ ) { log . write ( str_ ) ; string hex = integer . tohexstring ( ch ) ; for ( int l = hex . length ( ) ; l < num_ ; l ++ ) log . write ( str_ ) ; log . write ( hex ) ; } else { log . write ( ch ) ; } } log . write ( str_ ) ; } }	Writes a String, unicode escaping as needed.
public void movecameratolastlocation ( googlemap map , float zoom ) { mprovider . getlastlocation ( ) . subscribe ( location -> map . movecamera ( cameraupdatefactory . newlatlngzoom ( new latlng ( location . getlatitude ( ) , location . getlongitude ( ) ) , zoom ) ) ) ; }	Move and zoom to the most recently reported location.
public void animatecameratoincludeposition ( googlemap map , latlng position , long delay ) { if ( ! map . getprojection ( ) . getvisibleregion ( ) . latlngbounds . contains ( position ) ) { if ( delay > num_ ) { new handler ( looper . getmainlooper ( ) ) . postdelayed ( ( ) -> doanimatecameratoincludeposition ( map , position ) , delay ) ; } else { doanimatecameratoincludeposition ( map , position ) ; } } }	If the position is not visible on the map, animate the camera to include it, after the delay.
public static animator circletorect ( view circle , view rect ) { return circlerect ( circle , rect , bool_ ) ; }	Get an Animator that reveals the rectangular View from the circular View.
public static animator circlefromrect ( view circle , view rect ) { return circlerect ( circle , rect , bool_ ) ; }	Get an Animator that "unreveals" the rectangular View to the circular View.
public static transition arcmotion ( context context ) { if ( sarc == null ) { sarc = transitioninflater . from ( context ) . inflatetransition ( r . transition . sprockets_arc_motion ) ; } return sarc ; }	Get a cached arc motion transition.
public static stylespan bold ( int i ) { if ( sbolds == null ) { sbolds = new arraylist < > ( ) ; sbolds . add ( bold ( ) ) ; } if ( i < sbolds . size ( ) ) { return sbolds . get ( i ) ; } else { stylespan bold = new stylespan ( typeface . bold ) ; sbolds . add ( bold ) ; return bold ; } }	Get a cached bold span.
public static viewpropertyanimator scalein ( view view ) { return scale ( view , num_ , enterscreen ( ) , r . integer . anim_duration_enter ) ; }	Scale in the View to full size.
public static viewpropertyanimator scaleout ( view view ) { return scale ( view , num_ , exitscreen ( ) , r . integer . anim_duration_exit ) ; }	Scale out the View to zero size.
public static viewpropertyanimator scaleshownext ( viewswitcher view , runnable endaction ) { return scale ( view , view :: shownext , endaction ) ; }	Scale out the ViewSwitcher, show the next View, scale it back in, and run the action.
public static int getcount ( context context , uri uri ) { string [ ] proj = { str_ } ; return cursors . firstint ( context . getcontentresolver ( ) . query ( uri , proj , null , null , null ) ) ; }	Get the number of rows at the URI.
public static string concataddresslines ( address address , string delimiter ) { stringbuilder s = new stringbuilder ( num_ ) ; for ( int i = num_ , max = address . getmaxaddresslineindex ( ) ; i <= max ; i ++ ) { if ( i > num_ ) { s . append ( delimiter ) ; } s . append ( address . getaddressline ( i ) ) ; } return s . tostring ( ) ; }	Get a single line address which uses the delimiter between the original lines.
public static googleapiclient connect ( googleapiclient client , connectedlistener connected , onconnectionfailedlistener failed ) { client . registerconnectioncallbacks ( new connectionlistener ( connected ) ) ; client . registerconnectionfailedlistener ( failed ) ; client . connect ( ) ; return client ; }	Register the listeners and then connect the client.
@ suppresslint ( str_ ) private static fragmenttransaction transit ( fragmentmanager fm , int transit ) { return fm != null ? fm . begintransaction ( ) . settransition ( transit ) : null ; }	Begin a transaction that uses the transition.
@ override public int getforegroundcolor ( ) { return color . argb ( malpha , color . red ( mcolor ) , color . green ( mcolor ) , color . blue ( mcolor ) ) ; }	Get the result of applying the alpha to the color.
public static void setonclicklisteners ( onclicklistener listener , view ... views ) { for ( view view : views ) { view . setonclicklistener ( listener ) ; } }	Set the listener on all of the Views.
public static string getlevelname ( int level ) { switch ( level ) { case verbose : return str_ ; case debug : return str_ ; case info : return str_ ; case warn : return str_ ; case error : return str_ ; case assert : return str_ ; default : return str_ ; } }	Get the name of the level.
public static activityoptions makescaleupanimation ( view source ) { return activityoptions . makescaleupanimation ( source , num_ , num_ , source . getwidth ( ) , source . getheight ( ) ) ; }	Scale the new Activity from the View to its full size.
public static void show ( view view ) { view . postdelayed ( ( ) -> managers . inputmethod ( view . getcontext ( ) ) . showsoftinput ( view , num_ ) , num_ ) ;	Show the current input method for the focused View which can receive input.
public static void hide ( view view ) { managers . inputmethod ( view . getcontext ( ) ) . hidesoftinputfromwindow ( view . getwindowtoken ( ) , num_ ) ; }	Hide the input method for the View's window.
public static boolean hasposition ( cursor cursor , int position ) { return ! cursor . isclosed ( ) && position >= num_ && position < cursor . getcount ( ) ; }	True if the cursor has a row at the position.
public static int count ( cursor cursor , boolean close ) { int count = cursor . getcount ( ) ; close ( cursor , close ) ; return count ; }	Get the number of rows in the cursor.
public static int firstint ( cursor cursor , boolean close ) { int i = cursor . movetofirst ( ) ? cursor . getint ( num_ ) : integer . min_value ; close ( cursor , close ) ; return i ; }	Get the int value in the first row and column.
public static long firstlong ( cursor cursor , boolean close ) { long l = cursor . movetofirst ( ) ? cursor . getlong ( num_ ) : long . min_value ; close ( cursor , close ) ; return l ; }	Get the long value in the first row and column.
@ nullable public static string firststring ( cursor cursor , boolean close ) { string s = cursor . movetofirst ( ) ? cursor . getstring ( num_ ) : null ; close ( cursor , close ) ; return s ; }	Get the String value in the first row and column.
public static int [ ] allints ( cursor cursor , boolean close ) { int [ ] i = empty_int_array ; if ( cursor . movetofirst ( ) ) { i = new int [ cursor . getcount ( ) ] ; do { i [ cursor . getposition ( ) ] = cursor . getint ( num_ ) ; } while ( cursor . movetonext ( ) ) ; } close ( cursor , close ) ; return i ; }	Get all int values in the first column.
public static long [ ] alllongs ( cursor cursor , boolean close ) { long [ ] l = empty_long_array ; if ( cursor . movetofirst ( ) ) { l = new long [ cursor . getcount ( ) ] ; do { l [ cursor . getposition ( ) ] = cursor . getlong ( num_ ) ; } while ( cursor . movetonext ( ) ) ; } close ( cursor , close ) ; return l ; }	Get all long values in the first column.
public static string [ ] allstrings ( cursor cursor , boolean close ) { string [ ] s = empty_string_array ; if ( cursor . movetofirst ( ) ) { s = new string [ cursor . getcount ( ) ] ; do { s [ cursor . getposition ( ) ] = cursor . getstring ( num_ ) ; } while ( cursor . movetonext ( ) ) ; } close ( cursor , close ) ; return s ; }	Get all String values in the first column.
@ bindingadapter ( value = { str_ , str_ , str_ , str_ } , requireall = bool_ ) public static void load ( imageview view , drawable placeholder , uri load , boolean resize , string transform ) { requestcreator req = picasso . with ( view . getcontext ( ) ) . load ( load ) . placeholder ( placeholder ) ; if ( resize ) { req . fit ( ) . centercrop ( ) ;	Set a placeholder before loading an image, optionally resizing and transforming it.
public static int getorientation ( recyclerview view ) { layoutmanager layout = view . getlayoutmanager ( ) ; if ( layout instanceof linearlayoutmanager ) { return ( ( linearlayoutmanager ) layout ) . getorientation ( ) ; } else if ( layout instanceof staggeredgridlayoutmanager ) { return ( ( staggeredgridlayoutmanager ) layout ) . getorientation ( ) ; } return - num_ ; }	Get the orientation of the RecyclerView's LayoutManager.
public static int getspancount ( recyclerview view ) { layoutmanager layout = view . getlayoutmanager ( ) ; if ( layout != null ) { if ( layout instanceof gridlayoutmanager ) { return ( ( gridlayoutmanager ) layout ) . getspancount ( ) ; } else if ( layout instanceof staggeredgridlayoutmanager ) { return ( ( staggeredgridlayoutmanager ) layout ) . getspancount ( ) ; } return num_ ;	Get the number of spans laid out by the RecyclerView's LayoutManager.
public static relativelayout . layoutparams addrule ( view view , int verb , int anchor ) { relativelayout . layoutparams params = getparams ( view ) ; params . addrule ( verb , anchor ) ; view . requestlayout ( ) ; return params ; }	Add the rule to the View's RelativeLayout params and request a layout of the View.
public boolean wasread ( ) { int pos = getposition ( ) ; if ( pos < num_ || pos >= mread . length ) { return bool_ ; } boolean read = mread [ pos ] ; if ( ! read ) { mread [ pos ] = bool_ ; } return read ; }	True if this method has been previously called for the current row.
public static looper mineormain ( ) { looper looper = looper . mylooper ( ) ; return looper != null ? looper : looper . getmainlooper ( ) ; }	Get this thread's Looper, if it's a Looper thread.
@ suppresswarnings ( str_ ) public static < e > list < e > values ( sparsearray < e > array ) { return ( list < e > ) values ( array , null , null , null , null ) ; }	Get the values of the SparseArray.
@ suppresswarnings ( str_ ) public static < e > list < e > values ( longsparsearray < e > array ) { return ( list < e > ) values ( null , null , null , null , array ) ; }	Get the values of the LongSparseArray.
private void checkadapter ( ) { pageradapter adapter = mpager . getadapter ( ) ; if ( madapter != adapter ) { if ( madapter != null ) { madapter . unregisterdatasetobserver ( mobserver ) ; } madapter = adapter ; if ( madapter != null ) { madapter . registerdatasetobserver ( mobserver ) ; } reset ( ) ; } }	Check if the pager has a new adapter and switch to it if it does.
private void checkdrawable ( ) { drawable drawable = mview . getdrawable ( ) ; if ( mdrawable != drawable ) { mviewwidth = mview . getwidth ( ) ; mviewheight = mview . getheight ( ) ; if ( mviewwidth > num_ && mviewheight > num_ ) { mdrawable = drawable ;	Check if the ImageView has a new Drawable and calculate the new scaling if it does.
private void updatematrix ( int position , float offset ) { if ( mdrawable != null && mscale > num_ ) { if ( mpagecount == - num_ && madapter != null ) {	Scale the image and translate it according to the pager position and offset.
private int upddel ( int op , uri uri , contentvalues vals , string sel , string [ ] args ) { sql sql = elements ( op , uri , new string [ ] { str_ } , sel , args , null ) ; long [ ] ids = cursors . alllongs ( sql . mresult ) ; sqlitedatabase db = mhelper . getwritabledatabase ( ) ; int rows = op == update ? db . update ( sql . table ( ) , vals , sql . sel ( ) , sql . args ( ) ) : db . delete ( sql . table ( ) , ! textutils . isempty ( sql . sel ( ) ) ? sql . sel ( ) : str_ , sql . args ( ) ) ; if ( rows > num_ ) { for ( long id : ids ) { notifychange ( contenturis . withappendedid ( sql . notifyuri ( ) , id ) , uri ) ; } } return rows ; }	Update or delete records and get the number of rows affected.
private sql elements ( int op , uri uri , string [ ] proj , string sel , string [ ] args , string order ) { mutablesql sql = translate ( uri ) ; if ( sql == null ) { sql = sql . create ( ) ; } if ( sql . table ( ) == null ) { sql . table ( uri . getpathsegments ( ) . get ( num_ ) ) ; } if ( sql . notifyuri ( ) == null && op != select ) { sql . notifyuri ( uri . buildupon ( ) . path ( sql . table ( ) ) . clearquery ( ) . fragment ( null ) . build ( ) ) ; } if ( op != insert ) {	Get the updated SQL elements for the URI and, when not inserting, a cursor with the queryresults.
public static int getbytecount ( int width , int height , config config ) { int bytes = num_ ; switch ( config ) { case alpha_8 : bytes = num_ ; break ; case rgb_565 : bytes = num_ ; break ; case argb_4444 : bytes = num_ ; break ; case argb_8888 : bytes = num_ ; break ; } return width * height * bytes ; }	Get the number of bytes that would be used to store a bitmap with the size, in pixels, andstorage config.
@ nullable public static bitmap mutable ( bitmap source ) { if ( source . ismutable ( ) ) { return source ; } config config = source . getconfig ( ) ; bitmap bm = source . copy ( config != null ? config : argb_8888 , bool_ ) ; if ( bm != null ) { source . recycle ( ) ; } return bm ; }	If the bitmap is immutable, get a mutable copy of it.
public static boolean hasactivity ( context context , intent intent ) { return context . getpackagemanager ( ) . resolveactivity ( intent , match_default_only ) != null ; }	True if the Intent can be resolved to an Activity.
public static intent mailto ( list < string > to , list < string > cc , list < string > bcc , string subject , string body ) { return new intent ( action_sendto , uris . mailto ( to , cc , bcc , subject , body ) ) ; }	Get an Activity Intent that launches an email app with the headers.
public void setdefaultcontentview ( ) { setcontentview ( r . layout . sprockets_panes , r . id . panes , r . id . pane1 , r . id . pane2 ) ; }	Use the default layout for the panes.
@ nullable @ suppresswarnings ( str_ ) public < t extends fragment > t findfragmentbypane ( @ intrange ( from = num_ , to = num_ ) int pane ) { string tag = elements . get ( spanes , pane - num_ ) ; return tag != null ? ( t ) getfragmentmanager ( ) . findfragmentbytag ( tag ) : null ; }	Get the fragment that is displayed in the pane.
public static bundle of ( string key1 , int value1 , string key2 , int value2 ) { bundle b = new bundle ( num_ ) ; b . putint ( key1 , value1 ) ; b . putint ( key2 , value2 ) ; return b ; }	Get a Bundle of the keys and values.
public static intent newintent ( context context , string action , uri data , contentvalues values ) { return newintent ( context , action , data , values , null , null ) ; }	Get an Intent to insert or update rows of the content.
public static intent newupdateintent ( context context , uri data , contentvalues values , string selection , string [ ] selectionargs ) { return newintent ( context , action_edit , data , values , selection , selectionargs ) ; }	Get an Intent to update the selected rows of the content.
public static intent newdeleteintent ( context context , uri data ) { return newintent ( context , action_delete , data , null , null , null ) ; }	Get an Intent to delete rows of the content.
public static intent newdeleteintent ( context context , uri data , string selection , string [ ] selectionargs ) { return newintent ( context , action_delete , data , null , selection , selectionargs ) ; }	Get an Intent to delete the selected rows of the content.
public static int getactionbarsize ( context context ) { typedarray a = context . obtainstyledattributes ( sactionbarsize ) ; int size = a . getdimensionpixelsize ( num_ , num_ ) ; a . recycle ( ) ; return size ; }	Get the ActionBar height in the Context's theme.
@ nullable public static drawable getactionbarbackground ( context context ) { int [ ] attrs = { android . r . attr . actionbarstyle } ; typedarray a = context . obtainstyledattributes ( attrs ) ; int id = a . getresourceid ( num_ , num_ ) ; a . recycle ( ) ; if ( id > num_ ) { attrs [ num_ ] = android . r . attr . background ; a = context . obtainstyledattributes ( id , attrs ) ; drawable background = a . getdrawable ( num_ ) ; a . recycle ( ) ; return background ; } return null ; }	Get the ActionBar background in the Context's theme.
public static boolean isconnected ( context context ) { networkinfo info = managers . connectivity ( context ) . getactivenetworkinfo ( ) ; return info != null && info . isconnected ( ) ; }	True if a data network is connected.
public void diff_cleanupefficiency ( linkedlist < diff > diffs ) { if ( diffs . isempty ( ) ) { return ; } boolean changes = bool_ ; stack < diff > equalities = new stack < diff > ( ) ;	Reduce the number of edits by eliminating operationally trivial equalities.
public linkedlist < patch > patch_make ( string text1 , linkedlist < diff > diffs ) { if ( text1 == null || diffs == null ) { throw new illegalargumentexception ( str_ ) ; } linkedlist < patch > patches = new linkedlist < patch > ( ) ; if ( diffs . isempty ( ) ) { return patches ;	Compute a list of patches to turn text1 into text2.text2 is not provided, diffs are the delta between text1 and text2.
@ override public < r > option < r > flatmap ( throwablefunction1 < t , option < r > > function ) { try { return function . apply ( value ) ; } catch ( throwable ex ) { throw new brokenfunctionexception ( str_ , ex ) ; } }	Returns an Option consisting of the result of applying the given function to the current value.
string convertsoapmessageasstring ( soapmessage soapmessage ) { if ( soapmessage == null ) { return str_ ; } try { bytearrayoutputstream os = new bytearrayoutputstream ( ) ; soapmessage . writeto ( os ) ; return new string ( os . tobytearray ( ) , determinemessageencoding ( soapmessage ) ) ; } catch ( exception e ) { logger . error ( str_ + soapmessage . tostring ( ) ) ; return str_ ; } }	Converts a SOAPMessage instance to string representation.
protected static synchronized fileobjectwrapper getorcreateprofileproperties ( final filer filer , string filename ) throws ioexception { fileobjectwrapper fileobject = traceeprofileproperties . get ( filename ) ; if ( fileobject == null ) { fileobject = new fileobjectwrapper ( filer . createresource ( standardlocation . source_output , str_ , filename , null ) ) ; traceeprofileproperties . put ( filename , fileobject ) ; } return fileobject ; }	Central method to get cached FileObjectWrapper. Creates new FileObjectWrapper if it can't be found.
protected boolean isvalidmethod ( element element ) {	Checks if passed element is a method declared as public, not abstract and not static.
protected boolean isgettermethod ( executableelement executableelement ) {	Checks if passed element has a non void return type and takes no parameters.
public boolean getpropertyvalue ( final string propertykey ) { if ( propertykey == null ) { return null ; }	Checks whether the property for the passed key is enabled or not.
protected boolean checkifclasshasnoargsconstructor ( typeelement typeelement ) {	Checks if class has noargs constructor or default noargs constructor.
public static < t extends annotation > t getannotationfromtype ( final object instance , class < t > annotation ) { if ( instance == null || annotation == null ) { return null ; } return instance . getclass ( ) . getannotation ( annotation ) ; }	Gets an annotation of passed instance.
public static boolean checkmethodhasnonvoidreturntype ( final method method ) { if ( method == null ) { return bool_ ; } try { return ! ( void . type == method . getreturntype ( ) ) ; } catch ( exception e ) { return bool_ ; } }	Checks whether the passsed method has a non void return value.
public boolean apply ( final stringbuilder stringbuilder , final outputstyle outputstyle , final outputelement outputelement ) { boolean result = bool_ ; if ( outputelement != null ) { if ( outputelementtype . collection . equals ( outputelement . getoutputelementtype ( ) ) ) { result = handlecollectiontype ( stringbuilder , outputstyle , outputelement ) ; } else if ( outputelementtype . complex . equals ( outputelement . getoutputelementtype ( ) ) ) { if ( traceecontextlogannotationutilities . getannotationfromtype ( outputelement . getencapsulatedinstance ( ) ) != null ) { result = handletraceecontextprovider ( stringbuilder , outputstyle , outputelement ) ; } else { result = handlecomplextype ( stringbuilder , outputstyle , outputelement ) ; } } } return result ; }	Write the type string to the Stringbuilder.
public static set < class > findwrapperclasses ( ) { final list < typetowrapper > localtypetowrapperlist = gettypetowrapper ( ) ; set < class > resultlist = new hashset < class > ( ) ; if ( localtypetowrapperlist != null ) { for ( typetowrapper typetowrapper : localtypetowrapperlist ) { resultlist . add ( typetowrapper . getwrappertype ( ) ) ; } } return resultlist ; }	Gets a list with all wrapper classes.
public static set < implicitcontextdata > getimplicitcontextdataproviders ( ) { final set < implicitcontextdata > result = new hashset < implicitcontextdata > ( ) ; for ( class clazz : contextproviderserviceloader . getservicelocator ( ) . getimplicitcontextprovider ( ) ) { try { if ( implicitcontextdata . class . isassignablefrom ( clazz ) ) { implicitcontextdata instance = ( implicitcontextdata ) ( clazz . newinstance ( ) ) ; result . add ( instance ) ; } } catch ( throwable e ) {	Generic function to get a implicit data provider classes from resource files.
public static list < typetowrapper > getavailablewrappers ( ) { final list < typetowrapper > result = new arraylist < typetowrapper > ( ) ; for ( class clazz : contextproviderserviceloader . getservicelocator ( ) . getcontextprovider ( ) ) { try { if ( wrappedcontextdata . class . isassignablefrom ( clazz ) ) {	Method to get all available wrappers.
private void initconnectors ( ) {	Initializes all available connectors.
final void senderrorreporttoconnectors ( connectoroutputprovider connectoroutputprovider ) { for ( connector connector : this . connectormap . values ( ) ) { connector . senderrorreport ( connectoroutputprovider ) ; } }	Send error report to all initialized connector instances.
final set < string > getconnectorconfigurationnames ( ) { set < string > connectornames = new hashset < string > ( ) ; enumeration < object > keyenumeration = getsystemproperties ( ) . keys ( ) ; while ( keyenumeration . hasmoreelements ( ) ) { string key = keyenumeration . nextelement ( ) . tostring ( ) ;	Extracts all names for connector configurations from System properties.
final map < string , string > getpropertiesforconnectorconfigurationname ( final string connectorname ) { final map < string , string > propertymap = new hashmap < string , string > ( ) ; final string patternstring = string . format ( connector_property_grabber_pattern , connectorname ) ; final pattern propertygrabpattern = pattern . compile ( patternstring ) ; final set < map . entry < object , object > > entries = getsystemproperties ( ) . entryset ( ) ; for ( map . entry < object , object > entry : entries ) { final string key = entry . getkey ( ) . tostring ( ) ; final object value = entry . getvalue ( ) ;	Collects all properties for a given connector configuration name and writes them to a Map.
final connector createconnector ( final string connectorconfigurationname ) { map < string , string > propertymap = this . getpropertiesforconnectorconfigurationname ( connectorconfigurationname ) ; string type = propertymap . get ( traceecontextloggerconstants . system_property_context_logger_connector_type ) ;	Tries to create a Connector for a given connector configuration name.
private boolean isconnectorconfigured ( class connectorclass ) { for ( connector connector : this . connectormap . values ( ) ) { if ( connectorclass . isinstance ( connector ) ) { return bool_ ; } } return bool_ ; }	Checks whether the LogConnector is defined or not.
boolean hasgetterprefixinmethodname ( method method ) { string methodname = method . getname ( ) ; if ( methodname != null ) { for ( string prefix : getter_prefixes ) { if ( methodname . startswith ( prefix ) ) { return bool_ ; } } } return bool_ ; }	Getter method names must have a specific prefix.
boolean ispublicnonstaticmethod ( final method method ) { int modifiers = method . getmodifiers ( ) ; return ! modifier . isstatic ( modifiers ) && modifier . ispublic ( modifiers ) ; }	Getter methods must be public and not be static.
boolean hascompatiblereturntypes ( class type , method method ) { field correspondingfield = getcorrespondingfield ( type , method ) ; return correspondingfield != null && method . getreturntype ( ) . isassignablefrom ( correspondingfield . gettype ( ) ) ; }	Getter method and field must have compatible fields.
field getcorrespondingfield ( class type , method method ) { try { return type . getdeclaredfield ( getterutilities . getfieldname ( method ) ) ; } catch ( nosuchfieldexception e ) { return null ; } }	Helper method for getting a corresponsing field for a method.
public static boolean isgettermethod ( final string methodname ) { if ( methodname != null ) { for ( string prefix : getter_prefixes ) { if ( methodname . startswith ( prefix ) ) { return bool_ ; } } } return bool_ ; }	Checks whether the method name starts with a getter prefix.
static string capitalizefirstcharofstring ( final string input ) { if ( input == null || input . length ( ) == num_ ) { return str_ ; } else if ( input . length ( ) == num_ ) { return input . touppercase ( ) ; } else { return input . substring ( num_ , num_ ) . touppercase ( ) + input . substring ( num_ ) ; } }	Capitalizes first char of an input string.
static string decapitalizefirstcharofstring ( final string input ) { if ( input == null || input . length ( ) == num_ ) { return str_ ; } else if ( input . length ( ) == num_ ) { return input . tolowercase ( ) ; } else { return input . substring ( num_ , num_ ) . tolowercase ( ) + input . substring ( num_ ) ; } }	Decapitalizes first char of an input string.
static string stripgetterprefix ( final string input ) { if ( input != null ) { for ( string prefix : getter_prefixes ) { if ( input . startswith ( prefix ) ) { return input . substring ( prefix . length ( ) ) ; } } } return input ; }	Strips getter prefix from input string.
void senderrorreporttoconnectors ( proceedingjoinpoint proceedingjoinpoint , string annotatedid , throwable e ) {	Sends the error reports to all connectors.
public object apply ( contextloggerconfiguration contextloggerconfiguration , object instancetowrap ) {	Wraps the passed instance inside a matching tracee context logging provider instance.Will return the passed instance, if no matching tracee context logging provider exists.
protected object createinstance ( final class type ) { if ( type != null ) { try { return type . newinstance ( ) ; } catch ( exception e ) {	Creates a new instance of the passed type via reflection.
public static profile getcurrentprofile ( ) {	Gets the current profile.Uses the following algorithm to determine the profile.1.
public static properties openproperties ( final string propertyfilename ) throws ioexception { if ( propertyfilename == null ) { return null ; } inputstream inputstream = null ; try { inputstream = profile . class . getresourceasstream ( propertyfilename ) ; if ( inputstream != null ) {	Loads properties from resources.
private void fillmanualcontextoverridemap ( final string [ ] contexts , final boolean value ) { if ( contexts != null ) { for ( string context : contexts ) { if ( ! context . isempty ( ) ) { this . manualcontextoverrides . put ( context , value ) ; } } } }	Adds passed contexts value pairs to manualContextOverrides.
private traceecontextstringrepresentationbuilderimpl createcontextstringrepresentationlogbuilder ( ) { traceecontextstringrepresentationbuilderimpl traceecontextstringrepresentationbuilderimpl = new traceecontextstringrepresentationbuilderimpl ( ) ; traceecontextstringrepresentationbuilderimpl . setmanualcontextoverrides ( this . getmanualcontextoverrides ( ) ) ; traceecontextstringrepresentationbuilderimpl . setprofile ( this . getprofile ( ) ) ; traceecontextstringrepresentationbuilderimpl . setenforceorder ( this . getenforceorder ( ) ) ; traceecontextstringrepresentationbuilderimpl . setoutputwriterconfiguration ( this . getoutputwriterconfiguration ( ) ) ; return traceecontextstringrepresentationbuilderimpl ; }	Creates a TraceeGsonContextStringRepresentationBuilder instance which can be used for creating the createStringRepresentation message.
public static boolean checkifmethodthrowscontainspassedexception ( final proceedingjoinpoint proceedingjoinpoint , throwable thrownexception ) { if ( proceedingjoinpoint == null || thrownexception == null ) { return bool_ ; } class [ ] throwsclassesfrommethodsignature = getdefinedthrowsfrommethodsignature ( proceedingjoinpoint ) ; return checkclassisdefinedinthrowsexception ( throwsclassesfrommethodsignature , thrownexception ) ; }	Checks whether the passed Throwable is contained in methods throws part.
public static boolean checkclassisdefinedinthrowsexception ( class [ ] classes , throwable thrownexception ) {	Checks whether the passed Throwable is defined included in passed classes array or is subtype of one of the included classes.
public static class [ ] getdefinedthrowsfrommethodsignature ( final proceedingjoinpoint proceedingjoinpoint ) { if ( proceedingjoinpoint == null ) { return new class [ num_ ] ; }	Gets all Exceptions declared at the throws part of the method signature.
public static boolean checkprocesswatchdog ( final watchdog watchdogannotation , final proceedingjoinpoint proceedingjoinpoint , final throwable throwable ) {	Checks whether the exception should be processed or not.
public final @ notnull s hassize ( int expected ) { isnotnull ( ) ; int size = actualgroupsize ( ) ; if ( size == expected ) { return myself ( ) ; } failifcustommessageisset ( ) ; throw failure ( format ( str_ , expected , size , actual ) ) ; }	Verifies that the number of values in the actual group is equal to the given one.
protected final void assertdoesnothaveduplicates ( ) { isnotnull ( ) ; collection < ? > duplicates = duplicatesfrom ( actualaslist ( ) ) ; if ( duplicates . isempty ( ) ) { return ; } failifcustommessageisset ( ) ; throw failure ( format ( str_ , actual , duplicates ) ) ; }	Verifies that the actual group of objects does not have duplicates.
public view getdropdownview ( int index , view convertview , viewgroup parent ) { return dropdownviewfactory . getview ( convertview , itemlist . get ( index ) ) ; }	Declared by SpinnerAdapter, this method allows your spinner to showdifferent views in your drop down vs the 'closed' spinned box.
protected final int reservetermname ( string name ) { checkstatus ( status . initializing ) ; checkinitializationprecondition ( termutils . isvalidtermname ( name ) , str_ , name ) ; checkinitializationprecondition ( ! this . nameordinal . containskey ( name ) , str_ , name ) ; this . nameordinal . put ( name , ++ this . ordinal ) ; return this . ordinal ; }	Allow the reservation of term names during the initialization of thevocabulary.
protected final < s extends immutableterm > void registerterm ( s term ) { checkstatus ( status . initializing ) ; checkinitializationprecondition ( this . nameordinal . containskey ( term . name ( ) ) , str_ , term . name ( ) ) ; checkinitializationprecondition ( term . ordinal ( ) >= num_ && term . ordinal ( ) <= this . ordinal , str_ , term . ordinal ( ) , term . name ( ) ) ; this . terms . put ( term . ordinal ( ) , this . termclass . cast ( term ) ) ; }	Upon reservation, the method enables registering the properly builtimmutable term instance.
protected final void initialize ( ) { checkstatus ( status . initializing ) ; if ( this . terms . size ( ) != this . nameordinal . size ( ) ) { throw new illegalstateexception ( string . format ( str_ , this . namespace , getclass ( ) . getname ( ) ) ) ; } this . status = status . initialized ; }	Complete the initialization of the vocabulary.
public dataset getrepresentation ( ) { return datadsl . dataset ( ) . individual ( newreference ( ) . tolocalindividual ( ) . named ( str_ ) ) . haslink ( knows ) . referringto ( newreference ( ) . tomanagedindividual ( str_ ) . named ( str_ ) ) . individual ( newreference ( ) . tolocalindividual ( ) . named ( str_ ) ) . hasproperty ( created_on ) . withvalue ( new date ( ) ) . haslink ( knows ) . referringto ( newreference ( ) . tomanagedindividual ( str_ ) . named ( str_ ) ) . individual ( newreference ( ) . tomanagedindividual ( str_ ) . named ( str_ ) ) . hasproperty ( creation_date ) . withvalue ( new date ( ) ) . hasproperty ( age ) . withvalue ( num_ ) . haslink ( has_father ) . toindividual ( newreference ( ) . tolocalindividual ( ) . named ( str_ ) ) . haslink ( has_wife ) . referringto ( newreference ( ) . tolocalindividual ( ) . named ( str_ ) ) . build ( ) ; }	Get custom representation with bad data.
public name < string > name ( string name , string ... names ) { return createname ( assemble ( name , names ) ) ; }	Concatenates elements to form a dotted name, discarding null valuesand empty strings.
public name < string > name ( class < ? > clazz , string ... names ) { return name ( clazz . getcanonicalname ( ) , names ) ; }	Concatenates a canonical class name and elements to form a dotted name, discarding any null values or empty stringsany null values or empty strings.
public static mediatype wildcard ( string type ) { requirenonnull ( type , type_cannot_be_null ) ; return new immutablemediatype ( mediatypes . preferredsyntax ( ) , type , wildcard_type , null , null ) ; }	Create a wildcard media type for a given primary type.
public static mediatype wildcard ( string type , string suffix ) { requirenonnull ( type , type_cannot_be_null ) ; requirenonnull ( suffix , str_ ) ; return new immutablemediatype ( mediatypes . preferredsyntax ( ) , type , wildcard_type , suffix , null ) ; }	Create a wildcard structured-syntax media type for a given primary type.
public static mediatype of ( string type , string subtype ) { requirenonnull ( type , type_cannot_be_null ) ; requirenonnull ( subtype , str_ ) ; return fromstring ( type + str_ + subtype ) ; }	Create a media type.
public static string toheader ( final mediatype mediatype ) { requirenonnull ( mediatype , reference_media_type_cannot_be_null ) ; final stringbuilder builder = new stringbuilder ( ) . append ( mediatype . type ( ) . tolowercase ( locale . english ) ) . append ( str_ ) . append ( mediatype . subtype ( ) . tolowercase ( locale . english ) ) ; final string suffix = mediatype . suffix ( ) ; if ( suffix != null ) { builder . append ( str_ ) . append ( suffix . tolowercase ( locale . english ) ) ; } final charset charset = mediatype . charset ( ) ; if ( charset != null ) { builder . append ( str_ ) . append ( charset . name ( ) . tolowercase ( locale . english ) ) ; } for ( entry < string , string > entry : mediatype . parameters ( ) . entryset ( ) ) { final string key = entry . getkey ( ) ; if ( isstandardparameter ( key ) ) { continue ; } builder . append ( str_ ) . append ( key . tolowercase ( locale . english ) ) . append ( str_ ) . append ( entry . getvalue ( ) ) ; } return builder . tostring ( ) ; }	Format the media type in a HTTP-header compliant manner using preferredformat.
@ override public void run ( ) { applicationcontext ctx = applicationcontext . getinstance ( ) ; logger . debug ( str_ , new date ( ) ) ; try ( writesession session = ctx . createsession ( ) ) { resourcesnapshot snapshot = session . find ( resourcesnapshot . class , this . name , dynamicresourcehandler . class ) ; dataset dataset = this . handler . get ( snapshot ) ; individual < ? , ? > individual = dataset . individualofid ( managedindividualid . createid ( snapshot . name ( ) , snapshot . templateid ( ) ) ) ; snapshotresolver snapshotresolver = snapshotresolver . builder ( ) . withreadsession ( session ) . withcanonicalbase ( canonical_base ) . build ( ) ; uri snapshotendpoint = snapshotresolver . touri ( snapshot ) ; individual . addvalue ( snapshot_endpoint , literals . newliteral ( snapshotendpoint ) ) ; individual . addvalue ( snapshot_resolution , literals . newliteral ( roundtrip ( snapshotresolver , snapshotendpoint , snapshot ) ) ) ; this . handler . update ( this . name , dataset ) ; session . modify ( snapshot ) ; session . savechanges ( ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } finally { logger . debug ( str_ ) ; } }	Update the resource representation adding the path where the resource ispublished and whether or not if given that URI it can be resolved to thesame resource.
@ override public int compareto ( term other ) { immutableterm self = this ; if ( self . getdeclaringvocabulary ( ) != other . getdeclaringvocabulary ( ) ) { throw new classcastexception ( ) ; } return self . ordinal - other . ordinal ( ) ; }	Compares this term with the specified object for order.
public list < name < string > > pendingattachmentnames ( string attachmentid ) { list < name < string > > result = new arraylist < name < string > > ( ) ; namesource source = this . attachmentnamesources . get ( attachmentid ) ; if ( source != null ) { result . addall ( source . pendingnames ) ; } return result ; }	Return the pending names for the specified attachment.
public void addattachmentname ( string attachmentid , name < string > nextname ) { namesource ( attachmentid ) . addname ( nextname ) ; }	Add a name to the list of available names for a given attachment.
public name < string > nextattachmentname ( string attachmentid ) { namesource result = this . attachmentnamesources . get ( attachmentid ) ; if ( result == null ) { result = new namesource ( str_ + attachmentid + str_ ) ; } return result . nextname ( ) ; }	Return the next available name for a given attachment.
public static nameprovider create ( name < string > resource ) { objects . requirenonnull ( resource , str_ ) ; return new nameprovider ( resource ) ; }	Create a new name provider.
private static void parsesuffix ( final mediarange mr , final string mediatype ) { final string subtype = mr . subtype ; final int plusidx = subtype . lastindexof ( str_ ) ; if ( plusidx == num_ ) { throw new invalidmediatypeexception ( mediatype , str_ + subtype . substring ( num_ ) + str_ ) ; } else if ( plusidx == subtype . length ( ) - num_ ) { throw new invalidmediatypeexception ( mediatype , str_ + subtype . substring ( num_ , subtype . length ( ) - num_ ) + str_ ) ; } else if ( plusidx > num_ ) { mr . subtype = subtype . substring ( num_ , plusidx ) ; mr . suffix = subtype . substring ( plusidx + num_ ) ; }	As per RFC 6838, Section 4.2 structuring syntaxes specifier syntaxes aredefined after the last '+' symbol.
private static void checkquotedstring ( final string quotedstring ) { boolean quotedpair = bool_ ; for ( int i = num_ ; i < quotedstring . length ( ) ; i ++ ) { final char ch = quotedstring . charat ( i ) ; if ( quotedpair ) { checkargument ( quoted_pair . get ( ch ) , str_ , ch , quotedstring , i ) ; quotedpair = bool_ ; } else if ( ch == slash ) { quotedpair = bool_ ; } else { checkargument ( qdtext . get ( ch ) , str_ , ch , quotedstring , i ) ; } } checkargument ( ! quotedpair , str_ , quotedstring , quotedstring . length ( ) ) ; }	Checks the given quoted string for illegal characters, as defined in RFC7230, section 3.2.6.
@ override public integer next ( ) { if ( ! hasnext ( ) ) { throw new nosuchelementexception ( str_ ) ; } this . index = this . next ; final integer codepoint = character . codepointat ( this . s , this . next ) ; this . next += character . charcount ( codepoint ) ; return codepoint ; }	Returns the next code point in the iteration.
@ override public void run ( ) { applicationcontext ctx = applicationcontext . getinstance ( ) ; date date = new date ( ) ; logger . debug ( str_ , date ) ; try ( writesession session = ctx . createsession ( ) ) { resourcesnapshot snapshot = session . find ( resourcesnapshot . class , this . name , dynamicresourcehandler . class ) ; dataset dataset = this . handler . get ( snapshot ) ; individual < ? , ? > individual = dataset . individualofid ( managedindividualid . createid ( this . name , dynamicresourcehandler . id ) ) ; individual . addvalue ( refreshed_on , literals . of ( date ) . datetime ( ) ) ; this . handler . update ( this . name , dataset ) ; session . modify ( snapshot ) ; session . savechanges ( ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } finally { logger . debug ( str_ ) ; } }	Update the resource representation adding a temporal timestamp of whenthe resource was last updated.
private static void closequietly ( final inputstream is , final string message ) { if ( is != null ) { try { is . close ( ) ; } catch ( final exception e ) { if ( logger . iswarnenabled ( ) ) { logger . warn ( message , e ) ; } } } }	Close an input stream logging possible failures.
static boolean isnamestartchar ( final int codepoint ) { return ( codepoint == str_ ) || ( codepoint >= str_ && codepoint <= str_ ) || ( codepoint == str_ ) || ( codepoint >= str_ && codepoint <= str_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) ; }	Determines if a character is a Name start character.
static boolean isnamechar ( final int codepoint ) { return isnamestartchar ( codepoint ) || ( codepoint == str_ ) || ( codepoint == str_ ) || ( codepoint >= str_ && codepoint <= str_ ) || ( codepoint == num_ ) || ( codepoint >= num_ && codepoint <= num_ ) || ( codepoint >= num_ && codepoint <= num_ ) ; }	Determines if a character is a Name character.
static void checktoken ( final string token , final string message , object ... args ) { checknotnull ( message , str_ ) ; try { validatelength ( token ) ; validatecharacters ( token ) ; } catch ( illegalargumentexception e ) { throw new invalidtokenexception ( string . format ( message , args ) , token , e ) ; } }	Checks the given type name for illegal characters, as defined in RFC7230, section 3.2.6.
public datatransformator mediatype ( mediatype mediatype ) { checknotnull ( mediatype , media_type_cannot_be_null ) ; datatransformator result = new datatransformator ( this ) ; result . setmediatype ( mediatype ) ; return result ; }	Create transformator with the specified media type.
static void registeradapterclass ( class < ? > clazz ) { objects . requirenonnull ( clazz , str_ ) ; typeadapter . adapter_classes . addifabsent ( clazz ) ; }	Register a new adapter class.
static < s , t > typeadapter < s , t > createadapter ( class < ? extends s > sourcetype , class < ? extends t > targettype ) { return docreateadapter ( targettype , adaptermethodvalidator . newinstance ( targettype , sourcetype ) ) ; }	Get an adapter capable of transforming instances of a source type intoinstances of a target type.
static < s , t > t adapt ( s object , class < ? extends t > resultclass ) { return typeadapter . < s , t > docreateadapter ( resultclass , adaptermethodvalidator . newinstance ( resultclass , object ) ) . adapt ( object ) ; }	Transform a given object into an instance of the specified type.
public immutablenamespaces withprefix ( string prefix , string namespaceuri ) { objects . requirenonnull ( prefix , str_ ) ; objects . requirenonnull ( namespaceuri , str_ ) ; immutablenamespaces result = new immutablenamespaces ( this . map ) ; result . map . put ( prefix , namespaceuri ) ; return result ; }	Create a copy of the namespaces which includes a mapping between a givenprefix and namespace URI.
public immutablenamespaces withoutprefix ( string ... prefixes ) { immutablenamespaces result = new immutablenamespaces ( this . map ) ; for ( string prefix : prefixes ) { result . map . remove ( prefix ) ; } return result ; }	Create a copy of the namespaces without the prefixes.
public static string escapexml ( final charsequence s ) { final stringbuilder sb = new stringbuilder ( s . length ( ) * num_ ) ; final codepointiterator iterator = new codepointiterator ( s ) ; while ( iterator . hasnext ( ) ) { final int codepoint = iterator . next ( ) ; if ( codepoint == str_ ) { sb . append ( lt ) ; } else if ( codepoint == str_ ) { sb . append ( gt ) ; } else if ( codepoint == str_ ) { sb . append ( quot ) ; } else if ( codepoint == str_ ) { sb . append ( amp ) ; } else if ( codepoint == str_ ) { sb . append ( apos ) ; } else { sb . appendcodepoint ( codepoint ) ; } } return sb . tostring ( ) ; }	Escapes a character sequence so that it is valid XML.
@ override public dataset query ( resourcesnapshot resource , query query , readsession session ) throws invalidqueryexception { return querysupport . getdescription ( resource . name ( ) , query ) ; }	Instead of retrieving the contents of the resource, return a descriptionof the query received.
public final void addnameprovider ( name < string > containername , nameprovider provider ) { this . nameproviders . put ( containername , provider ) ; }	Add a name provider for a container resource.
public final nameprovider nameprovider ( name < ? > containername ) { nameprovider result = this . nameproviders . get ( containername ) ; if ( result == null ) { throw new applicationruntimeexception ( str_ + containername + str_ ) ; } return result ; }	Return the name provider registered for a given container resource.
public < t > t unwrap ( final class < ? extends t > clazz ) throws applicationengineexception { checknotnull ( clazz , str_ ) ; if ( ! clazz . isinstance ( this ) ) { throw new applicationengineexception ( str_ + clazz . getcanonicalname ( ) ) ; } return clazz . cast ( this ) ; }	Return an object of the specified type to allow access to theprovider-specific API.
public boolean isoutofscope ( ) {	Checks if the path is out of the scope.
public path withdirectory ( final string directory ) { final path result = new path ( this ) ; result . setdirectory ( directory ) ; return result ; }	Create a new path with a given directory.
public path withfile ( final string file ) { final path result = new path ( this ) ; result . setfile ( file ) ; return result ; }	Create a new path with a given file.
private path assemblerelativesegments ( final path path , final path base , final deque < string > segments ) { if ( segments . isempty ( ) && path . isdirectory ( ) && base . isfile ( ) ) { segments . add ( current ) ; } return path . create ( assemblesegments ( segments , path . getfile ( ) ) ) ; }	If there are no segments in the resolved path, and we are trying toresolve a directory coming from a path, we have to make explicit that wewant the directory.
static < t > class < t > gettypeparameter ( class < ? > clazz , class < ? super t > bound ) { type t = checknotnull ( clazz ) ; while ( t instanceof class < ? > ) { t = ( ( class < ? > ) t ) . getgenericsuperclass ( ) ; } if ( t instanceof parameterizedtype ) { class < t > result = processparameterizedtype ( bound , ( parameterizedtype ) t ) ; if ( result != null ) { return result ; } } throw new illegalstateexception ( str_ + clazz . getname ( ) ) ; }	Finds the type parameter for the given class which is assignable to thebound class.
public static < t > primitiveobjectfactory < t > create ( final class < ? extends t > valueclass ) { checknotnull ( valueclass , str_ ) ; checkargument ( valueclass . isprimitive ( ) , str_ + valueclass . getname ( ) + str_ ) ; return new primitiveobjectfactory < t > ( valueclass ) ; }	Create a primitive object factory for the specified primitive class.
public static list < variant > createvariants ( mediatype ... mediatypes ) { return variant . variantlistbuilder . newinstance ( ) . mediatypes ( mediatypes ) . encodings ( ) . languages ( ) . add ( ) . build ( ) ; }	Get a list of acceptable variants.
@ suppresswarnings ( str_ ) public individual < t , s > resolve ( dataset dataset ) { return ( individual < t , s > ) dataset . individualofid ( ref ( ) ) ; }	Find the individual of the data set with the same identifier.
@ factory public static < t extends viewgroup > matcher < t > equalchildrencountas ( int value ) { return new viewgroupcomparison < t > ( value , equal , equal ) ; }	Is value = expected?.
@ factory public static < t extends viewgroup > matcher < t > morechildrenthan ( int value ) { return new viewgroupcomparison < t > ( value , greater_than , greater_than ) ; }	Is value > expected?.
@ factory public static < t extends viewgroup > matcher < t > morechildrenorequal ( int value ) { return new viewgroupcomparison < t > ( value , equal , greater_than ) ; }	Is value >= expected?.
@ factory public static < t extends viewgroup > matcher < t > lesschildrenthan ( int value ) { return new viewgroupcomparison < t > ( value , less_than , less_than ) ; }	Is value < expected?.
@ factory public static < t extends viewgroup > matcher < t > lesschildrenorequal ( int value ) { return new viewgroupcomparison < t > ( value , less_than , equal ) ; }	Is value <= expected?.
public measures getmeasuresbyyearstate ( string year , string stateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , year , str_ , stateid ) , measures . class ) ; }	This method returns a list of state ballot measures in a given year.
public measure getmeasure ( string measureid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , measureid ) , measure . class ) ; }	This method returns a single Ballot Measure detail.
public candidaterating getcandidaterating ( string candidateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , candidateid ) , candidaterating . class ) ; }	This method dumps a candidate's rating by an SIG.
public rating getrating ( string ratingid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , ratingid ) , rating . class ) ; }	This method dumps all candidate ratings from a scorecard by an SIG.
public elections getelectionbyyearstate ( string year ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , year ) , elections . class ) ; }	This method grabs district basic election data according to year and stateid.
public electionbyzip getelectionbyzip ( string zip5 ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , zip5 ) , electionbyzip . class ) ; }	This method grabs district basic election data according to zip code.
public stagecandidates getstagecandidates ( string electionid , string stageid , string party ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , electionid , str_ , stageid , str_ , party ) , stagecandidates . class ) ; }	This method grabs district basic election data according to electionId and stageId.Per state lists of a Presidential election are available by specifying the stateId.
public addressaddress getofficebyofficestate ( string officeid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , officeid ) , addressaddress . class ) ; }	This method grabs office address and basic candidate information according to the officeId and state.
public offices getofficesbytype ( string officetypeid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , officetypeid ) , offices . class ) ; }	This method dumps offices we keep track of according to type.
public offices getofficesbylevel ( string levelid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , levelid ) , offices . class ) ; }	This method dumps offices we keep track of according to level.
public offices getofficesbytypelevel ( string officetypeid , string officelevelid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , officetypeid , str_ , officelevelid ) , offices . class ) ; }	This method dumps offices we keep track of according to type and level.
public offices getofficesbybranchlevel ( string branchid , string levelid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , branchid , str_ , levelid ) , offices . class ) ; }	This method dumps offices we keep track of according to branch and level.
public counties getcounties ( string stateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , stateid ) , counties . class ) ; }	Fetches counties in a state.
public cities getcities ( string stateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , stateid ) , cities . class ) ; }	Fetches cities in a state.
public localcandidatelist getofficials ( string localid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , localid ) , localcandidatelist . class ) ; }	Fetches officials for a locality.
public < t > t query ( string method , argmap argmap , class < t > responsetype ) throws votesmartexception , votesmarterrorexception { bufferedreader reader = null ; httpurlconnection conn = null ; string charset = str_ ; try { if ( iscaching ( method , argmap ) ) { file file = getcachefile ( method , argmap ) ; long filelength = file . length ( ) ; logger . fine ( str_ + filelength + str_ + file . getname ( ) ) ; if ( filelength == num_ ) { votesmart . cachefilefromapi ( method , argmap , file ) ; } reader = new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , charset ) ) ; } else { conn = votesmart . getconnectionfromapi ( method , argmap ) ; charset = getcharset ( conn ) ; reader = new bufferedreader ( new inputstreamreader ( conn . getinputstream ( ) , charset ) ) ; } jaxbelement < t > e = unmarshaller . unmarshal ( new streamsource ( reader ) , responsetype ) ; if ( e . getname ( ) . getlocalpart ( ) . equals ( str_ ) ) {	Queries the API server for the information requested.
public candidatelist getstatewide ( string stateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , stateid ) , candidatelist . class ) ; }	This method grabs a list of officials according to state representation.
public candidatelist getbyofficetypestate ( string officetypeid , string stateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , officetypeid , str_ , stateid ) , candidatelist . class ) ; }	This method grabs a list of officials according to office type and state representation.
public candidatelist getbyzip ( string zip5 ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , zip5 ) , candidatelist . class ) ; }	This method grabs a list of officials according to the zip code they represent.
public addlbio getaddlbio ( string candidateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , candidateid ) , addlbio . class ) ; }	This method grabs the extended bio for each candidate that has one.
public bio getbio ( string candidateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , candidateid ) , bio . class ) ; }	This method grabs the extended bio for each candidate that has one.It uses the updated version 'getDetailedBio' of the call.
public candidatelist getbylastname ( string lastname , string electionyear ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , lastname , str_ , electionyear ) , candidatelist . class ) ; }	This method grabs a list of candidates according to a lastname match.
public candidatelist getbyelection ( string electionid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , electionid ) , candidatelist . class ) ; }	This method grabs a list of candidates according to a fuzzy lastname match.
public candidatelist getbydistrict ( string districtid , string electionyear ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , districtid , str_ , electionyear ) , candidatelist . class ) ; }	This method grabs a list of candidates according to the district they represent.
public committees getcommitteesbytypestate ( string typeid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , typeid ) , committees . class ) ; }	Returns the list of committees that fit the criteria.
public committee getcommittee ( string committeeid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , committeeid ) , committee . class ) ; }	Returns detailed committee data.
public committeemembers getcommitteemembers ( string committeeid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , committeeid ) , committeemembers . class ) ; }	Returns members of the committee.
public leadership getpositions ( string stateid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , stateid ) , leadership . class ) ; }	Gets leadership positions by state and office.
public leaders getofficials ( string leadershipid ) throws votesmartexception , votesmarterrorexception { return api . query ( str_ , new argmap ( str_ , leadershipid ) , leaders . class ) ; }	Gets officials that hold the leadership role in certain states.
public static void sleep ( int ms ) { long deadline = system . currenttimemillis ( ) + ms ; while ( system . currenttimemillis ( ) < deadline ) { try { thread . sleep ( math . max ( num_ , ( deadline - system . currenttimemillis ( ) ) / num_ ) ) ; } catch ( interruptedexception ignore ) { } } }	Sleeps for the provided amount of milliseconds, ignoring threadinterrupts.
public void start ( ) { if ( timer != null ) throw new illegalstateexception ( str_ ) ; if ( interval < busy_waiting_threshold ) timer = new mybusytimer ( ) ; else if ( interval < millisecond_threshold ) timer = new mywaitingtimer ( ) ; else timer = new mymillisecondtimer ( ) ; thread thread = new thread ( timer , str_ ) ; thread . setdaemon ( bool_ ) ; thread . start ( ) ; }	Starts generating tick events, starting from 0.
public void waitfor ( ) throws throwable { while ( ! finished ) { try { synchronized ( this ) { this . wait ( num_ ) ; } } catch ( interruptedexception e ) { thread . currentthread ( ) . interrupt ( ) ; } } if ( t != null ) throw t ; }	Waits until the gobbler finished.
public void close ( ) { cancel = bool_ ; try { thread . interrupt ( ) ; waitfor ( ) ; } catch ( throwable ignore ) { } try { is . close ( ) ; } catch ( exception ignore ) { } try { os . close ( ) ; } catch ( exception ignore ) { } }	Interrupts the gobbler and closes its streams.
public static < k , v , m extends map < k , v > > m merge ( stream < ? extends map < k , v > > stream , binaryoperator < v > mergefunction , supplier < m > mapsupplier ) { assert . notnull ( stream , str_ ) ; assert . notnull ( mergefunction , str_ ) ; assert . notnull ( mapsupplier , str_ ) ; return stream . collect ( mapsupplier , ( a , b ) -> b . foreach ( ( k , v ) -> a . merge ( k , v , mergefunction ) ) , map :: putall ) ; }	Merging single level aggregation maps.
public static < k , v > list < map < k , v > > split ( map < k , v > map , int limit ) { assert . notnull ( map , str_ ) ; assert . istrue ( limit > num_ , str_ ) ; if ( map . size ( ) <= limit ) { return collections . singletonlist ( map ) ;	Splits map to list of maps.
public static < k , v > map < k , v > sort ( map < k , v > map , comparator < map . entry < k , v > > comparator ) { assert . notnull ( map , str_ ) ; assert . notnull ( comparator , str_ ) ; list < map . entry < k , v > > list = new linkedlist < > ( map . entryset ( ) ) ; collections . sort ( list , comparator ) ; map < k , v > result = new linkedhashmap < > ( ) ; for ( map . entry < k , v > entry : list ) { result . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; } return result ; }	Sorts map with comparator.
public static < t > t firstvalue ( map < string , t > map ) { if ( map == null || map . size ( ) == num_ ) { return null ; } string firstkey = map . keyset ( ) . iterator ( ) . next ( ) ; return map . get ( firstkey ) ; }	Returns first value in map as given by the iterator or null if empty.
public static < t > void isnull ( t test , string message ) { istrue ( test == null , message ) ; }	Tests if object is null.
public static < t > void notnull ( t test , string message ) { isfalse ( test == null , message ) ; }	Tests if object is != null.
public static void notnulloremptytrimmed ( string value , string message ) { isfalse ( stringutils . isnulloremptytrimmed ( value ) , message ) ; }	Tests if String is null or empty when trimmed.
public static < t > void isnullorempty ( set < t > set , string message ) { istrue ( set == null || set . size ( ) == num_ , message ) ; }	Tests if set is null or empty.
public static < t > void isnullorempty ( t [ ] array , string message ) { istrue ( array == null || array . length == num_ , message ) ; }	Tests if array is null or empty.
@ deprecated public static string getresourceasstring ( string resourcefile , class clazz ) { assert . notnulloremptytrimmed ( resourcefile , str_ ) ; scanner scanner = null ; try { inputstream resource = clazz . getresourceasstream ( resourcefile ) ; scanner = new scanner ( resource , utf_8 ) ; return scanner . usedelimiter ( str_ ) . next ( ) ; } catch ( exception e ) { return null ; } finally { if ( scanner != null ) { scanner . close ( ) ; } } }	Loads class resource to String.
public static set < string > getresourcewords ( string resourcefile , class clazz ) { assert . notnulloremptytrimmed ( resourcefile , str_ ) ; scanner scanner = null ; try { inputstream resource = clazz . getresourceasstream ( resourcefile ) ; scanner = new scanner ( resource , utf_8 ) ; set < string > list = new linkedhashset < > ( ) ; while ( scanner . hasnext ( ) ) { string next = scanner . next ( ) ; if ( next != null && next . trim ( ) . length ( ) > num_ ) { list . add ( next ) ; } } return list ; } catch ( exception e ) { return null ; } finally { if ( scanner != null ) { scanner . close ( ) ; } } }	Loads resource as a set of Strings, where each word is added to the set.
@ deprecated public static long getlastmodifiedtime ( string resourcefile , class clazz ) { assert . notnulloremptytrimmed ( resourcefile , str_ ) ; try { url url = clazz . getresource ( resourcefile ) ; return url . openconnection ( ) . getlastmodified ( ) ;	Get resource last modified date.
public static string getstring ( final inputstream is , string encoding ) { if ( is == null ) { return null ; } if ( stringutils . isnulloremptytrimmed ( encoding ) ) { encoding = utf_8 ; } final char [ ] buffer = new char [ buffer_size ] ; final stringbuilder out = new stringbuilder ( ) ; try { try ( reader in = new inputstreamreader ( is , encoding ) ) { for ( ; ; ) { int rsz = in . read ( buffer , num_ , buffer . length ) ; if ( rsz < num_ ) { break ; } out . append ( buffer , num_ , rsz ) ; } } } catch ( ioexception ioe ) { throw new runtimeexception ( ioe ) ; } return out . tostring ( ) ; }	Load input stream into string.
public static byte [ ] getbytes ( inputstream is ) { if ( is == null ) { return null ; } bytearrayoutputstream buffer = new bytearrayoutputstream ( ) ; int nread ; byte [ ] data = new byte [ buffer_size ] ; try { while ( ( nread = is . read ( data , num_ , data . length ) ) != - num_ ) { buffer . write ( data , num_ , nread ) ; } buffer . flush ( ) ; } catch ( ioexception ignored ) { } return buffer . tobytearray ( ) ; }	Load input stream into byte array.
public static string readfiletostring ( file file ) throws ioexception { assert . istrue ( file . exists ( ) , str_ + file + str_ ) ; assert . isfalse ( file . isdirectory ( ) , str_ + file + str_ ) ; assert . istrue ( file . canread ( ) , str_ + file + str_ ) ; fileinputstream stream = new fileinputstream ( file ) ; return getstring ( stream ) ; }	Reads file into String.
@ deprecated public static string getresourceabsolutepath ( string resource , class clazz ) { assert . notnulloremptytrimmed ( resource , str_ ) ; url file = clazz . getresource ( resource ) ; assert . notnull ( file , str_ + resource + str_ ) ; return file . getfile ( ) ; }	Gets absolute file path of resource.
public static string generatestring ( int length ) { if ( length <= num_ || length > num_ ) { throw new illegalargumentexception ( str_ + length ) ; } securerandom random = new securerandom ( ) ; stringbuilder sb = new stringbuilder ( length ) ; for ( int i = num_ ; i < length ; i ++ ) { sb . append ( elements . charat ( random . nextint ( elements . length ( ) ) ) ) ; } return sb . tostring ( ) ; }	Generates random string from ELEMENTS set of chars and numbers.
public static long generatelong ( int length ) { if ( length <= num_ || length > num_ ) { throw new illegalargumentexception ( str_ + length ) ; } securerandom random = new securerandom ( ) ; stringbuilder sb = new stringbuilder ( length ) ;	Generates non negative long key of maximum length 18.
@ safevarargs public static < t > t [ ] join ( final t [ ] array1 , final t ... array2 ) { if ( isempty ( array1 ) && isempty ( array2 ) ) { return null ; } if ( isempty ( array1 ) ) { return array2 ; } if ( isempty ( array2 ) ) { return array1 ; } final class < ? > type1 = array1 . getclass ( ) . getcomponenttype ( ) ; @ suppresswarnings ( str_ )	joins two arrays and preserves array orderarray1 items are followed by array2 items as given.
public static < t > list < set < t > > split ( set < t > set , int maxsize ) { assert . notnull ( set , str_ ) ; assert . istrue ( maxsize > num_ , str_ ) ; if ( set . size ( ) < maxsize ) { return collections . singletonlist ( set ) ; } list < set < t > > list = new arraylist < > ( ) ; iterator < t > iterator = set . iterator ( ) ; while ( iterator . hasnext ( ) ) { set < t > newset = new hashset < > ( ) ; for ( int j = num_ ; j < maxsize && iterator . hasnext ( ) ; j ++ ) { t item = iterator . next ( ) ; newset . add ( item ) ; } list . add ( newset ) ; } return list ; }	Splits set in 1..N chunks of maxSize or less.
public static instant getmonthstart ( instant time ) { assert . notnull ( time , str_ ) ; localdatetime datetime = localdatetime . ofinstant ( time , zoneoffset . utc ) ; datetime = datetime . withdayofmonth ( num_ ) . withhour ( num_ ) . withminute ( num_ ) . withsecond ( num_ ) . with ( chronofield . milli_of_second , num_ ) ; return datetime . toinstant ( zoneoffset . utc ) ; }	Gets first millisecond of first day in month.
public static instant getmonthend ( instant time ) { assert . notnull ( time , str_ ) ; localdatetime datetime = localdatetime . ofinstant ( time , zoneoffset . utc ) ; datetime = datetime . withdayofmonth ( num_ ) . withhour ( num_ ) . withminute ( num_ ) . withsecond ( num_ ) . with ( chronofield . milli_of_second , num_ ) ; datetime = datetime . plus ( num_ , chronounit . months ) . minus ( num_ , chronounit . days ) ; return datetime . toinstant ( zoneoffset . utc ) ; }	Returns last millisecond of last day in month ..
public static string trimtonull ( string text ) { text = trim ( text ) ; if ( text == null || text . isempty ( ) ) { return null ; } return text ; }	Trims down text to null if empty.
public static string capitalize ( string input ) { if ( input == null ) { return null ; } if ( input . length ( ) > num_ ) { for ( int i = num_ ; i < input . length ( ) ; i ++ ) { if ( character . isalphabetic ( input . charat ( i ) ) ) { return input . substring ( num_ , i ) + character . tostring ( input . charat ( i ) ) . touppercase ( ) + input . substring ( i + num_ ) ; } } } return input . touppercase ( ) ; }	Capitalizes first character in given string.
public static string join ( object [ ] args , string separator ) { return join ( args , separator , null ) ; }	Joins array of objects into string, where items are separatedwith a defined separator.
public static string join ( set < ? > items , string separator ) { return join ( items , separator , null ) ; }	Joins set of items to a single string, where items are separatedwith a defined separator.
public static list < string > getwords ( string text ) { list < string > output = new arraylist < > ( ) ; if ( isnulloremptytrimmed ( text ) ) { return output ; } pattern p = pattern . compile ( str_ ) ; matcher m = p . matcher ( text ) ; while ( m . find ( ) ) { output . add ( m . group ( ) ) ; } return output ; }	Extracts words from text removing non alpha characters.
public static string trimtextdown ( string text , int size ) { if ( text == null || text . length ( ) <= size ) { return text ; } int pos = text . lastindexof ( str_ , size ) ; if ( pos < num_ ) { return text . substring ( num_ , size ) ; } return text . substring ( num_ , pos ) ; }	Reduces text to max given size preserving words.
public static string trimtextdown ( string text , int sizeminusappend , string append ) { assert . notnull ( append , str_ ) ; if ( text == null || text . length ( ) <= sizeminusappend ) { return text ; } sizeminusappend = sizeminusappend - append . length ( ) ; int pos = text . lastindexof ( str_ , sizeminusappend ) ; if ( pos < num_ ) { return text . substring ( num_ , sizeminusappend ) + append ; } return text . substring ( num_ , pos ) + append ; }	Reduces text size to a given size.
public static list < string > aslistofchars ( string text ) { list < string > list = new arraylist < > ( ) ; if ( stringutils . isnulloremptytrimmed ( text ) ) { return list ; } for ( int i = num_ ; i < text . length ( ) ; i ++ ) { list . add ( character . tostring ( text . charat ( i ) ) ) ; } return list ; }	Converts text to list of characters.
public static int relevance ( string value , string search ) { if ( stringutils . isnulloremptytrimmed ( value ) || stringutils . isnulloremptytrimmed ( search ) ) { return - num_ ; } if ( search . length ( ) > value . length ( ) ) { return - num_ ; } int relevance = - num_ ;	Calculates matching relevance between given string and search expression.
public static string unquote ( string text ) { if ( isnulloremptytrimmed ( text ) ) { return text ; } if ( ( text . startswith ( str_ ) && text . endswith ( str_ ) ) || ( text . startswith ( str_ ) && text . endswith ( str_ ) ) ) { return text . substring ( num_ , text . length ( ) - num_ ) ; } return text ; }	Removes double or single quotes if any are present.
public static long gettimezonetime ( long time , int timezone ) { calendar calendar = getcalendar ( time ) ; int hour = calendar . get ( calendar . hour_of_day ) ; hour = ( hour + timezone ) % num_ ; if ( hour < num_ ) { hour = num_ + hour ; calendar . add ( calendar . day_of_month , - num_ ) ; } calendar . set ( calendar . hour_of_day , hour ) ; return calendar . gettimeinmillis ( ) ; }	Returns time for given time zone.
public list < integer > hastag ( final integer tagid ) { final list < integer > retvalue = new arraylist < integer > ( ) ; for ( final filtertag tag : getfiltertags ( ) ) { if ( tag . gettag ( ) . gettagid ( ) . equals ( tagid ) ) retvalue . add ( tag . gettagstate ( ) ) ; } return retvalue ; }	Loops through the FilterTags held by this Filter, and returns the state of the tag if it exists, and -1 if it does not.
private boolean isviolation ( string severity ) { if ( str_ . equals ( severity ) ) { return str_ . equals ( violationseverity ) || str_ . equals ( violationseverity ) || str_ . equals ( violationseverity ) ; } else if ( str_ . equals ( severity ) ) { return str_ . equals ( violationseverity ) || str_ . equals ( violationseverity ) ; } else if ( str_ . equals ( severity ) ) { return str_ . equals ( violationseverity ) ; } else { return bool_ ; } }	Checks if the given severity is considered a violation.
public void iconseverity ( string level ) { sink . figure ( ) ; sink . figuregraphics ( str_ + level + str_ ) ; sink . figure_ ( ) ; }	Render a simple icon of given level.
public void iconseverity ( string level , int texttype ) { sink . figure ( ) ; sink . figuregraphics ( str_ + level + str_ ) ; sink . figure_ ( ) ; if ( texttype > num_ ) { sink . nonbreakingspace ( ) ; sink . text ( bundle . getstring ( str_ + level + suffix ( texttype ) ) ) ; } }	Render an icon of given level with associated text.
@ transient public string gettagslist ( final boolean brlinebreak ) {	Generates a HTML formatted and categorized list of the tags that are associated with this topic.
@ transient public void setnextandclean ( csnode next ) { setnextinternal ( next ) ; if ( next != null ) { next . setpreviousinternal ( this ) ; } }	Sets the Next Node and cleans up any old references.
@ transient public void setpreviousandclean ( csnode previous ) { setpreviousinternal ( previous ) ; if ( previous != null ) { previous . setnextinternal ( this ) ; } }	Sets the Previous Node and cleans up any old references.
public node find ( string host , int port ) { return sockettonodemap . get ( utils . tokey ( host , port ) ) ; }	Finds the node by host and port.
public set < node > find ( string host ) { set < node > resultset = new hashset < node > ( ) ; if ( host != null ) { for ( node node : sockettonodemap . values ( ) ) { if ( host . equals ( node . gethost ( ) ) ) { resultset . add ( node ) ; } } } return resultset ; }	Finds the set of nodes by host.
public set < node > getallnotdead ( ) { set < node > allnotdeadnodesset = new hashset < node > ( ) ; for ( node node : sockettonodemap . values ( ) ) { if ( ! nodestatus . dead . equals ( node . getstatus ( ) ) ) { allnotdeadnodesset . add ( node ) ; } } return allnotdeadnodesset ; }	Gets all the nodes not in status DEAD.
public void add ( node node ) { sockettonodemap . put ( utils . tokey ( node ) , node ) ; sendevent ( node , nodeeventtype . added ) ; }	Adds one more node to the container.
public void remove ( node node ) { sockettonodemap . remove ( utils . tokey ( node ) ) ; sendevent ( node , nodeeventtype . removed ) ; }	Removes the specified node.
public void markasalive ( node node ) { if ( ! nodestatus . alive . equals ( node . getstatus ( ) ) ) { sockettonodemap . get ( utils . tokey ( node ) ) . markasalive ( ) ; sendevent ( node , nodeeventtype . marked_as_alive ) ; } }	Marks the node as ALIVE in case of its status is not ALIVE.
public void markasdead ( node node ) { if ( ! nodestatus . dead . equals ( node . getstatus ( ) ) ) { sockettonodemap . get ( utils . tokey ( node ) ) . markasdead ( ) ; sendevent ( node , nodeeventtype . marked_as_dead ) ; } }	Marks the node as DEAD in case of its status is not DEAD.
private void sendevent ( node node , nodeeventtype type ) { nodeevent event = new nodeevent ( node , type ) ; for ( nodeeventhandler handler : handlers ) { handler . handle ( event ) ; } }	Sends the event to all the handlers.
private string getcheckstyleversion ( ) { package checkstyleapipackage = configuration . class . getpackage ( ) ; return ( checkstyleapipackage == null ) ? null : checkstyleapipackage . getimplementationversion ( ) ; }	Get the effective Checkstyle version at runtime.
private void configureresourcelocator ( final resourcemanager resourcemanager , final checkstyleexecutorrequest request , final list < artifact > additionalartifacts ) { final mavenproject project = request . getproject ( ) ; resourcemanager . setoutputdirectory ( new file ( project . getbuild ( ) . getdirectory ( ) ) ) ;	Configures search paths in the resource locator.This method should only be called once per execution.
private map < string , object > createobjectpropertyvalues ( map < string , object > defaultpropertyvalues , list < object > attributes ) { map < string , object > propertyvalues = new hashmap < string , object > ( defaultpropertyvalues ) ; if ( attributes != null ) { iterator < object > iterator = attributes . iterator ( ) ; map < string , object > propertyoverridemap = new hashmap < string , object > ( ) ; while ( iterator . hasnext ( ) ) { string name = ( string ) iterator . next ( ) ;	Merge passed attributes with the supplied property values.
private int currentsequence ( string name ) { map < string , integer > sequencesforclass = sequences . get ( getclass ( ) ) ; if ( sequencesforclass == null ) { sequencesforclass = new hashmap < string , integer > ( ) ; sequences . put ( getclass ( ) , sequencesforclass ) ; } integer seq = sequencesforclass . get ( name ) ; seq = seq == null ? num_ : seq + num_ ; sequencesforclass . put ( name , seq ) ; return seq ; }	Retrieve the current sequence value for the given property.
@ override public int compareto ( final nodeid that ) {	Compares the supplied NodeID to this one.
public list < nodeevent > getandcleareventslist ( ) { arraylist < nodeevent > result = new arraylist < nodeevent > ( eventslist ) ; eventslist . clear ( ) ; return result ; }	Gets the copy of the buffer and clears the buffer.
public sortedset < packagedoc > findpackagesfromclassesinjavadocrun ( ) { final sortedset < packagedoc > toreturn = new treeset < > ( comparators . package_name_comparator ) ; final classdoc [ ] currentexecutionclasses = classes ( ) ; if ( currentexecutionclasses != null ) { arrays . stream ( currentexecutionclasses ) . map ( programelementdoc :: containingpackage ) . foreach ( toreturn :: add ) ; }	Finds all PackageDoc objects from the classes in this JavaDoc execution.
public static boolean setproperty ( object target , string name , object value ) { try { for ( propertydescriptor pd : introspector . getbeaninfo ( target . getclass ( ) ) . getpropertydescriptors ( ) ) { if ( pd . getwritemethod ( ) != null && pd . getname ( ) . equals ( name ) ) { pd . getwritemethod ( ) . invoke ( target , value ) ; return bool_ ; } } } catch ( exception e ) { throw new runtimeexception ( e ) ; } return bool_ ; }	Set the property identified by name to the provided value.
public static boolean setfield ( object target , string name , object value ) { try { field field = target . getclass ( ) . getdeclaredfield ( name ) ; field . setaccessible ( bool_ ) ; field . set ( target , value ) ; return bool_ ; } catch ( nosuchfieldexception e ) { return bool_ ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Set the field identified by name to the given value.
public static list < method > getannotatedmethods ( class targetclass , class < ? extends annotation > annotationtype ) { list < method > annotatedmethods = new arraylist < method > ( ) ; for ( method method : targetclass . getdeclaredmethods ( ) ) { if ( method . isannotationpresent ( annotationtype ) ) { annotatedmethods . add ( method ) ; } } return annotatedmethods ; }	Get all methods on the given class that are annotated with the given annotation type.
public static void invokemethod ( object target , method method , object ... arguments ) { method . setaccessible ( bool_ ) ;	Invoke the given method on the given target using the given arguments.Allows to call private and protected methods.
public static void main ( string [ ] args ) throws exception { if ( args . length > num_ ) { loadclasses ( args [ num_ ] ) ; } startcacheserver ( ) ; consoleutils . waitforenter ( javaprocesslauncher . process_startup_completed ) ; stopcacheserver ( ) ; }	Server entry point.
private string getconfigattribute ( configuration config , chaineditem < configuration > parentconfiguration , string attributename , string defaultvalue ) { string ret ; try { ret = config . getattribute ( attributename ) ; } catch ( checkstyleexception e ) {	Get the value of the specified attribute from the Checkstyle configuration.If parentConfigurations is non-null and non-empty, the parentconfigurations are searched if the attribute cannot be found in thecurrent configuration.
private void dorulessummary ( checkstyleresults results ) { if ( checkstyleconfig == null ) { return ; } sink . section1 ( ) ; sink . sectiontitle1 ( ) ; sink . text ( bundle . getstring ( str_ ) ) ; sink . sectiontitle1_ ( ) ; sink . table ( ) ; sink . tablerow ( ) ; sink . tableheadercell ( ) ; sink . text ( bundle . getstring ( str_ ) ) ; sink . tableheadercell_ ( ) ; sink . tableheadercell ( ) ; sink . text ( bundle . getstring ( str_ ) ) ; sink . tableheadercell_ ( ) ; sink . tableheadercell ( ) ; sink . text ( bundle . getstring ( str_ ) ) ; sink . tableheadercell_ ( ) ; sink . tableheadercell ( ) ; sink . text ( bundle . getstring ( str_ ) ) ; sink . tableheadercell_ ( ) ; sink . tablerow_ ( ) ;	Create the rules summary section of the report.
public boolean matchrule ( auditevent event , string rulename , string expectedmessage , string expectedseverity ) { if ( ! rulename . equals ( ruleutil . getname ( event ) ) ) { return bool_ ; }	Check if a violation matches a rule.
private string createreceivedatkey ( string fromclustername , string toclustername ) { return key_prefix + fromclustername + str_ + toclustername + key_postfix_duration ; }	Creates the receivedAt key.
private void waitforstarted ( ) { debug ( str_ ) ; while ( bool_ ) { boolean othersstarted = bool_ ; for ( object key : clustersproperties . keyset ( ) ) { string clustername = ( string ) key ; long startedat = region . get ( createstartedatkey ( clustername ) ) ; debug ( str_ + startedat + str_ + processingstartedat ) ; if ( ( startedat == null ) || ( startedat . longvalue ( ) < processingstartedat ) ) { othersstarted = bool_ ; break ; } } if ( othersstarted ) { break ; } try { timeunit . milliseconds . sleep ( check_period ) ; } catch ( interruptedexception e ) { } } debug ( str_ ) ; }	Wait until the other clients started.
private void waitforsent ( ) { debug ( str_ ) ; while ( bool_ ) { boolean otherssent = bool_ ; map < string , long > clusternametoreceivedatmap = new hashmap < string , long > ( ) ; for ( object key : clustersproperties . keyset ( ) ) { string clustername = ( string ) key ; if ( localclustername . equals ( clustername ) ) { continue ; } long sentat = region . get ( createsentatkey ( clustername ) ) ; long receivedat = system . currenttimemillis ( ) ; if ( ( sentat != null ) && ( sentat . longvalue ( ) > processingstartedat ) ) { clusternametoreceivedatmap . put ( clustername , receivedat ) ; } } for ( object key : clustersproperties . keyset ( ) ) { string clustername = ( string ) key ; if ( localclustername . equals ( clustername ) ) { continue ; } long receivedat = clusternametoreceivedatmap . get ( clustername ) ; if ( receivedat == null ) { if ( otherssent ) { otherssent = bool_ ; } } else { region . put ( createreceivedatkey ( clustername , localclustername ) , receivedat ) ; } } if ( otherssent ) { break ; } try { timeunit . milliseconds . sleep ( check_period ) ; } catch ( interruptedexception e ) { } } debug ( str_ ) ; }	Wait until received all the entries from other clients.
private void waitforconnected ( ) { debug ( str_ ) ; while ( bool_ ) { boolean connected = bool_ ; for ( object fromkey : clustersproperties . keyset ( ) ) { string fromclustername = ( string ) fromkey ; for ( object tokey : clustersproperties . keyset ( ) ) { string toclustername = ( string ) tokey ; if ( fromclustername . equals ( toclustername ) ) { continue ; } long receivedat = region . get ( createreceivedatkey ( fromclustername , toclustername ) ) ; if ( receivedat == null ) { connected = bool_ ; break ; } } } if ( connected ) { break ; } try { timeunit . milliseconds . sleep ( check_period ) ; } catch ( interruptedexception e ) { } } debug ( str_ ) ; }	Wait until all the clients received all the receivedAt entries.
public boolean waitfor ( long timeout ) { debug ( str_ + timeout ) ; processingtask connectionchecktask = new processingtask ( ) ; utils . execute ( connectionchecktask , timeout ) ; boolean connected = connectionchecktask . isconnected ( ) ; debug ( str_ + connected ) ; return connected ; }	Waits for processing finished.
public void close ( ) { try { debug ( str_ ) ; clientcache . close ( ) ; debug ( str_ + clientcache . isclosed ( ) ) ; } catch ( throwable t ) { debug ( str_ + t . getmessage ( ) , t ) ; } }	Finalizes work with the guest node.
public void printstate ( boolean connected ) { if ( ! quiet ) { stringbuilder sb = new stringbuilder ( ) ; if ( connected ) { sb . append ( localclustername ) . append ( str_ ) ; iterator < object > it = clustersproperties . keyset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { string clustername = ( string ) it . next ( ) ; if ( localclustername . equals ( clustername ) ) { continue ; } long sentat = region . get ( createsentatkey ( clustername ) ) ; long receivedat = region . get ( createreceivedatkey ( clustername , localclustername ) ) ; long duration = receivedat - sentat ; sb . append ( str_ ) . append ( clustername ) . append ( str_ ) . append ( duration ) . append ( str_ ) ; } } else { sb . append ( str_ ) . append ( localclustername ) ; } system . out . println ( sb . tostring ( ) ) ; } }	Prints the current state of connections.
public static void main ( string [ ] args ) { try { if ( args . length != num_ ) { utils . exitwithfailure ( ) ; } string cluster = args [ num_ ] ; properties clustersproperties = propertieshelper . stringtoproperties ( args [ num_ ] ) ; long timeout = long . parselong ( args [ num_ ] ) ; string regionname = args [ num_ ] ; boolean debugenabled = ( str_ . equals ( args [ num_ ] ) ? bool_ : bool_ ) ; boolean quiet = ( str_ . equals ( args [ num_ ] ) ? bool_ : bool_ ) ; long processingstartedat = long . parselong ( args [ num_ ] ) ; guestnode guestnode = new guestnode ( cluster , clustersproperties , regionname , debugenabled , quiet , processingstartedat ) ; boolean connected = guestnode . waitfor ( timeout ) ; guestnode . printstate ( connected ) ; guestnode . close ( ) ; if ( connected ) { utils . exitwithsuccess ( ) ; } utils . exitwithfailure ( ) ; } catch ( throwable t ) { utils . exitwithfailure ( ) ; } }	Configures and starts the guest node.
public list < xproperty > getorderedproperties ( ) { final list < xproperty > result = introspector . getproperties ( clazz ) ; collections . sort ( result , new xproperty . naturalorder ( ) ) ; return result ; }	Returns properties in "natural" order, i.e.
public short getversionmodelhashcode ( int version ) { list < xproperty > classfields = getorderedproperties ( ) ; stringbuilder builder = new stringbuilder ( ) ; for ( xproperty field : classfields ) { if ( version == - num_ || version >= field . getpropertyversion ( ) ) { builder . append ( field . gettype ( ) ) . append ( field . getname ( ) ) ; } } int hashcode = builder . tostring ( ) . hashcode ( ) ; return ( short ) ( ( hashcode & num_ ) ^ ( ( hashcode & num_ ) > > num_ ) ) ; }	Returns a hash code of class model for specified bean version based on fields that this model contains.
public int gettotalnumberofpages ( ) throws queryexception { prepareresultdata ( bool_ ) ; if ( isempty ( ) ) { return num_ ; } int total = totalnumberofentries / this . pagesize ; if ( totalnumberofentries % this . pagesize > num_ ) { total += num_ ; } return total ; }	Returns a total number of query pages.
@ suppresswarnings ( str_ ) private list < v > getvalues ( list < object > entrieskeysforpage ) { if ( entrieskeysforpage . isempty ( ) ) { return collections . emptylist ( ) ; } map < object , v > entriesmap = queryregion . getall ( entrieskeysforpage ) ; list < v > entries = new arraylist < v > ( entrieskeysforpage . size ( ) ) ; for ( object key : entrieskeysforpage ) { entries . add ( entriesmap . get ( key ) ) ; } return entries ; }	Returns values for given keys.
@ suppresswarnings ( { str_ } ) private void prepareresultdata ( boolean force ) throws queryexception { if ( this . infoloaded && ! force ) { return ; } pagekey pagekey = newkey ( page_number_for_general_info ) ; list < object > queryinfo = null ; if ( ! force ) { queryinfo = paginatedqueryinforegion . get ( pagekey ) ; } if ( queryinfo == null ) { query query = queryservice . newquery ( this . querystring ) ; selectresults < object > results = null ; try { results = ( selectresults < object > ) query . execute ( pagekey . getqueryparameters ( ) ) ; } catch ( functiondomainexception e ) { handleexception ( e ) ; } catch ( typemismatchexception e ) { handleexception ( e ) ; } catch ( nameresolutionexception e ) { handleexception ( e ) ; } catch ( queryinvocationtargetexception e ) { handleexception ( e ) ; } if ( results . size ( ) > querylimit ) { this . limitexceeded = bool_ ; this . totalnumberofentries = querylimit ; string msg = str_ + querylimit + str_ ; logger . warn ( msg ) ; } else { limitexceeded = bool_ ; this . totalnumberofentries = results . size ( ) ; } queryinfo = arrays . aslist ( new object [ ] { results . size ( ) , limitexceeded } ) ; storepage ( page_number_for_general_info , queryinfo ) ; list < object > keys = extractkeys ( results ) ; storeresults ( keys ) ; } else { this . totalnumberofentries = ( integer ) queryinfo . get ( num_ ) ; this . limitexceeded = ( boolean ) queryinfo . get ( num_ ) ; } this . infoloaded = bool_ ; }	Stores paginated query info if it has not been stored yet.
private void storeresults ( list < object > resultkeys ) { if ( resultkeys . size ( ) > querylimit ) { resultkeys = resultkeys . sublist ( num_ , querylimit ) ; } int keynumber = num_ ; int pagenumber = num_ ; list < object > page = new arraylist < object > ( ) ; for ( object key : resultkeys ) { if ( keynumber % getpagesize ( ) == num_ && keynumber != num_ ) { storepage ( ++ pagenumber , page ) ; page . clear ( ) ; } page . add ( key ) ; keynumber ++ ; } if ( page . size ( ) > num_ || pagenumber == num_ ) { storepage ( ++ pagenumber , page ) ; } }	Stores paginated query pages and general info.
public t create ( object ... attributes ) {	Create an object with the given attributes.First builds the object, than persists it.
@ override public int compare ( final tagtocategory o1 , final tagtocategory o2 ) { if ( o1 == null && o2 == null ) return num_ ; if ( o1 == null ) return lessthan ; if ( o2 == null ) return greaterthan ; if ( o1 . getsorting ( ) == null && o2 . getsorting ( ) == null ) return comparesecondlevel ( o1 , o2 ) ; if ( o1 . getsorting ( ) == null ) return greaterthan ; if ( o2 . getsorting ( ) == null ) return lessthan ; if ( o1 . getsorting ( ) . equals ( o2 . getsorting ( ) ) ) return comparesecondlevel ( o1 , o2 ) ; return o1 . getsorting ( ) . compareto ( o2 . getsorting ( ) ) * greaterthan ; }	Sorting order is preferentially used to sort TagToCategory's, or the name of the Tag thatthe TagToCategory's point to are used if both TagToCategory's sorting orders are null.
private void migratebrokenlocales ( final preparedstatement preparedstmt , final map < string , integer > localemap ) throws sqlexception { final integer enuslocaleid = localemap . get ( str_ ) ; if ( enuslocaleid != null && enuslocaleid > num_ ) { migratebrokenlocale ( preparedstmt , localemap , str_ , enuslocaleid ) ; migratebrokenlocale ( preparedstmt , localemap , str_ , enuslocaleid ) ; migratebrokenlocale ( preparedstmt , localemap , str_ , enuslocaleid ) ; migratebrokenlocale ( preparedstmt , localemap , str_ , enuslocaleid ) ; } }	Migrates locales from a very early version of PressGang that was using the wrong locale value.
public static boolean recalculateminhash ( final topic topic , final list < minhashxor > minhashxors ) { boolean retvalue = bool_ ; final set < minhash > existingminhashes = topic . getminhashes ( ) ; final map < integer , integer > minhashes = getminhashes ( topic . gettopicxml ( ) , minhashxors ) ; for ( final integer funcid : minhashes . keyset ( ) ) { boolean found = bool_ ; for ( final minhash minhash : existingminhashes ) { if ( minhash . getminhashfuncid ( ) . equals ( funcid ) ) { if ( ! minhash . getminhash ( ) . equals ( minhashes . get ( funcid ) ) ) { minhash . setminhash ( minhashes . get ( funcid ) ) ; retvalue = bool_ ; } found = bool_ ; break ; } } if ( ! found ) { retvalue = bool_ ; final minhash minhash = new minhash ( ) ; minhash . setminhashfuncid ( funcid ) ; minhash . setminhash ( minhashes . get ( funcid ) ) ; topic . addminhash ( minhash ) ; } } return retvalue ; }	Recalculate the min hash signature for a topic.
public static map < integer , integer > getminhashes ( final string xml , final list < minhashxor > minhashxors ) { final map < integer , integer > retvalue = new hashmap < integer , integer > ( ) ;	Generate the min hashes.
protected static string cleanxmlforminhash ( final string xml ) {	Cleans the provided XML by removing element names and other useless data.
public static void validateandfixrelationships ( final topic topic ) { final arraylist < topictotopic > removelist = new arraylist < topictotopic > ( ) ; for ( final topictotopic topictotopic : topic . getparenttopictotopics ( ) ) if ( topictotopic . getrelatedtopic ( ) . gettopicid ( ) . equals ( topic . gettopicid ( ) ) ) removelist . add ( topictotopic ) ; for ( final topictotopic topictotopic : removelist ) topic . getparenttopictotopics ( ) . remove ( topictotopic ) ; final arraylist < topictotopic > removechildlist = new arraylist < topictotopic > ( ) ; for ( final topictotopic topictotopic : topic . getchildtopictotopics ( ) ) if ( topictotopic . getmaintopic ( ) . gettopicid ( ) . equals ( topic . gettopicid ( ) ) ) removechildlist . add ( topictotopic ) ; for ( final topictotopic topictotopic : removechildlist ) topic . getchildtopictotopics ( ) . remove ( topictotopic ) ; }	Validate and Fix a topics relationships to ensure that the topics related topics are still matched by the Related Topicsthemselves.
public static void updatecontenthash ( final topic topic ) { if ( topic . gettopicxml ( ) != null ) { topic . settopiccontenthash ( hashutilities . generatesha256 ( topic . gettopicxml ( ) ) . tochararray ( ) ) ; } }	Set the content hash on the topic.
public static void validateandfixtags ( final topic topic ) {	Validate and Fix a topics tags so that mutually exclusive tags are enforced and also remove any tags that may have beenduplicated.
public static sortedmap < packagedoc , sortedset < classdoc > > sortclassesperpackage ( final classdoc ... classdocs ) { final sortedmap < packagedoc , sortedset < classdoc > > toreturn = new treemap < > ( comparators . package_name_comparator ) ; if ( classdocs != null ) { arrays . stream ( classdocs ) . foreach ( current -> {	Sorts all given ClassDocs into a SortedMap keyed by their respective PackageDocs.
@ override @ suppresswarnings ( str_ ) public final void execute ( final enforcerrulehelper helper ) throws enforcerruleexception { final mavenproject project ; try { project = ( mavenproject ) helper . evaluate ( str_ ) ; } catch ( final expressionevaluationexception e ) {	This is the interface into the rule.
protected static list < string > splice ( final string tosplice ) { final list < string > toreturn = new arraylist < string > ( ) ; final stringtokenizer tok = new stringtokenizer ( tosplice , str_ , bool_ ) ; while ( tok . hasmoretokens ( ) ) { toreturn . add ( tok . nexttoken ( ) ) ; } return toreturn ; }	Helper method which splices the provided string into a List, separating on commas.
protected static list < pattern > splice2pattern ( final string tosplice ) throws patternsyntaxexception { final list < pattern > toreturn = new arraylist < pattern > ( ) ; for ( final string current : splice ( tosplice ) ) { toreturn . add ( pattern . compile ( current ) ) ; } return toreturn ; }	Helper method which splices the provided String into a List of Pattern instances.
protected static boolean containsprefix ( final list < string > source , final string tocheck ) { if ( source != null ) { for ( final string current : source ) { if ( tocheck . startswith ( current ) ) { return bool_ ; } } }	Checks if any element within source startsWith the provided toCheck string.
private static class < ? extends objectfactory > getfactoryclass ( class < ? > factoryclass ) { if ( factorypackages . size ( ) == num_ ) throw new illegalargumentexception ( str_ ) ; if ( factoryclasses == null ) { factoryclasses = new hashmap < class < ? > , class < ? extends objectfactory > > ( ) ; set < class < ? extends objectfactory > > classes = reflectionutils . getsubclassesof ( objectfactory . class , factorypackages ) ; for ( class < ? extends objectfactory > clazz : classes ) { if ( ! modifier . isabstract ( clazz . getmodifiers ( ) ) ) { try { constructor constructor = clazz . getconstructor ( ) ; objectfactory factory = ( objectfactory ) constructor . newinstance ( ) ; factoryclasses . put ( factory . getfactoryclass ( ) , factory . getclass ( ) ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ;	Get the class of the Factory for the given factoryClass.
public void send ( string subject , string content ) throws messagingexception { mimemessage message = compose ( subject , content , propertieshelper . getstringproperty ( str_ ) ) ; transport ( message ) ; }	Sends email with subject and content to receivers specified in property file after key "mail.to".
public void send ( string subject , string content , string to ) throws messagingexception { mimemessage message = compose ( subject , content , to ) ; transport ( message ) ; }	Sends email with subject and content to receivers specified by argument "to".
private int executezerofunction ( pool pool ) throws functionexception , interruptedexception { int result = - num_ ; resultcollector < ? , ? > collector = functionservice . onserver ( pool ) . execute ( new zerofunction ( ) ) ; list < ? > functionresult = ( list < ? > ) collector . getresult ( ) ; if ( ( functionresult != null ) && ( functionresult . size ( ) == num_ ) && ( functionresult . get ( num_ ) instanceof integer ) ) { result = ( integer ) functionresult . get ( num_ ) ; } return result ; }	Executes the "zero" function using pool for the concrete server.
@ override @ suppresswarnings ( { str_ , str_ } ) public void execute ( functioncontext functioncontext ) { resultsender < serializable > resultsender = functioncontext . getresultsender ( ) ; regionfunctioncontext regionfunctioncontext = ( regionfunctioncontext ) functioncontext ; if ( functioncontext . getarguments ( ) == null ) { handleexception ( new functionexception ( str_ ) , resultsender , null ) ; return ; } if ( ! ( functioncontext . getarguments ( ) instanceof bucketorientedqueryfunctionargument ) ) { handleexception ( new functionexception ( str_ + bucketorientedqueryfunctionargument . class . getname ( ) + str_ ) , resultsender , null ) ; return ; } bucketorientedqueryfunctionargument argument = ( bucketorientedqueryfunctionargument ) functioncontext . getarguments ( ) ; localdataset localdata = ( localdataset ) partitionregionhelper . getlocaldataforcontext ( regionfunctioncontext ) ; queryservice queryservice = localdata . getcache ( ) . getqueryservice ( ) ; string querystr = argument . getquerystring ( ) ; try { query query = queryservice . newquery ( querystr ) ; selectresults < ? > result = ( selectresults < ? > ) localdata . executequery ( ( defaultquery ) query , argument . getqueryparameters ( ) , localdata . getbucketset ( ) ) ; resultsender . lastresult ( ( serializable ) formatresults ( result ) ) ; } catch ( exception e ) { handleexception ( e , resultsender , querystr ) ; } }	Executes query using arguments query string and query parameters.
@ suppresswarnings ( { str_ } ) private void handleexception ( throwable e , resultsender < serializable > resultsender , string querystring ) { logger . error ( str_ + ( querystring != null ? str_ + querystring : str_ ) , e ) ; resultsender . sendexception ( new functionexception ( e . getmessage ( ) ) ) ; }	Handles exceptions during query execution.
private list < object > formatresults ( selectresults < ? > selectresults ) { list < object > results = new arraylist < object > ( selectresults . size ( ) + num_ ) ; results . addall ( selectresults . aslist ( ) ) ; results . add ( selectresults . getcollectiontype ( ) . getelementtype ( ) ) ; return results ; }	Formats results of query execution.
@ override public final void adderrormessage ( final string message ) { if ( message == null || str_ . equals ( message ) ) { return ; }	Adds the provided error message to this ErrorMessageContainer.
@ override public string getmessage ( ) { final stringbuilder builder = new stringbuilder ( ) ; for ( final string current : errormessages ) { builder . append ( current ) . append ( str_ ) ; }	Returns the detail message string of this throwable.
public static boolean issocketalive ( string host , int port ) { boolean socketalive = bool_ ; socket socket = null ; try { socket = new socket ( host , port ) ; socketalive = socket . isconnected ( ) ; } catch ( throwable t ) {	Checks if the socket of specified host and port is alive.
public static void execute ( thread thread , long timeout ) { thread . start ( ) ; try { thread . join ( timeout ) ; } catch ( interruptedexception e ) {	Executes the thread with specified timeout.
private boolean hasresources ( list < resource > resources ) { for ( resource resource : resources ) { if ( new file ( resource . getdirectory ( ) ) . exists ( ) ) { return bool_ ; } } return bool_ ; }	Check if any of the resources exist.
private void mergedeprecatedinfo ( ) throws mavenreportexception { if ( str_ . equals ( configlocation ) && ! str_ . equals ( format ) ) { configlocation = format_to_config_location . get ( format ) ; throw new mavenreportexception ( str_ + configlocation + str_ ) ; } if ( stringutils . isempty ( propertieslocation ) ) { if ( propertiesfile != null ) { propertieslocation = propertiesfile . getpath ( ) ; throw new mavenreportexception ( str_ + str_ + propertieslocation + str_ ) ; } else if ( propertiesurl != null ) { propertieslocation = propertiesurl . toexternalform ( ) ; throw new mavenreportexception ( str_ + str_ + propertieslocation + str_ ) ; } } if ( str_ . equals ( headerlocation ) ) { file defaultheaderfile = new file ( project . getbasedir ( ) , str_ ) ; if ( ! defaultheaderfile . equals ( headerfile ) ) { headerlocation = headerfile . getpath ( ) ; } } if ( stringutils . isempty ( suppressionslocation ) ) { suppressionslocation = suppressionsfile ; if ( stringutils . isnotempty ( suppressionsfile ) ) { throw new mavenreportexception ( str_ + str_ + suppressionslocation + str_ ) ; } } if ( stringutils . isempty ( packagenameslocation ) ) { packagenameslocation = packagenamesfile ; if ( stringutils . isnotempty ( packagenamesfile ) ) { throw new mavenreportexception ( str_ + str_ + suppressionslocation + str_ ) ; } } }	Merge in the deprecated parameters to the new ones, unless the newparameters have values.
public static string addquerylimit ( string querystring , int querylimit ) { int limitindex = querystring . lastindexof ( str_ ) ; if ( limitindex == - num_ ) { limitindex = querystring . lastindexof ( str_ ) ; } if ( limitindex == - num_ ) { return querystring + str_ + ( querylimit + num_ ) ; } int limitnumber = integer . parseint ( querystring . substring ( limitindex + num_ ) . trim ( ) ) ; return ( limitnumber > querylimit ) ? querystring . substring ( num_ , limitindex ) + str_ + ( querylimit + num_ ) : querystring ; }	Limits query results.
public static string [ ] getfirstlocatorfromlocatorsstring ( string locatorsstring ) { if ( locatorsstring == null || locatorsstring . length ( ) == num_ ) { return new string [ num_ ] ; } string [ ] firstlocator = new string [ num_ ] ; firstlocator [ num_ ] = locatorsstring . substring ( num_ , locatorsstring . indexof ( str_ ) ) . trim ( ) ; locatorsstring = locatorsstring . substring ( locatorsstring . indexof ( str_ ) + num_ ) ; firstlocator [ num_ ] = locatorsstring . substring ( num_ , locatorsstring . indexof ( str_ ) ) ; return firstlocator ; }	Returns first locator host and port from locators string.
public static int getregionsize ( region < ? , ? > region ) { function function = new regionsizefunction ( ) ; functionservice . registerfunction ( function ) ; resultcollector < ? , ? > rc = functionservice . onregion ( region ) . withcollector ( new regionsizeresultcollector ( ) ) . execute ( function ) ; return ( integer ) rc . getresult ( ) ; }	Returns approximate number of entries in the region.
public static boolean isgemfireclient ( ) { gemfirecacheimpl impl = ( gemfirecacheimpl ) cachefactory . getanyinstance ( ) ; return impl != null && impl . isclient ( ) ; }	Checks if the current GemFire is a client instance.
public static < k > void removeall ( region < k , ? > region , set < k > keys ) { if ( keys == null ) { throw new nullpointerexception ( ) ; } if ( keys . isempty ( ) ) {	Removes several entries from region in a single hop.
public static < t > t retrywithexponentialbackoff ( retryable < t > runnable , int maxretries ) throws interruptedexception , operationretryfailedexception { int retry = num_ ; while ( retry < maxretries ) { retry ++ ; try { return runnable . execute ( ) ; } catch ( operationrequireretryexception e ) {	Retries passed operation with random exponential back off delay.
protected void generatebufferedimage ( transcoderinput in , int w , int h ) throws transcoderexception { bufferedimagetranscoder t = new bufferedimagetranscoder ( ) ; if ( w != num_ && h != num_ ) { t . setdimensions ( w , h ) ; } t . transcode ( in , null ) ; bufferedimage = t . getbufferedimage ( ) ; width = bufferedimage . getwidth ( ) ; height = bufferedimage . getheight ( ) ; }	Generate the BufferedImage.
@ override public void painticon ( component c , graphics g , int x , int y ) { if ( backgroundcolour == null ) g . drawimage ( bufferedimage , x , y , null ) ; else g . drawimage ( bufferedimage , x , y , backgroundcolour , null ) ; }	Draw the icon at the specified location.
private static bufferedreader getreader ( ) { if ( bufferedreader == null ) { bufferedreader = new bufferedreader ( new inputstreamreader ( system . in ) ) ; } return bufferedreader ; }	Method getReader returns the reader of this ConsoleUtils object.
public static void waitforenter ( string message ) { system . out . println ( message ) ; try { getreader ( ) . readline ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ;	Waits for enter with specified message.
public void execute ( string [ ] args , boolean debugenabled , boolean quiet ) { try { this . debugenabled = debugenabled ; debug ( str_ + arrays . aslist ( args ) ) ; parsecommandlinearguments ( args ) ; system . out . println ( str_ ) ; debug ( str_ + clustersproperties + str_ + timeout + str_ + regionname ) ; processortask task = new processortask ( clustersproperties , timeout , regionname , debugenabled , quiet ) ; debug ( str_ ) ; utils . execute ( task , timeout + delta_timeout ) ; int exitcode = task . getexitcode ( ) ; debug ( str_ + exitcode ) ; if ( exitcode == num_ ) { utils . exitwithsuccess ( ) ; } utils . exitwithfailure ( ) ; } catch ( throwable t ) { debug ( str_ + t . getmessage ( ) , t ) ; utils . exitwithfailure ( str_ , t ) ; } }	Runs the tool. All the tools run in this way.
protected void parsecommandlinearguments ( string [ ] commandlinearguments ) { options options = constructgnuoptions ( ) ; if ( commandlinearguments . length < num_ ) { printhelp ( options ) ; } commandlineparser parser = new gnuparser ( ) ; try { commandline line = parser . parse ( options , commandlinearguments ) ; if ( line . hasoption ( help_option ) ) { printhelp ( options ) ; } if ( line . hasoption ( region_option ) ) { regionname = line . getoptionvalue ( region_option ) ; } if ( line . hasoption ( timeout_option ) ) { string timeoutstring = line . getoptionvalue ( timeout_option ) ; timeout = long . parselong ( timeoutstring ) ; } if ( line . hasoption ( cluster_option ) ) { clustersproperties = line . getoptionproperties ( cluster_option ) ; if ( clustersproperties . keyset ( ) . size ( ) < num_ ) { utils . exitwithfailure ( str_ ) ; } } else { utils . exitwithfailure ( str_ ) ; } } catch ( throwable t ) { utils . exitwithfailure ( str_ , t ) ; } }	Parses command-line arguments and sets the local variables.
protected void printhelp ( final options options ) { helpformatter formatter = new helpformatter ( ) ; formatter . printhelp ( str_ , options ) ; utils . exitwithfailure ( ) ; }	Prints help if requested, or in case of any misconfiguration.
protected options constructgnuoptions ( ) { final options gnuoptions = new options ( ) ; gnuoptions . addoption ( str_ , timeout_option , bool_ , str_ + default_timeout ) . addoption ( str_ , region_option , bool_ , str_ + default_region_name + str_ ) . addoption ( str_ , help_option , bool_ , str_ ) ; @ suppresswarnings ( str_ ) option locatorsoption = optionbuilder . hasargs ( ) . withdescription ( str_ + str_ + str_ ) . withvalueseparator ( ) . withargname ( str_ ) . withlongopt ( cluster_option ) . create ( str_ ) ; gnuoptions . addoption ( locatorsoption ) ; return gnuoptions ; }	Constructs the set of GNU options.
private static void aggregatesingleclustermemberdata ( list < resultcollector > taskresults ) { for ( resultcollector singlecluster : taskresults ) { list membersresult = ( list ) singlecluster . getresult ( ) ; for ( object resultfromnode : membersresult ) { system . out . print ( ( ( hashmap ) resultfromnode ) . get ( str_ ) + str_ ) ; } system . out . println ( ) ; } }	only for partitioned region!.
public expressionbuilder notnull ( final object property , final string name ) { if ( property == null ) { messagecontainer . adderrormessage ( str_ + name + str_ ) ; } return this ; }	Adds a description for a null property.
private static void parsecommandlinearguments ( string [ ] commandlinearguments ) { options options = constructgnuoptions ( ) ; commandlineparser parser = new gnuparser ( ) ; try { commandline line = parser . parse ( options , commandlinearguments ) ; if ( line . hasoption ( help_option ) ) { printhelp ( options ) ; } if ( line . hasoption ( debug_option ) ) { debugenabled = bool_ ; } if ( ! debugenabled && line . hasoption ( quiet_option ) ) { quiet = bool_ ; } } catch ( throwable t ) { printhelp ( options ) ; } }	Parses command line arguments.
private static void printhelp ( final options options ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( str_ ) ; command [ ] commands = command . values ( ) ; for ( int i = num_ ; i < commands . length ; i ++ ) { sb . append ( commands [ i ] . getname ( ) ) ; if ( i < ( commands . length - num_ ) ) { sb . append ( str_ ) ; } } sb . append ( str_ ) ; helpformatter formatter = new helpformatter ( ) ; formatter . printhelp ( sb . tostring ( ) , options ) ; utils . exitwithfailure ( ) ; }	Prints help if requested.
private static options constructgnuoptions ( ) { final options gnuoptions = new options ( ) ; gnuoptions . addoption ( str_ , debug_option , bool_ , str_ ) . addoption ( str_ , quiet_option , bool_ , str_ + debug_option + str_ ) . addoption ( str_ , help_option , bool_ , str_ ) ; return gnuoptions ; }	Constructs the set of GNU options.
private static int findcommandindex ( string [ ] args ) { int commandindex = - num_ ; for ( int i = num_ ; i < args . length ; i ++ ) { for ( command command : command . values ( ) ) { if ( command . getname ( ) . equals ( args [ i ] . trim ( ) ) ) { commandindex = i ; break ; } } } return commandindex ; }	Looks for the index of command in the specified array.
private static string [ ] extractlauncherargs ( string [ ] args , int commandindex ) { string [ ] launcherargs = new string [ commandindex ] ; system . arraycopy ( args , num_ , launcherargs , num_ , commandindex ) ; return launcherargs ; }	Extracts the launcher arguments from the all arguments array.
private static string [ ] extractcommandargs ( string [ ] args , int commandindex ) { string [ ] commandargs = new string [ args . length - commandindex - num_ ] ; system . arraycopy ( args , commandindex + num_ , commandargs , num_ , args . length - commandindex - num_ ) ; return commandargs ; }	Extracts the command-specific arguments from the all arguments array.
public static void main ( string [ ] args ) { try { int commandindex = findcommandindex ( args ) ; if ( commandindex < num_ ) { printhelp ( ) ; } string [ ] launcherargs = extractlauncherargs ( args , commandindex ) ; string [ ] commandargs = extractcommandargs ( args , commandindex ) ; parsecommandlinearguments ( launcherargs ) ; debug ( str_ + arrays . aslist ( args ) ) ; debug ( str_ + arrays . aslist ( launcherargs ) ) ; debug ( str_ + arrays . aslist ( commandargs ) ) ; string commandname = args [ commandindex ] ; executable tool = command . getutil ( commandname ) ; if ( tool != null ) { tool . execute ( commandargs , debugenabled , quiet ) ; } else { debug ( str_ + commandname + str_ ) ; printhelp ( ) ; } } catch ( throwable t ) { debug ( str_ + t . getmessage ( ) , t ) ; utils . exitwithfailure ( str_ , t ) ; } }	The entry point of the application.
private static void debug ( string message , throwable t ) { if ( debugenabled ) { system . err . println ( str_ + message ) ; if ( t != null ) { t . printstacktrace ( system . err ) ; } } }	Prints debug information if debug is enabled.
private void start ( ) { try { timer . schedule ( new isalivetimertask ( ) , num_ , period ) ; } catch ( throwable t ) { utils . exitwithfailure ( str_ , t ) ; } }	Starts the checking task.
public set < region < ? , ? > > createregions ( map < string , string > regionnames ) { set < region < ? , ? > > regions = new hashset < region < ? , ? > > ( ) ; proxyregionfactory = cache . createclientregionfactory ( clientregionshortcut . proxy ) ; for ( string regionpath : regionnames . keyset ( ) ) { region region = createregion ( regionpath , regionnames . get ( regionpath ) ) ; regions . add ( region ) ; } return regions ; }	Creates regions structure similar to server region structure.
public long process ( region < ? , ? > region , expirationpolicy policy ) { long destroyedentriesnumber = num_ ; try { if ( region == null ) { throw new illegalstateexception ( str_ ) ; } if ( policy == null ) { throw new illegalargumentexception ( str_ ) ; } logger . info ( str_ + region + str_ + policy + str_ + packetsize + str_ + packetdelay ) ; destroyedentriescountcollector collector = ( destroyedentriescountcollector ) functionservice . onregion ( region ) . withargs ( new expirationfunctionarguments ( packetsize , packetdelay ) ) . withcollector ( new destroyedentriescountcollector ( ) ) . execute ( new expirationfunction ( policy ) ) ; object result = collector . getresult ( ) ; if ( result instanceof long ) { destroyedentriesnumber = ( long ) result ; } logger . info ( str_ + region + str_ + policy + str_ + packetsize + str_ + packetdelay + str_ + destroyedentriesnumber + str_ ) ; } catch ( runtimeexception re ) { logger . error ( str_ , re ) ; throw re ; } return destroyedentriesnumber ; }	Applies the specified policy on the specified region and returns numberof destroyed entries.
public final void setindentationtoken ( final string indentationtoken ) {	Assigns the indentationToken of this RenderConfiguration.
@ override public string getpackage ( final file sourcefile ) { string aline = getpackage ( sourcefile , package_statement ) ; if ( aline != null ) return aline ;	Retrieves the package definition from the supplied sourceFile.
public static boolean start ( final rootdoc root ) {	Generate documentation here.This method is required for all doclets.
private set < integer > extractportsset ( systemmember member ) throws adminexception { set < integer > portsset = new hashset < integer > ( ) ; systemmembercache cache = member . getcache ( ) ; if ( cache != null ) { systemmembercacheserver [ ] cacheservers = cache . getcacheservers ( ) ; if ( cacheservers != null ) { for ( systemmembercacheserver cacheserver : cacheservers ) { portsset . add ( cacheserver . getport ( ) ) ; } } } return portsset ; }	Extracts port from the SystemMember object.
private pool findorcreatepool ( string host , int port ) { string poolname = utils . tokey ( host , port ) ; pool pool = poolmanager . find ( poolname ) ; if ( pool == null ) { poolfactory . reset ( ) ; poolfactory . addserver ( host , port ) ; pool = poolfactory . create ( poolname ) ; } return pool ; }	Looks for the existing pool with name poolFactory.
public static string getname ( string eventsrcname ) { if ( eventsrcname == null ) { return null ; } if ( eventsrcname . endswith ( str_ ) ) { eventsrcname = eventsrcname . substring ( num_ , eventsrcname . length ( ) - num_ ) ; } return eventsrcname . substring ( eventsrcname . lastindexof ( str_ ) + num_ ) ; }	Get the rule name from an audit event source name.
public static string getcategory ( string eventsrcname ) { if ( eventsrcname == null ) { return null ; } int end = eventsrcname . lastindexof ( str_ ) ; eventsrcname = eventsrcname . substring ( num_ , end ) ; if ( checkstyle_package . equals ( eventsrcname ) ) { return str_ ; } else if ( ! eventsrcname . startswith ( checkstyle_package ) ) { return str_ ; } return eventsrcname . substring ( eventsrcname . lastindexof ( str_ ) + num_ ) ; }	Get the rule category from an audit event source name.
public static void enterframe ( string classname ) { int counter = local . get ( ) . incrementandget ( ) ; classnames . get ( ) . add ( classname ) ; if ( counter == max_stack_depth ) { throw new runtimeexception ( stack_overflow_msg + getclassnames ( ) ) ; } }	Increment the counter.
public static void exitframe ( string classname ) { int counter = local . get ( ) . decrementandget ( ) ; if ( counter < num_ ) { string errormessage = str_ + getclassnames ( ) ; clearcounter ( ) ; throw new runtimeexception ( errormessage ) ; } string frametoexit = classnames . get ( ) . remove ( classnames . get ( ) . size ( ) - num_ ) ; if ( ! classname . equals ( frametoexit ) ) { throw new runtimeexception ( str_ + classname + str_ + frametoexit + str_ + getclassnames ( ) ) ; } }	Decrement the counter and remove class name from the list.
private static string getclassnames ( ) { stringbuilder result = new stringbuilder ( str_ ) ; for ( string classname : classnames . get ( ) ) { result . append ( classname ) . append ( str_ ) ; } return result . tostring ( ) ; }	Creates string with all classes that have been entered by method frame counter.
public final void setpackageextractors ( final string packageextractorimplementations ) throws illegalargumentexception {	Splices the supplied packageExtractorImplementations argument, which is assumed to be a comma-separatedstring holding fully qualified class names of the PackageExtractor implementations which should be usedby this CorrectPackagingRule.
private void addpackages ( final file fileordirectory , final sortedmap < string , sortedset < string > > package2filenamesmap ) { for ( packageextractor current : packageextractors ) { final filefilter sourcefiledefinitionfilter = current . getsourcefilefilter ( ) ; if ( fileordirectory . isfile ( ) && sourcefiledefinitionfilter . accept ( fileordirectory ) ) {	Adds all source file found by recursive search under sourceRoot to thetoPopulate List, using a width-first approach.
@ prepersist @ preupdate private void updateimagedata ( ) throws customconstraintviolationexception { thumbnail = createimage ( bool_ ) ; imagefile . validate ( ) ; if ( imagedata != null ) { imagecontenthash = hashutilities . generatesha256 ( imagedata ) . tochararray ( ) ; } }	Create the thumbnails, and make sure the parent imagefile is valid.
public void setuioriginalfilename ( final string uioriginalfilename ) { this . uioriginalfilename = uioriginalfilename ; if ( this . uioriginalfilename != null && ! this . uioriginalfilename . isempty ( ) ) originalfilename = this . uioriginalfilename ; }	The UI will attempt to assign an empty value if the file upload box does not have a file selected.
private static int extractlimit ( string querystring ) { int limitindex = querystring . lastindexof ( str_ ) ; if ( limitindex == - num_ ) { limitindex = querystring . lastindexof ( str_ ) ; } if ( limitindex == - num_ ) { return limitindex ; } string limitvalue = querystring . substring ( limitindex + num_ ) ; return integer . parseint ( limitvalue . trim ( ) ) ; }	Extracts limit value from query string.
@ suppresswarnings ( { str_ } ) private static selectresults < object > formatselectresults ( list < list < object > > queryresults , int limit ) { list < object > list = new arraylist < object > ( ) ; objecttype baseelementtype = null ; for ( list < object > queryresult : queryresults ) { objecttype elementtype = ( objecttype ) queryresult . remove ( queryresult . size ( ) - num_ ) ; if ( baseelementtype == null ) { baseelementtype = elementtype ; } else if ( ! baseelementtype . equals ( elementtype ) ) { throw new illegalstateexception ( str_ ) ; } list . addall ( queryresult ) ; if ( limit != - num_ && list . size ( ) >= limit ) { break ; } } return limit == - num_ ? new resultscollectionwrapper ( baseelementtype , list ) : new resultscollectionwrapper ( baseelementtype , list , limit ) ; }	Collects and formats query results into SelectResults.
private static void checkallowedinrealtime0 ( object obj , int depth ) throws invalidclassexception { if ( depth >= methodframecounter . max_stack_depth ) {	With stack counter.
public process runwithconfirmation ( string id , class < ? > klass , string [ ] javaarguments , string [ ] processarguments ) throws ioexception , interruptedexception { process process = startprocess ( id , klass , javaarguments , processarguments , bool_ ) ; waitconfirmation ( klass . getsimplename ( ) , process ) ; new streamredirector ( process . getinputstream ( ) , klass . getsimplename ( ) + process_stdout_stream_prefix , redirectprocessinputstreamtoparentprocessstdout ) . start ( ) ; return process ; }	Runs process based on a specified class in a separate VM using array ofarguments.
public process runwithstartupdelay ( class < ? > klass , string [ ] javaarguments , string [ ] processarguments ) throws ioexception , interruptedexception , timeoutexception { return runwithstartupdelay ( klass , javaarguments , processarguments , default_process_startup_shutdown_time ) ; }	Runs process with arguments based on a specified class in a separate VM.Waits DEFAULT_PROCESS_STARTUP_TIME before returns the created process toa caller.
public process runwithstartupdelay ( class < ? > klass , string [ ] javaarguments , string [ ] processarguments , long processstartuptime ) throws ioexception , interruptedexception , timeoutexception { process process = runwithconfirmation ( str_ , klass , javaarguments , processarguments ) ; if ( processstartuptime > num_ ) { thread . sleep ( processstartuptime ) ; } return process ; }	Runs process with arguments based on a specified class in a separate VM.Waits processStartupTime before returns the created process to a caller.
public void stopbysendingnewlineintoprocess ( process process ) throws ioexception , interruptedexception { if ( process != null ) { bufferedwriter writer = new bufferedwriter ( new outputstreamwriter ( process . getoutputstream ( ) ) ) ; writer . newline ( ) ; writer . flush ( ) ; process . waitfor ( ) ; } }	Stops process by sending new line to it's output stream.The process can be stopped by calling destroy() method.
private process startprocess ( string id , class < ? > klass , string [ ] javaarguments , string [ ] processarguments , boolean withconfirmation ) throws ioexception , interruptedexception { list < string > arguments = createcommandlineforprocess ( klass , javaarguments , processarguments ) ; process process = new processbuilder ( arguments ) . start ( ) ; redirectprocessstreams ( id , klass , process , ! withconfirmation ) ; return process ; }	Starts process based on specified class using command line arguments.This process inherits a classpath from parent VM that starts it.
private void redirectprocessstreams ( string id , class < ? > klass , process process , boolean redirectprocessstdout ) { string errorstreamtype = ( printtype ? klass . getsimplename ( ) + id + process_error_stream_prefix : str_ ) ; new streamredirector ( process . geterrorstream ( ) , errorstreamtype , redirectprocesserrorstreamtoparentprocessstdout , system . err ) . start ( ) ; if ( redirectprocessstdout ) { string outputstreamtype = ( printtype ? klass . getsimplename ( ) + id + process_stdout_stream_prefix : str_ ) ; new streamredirector ( process . getinputstream ( ) , outputstreamtype , redirectprocessinputstreamtoparentprocessstdout , system . out ) . start ( ) ; } }	Redirects process standard output and error streams into parent processstandard output.
private void waitconfirmation ( string classname , process process ) throws ioexception , interruptedexception { system . out . println ( str_ + classname + str_ ) ; bufferedreader bufferedreader = new bufferedreader ( new inputstreamreader ( process . getinputstream ( ) ) ) ; string line ; while ( ( line = bufferedreader . readline ( ) ) != null ) { if ( line . equals ( process_startup_completed ) ) { system . out . println ( str_ + classname + str_ ) ; return ; } else if ( redirectprocessinputstreamtoparentprocessstdout ) { system . out . println ( classname + process_stdout_stream_prefix + line ) ; } } throw new interruptedexception ( str_ + classname + str_ + str_ ) ; }	Waits startup complete confirmation from process.
public void generate ( string outputfilename , string template , context context ) throws velocityexception , mojoexecutionexception , ioexception { writer writer = null ; try { file f = new file ( outputfilename ) ; if ( ! f . getparentfile ( ) . exists ( ) ) { f . getparentfile ( ) . mkdirs ( ) ; } writer = new filewriter ( f ) ; getvelocity ( ) . getengine ( ) . mergetemplate ( templatedirectory + str_ + template , context , writer ) ; } catch ( resourcenotfoundexception e ) { throw new resourcenotfoundexception ( str_ + templatedirectory + str_ + template , e ) ; } catch ( velocityexception | ioexception e ) { throw e ;	Using a specified Velocity Template and provided context, create the outputFilename.
public int process ( ) throws ioexception , interruptedexception { debug ( str_ ) ; properties gemfireproperties = propertieshelper . filterproperties ( system . getproperties ( ) , str_ ) ; string [ ] vmoptions = propertieshelper . propertiestovmoptions ( gemfireproperties ) ; debug ( str_ + arrays . aslist ( vmoptions ) ) ; list < process > processeslist = new arraylist < process > ( ) ; for ( object keyobject : clustersproperties . keyset ( ) ) { string cluster = ( string ) keyobject ; string clusterspropertiesstring = propertieshelper . propertiestostring ( clustersproperties ) ; debug ( str_ + cluster + str_ + clusterspropertiesstring + str_ + timeout + str_ + regionname ) ; process process = javaprocesslauncher . runwithoutconfirmation ( str_ , guestnode . class , vmoptions , new string [ ] { cluster , clusterspropertiesstring , string . valueof ( timeout ) , regionname , string . valueof ( debugenabled ) , string . valueof ( quiet ) , string . valueof ( processingstartedat ) } ) ; debug ( str_ ) ; processeslist . add ( process ) ; } debug ( str_ ) ; int mainexitcode = num_ ; int processnumber = num_ ; for ( process process : processeslist ) { debug ( str_ + processnumber ) ; int exitcode = process . waitfor ( ) ; if ( exitcode != num_ ) { mainexitcode = num_ ; } debug ( str_ + processnumber + str_ + exitcode ) ; processnumber ++ ; } debug ( str_ + mainexitcode ) ; return mainexitcode ; }	Creates, configures and runs the guest nodes and collects informationform them.
public static boolean isa ( class clazz , parameterizedtype ptype ) { return clazz . isassignablefrom ( ( class ) ptype . getrawtype ( ) ) ; }	Is the genericType of a certain class?.
public static boolean iscompatible ( method method , method intfmethod ) { if ( method == intfmethod ) return bool_ ; if ( ! method . getname ( ) . equals ( intfmethod . getname ( ) ) ) return bool_ ; if ( method . getparametertypes ( ) . length != intfmethod . getparametertypes ( ) . length ) return bool_ ; for ( int i = num_ ; i < method . getparametertypes ( ) . length ; i ++ ) { class rootparam = method . getparametertypes ( ) [ i ] ; class intfparam = intfmethod . getparametertypes ( ) [ i ] ; if ( ! intfparam . isassignablefrom ( rootparam ) ) return bool_ ; } return bool_ ; }	See if the two methods are compatible, that is they have the samerelative signature.
public static method getimplementingmethod ( class clazz , method intfmethod ) { class < ? > declaringclass = intfmethod . getdeclaringclass ( ) ; if ( declaringclass . equals ( clazz ) ) return intfmethod ; class [ ] paramtypes = intfmethod . getparametertypes ( ) ; if ( declaringclass . gettypeparameters ( ) . length > num_ && paramtypes . length > num_ ) { type [ ] intftypes = findparameterizedtypes ( clazz , declaringclass ) ; map < string , type > typevarmap = new hashmap < string , type > ( ) ; typevariable < ? extends class < ? > > [ ] vars = declaringclass . gettypeparameters ( ) ; for ( int i = num_ ; i < vars . length ; i ++ ) { if ( intftypes != null && i < intftypes . length ) { typevarmap . put ( vars [ i ] . getname ( ) , intftypes [ i ] ) ; } else {	Given a method and a root class, find the actual method declared in theroot that implements the method.
public static class < ? > gettypeargument ( type generictype ) { if ( ! ( generictype instanceof parameterizedtype ) ) return null ; parameterizedtype parameterizedtype = ( parameterizedtype ) generictype ; class < ? > typearg = ( class < ? > ) parameterizedtype . getactualtypearguments ( ) [ num_ ] ; return typearg ; }	Returns the type argument from a parameterized type.
public static type resolvetypevariable ( class < ? > root , typevariable < ? > typevariable ) { if ( typevariable . getgenericdeclaration ( ) instanceof class < ? > ) { class < ? > classdeclaringtypevariable = ( class < ? > ) typevariable . getgenericdeclaration ( ) ; type [ ] types = findparameterizedtypes ( root , classdeclaringtypevariable ) ; if ( types == null ) return null ; for ( int i = num_ ; i < types . length ; i ++ ) { typevariable < ? > tv = classdeclaringtypevariable . gettypeparameters ( ) [ i ] ; if ( tv . equals ( typevariable ) ) { return types [ i ] ; } } } return null ; }	Finds an actual value of a type variable.
public static type [ ] getactualtypeargumentsofaninterface ( class < ? > classtosearch , class < ? > interfacetofind ) { type [ ] types = findparameterizedtypes ( classtosearch , interfacetofind ) ; if ( types == null ) throw new runtimeexception ( str_ + interfacetofind ) ; return types ; }	Given a class and an interfaces, go through the class hierarchy to findthe interface and return its type arguments.
private void populate ( ) throws exception { list < t > initializer = new arraylist < t > ( this . getminidle ( ) ) ; for ( int idx = num_ ; idx < this . getminidle ( ) && ( this . getmaxidle ( ) == disabled || idx < this . getmaxidle ( ) ) && ( this . getmaxactive ( ) == disabled || idx < this . getmaxactive ( ) ) ; idx ++ ) { initializer . add ( this . borrowobject ( ) ) ; } for ( int idx = num_ ; idx < this . getminidle ( ) && ( this . getmaxidle ( ) == disabled || idx < this . getmaxidle ( ) ) && ( this . getmaxactive ( ) == disabled || idx < this . getmaxactive ( ) ) ; idx ++ ) { this . returnobject ( initializer . get ( idx ) ) ; } }	Populate the pool up to minIdle instances.
private void addreturnoptiondescription ( method method , return . returnbuilder returnbuilder ) { docreturn returnanno = getnonexceptiondocreturn ( method ) ; string returnoptiondesc = ( returnanno == null ) ? null : returnanno . description ( ) ; returnbuilder . description ( stringutils . isempty ( returnoptiondesc ) ? null : returnanno . description ( ) ) ; }	Used for non exception return option.
private void returnobject ( objectpool < classifier > pool , classifier object ) { try { pool . returnobject ( object ) ; } catch ( exception e ) { logger . error ( str_ , e ) ; } }	Returns the given object to the pool.
private destination getdestination ( final string destinationname ) { if ( ! destinations . containskey ( destinationname ) ) { destination destination = destinationsupplier . apply ( destinationname ) ; destinations . put ( destinationname , destination ) ; } return destinations . get ( destinationname ) ; }	Get the destination.
private messageconsumer getconsumer ( final string destinationname ) { if ( ! consumers . containskey ( destinationname ) ) { session session = getsession ( ) ; destination destination = getdestination ( destinationname ) ; try { messageconsumer consumer = session . createconsumer ( destination ) ; consumers . put ( destinationname , consumer ) ; } catch ( jmsexception e ) { throw new jmsexception ( str_ + destinationname , e ) ; } } return consumers . get ( destinationname ) ; }	Get the `MessageConsumer`.
private messageproducer getproducer ( final string destinationname ) { if ( ! producers . containskey ( destinationname ) ) { session session = getsession ( ) ; destination destination = getdestination ( destinationname ) ; messageproducer producer ; try { producer = session . createproducer ( destination ) ; } catch ( jmsexception e ) { throw new jmsexception ( str_ + destinationname , e ) ; } producers . put ( destinationname , producer ) ; } return producers . get ( destinationname ) ; }	Get the `MessageProducer` or create one from the JMS session.
private session getsession ( ) { if ( ! sessionoption . ispresent ( ) ) { try { sessionoption = optional . of ( getconnection ( ) . createsession ( transacted , acknowledgemode ) ) ; } catch ( jmsexception e ) { throw new jmsexception ( str_ , e ) ; } } return sessionoption . get ( ) ; }	Get the current session or create one from the JMS connection.
private connection getconnection ( ) { if ( ! connectionoption . ispresent ( ) ) { final connection connection = connectionsupplier . get ( ) ; if ( connection instanceof activemqconnection ) { ( ( activemqconnection ) connection ) . addtransportlistener ( new transportlistener ( ) { @ override public void oncommand ( object command ) { } @ override public void onexception ( ioexception error ) { } @ override public void transportinterupted ( ) { connected . set ( bool_ ) ; } @ override public void transportresumed ( ) { connected . set ( bool_ ) ; } } ) ; } connected . set ( bool_ ) ; if ( startconnection ) { try { connection . start ( ) ; } catch ( jmsexception e ) { throw new jmsexception ( str_ , e ) ; } } connectionoption = optional . of ( connection ) ; } return connectionoption . get ( ) ; }	Get the current connection or create one using the connectionSupplier.
public void sendtextmessagewithdestination ( final string destinationname , final string messagecontent ) { if ( ! this . isconnected ( ) ) { throw new jmsnotconnectedexception ( str_ + destinationname ) ; } final session session = getsession ( ) ; final messageproducer producer = getproducer ( destinationname ) ; try { textmessage message = session . createtextmessage ( messagecontent ) ; producer . send ( message ) ; } catch ( jmsexception e ) { throw new jmsexception ( str_ + destinationname , e ) ; } }	Send a text message given a queue or topic name and a text message.
public void listentextmessageswithdestination ( final string destinationname , final consumer < string > messagelistener ) { final messageconsumer consumer = getconsumer ( destinationname ) ; try { consumer . setmessagelistener ( message -> { try { messagelistener . accept ( ( ( textmessage ) message ) . gettext ( ) ) ; if ( acknowledgemode == session . client_acknowledge ) { message . acknowledge ( ) ; } } catch ( jmsexception e ) { throw new jmsexception ( str_ + destinationname , e ) ; } catch ( exception ex ) { throw new illegalstateexception ( str_ + destinationname , ex ) ; } } ) ; } catch ( jmsexception e ) { throw new jmsexception ( str_ + destinationname , e ) ; } }	Listen to a message from JMS from a given destination by name.
public string receivetextmessagefromdestinationwithtimeout ( final string destinationname , final int timeout ) { if ( ! this . isconnected ( ) ) { throw new jmsnotconnectedexception ( str_ ) ; } messageconsumer consumer = getconsumer ( destinationname ) ; textmessage message ; try { if ( timeout == num_ ) { message = ( textmessage ) consumer . receivenowait ( ) ; } else { message = ( textmessage ) consumer . receive ( timeout ) ; } if ( message != null ) { if ( acknowledgemode == session . client_acknowledge ) { message . acknowledge ( ) ; } return message . gettext ( ) ; } else { return null ; } } catch ( jmsexception e ) { throw new jmsexception ( str_ + destinationname , e ) ; } }	Receive a message from destination with timeout.
private void handleloadfromuserdataservice ( final user loadeduser , final callback < list < recommendation > > recommendationscallback ) { callbacks . add ( ( ) -> { list < recommendation > recommendations = runrulesengineagainstuser ( loadeduser ) ; recommendationscallback . accept ( recommendations ) ; } ) ;	Handle defered recommendations based on user loads.
@ notnull public map < object , object > getpoolconfiguration ( ) { return configurationconverter . getmap ( configuration . subset ( genericobjectpoolconfig . class . getname ( ) ) ) ; }	Returns the pool configuration of the scorer.
public void setid ( uuid id ) { this . dirty = bool_ ; this . id = id ; this . modelconfig . setproperty ( id , id . tostring ( ) ) ; }	Sets the ID of the model.
public void setmodel ( file model ) { this . dirty = bool_ ; this . model = model ; this . modelconfig . setproperty ( model_file , model . getabsolutepath ( ) ) ; }	Sets the model file of the serialized classifier.
public void addorupdate ( wekamodelconfig wekamodelconfig ) throws fosexception { checknotnull ( wekamodelconfig , str_ ) ; wekathreadsafescorer newwekathreadsafescorer = new wekathreadsafescorerpool ( wekamodelconfig , wekamanagerconfig ) ; wekathreadsafescorer oldwekathreadsafescorer = quickswitch ( wekamodelconfig . getid ( ) , newwekathreadsafescorer ) ; wekautils . closesilently ( oldwekathreadsafescorer ) ; }	Adds the given model to the managed models.
public void removemodel ( uuid modelid ) { wekathreadsafescorer newwekathreadsafescorer = null ; wekathreadsafescorer oldwekathreadsafescorer = quickswitch ( modelid , newwekathreadsafescorer ) ; wekautils . closesilently ( oldwekathreadsafescorer ) ; }	Removes the given model from the managed models.
@ bean public servicequeue clusteredeventmanagerservicequeue ( final @ qualifier ( str_ ) eventbuscluster eventbuscluster ) { if ( eventbuscluster == null ) { return null ; } return eventbuscluster . eventservicequeue ( ) ; }	The actual service queue for the clustered event bus.All events are sent to this queue first.
@ bean public eventmanager clusteredeventmanagerimpl ( final eventconnectorhub eventconnectorhub ) { return eventmanagerbuilder . eventmanagerbuilder ( ) . seteventconnector ( eventconnectorhub ) . setname ( str_ ) . build ( ) ; }	Wraps factory method call so we can provide another implementation of interface if needed.
public static string encodenoncodes ( string string ) { matcher matcher = noncodes . matcher ( string ) ; stringbuffer buf = new stringbuffer ( ) ;	Encode '%' if it is not an encoding sequence.
public static multivaluedmap < string , string > decode ( multivaluedmap < string , string > map ) { multivaluedmapimpl < string , string > decoded = new multivaluedmapimpl < string , string > ( ) ; for ( map . entry < string , list < string > > entry : map . entryset ( ) ) { list < string > values = entry . getvalue ( ) ; for ( string value : values ) { try { decoded . add ( urldecoder . decode ( entry . getkey ( ) , utf_8 ) , urldecoder . decode ( value , utf_8 ) ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } } } return decoded ; }	decode an encoded map.
public servicegroup createservicegroup ( set < resourceclass > resourceclasses , servicegroup . servicegroupbuilder servicegroupbuilder ) { for ( resourceclass resourceclass : resourceclasses ) { logger . info ( str_ , resourceclass . getclazz ( ) . getcanonicalname ( ) ) ; service service = createresource ( resourceclass ) ; servicegroupbuilder . service ( service ) ; logger . info ( str_ , resourceclass . getclazz ( ) . getcanonicalname ( ) ) ; } return servicegroupbuilder . build ( ) ; }	Main method, creates API model from metadata.
@ override public synchronized void close ( ) throws fosexception { acceptthreadrunning = bool_ ; if ( scorerhandler != null ) { scorerhandler . close ( ) ; } ioutils . closequietly ( serversocket ) ; saveconfiguration ( ) ; }	Will save the configuration to file.
@ override public void forwardevent ( final eventtransferobject < object > event ) { eventconnector . forwardevent ( new eventtransferobject < object > ( ) { @ override public string channel ( ) { return event . channel ( ) ; } @ override public long id ( ) { return event . id ( ) ; } @ override public object body ( ) { return event . body ( ) ; } @ override public boolean issingleton ( ) { return bool_ ; } @ override public multimap < string , string > params ( ) { return event . params ( ) ; } @ override public multimap < string , string > headers ( ) { return event . headers ( ) ; } @ override public boolean wasreplicated ( ) { return bool_ ; } @ suppresswarnings ( str_ ) @ override public boolean equals ( object obj ) {	This message receives an event from a remote call.
public static annotation [ ] getresourcesannotations ( method method ) { map < class < ? > , annotation > annotations = new hashmap < class < ? > , annotation > ( ) ; for ( annotation annotation : method . getdeclaringclass ( ) . getannotations ( ) ) { annotations . put ( annotation . getclass ( ) , annotation ) ; } for ( annotation annotation : method . getannotations ( ) ) { annotations . put ( annotation . getclass ( ) , annotation ) ; } return annotations . values ( ) . toarray ( new annotation [ annotations . size ( ) ] ) ; }	Returns an array of annotations the specified method of a resource class.
public static < t extends annotation > t findannotation ( class < ? > type , annotation [ ] annotations , class < t > annotation ) { t config = findannotation . findannotation ( annotations , annotation ) ; if ( config == null ) { config = type . getannotation ( annotation ) ; } return config ; }	Look for an annotation in a list of annotations. If not there, see if itis on the type provided.
public static resourceconstructor constructor ( class < ? > annotatedresourceclass ) { constructor constructor = pickconstructor . pickperrequestconstructor ( annotatedresourceclass ) ; if ( constructor == null ) { throw new runtimeexception ( str_ + annotatedresourceclass . getname ( ) ) ; } resourceconstructorbuilder builder = rootresource ( annotatedresourceclass ) . constructor ( constructor ) ; if ( constructor . getparametertypes ( ) != null ) { for ( int i = num_ ; i < constructor . getparametertypes ( ) . length ; i ++ ) builder . param ( i ) . fromannotations ( ) ; } return builder . buildconstructor ( ) . buildclass ( ) . getconstructor ( ) ; }	Picks a constructor from an annotated resource class based on spec rules.
public static resourceclass rootresourcefromannotations ( class < ? > clazz ) { resourceclass resourceclass = fromannotations ( bool_ , clazz ) ; return resourceclass ; }	Build metadata from annotations on classes and methods.
public static void setupbaggingclassifiers ( iteratedsingleclassifierenhancer bagging ) throws exception { bagging . m_classifiers = classifier . makecopies ( bagging . m_classifier , bagging . m_numiterations ) ; }	Sets the classifiers in a bagging.
@ notnull public t get ( ) throws ioexception , classnotfoundexception { bytearrayinputstream bytearrayinputstream = null ; objectinputstream objectinputstream = null ; try { bytearrayinputstream = new bytearrayinputstream ( this . serializedobject ) ; objectinputstream = new objectinputstream ( bytearrayinputstream ) ; return ( t ) objectinputstream . readobject ( ) ; } finally { ioutils . closequietly ( bytearrayinputstream ) ; ioutils . closequietly ( objectinputstream ) ; } }	Gets a fresh clone of the object.
@ notnull public byte [ ] getserialized ( ) { byte [ ] result = new byte [ serializedobject . length ] ; system . arraycopy ( serializedobject , num_ , result , num_ , serializedobject . length ) ; return result ; }	Returns a copy of the serialized object.
public void write ( file file ) throws ioexception { checknotnull ( file , str_ ) ; fileutils . writebytearraytofile ( file , serializedobject ) ; }	Writes the serialized object to file.
public static string leafscorefromdistribution ( double [ ] classdistribution , instances instances ) { double sum = num_ , maxcount = num_ ; int maxindex = num_ ; if ( classdistribution != null ) { sum = utils . sum ( classdistribution ) ; maxindex = utils . maxindex ( classdistribution ) ; maxcount = classdistribution [ maxindex ] ; } return instances . classattribute ( ) . value ( maxindex ) ; }	Retrieves a String representing the score of the given class distribution.
public string getproviderurl ( ) { if ( providerurl == null ) { providerurl = getproviderurlpattern ( ) . replace ( str_ , gethost ( ) ) . replace ( str_ , integer . tostring ( getport ( ) ) ) ; } return providerurl ; }	If null, will build based on host, port and provider url pattern.
public context getcontext ( ) { if ( context == null ) { try { context = new initialcontext ( createproperties ( ) ) ; } catch ( namingexception e ) { throw new illegalstateexception ( str_ , e ) ; } } return context ; }	Gets the initial JNDI context, if not set uses the jndi settings and `initialContextFactory` to createa JNDI initial context.
public supplier < connection > getconnectionsupplier ( ) { final boolean startconnection = isstartconnection ( ) ; if ( connectionsupplier == null ) { if ( getusername ( ) == null ) { connectionsupplier = ( ) -> { try { final connection connection = getconnectionfactory ( ) . createconnection ( ) ; if ( startconnection ) { connection . start ( ) ; } return connection ; } catch ( jmsexception e ) { throw new jmsnotconnectedexception ( str_ , e ) ; } } ; } else { final string username = getusername ( ) ; final string password = getpassword ( ) ; connectionsupplier = ( ) -> { try { final connection connection = getconnectionfactory ( ) . createconnection ( username , password ) ; if ( startconnection ) { connection . start ( ) ; } return connection ; } catch ( jmsexception e ) { throw new jmsnotconnectedexception ( str_ + username , e ) ; } } ; } } return connectionsupplier ; }	If the user name is set, use the user name and password to create the JMS connection.
public jmsservice build ( ) { return new jmsservice ( getconnectionsupplier ( ) , getdestinationsupplier ( ) , istransacted ( ) , getacknowledgemode ( ) , isstartconnection ( ) , getdefaultdestination ( ) , getdefaulttimeout ( ) ) ; }	Build JMS Service.
public type gettype ( simpletype jacksontype ) { try { string signature = jacksonsignature . createsignature ( jacksontype ) ; customtype type = new customtype ( jacksontype . getrawclass ( ) . getname ( ) , signature , jacksontype . getrawclass ( ) ) ; if ( cache . containskey ( signature ) ) { return cache . get ( signature ) ; } cache . put ( signature , type ) ; objectwriter objectwriter = objectmapper . writerfor ( jacksontype ) ; field prefetchfield = objectwriter . getclass ( ) . getdeclaredfield ( str_ ) ; prefetchfield . setaccessible ( bool_ ) ; objectwriter . prefetch prefetch = ( objectwriter . prefetch ) prefetchfield . get ( objectwriter ) ; dointrospection ( prefetch . valueserializer , type ) ; return type ; } catch ( nosuchfieldexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } return null ; }	From Jackson type creates a JRAPIDoc type, type is stored in cache.
public type gettype ( javatype type ) { if ( type instanceof simpletype ) { return gettype ( ( simpletype ) type ) ; } else if ( type instanceof collectiontype ) { return gettype ( ( collectionliketype ) type ) ; } else if ( type instanceof arraytype ) { return gettype ( ( arraytype ) type ) ; } else if ( type instanceof mapliketype ) { return gettype ( ( mapliketype ) type ) ; } throw new runtimeexception ( str_ + type ) ; }	Do redirection from general Jackson type to the concrete one.
private void dointrospection ( jsonserializer serializer , type type ) { if ( serializer == null ) { return ; } if ( enumserializer . class . isassignablefrom ( serializer . getclass ( ) ) ) { introspectserializer ( ( enumserializer ) serializer , ( customtype ) type ) ; } else if ( beanserializerbase . class . isassignablefrom ( serializer . getclass ( ) ) ) { introspectserializer ( ( beanserializerbase ) serializer , ( customtype ) type ) ; } else if ( stdscalarserializer . class . isassignablefrom ( serializer . getclass ( ) ) ) { introspectserializer ( ( stdscalarserializer ) serializer , ( customtype ) type ) ; } else if ( asarrayserializerbase . class . isassignablefrom ( serializer . getclass ( ) ) ) { introspectserializer ( ( asarrayserializerbase ) serializer , ( collectiontypejrapidoc ) type ) ; } else if ( mapserializer . class . isassignablefrom ( serializer . getclass ( ) ) ) { introspectserializer ( ( mapserializer ) serializer , ( maptypejrapidoc ) type ) ; } }	Do redirection from general Jackson serializer to the concrete one.
private void introspectserializer ( beanserializerbase beanserializer , customtype type ) { try { field propsfield = beanserializer . getclass ( ) . getsuperclass ( ) . getdeclaredfield ( str_ ) ; propsfield . setaccessible ( bool_ ) ; beanpropertywriter [ ] props = ( beanpropertywriter [ ] ) propsfield . get ( beanserializer ) ; for ( beanpropertywriter prop : props ) { javatype proptype = prop . gettype ( ) ; gettype ( proptype ) ; string signature = jacksonsignature . createsignature ( proptype ) ; type . addbeanproperty ( new beanproperty ( prop . getname ( ) , signature , prop . getpropertytype ( ) , prop . getmetadata ( ) . getdescription ( ) , prop . getmetadata ( ) . isrequired ( ) ) ) ; } } catch ( nosuchfieldexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } }	Introspect serializer for java beans.
private void introspectserializer ( enumserializer enumserializer , customtype type ) { for ( serializablestring value : enumserializer . getenumvalues ( ) . values ( ) ) { type . addenumeration ( value . getvalue ( ) ) ; } }	Introspect serializer for enumerations.
private void introspectserializer ( mapserializer mapserializer , maptypejrapidoc type ) { try { field keytypefield = mapserializer . getclass ( ) . getdeclaredfield ( str_ ) ; keytypefield . setaccessible ( bool_ ) ; javatype keytype = ( javatype ) keytypefield . get ( mapserializer ) ; javatype valuetype = mapserializer . getcontenttype ( ) ; gettype ( keytype ) ; gettype ( valuetype ) ; } catch ( nosuchfieldexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } }	Introspect serializer for map.
private void frame1 ( ) {	Get customer, customer account, and broker information.
private void frame3 ( ) {	Estimate overall effects of the trade.
private void frame4 ( ) { long currenttime = system . currenttimemillis ( ) ;	Record the trade request by making all related updates.
public void next ( ) { for ( int k = a . length - num_ ; k > num_ ; k -- ) { int w = ( int ) math . floor ( math . random ( ) * ( k + num_ ) ) ; int temp = a [ w ] ; a [ w ] = a [ k ] ; a [ k ] = temp ; } }	It produces the next random permutation.
public int next ( ) {	Not repeat, randomly choose a number from 1 to the initinalized size.
public static void main ( string [ ] args ) { microbenchmarkparamgen executor = new microbenchmarkparamgen ( ) ; system . out . println ( str_ ) ; system . out . println ( str_ + rw_tx_rate ) ; system . out . println ( str_ + long_read_tx_rate ) ; system . out . println ( str_ + total_read_count ) ; system . out . println ( str_ + local_hot_count ) ; system . out . println ( str_ + write_ratio_in_rw_tx ) ; system . out . println ( str_ + hot_conflict_rate ) ; system . out . println ( str_ + data_size ) ; system . out . println ( str_ + hot_data_size ) ; system . out . println ( str_ + cold_data_size ) ; system . out . println ( ) ; for ( int i = num_ ; i < num_ ; i ++ ) { object [ ] params = executor . generateparameter ( ) ; system . out . println ( arrays . tostring ( params ) ) ; } }	a main application for debugging.
public string makelastname ( int number ) { if ( number < num_ && number > tpccconstants . num_distinct_clast - num_ ) throw new illegalargumentexception ( ) ; int indicies [ ] = { number / num_ , ( number / num_ ) % num_ , number % num_ } ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = num_ ; i < indicies . length ; ++ i ) { sb . append ( tokens [ indicies [ i ] ] ) ; } return sb . tostring ( ) ; }	Return a last name as defined by TPC-C 4.3.2.3.
public int randomchoosefromdistribution ( double ... probs ) { int result = - num_ ; int [ ] range = new int [ probs . length ] ; double accuracy = num_ ; int total = num_ ; for ( int i = num_ ; i < probs . length ; i ++ ) { range [ i ] = ( int ) ( probs [ i ] * accuracy ) ; total += range [ i ] ; } int randnum = ( int ) ( rng . nextdouble ( ) * total ) ; for ( int i = num_ ; i < range . length ; i ++ ) { randnum -= range [ i ] ; if ( randnum <= num_ ) { result = i ; break ; } } return result ; }	Return the result of a random choose from a given distribution.
public static file getrelativepath ( file in , file repositorypath ) throws javagitexception { string path = in . getpath ( ) ; string absolutepath = in . getabsolutepath ( ) ;	Returns a file, with path relative to git working tree.
public gitaddresponse add ( ) throws ioexception , javagitexception { gitadd gitadd = new gitadd ( ) ;	Adds the object to the git index.
public gitcommitresponse commit ( string comment ) throws ioexception , javagitexception {	Commits the file system object.
public gitmvresponse mv ( file dest ) throws ioexception , javagitexception {	Moves or renames the object.
public gitrmresponse rm ( ) throws ioexception , javagitexception { gitrm gitrm = new gitrm ( ) ;	Removes the file system object from the working tree and the index.
public static void checkfilevalidity ( file file ) throws ioexception { if ( ! file . exists ( ) ) { throw new ioexception ( exceptionmessagemap . getmessage ( str_ ) + str_ + file . getname ( ) + str_ ) ; } }	Checks that the specified file exists.
public static boolean checkunorderedlistsequal ( list < ? > l1 , list < ? > l2 ) { if ( null == l1 && null != l2 ) { return bool_ ; } if ( null != l1 && null == l2 ) { return bool_ ; } if ( l1 . size ( ) != l2 . size ( ) ) { return bool_ ; } for ( object o : l1 ) { if ( ! l2 . contains ( o ) ) { return bool_ ; } } for ( object o : l2 ) { if ( ! l1 . contains ( o ) ) { return bool_ ; } } return bool_ ; }	Checks if two unordered lists are equal.
public static void checkintinrange ( int index , int start , int end ) { if ( index < start ) { throw new indexoutofboundsexception ( exceptionmessagemap . getmessage ( str_ ) + str_ + index + str_ + start + str_ + end + str_ ) ; } if ( index >= end ) { throw new indexoutofboundsexception ( exceptionmessagemap . getmessage ( str_ ) + str_ + index + str_ + start + str_ + end + str_ ) ; } }	A general range check utility for checking whether a given &lt;integer&gt; value is between agiven start and end indexes.
public iclient getclientinstance ( clienttype clienttype ) { iclient clientinstance = clientimpls . get ( clienttype ) ; if ( null == clientinstance ) { if ( clienttype . cli == clienttype ) { clientinstance = new cliclient ( ) ; } if ( null != clientinstance ) { clientimpls . put ( clienttype , clientinstance ) ; } } return clientinstance ; }	Gets an instance of the specified client type.
public void setpreferredclienttype ( clienttype preferredclienttype ) { if ( null == preferredclienttype ) { this . preferredclienttype = clienttype . cli ; } else { this . preferredclienttype = preferredclienttype ; } }	Sets the preferred client type.
public gitaddresponse add ( file repositorypath , gitaddoptions options , list < file > paths ) throws javagitexception , ioexception { checkutilities . checkfilevalidity ( repositorypath ) ; gitaddparser parser = new gitaddparser ( ) ; list < string > command = buildcommand ( repositorypath , options , paths ) ; gitaddresponseimpl response = ( gitaddresponseimpl ) processutilities . runcommand ( repositorypath , command , parser ) ; if ( options != null ) { adddryrun ( options , response ) ; } return ( gitaddresponse ) response ; }	Implementations of &lt;git-add&gt; with options and list of files provided.
public gitaddresponse add ( file repositorypath , list < file > files ) throws javagitexception , ioexception { gitaddoptions options = null ; return add ( repositorypath , options , files ) ; }	Adds a list of files with no GitAddOptions.
public gitaddresponse add ( file repositorypath , file file ) throws javagitexception , ioexception { list < file > filepaths = new arraylist < file > ( ) ; filepaths . add ( file ) ; gitaddoptions options = null ; return add ( repositorypath , options , filepaths ) ; }	Adds one file to the index with no GitAddOptions.
public gitaddresponse add ( file repositorypath , gitaddoptions options , file file ) throws javagitexception , ioexception { list < file > paths = new arraylist < file > ( ) ; paths . add ( file ) ; return add ( repositorypath , options , paths ) ; }	Implementations of &lt;git-add&gt; with options and one file to be added to index.
public gitaddresponse adddryrun ( file repositorypath , list < file > paths ) throws javagitexception , ioexception { gitaddoptions options = new gitaddoptions ( ) ; options . setdryrun ( bool_ ) ; return add ( repositorypath , options , paths ) ; }	Implementation of &lt;git-add&gt; dry run.
public gitaddresponse addverbose ( file repositorypath , list < file > paths ) throws javagitexception , ioexception { gitaddoptions options = new gitaddoptions ( ) ; options . setverbose ( bool_ ) ; return add ( repositorypath , options , paths ) ; }	Implementations of &lt;git-add&gt; in verbose mode.
public gitaddresponse addwithforce ( file repositorypath , list < file > paths ) throws javagitexception , ioexception { gitaddoptions options = new gitaddoptions ( ) ; options . setforce ( bool_ ) ; return add ( repositorypath , options , paths ) ; }	Implementations of &lt;git-add&gt; with force option set.
private void adddryrun ( gitaddoptions options , gitaddresponseimpl response ) { if ( options . dryrun ( ) ) { response . setdryrun ( bool_ ) ; } }	if the dry run option was selected then set the flag in response.
private int comparetoreleaseminor ( gitversion that ) { if ( this . containsreleaseminor ( ) && that . containsreleaseminor ( ) ) return comparetoint ( this . getreleaseminor ( ) , that . getreleaseminor ( ) ) ; else if ( ! this . containsreleaseminor ( ) && ! that . containsreleaseminor ( ) ) return same ; else if ( this . containsreleaseminor ( ) && ! that . containsreleaseminor ( ) ) return later ; else return previous ; }	Compares minor releases values given that git version contains no tagfor none of GitVersion objects.
private static list < iparameter > createlist ( method method ) { list < iparameter > parameters = new arraylist < iparameter > ( ) ; class < ? > paramtypes [ ] = method . getparametertypes ( ) ; annotation [ ] [ ] methodannotations = method . getparameterannotations ( ) ; for ( int i = num_ ; i < methodannotations . length ; i ++ ) {	Creates the list of BinderVariables given a method obtained throughreflection.
public int [ ] getfunctiondefinitionarray ( int functionoffset , int maxparams , int returntype ) { int [ ] definition = new int [ maxparams + extra_func_def_values ] ; int paramcount = getparametercount ( bool_ ) ; int fullparamcount = getparametercount ( bool_ ) ; definition [ num_ ] = functionoffset ; if ( paramcount > maxparams ) { throw new illegalstateexception ( str_ + str_ + maxparams + str_ + paramcount ) ; } definition [ num_ ] = paramcount ; int j = num_ ; for ( int i = num_ ; i < fullparamcount ; i ++ ) {	Return the m_functionDefinition compatible array.
public object [ ] getvaluearray ( workspace ws , databinder binder , executioncontext ctx ) { object [ ] paramarray = new object [ this . parameters . size ( ) ] ; for ( int i = num_ ; i < this . parameters . size ( ) ; i ++ ) {	Returns an array of values given a filter execution context.
public static synchronized boolean existsinstance ( file path ) { string canonicalpath = str_ ; try { canonicalpath = path . getcanonicalpath ( ) ; } catch ( ioexception e ) {	Checks if there is a DotGit instance for a given path.
public ref createbranch ( string name ) throws ioexception , javagitexception { ref newbranch = ref . createbranchref ( name ) ; gitbranch gitbranch = new gitbranch ( ) ; gitbranch . createbranch ( path , newbranch ) ; return newbranch ; }	Creates a new branch.
public void deletebranch ( ref branch , boolean forcedelete ) throws ioexception , javagitexception { gitbranch gitbranch = new gitbranch ( ) ; gitbranch . deletebranch ( path , forcedelete , bool_ , branch ) ; branch = null ; }	Deletes a branch.
public ref renamebranch ( ref branchfrom , string nameto , boolean forcerename ) throws ioexception , javagitexception { ref newbranch = ref . createbranchref ( nameto ) ; gitbranch gitbranch = new gitbranch ( ) ; gitbranch . renamebranch ( path , forcerename , branchfrom , newbranch ) ; return newbranch ; }	Renames a branch.
public iterator < ref > getbranches ( ) throws ioexception , javagitexception { gitbranch gitbranch = new gitbranch ( ) ; gitbranchoptions options = new gitbranchoptions ( ) ; gitbranchresponse response = gitbranch . branch ( path , options ) ; return response . getbranchlistiterator ( ) ; }	Gets a list of the branches in the repository.
@ suppresswarnings ( str_ ) public static < t > t convert ( object from , class < t > to ) {	Convert the given object value to the given class.
public static boolean integertoboolean ( integer value ) { return value . intvalue ( ) == num_ ? boolean . false : boolean . true ; }	Converts Integer to Boolean.
public static integer booleantointeger ( boolean value ) { return value . booleanvalue ( ) ? integer . valueof ( num_ ) : integer . valueof ( num_ ) ; }	Converts Boolean to Integer.
public static string longtostring ( date value ) { if ( value == null ) { return null ; } simpledateformat sdf = new simpledateformat ( ) ; return sdf . format ( value ) ; }	Converts Date to String.
public static string getmessage ( string code ) { string str = message_map . get ( code ) ; if ( null == str ) { return str_ + code + str_ ; } return str ; }	Gets the error message for the specified code.
public file getfileneedingupdate ( int index ) { checkutilities . checkintindexinlistrange ( filesneedingupdate , index ) ; return filesneedingupdate . get ( index ) ; }	Gets the file at the specified index from the list of files needing update.
public void addtodeletedfilestocommit ( file file ) { deletedfilestocommit . add ( file ) ; filetostatus . put ( file , status . deleted_to_commit ) ; }	Adds a file to list of files that are deleted and will be committed next time&lt;git-commit&gt; is run.
public void addtodeletedfilesnotupdated ( file file ) { deletedfilesnotupdated . add ( file ) ; filetostatus . put ( file , status . deleted ) ; }	Adds a file to the list of files that are deleted locally but not yet deleted from index using&lt;git-rm&gt; command.
public void addtomodifiedfilestocommit ( file file ) { modifiedfilestocommit . add ( file ) ; filetostatus . put ( file , status . modified_to_commit ) ; }	Adds a file to list of files that are modified and will be committed next time&lt;git-commit&gt; is run.
public void addtomodifiedfilesnotupdated ( file file ) { modifiedfilesnotupdated . add ( file ) ; filetostatus . put ( file , status . modified ) ; }	Adds a file to the list of files that are modified files but not yet updated.
public void addtonewfilestocommit ( file file ) { newfilestocommit . add ( file ) ; filetostatus . put ( file , status . new_to_commit ) ; }	Adds a file to the list of new files that are ready to be committed next time &lt;git-commit&gt;command is run.
public void addtorenamedfilestocommit ( file file ) { renamedfilestocommit . add ( file ) ; filetostatus . put ( file , status . renamed_to_commit ) ; }	Adds a file to the list of renamed files that are ready to be committed next time &lt;git-commit&gt;command is run.
public void addtountrackedfiles ( file file ) { untrackedfiles . add ( file ) ; filetostatus . put ( file , status . untracked ) ; }	Adds a file to list of files that have been added locally but not yet added to the index.
public string getstringvalue ( databinder binder ) {	Get the string value from binder.
public void setoptverbose ( boolean optverbose ) { checkcansetnoargoption ( str_ ) ; if ( ( bool_ == optverbose ) && ( optabbrev || optnoabbrev ) ) { throw new illegalargumentexception ( exceptionmessagemap . getmessage ( str_ ) + str_ ) ; } this . optverbose = optverbose ; }	Checks whether the verbose option should be set and sets it.
public void setoptdlower ( boolean optdlower ) { checkcansetdeleteoption ( str_ ) ; if ( optdlower && optdupper ) { throw new illegalargumentexception ( exceptionmessagemap . getmessage ( str_ ) + str_ ) ; } this . optdlower = optdlower ; }	Checks whether the -d option should be set and sets it.
public void setoptdupper ( boolean optdupper ) { checkcansetdeleteoption ( str_ ) ; if ( optdlower && optdupper ) { throw new illegalargumentexception ( exceptionmessagemap . getmessage ( str_ ) + str_ ) ; } this . optdupper = optdupper ; }	Checks whether the -D option should be set and sets it.
public void setoptmlower ( boolean optmlower ) { checkcansetrenameoption ( str_ ) ; if ( optmlower && optmupper ) { throw new illegalargumentexception ( exceptionmessagemap . getmessage ( str_ ) + str_ ) ; } this . optmlower = optmlower ; }	Checks whether the -m option should be set and sets it.
public void setoptmupper ( boolean optmupper ) { checkcansetrenameoption ( str_ ) ; if ( optmlower && optmupper ) { throw new illegalargumentexception ( exceptionmessagemap . getmessage ( str_ ) + str_ ) ; } this . optmupper = optmupper ; }	Checks whether the -M option should be set and sets it.
public integer getfunctionreturntype ( method m ) { class < ? > type = m . getreturntype ( ) ; if ( type == void . class || type == void . class ) { return return_void ; } if ( type == boolean . class || type == boolean . class ) { return return_boolean ; } if ( type == integer . class || type == int . class || type == long . class || type == long . class ) { return return_integer ; } if ( type == float . class || type == float . class || type == double . class || type == double . class ) { return return_float ; } return return_string ; }	Get idoc function return type.
public boolean evaluatefunction ( scriptinfo info , object [ ] args , executioncontext context ) throws serviceexception { int config [ ] = ( int [ ] ) info . m_entry ; string functioncalled = info . m_key ; int functionindex = config [ num_ ] ; int nargs = args . length - num_ ; int allowedparams = config [ num_ ] ; if ( allowedparams >= num_ && allowedparams != nargs ) { string msg = localeutils . encodemessage ( str_ , null , functioncalled , str_ + allowedparams ) ; throw new illegalargumentexception ( msg ) ; } userdata userdata = ( userdata ) context . getcachedobject ( str_ ) ; if ( userdata == null ) { string msg = localeutils . encodemessage ( str_ , null , functioncalled ) ; throw new serviceexception ( msg ) ; } if ( functionindex > m_functiontable . length ) { systemutils . trace ( str_ , str_ + functionindex ) ; return bool_ ; } try { args [ nargs ] = runfunctionmethod ( functionindex , args , context ) ; } catch ( exception e ) { string msg = e . getmessage ( ) ; if ( e instanceof invocationtargetexception ) { msg = ( ( invocationtargetexception ) e ) . gettargetexception ( ) . getmessage ( ) ; } msg = str_ + functioncalled + str_ + msg ; systemutils . err ( e , msg ) ; systemutils . trace ( str_ , msg ) ; throw new serviceexception ( e ) ; }	This is where the custom IdocScript function is evaluated.
public object [ ] getinjectedvaluearray ( method method , object [ ] args , executioncontext ctx ) throws illegalargumentexception , serviceexception { parametermarshaller marshaller = new parametermarshaller ( method ) ; if ( ( ctx instanceof service ) == bool_ ) { throw new serviceexception ( str_ ) ; } return marshaller . getvaluearray ( args , ( service ) ctx ) ; }	Enumerates the correct parameters for the delegated method.
public object runfunctionmethod ( int functionindex , object [ ] args , executioncontext ctx ) throws securityexception , nosuchmethodexception , illegalargumentexception , serviceexception , illegalaccessexception , invocationtargetexception { method method = functionmethods [ functionindex ] ; object params [ ] = getinjectedvaluearray ( method , args , ctx ) ; object result ; try { result = method . invoke ( m_class . newinstance ( ) , params ) ; } catch ( instantiationexception e ) {	Executes the annotated method.
private object convertreturnvalue ( object result ) { if ( boolean . class . isinstance ( result ) || result instanceof boolean ) { return scriptextensionutils . computereturnobject ( num_ , ( ( boolean ) result ) . booleanvalue ( ) , num_ , num_ , null ) ; } else if ( long . class . isinstance ( result ) ) { return ( long ) result ; } else if ( int . class . isinstance ( result ) || result instanceof integer ) { return new long ( ( integer ) result ) ; } else if ( double . class . isinstance ( result ) ) { return ( double ) result ; }	Convert the method return value into a PageMerger internal type of String,Long or Double.
public boolean evaluatevalue ( scriptinfo info , boolean [ ] returnbool , string [ ] returnstring , executioncontext context , boolean isconditional ) throws serviceexception { int config [ ] = ( int [ ] ) info . m_entry ; string key = info . m_key ; if ( ( context instanceof service ) == bool_ ) {	This is where the custom IdocScript variable is evaluated.
public gitbranchresponse branch ( file repositorypath ) throws ioexception , javagitexception { checkutilities . checknullargument ( repositorypath , str_ ) ; iclient client = clientmanager . getinstance ( ) . getpreferredclient ( ) ; igitbranch gitbranch = client . getgitbranchinstance ( ) ; return gitbranch . branch ( repositorypath ) ; }	Does a basic git-branch without any options.
public gitcommitresponse commit ( string comment ) throws ioexception , javagitexception { gitcommit gitcommit = new gitcommit ( ) ; return gitcommit . commit ( path , comment ) ; }	Commits the objects specified in the index to the repository.
public ref getcurrentbranch ( ) throws ioexception , javagitexception { gitbranch gitbranch = new gitbranch ( ) ; gitbranchoptions options = new gitbranchoptions ( ) ; gitbranchresponse response = gitbranch . branch ( path , options ) ; return response . getcurrentbranch ( ) ; }	Gets the currently checked-out branch of the working directory.
public void checkout ( ref ref ) throws ioexception , javagitexception { gitcheckout gitcheckout = new gitcheckout ( ) ; gitcheckout . checkout ( path , null , ref ) ;	Switches to a new branch.
public gitstatusresponse getstatus ( ) throws ioexception , javagitexception { gitstatus gitstatus = new gitstatus ( ) ; return gitstatus . status ( path ) ; }	Gets the status of all files in the working directory.
public file getfilefromnewfilestocommit ( int index ) { checkutilities . checkintindexinlistrange ( newfilestocommit , index ) ; return newfilestocommit . get ( index ) ; }	Get the name of the file from newFilesToCommit list at a given index.
public file getfilefromdeletedfilestocommit ( int index ) { checkutilities . checkintindexinlistrange ( deletedfilestocommit , index ) ; return deletedfilestocommit . get ( index ) ; }	Get the name of the deleted file that will be committed next time git-commit is executedcurrently located at the given index in the list.
public file getfilefrommodifiedfilestocommit ( int index ) { checkutilities . checkintindexinlistrange ( modifiedfilestocommit , index ) ; return modifiedfilestocommit . get ( index ) ; }	Get the name of the file that is modified and added to the repository by &lt;git-add&gt;command and will be committed to repository next time &lt;git-commit&gt; is executed.
public file getfilefromdeletedfilesnotupdated ( int index ) { checkutilities . checkintindexinlistrange ( deletedfilesnotupdated , index ) ; return deletedfilesnotupdated . get ( index ) ; }	Returns the name of the deleted file that is removed locally but not yet removed fromrepository.
public file getfilefrommodifiedfilesnotupdated ( int index ) { checkutilities . checkintindexinlistrange ( modifiedfilesnotupdated , index ) ; return modifiedfilesnotupdated . get ( index ) ; }	Returns the name of the file that is existing in the repository and has been locally modified.This file is one of the files that has been locally modified and is located at given index inthe list.
public file getfilefromuntrackedfiles ( int index ) { checkutilities . checkintindexinlistrange ( untrackedfiles , index ) ; return untrackedfiles . get ( index ) ; }	Returns the name of the file at the specified index that has been created locally but has notyet been added to the repository by &lt;git-add&gt;.
public file getfilefromrenamedfiles ( int index ) { checkutilities . checkintindexinlistrange ( renamedfilestocommit , index ) ; return renamedfilestocommit . get ( index ) ; }	Returns the file at the specified index in the list of renamed files.
public string geterror ( int index ) { if ( index < errors . size ( ) ) { errordetails errordetails = errors . get ( index ) ; return errordetails . linenumber + str_ + errordetails . error ; } return null ; }	Returns the error message otherwise returns null;.
public string geterror ( ) { stringbuilder strbuilder = new stringbuilder ( ) ; for ( int i = num_ ; i < errors . size ( ) ; i ++ ) { strbuilder . append ( geterror ( i ) + str_ ) ; } return strbuilder . tostring ( ) ; }	Gets all the errors generated by &lt;git-status&gt; command and returns them in String format.
public boolean addaddedfile ( file pathtofile , string mode ) { if ( null == pathtofile ) { return bool_ ; } return addedfiles . add ( new addedordeletedfile ( pathtofile , mode ) ) ; }	Add the information about a newly added file in the repository for a given commit.
public boolean addcopiedfile ( file sourcefilepath , file destinationfilepath , int percentage ) { if ( null == sourcefilepath || null == destinationfilepath ) { return bool_ ; } return copiedfiles . add ( new copiedormovedfile ( sourcefilepath , destinationfilepath , percentage ) ) ; }	Add the information about a newly copied file in the repository for a given commit.
public boolean adddeletedfile ( file pathtofile , string mode ) { if ( null == pathtofile ) { return bool_ ; } return deletedfiles . add ( new addedordeletedfile ( pathtofile , mode ) ) ; }	Add the information about a file deleted from the repository for a given commit.
public boolean setfileschanged ( string fileschangedstr ) { try { this . fileschanged = integer . parseint ( fileschangedstr ) ; return bool_ ; } catch ( numberformatexception e ) { return bool_ ; } }	Sets the number of files changed during a commit.
public boolean setlinesdeleted ( string linesdeletedstr ) { try { this . linesdeleted = integer . parseint ( linesdeletedstr ) ; return bool_ ; } catch ( numberformatexception e ) { return bool_ ; } }	Sets the number of lines deleted in a commit.
public boolean setlinesinserted ( string linesinsertedstr ) { try { this . linesinserted = integer . parseint ( linesinsertedstr ) ; return bool_ ; } catch ( numberformatexception e ) { return bool_ ; } }	Sets the number of lines inserted in a commit.
public static int indexofleft ( string str , int from , char c ) { int pos = - num_ ; int f = from ; while ( f >= num_ && pos == - num_ ) if ( str . charat ( f -- ) == c ) pos = f + num_ ; return pos ; }	Returns the position for char 'c' in string 'str' starting from position 'pos'and searching towards the string beginning.
private dataresultset getresultset ( string name , service service ) { resultset rs = service . getbinder ( ) . getresultset ( name ) ; dataresultset drs = new dataresultset ( ) ; if ( rs != null ) { drs . copy ( rs ) ; return drs ; } return null ; }	Find a result set in the service binder.
public list < commit > log ( file repositorypath , gitlogoptions options ) throws javagitexception , ioexception { checkutilities . checkfilevalidity ( repositorypath ) ; gitlogparser parser = new gitlogparser ( ) ; list < string > command = buildcommand ( repositorypath , options ) ; gitlogresponse response = ( gitlogresponse ) processutilities . runcommand ( repositorypath , command , parser ) ; if ( response . containserror ( ) ) { int line = response . geterror ( num_ ) . getlinenumber ( ) ; string error = response . geterror ( num_ ) . error ( ) ; throw new javagitexception ( num_ , str_ + line + str_ + error ) ; } return response . getlog ( ) ; }	Implementations of &lt;git log&gt; with options and one file to be added to index.
public void addcommit ( ) { if ( this . sha != null ) { commit commit = new commit ( this . sha , this . mergedetails , this . author , this . datestring , this . message , this . files ) ; if ( commitlist == null ) { commitlist = new arraylist < commit > ( ) ; } this . commitlist . add ( commit ) ;	This add a newly created commit object to the list of commits for a log.
public void addfile ( string filename , int linesadded , int linesdeleted ) { commitfile commitfile = new commitfile ( filename , linesadded , linesdeleted ) ; if ( files == null ) { files = new arraylist < commitfile > ( ) ; } this . files . add ( commitfile ) ; }	This adds a file to the list of files affected by a particular commit.
public gitcheckoutresponse checkout ( file repositorypath , gitcheckoutoptions options , ref ref ) throws javagitexception , ioexception { checkutilities . checkfilevalidity ( repositorypath ) ; checkrefagainstreftype ( ref , reftype . head ) ; list < string > command = buildcommand ( options , ref ) ; gitcheckoutparser parser = new gitcheckoutparser ( ) ; gitcheckoutresponse response = ( gitcheckoutresponse ) processutilities . runcommand ( repositorypath , command , parser ) ; return response ; }	Git checkout with options and base branch information provided to &lt;git-checkout&gt; command.
public gitcheckoutresponse checkout ( file repositorypath ) throws javagitexception , ioexception { gitcheckoutoptions options = null ; return checkout ( repositorypath , options , null ) ; }	Git checkout without any options and branch information provided.
public gitcheckoutresponse checkout ( file repositorypath , ref branch ) throws javagitexception , ioexception { return checkout ( repositorypath , null , branch ) ; }	Checks out a branch from the git repository with a given branch name.
public gitcheckoutresponse checkout ( file repositorypath , list < file > paths ) throws javagitexception , ioexception { checkutilities . checkfilevalidity ( repositorypath ) ; checkutilities . checknulllistargument ( paths , str_ ) ; gitcheckoutparser parser = new gitcheckoutparser ( ) ; list < string > command = buildcommand ( null , null , paths ) ; gitcheckoutresponse response = ( gitcheckoutresponse ) processutilities . runcommand ( repositorypath , command , parser ) ; return response ; }	Checks out a list of files from repository, no checkout options provided.
public gitcheckoutresponse checkout ( file repositorypath , gitcheckoutoptions options , ref ref , list < file > paths ) throws javagitexception , ioexception { checkutilities . checkfilevalidity ( repositorypath ) ; if ( ref != null && ref . getreftype ( ) == reftype . head ) { throw new illegalargumentexception ( str_ ) ; } gitcheckoutparser parser = new gitcheckoutparser ( ) ; list < string > command = buildcommand ( options , ref , paths ) ; return ( gitcheckoutresponse ) processutilities . runcommand ( repositorypath , command , parser ) ; }	Checks out a list of file from repository, with &lt;tree-ish&gt; options provided.
public gitcheckoutresponse checkout ( file repositorypath , gitcheckoutoptions options , ref branch , file path ) throws javagitexception , ioexception { checkutilities . checkfilevalidity ( repositorypath ) ; gitcheckoutparser parser = new gitcheckoutparser ( ) ; list < file > paths = new arraylist < file > ( ) ; paths . add ( path ) ; list < string > command = buildcommand ( options , branch , paths ) ; gitcheckoutresponse response = ( gitcheckoutresponse ) processutilities . runcommand ( repositorypath , command , parser ) ; return response ; }	Checks out a file from repository from a particular branch.
private void checkrefagainstreftype ( ref ref , reftype reftype ) { if ( ref != null && ref . getreftype ( ) == reftype ) { throw new illegalargumentexception ( str_ ) ; } }	This is just a test method for verifying that a given ref is not of refType provided as one of the parameters.
public list < gitfilesystemobject > getchildren ( ) throws ioexception , javagitexception { list < gitfilesystemobject > children = new arraylist < gitfilesystemobject > ( ) ;	Gets the children of this directory.
public file getremovedfile ( int index ) { checkutilities . checkintindexinlistrange ( removedfiles , index ) ; return removedfiles . get ( index ) ; }	Gets the file at the specified index from the removed file list.
public gitcheckoutresponse checkout ( file repositorypath , list < file > paths ) throws ioexception , javagitexception { checkutilities . checkfilevalidity ( repositorypath ) ; checkutilities . checknulllistargument ( paths , str_ ) ; iclient client = clientmanager . getinstance ( ) . getpreferredclient ( ) ; igitcheckout gitcheckout = client . getgitcheckoutinstance ( ) ; return gitcheckout . checkout ( repositorypath , paths ) ; }	For checking a file or list of files from a branch.
public gitcheckoutresponse checkout ( file repositorypath , ref ref , list < file > paths ) throws javagitexception , ioexception { checkutilities . checkfilevalidity ( repositorypath ) ; if ( ref != null && ( ref . getreftype ( ) != reftype . branch && ref . getreftype ( ) != reftype . sha1 ) ) { throw new javagitexception ( num_ , exceptionmessagemap . getmessage ( str_ ) + str_ + ref . getreftype ( ) ) ; } checkutilities . checknulllistargument ( paths , str_ ) ; iclient client = clientmanager . getinstance ( ) . getpreferredclient ( ) ; igitcheckout gitcheckout = client . getgitcheckoutinstance ( ) ; return gitcheckout . checkout ( repositorypath , ref , paths ) ; }	Checks out files from the repository when a tree-ish object is given as the reference.
public void setcomment ( int linenumber , string commentstring ) { responsestring comment = new responsestring ( linenumber , commentstring ) ; comments . add ( comment ) ; }	Sets the non-error message generated in the output of the &lt;git-add&gt; command.
public void setdeleteoptions ( gitbranchoptions options , boolean forcedelete , boolean remote ) { if ( forcedelete ) { options . setoptdupper ( bool_ ) ; } else { options . setoptdlower ( bool_ ) ; } if ( remote ) { options . setoptr ( bool_ ) ; } }	Sets the options for delete.
@ override public void inject ( class < ? > klass ) throws dataexception { method [ ] classmethods = klass . getmethods ( ) ; for ( method method : classmethods ) { servicemethod annotation = ( servicemethod ) method . getannotation ( servicemethod . class ) ; if ( annotation != null ) { injectservicemethod ( method , annotation ) ; } } }	Inject a service into the service manager registry.
private static void injectservicemethod ( method method , servicemethod annotation ) throws dataexception { servicedata servicedata = new servicedata ( ) ; string template = annotation . template ( ) ; int accesslevel = annotation . accesslevel ( ) ; string servicetype = ( ! annotation . type ( ) . equals ( str_ ) ) ? annotation . type ( ) : null ; string errormessage = annotation . errormessage ( ) ; string subjects = annotation . subjects ( ) ; string servicename = annotation . name ( ) ; try { servicedata . init ( servicename , serviceproxy . class . getname ( ) , accesslevel , template , servicetype , errormessage , subjects ) ; } catch ( exception e ) { throw new dataexception ( str_ + servicename + str_ + e . getmessage ( ) ) ; }	Injects a single UCMService annotation into the ServiceManager registry.
public void setoptb ( ref newbranch ) { checkutilities . validateargumentreftype ( newbranch , reftype . branch , str_ ) ; optb = newbranch ; }	Sets the name of the new branch that need to be created from the base branch.
public int dofilter ( workspace ws , databinder binder , executioncontext ctx ) throws dataexception , serviceexception { string configfilename = ( string ) ctx . getcachedobject ( str_ ) ; try { classloader cl = getclass ( ) . getclassloader ( ) ; enumeration < url > propfiles = cl . getresources ( configfilename ) ;	Begins injection of filters, including the Service and IdocScript injectorsrequired to load other ucm entities.
private enumeration < url > getresources11g ( classloader classloader , string configfilename ) { list < url > newprops = new arraylist < url > ( ) ; if ( classloader . getclass ( ) . getsimplename ( ) . equalsignorecase ( str_ ) ) { try { field field = classloader . getclass ( ) . getfield ( str_ ) ; @ suppresswarnings ( str_ ) map < string , idczipfile > zipfiles = ( map < string , idczipfile > ) field . get ( classloader ) ; for ( entry < string , idczipfile > entry : zipfiles . entryset ( ) ) { if ( entry . getvalue ( ) . m_entries . get ( configfilename ) != null ) { string jarfile = entry . getkey ( ) ;	Replacement for getResources which works on 11g. The UCM 11G {.
private void setup ( resettype resettype , ref commitname ) { checkutilities . checknullargument ( resettype , str_ ) ; checkutilities . checknullargument ( commitname , str_ ) ; this . resettype = resettype ; this . commitname = commitname ; }	Central instance construction setup method.
public static string addmethod ( method m ) { if ( methods == null ) { methods = new hashmap < string , method > ( ) ; } string hashcode = string . valueof ( m . hashcode ( ) ) ; if ( ! methods . containskey ( hashcode ) ) { methods . put ( hashcode , m ) ; } return string . valueof ( m . hashcode ( ) ) ; }	Adds a method to the registry and returns the UUID.
public int dofilter ( workspace ws , databinder binder , executioncontext ctx ) throws dataexception , serviceexception { object returnval = null ; try { string methodid = ( string ) ctx . getcachedobject ( str_ ) ; method m = methodregistry . getmethod ( methodid ) ; parametermarshaller marshaller = new parametermarshaller ( m ) ; object [ ] params = marshaller . getvaluearray ( ws , binder , ctx ) ; object context = m . getdeclaringclass ( ) . newinstance ( ) ; returnval = m . invoke ( context , params ) ; } catch ( illegalargumentexception e ) { throw new dataexception ( e . getmessage ( ) , e ) ; } catch ( exception e ) { throw new serviceexception ( e . getmessage ( ) , e ) ; } if ( returnval != null && returnval instanceof integer ) { return ( ( integer ) returnval ) . intvalue ( ) ; } return continue ; }	Main entry point which will delegate to the filter method with dependencyinjection.
public void reducedatabaseconnection ( ) { synchronized ( lock ) { int numberofopenconnections = open_connections . decrementandget ( ) ; if ( numberofopenconnections == num_ && dbconnection != null ) { dbconnection . close ( ) ; dbconnection = null ; } } }	Reduce the connection opened.
public void consumedatabase ( dbconsumer dbconsumer ) { sqlitedatabase db = getdatabaseconnection ( ) ; try { dbconsumer . consume ( db ) ; } finally { reducedatabaseconnection ( ) ; } }	Execute an action on the database.
public cursor query ( string table , string [ ] columns , string selection , string [ ] selectionargs , string groupby , string having , string orderby ) { sqlitedatabase db = getdatabaseconnection ( ) ; return new dbclosingcursor ( db . query ( table , columns , selection , selectionargs , groupby , having , orderby ) , this ) ; }	Executes a query on the database.
public cursor rawquery ( string sql ) { sqlitedatabase db = getdatabaseconnection ( ) ; return new dbclosingcursor ( db . rawquery ( sql , null ) , this ) ; }	Executes a raw query on the database.
private list < string > buildcommandline ( gitrmoptions options , file path , list < file > paths ) { list < string > cmdline = new arraylist < string > ( ) ; cmdline . add ( javagitconfiguration . getgitcommand ( ) ) ; cmdline . add ( str_ ) ; if ( null != options ) { if ( options . isoptcached ( ) ) { cmdline . add ( str_ ) ; } if ( options . isoptf ( ) ) { cmdline . add ( str_ ) ; } if ( options . isoptn ( ) ) { cmdline . add ( str_ ) ; } if ( options . isoptq ( ) ) { cmdline . add ( str_ ) ; } if ( options . isoptr ( ) ) { cmdline . add ( str_ ) ; } } if ( null != path ) { cmdline . add ( path . getpath ( ) ) ; } else { for ( file f : paths ) { cmdline . add ( f . getpath ( ) ) ; } } return cmdline ; }	Builds the command line.
public file getaddedfile ( int index ) { checkutilities . checkintindexinlistrange ( addedfiles , index ) ; return addedfiles . get ( index ) ; }	Returns the file at a given location in the addedFiles list.
public file getdeletedfile ( int index ) { checkutilities . checkintindexinlistrange ( deletedfiles , index ) ; return deletedfiles . get ( index ) ; }	Returns the file at a given location in the deletedFiles list.
public file getmodifiedfile ( int index ) { checkutilities . checkintindexinlistrange ( modifiedfiles , index ) ; return modifiedfiles . get ( index ) ; }	Returns the file at a given location in the modifiedFiles list.
public status getstatus ( ) throws ioexception , javagitexception { gitstatus gitstatus = new gitstatus ( ) ;	Show object's status in the working directory.
protected static headelement gethead ( ) { if ( head == null ) { final element element = document . get ( ) . getelementsbytagname ( str_ ) . getitem ( num_ ) ; assert element != null : str_ ; final headelement head = headelement . as ( element ) ; abstractinjector . head = head ; } return abstractinjector . head ; }	Gets the document header.
public arraylist < file > getfiles ( ) {	Return array if all files added to dropzone.
public int getfilescount ( ) { final jsarray < filejs > files = getfilesnative ( getelement ( ) ) ; return files != null ? files . length ( ) : num_ ; }	Return number of added files.
public boolean matches ( string string ) { string src = string ; final boolean result ; if ( _compiledpattern . length == num_ ) {	Match the given string.
@ override protected void updatelistafterhit ( cacheentry < k , v > entry ) { if ( entry != null && ! entry . equals ( _first ) ) { if ( entry . equals ( _last ) ) { setlast ( entry . getprevious ( ) ) ; } else { final cacheentry < k , v > previous = entry . getprevious ( ) ; final cacheentry < k , v > next = entry . getnext ( ) ; previous . setnext ( next ) ; next . setprevious ( previous ) ; } _first . setprevious ( entry ) ; entry . setnext ( _first ) ; setfirst ( entry ) ; } }	Move the entry to the beginning of the LinkedList.
protected void removelast ( ) { final cacheentry < k , v > entry ; synchronized ( _lock ) { if ( _last != null ) { entry = _entries . remove ( _last . getkey ( ) ) ; setlast ( _last . getprevious ( ) ) ; } else { entry = null ; } if ( size ( ) == num_ ) { _first = null ; _last = null ; } } if ( entry != null ) { handleremove ( entry ) ; } }	Remove the last element from the cache.
@ suppresswarnings ( str_ ) public void cleanuplifetimeexpired ( ) { final long currenttime = currenttimemillis ( ) ;	Remove entries that are out of their maxLifetime.
@ override protected void updatelistafterhit ( cacheentry < k , v > entry ) { if ( entry != null && ! entry . equals ( _first ) ) { if ( entry . gethits ( ) > entry . getprevious ( ) . gethits ( ) ) {	Resort the linked list.
public static boolean startswith ( char [ ] src , char [ ] find , int startat ) { int startpos = startat ; boolean result = bool_ ;	Test whether 'find' can be found at position 'startPos' in the string 'src'.
@ override public token getaccesstoken ( token requesttoken , verifier verifier ) { oauthrequest request = new proxyoauthrequest ( this . api . getaccesstokenverb ( ) , this . api . getaccesstokenendpoint ( ) , this . proxyhost , this . proxyport ) ; string userpass = this . config . getapikey ( ) + str_ + this . config . getapisecret ( ) ; string basicauth = str_ + javax . xml . bind . datatypeconverter . printbase64binary ( userpass . getbytes ( ) ) ; request . addheader ( str_ , basicauth ) ; request . addbodyparameter ( str_ , str_ ) ; request . addbodyparameter ( str_ , verifier . getvalue ( ) ) ; request . addbodyparameter ( str_ , config . getcallback ( ) ) ; response response = request . send ( ) ; string body = response . getbody ( ) ; jsonnode json = jsonhelper . getfirstnode ( body ) ; if ( json != null ) { return new token ( ( string ) jsonhelper . get ( json , str_ ) , str_ , body ) ; } else { return null ; } }	Makes the call to request an access token for an authorized user.
@ override public void signrequest ( token accesstoken , oauthrequest request ) { request . addheader ( str_ , str_ + accesstoken . gettoken ( ) ) ; }	Adds an authorization header containing the bearer token to a request.It is intended for use in API calls after getting the access token, suchas requesting the user's profile.
@ override public string getauthorizationurl ( oauthconfig config ) { preconditions . checkvalidurl ( config . getcallback ( ) , str_ ) ; return string . format ( authorize_url , config . getapikey ( ) , oauthencoder . encode ( config . getcallback ( ) ) , scopes ) ; }	Returns the URL for authorizing the user.
public boolean performfinish ( ) { final string containername = getprojectname ( ) ; final ipath location = projectpage . usedefaults ( ) ? null : projectpage . getlocationpath ( ) ; irunnablewithprogress op = new irunnablewithprogress ( ) { public void run ( iprogressmonitor monitor ) throws invocationtargetexception { try { dofinish ( containername , location , monitor ) ; } catch ( coreexception e ) { throw new invocationtargetexception ( e ) ; } finally { monitor . done ( ) ; } } } ; try { getcontainer ( ) . run ( bool_ , bool_ , op ) ; } catch ( interruptedexception e ) { return bool_ ; } catch ( invocationtargetexception e ) { throwable realexception = e . gettargetexception ( ) ; messagedialog . openerror ( getshell ( ) , str_ , realexception . getmessage ( ) ) ; return bool_ ; } return bool_ ; }	This method is called when 'Finish' button is pressed in the wizard.
private void dofinish ( string containername , ipath location , iprogressmonitor monitor ) throws coreexception {	The worker method. It will find the container, create the file if missingor just replace its contents, and open the editor on the newly createdfile.
public void createcontrol ( composite parent ) { composite composite = new composite ( parent , swt . null ) ; composite . setlayout ( new gridlayout ( num_ , bool_ ) ) ; createartifactgroup ( composite ) ; createpropertiesgroup ( composite ) ; setarchetype ( ) ; validate ( ) ; setcontrol ( composite ) ; }	Creates page controls.
protected string getdefaultjavapackage ( ) { return projectwizardparameterspage . getdefaultjavapackage ( groupidcombo . gettext ( ) . trim ( ) , artifactidcombo . gettext ( ) . trim ( ) ) ; }	Returns the default package name.
public void setvisible ( boolean visible ) { super . setvisible ( visible ) ; boolean shouldvalidate = bool_ ; if ( visible ) { if ( groupidcombo . gettext ( ) . length ( ) == num_ && groupidcombo . getitemcount ( ) > num_ ) { groupidcombo . settext ( groupidcombo . getitem ( num_ ) ) ; packagecombo . settext ( getdefaultjavapackage ( ) ) ; packagecustomized = bool_ ; } if ( shouldvalidate ) { validate ( ) ; } } }	Loads the group value when the page is displayed.
public string createquerydebugstring ( ) {	Creates a human-readable representation of the query that will be createdfrom this builder.
private list < object > getqueryparametersaslist ( ) {	Creates an ordered list of all parameter values registered atthe root criteria.
public void createpartcontrol ( composite parent ) { viewer = new paletteviewer ( ) ; viewer . createcontrol ( parent ) ; paletteroot root = new paletteroot ( ) ; string [ ] category = getcategories ( ) ; for ( int i = num_ ; i < category . length ; i ++ ) { palettedrawer group = new palettedrawer ( category [ i ] ) ; ipaletteitem [ ] items = getpaletteitems ( category [ i ] ) ; for ( int j = num_ ; j < items . length ; j ++ ) { htmlpaletteentry entry = new htmlpaletteentry ( items [ j ] . getlabel ( ) , null , items [ j ] . getimagedescriptor ( ) ) ; tools . put ( entry , items [ j ] ) ; group . add ( entry ) ; } root . add ( group ) ; } viewer . setpaletteroot ( root ) ; viewer . getcontrol ( ) . addmouselistener ( new mouseadapter ( ) { @ override public void mousedoubleclick ( mouseevent e ) {	create controls and apply configurations.
private void addpaletteitem ( string category , ipaletteitem item ) { if ( items . get ( category ) == null ) { list < ipaletteitem > list = new arraylist < ipaletteitem > ( ) ; items . put ( category , list ) ; } list < ipaletteitem > list = items . get ( category ) ; list . add ( item ) ; }	Adds PaletteItem to the specified category.
private ipaletteitem [ ] getpaletteitems ( string category ) { list < ipaletteitem > list = items . get ( category ) ; if ( list == null ) { return new ipaletteitem [ num_ ] ; } return list . toarray ( new ipaletteitem [ list . size ( ) ] ) ; }	Returns PaletteItems which are contained by the specified category.
private void configuretableresizing ( final composite parent , final table table , final tablecolumn column1 , final tablecolumn column2 ) { parent . addcontrollistener ( new controladapter ( ) { public void controlresized ( controlevent e ) { rectangle area = parent . getclientarea ( ) ; point preferredsize = table . computesize ( swt . default , swt . default ) ; int width = area . width - num_ * table . getborderwidth ( ) ; if ( preferredsize . y > area . height ) {	Correctly resizes the table so no phantom columns appear.
private template getselectedtemplate ( ) { template template = null ; istructuredselection selection = ( istructuredselection ) ftableviewer . getselection ( ) ; if ( selection . size ( ) == num_ ) { template = ( template ) selection . getfirstelement ( ) ; } return template ; }	Get the currently selected template.
string gettemplatestring ( ) { string templatestring = null ; template template = getselectedtemplate ( ) ; if ( template != null ) { templatecontexttype contexttype = glassmakeruiplugin . getdefault ( ) . gettemplatecontextregistry ( ) . getcontexttype ( cardcontexttype . context_type ) ; idocument document = new document ( ) ; templatecontext context = new documenttemplatecontext ( contexttype , document , num_ , num_ ) ; try { templatebuffer buffer = context . evaluate ( template ) ; templatestring = buffer . getstring ( ) ; } catch ( exception e ) { glassmakeruiplugin . logerror ( str_ , e ) ; } } return templatestring ; }	Returns template string to insert.
private void loadlastsavedpreferences ( ) { flastselectedtemplatename = str_ ;	Load the last template name used in New HTML File wizard.
void savelastsavedpreferences ( ) { string templatename = str_ ;	Save template name used for next call to New HTML File wizard.
private void setselectedtemplate ( string templatename ) { object template = null ; if ( templatename != null && templatename . length ( ) > num_ ) {	Select a template in the table viewer given the template name.
void updateviewerinput ( ) { template template = getselectedtemplate ( ) ; if ( template != null ) { fpatternviewer . getdocument ( ) . set ( template . getpattern ( ) ) ; string imageid = str_ + template . getname ( ) . replace ( str_ , str_ ) . tolowercase ( ) ; imagedescriptor desc = imageregistry . getdescriptor ( imageid ) ; if ( desc != null ) { fimage . setimage ( desc . createimage ( ) ) ; } else { fimage . setimage ( null ) ; } } else { fpatternviewer . getdocument ( ) . set ( str_ ) ;	Updates the pattern viewer.
public static criterion in ( string relativepath , collection < ? > values ) { return new inexpression ( relativepath , values . toarray ( ) ) ; }	Adds an "in" restriction to a persistent field.
public static criterion memberof ( string relativepath , object value ) { return new memberofexpression ( relativepath , value , bool_ ) ; }	Creates a "member of" restriction.
public static criterion notmemberof ( string relativepath , object value ) { return new memberofexpression ( relativepath , value , bool_ ) ; }	Creates a "not member of" restriction.
public void createfieldeditors ( ) { addfield ( new stringfieldeditor ( preferenceconstants . client_id , str_ , getfieldeditorparent ( ) ) ) ; addfield ( new stringfieldeditor ( preferenceconstants . client_secret , str_ , getfieldeditorparent ( ) ) ) ; }	Creates the field editors.
public static string getlastpathcomponent ( string path ) {	Returns the last component of a dot-separated path.
protected void initialpopulatecontainernamefield ( ) { super . initialpopulatecontainernamefield ( ) ; ipath fullpath = getcontainerfullpath ( ) ; iproject project = getprojectfrompath ( fullpath ) ; ipath root = projectutils . getrootcontainerforpath ( project , fullpath ) ; if ( root != null ) { return ; } root = projectutils . getdefaultrootcontainer ( project ) ; if ( root != null ) { setcontainerfullpath ( root ) ; return ; } }	This method is overridden to set the selected folder to web contentsfolder if the current selection is outside the web contents folder.
protected boolean validatepage ( ) { setmessage ( null ) ; seterrormessage ( null ) ; if ( ! super . validatepage ( ) ) { return bool_ ; } string filename = getfilename ( ) ; ipath fullpath = getcontainerfullpath ( ) ; if ( ( fullpath != null ) && ( fullpath . isempty ( ) == bool_ ) && ( filename != null ) ) {	This method is overridden to set additional validation specific to htmlfiles.
private boolean extensionvalidforcontenttype ( string filename ) { boolean valid = bool_ ; icontenttype type = getcontenttype ( ) ;	Verifies if fileName is valid name for content type.
string adddefaultextension ( string filename ) { stringbuffer newfilename = new stringbuffer ( filename ) ; string ext = str_ ; newfilename . append ( str_ ) ;	Adds default extension to the filename.
private iproject getprojectfrompath ( ipath path ) { iworkspace workspace = resourcesplugin . getworkspace ( ) ; iproject project = null ; if ( path != null ) { if ( workspace . validatepath ( path . tostring ( ) , iresource . project ) . isok ( ) ) { project = workspace . getroot ( ) . getproject ( path . tostring ( ) ) ; } else { project = workspace . getroot ( ) . getfile ( path ) . getproject ( ) ; } } return project ; }	Returns the project that contains the specified path.
public string getuserid ( httpservletrequest request ) { httpsession session = request . getsession ( ) ; return ( string ) session . getattribute ( str_ ) ; }	Get the current user's ID from the session.
void createpage0 ( ) { try { texteditor = new structuredtexteditor ( ) ; int index = addpage ( texteditor , geteditorinput ( ) ) ; setpagetext ( index , str_ ) ; setpartname ( texteditor . gettitle ( ) ) ; } catch ( partinitexception e ) { errordialog . openerror ( getsite ( ) . getshell ( ) , str_ , null , e . getstatus ( ) ) ; } }	Creates Structured Twext Editot of the multi-page editor, which contains an HTML editor.
public void dosaveas ( ) { ieditorpart editor = geteditor ( num_ ) ; editor . dosaveas ( ) ; setpagetext ( num_ , editor . gettitle ( ) ) ; setinput ( editor . geteditorinput ( ) ) ; }	Saves the multi-page editor's document as another file.
public void resourcechanged ( final iresourcechangeevent event ) { if ( event . gettype ( ) == iresourcechangeevent . pre_close ) { display . getdefault ( ) . asyncexec ( new runnable ( ) { public void run ( ) { iworkbenchpage [ ] pages = getsite ( ) . getworkbenchwindow ( ) . getpages ( ) ; for ( int i = num_ ; i < pages . length ; i ++ ) { if ( ( ( fileeditorinput ) texteditor . geteditorinput ( ) ) . getfile ( ) . getproject ( ) . equals ( event . getresource ( ) ) ) { ieditorpart editorpart = pages [ i ] . findeditor ( texteditor . geteditorinput ( ) ) ; pages [ i ] . closeeditor ( editorpart , bool_ ) ; } } } } ) ; } }	Closes all project files on project close.
void showpage ( ) { string editortext = getdocumentprovider ( ) . getdocument ( texteditor . geteditorinput ( ) ) . get ( ) ; deletepreviewfiles ( ) ; file file = topreviewfile ( editortext ) ; if ( file != null ) { preview_files_list . add ( file ) ; string s = str_ + file . getabsolutepath ( ) ;	Sorts the words in page 0, and shows them in page 2.
public static string createquerylogmessage ( string query , list < object > parametervalues ) {	Method to create a human readable log message regarding a generated query.
private static string objecttostring ( object obj ) {	Helper method to create a string representation of an object.
public timelineitem inserttimelineitem ( timelineitem item ) throws ioexception { return getmirror ( ) . timeline ( ) . insert ( item ) . execute ( ) ; }	Inserts a simple timeline item.
public void inserttimelineitem ( timelineitem item , string attachmentcontenttype , byte [ ] attachmentdata ) throws ioexception { mirror . timeline timeline = getmirror ( ) . timeline ( ) ; timeline . insert ( item , new bytearraycontent ( attachmentcontenttype , attachmentdata ) ) . execute ( ) ; }	Inserts an item with an attachment provided as a byte array.
public void inserttimelineitem ( timelineitem item , string attachmentcontenttype , inputstream attachmentinputstream ) throws ioexception { inserttimelineitem ( item , attachmentcontenttype , bytestreams . tobytearray ( attachmentinputstream ) ) ; }	Inserts an item with an attachment provided as an input stream.
private void validate ( final cacheresponse response , final string keyword ) { if ( ! response . getmessage ( ) . tolowercase ( locale . us ) . startswith ( keyword ) ) { throw new illegalargumentexception ( response . getmessage ( ) ) ; } }	Validates that the keyword expected was returned.
public string toquerystring ( criteria criteria , criteriaquerybuilder querybuilder ) { string absolutepath = querybuilder . getabsolutepath ( criteria , relativepath ) ; return ascending ? absolutepath : absolutepath + str_ ; }	Renders the order to a ORDER BY substring of JPQL query.
public templatestore gettemplatestore ( ) { if ( ftemplatestore == null ) { ftemplatestore = new contributiontemplatestore ( gettemplatecontextregistry ( ) , getpreferencestore ( ) , str_ ) ; try { ftemplatestore . load ( ) ; } catch ( ioexception e ) { logerror ( str_ , e ) ; } } return ftemplatestore ; }	Returns the template store for the html editor templates.
public contexttyperegistry gettemplatecontextregistry ( ) { if ( fcontexttyperegistry == null ) { contributioncontexttyperegistry registry = new contributioncontexttyperegistry ( ) ; registry . addcontexttype ( cardcontexttype . context_type ) ; fcontexttyperegistry = registry ; } return fcontexttyperegistry ; }	Returns the template context type registry for the html plugin.
protected iaction getaction ( itexteditor editor , string actionid ) { return ( editor == null ? null : editor . getaction ( actionid ) ) ; }	Returns the action registed with the given text editor.
private dbi createdbi ( ) throws exception { if ( driver != null ) { class . forname ( driver ) . newinstance ( ) ; } return new dbi ( url , user , password ) ; }	Creates the datasource config based on the provided parameters.
protected void appendlimitandoffset ( final stringbuilder sql , final page page ) { sql . append ( str_ ) . append ( page . getpagesize ( ) ) . append ( str_ ) . append ( page . getoffset ( ) ) ; }	Appends LIMIT and OFFSET for POSTGRESQL SQL queries SELECT select_listFROM table_expression[ ORDER BY ..
public static < n > namedproperty < n > namedproperty ( final n name , final propertyvalue < n > value ) { return new namedproperty . impl < > ( name , value ) ; }	Create a value property from a literal value.
public static < n > namedproperty < n > namedproperty ( final n name , final string value ) { return namedproperty ( name , datatree . < n > literal ( value ) ) ; }	Create a value property from a string value.
public static < n > namedproperty < n > namedproperty ( final n name , final nesteddocument < n > value ) { return new namedproperty . impl < > ( name , value ) ; }	Create a value property from a nested document value.
public static < n > literal . stringliteral < n > literal ( final string value ) { return new literal . stringliteral < > ( value ) ; }	Create a string literal.
public static < n > literal . uriliteral < n > literal ( final uri value ) { return new literal . uriliteral < > ( value ) ; }	Create a URI literal.
public static < n > literal . typedliteral < n > literal ( final string value , final qname type ) { return new literal . typedliteral < > ( value , type ) ; }	Create a typed literal.
public static qname qname ( string namespaceuri , string localpart , string prefix ) { return new qname ( namespaceuri , localpart , prefix ) ; }	Create a QName from a namespace URI, local part and prefix.
public void init ( final filterconfig filterconfig ) throws servletexception {	This method is invoked by the web container to initialise thefilter at startup.
public void created ( final uuid createdbyentityid ) { if ( this . entityid != null ) { throw new illegalstateexception ( str_ + entityid ) ; } this . entityid = uuid . randomuuid ( ) ; this . entityversion = num_ ; this . createdbyentityid = createdbyentityid ; this . updatedbyentityid = createdbyentityid ; this . entitycreatedon = system . currenttimemillis ( ) ; this . entityupdatedon = this . entitycreatedon ; }	Call this method when the entity is updated to increment its version and update its lastupdatedByEntityId.
protected void init ( jsonparser parser ) throws ioexception { loggerfactory . getlogger ( getclass ( ) ) . warn ( str_ , parser . getcurrentname ( ) ) ; }	Sub-classes should override this to parse sub-class specific fields.This is invoked by init(InputStream), when an unknown field is encountered.
public void updated ( final uuid lastupdatedbyentityid ) { if ( this . entityid == null ) { throw new illegalstateexception ( str_ ) ; } assert . notnull ( lastupdatedbyentityid , str_ ) ; entityversion ++ ; updatedbyentityid = lastupdatedbyentityid ; entityupdatedon = system . currenttimemillis ( ) ; }	Call this method when the entity is updated before it is persisted to increment its version and update its lastupdatedByEntityId.
public void close ( int port ) { for ( iterator i = _listeners . keyset ( ) . iterator ( ) ; i . hasnext ( ) ; ) { object k = i . next ( ) ; object s = _listeners . get ( k ) ; if ( s instanceof sockethandler ) { sockethandler sh = ( sockethandler ) s ; if ( port == - num_ || sh . isport ( port ) ) { sh . interrupt ( ) ; sh . close ( ) ; _transactions . remove ( s ) ; _listeners . remove ( k ) ; } } } }	Closes a port. All connections on this port will be closed.
public static final void main ( string [ ] args ) { if ( args . length != num_ ) { system . err . println ( str_ ) ; system . exit ( num_ ) ; } int port = integer . valueof ( args [ num_ ] ) . intvalue ( ) ; system . out . println ( version . version ) ; try { new server ( port ) ; } catch ( exception e ) { system . err . println ( str_ ) ; e . printstacktrace ( system . err ) ; } }	Gozirra is probably not the best choice for a stand-alone server.
public void validateopts ( object instance ) { final set < constraintviolation < object > > set = validator . validate ( instance ) ; final stringbuilder sb = new stringbuilder ( ) ; for ( constraintviolation < object > violation : set ) { final path path = violation . getpropertypath ( ) ; final string msg = violation . getmessage ( ) ; sb . append ( path . tostring ( ) ) . append ( str_ ) . append ( msg ) . append ( str_ ) ; } if ( sb . length ( ) > num_ ) {	This method will only be called if we know that JSR 303 1.0 Bean Validation APIand compliant implementation are available on classpath.
public void validateargs ( list < object > args , object instance , method m , command cmd ) { final set < constraintviolation < object > > set = validator . validateparameters ( instance , m , args . toarray ( ) ) ; final stringbuilder sb = new stringbuilder ( ) ; for ( constraintviolation < object > violation : set ) { final path path = violation . getpropertypath ( ) ; final string msg = violation . getmessage ( ) ; string var = path . tostring ( ) ; try { int pos = integer . parseint ( str_ + var . charat ( var . length ( ) - num_ ) ) ; argument arg = cmd . getarguments ( ) . get ( pos ) ; sb . append ( arg . getname ( ) ) . append ( str_ ) . append ( msg ) . append ( str_ ) ; } catch ( exception e ) { sb . append ( var ) . append ( str_ ) . append ( msg ) . append ( str_ ) ; } } if ( sb . length ( ) > num_ ) {	This method will only be called if we know that JSR 303 1.1 Bean Validation APIand compliant implementation are available on classpath.Method validation was first introduced in version 1.1.
public void subscribe ( string name , listener listener , map headers ) { synchronized ( _listeners ) { if ( listener != null ) { list list = ( list ) _listeners . get ( name ) ; if ( list == null ) { list = new arraylist ( ) ; _listeners . put ( name , list ) ; } if ( ! list . contains ( listener ) ) list . add ( listener ) ; } } if ( headers == null ) headers = new hashmap ( ) ; headers . put ( str_ , name ) ; transmit ( command . subscribe , headers ) ; }	Subscribe to a channel.
public void unsubscribe ( string name , listener l ) { synchronized ( _listeners ) { list list = ( list ) _listeners . get ( name ) ; if ( list != null ) { list . remove ( l ) ; if ( list . size ( ) == num_ ) { unsubscribe ( name ) ; } } } }	Unsubscribe a single listener from a channel.
public void unsubscribe ( string name , map header ) { if ( header == null ) header = new hashmap ( ) ; synchronized ( _listeners ) { _listeners . remove ( name ) ; } header . put ( str_ , name ) ; transmit ( command . unsubscribe , header ) ; }	Unsubscribe from a channel.
public void unsubscribew ( string name , map header ) throws interruptedexception { string receipt = addreceipt ( header ) ; unsubscribe ( name , ( hashmap ) null ) ; waitonreceipt ( receipt ) ; }	Unsubscribe from a channel.
public void send ( string dest , string mesg , map header ) { if ( header == null ) header = new hashmap ( ) ; header . put ( str_ , dest ) ; transmit ( command . send , header , mesg ) ; }	Send a message to a channel.
public message getnext ( string name ) { synchronized ( _queue ) { for ( int idx = num_ ; idx < _queue . size ( ) ; idx ++ ) { message m = ( message ) _queue . get ( idx ) ; if ( m . headers ( ) . get ( str_ ) . equals ( name ) ) { _queue . remove ( idx ) ; return m ; } } } return null ; }	Get the next unconsumed message for a particular channel.
public boolean hasreceipt ( string receipt_id ) { synchronized ( _receipts ) { for ( iterator i = _receipts . iterator ( ) ; i . hasnext ( ) ; ) { string o = ( string ) i . next ( ) ; if ( o . equals ( receipt_id ) ) return bool_ ; } } return bool_ ; }	Checks to see if a receipt has come in.
public void clearreceipt ( string receipt_id ) { synchronized ( _receipts ) { for ( iterator i = _receipts . iterator ( ) ; i . hasnext ( ) ; ) { string o = ( string ) i . next ( ) ; if ( o . equals ( receipt_id ) ) i . remove ( ) ; } } }	Deletes all receipts with a given ID.
@ subscribe public void logdeadevent ( final deadevent deadevent ) { final object event = deadevent . getevent ( ) ; log . warn ( str_ , beanname , event . getclass ( ) . getname ( ) , event ) ; }	Logs dead event as warnings.
public < t > t convert ( final object source , final class < t > targetclass ) { if ( source == null ) { return null ; } final class < ? > sourceclass = source . getclass ( ) ; final sourcetargetpairkey key = new sourcetargetpairkey ( sourceclass , targetclass ) ; converter converter = cache . get ( key ) ; if ( converter != null ) { return ( t ) converter . convert ( source , targetclass ) ; } final linkedlist < sourcetargetpairmatch > matches = new linkedlist < sourcetargetpairmatch > ( ) ; for ( sourcetargetpair pair : converters . values ( ) ) { sourcetargetpairmatch match = pair . match ( sourceclass , targetclass ) ; if ( match . matchessource ( ) && match . matchestarget ( ) ) { matches . add ( match ) ; } } if ( matches . size ( ) == num_ ) { throw new conversionexception ( str_ + targetclass . getname ( ) + str_ + sourceclass . getname ( ) + str_ + converters . keyset ( ) + str_ ) ; } collections . sort ( matches , sourcetargetpairmatch . besttargetmatch ( ) ) ; converter = matches . get ( num_ ) . pair . converter ; cache . put ( key , converter ) ; return ( t ) converter . convert ( source , targetclass ) ; }	Convert a value to a specific class.The algorithm for finding a suitable converter is as follows:Find converters that is able to convert both source and target; a exact orsuperclass match.
protected priority getpriority ( final int lines ) { if ( lines >= highthreshold ) { return priority . high ; } else if ( lines >= normalthreshold ) { return priority . normal ; } else { return priority . low ; } }	Returns the priority of the warning.
public void execute ( gnuishparser p ) { if ( instance == null ) { instance = utils . newinstance ( classname ) ; } final class < ? > clazz = instance . getclass ( ) ; final method [ ] methods = clazz . getdeclaredmethods ( ) ; for ( method m : methods ) { m . setaccessible ( bool_ ) ; if ( ! m . getname ( ) . equals ( p . getcommand ( ) ) ) { continue ; } final list < object > args = adjustargs ( p . getargs ( ) , m ) ; injectopts ( p , clazz ) ; try { validateargs ( args , instance , m , this ) ; m . invoke ( instance , args . toarray ( ) ) ; return ; } catch ( invocationtargetexception e ) { final throwable ex = e . gettargetexception ( ) ; if ( ex instanceof runtimeexception ) { throw ( runtimeexception ) e . getcause ( ) ; } else { throw new runtimeexception ( e . gettargetexception ( ) ) ; } } catch ( runtimeexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } } system . out . println ( p . getcommand ( ) + str_ ) ; }	Execute this command according to the user input argumentsparsed by the parser.
private void injectopts ( gnuishparser p , class < ? > clazz ) { for ( field f : clazz . getdeclaredfields ( ) ) { f . setaccessible ( bool_ ) ; final clioption anno = f . getannotation ( clioption . class ) ; if ( anno == null ) { continue ; } string value = p . getshortopt ( anno . shortname ( ) ) ; if ( value == null ) { value = p . getlongopt ( f . getname ( ) ) ; if ( value == null ) { continue ; } } try { f . set ( instance , c . convert ( value , f . gettype ( ) ) ) ; } catch ( conversionexception e ) { throw cliexception . wrong_opt_type ( f . getname ( ) , f . gettype ( ) . getname ( ) , value ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } } validateopts ( instance ) ; }	Convert options to appropriate type and inject them intothe command instance.
private list < object > adjustargs ( list < string > args , method m ) { final list < object > result = new arraylist < object > ( ) ; final class < ? > [ ] types = m . getparametertypes ( ) ; if ( m . isvarargs ( ) ) { types [ types . length - num_ ] = types [ types . length - num_ ] . getcomponenttype ( ) ; if ( ! string . class . isassignablefrom ( types [ types . length - num_ ] ) ) { throw new cliexception ( str_ ) ; } types [ types . length - num_ ] = string . class ; } list < object > varargs = new arraylist < > ( ) ; for ( int i = num_ ; i < args . size ( ) ; i ++ ) { try { if ( m . isvarargs ( ) && i >= types . length - num_ ) { varargs . add ( c . convert ( args . get ( i ) , types [ types . length - num_ ] ) ) ; } else { result . add ( c . convert ( args . get ( i ) , types [ i ] ) ) ; } } catch ( conversionexception e ) { throw cliexception . wrong_arg_type ( getarguments ( ) . get ( i ) . getname ( ) , types [ i ] . getname ( ) , args . get ( i ) ) ; } } if ( m . isvarargs ( ) ) { result . add ( varargs . toarray ( new string [ num_ ] ) ) ; } return result ; }	Add or remove parameters to fit the method declaration and also convert themto appropriate data type.
private list < migrationresult > migratepersonality ( final metadatamanager metadatamanager , final string personalityname , final integer targetversion , final migratoryoption [ ] options ) { final integer currentversion = metadatamanager . getcurrentversion ( personalityname ) ; if ( currentversion == null && ! migratoryconfig . iscreatepersonalities ( ) ) { throw new migratoryexception ( reason . new_personalities_denied ) ; }	Performs the migration of a personality.
public void handleactualrequest ( final httpservletrequest request , final httpservletresponse response ) throws invalidcorsrequestexception , corsorigindeniedexception , unsupportedhttpmethodexception { if ( corsrequesttype . detect ( request ) != corsrequesttype . actual ) throw new invalidcorsrequestexception ( str_ ) ;	Handles a simple or actual CORS request. CORS specification: Simple Cross-Origin Request, Actual Request, and Redirects .
public void handlepreflightrequest ( final httpservletrequest request , final httpservletresponse response ) throws invalidcorsrequestexception , corsorigindeniedexception , unsupportedhttpmethodexception , unsupportedhttpheaderexception { if ( corsrequesttype . detect ( request ) != corsrequesttype . preflight ) throw new invalidcorsrequestexception ( str_ ) ;	Handles a preflight CORS request. CORS specification: Preflight Request .
protected string check ( ) { string error ; if ( ! m_javahome . exists ( ) ) return str_ + m_javahome ; if ( ! m_javahome . isdirectory ( ) ) return str_ + m_javahome ; if ( system . getproperty ( str_ ) . tolowercase ( ) . contains ( str_ ) ) m_jdeps = new file ( m_javahome . getabsolutepath ( ) + file . separator + str_ + file . separator + str_ ) ; else m_jdeps = new file ( m_javahome . getabsolutepath ( ) + file . separator + str_ + file . separator + str_ ) ; if ( ! m_jdeps . exists ( ) ) return str_ + m_jdeps ; if ( ! m_classesfile . exists ( ) ) return str_ + m_classesfile ; if ( m_classesfile . isdirectory ( ) ) return str_ + m_classesfile ;	Performs some checks.
protected list < string > filter ( list < string > lines , string regexp , boolean invert ) { list < string > result ; pattern pattern ; result = new arraylist < > ( ) ; pattern = pattern . compile ( regexp ) ; for ( string line : lines ) { if ( invert ) { if ( ! pattern . matcher ( line ) . matches ( ) ) result . add ( line ) ; } else { if ( pattern . matcher ( line ) . matches ( ) ) result . add ( line ) ; } } return result ; }	Filters the list of strings with a regular expression.
protected string packagesregexp ( ) { stringbuilder result ; int i ; string pkg ; result = new stringbuilder ( ) ; result . append ( str_ ) ; for ( i = num_ ; i < m_packages . size ( ) ; i ++ ) { if ( i > num_ ) result . append ( str_ ) ; pkg = m_packages . get ( i ) ; if ( ! pkg . endswith ( str_ ) ) pkg = pkg + str_ ; pkg = pkg . replace ( str_ , str_ ) ; result . append ( pkg ) ; } result . append ( str_ ) ; return result . tostring ( ) ; }	Builds the regular expression for the packages to keep.
public void output ( ) { if ( ( m_outputfile == null || m_outputfile . isdirectory ( ) ) ) { for ( string dep : m_dependencies ) system . out . println ( dep ) ; } else { try { files . write ( m_outputfile . topath ( ) , m_dependencies , standardopenoption . create , standardopenoption . truncate_existing ) ; } catch ( exception e ) { system . err . println ( str_ + m_outputfile ) ; e . printstacktrace ( ) ; } } }	Outputs the dependencies on stdout.
@ override public int compareto ( instanceprovider instanceprovider ) { if ( this . getpriority ( ) . equals ( instanceprovider . getpriority ( ) ) ) { return this . getname ( ) . compareto ( instanceprovider . getname ( ) ) ; } else { return this . getpriority ( ) . compareto ( instanceprovider . getpriority ( ) ) ; } }	Default implementation of compareTo for the InstanceManager.
public static ioutils getioutils ( ) { if ( ioutils == null ) { try { class clazz = class . forname ( io_utils ) ; ioutils = ( ioutils ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return ioutils ; }	Retrieve IOUtils implementation.
public static imageutils getimageutils ( ) { if ( imageutils == null ) { try { class clazz = class . forname ( image_utils ) ; imageutils = ( imageutils ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return imageutils ; }	Retrieve ImageUtils implementation.
public static priceutils getpriceutils ( ) { if ( priceutils == null ) { try { class clazz = class . forname ( price_utils ) ; priceutils = ( priceutils ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return priceutils ; }	Retrieve PriceUtils implementation.
public static resourceutils getresourceutils ( ) { if ( resourceutils == null ) { try { class clazz = class . forname ( resource_utils ) ; resourceutils = ( resourceutils ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return resourceutils ; }	Retrieve ResourceUtils implementation.
public static ziputils getziputils ( ) { if ( ziputils == null ) { try { class clazz = class . forname ( zip_utils ) ; ziputils = ( ziputils ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return ziputils ; }	Retrieve ZipUtils implementation.
public static digestutils getdigestutils ( ) { if ( digestutils == null ) { try { class clazz = class . forname ( digest_utils ) ; digestutils = ( digestutils ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return digestutils ; }	Retrieve DigestUtils implementation.
public static stringutils getstringutils ( ) { if ( stringutils == null ) { try { class clazz = class . forname ( string_utils ) ; stringutils = ( stringutils ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return stringutils ; }	Retrieve StringUtils implementation.
public static resourceservice getresourceservice ( ) { if ( resourceservice == null ) { try { class clazz = class . forname ( resource_service ) ; resourceservice = ( resourceservice ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return resourceservice ; }	Retrieve ResourceService implementation.
public static pricingservice getpricingservice ( ) { if ( pricingservice == null ) { try { class clazz = class . forname ( pricing_service ) ; pricingservice = ( pricingservice ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return pricingservice ; }	Retrieve PricingService implementation.
public static instanceservice getinstanceservice ( ) { if ( instanceservice == null ) { try { class clazz = class . forname ( instance_service ) ; instanceservice = ( instanceservice ) clazz . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { logger . warn ( str_ , e . getmessage ( ) ) ; throw new illegalstateexception ( e ) ; } } return instanceservice ; }	Retrieve InstanceService implementation.
@ override public set < string > getobjectid ( file uploadedfile ) throws harvesterexception { set < string > objectids = new hashset < string > ( ) ; try { objectids . add ( createdigitalobject ( uploadedfile ) ) ; } catch ( storageexception se ) { throw new harvesterexception ( se ) ; } return objectids ; }	Get an individual uploaded file as a digital object.
private string createdigitalobject ( file file ) throws harvesterexception , storageexception { string objectid ; digitalobject object ; if ( forceupdate ) { object = storageutils . storefile ( getstorage ( ) , file , ! forcelocalstorage ) ; } else { string oid = storageutils . generateoid ( file ) ; string pid = storageutils . generatepid ( file ) ; object = getstorage ( ) . createobject ( oid ) ; if ( forcelocalstorage ) { try { object . createstoredpayload ( pid , new fileinputstream ( file ) ) ; } catch ( filenotfoundexception ex ) { throw new harvesterexception ( ex ) ; } } else { object . createlinkedpayload ( pid , file . getabsolutepath ( ) ) ; } }	Store the provided file in storage.
private void storelist ( properties props , map < string , list < string > > details , string field ) { set < string > valueset = new linkedhashset < string > ( ) ;	Take a list of strings from a Java Map, concatenate the values togetherand store them in a Properties object using the Map's original key.
public list < metadatainfo > ensuremetadata ( final migratoryoption [ ] options ) throws migratoryexception { if ( migratorycontext . getdbsupport ( ) . tableexists ( migratoryconfig . getmetadatatablename ( ) ) ) { return null ; } if ( migratoryconfig . isreadonly ( ) ) { throw new migratoryexception ( reason . is_readonly ) ; }	Make sure that the metadata exists.
private object createdrysourcedetail ( final abstractbuild < ? , ? > owner , final annotationcontainer container , final string defaultencoding , final string fromstring , final string tostring ) { long from = long . parselong ( fromstring ) ; long to = long . parselong ( tostring ) ; fileannotation fromannotation = container . getannotation ( from ) ; if ( fromannotation instanceof duplicatecode ) { return new sourcedetail ( owner , ( ( duplicatecode ) fromannotation ) . getlink ( to ) , defaultencoding ) ; } return null ; }	Creates the dry source detail view.
private formvalidation validate ( final string highthreshold , final string normalthreshold , final string message ) { try { int high = integer . parseint ( highthreshold ) ; int normal = integer . parseint ( normalthreshold ) ; if ( isvalid ( normal , high ) ) { return formvalidation . ok ( ) ; } } catch ( numberformatexception exception ) {	Performs on-the-fly validation on thresholds for high and normal warnings.
static void validateargs ( list < object > args , object instance , method m , command cmd ) { if ( ! onclasspath ( jsr303_1_1_classname ) ) { return ; } try { object validator = getvalidator ( ) ; method validate = validator . getclass ( ) . getmethod ( str_ , list . class , object . class , method . class , command . class ) ; validate . invoke ( validator , args , instance , m , cmd ) ; } catch ( invocationtargetexception e ) { if ( e . gettargetexception ( ) instanceof runtimeexception ) { throw ( runtimeexception ) e . getcause ( ) ; } throw new runtimeexception ( e . getcause ( ) ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	Validate that the method parameters if Bean Validation 1.1 is availableon classpath.
static void validateopts ( object instance ) { if ( ! onclasspath ( jsr303_1_0_classname ) ) { return ; } try { object validator = getvalidator ( ) ; method validate = validator . getclass ( ) . getmethod ( str_ , object . class ) ; validate . invoke ( validator , instance ) ; } catch ( invocationtargetexception e ) { if ( e . gettargetexception ( ) instanceof runtimeexception ) { throw ( runtimeexception ) e . gettargetexception ( ) ; } throw new runtimeexception ( e . gettargetexception ( ) ) ; } catch ( runtimeexception e ) { throw e ; } catch ( throwable e ) { throw new runtimeexception ( e ) ; } }	Validate that the options if Bean Validation is available on classpath.
static boolean onclasspath ( string classname ) { classloader cl = thread . currentthread ( ) . getcontextclassloader ( ) ; try { cl . loadclass ( classname ) ; } catch ( classnotfoundexception e ) { return bool_ ; } return bool_ ; }	Checks to see if JSR303 implementation isavailable on classpath.
public boolean accept ( final uri uri ) { for ( final migrationloader loader : loaders ) { if ( loader . accept ( uri ) ) { return bool_ ; } } return bool_ ; }	Returns true if this loader accepts the URI.
public string loadfile ( final uri fileuri ) { try { for ( final migrationloader loader : loaders ) { if ( loader . accept ( fileuri ) ) { return loader . loadfile ( fileuri ) ; } } return null ; } catch ( ioexception ioe ) { throw new migratoryexception ( reason . internal , ioe ) ; } }	Load a file from an URI.
public void run ( ) throws runtimeexception { if ( terminalargs == null ) { terminalargs = new string [ num_ ] ; } p = gnuishparser . parse ( terminalargs ) ; readcommands ( ) ; if ( p . getcommand ( ) == null || str_ . equals ( p . getcommand ( ) ) ) { utils . printavailablecommandshelp ( commands ) ; return ; } final command cmd = commands . get ( p . getcommand ( ) ) ; if ( cmd == null ) { throw cliexception . command_not_found ( p . getcommand ( ) ) ; } if ( p . help ( ) ) { utils . printcommandhelp ( cmd ) ; return ; } try { cmd . execute ( p ) ; } catch ( exception e ) { if ( p . debug ( ) ) { e . printstacktrace ( ) ; } if ( e instanceof runtimeexception ) { throw ( runtimeexception ) e ; } } }	Start evaluating the user input and eventually execute the commandrequested by the user.
private void readcommands ( ) { try { final enumeration < url > urls = thread . currentthread ( ) . getcontextclassloader ( ) . getresources ( xmlcommands . filepath ) ; while ( urls . hasmoreelements ( ) ) { url url = urls . nextelement ( ) ; inputstream in = url . openstream ( ) ; for ( command command : xmlcommands . fromxml ( in ) ) { commands . put ( command . getcommand ( ) , command ) ; } } } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	Find all commands available on classpath.
protected void postprocess ( final string target , final request baserequest , final httpservletrequest request , final httpservletresponse response ) throws ioexception , servletexception {	The purpose of this methods is to allow the Handler to return an HTTP response.
protected map < string , object > preprocess ( final string target , final request baserequest , final httpservletrequest request , final httpservletresponse response ) throws ioexception , servletexception { return collections . emptymap ( ) ; }	Validate the request and extract any data from the HTTP request that will be required to process the request asynchronously.If the request is invalid, then handle the request appropriately.*** NOTE: to indicate that this method handled the request, set Request.handled to true: baseRequest.setHandled(true);.
public map < string , list < metadatainfo > > dbmigrate ( final migrationplan migrationplan , final migratoryoption ... options ) throws migratoryexception { init ( ) ; final internalmigrator migrator = new internalmigrator ( this ) ; return migrator . migrate ( migrationplan , options ) ; }	Bring the current database to the requested levels.
public map < string , validationresult > dbvalidate ( final collection < string > personalities , final migratoryoption ... options ) throws migratoryexception { init ( ) ; final internalvalidator validator = new internalvalidator ( this ) ; return validator . validate ( personalities , options ) ; }	Run validation on the database.
public map < string , list < metadatainfo > > dbhistory ( final collection < string > personalities , final migratoryoption ... options ) throws migratoryexception { init ( ) ; final internalhistory internalhistory = new internalhistory ( this ) ; return internalhistory . history ( personalities , options ) ; }	Returns the full history of all applied migrations.
public list < metadatainfo > dbinit ( final migratoryoption ... options ) throws migratoryexception { init ( ) ; final internalinit internalinit = new internalinit ( this ) ; return internalinit . init ( options ) ; }	Creates and initializes the Migratory metadata table.Returns null if the table already exists, returns a list of migration resultsfor the migrations executed otherwise.
list < sqlstatement > linestostatements ( list < string > lines ) { final list < sqlstatement > statements = lists . newarraylist ( ) ; final stringbuilder statementsql = new stringbuilder ( ) ; int count = num_ ; string delimiter = default_statement_delimiter ; for ( final string line : lines ) { if ( stringutils . isblank ( line ) ) { continue ; } if ( statementsql . length ( ) > num_ ) { statementsql . append ( str_ ) ; } statementsql . append ( line ) ; final string olddelimiter = delimiter ; delimiter = changedelimiterifnecessary ( statementsql . tostring ( ) , line , delimiter ) ; if ( ! stringutils . equals ( delimiter , olddelimiter ) && isdelimiterchangeexplicit ( ) ) { statementsql . setlength ( num_ ) ; continue ;	Turns these lines in a series of statements.
@ programmatic public notablelink findbynotableandcalendarname ( final object notable , final string calendarname ) { if ( notable == null ) { return null ; } if ( calendarname == null ) { return null ; } final bookmark bookmark = bookmarkservice . bookmarkfor ( notable ) ; if ( bookmark == null ) { return null ; } final string notablestr = bookmark . tostring ( ) ; return repositoryservice . firstmatch ( new querydefault < > ( notablelink . class , str_ , str_ , notablestr , str_ , calendarname ) ) ; }	Each notable can only have one note per calendar, thus this method returns a single object rather than a list.
private string [ ] parseopts ( string [ ] args ) { if ( args == null || args . length == num_ ) { return new string [ num_ ] ; } final list < string > remainingargs = new arraylist < string > ( ) ; final list < string > argslist = arrays . aslist ( args ) ; final listiterator < string > argsit = argslist . listiterator ( ) ; while ( argsit . hasnext ( ) ) { string word = argsit . next ( ) ; if ( word . startswith ( str_ ) ) {	Parse the options for the command.
public void transmit ( command c , map h , string b ) { _server . receive ( c , h , b , this ) ; }	Transmit a message to clients and listeners.
public string getformattedsourcecode ( ) { try { javasource source = new javasourceparser ( ) . parse ( new stringreader ( sourcecode ) ) ; javasource2htmlconverter converter = new javasource2htmlconverter ( ) ; stringwriter writer = new stringwriter ( ) ; javasourceconversionoptions options = javasourceconversionoptions . getdefault ( ) ; options . setshowlinenumbers ( bool_ ) ; options . setaddlineanchors ( bool_ ) ; converter . convert ( source , options , writer ) ; return writer . tostring ( ) ; } catch ( illegalconfigurationexception exception ) { return sourcecode ; } catch ( ioexception exception ) { return sourcecode ; } }	Returns the duplicate source code fragment as formatted HTML string.
public fileannotation getlink ( final long linkhashcode ) { for ( fileannotation link : links ) { if ( link . getkey ( ) == linkhashcode ) { return link ; } } throw new nosuchelementexception ( str_ + linkhashcode ) ; }	Returns the link with the specified hash code.
public void transmit ( command c , map h , string b ) { try { transmitter . transmit ( c , h , b , _output ) ; } catch ( exception e ) { receive ( command . error , null , e . getmessage ( ) ) ; } }	Transmit a message to the server.
public static jaxbcontext get ( final string contextpath ) { assert . hastext ( contextpath , str_ ) ; jaxbcontext ctx = jaxbcontexts . get ( contextpath ) ; if ( ctx == null ) { try { ctx = jaxbcontext . newinstance ( contextpath ) ; } catch ( final jaxbexception e ) { throw new illegalargumentexception ( str_ + contextpath , e ) ; } jaxbcontexts . put ( contextpath , ctx ) ; loggerfactory . getlogger ( jaxbcontextcache . class ) . info ( str_ , contextpath ) ; } return ctx ; }	If the JAXBContext is not cached, then it will create a new instance and cache it.
private void createboxlist ( box root , vector < boxnode > list ) { if ( root . isdisplayed ( ) ) { if ( ! ( root instanceof viewport ) && root . isvisible ( ) ) { boxnode newnode = new boxnode ( root , page , zoom ) ; newnode . setorder ( order_counter ++ ) ; list . add ( newnode ) ; } if ( root instanceof elementbox ) { elementbox elem = ( elementbox ) root ; for ( int i = elem . getstartchild ( ) ; i < elem . getendchild ( ) ; i ++ ) createboxlist ( elem . getsubbox ( i ) , list ) ; } } }	Recursively creates a list of all the visible boxes in a box subtree.
private void computebackgrounds ( boxnode root , color currentbg ) { color newbg = root . getbackgroundcolor ( ) ; if ( newbg == null ) newbg = currentbg ; root . setefficientbackground ( newbg ) ; root . setbackgroundseparated ( ! newbg . equals ( currentbg ) ) ; for ( int i = num_ ; i < root . getchildcount ( ) ; i ++ ) computebackgrounds ( ( boxnode ) root . getchildat ( i ) , newbg ) ; }	Computes efficient background color for all the nodes in the tree.
public void setmappingfile ( url url , string realfile ) { if ( componentfiles == null ) initfastindexes ( str_ , str_ , str_ ) ; file file = new file ( realfile ) ; componentfiles . put ( url . getfile ( ) , file ) ; }	Set the real file of component url.
public boxtransform concatenate ( boxtransform src ) { if ( src . isempty ( ) ) return this ; else if ( this . isempty ( ) ) return src ; else { boxtransform ret = new boxtransform ( this ) ; ret . transform = new affinetransform ( transform ) ; ret . transform . concatenate ( src . transform ) ; return ret ; } }	Concatenates another transformation to this transformation.
public rectangular transformrect ( rectangular rect ) { if ( transform != null ) { rectangle src = new rectangle ( rect . getx1 ( ) , rect . gety1 ( ) , rect . getwidth ( ) , rect . getheight ( ) ) ; shape dest = transform . createtransformedshape ( src ) ; rectangle destr ; if ( dest instanceof rectangle ) destr = ( rectangle ) dest ; else destr = dest . getbounds ( ) ; return new rectangular ( destr ) ; } else return rect ; }	Transforms a rectangle to other rectangle using the given transformation.
private rectangular getminimalvisualbounds ( ) { final box box = getbox ( ) ; if ( box instanceof textbox ) return new rectangularz ( box . getabsolutebounds ( ) . intersection ( box . getclipblock ( ) . getclippedcontentbounds ( ) ) , zoom ) ; else if ( box != null && box . isreplaced ( ) ) return new rectangularz ( box . getminimalabsolutebounds ( ) . intersection ( box . getclipblock ( ) . getclippedcontentbounds ( ) ) , zoom ) ; else { rectangular ret = null ; for ( int i = num_ ; i < getchildcount ( ) ; i ++ ) { boxnode subnode = ( boxnode ) getchildat ( i ) ; box sub = subnode . getbox ( ) ; rectangular sb = subnode . getvisualbounds ( ) ; if ( sub . isdisplayed ( ) && subnode . isvisible ( ) && sb . getwidth ( ) > num_ && sb . getheight ( ) > num_ ) { if ( ret == null ) ret = new rectangular ( sb ) ; else ret . expandtoenclose ( sb ) ; } }	Returns the minimal bounds of the box for enclosing all the contained boxes.
public void recomputevisualbounds ( ) { for ( int i = num_ ; i < getchildcount ( ) ; i ++ ) ( ( boxnode ) getchildat ( i ) ) . recomputevisualbounds ( ) ; visual = computevisualbounds ( ) ; }	Re-computes the visual bounds of the whole subtree.
public void recomputebounds ( ) { bounds = new rectangular ( visual ) ; for ( int i = num_ ; i < getchildcount ( ) ; i ++ ) { boxnode child = ( boxnode ) getchildat ( i ) ; child . recomputebounds ( ) ; expandtoenclose ( child ) ; } }	Recomputes the total bounds of the whole subtree.
private rectangular computecontentbounds ( ) { box box = getbox ( ) ; rectangular ret = null ; if ( box instanceof viewport ) { ret = new rectangularz ( ( ( viewport ) box ) . getclippedbounds ( ) , zoom ) ; } else if ( box instanceof elementbox ) { elementbox elem = ( elementbox ) box ;	Computes node the content bounds.
@ override public int gettopborder ( ) { box box = getbox ( ) ; if ( box instanceof elementbox ) return ( ( elementbox ) box ) . getborder ( ) . top ; else return num_ ; }	Obtains the top border of the box.
@ override public int getbottomborder ( ) { box box = getbox ( ) ; if ( box instanceof elementbox ) return ( ( elementbox ) box ) . getborder ( ) . bottom ; else return num_ ; }	Obtains the bottom border of the box.
@ override public int getleftborder ( ) { box box = getbox ( ) ; if ( box instanceof elementbox ) return ( ( elementbox ) box ) . getborder ( ) . left ; else return num_ ; }	Obtains the left border of the box.
@ override public int getrightborder ( ) { box box = getbox ( ) ; if ( box instanceof elementbox ) return ( ( elementbox ) box ) . getborder ( ) . right ; else return num_ ; }	Obtains the right border of the box.
public string getefficientcolor ( ) { box box = getbox ( ) ; do { if ( box instanceof elementbox ) { string color = ( ( elementbox ) box ) . getstylepropertyvalue ( str_ ) ; if ( ! color . equals ( str_ ) ) return color ; } box = box . getparent ( ) ; } while ( box != null ) ; return str_ ; }	Get the effective text color.
public boolean visuallyencloses1 ( boxnode childnode ) { int cx1 = childnode . getvisualbounds ( ) . getx1 ( ) ; int cy1 = childnode . getvisualbounds ( ) . gety1 ( ) ; int cx2 = childnode . getvisualbounds ( ) . getx2 ( ) ; int cy2 = childnode . getvisualbounds ( ) . gety2 ( ) ; int px1 = getvisualbounds ( ) . getx1 ( ) ; int py1 = getvisualbounds ( ) . gety1 ( ) ; int px2 = getvisualbounds ( ) . getx2 ( ) ; int py2 = getvisualbounds ( ) . gety2 ( ) ;	Checks if another node is fully located inside the content bounds of this box.
public void takechildren ( vector < boxnode > list ) { for ( iterator < boxnode > it = list . iterator ( ) ; it . hasnext ( ) ; ) { boxnode node = it . next ( ) ; if ( node . nearestparent . equals ( this ) ) { appendchild ( node ) ; it . remove ( ) ; } }	Goes through the parent's children, takes all the nodes that are inside of this nodeand makes them the children of this node.
protected void process ( string command ) { try { method method = this . getclass ( ) . getmethod ( command ) ; logger . info ( str_ , command ) ; method . invoke ( this ) ; logger . info ( str_ , command ) ; } catch ( nosuchmethodexception e ) { logger . warn ( str_ , command ) ; } catch ( exception e ) { logger . warn ( str_ , command ) ; } }	Process user specified command.
@ bean public datasource datasource ( ) {	Use this data source to create an embedded database.
@ bean public datasource datasource_plain ( ) { simpledriverdatasource ds = new simpledriverdatasource ( ) ; ds . setdriverclass ( null ) ; ds . seturl ( str_ ) ; ds . setusername ( str_ ) ; ds . setpassword ( str_ ) ; return ds ; }	Use this data source to connect to an existing database.
public void setup ( platformconfiguration config , environment env ) { this . configuration = preconditions . checknotnull ( config , str_ ) ; this . environment = preconditions . checknotnull ( env , str_ ) ; }	Called when the configuration and environment come into scope.
public < t > t query ( methodmap methodmap , argmap argmap , class < t > responsetype ) throws openstatesexception { bufferedreader reader = null ; httpurlconnection conn = null ; string charset = str_ ; try { if ( iscaching ( methodmap , argmap ) ) { file file = getcachefile ( methodmap , argmap ) ; long filelength = file . length ( ) ; logger . fine ( str_ + filelength + str_ + file . getname ( ) ) ; if ( filelength == num_ ) { openstates . cachefilefromapi ( methodmap , argmap , file , responsetype ) ; } reader = new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , charset ) ) ; } else { conn = openstates . getconnectionfromapi ( methodmap , argmap ) ; charset = getcharset ( conn ) ;	Handles the actual API calls and caching.This is part of a static class and therefore is not thread-safe.
public void register ( command command ) { preconditions . checkargument ( command != null , str_ + command + str_ ) ; register ( command . name ( ) , command ) ; }	Registers the specified command instance into the shell.
public void register ( string name , command command ) { preconditions . checkargument ( name != null && ! name . isempty ( ) , str_ + name + str_ ) ; preconditions . checkargument ( command != null , str_ + command + str_ ) ; commands . put ( name , command ) ; }	Registers the specified command instance into the shell with the specified name.
public void unregister ( string name ) { preconditions . checkargument ( name != null && ! name . isempty ( ) , str_ + name + str_ ) ; commands . remove ( name ) ; }	Unregisters the command corresponding to the specified name from the shell.
@ suppresswarnings ( str_ ) public void exec ( string line ) { string [ ] strings = line . split ( str_ ) ; if ( strings . length == num_ ) { return ; } string cmd = strings [ num_ ] ; if ( strings [ num_ ] == null || strings [ num_ ] . isempty ( ) ) { return ; } string [ ] args = { } ; if ( strings . length > num_ ) { args = new string [ strings . length - num_ ] ; system . arraycopy ( strings , num_ , args , num_ , args . length ) ; } command command = commands . get ( cmd ) ; if ( command == null ) {	Executes the specified command line input.
public void start ( ) { repl . set ( bool_ ) ; string line = null ; while ( repl . get ( ) && ( ( line = console . readline ( ) ) != null ) ) { exec ( line ) ; } }	Runs into the REPL mode.
public committees searchbystatechamber ( string state , string chamber ) throws openstatesexception { return api . query ( new methodmap ( str_ ) , new argmap ( str_ , state , str_ , chamber ) , committees . class ) ; }	Committee SearchThis method allows searching by state and chamber.Committee objects returned by this method do not include the list of members by default.
public committee detail ( string id ) throws openstatesexception { return api . query ( new methodmap ( str_ , id ) , null , committee . class ) ; }	Committee DetailThis method returns the full committee object given a committee id.
private static jmxconnector connect ( string host , string port , string login , string password ) throws ioexception {	Connect to the JMX service.
private static string getproperty ( properties properties , string key ) {	Get the property.
@ override public object invoke ( object proxy , method method , object [ ] args ) throws throwable { object result ; jmxconnector connector = null ; try {	Invoke the method and return the result.
public districts searchbystate ( string state ) throws openstatesexception { return api . query ( new methodmap ( str_ , state ) , null , districts . class ) ; }	List districts for state.
public districts search ( string state , string chamber ) throws openstatesexception { return api . query ( new methodmap ( str_ , state , chamber ) , null , districts . class ) ; }	List districts for state and chamber.
public district boundarylookup ( string boundary_id ) throws openstatesexception { return api . query ( new methodmap ( str_ , str_ , boundary_id ) , null , district . class ) ; }	Get geographic boundary for a district.
public metadata state ( string state ) throws openstatesexception { return api . query ( new methodmap ( str_ , state ) , null , metadata . class ) ; }	Get detailed metadata for a particular state.
private static < t > t createobject ( class < t > interfaceclass ) { serviceloader < t > loader = serviceloader . load ( interfaceclass ) ; t object = null ;	Create the MBean object.
public static < t > objectname register ( class < t > interfaceclass , objectname objectname ) throws mbeanexception {	Register the MBean represented by the interface class.
public static void unregister ( objectname objectname ) throws mbeanexception { try {	Unregister the MBean represented by the object name.
protected static void validatembean ( class interfaceclass , objectname objectname , mbeanserverconnection mbeanserverconnection ) throws mbeanexception { try {	Validate the MBean represented by the interface class and object name.
@ override public string get ( ) { try ( final timer . context context = timer . time ( ) ) { final string s = randomuuid ( ) . tostring ( ) ; if ( length == num_ || count == num_ ) { return s ; } final stringjoiner joiner = new stringjoiner ( str_ , str_ , str_ + s ) ; intstream . rangeclosed ( num_ , count - num_ ) . foreach ( x -> joiner . add ( s . substring ( x * length , ( x + num_ ) * length ) ) ) ; return joiner . tostring ( ) ; } }	Mint a unique identifier as a UUID.
public void addvalue ( string value , boolean isdefault ) { p ( str_ + ( isdefault ? str_ : str_ ) + str_ + value + str_ + m_field . getname ( ) ) ; string name = m_wrappedparameter . names ( ) [ num_ ] ; if ( m_assigned && ! ismultioption ( ) ) { throw new parameterexception ( str_ + name + str_ ) ; } validateparameter ( name , value ) ; class < ? > type = m_field . gettype ( ) ; object convertedvalue = m_jcommander . convertvalue ( this , value ) ; boolean iscollection = collection . class . isassignablefrom ( type ) ; try { if ( iscollection ) { @ suppresswarnings ( str_ ) collection < object > l = ( collection < object > ) m_field . get ( m_object ) ; if ( l == null || fieldissetforthefirsttime ( isdefault ) ) { l = newcollection ( type ) ; m_field . set ( m_object , l ) ; } if ( convertedvalue instanceof collection ) { l . addall ( ( collection ) convertedvalue ) ; } else {	Add the specified value to the field.
public legislators searchbystate ( string state ) throws openstatesexception { return api . query ( new methodmap ( str_ ) , new argmap ( str_ , state ) , legislators . class ) ; }	Get Legislators by State.
public legislators searchbystateactive ( string state , boolean active ) throws openstatesexception { return api . query ( new methodmap ( str_ ) , new argmap ( str_ , state , str_ , active . tostring ( ) ) , legislators . class ) ; }	Get Legislators by State and Active filters.
public legislators searchbystateterm ( string state , string term ) throws openstatesexception { return api . query ( new methodmap ( str_ ) , new argmap ( str_ , state , str_ , term ) , legislators . class ) ; }	Search for Legislators by State and Term.
public legislator detail ( string id ) throws openstatesexception { return api . query ( new methodmap ( str_ , id ) , null , legislator . class ) ; }	This method returns the full detail for a legislator.
public int compareto ( e o ) { if ( o . getclass ( ) != getclass ( ) ) { throw new classcastexception ( ) ; } return ordinal - typesafeenum . class . cast ( o ) . ordinal ; }	Compares with the specified object by ordinal.
public void setmappedclass ( class < t > mappedclass ) { if ( this . mappedclass == null ) { initialize ( mappedclass ) ; } else { if ( ! this . mappedclass . equals ( mappedclass ) ) { throw new invaliddataaccessapiusageexception ( str_ + mappedclass + str_ + this . mappedclass ) ; } } }	Set the class that each row should be mapped to.
@ suppresswarnings ( str_ ) public r proceed ( ) throws throwable { try { return ( r ) method ( ) . invoke ( target , args ) ; } catch ( invocationtargetexception e ) { throw e . gettargetexception ( ) ; } }	Proceeds this method invocation.
public long stop ( ) { if ( isrunning ( ) ) { stop = system . nanotime ( ) ; total += stop - start ; running = bool_ ; } return math . round ( total * getprecision ( ) . value ) ; }	Stops to measure.
protected httpclient buildclient ( ) { httpclientbuilder builder = httpclientbuilder . create ( ) . usesystemproperties ( ) . setconnectionmanager ( connmanager ) ; if ( ! isblank ( username ) && ! isblank ( password ) ) { final uri uri = uri . create ( url ) ; final credentialsprovider credsprovider = new basiccredentialsprovider ( ) ; credsprovider . setcredentials ( new authscope ( uri . gethost ( ) , uri . getport ( ) ) , new usernamepasswordcredentials ( username , password ) ) ; builder = builder . setdefaultcredentialsprovider ( credsprovider ) ; } return builder . build ( ) ; }	Setup authentication in httpclient.
private httpurirequest minterrequest ( ) { switch ( method . touppercase ( ) ) { case str_ : return new httpget ( url ) ; case str_ : return new httpput ( url ) ; default : return new httppost ( url ) ; } }	Instantiate a request object based on the method variable.
protected string responsetopid ( final string responsetext ) throws ioexception { logger . debug ( str_ , responsetext ) ; if ( ! isblank ( regex ) ) { return responsetext . replacefirst ( regex , str_ ) ; } else if ( xpath != null ) { try { return xpath ( responsetext , xpath ) ; } catch ( parserconfigurationexception | saxexception | xpathexpressionexception e ) { throw new ioexception ( e ) ; } } else { return responsetext ; } }	Remove unwanted text from the minter service response to produce the desired identifier.Override this method for processing more complex than a simple regex replacement.
private static string xpath ( final string xml , final xpathexpression xpath ) throws parserconfigurationexception , saxexception , ioexception , xpathexpressionexception { final documentbuilder builder = document_builder_factory . newdocumentbuilder ( ) ; final document doc = builder . parse ( new bytearrayinputstream ( xml . getbytes ( ) ) ) ; return xpath . evaluate ( doc ) ; }	Extract the desired identifier value from an XML response using XPath.
@ timed @ override public string get ( ) { try { logger . debug ( str_ ) ; final httpresponse resp = client . execute ( minterrequest ( ) ) ; return responsetopid ( entityutils . tostring ( resp . getentity ( ) ) ) ; } catch ( final ioexception ex ) { logger . warn ( str_ , url , ex . getmessage ( ) ) ; throw new pidmintingexception ( str_ , ex ) ; } catch ( final exception ex ) { logger . warn ( str_ , ex . getmessage ( ) ) ; throw new pidmintingexception ( str_ , ex ) ; } }	Mint a unique identifier using an external HTTP API.
public static < t extends configuration > configurationbinder < t > forclass ( class < t > klass , binder binder ) { return new configurationbinder < > ( klass , binder ) ; }	The starting point for using a ConfigurationBinder.
public void toinstance ( config configuration ) { preconditions . checknotnull ( configuration , str_ ) ; if ( annotationclass == null ) { binder . bind ( configclass ) . toinstance ( configuration ) ; } else { binder . bind ( configclass ) . annotatedwith ( annotationclass ) . toinstance ( configuration ) ; } }	This method will bind the class to a particular instance.
public static filterpattern newinstance ( enumset < dispatchertype > dispatchertypes , boolean matchafter , iterable < string > patterns ) { return new filterpattern ( dispatchertypes , matchafter , immutablelist . copyof ( patterns ) ) ; }	Returns a new instance of FilterPattern, using the passed in arguments.
public t proceed ( ) throws throwable { try { return constructor ( ) . newinstance ( args ) ; } catch ( invocationtargetexception e ) { throw e . gettargetexception ( ) ; } }	Proceeds this constructor invocation.
