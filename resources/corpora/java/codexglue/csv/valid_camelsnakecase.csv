code	desc
@ can ignore return value public long copy to ( char sink sink ) throws io { check not null ( sink ) ; closer closer = closer . create ( ) ; try { reader reader = closer . register ( open stream ( ) ) ; writer writer = closer . register ( sink . open stream ( ) ) ; return char streams . copy ( reader , writer ) ; } catch ( throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }	Copies the contents of this source to the given sink.
public string read ( ) throws io { closer closer = closer . create ( ) ; try { reader reader = closer . register ( open stream ( ) ) ; return char streams . to string ( reader ) ; } catch ( throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }	Reads the contents of this source as a string.
@ override public int read ( byte [ ] b , int off , int len ) throws io {	buffer when possible.
private static char buffer grow ( char buffer buf ) { char [ ] copy = arrays . copy of ( buf . array ( ) , buf . capacity ( ) * num ) ; char buffer bigger = char buffer . wrap ( copy ) ; bigger . position ( buf . position ( ) ) ; bigger . limit ( buf . limit ( ) ) ; return bigger ; }	Returns a new CharBuffer identical to buf, except twice the capacity.
private void read more chars ( ) throws io {	Handle the case of underflow caused by needing more input characters.
private void start draining ( boolean overflow ) { byte buffer . flip ( ) ; if ( overflow && byte buffer . remaining ( ) == num ) { byte buffer = byte buffer . allocate ( byte buffer . capacity ( ) * num ) ; } else { draining = bool ; } }	Flips the buffer output buffer so we can start reading bytes from it.
public static boolean is empty ( iterable < ? > iterable ) { if ( iterable instanceof collection ) { return ( ( collection < ? > ) iterable ) . is empty ( ) ; } return ! iterable . iterator ( ) . has next ( ) ; }	Determines if the given iterable contains no elements. There is no precise {.
static < t > function < iterable < ? extends t > , iterator < ? extends t > > to iterator ( ) { return new function < iterable < ? extends t > , iterator < ? extends t > > ( ) { @ override public iterator < ? extends t > apply ( iterable < ? extends t > iterable ) { return iterable . iterator ( ) ; } } ; }	Useful as a public method?.
private static < t > iterator < t > consuming for array ( final t ... elements ) { return new unmodifiable iterator < t > ( ) { int index = num ; @ override public boolean has next ( ) { return index < elements . length ; } @ override public t next ( ) { if ( ! has next ( ) ) { throw new no such element exception ( ) ; } t result = elements [ index ] ; elements [ index ] = null ; index ++ ; return result ; } } ; }	Returns an Iterator that walks the specified array, nulling out elements behind it.
static < t > iterator < t > concat no defensive copy ( iterator < ? extends t > ... inputs ) { for ( iterator < ? extends t > input : check not null ( inputs ) ) { check not null ( input ) ; } return concat ( consuming for array ( inputs ) ) ; }	Concats a varargs array of iterators without making a defensive copy of the array.
static void clear ( iterator < ? > iterator ) { check not null ( iterator ) ; while ( iterator . has next ( ) ) { iterator . next ( ) ; iterator . remove ( ) ; } }	Clears the iterator using its remove method.
public void write ( byte [ ] bytes ) throws io { check not null ( bytes ) ; closer closer = closer . create ( ) ; try { output stream out = closer . register ( open stream ( ) ) ; out . write ( bytes ) ; out . flush ( ) ;	Writes all the given bytes to this sink.
public static cache builder spec parse ( string cache builder specification ) { cache builder spec spec = new cache builder spec ( cache builder specification ) ; if ( ! cache builder specification . is empty ( ) ) { for ( string key value pair : keys splitter . split ( cache builder specification ) ) { list < string > key and value = immutable list . copy of ( key value splitter . split ( key value pair ) ) ; check argument ( ! key and value . is empty ( ) , str ) ; check argument ( key and value . size ( ) <= num , str , key value pair ) ;	Creates a CacheBuilderSpec from a string.
cache builder < object , object > to cache builder ( ) { cache builder < object , object > builder = cache builder . new builder ( ) ; if ( initial capacity != null ) { builder . initial capacity ( initial capacity ) ; } if ( maximum size != null ) { builder . maximum size ( maximum size ) ; } if ( maximum weight != null ) { builder . maximum weight ( maximum weight ) ; } if ( concurrency level != null ) { builder . concurrency level ( concurrency level ) ; } if ( key strength != null ) { switch ( key strength ) { case weak : builder . weak keys ( ) ; break ; default : throw new assertion error ( ) ; } } if ( value strength != null ) { switch ( value strength ) { case soft : builder . soft values ( ) ; break ; case weak : builder . weak values ( ) ; break ; default : throw new assertion error ( ) ; } } if ( record stats != null && record stats ) { builder . record stats ( ) ; } if ( write expiration time unit != null ) { builder . expire after write ( write expiration duration , write expiration time unit ) ; } if ( access expiration time unit != null ) { builder . expire after access ( access expiration duration , access expiration time unit ) ; } if ( refresh time unit != null ) { builder . refresh after write ( refresh duration , refresh time unit ) ; } return builder ; }	Returns a CacheBuilder configured according to this instance's specification.
public joiner skip nulls ( ) { return new joiner ( this ) { @ override public < a extends appendable > a append to ( a appendable , iterator < ? > parts ) throws io { check not null ( appendable , str ) ; check not null ( parts , str ) ; while ( parts . has next ( ) ) { object part = parts . next ( ) ; if ( part != null ) { appendable . append ( joiner . this . to string ( part ) ) ; break ; } } while ( parts . has next ( ) ) { object part = parts . next ( ) ; if ( part != null ) { appendable . append ( separator ) ; appendable . append ( joiner . this . to string ( part ) ) ; } } return appendable ; } @ override public joiner use for null ( string null text ) { throw new unsupported operation exception ( str ) ; } @ override public map joiner with key value separator ( string kvs ) { throw new unsupported operation exception ( str ) ; } } ; }	Returns a joiner with the same behavior as this joiner, except automatically skipping over anyprovided null elements.
public static immutable int array of ( int first , int ... rest ) { check argument ( rest . length <= integer . max value - num , str ) ; int [ ] array = new int [ rest . length + num ] ; array [ num ] = first ; system . arraycopy ( rest , num , array , num , rest . length ) ; return new immutable int array ( array ) ; }	okay since we have to copy the just-created array anyway.
public immutable int array sub array ( int start index , int end index ) { preconditions . check position indexes ( start index , end index , length ( ) ) ; return start index == end index ? empty : new immutable int array ( array , start + start index , start + end index ) ; }	Returns a new immutable array containing the values in the specified range.
@ override @ can ignore return value public int read ( ) throws io { int b = in . read ( ) ; if ( b != - num ) { hasher . put byte ( ( byte ) b ) ; } return b ; }	Reads the next byte of data from the underlying input stream and updates the hasher with thebyte read.
@ override @ can ignore return value public int read ( byte [ ] bytes , int off , int len ) throws io { int num of bytes read = in . read ( bytes , off , len ) ; if ( num of bytes read != - num ) { hasher . put bytes ( bytes , off , num of bytes read ) ; } return num of bytes read ; }	Reads the specified bytes of data from the underlying input stream and updates the hasher withthe bytes read.
static < k , v > void write map ( map < k , v > map , object output stream stream ) throws io { stream . write int ( map . size ( ) ) ; for ( map . entry < k , v > entry : map . entry set ( ) ) { stream . write object ( entry . get key ( ) ) ; stream . write object ( entry . get value ( ) ) ; } }	Stores the contents of a map in an output stream, as part of serialization.
static < e > void write multiset ( multiset < e > multiset , object output stream stream ) throws io { int entry count = multiset . entry set ( ) . size ( ) ; stream . write int ( entry count ) ; for ( multiset . entry < e > entry : multiset . entry set ( ) ) { stream . write object ( entry . get element ( ) ) ; stream . write int ( entry . get count ( ) ) ; } }	Stores the contents of a multiset in an output stream, as part of serialization.
static < t > field setter < t > get field setter ( final class < t > clazz , string field name ) { try { field field = clazz . get declared field ( field name ) ; return new field setter < t > ( field ) ; } catch ( no such field exception e ) { throw new assertion error ( e ) ;	Secret sauce for setting final fields; don't make it public.
@ can ignore return value public stopwatch start ( ) { check state ( ! is running , str ) ; is running = bool ; start tick = ticker . read ( ) ; return this ; }	Starts the stopwatch.
@ can ignore return value @ override public int add ( e element , int occurrences ) { check not null ( element ) ; if ( occurrences == num ) { return count ( element ) ; } collect preconditions . check positive ( occurrences , str ) ; while ( bool ) { atomic integer existing counter = maps . safe get ( count map , element ) ; if ( existing counter == null ) { existing counter = count map . put if absent ( element , new atomic integer ( occurrences ) ) ; if ( existing counter == null ) { return num ; }	Adds a number of occurrences of the specified element to this multiset.
private void resize me maybe ( int new size ) { int entries size = entries . length ; if ( new size > entries size ) { int new capacity = entries size + math . max ( num , entries size > > > num ) ; if ( new capacity < num ) { new capacity = integer . max value ; } if ( new capacity != entries size ) { resize entries ( new capacity ) ; } } }	Resizes the entries storage if necessary.
private static inet address bytes to inet address ( byte [ ] addr ) { try { return inet address . get by address ( addr ) ; } catch ( unknown host exception e ) { throw new assertion error ( e ) ; } }	Convert a byte array into an InetAddress. {.
private static void compress longest run of zeroes ( int [ ] hextets ) { int best run start = - num ; int best run length = - num ; int run start = - num ; for ( int i = num ; i < hextets . length + num ; i ++ ) { if ( i < hextets . length && hextets [ i ] == num ) { if ( run start < num ) { run start = i ; } } else if ( run start >= num ) { int run length = i - run start ; if ( run length > best run length ) { best run start = run start ; best run length = run length ; } run start = - num ; } } if ( best run length >= num ) { arrays . fill ( hextets , best run start , best run start + best run length , - num ) ; } }	Identify and mark the longest run of zeroes in an IPv6 address.
private static string hextets to i ( int [ ] hextets ) {	Convert a list of hextets into a human-readable IPv6 address.
public static inet address for uri string ( string host addr ) { inet address addr = for uri string no throw ( host addr ) ; if ( addr == null ) { throw format illegal argument exception ( str , host addr ) ; } return addr ; }	Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded inthe format specified by RFC 3986 section 3.2.2.
public static inet4 address get compat i ( inet6 address ip ) { check argument ( is compat i ( ip ) , str , to addr string ( ip ) ) ; return get inet4 address ( arrays . copy of range ( ip . get address ( ) , num , num ) ) ; }	Returns the IPv4 address embedded in an IPv4 compatible address.
public static boolean is teredo address ( inet6 address ip ) { byte [ ] bytes = ip . get address ( ) ; return ( bytes [ num ] == ( byte ) num ) && ( bytes [ num ] == ( byte ) num ) && ( bytes [ num ] == num ) && ( bytes [ num ] == num ) ; }	Evaluates whether the argument is a Teredo address. Teredo addresses begin with the {.
public static boolean is isatap address ( inet6 address ip ) {	Evaluates whether the argument is an ISATAP address.
public static inet4 address get isatap i ( inet6 address ip ) { check argument ( is isatap address ( ip ) , str , to addr string ( ip ) ) ; return get inet4 address ( arrays . copy of range ( ip . get address ( ) , num , num ) ) ; }	Returns the IPv4 address embedded in an ISATAP address.
public static inet4 address get embedded i ( inet6 address ip ) { if ( is compat i ( ip ) ) { return get compat i ( ip ) ; } if ( is6to4 address ( ip ) ) { return get6to4 i ( ip ) ; } if ( is teredo address ( ip ) ) { return get teredo info ( ip ) . get client ( ) ; } throw format illegal argument exception ( str , to addr string ( ip ) ) ; }	Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is anIPv6 address of one of the specified address types that contain an embedded IPv4 address.
public static inet address decrement ( inet address address ) { byte [ ] addr = address . get address ( ) ; int i = addr . length - num ; while ( i >= num && addr [ i ] == ( byte ) num ) { addr [ i ] = ( byte ) num ; i -- ; } check argument ( i >= num , str , address ) ; addr [ i ] -- ; return bytes to inet address ( addr ) ; }	Returns a new InetAddress that is one less than the passed in address.
@ beta public static buffered reader new reader ( file file , charset charset ) throws file not found exception { check not null ( file ) ; check not null ( charset ) ; return new buffered reader ( new input stream reader ( new file input stream ( file ) , charset ) ) ; }	Returns a buffered reader that reads from a file using the given character set. {.
@ beta public static void write ( byte [ ] from , file to ) throws io { as byte sink ( to ) . write ( from ) ; }	Overwrites a file with the contents of a byte array. {.
@ beta public static void copy ( file from , output stream to ) throws io { as byte source ( from ) . copy to ( to ) ; }	Copies all bytes from a file to an output stream. {.
@ beta @ suppress warnings ( str )	Creates an empty file or updates the last updated timestamp on the same as the unix command ofthe same name.
@ beta @ deprecated public static string read first line ( file file , charset charset ) throws io { return as char source ( file , charset ) . read first line ( ) ; }	Reads the first line from a file.
@ beta public static < k , v > builder < k , v > builder with expected size ( int expected size ) { check nonnegative ( expected size , str ) ; return new builder < > ( expected size ) ; }	Returns a new builder, expecting the specified number of entries to be added. If {.
@ can ignore return value @ deprecated @ override public v force put ( k key , v value ) { throw new unsupported operation exception ( ) ; }	Guaranteed to throw an exception and leave the bimap unmodified.
public static < e extends comparable < e > > min max priority queue < e > create ( iterable < ? extends e > initial contents ) { return new builder < e > ( ordering . < e > natural ( ) ) . create ( initial contents ) ; }	Creates a new min-max priority queue using natural order, no maximum size, and initiallycontaining the given elements.
private int calculate new capacity ( ) { int old capacity = queue . length ; int new capacity = ( old capacity < num ) ? ( old capacity + num ) * num : int math . checked multiply ( old capacity / num , num ) ; return cap at maximum size ( new capacity , maximum size ) ; }	Returns ~2x the old capacity if small; ~1.5x otherwise.
private static hash code fmix ( int h1 , int length ) { h1 ^= length ; h1 ^= h1 > > > num ; h1 *= num ; h1 ^= h1 > > > num ; h1 *= num ; h1 ^= h1 > > > num ; return hash code . from int ( h1 ) ; }	Finalization mix - force all bits of a hash block to avalanche.
public static < s extends comparable < ? super s > > element order < s > natural ( ) { return new element order < s > ( type . sorted , ordering . < s > natural ( ) ) ; }	Returns an instance which specifies that the natural ordering of the elements is guaranteed.
@ suppress warnings ( str )	Enters this monitor. Blocks at most the given time.
@ suppress warnings ( str )	Enters this monitor. Blocks at most the given time, and may be interrupted.
public void enter when ( guard guard ) throws interrupted exception { if ( guard . monitor != this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; boolean signal before waiting = lock . is held by current thread ( ) ; lock . lock interruptibly ( ) ; boolean satisfied = bool ; try { if ( ! guard . is satisfied ( ) ) { await ( guard , signal before waiting ) ; } satisfied = bool ; } finally { if ( ! satisfied ) { leave ( ) ; } } }	Enters this monitor when the guard is satisfied.
@ suppress warnings ( str )	Enters this monitor when the guard is satisfied.
public void enter when uninterruptibly ( guard guard ) { if ( guard . monitor != this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; boolean signal before waiting = lock . is held by current thread ( ) ; lock . lock ( ) ; boolean satisfied = bool ; try { if ( ! guard . is satisfied ( ) ) { await uninterruptibly ( guard , signal before waiting ) ; } satisfied = bool ; } finally { if ( ! satisfied ) { leave ( ) ; } } }	Enters this monitor when the guard is satisfied.
public boolean enter if ( guard guard ) { if ( guard . monitor != this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; lock . lock ( ) ; boolean satisfied = bool ; try { return satisfied = guard . is satisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } }	Enters this monitor if the guard is satisfied.
@ suppress warnings ( str )	Enters this monitor if the guard is satisfied.
public boolean enter if interruptibly ( guard guard ) throws interrupted exception { if ( guard . monitor != this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; boolean satisfied = bool ; try { return satisfied = guard . is satisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } }	Enters this monitor if the guard is satisfied.
public boolean try enter if ( guard guard ) { if ( guard . monitor != this ) { throw new illegal monitor state exception ( ) ; } final reentrant lock lock = this . lock ; if ( ! lock . try lock ( ) ) { return bool ; } boolean satisfied = bool ; try { return satisfied = guard . is satisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } }	Enters this monitor if it is possible to do so immediately and the guard is satisfied.
public void wait for ( guard guard ) throws interrupted exception { if ( ! ( ( guard . monitor == this ) & lock . is held by current thread ( ) ) ) { throw new illegal monitor state exception ( ) ; } if ( ! guard . is satisfied ( ) ) { await ( guard , bool ) ; } }	Waits for the guard to be satisfied.
public void wait for uninterruptibly ( guard guard ) { if ( ! ( ( guard . monitor == this ) & lock . is held by current thread ( ) ) ) { throw new illegal monitor state exception ( ) ; } if ( ! guard . is satisfied ( ) ) { await uninterruptibly ( guard , bool ) ; } }	Waits for the guard to be satisfied.
@ suppress warnings ( str )	Waits for the guard to be satisfied.
public int get wait queue length ( guard guard ) { if ( guard . monitor != this ) { throw new illegal monitor state exception ( ) ; } lock . lock ( ) ; try { return guard . waiter count ; } finally { lock . unlock ( ) ; } }	Returns an estimate of the number of threads waiting for the given guard to become satisfied.Note that because timeouts and interrupts may occur at any time, the estimate serves only as anupper bound on the actual number of waiters.
@ guarded by ( str ) private void signal all waiters ( ) { for ( guard guard = active guards ; guard != null ; guard = guard . next ) { guard . condition . signal all ( ) ; } }	Signals all threads waiting on guards.
@ guarded by ( str ) private void begin waiting for ( guard guard ) { int waiters = guard . waiter count ++ ; if ( waiters == num ) {	Records that the current thread is about to wait on the specified guard.
@ guarded by ( str ) private void end waiting for ( guard guard ) { int waiters = -- guard . waiter count ; if ( waiters == num ) {	Records that the current thread is no longer waiting on the specified guard.
@ guarded by ( str ) private boolean await nanos ( guard guard , long nanos , boolean signal before waiting ) throws interrupted exception { boolean first time = bool ; try { do { if ( nanos <= num ) { return bool ; } if ( first time ) { if ( signal before waiting ) { signal next waiter ( ) ; } begin waiting for ( guard ) ; first time = bool ; } nanos = guard . condition . await nanos ( nanos ) ; } while ( ! guard . is satisfied ( ) ) ; return bool ; } finally { if ( ! first time ) { end waiting for ( guard ) ; } } }	Caller should check before calling that guard is not satisfied.
public void write ( char sequence char sequence ) throws io { check not null ( char sequence ) ; closer closer = closer . create ( ) ; try { writer out = closer . register ( open stream ( ) ) ; out . append ( char sequence ) ; out . flush ( ) ;	Writes the given character sequence to this sink.
public void execute ( ) {	Runs this execution list, executing all existing pairs in the order they were added.
static long load64 safely ( byte [ ] input , int offset , int length ) { long result = num ;	Similar to load64, but allows offset + 8 > input.length, padding the result with zeroes.
static void store64 ( byte [ ] sink , int offset , long value ) {	Store 8 bytes into the provided array at the indicated offset, using the value provided.
static int load32 ( byte [ ] source , int offset ) {	Load 4 bytes from the provided array at the indicated offset.
public static media type create ( string type , string subtype ) { media type media type = create ( type , subtype , immutable list multimap . < string , string > of ( ) ) ; media type . parsed charset = optional . absent ( ) ; return media type ; }	Creates a new media type with the given type and subtype.
public static media type parse ( string input ) { check not null ( input ) ; tokenizer tokenizer = new tokenizer ( input ) ; try { string type = tokenizer . consume token ( token matcher ) ; tokenizer . consume character ( str ) ; string subtype = tokenizer . consume token ( token matcher ) ; immutable list multimap . builder < string , string > parameters = immutable list multimap . builder ( ) ; while ( tokenizer . has more ( ) ) { tokenizer . consume token if present ( linear white space ) ; tokenizer . consume character ( str ) ; tokenizer . consume token if present ( linear white space ) ; string attribute = tokenizer . consume token ( token matcher ) ; tokenizer . consume character ( str ) ; final string value ; if ( str == tokenizer . preview char ( ) ) { tokenizer . consume character ( str ) ; string builder value builder = new string builder ( ) ; while ( str != tokenizer . preview char ( ) ) { if ( str == tokenizer . preview char ( ) ) { tokenizer . consume character ( str ) ; value builder . append ( tokenizer . consume character ( ascii ( ) ) ) ; } else { value builder . append ( tokenizer . consume token ( quoted text matcher ) ) ; } } value = value builder . to string ( ) ; tokenizer . consume character ( str ) ; } else { value = tokenizer . consume token ( token matcher ) ; } parameters . put ( attribute , value ) ; } return create ( type , subtype , parameters . build ( ) ) ; } catch ( illegal state exception e ) { throw new illegal argument exception ( str + input + str , e ) ; } }	Parses a media type from its string representation.
final type capture ( ) { type superclass = get class ( ) . get generic superclass ( ) ; check argument ( superclass instanceof parameterized type , str , superclass ) ; return ( ( parameterized type ) superclass ) . get actual type arguments ( ) [ num ] ; }	Returns the captured type.
static boolean remove all impl ( set < ? > set , iterator < ? > iterator ) { boolean changed = bool ; while ( iterator . has next ( ) ) { changed |= set . remove ( iterator . next ( ) ) ; } return changed ; }	Remove each element in an iterable from a set.
@ override public string escape ( string string ) { check not null ( string ) ;	Returns the escaped form of a given literal string.
private static char [ ] grow buffer ( char [ ] dest , int index , int size ) { if ( size < num ) {	Helper method to grow the character buffer as needed, this only happens once in a while so it'sok if it's in a method call.
public < k1 extends k , v1 extends v > cache < k1 , v1 > build ( ) { check weight with weigher ( ) ; check non loading cache ( ) ; return new local cache . local manual cache < > ( this ) ; }	Builds a cache which does not automatically load values when keys are requested. Consider {.
void alloc arrays ( ) { preconditions . check state ( needs alloc arrays ( ) , str ) ; int expected size = mod count ; int buckets = hashing . closed table size ( expected size , load factor ) ; this . table = new table ( buckets ) ; this . entries = new entries ( expected size ) ; this . keys = new object [ expected size ] ; this . values = new object [ expected size ] ; }	Handle lazy allocation of arrays.
public void add ( double value ) { if ( count == num ) { count = num ; mean = value ; min = value ; max = value ; if ( ! is finite ( value ) ) { sum of squares of deltas = n ; } } else { count ++ ; if ( is finite ( value ) && is finite ( mean ) ) {	Adds the given value to the dataset.
static double calculate new mean non finite ( double previous mean , double value ) { if ( is finite ( previous mean ) ) {	Calculates the new value for the accumulated mean when a value is added, in the case where atleast one of the previous mean and the value is non-finite.
static object [ ] rebuild hash table ( int new table size , object [ ] elements , int n ) { object [ ] hash table = new object [ new table size ] ; int mask = hash table . length - num ; for ( int i = num ; i < n ; i ++ ) { object e = elements [ i ] ; int j0 = hashing . smear ( e . hash code ( ) ) ; for ( int j = j0 ; ; j ++ ) { int index = j & mask ; if ( hash table [ index ] == null ) { hash table [ index ] = e ; break ; } } } return hash table ; }	Builds a new open-addressed hash table from the first n objects in elements.
@ visible for testing static int choose table size ( int set size ) { set size = math . max ( set size , num ) ;	Returns an array size suitable for the backing array of a hash table that uses open addressingwith linear probing in its implementation.
@ suppress warnings ( str ) public static < r , c , v > immutable table < r , c , v > of ( ) { return ( immutable table < r , c , v > ) sparse immutable table . empty ; }	Returns an empty immutable table.
public static < r , c , v > immutable table < r , c , v > of ( r row key , c column key , v value ) { return new singleton immutable table < > ( row key , column key , value ) ; }	Returns an immutable table containing a single cell.
@ suppress warnings ( str )	Returns a serializable converter that always converts or reverses an object to itself.
static < r , c , v > regular immutable table < r , c , v > for ordered components ( immutable list < cell < r , c , v > > cell list , immutable set < r > row space , immutable set < c > column space ) {	A factory that chooses the most space-efficient representation of the table.
public static < e extends comparable < ? super e > > immutable sorted multiset < e > of ( e element ) { regular immutable sorted set < e > element set = ( regular immutable sorted set < e > ) immutable sorted set . of ( element ) ; long [ ] cumulative counts = { num , num } ; return new regular immutable sorted multiset < e > ( element set , cumulative counts , num , num ) ; }	Returns an immutable sorted multiset containing a single element.
public static < e extends comparable < ? > > builder < e > reverse order ( ) { return new builder < e > ( ordering . natural ( ) . reverse ( ) ) ; }	Returns a builder that creates immutable sorted multisets whose elements are ordered by thereverse of their natural ordering. Note: the type parameter {.
private static < e > boolean retain occurrences impl ( multiset < e > multiset to modify , multiset < ? > occurrences to retain ) { check not null ( multiset to modify ) ; check not null ( occurrences to retain ) ;	Delegate implementation which cares about the element type.
@ deprecated public final fluent iterable < t > pre order traversal ( final t root ) { check not null ( root ) ; return new fluent iterable < t > ( ) { @ override public unmodifiable iterator < t > iterator ( ) { return pre order iterator ( root ) ; } @ override public void for each ( consumer < ? super t > action ) { check not null ( action ) ; new consumer < t > ( ) { @ override public void accept ( t t ) { action . accept ( t ) ; children ( t ) . for each ( this ) ; } } . accept ( root ) ; } } ; }	Returns an unmodifiable iterable over the nodes in a tree structure, using pre-order traversal.That is, each node's subtrees are traversed after the node itself is returned.
static string builder new string builder for collection ( int size ) { check nonnegative ( size , str ) ; return new string builder ( ( int ) math . min ( size * num , ints . max power of two ) ) ; }	Returns best-effort-sized StringBuilder based on the given collection size.
final void set map ( map < k , collection < v > > map ) { this . map = map ; total size = num ; for ( collection < v > values : map . values ( ) ) { check argument ( ! values . is empty ( ) ) ; total size += values . size ( ) ; } }	Used during deserialization only.
private void remove values for key ( object key ) { collection < v > collection = maps . safe remove ( map , key ) ; if ( collection != null ) { int count = collection . size ( ) ; collection . clear ( ) ; total size -= count ; } }	Removes all values for the provided key.
private static < t > fluent iterable < t > concat no defensive copy ( final iterable < ? extends t > ... inputs ) { for ( iterable < ? extends t > input : inputs ) { check not null ( input ) ; } return new fluent iterable < t > ( ) { @ override public iterator < t > iterator ( ) { return iterators . concat ( new abstract indexed list iterator < iterator < ? extends t > > ( inputs . length ) { @ override public iterator < ? extends t > get ( int i ) { return inputs [ i ] . iterator ( ) ; } } ) ; } } ; }	Concatenates a varargs array of iterables without making a defensive copy of the array.
@ beta public static < e > fluent iterable < e > of ( ) { return fluent iterable . from ( immutable list . < e > of ( ) ) ; }	Returns a fluent iterable containing no elements. {.
public static < k , v > immutable multimap < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { return immutable list multimap . of ( k1 , v1 , k2 , v2 ) ; }	Returns an immutable multimap containing the given entries, in order.
@ override public immutable collection < entry < k , v > > entries ( ) { return ( immutable collection < entry < k , v > > ) super . entries ( ) ; }	Returns an immutable collection of all key-value pairs in the multimap.
private long count by skipping ( input stream in ) throws io { long count = num ; long skipped ; while ( ( skipped = skip up to ( in , integer . max value ) ) > num ) { count += skipped ; } return count ; }	Counts the bytes in the given input stream using skip if possible.
public byte [ ] read ( ) throws io { closer closer = closer . create ( ) ; try { input stream in = closer . register ( open stream ( ) ) ; optional < long > size = size if known ( ) ; return size . is present ( ) ? byte streams . to byte array ( in , size . get ( ) ) : byte streams . to byte array ( in ) ; } catch ( throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }	Reads the full contents of this byte source as a byte array.
public hash code hash ( hash function hash function ) throws io { hasher hasher = hash function . new hasher ( ) ; copy to ( funnels . as output stream ( hasher ) ) ; return hasher . hash ( ) ; }	Hashes the contents of this byte source using the given hash function.
public boolean content equals ( byte source other ) throws io { check not null ( other ) ; byte [ ] buf1 = create buffer ( ) ; byte [ ] buf2 = create buffer ( ) ; closer closer = closer . create ( ) ; try { input stream in1 = closer . register ( open stream ( ) ) ; input stream in2 = closer . register ( other . open stream ( ) ) ; while ( bool ) { int read1 = byte streams . read ( in1 , buf1 , num , buf1 . length ) ; int read2 = byte streams . read ( in2 , buf2 , num , buf2 . length ) ; if ( read1 != read2 || ! arrays . equals ( buf1 , buf2 ) ) { return bool ; } else if ( read1 != buf1 . length ) { return bool ; } } } catch ( throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }	Checks that the contents of this byte source are equal to the contents of the given bytesource.
@ suppress warnings ( str ) public static < k extends comparable < ? > , v > immutable range map < k , v > of ( ) { return ( immutable range map < k , v > ) empty ; }	Returns an empty immutable range map.
public static < k extends comparable < ? > , v > immutable range map < k , v > of ( range < k > range , v value ) { return new immutable range map < > ( immutable list . of ( range ) , immutable list . of ( value ) ) ; }	Returns an immutable range map mapping a single range to a single value.
public static hash function concatenating ( hash function first , hash function second , hash function ... rest ) {	Returns a hash function which computes its hash code by concatenating the hash codes of theunderlying hash functions together.
public static < e extends comparable < ? super e > > immutable sorted set < e > of ( e element ) { return new regular immutable sorted set < e > ( immutable list . of ( element ) , ordering . natural ( ) ) ; }	Returns an immutable sorted set containing a single element.
public value graph builder < n , v > expected node count ( int expected node count ) { this . expected node count = optional . of ( check non negative ( expected node count ) ) ; return this ; }	Specifies the expected number of nodes in the graph.
public static < t , s extends t > comparator < iterable < s > > lexicographical ( comparator < t > comparator ) { return new lexicographical ordering < s > ( check not null ( comparator ) ) ; }	think tip it over into being worthwhile.
public static void start finalizer ( class < ? > finalizable reference class , reference queue < object > queue , phantom reference < object > frq reference ) { if ( ! finalizable reference class . get name ( ) . equals ( finalizable reference ) ) { throw new illegal argument exception ( str + finalizable reference + str ) ; } finalizer finalizer = new finalizer ( finalizable reference class , queue , frq reference ) ; string thread name = finalizer . class . get name ( ) ; thread thread = null ; if ( big thread constructor != null ) { try { boolean inherit thread locals = bool ; long default stack size = num ; thread = big thread constructor . new instance ( ( thread group ) null , finalizer , thread name , default stack size , inherit thread locals ) ; } catch ( throwable t ) { logger . log ( level . info , str , t ) ; } } if ( thread == null ) { thread = new thread ( ( thread group ) null , finalizer , thread name ) ; } thread . set daemon ( bool ) ; try { if ( inheritable thread locals != null ) { inheritable thread locals . set ( thread , null ) ; } } catch ( throwable t ) { logger . log ( level . info , str , t ) ; } thread . start ( ) ; }	Starts the Finalizer thread.
@ suppress warnings ( str )	Returns the empty sorted map.
public static < k extends comparable < ? super k > , v > immutable sorted map < k , v > of ( k k1 , v v1 ) { return of ( ordering . natural ( ) , k1 , v1 ) ; }	Returns an immutable map containing a single entry.
@ suppress warnings ( str ) public static < k extends comparable < ? super k > , v > immutable sorted map < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { return of entries ( entry of ( k1 , v1 ) , entry of ( k2 , v2 ) ) ; }	Returns an immutable sorted map containing the given entries, sorted by the natural ordering oftheir keys.
@ suppress warnings ( str ) public static < k , v > immutable sorted map < k , v > copy of sorted ( sorted map < k , ? extends v > map ) { comparator < ? super k > comparator = map . comparator ( ) ; if ( comparator == null ) {	Returns an immutable map containing the same entries as the provided sorted map, with the sameordering.
private static void weak hash length32 with seeds ( byte [ ] bytes , int offset , long seed a , long seed b , long [ ] output ) { long part1 = load64 ( bytes , offset ) ; long part2 = load64 ( bytes , offset + num ) ; long part3 = load64 ( bytes , offset + num ) ; long part4 = load64 ( bytes , offset + num ) ; seed a += part1 ; seed b = rotate right ( seed b + seed a + part4 , num ) ; long c = seed a ; seed a += part2 ; seed a += part3 ; seed b += rotate right ( seed a , num ) ; output [ num ] = seed a + part4 ; output [ num ] = seed b + c ; }	Computes intermediate hash of 32 bytes of byte array from the given offset.
@ guarded by ( str ) private void check current state ( state expected ) { state actual = state ( ) ; if ( actual != expected ) { if ( actual == failed ) {	Checks that the current state is equal to the expected state.
public static immutable list < path > list files ( path dir ) throws io { try ( directory stream < path > stream = files . new directory stream ( dir ) ) { return immutable list . copy of ( stream ) ; } catch ( directory iterator exception e ) { throw e . get cause ( ) ; } }	Returns an immutable list of paths to the files contained in the given directory.
private static boolean is directory ( secure directory stream < path > dir , path name , link option ... options ) throws io { return dir . get file attribute view ( name , basic file attribute view . class , options ) . read attributes ( ) . is directory ( ) ; }	Returns whether or not the file with the given name in the given dir is a directory.
public static boolean equal ( path path1 , path path2 ) throws io { check not null ( path1 ) ; check not null ( path2 ) ; if ( files . is same file ( path1 , path2 ) ) { return bool ; } byte source source1 = as byte source ( path1 ) ; byte source source2 = as byte source ( path2 ) ; long len1 = source1 . size if known ( ) . or ( num ) ; long len2 = source2 . size if known ( ) . or ( num ) ; if ( len1 != num && len2 != num && len1 != len2 ) { return bool ; } return source1 . content equals ( source2 ) ; }	Returns true if the files located by the given paths exist, are not directories, and containthe same bytes.
@ suppress warnings ( str )	Like the unix command of the same name, creates an empty file or updates the last modifiedtimestamp of the existing file at the given path to the current system time.
private static @ nullable path get parent path ( path path ) { path parent = path . get parent ( ) ;	Returns a path to the parent directory of the given path.
private static void check allows insecure ( path path , recursive delete option [ ] options ) throws insecure recursive delete exception { if ( ! arrays . as list ( options ) . contains ( recursive delete option . allow insecure ) ) { throw new insecure recursive delete exception ( path . to string ( ) ) ; } }	Checks that the given options allow an insecure delete, throwing an exception if not.
private static void throw delete failed ( path path , collection < io > exceptions ) throws file system exception {	Throws an exception indicating that one or more files couldn't be deleted.
static int rehash ( int h ) {	Applies a supplemental hash function to a given hash code, which defends against poor qualityhash functions.
segment < k , v , e , s > segment for ( int hash ) {	Returns the segment that should be used for a key with the given hash.
static < e > immutable list < e > unsafe delegate list ( list < ? extends e > list ) { switch ( list . size ( ) ) { case num : return of ( ) ; case num : return of ( list . get ( num ) ) ; default : @ suppress warnings ( str ) list < e > casted list = ( list < e > ) list ; return new regular immutable list < e > ( casted list ) ; } }	are guaranteed to be non-null.
private range < k > coalesced range ( range < k > range , v value ) { range < k > coalesced range = range ; entry < cut < k > , range map entry < k , v > > lower entry = entries by lower bound . lower entry ( range . lower bound ) ; coalesced range = coalesce ( coalesced range , value , lower entry ) ; entry < cut < k > , range map entry < k , v > > higher entry = entries by lower bound . floor entry ( range . upper bound ) ; coalesced range = coalesce ( coalesced range , value , higher entry ) ; return coalesced range ; }	Computes the coalesced range for the given range+value - does not mutate the map.
void unregister ( object listener ) { multimap < class < ? > , subscriber > listener methods = find all subscribers ( listener ) ; for ( entry < class < ? > , collection < subscriber > > entry : listener methods . as map ( ) . entry set ( ) ) { class < ? > event type = entry . get key ( ) ; collection < subscriber > listener methods for type = entry . get value ( ) ; copy on write array set < subscriber > current subscribers = subscribers . get ( event type ) ; if ( current subscribers == null || ! current subscribers . remove all ( listener methods for type ) ) {	Unregisters all subscribers on the given listener object.
iterator < subscriber > get subscribers ( object event ) { immutable set < class < ? > > event types = flatten hierarchy ( event . get class ( ) ) ; list < iterator < subscriber > > subscriber iterators = lists . new array list with capacity ( event types . size ( ) ) ; for ( class < ? > event type : event types ) { copy on write array set < subscriber > event subscribers = subscribers . get ( event type ) ; if ( event subscribers != null ) {	Gets an iterator representing an immutable snapshot of all subscribers to the given event atthe time this method is called.
private multimap < class < ? > , subscriber > find all subscribers ( object listener ) { multimap < class < ? > , subscriber > methods in listener = hash multimap . create ( ) ; class < ? > clazz = listener . get class ( ) ; for ( method method : get annotated methods ( clazz ) ) { class < ? > [ ] parameter types = method . get parameter types ( ) ; class < ? > event type = parameter types [ num ] ; methods in listener . put ( event type , subscriber . create ( bus , listener , method ) ) ; } return methods in listener ; }	Returns all subscribers for the given listener grouped by the type of event they subscribe to.
static < e > immutable list < e > as immutable list ( object [ ] elements ) { return as immutable list ( elements , elements . length ) ; }	Views the array as an immutable list.
static < e > immutable list < e > as immutable list ( object [ ] elements , int length ) { if ( length == num ) { return of ( ) ; } return new regular immutable list < e > ( elements , length ) ; }	Views the array as an immutable list.
@ beta public static < e > builder < e > builder with expected size ( int expected size ) { check nonnegative ( expected size , str ) ; return new immutable list . builder < e > ( expected size ) ; }	Returns a new builder, expecting the specified number of elements to be added. If {.
private static wildcard type canonicalize wildcard type ( type variable < ? > declaration , wildcard type type ) { type [ ] declared = declaration . get bounds ( ) ; list < type > upper bounds = new array list < > ( ) ; for ( type bound : type . get upper bounds ( ) ) { if ( ! any ( declared ) . is subtype of ( bound ) ) { upper bounds . add ( canonicalize wildcards in type ( bound ) ) ; } } return new types . wildcard type impl ( type . get lower bounds ( ) , upper bounds . to array ( new type [ num ] ) ) ; }	Just don't ever let the user access it.
static < e > immutable list < e > as immutable list ( object [ ] elements , int length ) { switch ( length ) { case num : return of ( ) ; case num : return of ( ( e ) elements [ num ] ) ; default : if ( length < elements . length ) { elements = arrays . copy of ( elements , length ) ; } return new regular immutable list < e > ( elements ) ; } }	Views the array as an immutable list.
@ deprecated public static < k , v > immutable sorted map . builder < k , v > builder with expected size ( int expected size ) { throw new unsupported operation exception ( ) ; }	Not supported for ImmutableSortedMap.
@ override public immutable set < entry < k , v > > entry set ( ) { immutable set < entry < k , v > > result = entry set ; return ( result == null ) ? entry set = create entry set ( ) : result ; }	Returns an immutable set of the mappings in this map.
@ can ignore return value private boolean finish line ( boolean saw newline ) throws io { string separator = saw return ? ( saw newline ? str : str ) : ( saw newline ? str : str ) ; handle line ( line . to string ( ) , separator ) ; line = new string builder ( ) ; saw return = bool ; return saw newline ; }	Called when a line is complete.
static < k , v1 , v2 > entry transformer < k , v1 , v2 > as entry transformer ( final function < ? super v1 , v2 > function ) { check not null ( function ) ; return new entry transformer < k , v1 , v2 > ( ) { @ override public v2 transform entry ( k key , v1 value ) { return function . apply ( value ) ; } } ; }	Views a function as an entry transformer that ignores the entry key.
static < v2 , k , v1 > entry < k , v2 > transform entry ( final entry transformer < ? super k , ? super v1 , v2 > transformer , final entry < k , v1 > entry ) { check not null ( transformer ) ; check not null ( entry ) ; return new abstract map entry < k , v2 > ( ) { @ override public k get key ( ) { return entry . get key ( ) ; } @ override public v2 get value ( ) { return transformer . transform entry ( entry . get key ( ) , entry . get value ( ) ) ; } } ; }	Returns a view of an entry transformed by the specified transformer.
static < k , v1 , v2 > function < entry < k , v1 > , entry < k , v2 > > as entry to entry function ( final entry transformer < ? super k , ? super v1 , v2 > transformer ) { check not null ( transformer ) ; return new function < entry < k , v1 > , entry < k , v2 > > ( ) { @ override public entry < k , v2 > apply ( final entry < k , v1 > entry ) { return transform entry ( transformer , entry ) ; } } ; }	Views an entry transformer as a function from entries to entries.
static < e > immutable map < e , integer > index map ( collection < e > list ) { immutable map . builder < e , integer > builder = new immutable map . builder < > ( list . size ( ) ) ; int i = num ; for ( e e : list ) { builder . put ( e , i ++ ) ; } return builder . build ( ) ; }	Returns a map from the ith element of list to i.
protected @ nullable string pending to string ( ) { object local value = value ; if ( local value instanceof set future ) { return str + user object to string ( ( ( set future ) local value ) . future ) + str ; } else if ( this instanceof scheduled future ) { return str + ( ( scheduled future ) this ) . get delay ( time unit . milliseconds ) + str ; } return null ; }	Provide a human-readable explanation of why this future has not yet completed.
protected void update ( byte buffer b ) { if ( b . has array ( ) ) { update ( b . array ( ) , b . array offset ( ) + b . position ( ) , b . remaining ( ) ) ; b . position ( b . limit ( ) ) ; } else { for ( int remaining = b . remaining ( ) ; remaining > num ; remaining -- ) { update ( b . get ( ) ) ; } } }	Updates this hasher with bytes from the given buffer.
static < e > immutable sorted set < e > unsafe delegate sorted set ( sorted set < e > delegate , boolean is subset ) { return delegate . is empty ( ) ? empty set ( delegate . comparator ( ) ) : new regular immutable sorted set < e > ( delegate , is subset ) ; }	Assumes that delegate doesn't have null elements and comparator.
@ suppress warnings ( str ) public static immutable set multimap < object , object > instantiate ( serialization stream reader reader ) throws serialization exception { comparator < object > value comparator = ( comparator < object > ) reader . read object ( ) ; immutable set multimap . builder < object , object > builder = immutable set multimap . builder ( ) ; if ( value comparator != null ) { builder . order values by ( value comparator ) ; } return ( immutable set multimap < object , object > ) multimap custom field serializer base . instantiate ( reader , builder ) ; }	Serialization type safety is at the caller's mercy.
public long sum ( ) { long sum = num ; for ( atomic long value : map . values ( ) ) { sum = sum + value . get ( ) ; } return sum ; }	Returns the sum of all values in this map.
private static class < ? > load finalizer ( finalizer loader ... loaders ) { for ( finalizer loader loader : loaders ) { class < ? > finalizer = loader . load finalizer ( ) ; if ( finalizer != null ) { return finalizer ; } } throw new assertion error ( ) ; }	Iterates through the given loaders until it finds one that can load Finalizer.
public void dispatch ( ) {	Dispatches all events enqueued prior to this call, serially and in order, for every listener. Note: this method is idempotent and safe to call from any thread.
public static void copy ( url from , output stream to ) throws io { as byte source ( from ) . copy to ( to ) ; }	Copies all bytes from a URL to an output stream.
public void post ( object event ) { iterator < subscriber > event subscribers = subscribers . get subscribers ( event ) ; if ( event subscribers . has next ( ) ) { dispatcher . dispatch ( event , event subscribers ) ; } else if ( ! ( event instanceof dead event ) ) {	Posts an event to all registered subscribers.
void set delegates ( map < k , v > forward , map < v , k > backward ) { check state ( delegate == null ) ; check state ( inverse == null ) ; check argument ( forward . is empty ( ) ) ; check argument ( backward . is empty ( ) ) ; check argument ( forward != backward ) ; delegate = forward ; inverse = make inverse ( backward ) ; }	Specifies the delegate maps going in each direction.
@ override public void execute ( final runnable task ) { check not null ( task ) ; final runnable submitted task ; final long old run count ; synchronized ( queue ) {	Adds a task to the queue and makes sure a worker thread is running.
public static < e extends comparable > tree multiset < e > create ( iterable < ? extends e > elements ) { tree multiset < e > multiset = create ( ) ; iterables . add all ( multiset , elements ) ; return multiset ; }	Creates an empty multiset containing the given initial elements, sorted according to theelements' natural order. This implementation is highly efficient when {.
private static boolean add causal chain ( set < throwable > seen , throwable t ) { for ( ; t != null ; t = t . get cause ( ) ) { boolean first time seen = seen . add ( t ) ; if ( ! first time seen ) { return bool ; } } return bool ; }	Adds the chain to the seen set, and returns whether all the chain was new to us.
public thread factory builder set priority ( int priority ) {	Sets the priority for new threads created with this ThreadFactory.
public static host and port from parts ( string host , int port ) { check argument ( is valid port ( port ) , str , port ) ; host and port parsed host = from string ( host ) ; check argument ( ! parsed host . has port ( ) , str , host ) ; return new host and port ( parsed host . host , port , parsed host . has bracketless colons ) ; }	Build a HostAndPort instance from separate host and port values.
public static host and port from host ( string host ) { host and port parsed host = from string ( host ) ; check argument ( ! parsed host . has port ( ) , str , host ) ; return parsed host ; }	Build a HostAndPort instance from a host only.
public static host and port from string ( string host port string ) { check not null ( host port string ) ; string host ; string port string = null ; boolean has bracketless colons = bool ; if ( host port string . starts with ( str ) ) { string [ ] host and port = get host and port from bracketed host ( host port string ) ; host = host and port [ num ] ; port string = host and port [ num ] ; } else { int colon pos = host port string . index of ( str ) ; if ( colon pos >= num && host port string . index of ( str , colon pos + num ) == - num ) {	Split a freeform string into a host and port, without strict validation.
private static string [ ] get host and port from bracketed host ( string host port string ) { int colon index = num ; int close bracket index = num ; check argument ( host port string . char at ( num ) == str , str , host port string ) ; colon index = host port string . index of ( str ) ; close bracket index = host port string . last index of ( str ) ; check argument ( colon index > - num && close bracket index > colon index , str , host port string ) ; string host = host port string . substring ( num , close bracket index ) ; if ( close bracket index + num == host port string . length ( ) ) { return new string [ ] { host , str } ; } else { check argument ( host port string . char at ( close bracket index + num ) == str , str , host port string ) ; for ( int i = close bracket index + num ; i < host port string . length ( ) ; ++ i ) { check argument ( character . is digit ( host port string . char at ( i ) ) , str , host port string ) ; } return new string [ ] { host , host port string . substring ( close bracket index + num ) } ; } }	Parses a bracketed host-port string, throwing IllegalArgumentException if parsing fails.
static < t > general range < t > all ( comparator < ? super t > comparator ) { return new general range < t > ( comparator , bool , null , open , bool , null , open ) ; }	Returns the whole range relative to the specified comparator.
general range < t > reverse ( ) { general range < t > result = reverse ; if ( result == null ) { result = new general range < t > ( ordering . from ( comparator ) . reverse ( ) , has upper bound , get upper endpoint ( ) , get upper bound type ( ) , has lower bound , get lower endpoint ( ) , get lower bound type ( ) ) ; result . reverse = this ; return this . reverse = result ; } return result ; }	Returns the same range relative to the reversed comparator.
static < e > immutable set < e > unsafe delegate ( set < e > delegate ) { switch ( delegate . size ( ) ) { case num : return of ( ) ; case num : return new singleton immutable set < e > ( delegate . iterator ( ) . next ( ) ) ; default : return new regular immutable set < e > ( delegate ) ; } }	the elements are known to be non-null.
public static < b > immutable type to instance map < b > of ( ) { return new immutable type to instance map < b > ( immutable map . < type token < ? extends b > , b > of ( ) ) ; }	Returns an empty type to instance map.
private void about to acquire ( cycle detecting lock lock ) { if ( ! lock . is acquired by current thread ( ) ) { array list < lock graph node > acquired lock list = acquired locks . get ( ) ; lock graph node node = lock . get lock graph node ( ) ; node . check acquired locks ( policy , acquired lock list ) ; acquired lock list . add ( node ) ; } }	CycleDetectingLock implementations must call this method before attempting to acquire the lock.
@ override public immutable range set < c > sub range set ( range < c > range ) { if ( ! is empty ( ) ) { range < c > span = span ( ) ; if ( range . encloses ( span ) ) { return this ; } else if ( range . is connected ( span ) ) { return new immutable range set < c > ( intersect ranges ( range ) ) ; } } return of ( ) ; }	Returns a view of the intersection of this range set with the given range.
static < k , v > immutable map entry < k , v > make immutable ( entry < k , v > entry , k key , v value ) { boolean reusable = entry instanceof immutable map entry && ( ( immutable map entry < k , v > ) entry ) . is reusable ( ) ; return reusable ? ( immutable map entry < k , v > ) entry : new immutable map entry < k , v > ( key , value ) ; }	Makes an entry usable internally by a new ImmutableMap without rereading its contents.
static < k , v > immutable map entry < k , v > make immutable ( entry < k , v > entry ) { return make immutable ( entry , entry . get key ( ) , entry . get value ( ) ) ; }	Makes an entry usable internally by a new ImmutableMap.
private static unicode escaper wrap ( final char escaper escaper ) { return new unicode escaper ( ) { @ override protected char [ ] escape ( int cp ) {	Private helper to wrap a CharEscaper as a UnicodeEscaper.
public void add ( double x , double y ) {	Adds the given pair of values to the dataset.
public static < k , v > immutable bi map < k , v > of ( k k1 , v v1 ) { check entry not null ( k1 , v1 ) ; return new regular immutable bi map < > ( new object [ ] { k1 , v1 } , num ) ; }	Returns an immutable bimap containing a single entry.
@ beta public static < k , v > immutable bi map < k , v > copy of ( iterable < ? extends entry < ? extends k , ? extends v > > entries ) { int estimated size = ( entries instanceof collection ) ? ( ( collection < ? > ) entries ) . size ( ) : immutable collection . builder . default initial capacity ; return new builder < k , v > ( estimated size ) . put all ( entries ) . build ( ) ; }	Returns an immutable bimap containing the given entries.
@ suppress warnings ( str ) public static < e > function < e , e > identity ( ) { return ( function < e , e > ) identity function . instance ; }	implementation is "fully variant"; E has become a "pass-through" type.
public static < t > function < t , boolean > for predicate ( predicate < t > predicate ) { return new predicate function < t > ( predicate ) ; }	Creates a function that returns the same boolean output as the given predicate for all inputs. The returned function is consistent with equals (as documented at {.
@ suppress warnings ( str )	Singleton placeholder that indicates a value is being loaded.
boolean is expired ( reference entry < k , v > entry , long now ) { check not null ( entry ) ; if ( expires after access ( ) && ( now - entry . get access time ( ) >= expire after access nanos ) ) { return bool ; } if ( expires after write ( ) && ( now - entry . get write time ( ) >= expire after write nanos ) ) { return bool ; } return bool ; }	Returns true if the entry has expired.
final long reserve and get wait length ( int permits , long now micros ) { long moment available = reserve earliest available ( permits , now micros ) ; return max ( moment available - now micros , num ) ; }	Reserves next ticket and returns the wait time that the caller must wait for.
private void ensure capacity ( int min capacity ) { if ( next in bucket k v . length < min capacity ) { int old capacity = next in bucket k v . length ; int new capacity = immutable collection . builder . expanded capacity ( old capacity , min capacity ) ; keys = arrays . copy of ( keys , new capacity ) ; values = arrays . copy of ( values , new capacity ) ; next in bucket k v = expand and fill with absent ( next in bucket k v , new capacity ) ; next in bucket v k = expand and fill with absent ( next in bucket v k , new capacity ) ; prev in insertion order = expand and fill with absent ( prev in insertion order , new capacity ) ; next in insertion order = expand and fill with absent ( next in insertion order , new capacity ) ; } if ( hash table k v . length < min capacity ) { int new table size = hashing . closed table size ( min capacity , num ) ; hash table k v = create filled with absent ( new table size ) ; hash table v k = create filled with absent ( new table size ) ; for ( int entry to rehash = num ; entry to rehash < size ; entry to rehash ++ ) { int key hash = hashing . smeared hash ( keys [ entry to rehash ] ) ; int key bucket = bucket ( key hash ) ; next in bucket k v [ entry to rehash ] = hash table k v [ key bucket ] ; hash table k v [ key bucket ] = entry to rehash ; int value hash = hashing . smeared hash ( values [ entry to rehash ] ) ; int value bucket = bucket ( value hash ) ; next in bucket v k [ entry to rehash ] = hash table v k [ value bucket ] ; hash table v k [ value bucket ] = entry to rehash ; } } }	Ensures that all of the internal structures in the HashBiMap are ready for this many elements.
private void insert into table k v ( int entry , int key hash ) { check argument ( entry != absent ) ; int key bucket = bucket ( key hash ) ; next in bucket k v [ entry ] = hash table k v [ key bucket ] ; hash table k v [ key bucket ] = entry ; }	Updates the K-to-V hash table to include the entry at the specified index, which is assumed tohave not yet been added.
private void insert into table v k ( int entry , int value hash ) { check argument ( entry != absent ) ; int value bucket = bucket ( value hash ) ; next in bucket v k [ entry ] = hash table v k [ value bucket ] ; hash table v k [ value bucket ] = entry ; }	Updates the V-to-K hash table to include the entry at the specified index, which is assumed tohave not yet been added.
private void delete from table k v ( int entry , int key hash ) { check argument ( entry != absent ) ; int key bucket = bucket ( key hash ) ; if ( hash table k v [ key bucket ] == entry ) { hash table k v [ key bucket ] = next in bucket k v [ entry ] ; next in bucket k v [ entry ] = absent ; return ; } int prev in bucket = hash table k v [ key bucket ] ; for ( int entry in bucket = next in bucket k v [ prev in bucket ] ; entry in bucket != absent ; entry in bucket = next in bucket k v [ entry in bucket ] ) { if ( entry in bucket == entry ) { next in bucket k v [ prev in bucket ] = next in bucket k v [ entry ] ; next in bucket k v [ entry ] = absent ; return ; } prev in bucket = entry in bucket ; } throw new assertion error ( str + keys [ entry ] ) ; }	Updates the K-to-V hash table to remove the entry at the specified index, which is assumed tobe present.
private void delete from table v k ( int entry , int value hash ) { check argument ( entry != absent ) ; int value bucket = bucket ( value hash ) ; if ( hash table v k [ value bucket ] == entry ) { hash table v k [ value bucket ] = next in bucket v k [ entry ] ; next in bucket v k [ entry ] = absent ; return ; } int prev in bucket = hash table v k [ value bucket ] ; for ( int entry in bucket = next in bucket v k [ prev in bucket ] ; entry in bucket != absent ; entry in bucket = next in bucket v k [ entry in bucket ] ) { if ( entry in bucket == entry ) { next in bucket v k [ prev in bucket ] = next in bucket v k [ entry ] ; next in bucket v k [ entry ] = absent ; return ; } prev in bucket = entry in bucket ; } throw new assertion error ( str + values [ entry ] ) ; }	Updates the V-to-K hash table to remove the entry at the specified index, which is assumed tobe present.
private void remove entry ( int entry , int key hash , int value hash ) { check argument ( entry != absent ) ; delete from table k v ( entry , key hash ) ; delete from table v k ( entry , value hash ) ; int old predecessor = prev in insertion order [ entry ] ; int old successor = next in insertion order [ entry ] ; set succeeds ( old predecessor , old successor ) ; move entry to index ( size - num , entry ) ; keys [ size - num ] = null ; values [ size - num ] = null ; size -- ; mod count ++ ; }	Removes the entry at the specified index, given the hash of its key and value.
void remove entry key hash known ( int entry , int key hash ) { remove entry ( entry , key hash , hashing . smeared hash ( values [ entry ] ) ) ; }	Removes the entry at the specified index, given the hash of its key.
void remove entry value hash known ( int entry , int value hash ) { remove entry ( entry , hashing . smeared hash ( keys [ entry ] ) , value hash ) ; }	Removes the entry at the specified index, given the hash of its value.
public network builder < n , e > expected node count ( int expected node count ) { this . expected node count = optional . of ( check non negative ( expected node count ) ) ; return this ; }	Specifies the expected number of nodes in the network.
public network builder < n , e > expected edge count ( int expected edge count ) { this . expected edge count = optional . of ( check non negative ( expected edge count ) ) ; return this ; }	Specifies the expected number of edges in the network.
@ override public string get sql with values ( ) { if ( named parameter values . size ( ) == num ) { return super . get sql with values ( ) ; } final string builder result = new string builder ( ) ; final string statement query = get statement query ( ) ;	Generates the query for the callable statement with all parameter placeholdersreplaced with the actual parameter values.
public void set parameter value ( final string name , final object value ) { named parameter values . put ( name , new value ( value ) ) ; }	Records the value of a parameter.
public static byte [ ] object to blob ( object o ) { try { return serializer context . get instance ( ) . serialize ( o ) ; } catch ( serializer exception e ) { throw new runtime exception ( e ) ; } }	java Object to bytes.
public static < t > t blob to object ( byte [ ] blob , class < t > type ) { try { return serializer context . get instance ( ) . de serialize ( blob , type ) ; } catch ( serializer exception e ) { throw new illegal state exception ( e ) ; } }	bytes to java object.
@ bean @ conditional on class ( name = str ) public redis template < string , object > function domain redis template ( redis connection factory redis connection factory ) { jdk serialization redis serializer serialization redis serializer = new jdk serialization redis serializer ( ) ; string redis serializer string redis serializer = new string redis serializer ( ) ; redis template < string , object > redis template = new redis template < > ( ) ; redis template . set key serializer ( string redis serializer ) ; redis template . set hash key serializer ( string redis serializer ) ; redis template . set hash value serializer ( serialization redis serializer ) ; redis template . set value serializer ( serialization redis serializer ) ; redis template . set connection factory ( redis connection factory ) ; return redis template ; }	default configuration redis template when have RedisConnectionFactory.
public string app map string ( ) { if ( has group ( ) ) { string app map = optional . of nullable ( this . fields . get ( tracing constants . app map ) ) . or else ( str ) ; log . debug ( str , app map ) ; return app map ; } raise non group exception ( ) ; return str ; }	String Type App map.
public static url locate on class path ( string filename ) { url result ;	Locates a file on the classpath.
public static connection information from connection ( connection connection ) { final connection information connection information = new connection information ( ) ; connection information . connection = connection ; return connection information ; }	This method should only be used in test scenarios.
public integer map throwable ( final throwable throwable ) { throwable throwable to check = throwable ; int depth to go = num ; while ( bool ) { integer res id = map throwable flat ( throwable to check ) ; if ( res id != null ) { return res id ; } else { throwable to check = throwable to check . get cause ( ) ; depth to go -- ; if ( depth to go <= num || throwable to check == throwable || throwable to check == null ) { log . d ( str , str + throwable ) ;	Looks at the exception and its causes trying to find an ID.
public static event bus get default ( ) { event bus instance = default instance ; if ( instance == null ) { synchronized ( event bus . class ) { instance = event bus . default instance ; if ( instance == null ) { instance = event bus . default instance = new event bus ( ) ; } } } return instance ; }	Convenience singleton for apps using a process-wide EventBus instance.
private void subscribe ( object subscriber , subscriber method subscriber method ) { class < ? > event type = subscriber method . event type ; subscription new subscription = new subscription ( subscriber , subscriber method ) ; copy on write array list < subscription > subscriptions = subscriptions by event type . get ( event type ) ; if ( subscriptions == null ) { subscriptions = new copy on write array list < > ( ) ; subscriptions by event type . put ( event type , subscriptions ) ; } else { if ( subscriptions . contains ( new subscription ) ) { throw new event bus exception ( str + subscriber . get class ( ) + str + event type ) ; } } int size = subscriptions . size ( ) ; for ( int i = num ; i <= size ; i ++ ) { if ( i == size || subscriber method . priority > subscriptions . get ( i ) . subscriber method . priority ) { subscriptions . add ( i , new subscription ) ; break ; } } list < class < ? > > subscribed events = types by subscriber . get ( subscriber ) ; if ( subscribed events == null ) { subscribed events = new array list < > ( ) ; types by subscriber . put ( subscriber , subscribed events ) ; } subscribed events . add ( event type ) ; if ( subscriber method . sticky ) { if ( event inheritance ) {	Must be called in synchronized block.
private void unsubscribe by event type ( object subscriber , class < ? > event type ) { list < subscription > subscriptions = subscriptions by event type . get ( event type ) ; if ( subscriptions != null ) { int size = subscriptions . size ( ) ; for ( int i = num ; i < size ; i ++ ) { subscription subscription = subscriptions . get ( i ) ; if ( subscription . subscriber == subscriber ) { subscription . active = bool ; subscriptions . remove ( i ) ; i -- ; size -- ; } } } }	Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber.
public synchronized void unregister ( object subscriber ) { list < class < ? > > subscribed types = types by subscriber . get ( subscriber ) ; if ( subscribed types != null ) { for ( class < ? > event type : subscribed types ) { unsubscribe by event type ( subscriber , event type ) ; } types by subscriber . remove ( subscriber ) ; } else { logger . log ( level . warning , str + subscriber . get class ( ) ) ; } }	Unregisters the given subscriber from all event classes.
public void post ( object event ) { posting thread state posting state = current posting thread state . get ( ) ; list < object > event queue = posting state . event queue ; event queue . add ( event ) ; if ( ! posting state . is posting ) { posting state . is main thread = is main thread ( ) ; posting state . is posting = bool ; if ( posting state . canceled ) { throw new event bus exception ( str ) ; } try { while ( ! event queue . is empty ( ) ) { post single event ( event queue . remove ( num ) , posting state ) ; } } finally { posting state . is posting = bool ; posting state . is main thread = bool ; } } }	Posts the given event to the event bus.
public < t > t get sticky event ( class < t > event type ) { synchronized ( sticky events ) { return event type . cast ( sticky events . get ( event type ) ) ; } }	Gets the most recent sticky event for the given type.
public < t > t remove sticky event ( class < t > event type ) { synchronized ( sticky events ) { return event type . cast ( sticky events . remove ( event type ) ) ; } }	Remove and gets the recent sticky event for the given event type.
public boolean remove sticky event ( object event ) { synchronized ( sticky events ) { class < ? > event type = event . get class ( ) ; object existing event = sticky events . get ( event type ) ; if ( event . equals ( existing event ) ) { sticky events . remove ( event type ) ; return bool ; } else { return bool ; } } }	Removes the sticky event if it equals to the given event.
private static list < class < ? > > lookup all event types ( class < ? > event class ) { synchronized ( event types cache ) { list < class < ? > > event types = event types cache . get ( event class ) ; if ( event types == null ) { event types = new array list < > ( ) ; class < ? > clazz = event class ; while ( clazz != null ) { event types . add ( clazz ) ; add interfaces ( event types , clazz . get interfaces ( ) ) ; clazz = clazz . get superclass ( ) ; } event types cache . put ( event class , event types ) ; } return event types ; } }	Looks up all Class objects including super classes and interfaces.
static void add interfaces ( list < class < ? > > event types , class < ? > [ ] interfaces ) { for ( class < ? > interface class : interfaces ) { if ( ! event types . contains ( interface class ) ) { event types . add ( interface class ) ; add interfaces ( event types , interface class . get interfaces ( ) ) ; } } }	Recurses through super interfaces.
public event bus builder add index ( subscriber info index index ) { if ( subscriber info indexes == null ) { subscriber info indexes = new array list < > ( ) ; } subscriber info indexes . add ( index ) ; return this ; }	Adds an index generated by EventBus' annotation preprocessor.
public static void attach to ( activity activity , boolean finish after dialog , bundle arguments for error dialog ) { object execution scope = activity . get class ( ) ; attach to ( activity , execution scope , finish after dialog , arguments for error dialog ) ; }	Scope is limited to the activity's class.
protected t prepare error fragment ( throwable failure event event , boolean finish after dialog , bundle arguments for error dialog ) { if ( event . is suppress error ui ( ) ) {	Prepares the fragment's arguments and creates the fragment.
protected string get title for ( throwable failure event event , bundle arguments ) { return config . resources . get string ( config . default title id ) ; }	May be overridden to provide custom error title.
protected string get message for ( throwable failure event event , bundle arguments ) { int msg res id = config . get message id for throwable ( event . throwable ) ; return config . resources . get string ( msg res id ) ; }	May be overridden to provide custom error messages.
static < t , f > boolean post complete drain ( long n , subscriber < ? super t > actual , queue < t > queue , atomic long field updater < f > field , f instance , boolean supplier is cancelled ) {	Drains the queue either in a pre- or post-complete state.
@ nullable final t blocking get ( long timeout , time unit unit ) { if ( schedulers . is in non blocking thread ( ) ) { throw new illegal state exception ( str + thread . current thread ( ) . get name ( ) ) ; } if ( get count ( ) != num ) { try { if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw new illegal state exception ( str + timeout + str + unit ) ; } } catch ( interrupted exception ex ) { dispose ( ) ; runtime exception re = exceptions . propagate ( ex ) ;	Block until the first value arrives and return it, otherwisereturn null for an empty source and rethrow any exception.
public final mono < t > element at ( int index , t default value ) { return mono . on assembly ( new mono element at < > ( this , index , default value ) ) ; }	Emit only the element at the given index position or fall back to adefault value if the sequence is shorter. .
public final flux < t > on error resume ( function < ? super throwable , ? extends publisher < ? extends t > > fallback ) { return on assembly ( new flux on error resume < > ( this , fallback ) ) ; }	Subscribe to a returned fallback publisher when any error occurs, using a function tochoose the fallback depending on the error. .
public final flux < t > repeat ( long num repeat , boolean supplier predicate ) { if ( num repeat < num ) { throw new illegal argument exception ( str ) ; } if ( num repeat == num ) { return this ; } return defer ( ( ) -> repeat ( counting boolean supplier ( predicate , num repeat ) ) ) ; }	Repeatedly subscribe to the source if the predicate returns true after completion of the previoussubscription.
static < t > mono < t > convert to mono ( callable < t > supplier ) { if ( supplier instanceof fuseable . scalar callable ) { fuseable . scalar callable < t > scalar callable = ( fuseable . scalar callable < t > ) supplier ; t v ; try { v = scalar callable . call ( ) ; } catch ( exception e ) { return mono . error ( e ) ; } if ( v == null ) { return mono . empty ( ) ; } return mono . just ( v ) ; } return mono . on assembly ( new mono callable < > ( supplier ) ) ; }	Returns the appropriate Mono instance for a known Supplier Flux.
static long get and sub ( ring buffer . sequence sequence , long to sub ) { long r , u ; do { r = sequence . get as long ( ) ; if ( r == num || r == long . max value ) { return r ; } u = operators . sub or zero ( r , to sub ) ; } while ( ! sequence . compare and set ( r , u ) ) ; return r ; }	Concurrent subtraction bound to 0 and Long.MAX_VALUE.
@ suppress warnings ( str ) @ nullable public static < t > queue subscription < t > as ( subscription s ) { if ( s instanceof queue subscription ) { return ( queue subscription < t > ) s ; } return null ; }	Returns the subscription as QueueSubscription if possible or null.
public static void error ( subscriber < ? > s , throwable e ) { s . on subscribe ( empty subscription . instance ) ; s . on error ( e ) ; }	Calls onSubscribe on the target Subscriber with the empty instance followed by a call to onError with thesupplied error.
public static < t > long produced ( atomic long field updater < t > updater , t instance , long to sub ) { long r , u ; do { r = updater . get ( instance ) ; if ( r == num || r == long . max value ) { return r ; } u = sub or zero ( r , to sub ) ; } while ( ! updater . compare and set ( instance , r , u ) ) ; return u ; }	Concurrent subtraction bound to 0, mostly used to decrement a request tracker bythe amount produced by the operator.
public static < t > subscription scalar subscription ( core subscriber < ? super t > subscriber , t value ) { return new scalar subscription < > ( subscriber , value ) ; }	Represents a fuseable Subscription that emits a single constant value synchronouslyto a Subscriber or consumer.
< u > mono ignore then < u > shift ( mono < u > new last ) { objects . require non null ( new last , str ) ; publisher < ? > [ ] a = ignore ; int n = a . length ; publisher < ? > [ ] b = new publisher [ n + num ] ; system . arraycopy ( a , num , b , num , n ) ; b [ n ] = last ; return new mono ignore then < > ( b , new last ) ; }	Shifts the current last Mono into the ignore array and sets up a new last Mono instance.
public static wait strategy phased off sleep ( long spin timeout , long yield timeout , time unit units ) { return phased off ( spin timeout , yield timeout , units , parking ( num ) ) ; }	Block by parking in a loop.
public final mono < void > and ( publisher < ? > other ) { if ( this instanceof mono when ) { @ suppress warnings ( str ) mono when o = ( mono when ) this ; mono < void > result = o . when additional source ( other ) ; if ( result != null ) { return result ; } } return when ( this , other ) ; }	Join the termination signals from this mono and another source into the returnedvoid mono .
public final mono < t > default if empty ( t default v ) { if ( this instanceof fuseable . scalar callable ) { try { t v = block ( ) ; if ( v == null ) { return mono . just ( default v ) ; } } catch ( throwable e ) {	Provide a default single value if this mono is completed without any data .
public final mono < t > or ( mono < ? extends t > other ) { if ( this instanceof mono first ) { mono first < t > a = ( mono first < t > ) this ; mono < t > result = a . or additional source ( other ) ; if ( result != null ) { return result ; } } return first ( this , other ) ; }	Emit the first available result from this mono or the other mono. .
public final mono < t > on error resume ( function < ? super throwable , ? extends mono < ? extends t > > fallback ) { return on assembly ( new mono on error resume < > ( this , fallback ) ) ; }	Subscribe to a fallback publisher when any error occurs, using a function tochoose the fallback depending on the error. .
static final map < string , function < ? super publisher < object > , ? extends publisher < object > > > get on each operator hooks ( ) { return collections . unmodifiable map ( on each operator hooks ) ; }	Immutable views on hook trackers, for testing purpose.
@ suppress warnings ( str ) mono delay until < t > copy with new trigger generator ( boolean delay error , function < ? super t , ? extends publisher < ? > > trigger generator ) { objects . require non null ( trigger generator , str ) ; function < ? super t , ? extends publisher < ? > > [ ] old triggers = this . other generators ; function < ? super t , ? extends publisher < ? > > [ ] new triggers = new function [ old triggers . length + num ] ; system . arraycopy ( old triggers , num , new triggers , num , old triggers . length ) ; new triggers [ old triggers . length ] = trigger generator ; return new mono delay until < > ( this . source , new triggers ) ; }	Add a trigger generator to wait for.
static < q , s > void drain max loop ( queue < q > q , subscriber < ? super s > a , boolean delay error , disposable dispose , queue drain subscriber < ? , q , s > qd ) { int missed = num ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; q v = q . poll ( ) ; boolean empty = v == null ; if ( check terminated ( d , empty , a , delay error , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != num ) { if ( qd . accept ( a , v ) ) { if ( r != long . max value ) { qd . produced ( num ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . on error ( exceptions . fail with overflow ( str ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == num ) { break ; } } }	Drain the queue but give up with an error if there aren't enough requests.
public final < u > u as ( function < ? super parallel flux < t > , u > converter ) { return converter . apply ( this ) ; }	Perform a fluent transformation to a value via a converter function which receivesthis ParallelFlux.
public final < c > parallel flux < c > collect ( supplier < ? extends c > collection supplier , bi consumer < ? super c , ? super t > collector ) { return on assembly ( new parallel collect < > ( this , collection supplier , collector ) ) ; }	Collect the elements in each rail into a collection supplied via acollectionSupplier and collected into with a collector action, emitting thecollection at the end.
public final < r > parallel flux < r > concat map ( function < ? super t , ? extends publisher < ? extends r > > mapper ) { return concat map ( mapper , num , error mode . immediate ) ; }	Generates and concatenates Publishers on each 'rail', signalling errors immediatelyand generating 2 publishers upfront.
public final parallel flux < t > do on cancel ( runnable on cancel ) { objects . require non null ( on cancel , str ) ; return do on signal ( this , null , null , null , null , null , null , null , on cancel ) ; }	Run the specified runnable when a 'rail' receives a cancellation.
public final parallel flux < t > do on complete ( runnable on complete ) { objects . require non null ( on complete , str ) ; return do on signal ( this , null , null , null , on complete , null , null , null , null ) ; }	Run the specified runnable when a 'rail' completes.
public final parallel flux < t > do on error ( consumer < ? super throwable > on error ) { objects . require non null ( on error , str ) ; return do on signal ( this , null , null , on error , null , null , null , null , null ) ; }	Call the specified consumer with the exception passing through any 'rail'.
public final parallel flux < t > do on request ( long consumer on request ) { objects . require non null ( on request , str ) ; return do on signal ( this , null , null , null , null , null , null , on request , null ) ; }	Call the specified consumer with the request amount if any rail receives arequest.
public final < r > parallel flux < r > flat map ( function < ? super t , ? extends publisher < ? extends r > > mapper , boolean delay error , int max concurrency , int prefetch ) { return on assembly ( new parallel flat map < > ( this , mapper , delay error , max concurrency , queues . get ( max concurrency ) , prefetch , queues . get ( prefetch ) ) ) ; }	Generates and flattens Publishers on each 'rail', optionally delaying errors,having a total number of simultaneous subscriptions to the inner Publishers andusing the given prefetch amount for the inner Publishers.
public final flux < t > sequential ( int prefetch ) { return flux . on assembly ( new parallel merge sequential < > ( this , prefetch , queues . get ( prefetch ) ) ) ; }	Merges the values from each 'rail' in a round-robin or same-order fashion andexposes it as a regular Publisher sequence, running with a give prefetch value forthe rails.
protected final boolean validate ( subscriber < ? > [ ] subscribers ) { int p = parallelism ( ) ; if ( subscribers . length != p ) { illegal argument exception iae = new illegal argument exception ( str + str + p + str + subscribers . length ) ; for ( subscriber < ? > s : subscribers ) { operators . error ( s , iae ) ; } return bool ; } return bool ; }	Validates the number of subscribers and returns true if their number matches theparallelism level of this ParallelFlux.
final < r > parallel flux < r > concat map ( function < ? super t , ? extends publisher < ? extends r > > mapper , int prefetch , error mode error mode ) { return on assembly ( new parallel concat map < > ( this , mapper , queues . get ( prefetch ) , prefetch , error mode ) ) ; }	Generates and concatenates Publishers on each 'rail', optionally delaying errorsand using the given prefetch amount for generating Publishers upfront.
final < r > parallel flux < r > concat map delay error ( function < ? super t , ? extends publisher < ? extends r > > mapper , boolean delay until end , int prefetch ) { return concat map ( mapper , prefetch , delay until end ? error mode . end : error mode . boundary ) ; }	Generates and concatenates Publishers on each 'rail', delaying errorsand using the given prefetch amount for generating Publishers upfront.
@ nullable public static < t > throwable terminate ( atomic reference field updater < t , throwable > field , t instance ) { throwable current = field . get ( instance ) ; if ( current != terminated ) { current = field . get and set ( instance , terminated ) ; } return current ; }	Atomic utility to safely mark a volatile throwable reference with a terminalmarker.
void log ( signal type signal type , object signal value ) { string line = fuseable ? log template fuseable : log template ; if ( operator line != null ) { line = line + str + operator line ; } if ( level == level . finest ) { log . trace ( line , signal type , signal value ) ; } else if ( level == level . fine ) { log . debug ( line , signal type , signal value ) ; } else if ( level == level . info ) { log . info ( line , signal type , signal value ) ; } else if ( level == level . warning ) { log . warn ( line , signal type , signal value ) ; } else if ( level == level . severe ) { log . error ( line , signal type , signal value ) ; } }	Structured logging with level adaptation and operator ascii graph if required.
public boolean start ( final file download listener listener , final boolean is serial ) { if ( listener == null ) { file download log . w ( this , str + str , is serial ) ; return bool ; } return is serial ? get queues handler ( ) . start queue serial ( listener ) : get queues handler ( ) . start queue parallel ( listener ) ; }	Start the download queue by the same listener.
public void pause all ( ) { file download task launcher . get impl ( ) . expire all ( ) ; final base download task . i [ ] download list = file download list . get impl ( ) . copy ( ) ; for ( base download task . i task : download list ) { task . get origin ( ) . pause ( ) ; }	Pause all tasks running in FileDownloader.
public long get so far ( final int download id ) { base download task . i task = file download list . get impl ( ) . get ( download id ) ; if ( task == null ) { return file download service proxy . get impl ( ) . get sofar ( download id ) ; } return task . get origin ( ) . get large file so far bytes ( ) ; }	Get downloaded bytes so far by the downloadId.
public boolean un bind service if idle ( ) {	Unbind and stop the downloader service when there is no task running in the FileDownloader.
public boolean set max network thread count ( final int count ) { if ( ! file download list . get impl ( ) . is empty ( ) ) { file download log . w ( this , str + str + str + str ) ; return bool ; } return file download service proxy . get impl ( ) . set max network thread count ( count ) ; }	Set the maximum count of the network thread, what is the number of simultaneous downloads inFileDownloader.
public void pause all ( ) { list < integer > list = m thread pool . get all exact running download ids ( ) ; if ( file download log . need log ) { file download log . d ( this , str , list . size ( ) ) ; } for ( integer id : list ) { pause ( id ) ; } }	Pause all running task.
public void start ( ) { for ( base download task task : tasks ) { task . set listener ( target ) ; if ( auto retry times != null ) { task . set auto retry times ( auto retry times ) ; } if ( sync callback != null ) { task . set sync callback ( sync callback ) ; } if ( is force re download != null ) { task . set force re download ( is force re download ) ; } if ( callback progress times != null ) { task . set callback progress times ( callback progress times ) ; } if ( callback progress min interval millis != null ) { task . set callback progress min interval ( callback progress min interval millis ) ; } if ( tag != null ) { task . set tag ( tag ) ; } if ( task finish listener list != null ) { for ( base download task . finish listener finish listener : task finish listener list ) { task . add finish listener ( finish listener ) ; } } if ( this . directory != null ) { task . set path ( this . directory , bool ) ; } if ( this . is wifi required != null ) { task . set wifi required ( this . is wifi required ) ; } task . as in queue task ( ) . enqueue ( ) ; } file downloader . get impl ( ) . start ( target , is serial ) ; }	Start tasks in a queue.
void divert and ignore duplicate ( @ suppress warnings ( str ) final list < base download task . i > destination ) { synchronized ( m list ) { for ( base download task . i i running task : m list ) { if ( ! destination . contains ( i running task ) ) { destination . add ( i running task ) ; } } m list . clear ( ) ; } }	Divert all data in list 2 destination list.
void add unchecked ( final base download task . i task ) { if ( task . is marked added2 list ( ) ) { return ; } synchronized ( m list ) { if ( m list . contains ( task ) ) { file download log . w ( this , str , task ) ; } else { task . mark added2 list ( ) ; m list . add ( task ) ; if ( file download log . need log ) { file download log . v ( this , str , task , task . get origin ( ) . get status ( ) , m list . size ( ) ) ; } } } }	This method generally used for enqueuing the task which will be assembled by a queue.
public void pause ( ) { synchronized ( finish callback ) { if ( paused ) { file download log . w ( this , str + str , m tasks . size ( ) ) ; return ; } paused = bool ; m tasks . drain to ( paused list ) ; if ( working task != null ) { working task . remove finish listener ( finish callback ) ; working task . pause ( ) ; } } }	Pause the queue.
public void resume ( ) { synchronized ( finish callback ) { if ( ! paused ) { file download log . w ( this , str + str , m tasks . size ( ) ) ; return ; } paused = bool ; m tasks . add all ( paused list ) ; paused list . clear ( ) ; if ( working task == null ) { send next ( ) ; } else { working task . add finish listener ( finish callback ) ; working task . start ( ) ; } } }	Resume the queue if the queue is paused.
public static boolean is accept range ( int response code , file download connection connection ) { if ( response code == url . http partial || response code == file download connection . response code from offset ) return bool ; final string accept ranges = connection . get response header field ( str ) ; return str . equals ( accept ranges ) ; }	accept range is effect by response code and Accept-Ranges header field.
public static long find instance length for trial ( file download connection connection ) { long length = find instance length from content range ( connection ) ; if ( length < num ) { length = total value in chunked resource ; file download log . w ( file download utils . class , str + str ) ; }	content-length.
public void set animated ( boolean animated ) { m is animated = animated ; m open animator set . set duration ( animated ? animation duration : num ) ; m close animator set . set duration ( animated ? animation duration : num ) ; }	Sets whether open and close actions should be animated.
@ target api ( build . version codes . lollipop ) public void set elevation compat ( float elevation ) { m shadow color = num ; m shadow radius = math . round ( elevation / num ) ; m shadow x = num ; m shadow y = math . round ( m fab size == size normal ? elevation : elevation / num ) ; if ( util . has lollipop ( ) ) { super . set elevation ( elevation ) ; m using elevation compat = bool ; m show shadow = bool ; update background ( ) ; view group . layout params layout params = get layout params ( ) ; if ( layout params != null ) { set layout params ( layout params ) ; } } else { m show shadow = bool ; update background ( ) ; } }	Sets the shadow color and radius to mimic the native elevation.
public void set label colors ( int color normal , int color pressed , int color ripple ) { label label = get label view ( ) ; int left = label . get padding left ( ) ; int top = label . get padding top ( ) ; int right = label . get padding right ( ) ; int bottom = label . get padding bottom ( ) ; label . set colors ( color normal , color pressed , color ripple ) ; label . update background ( ) ; label . set padding ( left , top , right , bottom ) ; }	Set the label's background colors.
@ override public void add configuration properties ( properties properties ) { suppress date = is true ( properties . get property ( property registry . comment generator suppress date ) ) ; suppress all comments = is true ( properties . get property ( property registry . comment generator suppress all comments ) ) ; }	Adds properties for this instance from any properties configured in theCommentGenerator configuration.This method will be called before any of the other methods.
@ override public string get fully qualified name ( ) { string fully qualified name = super . get fully qualified name ( ) ; string before = fully qualified name . substring ( num , fully qualified name . last index of ( str ) ) ; string end = fully qualified name . substring ( fully qualified name . last index of ( str ) ) ; return before + str + outer type + end ; }	This method returns the fully qualified name - including any generic type parameters.
public static element get select key ( introspected column introspected column , generated key generated key ) { return get select key ( introspected column , generated key , null ) ; }	This method should return an XmlElement for the select key used toautomatically generate keys.
public package resource table new framework resource table ( resource path resource path ) { return perf stats collector . get instance ( ) . measure ( str , ( ) -> { package resource table resource table = new package resource table ( str ) ; if ( resource path . get r ( ) != null ) { add r ( resource table , resource path . get r ( ) ) ; add missing styleable attributes ( resource table , resource path . get r ( ) ) ; } if ( resource path . get internal r ( ) != null ) { add r ( resource table , resource path . get internal r ( ) ) ; add missing styleable attributes ( resource table , resource path . get internal r ( ) ) ; } parse resource files ( resource path , resource table ) ; return resource table ; } ) ; }	Builds an Android framework resource table in the "android" package space.
public package resource table new resource table ( string package name , resource path ... resource paths ) { return perf stats collector . get instance ( ) . measure ( str , ( ) -> { package resource table resource table = new package resource table ( package name ) ; for ( resource path resource path : resource paths ) { if ( resource path . get r ( ) != null ) { add r ( resource table , resource path . get r ( ) ) ; } } for ( resource path resource path : resource paths ) { parse resource files ( resource path , resource table ) ; } return resource table ; } ) ; }	Creates an application resource table which can be constructed with multiple resources pathsrepresenting overlayed resource libraries.
private void add missing styleable attributes ( package resource table resource table , class < ? > r class ) { for ( class inner class : r class . get classes ( ) ) { if ( inner class . get simple name ( ) . equals ( str ) ) { string styleable name = null ;	Check the stylable elements.
public static void set wifi on ( boolean is on ) { settings . global . put int ( runtime environment . application . get content resolver ( ) , settings . global . wifi on , is on ? num : num ) ; settings . system . put int ( runtime environment . application . get content resolver ( ) , settings . system . wifi on , is on ? num : num ) ; }	Non-Android accessor that allows the value of the WIFI_ON setting to be set.
@ deprecated public static string add smallest screen width ( string qualifiers , int smallest screen width ) { int qualifiers smallest screen width = qualifiers . get smallest screen width ( qualifiers ) ; if ( qualifiers smallest screen width == - num ) { if ( qualifiers . length ( ) > num ) { qualifiers += str ; } qualifiers += str + smallest screen width + str ; } return qualifiers ; }	If the Config already has a `sw` qualifier, do nothing.
protected void instrument native method ( mutable class mutable class , method node method ) { method . access = method . access & ~ opcodes . acc native ; robolectric generator adapter generator = new robolectric generator adapter ( method ) ; type return type = generator . get return type ( ) ; generator . push default return value to stack ( return type ) ; generator . return value ( ) ; }	Creates native stub which returns the default return value.
private void rewrite method body ( mutable class mutable class , method node calling method ) { list iterator < abstract insn node > instructions = calling method . instructions . iterator ( ) ; while ( instructions . has next ( ) ) { abstract insn node node = instructions . next ( ) ; switch ( node . get opcode ( ) ) { case opcodes . new : type insn node new insn node = ( type insn node ) node ; new insn node . desc = mutable class . config . mapped type name ( new insn node . desc ) ; break ; case opcodes . getfield : case opcodes . putfield : case opcodes . getstatic : case opcodes . putstatic : field insn node field insn node = ( field insn node ) node ; field insn node . desc = mutable class . config . mapped type name ( field insn node . desc ) ;	Filters methods that might need special treatment because of various reasons.
private boolean is gregorian calendar boolean constructor ( method insn node target method ) { return target method . owner . equals ( str ) && target method . name . equals ( str ) && target method . desc . equals ( str ) ; }	Verifies if the .
private void make class public ( class node clazz ) { clazz . access = ( clazz . access | opcodes . acc public ) & ~ ( opcodes . acc protected | opcodes . acc private ) ; }	Replaces protected and private class modifiers with public.
protected void make method public ( method node method ) { method . access = ( method . access | opcodes . acc public ) & ~ ( opcodes . acc protected | opcodes . acc private ) ; }	Replaces protected and private method modifiers with public.
protected void make method private ( method node method ) { method . access = ( method . access | opcodes . acc private ) & ~ ( opcodes . acc public | opcodes . acc protected ) ; }	Replaces protected and public class modifiers with private.
public void set traversal after ( accessibility node info info ) { if ( this . traversal after != null ) { this . traversal after . recycle ( ) ; } this . traversal after = obtain ( info ) ; }	Sets the view whose node is visited after this one in accessibility traversal.This may be useful for configuring traversal order in tests before the correspondingviews have been inflated.
public void set traversal before ( accessibility node info info ) { if ( this . traversal before != null ) { this . traversal before . recycle ( ) ; } this . traversal before = obtain ( info ) ; }	Sets the view before whose node this one should be visited during traversal.This may be useful for configuring traversal order in tests before the correspondingviews have been inflated.
public void add child ( accessibility node info child ) { if ( children == null ) { children = new array list < > ( ) ; } children . add ( child ) ; shadow accessibility node info shadow accessibility node info = shadow . extract ( child ) ; shadow accessibility node info . parent = real accessibility node info ; }	Add a child node to this one.
public void push default return value to stack ( type type ) { if ( type . equals ( type . boolean type ) ) { push ( bool ) ; } else if ( type . equals ( type . int type ) || type . equals ( type . short type ) || type . equals ( type . byte type ) || type . equals ( type . char type ) ) { push ( num ) ; } else if ( type . equals ( type . long type ) ) { push ( num ) ; } else if ( type . equals ( type . float type ) ) { push ( num ) ; } else if ( type . equals ( type . double type ) ) { push ( num ) ; } else if ( type . get sort ( ) == array || type . get sort ( ) == object ) { load null ( ) ; } }	Forces a return of a default value, depending on the method's return type.
public static int get mode ( string path ) { if ( path == null ) { return num ; } file file = new file ( path ) ; if ( file . is directory ( ) ) { return s ifdir value ; } if ( file . is file ( ) ) { return s ifreg value ; } if ( ! canonicalize ( path ) . equals ( path ) ) { return s iflnk value ; } return num ; }	Returns the st_mode for the path.
public activity controller < t > setup ( bundle saved instance state ) { return create ( saved instance state ) . start ( ) . restore instance state ( saved instance state ) . post create ( saved instance state ) . resume ( ) . visible ( ) ; }	Calls the same lifecycle methods on the Activity called by Android when an Activity is restored from previously saved state.
public activity controller < t > configuration change ( final configuration new configuration ) { final configuration current config = component . get resources ( ) . get configuration ( ) ; final int changed bits = current config . diff ( new configuration ) ; current config . set to ( new configuration ) ;	Performs a configuration change on the Activity.If the activity is configured to handle changes without being recreated,{.
@ suppress warnings ( str ) public activity controller < t > recreate ( ) { stage original stage = activity lifecycle monitor registry . get instance ( ) . get lifecycle stage of ( component ) ; switch ( original stage ) { case pre on create : create ( ) ;	Recreates activity instance which is controlled by this ActivityController.NonConfigurationInstances and savedInstanceStateBundle are properly passed into a new instance.After the recreation, it brings back its lifecycle state to the original state.
public void set call state ( int call state , string incoming phone number ) { if ( call state != call state ringing ) { incoming phone number = null ; } this . call state = call state ; this . incoming phone number = incoming phone number ; for ( phone state listener listener : get listeners for flags ( listen call state ) ) { listener . on call state changed ( call state , incoming phone number ) ; } }	Sets the current call state with the option to specify an incoming phone number for theCALL_STATE_RINGING state.
public void expect log message ( int level , string tag , string message ) { check tag ( tag ) ; expected logs . add ( new log item ( level , tag , message , null ) ) ; }	Adds an expected log statement.
public boolean is exported ( ) { boolean default value = ! intent filters . is empty ( ) ; return ( attributes . contains key ( exported ) ? boolean . parse boolean ( attributes . get ( exported ) ) : default value ) ; }	Returns whether this service is exported by checking the XML attribute.
private static void get shape end point ( int type , float [ ] coords , float [ ] point ) {	Returns the end point of a given segment.
private void get point at length ( int type , float [ ] coords , float last x , float last y , float t , float [ ] point ) { if ( type == path iterator . seg lineto ) { point [ num ] = last x + ( coords [ num ] - last x ) * t ; point [ num ] = last y + ( coords [ num ] - last y ) * t ;	Returns the estimated position along a path of the given length.
static config create config ( byte buffer buffer ) { int start position = buffer . position ( ) ;	packed version of "tl".
public final boolean is default ( ) { return mcc == num && mnc == num && is zeroes ( language ) && is zeroes ( country ) && orientation == num && touchscreen == num && density == num && keyboard == num && navigation == num && input flags == num && screen width == num && screen height == num && sdk version == num && minor version == num && screen layout == num && ui mode == num && smallest screen width dp == num && screen width dp == num && screen height dp == num && is zeroes ( locale script ) && is zeroes ( locale variant ) && screen layout2 == num && color mode == num ; }	Returns true if this is the default "any" configuration.
@ implementation ( min sdk = jelly bean m ) protected bundle get application restrictions ( string package name ) { bundle bundle = application restrictions . get ( package name ) ; return bundle != null ? bundle : new bundle ( ) ; }	Compared to real Android, there is no check that the package name matches the applicationpackage name and the method returns instantly.
public long add user profile ( user handle user handle ) { long serial number = next user serial ++ ; user profiles . put ( user handle , serial number ) ; return serial number ; }	Adds a profile associated for the user that the calling process is running on.The user is assigned an arbitrary unique serial number.
public user handle add user ( int id , string name , int flags ) { user handle user handle = id == user handle . user system ? process . my user handle ( ) : new user handle ( id ) ; add user profile ( user handle ) ; set serial number for user ( user handle , ( long ) id ) ; user info map . put ( id , new user info ( id , name , flags ) ) ; user pid map . put ( id , id == user handle . user system ? process . my uid ( ) : id * user handle . per user range + shadow process . get random application uid ( ) ) ; return user handle ; }	Creates a user with the specified name, userId and flags.
@ implementation protected void connect ( ) throws io { if ( state == socket state . closed ) { throw new io ( str ) ; } state = socket state . connected ; }	This method doesn't perform an actual connection and returns immediately.
private void intercept invoke virtual method with invoke dynamic ( list iterator < abstract insn node > instructions , method insn node target method ) { instructions . remove ( ) ;	Intercepts the method using the invokedynamic bytecode instruction available in Java 7+.Should be called through interceptInvokeVirtualMethod, not directly.
int add mappings ( final dynamic ref table other ) { if ( m assigned package id != other . m assigned package id ) { return unknown error ; }	Adds mappings from the other DynamicRefTable.
int add mapping ( final string package name , byte package id ) { byte index = m entries . get ( package name ) ; if ( index == null ) { return unknown error ; } m lookup table [ index ] = package id ; return no error ; }	the given package.
public void grant permissions ( int pid , int uid , string ... permissions ) { get shadow instrumentation ( ) . grant permissions ( pid , uid , permissions ) ; }	Grant the given permissions for the given process and user.
public void deny permissions ( int pid , int uid , string ... permissions ) { get shadow instrumentation ( ) . deny permissions ( pid , uid , permissions ) ; }	Revoke the given permissions for the given process and user.
@ override @ nonnull public list < sdk > select sdks ( configuration configuration , uses sdk uses sdk ) { config config = configuration . get ( config . class ) ; set < sdk > sdks = new tree set < > ( configured sdks ( config , uses sdk ) ) ; if ( enabled sdks != null ) { sdks = sets . intersection ( sdks , enabled sdks ) ; } return lists . new array list ( sdks ) ; }	Enumerate the SDKs to be used for this test.
private static path get file from zip ( path path ) { byte [ ] buffer = new byte [ num ] ; try { path output dir = new temp directory ( str ) . create ( str ) ; try ( input stream zis = fs . get input stream ( path ) ) { path file from zip = output dir . resolve ( path . get file name ( ) . to string ( ) ) ; try ( output stream fos = files . new output stream ( file from zip ) ) { int len ; while ( ( len = zis . read ( buffer ) ) > num ) { fos . write ( buffer , num , len ) ; } } return file from zip ; } } catch ( io e ) { throw new runtime exception ( e ) ; } }	Extract an asset from a zipped up assets provided by the build system, this is required becausethere is no way to get a FileDescriptor from a zip entry.
public static http request get next sent http request ( ) { http request info http request info = get fake http layer ( ) . get next sent http request info ( ) ; return http request info == null ? null : http request info . get http request ( ) ; }	Accessor to obtain HTTP requests made during the current test in the order in which they were made.
public static void add http response rule ( string method , string uri , http response response ) { get fake http layer ( ) . add http response rule ( method , uri , response ) ; }	Adds an HTTP response rule.
public static void add http response rule ( request matcher request matcher , list < ? extends http response > responses ) { get fake http layer ( ) . add http response rule ( request matcher , responses ) ; }	Adds an HTTP response rule.
@ implementation protected static void native stop ( long native object ) { try {	Closes the FileOutputStream for the associated muxer.
public void add http response rule ( request matcher request matcher , list < ? extends http response > responses ) { add http response rule ( new request matcher response rule ( request matcher , responses ) ) ; }	Add a response rule.
public void add bluetooth route ( ) { update bluetooth audio route ( bluetooth device name ) ; if ( runtime environment . get api level ( ) <= jelly bean m ) { reflection helpers . call instance method ( media router . class , real object , str , class parameter . from ( int . class , media router . route type live audio ) , class parameter . from ( route info . class , get bluetooth a2dp route ( ) ) ) ; } else { real object . select route ( media router . route type live audio , get bluetooth a2dp route ( ) ) ; } }	Adds the Bluetooth A2DP route and ensures it's the selected route, simulating connecting aBluetooth device.
@ implementation protected static final void set thread priority ( int tid , int priority ) { check argument ( priority >= android . os . process . thread priority urgent audio && priority <= android . os . process . thread priority lowest , str , priority ) ; if ( tid == num ) { tid = shadow process . my tid ( ) ; } synchronized ( thread priorities lock ) { thread priorities . put ( tid , priority ) ; } }	Stores priority for the given thread, but doesn't actually change it to not mess up with testrunner.
@ implementation protected static final int get thread priority ( int tid ) { if ( tid == num ) { tid = shadow process . my tid ( ) ; } synchronized ( thread priorities lock ) { return thread priorities . get or default ( tid , num ) ; } }	Returns priority stored for the given thread.
int get index of bit ( int n ) {	Gets the index of the specified bit in the set, which is the number of marked bits that appearbefore the specified bit.
public static int get color ( string value ) { if ( value != null ) { if ( value . starts with ( str ) == bool ) { throw new number format exception ( string . format ( str , value ) ) ; } value = value . substring ( num ) ;	Returns the color value represented by the given string value.
public static int get color type ( string value ) { if ( value != null && value . starts with ( str ) ) { switch ( value . length ( ) ) { case num : return typed value . type int color rg ; case num : return typed value . type int color arg ; case num : return typed value . type int color rg ; case num : return typed value . type int color arg ; } } return typed value . type int color arg ; }	Returns the TypedValue color type represented by the given string value.
public static boolean parse float attribute ( string attribute , string value , typed value out value , boolean require unit ) { assert require unit == bool || attribute != null ;	Parse a float attribute and return the parsed value into a given TypedValue.
@ implementation protected static image decoder n create ( long asset , source source ) throws io { return n create asset ( asset , source ) ; }	native method implementations...
@ implementation protected static image decoder n create ( file descriptor fd , source src ) throws io { return n create fd ( fd , src ) ; }	The fd must be seekable.
public boolean click menu item ( int menu item res id ) { final robo menu item item = new robo menu item ( menu item res id ) ; return real activity . on menu item selected ( window . feature options panel , item ) ; }	Perform a click on a menu item.
public void call on activity result ( int request code , int result code , intent result data ) { final activity invoker invoker = new activity invoker ( ) ; invoker . call ( str , integer . type , integer . type , intent . class ) . with ( request code , result code , result data ) ; }	For internal use only.
@ implementation ( min sdk = lollipop ) protected void start lock task ( ) { shadow . < shadow activity manager > extract ( get activity manager ( ) ) . set lock task mode state ( activity manager . lock task mode locked ) ; }	Starts a lock task. The status of the lock task can be verified using {.
@ implementation ( min sdk = lollipop ) protected void stop lock task ( ) { shadow . < shadow activity manager > extract ( get activity manager ( ) ) . set lock task mode state ( activity manager . lock task mode none ) ; }	Stops a lock task. The status of the lock task can be verified using {.
public synchronized void post delayed ( runnable runnable , long delay , time unit unit ) { long delay millis = unit . to millis ( delay ) ; if ( ( idle state != constant idle && ( is paused ( ) || delay millis > num ) ) || thread . current thread ( ) != associated thread ) { runnables . add ( new scheduled runnable ( runnable , current time + delay millis ) ) ; } else { run or queue runnable ( runnable , current time + delay millis ) ; } }	Add a runnable to the queue to be run after a delay.
public synchronized void post at front of queue ( runnable runnable ) { if ( is paused ( ) || thread . current thread ( ) != associated thread ) { final long time disambiguator ; if ( runnables . is empty ( ) ) { time disambiguator = next time disambiguator ++ ; } else { time disambiguator = runnables . peek ( ) . time disambiguator - num ; } runnables . add ( new scheduled runnable ( runnable , num , time disambiguator ) ) ; } else { run or queue runnable ( runnable , current time ) ; } }	Add a runnable to the head of the queue.
public synchronized void remove ( runnable runnable ) { iterator < scheduled runnable > iterator = runnables . iterator ( ) ; while ( iterator . has next ( ) ) { if ( iterator . next ( ) . runnable == runnable ) { iterator . remove ( ) ; } } }	Remove a runnable from the queue.
public synchronized boolean advance to last posted runnable ( ) { long current max time = current time ; for ( scheduled runnable scheduled : runnables ) { if ( current max time < scheduled . scheduled time ) { current max time = scheduled . scheduled time ; } } return advance to ( current max time ) ; }	Run all runnables in the queue, and any additional runnables they schedule that are scheduledbefore the latest scheduled runnable currently in the queue.
public synchronized boolean advance by ( long amount , time unit unit ) { long ending time = current time + unit . to millis ( amount ) ; return advance to ( ending time ) ; }	Run all runnables that are scheduled to run in the next time interval.
public synchronized boolean advance to ( long end time ) { if ( end time < current time || runnables . is empty ( ) ) { current time = end time ; return bool ; } int run count = num ; while ( next task is scheduled before ( end time ) ) { run one task ( ) ; ++ run count ; } current time = end time ; return run count > num ; }	Run all runnables that are scheduled before the endTime.
public synchronized boolean run one task ( ) { scheduled runnable posted runnable = runnables . poll ( ) ; if ( posted runnable != null ) { if ( posted runnable . scheduled time > current time ) { current time = posted runnable . scheduled time ; } posted runnable . run ( ) ; return bool ; } return bool ; }	Run the next runnable in the queue.
@ implementation ( min sdk = lollipop ) protected boolean bind service as user ( intent intent , final service connection service connection , int i , user handle user handle ) { return get shadow instrumentation ( ) . bind service ( intent , service connection , i ) ; }	Binds to a service but ignores the given UserHandle.
@ implementation protected static boolean set current time millis ( long millis ) { if ( current time millis > millis ) { return bool ; } current time millis = millis ; for ( listener listener : listeners ) { listener . clock updated ( current time millis ) ; } return bool ; }	Sets the current wall time.
@ implementation ( min sdk = num ) public boolean is idle ( ) { if ( build . version . sdk int >= m ) { return directly on ( real queue , message queue . class ) . is idle ( ) ; } else { reflector message queue internal queue = reflector ( reflector message queue . class , real queue ) ;	Exposes the API23+_isIdle method to older platforms.
@ override public void reset ( ) { reflector message queue msg queue = reflector ( reflector message queue . class , real queue ) ; msg queue . set messages ( null ) ; msg queue . set idle handlers ( new array list < > ( ) ) ; msg queue . set next barrier token ( num ) ; }	so it should be package private.
public static < t extends activity > activity controller < t > build activity ( class < t > activity class ) { return build activity ( activity class , null ) ; }	Creates a ActivityController for the given activity class. Consider using {.
public static < t extends activity > activity controller < t > build activity ( class < t > activity class , intent intent ) { return activity controller . of ( reflection helpers . call constructor ( activity class ) , intent ) ; }	Creates a ActivityController for the given activity class with the intent.
@ deprecated public static < t extends activity > t setup activity ( class < t > activity class ) { return build activity ( activity class ) . setup ( ) . get ( ) ; }	Simulates starting activity with the given class type and returns its reference. Use {.
@ deprecated public static < t extends fragment > fragment controller < t > build fragment ( class < t > fragment class ) { return fragment controller . of ( reflection helpers . call constructor ( fragment class ) ) ; }	Creates a FragmentController for the given fragment class.
@ implementation protected int speak ( final string text , final int queue mode , final hash map < string , string > params ) { if ( runtime environment . get api level ( ) >= lollipop ) { return shadow . directly on ( tts , text to speech . class ) . speak ( text , queue mode , params ) ; } return speak ( text , queue mode , null , params == null ? null : params . get ( engine . key param utterance id ) ) ; }	Speaks the string using the specified queuing strategy and speech parameters.
@ implementation ( min sdk = o m ) public point get stable display size ( ) throws remote exception { display info default display info = m dm . get display info ( display . default display ) ; return new point ( default display info . get natural width ( ) , default display info . get natural height ( ) ) ; }	Returns the 'natural' dimensions of the default display.
private static file system get jar fs ( path jar file ) throws io { path key = jar file . to absolute path ( ) ; synchronized ( zip filesystems ) { fs wrapper fs = zip filesystems . get ( key ) ; if ( fs == null ) { fs = new fs wrapper ( file systems . new file system ( key , null ) , key ) ; fs . incr ref count ( ) ; zip filesystems . put ( key , fs ) ; } else { fs . incr ref count ( ) ; } return fs ; } }	Returns a reference-counted Jar FileSystem, possibly one that was previously returned.
public static list < log item > get logs for tag ( string tag ) { queue < log item > logs = logs by tag . get ( tag ) ; return logs == null ? collections . empty list ( ) : new array list < > ( logs ) ; }	Returns ordered list of all log items for a specific tag.
public list < android manifest > get all manifests ( ) { set < android manifest > seen manifests = new hash set < > ( ) ; list < android manifest > unique manifests = new array list < > ( ) ; add transitive manifests ( seen manifests , unique manifests ) ; return unique manifests ; }	Returns all transitively reachable manifests, including this one, in order and withoutduplicates.
public @ nullable broadcast receiver data get broadcast receiver ( string class name ) { parse android manifest ( ) ; for ( broadcast receiver data receiver : receivers ) { if ( receiver . get name ( ) . equals ( class name ) ) { return receiver ; } } return null ; }	Returns data for the broadcast receiver with the provided name from this manifest.
@ implementation ( min sdk = build . version codes . o ) protected void delete notification channel group ( string channel group id ) { if ( get notification channel group ( channel group id ) != null ) {	Delete a notification channel group and all notification channels associated with the group.This method will not notify any NotificationListenerService of resulting changes tonotification channel groups nor to notification channels.
private static int get java version ( ) { string version = system . get property ( str ) ; assert version != null ; if ( version . starts with ( str ) ) { version = version . substring ( num ) ; }	Returns the Java version as an int value.
@ implementation protected final void transform ( matrix matrix ) { check not null ( matrix ) ; native input . motion event event = get native motion event ( ) ; shadow matrix shadow matrix = shadow . extract ( matrix ) ; float [ ] m = new float [ num ] ; shadow matrix . get values ( m ) ; event . transform ( m ) ; }	shadow this directly as opposed to nativeTransform because need access to ShadowMatrix.
@ implementation @ nullable @ suppress warnings ( str ) protected < t > t get ( key < t > key ) { return ( t ) results key to value . get ( key ) ; }	Obtain a property of the CaptureResult.
@ implementation @ hidden api protected final int load resource bag value ( int ident , int bag entry id , typed value out value , boolean resolve ) { cpp asset manager am = asset manager for java object ( ) ; if ( am == null ) { return num ; } final res table res = am . get resources ( ) ; return load resource bag value internal ( ident , bag entry id , out value , resolve , res ) ; }	Returns true if the resource was found, filling in mRetStringBlock andmRetData.
@ override @ deprecated public boolean post ( runnable runnable , long delay millis ) { if ( ! quit ) { get scheduler ( ) . post delayed ( runnable , delay millis , time unit . milliseconds ) ; return bool ; } else { return bool ; } }	Enqueue a task to be run later.
@ override @ deprecated public boolean post at front of queue ( runnable runnable ) { if ( ! quit ) { get scheduler ( ) . post at front of queue ( runnable ) ; return bool ; } else { return bool ; } }	Enqueue a task to be run ahead of all other delayed tasks.
public activity info add activity if not present ( component name component name ) { return add component ( activity filters , p -> p . activities , ( p , a ) -> p . activities = a , update name ( component name , new activity info ( ) ) , bool ) ; }	Makes sure that given activity exists.If the activity doesn't exist yet, it will be created with {.
public service info add service if not present ( component name component name ) { return add component ( service filters , p -> p . services , ( p , a ) -> p . services = a , update name ( component name , new service info ( ) ) , bool ) ; }	Makes sure that given service exists.If the service doesn't exist yet, it will be created with {.
public activity info add receiver if not present ( component name component name ) { return add component ( receiver filters , p -> p . receivers , ( p , a ) -> p . receivers = a , update name ( component name , new activity info ( ) ) , bool ) ; }	Makes sure that given receiver exists.If the receiver doesn't exist yet, it will be created with {.
public provider info add provider if not present ( component name component name ) { return add component ( provider filters , p -> p . providers , ( p , a ) -> p . providers = a , update name ( component name , new provider info ( ) ) , bool ) ; }	Makes sure that given provider exists.If the provider doesn't exist yet, it will be created with {.
public void add or update activity ( activity info activity info ) { add component ( activity filters , p -> p . activities , ( p , a ) -> p . activities = a , new activity info ( activity info ) , bool ) ; }	Adds or updates given activity in the system.If activity with the same {.
public void add or update service ( service info service info ) { add component ( service filters , p -> p . services , ( p , a ) -> p . services = a , new service info ( service info ) , bool ) ; }	Adds or updates given service in the system.If service with the same {.
public void add or update receiver ( activity info receiver info ) { add component ( receiver filters , p -> p . receivers , ( p , a ) -> p . receivers = a , new activity info ( receiver info ) , bool ) ; }	Adds or updates given broadcast receiver in the system.If broadcast receiver with the same {.
public void add or update provider ( provider info provider info ) { add component ( provider filters , p -> p . providers , ( p , a ) -> p . providers = a , new provider info ( provider info ) , bool ) ; }	Adds or updates given content provider in the system.If content provider with the same {.
@ nullable public activity info remove activity ( component name component name ) { return remove component ( component name , activity filters , p -> p . activities , ( p , a ) -> p . activities = a ) ; }	Removes activity from the package manager.
@ nullable public service info remove service ( component name component name ) { return remove component ( component name , service filters , p -> p . services , ( p , a ) -> p . services = a ) ; }	Removes service from the package manager.
@ nullable public provider info remove provider ( component name component name ) { return remove component ( component name , provider filters , p -> p . providers , ( p , a ) -> p . providers = a ) ; }	Removes content provider from the package manager.
@ nullable public activity info remove receiver ( component name component name ) { return remove component ( component name , receiver filters , p -> p . receivers , ( p , a ) -> p . receivers = a ) ; }	Removes broadcast receiver from the package manager.
@ deprecated public void set resolve infos for intent ( intent intent , list < resolve info > info ) { resolve info for intent . remove ( intent ) ; for ( resolve info resolve info : info ) { add resolve info for intent ( intent , resolve info ) ; } }	Sets extra resolve infos for an intent.Those entries are added to whatever might be in the manifest already.Note that all resolve infos will have {.
@ deprecated public void add resolve info for intent ( intent intent , resolve info info ) { info . is default = bool ; component info [ ] component infos = new component info [ ] { info . activity info , info . service info , build . version . sdk int >= kitkat ? info . provider info : null } ; for ( component info component : component infos ) { if ( component != null && component . application info != null ) { component . application info . flags |= application info . flag installed ; if ( component . application info . process name == null ) { component . application info . process name = component . application info . package name ; } } } if ( info . match == num ) { info . match = integer . max value ;	Adds extra resolve info for an intent.Note that this resolve info will have {.
public void add package internal ( package app package ) { int flags = get activities | get receivers | get services | get providers | get instrumentation | get intent filters | get signatures | get resolved filter | get meta data | get gids | match disabled components | get shared library files | get uri permission patterns | get permissions | match uninstalled packages | get configurations | match disabled until used components | match direct boot unaware | match direct boot aware ; for ( permission group permission group : app package . permission groups ) { permission group info permission group info = package parser . generate permission group info ( permission group , flags ) ; add permission group info ( permission group info ) ; } package info package info = reflector ( package parser . class ) . generate package info ( app package , new int [ ] { num } , flags , num , num ) ; package info . application info . uid = process . my uid ( ) ; package info . application info . data dir = create temp dir ( package info . package name + str ) ; install package ( package info ) ; add filters ( activity filters , app package . activities ) ; add filters ( service filters , app package . services ) ; add filters ( provider filters , app package . providers ) ; add filters ( receiver filters , app package . receivers ) ; }	Internal use only.
public void add intent filter for activity ( component name component name , intent filter filter ) throws name not found exception { add intent filter for component ( component name , filter , activity filters ) ; }	Add intent filter for given activity.
public void add intent filter for service ( component name component name , intent filter filter ) throws name not found exception { add intent filter for component ( component name , filter , service filters ) ; }	Add intent filter for given service.
public void add intent filter for receiver ( component name component name , intent filter filter ) throws name not found exception { add intent filter for component ( component name , filter , receiver filters ) ; }	Add intent filter for given receiver.
public void add intent filter for provider ( component name component name , intent filter filter ) throws name not found exception { add intent filter for component ( component name , filter , provider filters ) ; }	Add intent filter for given provider.
private static int find parent ( int packed locale , final string script ) { if ( has region ( packed locale ) ) { for ( map . entry < string , map < integer , integer > > entry : script parents . entry set ( ) ) { if ( script . equals ( entry . get key ( ) ) ) { map < integer , integer > map = entry . get value ( ) ; integer lookup result = map . get ( packed locale ) ; if ( lookup result != null ) { return lookup result ; } break ; } } return drop region ( packed locale ) ; } return packed root ; }	to represent the root locale.
static int find ancestors ( int [ ] out , ref < long > stop list index , int packed locale , final string script , final int [ ] stop list , int stop set length ) { int ancestor = packed locale ; int count = num ; do { if ( out != null ) { out [ count ] = ancestor ; } count ++ ; for ( int i = num ; i < stop set length ; i ++ ) { if ( stop list [ i ] == ancestor ) { stop list index . set ( ( long ) i ) ; return count ; } } ancestor = find parent ( ancestor , script ) ; } while ( ancestor != packed root ) ; stop list index . set ( ( long ) - num ) ; return count ; }	any results in 'out'.).
public static package call parse package ( path apk file ) { package parser package parser = new package parser ( ) ; int flags = package parser . parse ignore processes ; try { package the package ; if ( runtime environment . get api level ( ) >= build . version codes . lollipop ) {	Parses an AndroidManifest.xml file using the framework PackageParser.
@ override public intent get intent for activity ( class < ? extends activity > activity class ) { package manager package manager = get target context ( ) . get package manager ( ) ; component name component name = new component name ( get target context ( ) , activity class ) ; intent intent = intent . make main activity ( component name ) ; if ( package manager . resolve activity ( intent , num ) != null ) { return intent ; } return intent . make main activity ( new component name ( get context ( ) , activity class ) ) ; }	This implementation makes sure, that the activity you are trying to launch exists.
static boolean verify res table type ( type header ) { if ( header . id == num ) { log error ( str ) ; return bool ; } int entry count = dtohl ( header . entry count ) ;	the ResChunk_header is safe.
private static list < manifest identifier > find libraries ( path res directory ) throws io { list < manifest identifier > library base dirs = new array list < > ( ) ; if ( res directory != null ) { path base dir = res directory . get parent ( ) ; final properties properties = get properties ( base dir . resolve ( str ) ) ; properties override properties = get properties ( base dir . resolve ( str ) ) ; properties . put all ( override properties ) ; int lib ref = num ; string lib ; while ( ( lib = properties . get property ( str + lib ref ) ) != null ) { path library dir = base dir . resolve ( lib ) ; if ( files . is directory ( library dir ) ) {	Find valid library AndroidManifest files referenced from an already loaded AndroidManifest's`project.properties` file, recursively.
@ implementation ( min sdk = n ) @ nullable protected char sequence get organization name ( component name admin ) { if ( build . version . sdk int >= build . version codes . o ) { enforce device owner or profile owner ( admin ) ; } else { enforce profile owner ( admin ) ; } return organization name ; }	Returns organization name. The API can only be called by profile owner since Android N. Android framework has a hidden API for getting the organization name for device owner sinceAndroid O. This method, however, is extended to return the organization name for device ownerstoo to make testing of {.
@ implementation ( min sdk = lollipop ) protected boolean set permitted accessibility services ( component name admin , list < string > package names ) { enforce device owner or profile owner ( admin ) ; permitted accessibility services = package names ; return bool ; }	Sets permitted accessibility services.
@ implementation ( min sdk = lollipop ) protected boolean set permitted input methods ( component name admin , list < string > package names ) { enforce device owner or profile owner ( admin ) ; permitted input methods = package names ; return bool ; }	Sets permitted input methods.
public boolean activate reset token ( component name admin ) { if ( ! password reset tokens . contains key ( admin ) ) { throw new illegal argument exception ( str + admin ) ; } return components with activated tokens . add ( admin ) ; }	Activates reset token for given admin.
public set < config > get resource configurations ( boolean exclude system , boolean exclude mipmap ) {	boolean exclude_mipmap = false);.
public set < string > get resource locales ( boolean exclude system , boolean merge equivalent languages ) { atrace call ( ) ; set < string > locales = new hash set < > ( ) ; for ( final package group package group : package groups ) { for ( final configured package package : package group . packages ) { if ( exclude system && package . loaded package . is system ( ) ) { continue ; } package . loaded package . collect locales ( merge equivalent languages , locales ) ; } } return locales ; }	boolean merge_equivalent_languages = false);.
public asset open non asset ( final string filename , asset . access mode mode , ref < apk assets cookie > out cookie ) { atrace call ( ) ; for ( int i = apk assets . size ( ) - num ; i >= num ; i -- ) { asset asset = apk assets . get ( i ) . open ( filename , mode ) ; if ( is truthy ( asset ) ) { if ( out cookie != null ) { out cookie . set ( apk assets cookie . for int ( i ) ) ; } return asset ; } } if ( out cookie != null ) { out cookie . set ( k invalid cookie ) ; } return null ; }	is inconsistent for split APKs.
public void add available restore sets ( long restore token , list < string > packages ) { service state . restore data . put ( restore token , packages ) ; }	Adds a restore set available to be restored.
private void execute on looper ( control runnable runnable ) { if ( thread . current thread ( ) == real looper . get thread ( ) ) { runnable . run ( ) ; } else { if ( real looper . equals ( looper . get main looper ( ) ) ) { throw new unsupported operation exception ( str ) ; } looper executor . execute ( runnable ) ; runnable . wait till complete ( ) ; } }	Executes the given runnable on the loopers thread, and waits for it to complete.
@ implementation ( max sdk = jelly bean m ) @ suppress warnings ( str ) protected < t extends parcelable > t read parcelable ( class loader loader ) {	this needs to start above 0, which is a magic number to Parcel.
@ implementation ( min sdk = m ) protected void write blob ( byte [ ] b , int offset , int len ) { if ( b == null ) { real object . write int ( - num ) ; return ; } throws if out of bounds ( b . length , offset , len ) ; long native ptr = reflection helpers . get field ( real object , str ) ; native write blob ( native ptr , b , offset , len ) ; }	non-existent-in-JDK java.util.Arrays.checkOffsetAndCount method.
@ implementation ( min sdk = lollipop ) protected static void native write blob ( long native ptr , byte [ ] b , int offset , int len ) { native write byte array ( native ptr , b , offset , len ) ; }	nativeWriteBlob was introduced in lollipop, thus no need for a int nativePtr variant.
public byte [ ] to byte array ( ) { int old data position = data position ; try { byte array output stream bos = new byte array output stream ( ) ; object output stream oos = new object output stream ( bos ) ;	Converts a ByteBuffer to a raw byte array.
public void set data position ( int pos ) { if ( pos > data size ) {	Sets the current data position.
private void check consistent read and increment position ( class < ? > clazz , fake encoded item item ) { int end position = data position + item . size bytes ; for ( int i = data position ; i < end position ; i ++ ) { fake encoded item found item item = i < data size ? data [ i ] : null ; if ( found item item != item ) { throw new unreliable behavior error ( clazz , data position , item , string . format ( locale . us , str , found item item == null ? str : found item item . value , i ) ) ; } } data position = math . min ( data size , data position + item . size bytes ) ; }	Ensures that the next sizeBytes are all the initial value we read. This detects: Reading an item, but not starting at its start position Reading items that were truncated by setSize Reading items that were partially overwritten by another.
private object peek ( ) { return data position < data size && data [ data position ] != null ? data [ data position ] . value : null ; }	Returns the item at the current position, or null if uninitialized or null.
private < t > fake encoded item read next item ( class < t > clazz ) { fake encoded item item = data [ data position ] ; if ( item == null ) {	Reads a complete item in the byte buffer.
private < t > t read value ( t past end value , class < t > clazz , boolean allow null ) { if ( data position >= data size ) {	Reads the next value in the byte buffer of a specified type.
private boolean read zeroes ( int bytes ) { int end position = data position + bytes ; if ( end position > data size ) { return bool ; } for ( int i = data position ; i < end position ; i ++ ) { if ( data [ i ] == null || ! data [ i ] . is encoded as all zero bytes ) { return bool ; } }	Determines if there is a sequence of castable zeroes, and consumes them.
private < t > t read primitive ( int default size bytes , t default value , class < t > clazz ) {	Reads a primitive, which may reinterpret zeros of other types.
private void write item ( fake encoded item item ) { int end position = data position + item . size bytes ; if ( end position > data . length ) {	Writes an encoded item directly, bypassing alignment, and possibly repeating an item.
public static byte [ ] read bytes ( input stream is ) throws io { try ( byte array output stream bos = new byte array output stream ( is . available ( ) ) ) { copy ( is , bos ) ; return bos . to byte array ( ) ; } }	This method consumes an input stream and returns its content.
@ deprecated public synchronized long get native object id ( t o ) { check not null ( o ) ; long native id = native obj to id map . inverse ( ) . get ( o ) ; if ( native id == null ) { native id = next id ; if ( debug ) { system . out . printf ( str , name , native id , o ) ; } native obj to id map . put ( native id , o ) ; next id ++ ; } return native id ; }	Retrieve the native id for given object.
public synchronized t get native object ( long native id ) { t object = native obj to id map . get ( native id ) ; if ( object != null ) { return object ; } else { throw new null pointer exception ( string . format ( str , native id , native obj to id map . key set ( ) ) ) ; } }	Retrieve the native object for given id. Throws if object with that id cannot be found.
public void call attach ( context context ) { reflection helpers . call instance method ( application . class , real application , str , reflection helpers . class parameter . from ( context . class , context ) ) ; }	Attaches an application to a base context.
public void set default network active ( boolean is active ) { default network active = is active ; if ( default network active ) { for ( connectivity manager . on network active listener l : on network active listeners ) { if ( l != null ) { l . on network active ( ) ; } } } }	Sets the active state of the default network.By default this is true and affects the result of {.
@ implementation protected int load ( string path , int priority ) { int sound id = sound ids . get and increment ( ) ; id to paths . put ( sound id , path ) ; return sound id ; }	FileDescriptor which would make it difficult to check if a given sound has been placed.
public void reconstruct widget view as if phone was rotated ( int app widget id ) { widget info widget info = widget infos . get ( app widget id ) ; widget info . view = create widget view ( widget info . layout id ) ; widget info . last remote views . reapply ( context , widget info . view ) ; }	Triggers a reapplication of the most recent set of actions against the widget, which is what happens when thephone is rotated.
public int [ ] create widgets ( class < ? extends app widget provider > app widget provider class , int widget layout id , int how many to create ) { app widget provider app widget provider = reflection helpers . call constructor ( app widget provider class ) ; int [ ] new widget ids = new int [ how many to create ] ; for ( int i = num ; i < how many to create ; i ++ ) { view widget view = create widget view ( widget layout id ) ; int my widget id = next widget id ++ ; widget infos . put ( my widget id , new widget info ( widget view , widget layout id , app widget provider ) ) ; new widget ids [ i ] = my widget id ; } app widget provider . on update ( context , real app widget manager , new widget ids ) ; return new widget ids ; }	Creates a bunch of widgets by inflating the same layout multiple times.
public void invoke seek complete listener ( ) { int duration = get media info ( ) . duration ; set current position ( pending seek > duration ? duration : pending seek < num ? num : pending seek ) ; pending seek = - num ; if ( state == started ) { do start ( ) ; } if ( seek complete listener == null ) { return ; } seek complete listener . on seek complete ( player ) ; }	Allows test cases to simulate seek completion by invoking callback.
public void invoke info listener ( int what , int extra ) { if ( info listener != null ) { info listener . on info ( player , what , extra ) ; } }	Allows test cases to directly simulate invocation of the OnInfo event.
public void invoke error listener ( int what , int extra ) {	Allows test cases to directly simulate invocation of the OnError event.
public static display get default display ( ) { window manager window manager = ( window manager ) runtime environment . application . get system service ( context . window service ) ; return window manager . get default display ( ) ; }	Returns the default display.
public void set density dpi ( int density dpi ) { if ( is jb ( ) ) { this . density dpi = density dpi ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . logical density dpi = density dpi ) ; } }	Changes the density for this display.Any registered {.
public void set xdpi ( float xdpi ) { if ( is jb ( ) ) { this . xdpi = xdpi ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . physical x = xdpi ) ; } }	Changes the horizontal DPI for this display.Any registered {.
public void set ydpi ( float ydpi ) { if ( is jb ( ) ) { this . ydpi = ydpi ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . physical y = ydpi ) ; } }	Changes the vertical DPI for this display.Any registered {.
public void set name ( string name ) { if ( is jb ( ) ) { this . name = name ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . name = name ) ; } }	Changes the name for this display.Any registered {.
public void set flags ( int flags ) { reflector ( display . class , real object ) . set flags ( flags ) ; if ( ! is jb ( ) ) { shadow display manager . change display ( real object . get display id ( ) , di -> di . flags = flags ) ; } }	Changes the flags for this display.Any registered {.
public void set width ( int width ) { if ( is jb ( ) ) { this . width = width ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . app width = width ) ; } }	Changes the width available to the application for this display.Any registered {.
public void set height ( int height ) { if ( is jb ( ) ) { this . height = height ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . app height = height ) ; } }	Changes the height available to the application for this display.Any registered {.
public void set real width ( int width ) { if ( is jb ( ) ) { this . real width = width ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . logical width = width ) ; } }	Changes the simulated physical width for this display.Any registered {.
public void set real height ( int height ) { if ( is jb ( ) ) { this . real height = height ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . logical height = height ) ; } }	Changes the simulated physical height for this display.Any registered {.
public void set rotation ( int rotation ) { if ( is jb ( ) ) { this . rotation = rotation ; } else { shadow display manager . change display ( real object . get display id ( ) , di -> di . rotation = rotation ) ; } }	Changes the rotation for this display.Any registered {.
public void set state ( int state ) { if ( ! is jb ( ) ) { shadow display manager . change display ( real object . get display id ( ) , di -> di . state = state ) ; } }	Changes the simulated state for this display, such as whether it is on or offAny registered {.
protected void release connection ( ) {	Returns the connection back to the connection managerand prepares for retrieving a new connection duringthe next request.
protected void establish route ( http route route , http context context ) throws http exception , io { http route director rowdy = new basic route director ( ) ; int step ; do { http route fact = managed conn . get route ( ) ; step = rowdy . next step ( route , fact ) ; switch ( step ) { case http route director . connect target : case http route director . connect proxy : managed conn . open ( route , context , this . params ) ; break ; case http route director . tunnel target : { boolean secure = create tunnel to target ( route , context ) ; this . log . debug ( str ) ; managed conn . tunnel target ( secure , this . params ) ; } break ; case http route director . tunnel proxy : {	Establishes the target route.
public string qualify ( string value ) { if ( value == null ) return null ; if ( attribute resource . is resource reference ( value ) ) { return str + res name . qualify resource name ( value . trim ( ) . substring ( num ) . replace ( str , str ) , package name , str ) ; } else if ( attribute resource . is style reference ( value ) ) { return str + res name . qualify resource name ( value . trim ( ) . substring ( num ) , package name , str ) ; } else { return string resources . process string resources ( value ) ; } }	for testing only...
int navigate to next node ( node node ) throws xml pull parser exception { node next node = node . get next sibling ( ) ; if ( next node != null ) {	Navigate to the next node after a node and all of hischildren have been explored.If the node has unexplored siblings navigate to thenext sibling.
private static boolean is android supported feature ( string name ) { if ( name == null ) { return bool ; } for ( string feature : available features ) { if ( feature . equals ( name ) ) { return bool ; } } return bool ; }	Tell is a given feature is supported by android.
int add ( asset asset , asset idmap asset , final int cookie , boolean copy data , boolean app as lib , boolean is system asset ) { final byte [ ] data = asset . get buffer ( bool ) ; if ( data == null ) { alogw ( str ) ; return unknown error ; } int idmap size = num ; object idmap data = null ; if ( idmap asset != null ) { idmap data = idmap asset . get buffer ( bool ) ; if ( idmap data == null ) { alogw ( str ) ; return unknown error ; } idmap size = ( int ) idmap asset . get length ( ) ; } return add internal ( data , ( int ) asset . get length ( ) , idmap data , idmap size , app as lib , cookie , copy data , is system asset ) ; }	bool appAsLib=false, bool isSystemAsset=false);.
public static string get qualifiers ( configuration configuration , display metrics display metrics ) { return configuration v25 . resource qualifier string ( configuration , display metrics ) ; }	Returns a qualifier string describing the given configuration and display metrics.
public static void set qualifiers ( string new qualifiers ) { configuration configuration ; display metrics display metrics = new display metrics ( ) ; if ( new qualifiers . starts with ( str ) ) { configuration = new configuration ( resources . get system ( ) . get configuration ( ) ) ; display metrics . set to ( resources . get system ( ) . get display metrics ( ) ) ; } else { configuration = new configuration ( ) ; } bootstrap . apply qualifiers ( new qualifiers , get api level ( ) , configuration , display metrics ) ; resources system resources = resources . get system ( ) ; system resources . update configuration ( configuration , display metrics ) ; if ( application != null ) { application . get resources ( ) . update configuration ( configuration , display metrics ) ; } }	Overrides the current device configuration.If `newQualifiers` starts with a plus (`+`), the prior configuration is used as the baseconfiguration, with the given changes applied additively.
public static string build string ( char [ ] data ) { int count = num ; for ( count = num ; count < data . length ; count ++ ) { if ( data [ count ] == num ) { break ; } } return new string ( data , num , count ) ; }	Builds a string from a null-terminated char data.
public static < s > service finder < s > load ( class < s > service , class loader loader ) { return new service finder < > ( service , loader ) ; }	Creates a new service loader for the given service type and classloader.
public static < s > s load from system property ( final class < s > service ) { try { final string class name = system . get property ( service . get name ( ) ) ; if ( class name != null ) { class < ? > c = class loader . get system class loader ( ) . load class ( class name ) ; return ( s ) c . new instance ( ) ; } return null ; } catch ( exception e ) { throw new error ( e ) ; } }	Internal API to support built-in SPIs that check a system property first.Returns an instance specified by a property with the class' binary name, or null ifno such property is set.
public boolean has permission for package ( usb device device , string package name ) { list < usb device > usb devices = granted permissions . get ( package name ) ; return usb devices != null && usb devices . contains ( device ) ; }	Returns true if the given package has permission to access the device.
public void revoke permission ( usb device device , string package name ) { list < usb device > usb devices = granted permissions . get ( package name ) ; if ( usb devices != null ) { usb devices . remove ( device ) ; } }	Revokes permission to a USB device granted to a package.
public void add or update usb device ( usb device usb device , boolean has permission ) { preconditions . check not null ( usb device ) ; preconditions . check not null ( usb device . get device name ( ) ) ; usb devices . put ( usb device . get device name ( ) , usb device ) ; if ( has permission ) { grant permission ( usb device ) ; } else { revoke permission ( usb device , runtime environment . application . get package name ( ) ) ; } }	Adds a USB device into available USB devices map with permission value.
public void remove usb device ( usb device usb device ) { preconditions . check not null ( usb device ) ; usb devices . remove ( usb device . get device name ( ) ) ; revoke permission ( usb device , runtime environment . application . get package name ( ) ) ; }	Removes a USB device from available USB devices map.
public void add port ( string port id ) { if ( runtime environment . get api level ( ) >= build . version codes . q ) { usb ports . put ( ( usb port ) create usb port ( real usb manager , port id , usb port status . mode dual ) , ( usb port status ) create usb port status ( usb port status . mode dual , usb port status . power role sink , usb port status . data role device , num ) ) ; return ; } usb ports . put ( call constructor ( usb port . class , from ( string . class , port id ) , from ( int . class , get static field ( usb port . class , str ) ) ) , ( usb port status ) create usb port status ( get static field ( usb port . class , str ) , get static field ( usb port . class , str ) , get static field ( usb port . class , str ) , num ) ) ; }	Adds a USB port to UsbManager.
@ implementation protected parcel file descriptor open accessory ( usb accessory accessory ) { try { file tmp usb dir = runtime environment . get temp directory ( ) . create if not exists ( str ) . to file ( ) ; return parcel file descriptor . open ( new file ( tmp usb dir , str ) , parcel file descriptor . mode read write ) ; } catch ( file not found exception error ) { throw new runtime exception ( str , error ) ; } }	Opens a file descriptor from a temporary file.
public media item create media item ( string parent id , string media id , string title , int flag ) { final media metadata compat metadata compat = new media metadata compat . builder ( ) . put string ( media metadata compat . metadata key media id , media id ) . put string ( media metadata compat . metadata key title , title ) . put string ( media metadata compat . metadata key media uri , uri . parse ( media id ) . to string ( ) ) . build ( ) ; final media item media item = new media item ( metadata compat . get description ( ) , flag ) ; media items . put ( media id , media item ) ;	Creates a MediaItem and returns it.
@ suppress warnings ( str ) public static < r > r get field ( final object object , final string field name ) { try { return traverse class hierarchy ( object . get class ( ) , no such field exception . class , new inside traversal < r > ( ) { @ override public r run ( class < ? > traversal class ) throws exception { field field = traversal class . get declared field ( field name ) ; field . set accessible ( bool ) ; return ( r ) field . get ( object ) ; } } ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Reflectively get the value of a field.
public static < r > r call instance method ( final object instance , final string method name , class parameter < ? > ... class parameters ) { try { final class < ? > [ ] classes = class parameter . get classes ( class parameters ) ; final object [ ] values = class parameter . get values ( class parameters ) ; return traverse class hierarchy ( instance . get class ( ) , no such method exception . class , new inside traversal < r > ( ) { @ override @ suppress warnings ( str ) public r run ( class < ? > traversal class ) throws exception { method declared method = traversal class . get declared method ( method name , classes ) ; declared method . set accessible ( bool ) ; return ( r ) declared method . invoke ( instance , values ) ; } } ) ; } catch ( invocation target exception e ) { if ( e . get target exception ( ) instanceof runtime exception ) { throw ( runtime exception ) e . get target exception ( ) ; } if ( e . get target exception ( ) instanceof error ) { throw ( error ) e . get target exception ( ) ; } throw new runtime exception ( e . get target exception ( ) ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Reflectively call an instance method on an object.
public static < r > r call instance method ( class < ? > cl , final object instance , final string method name , class parameter < ? > ... class parameters ) { try { final class < ? > [ ] classes = class parameter . get classes ( class parameters ) ; final object [ ] values = class parameter . get values ( class parameters ) ; method method = cl . get declared method ( method name , classes ) ; method . set accessible ( bool ) ; if ( modifier . is static ( method . get modifiers ( ) ) ) { throw new illegal argument exception ( method + str ) ; } return ( r ) method . invoke ( instance , values ) ; } catch ( invocation target exception e ) { if ( e . get target exception ( ) instanceof runtime exception ) { throw ( runtime exception ) e . get target exception ( ) ; } if ( e . get target exception ( ) instanceof error ) { throw ( error ) e . get target exception ( ) ; } throw new runtime exception ( e . get target exception ( ) ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Reflectively call an instance method on an object on a specific class.
public static < r > r call static method ( class loader class loader , string fully qualified class name , string method name , class parameter < ? > ... class parameters ) { class < ? > clazz = load class ( class loader , fully qualified class name ) ; return call static method ( clazz , method name , class parameters ) ; }	Helper method for calling a static method using a class from a custom class loader.
@ suppress warnings ( str ) public static < r > r call static method ( class < ? > clazz , string method name , class parameter < ? > ... class parameters ) { try { class < ? > [ ] classes = class parameter . get classes ( class parameters ) ; object [ ] values = class parameter . get values ( class parameters ) ; method method = clazz . get declared method ( method name , classes ) ; method . set accessible ( bool ) ; if ( ! modifier . is static ( method . get modifiers ( ) ) ) { throw new illegal argument exception ( method + str ) ; } return ( r ) method . invoke ( null , values ) ; } catch ( invocation target exception e ) { if ( e . get target exception ( ) instanceof runtime exception ) { throw ( runtime exception ) e . get target exception ( ) ; } if ( e . get target exception ( ) instanceof error ) { throw ( error ) e . get target exception ( ) ; } throw new runtime exception ( e . get target exception ( ) ) ; } catch ( no such method exception e ) { throw new runtime exception ( str + clazz + str + method name , e ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Reflectively call a static method on a class.
public static < t > t new instance ( class < t > cl ) { try { return cl . get declared constructor ( ) . new instance ( ) ; } catch ( instantiation exception | illegal access exception | no such method exception | invocation target exception e ) { throw new runtime exception ( e ) ; } }	Create a new instance of a class.
public static < r > r call constructor ( class < ? extends r > clazz , class parameter < ? > ... class parameters ) { try { final class < ? > [ ] classes = class parameter . get classes ( class parameters ) ; final object [ ] values = class parameter . get values ( class parameters ) ; constructor < ? extends r > constructor = clazz . get declared constructor ( classes ) ; constructor . set accessible ( bool ) ; return constructor . new instance ( values ) ; } catch ( instantiation exception e ) { throw new runtime exception ( str + clazz . get name ( ) , e ) ; } catch ( invocation target exception e ) { if ( e . get target exception ( ) instanceof runtime exception ) { throw ( runtime exception ) e . get target exception ( ) ; } if ( e . get target exception ( ) instanceof error ) { throw ( error ) e . get target exception ( ) ; } throw new runtime exception ( e . get target exception ( ) ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Reflectively call the constructor of an object.
@ implementation ( min sdk = p ) protected void start ranging ( ranging request request , executor executor , ranging result callback callback ) { if ( ! ranging results . is empty ( ) ) { executor . execute ( ( ) -> callback . on ranging results ( this . ranging results ) ) ; } else { executor . execute ( ( ) -> callback . on ranging failure ( ranging result callback . status code fail ) ) ; } }	If there are RangingResults set by the setRangeResults method of this shadow class, this methodwill call the onRangingResults method of the callback on the executor thread and pass the listof RangingResults.
@ implementation public static typeface get font sync ( font request request ) { return typeface . create ( request . get query ( ) , typeface . normal ) ; }	Returns a stub typeface immediately.
@ nonnull synchronized public package resource table get compile time sdk resource table ( ) { if ( compiletime sdk resource table == null ) { resource table factory resource table factory = new resource table factory ( ) ; compiletime sdk resource table = resource table factory . new framework resource table ( new resource path ( android . r . class , null , null ) ) ; } return compiletime sdk resource table ; }	Returns the ResourceTable for the compile time SDK.
@ suppress warnings ( str ) @ deprecated public static void dump ( view view ) { shadow view shadow view = shadow . extract ( view ) ; shadow view . dump ( ) ; }	Emits an xml-like representation of the view to System.out.
@ suppress warnings ( str ) public static string inner text ( view view ) { shadow view shadow view = shadow . extract ( view ) ; return shadow view . inner text ( ) ; }	Returns the text contained within this view.
private list < wrapper > get appropriate wrappers ( intent intent , string receiver permission ) { broadcast intents . add ( intent ) ; list < wrapper > result = new array list < > ( ) ; list < wrapper > copy = new array list < > ( ) ; copy . add all ( registered receivers ) ; string intent class = intent . get component ( ) != null ? intent . get component ( ) . get class name ( ) : null ; for ( wrapper wrapper : copy ) { if ( ( has matching permission ( wrapper . broadcast permission , receiver permission ) && wrapper . intent filter . match action ( intent . get action ( ) ) ) || ( intent class != null && intent class . equals ( wrapper . broadcast receiver . get class ( ) . get name ( ) ) ) ) { final int match = wrapper . intent filter . match data ( intent . get type ( ) , intent . get scheme ( ) , intent . get data ( ) ) ; if ( match != intent filter . no match data && match != intent filter . no match type ) { result . add ( wrapper ) ; } } } return result ; }	Returns the BroadcaseReceivers wrappers, matching intent's action and permissions.
private listenable future < broadcast result holder > post intent ( final wrapper wrapper , final intent intent , listenable future < broadcast result holder > old result , final atomic boolean abort , final context context ) { final handler scheduler = ( wrapper . scheduler != null ) ? wrapper . scheduler : get main handler ( context ) ; return futures . transform async ( old result , new async function < broadcast result holder , broadcast result holder > ( ) { @ override public listenable future < broadcast result holder > apply ( broadcast result holder broadcast result holder ) throws exception { final broadcast receiver . pending result result = shadow broadcast pending result . create ( broadcast result holder . result code , broadcast result holder . result data , broadcast result holder . result extras , bool ) ; wrapper . broadcast receiver . set pending result ( result ) ; scheduler . post ( ( ) -> { shadow broadcast receiver shadow broadcast receiver = shadow . extract ( wrapper . broadcast receiver ) ; shadow broadcast receiver . on receive ( context , intent , abort ) ; } ) ; return broadcast result holder . transform ( result ) ; } } , direct executor ( ) ) ; }	Enforces that BroadcastReceivers invoked during an ordered broadcast run serially, passingalong their results.
@ implementation ( min sdk = jelly bean m ) protected static void begin section ( string section name ) { if ( trace . is tag enabled ( trace tag app ) ) { if ( crash on incorrect usage ) { if ( section name . length ( ) > max section name len ) { throw new illegal argument exception ( str ) ; } } else if ( section name == null ) { log . w ( tag , str ) ; return ; } else if ( section name . length ( ) > max section name len ) { log . w ( tag , str ) ; return ; } synchronized ( lock ) { current sections . add first ( section name ) ; } } }	Starts a new trace section with given name.
@ implementation ( min sdk = jelly bean m ) protected static void end section ( ) { if ( trace . is tag enabled ( trace tag app ) ) { synchronized ( lock ) { if ( current sections . is empty ( ) ) { log . e ( tag , str ) ; return ; } previous sections . offer ( current sections . remove first ( ) ) ; } } }	Ends the most recent active trace section.
@ suppress warnings ( str ) @ nonnull private synchronized < t > provider < t > get provider ( final key < t > key ) {	Finds a provider for the given key.Calls are guaranteed idempotent and non-blocking.
boolean create ( string orig file name , int fd , long offset , int length , boolean read only ) { this . m file name = orig file name ; this . fd = fd ; this . m data offset = offset ; this . read only = read only ; return bool ; }	Returns "false" on failure.
public int run all ( ) { int num tasks run = num ; if ( thread . current thread ( ) . equals ( executor thread ) ) { logger . info ( str ) ; return num tasks run ; } while ( has queued tasks ( ) ) { run next ( ) ; num tasks run ++ ; } return num tasks run ; }	Execute all posted tasks and block until they are complete.
public boolean run next ( ) { if ( ! has queued tasks ( ) ) { return bool ; } if ( thread . current thread ( ) . equals ( executor thread ) ) { logger . info ( str ) ; return bool ; } runnable task = deferred tasks . poll ( ) ; task . run ( ) ; return bool ; }	Executes the next queued task.Will be ignored if called from the executor service thread to prevent deadlocks.
@ implementation ( min sdk = o ) protected int request audio focus ( android . media . audio focus request audio focus request ) { last audio focus request = new audio focus request ( audio focus request ) ; return next response value ; }	Provides a mock like interface for the requestAudioFocus method by storing the request objectfor later inspection and returning the value specified in setNextFocusRequestResponse.
@ implementation ( min sdk = o ) protected int abandon audio focus request ( android . media . audio focus request audio focus request ) { last abandoned audio focus request = audio focus request ; return next response value ; }	Provides a mock like interface for the abandonAudioFocusRequest method by storing the requestobject for later inspection and returning the value specified in setNextFocusRequestResponse.
@ implementation ( min sdk = lollipop ) protected void native start ( ) {	Starts the async encoding process, by first reporting a format change event, and thenpresenting an input buffer to the callback.
@ implementation ( min sdk = lollipop ) protected byte buffer get buffer ( boolean input , int index ) { byte buffer [ ] buffers = input ? input buffers : output buffers ; return ( index >= num && index < buffers . length ) ? buffers [ index ] : null ; }	Returns the input or output buffer corresponding to the given index, or null if invalid.
@ implementation ( min sdk = lollipop ) protected void native queue input buffer ( int index , int offset , int size , long presentation time us , int flags ) {	Triggers presentation of the corresponding output buffer for the given input buffer, and passesthe given metadata as buffer info.
@ implementation ( min sdk = lollipop ) protected void release output buffer ( int index , boolean render , boolean update pts , long time ns ) { if ( reached eos ) { return ; } make input buffer available ( index ) ; }	Triggers presentation of the corresponding input buffer for the given output buffer, if end ofstream has not yet been signaled.
private static bundle meta data to bundle ( map < string , object > meta ) { if ( meta . size ( ) == num ) { return null ; } bundle bundle = new bundle ( ) ; for ( map . entry < string , object > entry : meta . entry set ( ) ) { string key = entry . get key ( ) ; object value = entry . get value ( ) ; if ( boolean . class . is instance ( value ) ) { bundle . put boolean ( key , ( boolean ) value ) ; } else if ( float . class . is instance ( value ) ) { bundle . put float ( key , ( float ) value ) ; } else if ( integer . class . is instance ( value ) ) { bundle . put int ( key , ( integer ) value ) ; } else { bundle . put string ( key , value == null ? null : value . to string ( ) ) ; } } return bundle ; }	Goes through the meta data and puts each value in to a bundle as the correct type.
static string convert sql ( string sql ) { matcher matcher = collate localized unicode pattern . matcher ( sql ) ; return matcher . replace all ( str ) ; }	Convert SQL with phrase COLLATE LOCALIZED or COLLATE UNICODE to COLLATE NOCASE.
private static package info new package info ( package info orig ) { parcel parcel = parcel . obtain ( ) ; orig . write to parcel ( parcel , num ) ; parcel . set data position ( num ) ; return package info . creator . create from parcel ( parcel ) ; }	There is no copy constructor for PackageInfo.
private void apply flags to component info ( component info component info , int flags ) throws name not found exception { component info . name = ( component info . name == null ) ? str : component info . name ; application info application info = component info . application info ; boolean is application enabled = bool ; if ( application info != null ) { if ( application info . package name == null ) { application info . package name = component info . package name ; } apply flags to application info ( component info . application info , flags ) ; component info . package name = application info . package name ; is application enabled = application info . enabled ; } if ( ( flags & get meta data ) == num ) { component info . meta data = null ; } boolean is component enabled = is component enabled ( component info ) ; if ( ( flags & match all ) != num && build . version . sdk int >= num ) { return ; }	Modifies the component in place using.
private int get permission index ( package info package info , string permission name ) { if ( package info . requested permissions != null ) { for ( int i = num ; i < package info . requested permissions . length ; i ++ ) { if ( permission name . equals ( package info . requested permissions [ i ] ) ) { return i ; } } } return - num ; }	Returns the index of the given permission in the PackageInfo.requestedPermissions array, or -1if it's not found.
@ implementation ( min sdk = lollipop ) protected drawable get user badged icon ( drawable icon , user handle user ) { return icon ; }	Adds a profile badge to the icon.This implementation just returns the unbadged icon, as some default implementations add aninternal resource to the icon that is unavailable to Robolectric.
private boolean has profile owner or device owner on current user ( ) { device policy manager device policy manager = ( device policy manager ) context . get system service ( context . device policy service ) ; return device policy manager . get profile owner ( ) != null || ( user handle . of ( user handle . my user id ( ) ) . is system ( ) && device policy manager . get device owner ( ) != null ) ; }	Returns whether the current user profile has a profile owner or a device owner.
private static char [ ] extract code point ( string code point ) { try { return character . to chars ( integer . value of ( code point , num ) ) ; } catch ( illegal argument exception e ) {	Converts code points in a given string to actual characters.
public static < t > t reflector ( class < t > i class , object target ) { class < ? > target class = determine target class ( i class ) ; constructor < ? extends t > ctor = ( constructor < ? extends t > ) cache . get ( i class ) ; try { if ( ctor == null ) { class < ? extends t > reflector class = create reflector class ( i class , target class ) ; ctor = reflector class . get constructor ( target class ) ; ctor . set accessible ( bool ) ; } cache . put ( i class , ctor ) ; return ctor . new instance ( target ) ; } catch ( no such method exception | instantiation exception | illegal access exception | invocation target exception e ) { throw new illegal state exception ( e ) ; } }	Returns an object which provides accessors for invoking otherwise inaccessible methods andfields.
public static status get status ( account account , string authority , boolean create ) { map < account , status > map = syncable accounts . get ( authority ) ; if ( map == null ) { map = new hash map < > ( ) ; syncable accounts . put ( authority , map ) ; } status status = map . get ( account ) ; if ( status == null && create ) { status = new status ( ) ; map . put ( account , status ) ; } return status ; }	Retrieve information on the status of the given account.
public collection < content observer > get content observers ( uri uri ) { array list < content observer > observers = new array list < > ( num ) ; for ( content observer entry entry : content observers ) { if ( entry . matches ( uri ) ) { observers . add ( entry . observer ) ; } } return observers ; }	Returns the content observers registered for updates under the given URI.Will be empty if no observer is registered.
public static int add display ( string qualifiers str ) { int id = get shadow display manager global ( ) . add display ( create display info ( qualifiers str , null ) ) ; shadow main looper ( ) . idle ( ) ; return id ; }	Adds a simulated display and drain the main looper queue to ensure all the callbacks areprocessed.
static void change display ( int display id , consumer < display config > consumer ) { display info display info = display manager global . get instance ( ) . get display info ( display id ) ; if ( display info != null ) { display config display config = new display config ( display info ) ; consumer . accept ( display config ) ; display config . copy to ( display info ) ; fix nominal dimens ( display info ) ; } get shadow display manager global ( ) . change display ( display id , display info ) ; }	Changes properties of a simulated display.
private static string fix trace path ( string trace path ) { string default trace body = str ; string default trace extension = str ; if ( trace path == null || trace path . char at ( num ) != str ) { final file dir = runtime environment . application . get external files dir ( null ) ; if ( trace path == null ) { trace path = new file ( dir , default trace body ) . get absolute path ( ) ; } else { trace path = new file ( dir , trace path ) . get absolute path ( ) ; } } if ( ! trace path . ends with ( default trace extension ) ) { trace path += default trace extension ; } return trace path ; }	Forked from android.os.Debug.
private int find next ( bit set bits , int value , calendar calendar , int field , int next field , list < integer > lower orders ) { int next value = bits . next set bit ( value ) ;	Search the bits provided for the next set bit after the value provided,and reset the calendar.
private void reset ( calendar calendar , list < integer > fields ) { for ( int field : fields ) { calendar . set ( field , field == calendar . day of month ? num : num ) ; } }	Reset the calendar setting all the fields provided to zero.
private void parse ( string expression ) throws illegal argument exception { string [ ] fields = strings . split ignore blank ( expression , str ) ; if ( fields . length != num ) { throw new illegal argument exception ( string . format ( str , fields . length , expression ) ) ; } set number hits ( this . seconds , fields [ num ] , num , num ) ; set number hits ( this . minutes , fields [ num ] , num , num ) ; set number hits ( this . hours , fields [ num ] , num , num ) ; set days of month ( this . days of month , fields [ num ] ) ; set months ( this . months , fields [ num ] ) ; set days ( this . days of week , replace ordinals ( fields [ num ] , str ) , num ) ; if ( this . days of week . get ( num ) ) {	Parse the given pattern expression.
private int get arg index ( final int arg ) { int index = ( access & opcodes . acc static ) == num ? num : num ; for ( int i = num ; i < arg ; i ++ ) { index += argument types [ i ] . get size ( ) ; } return index ; }	Returns the index of the given method argument in the frame's localvariables array.
private void load insn ( final type type , final int index ) { mv . visit var insn ( type . get opcode ( opcodes . iload ) , index ) ; }	Generates the instruction to push a local variable on the stack.
private void store insn ( final type type , final int index ) { mv . visit var insn ( type . get opcode ( opcodes . istore ) , index ) ; }	Generates the instruction to store the top stack value in a localvariable.
public void load args ( final int arg , final int count ) { int index = get arg index ( arg ) ; for ( int i = num ; i < count ; ++ i ) { type t = argument types [ arg + i ] ; load insn ( t , index ) ; index += t . get size ( ) ; } }	Generates the instructions to load the given method arguments on thestack.
public void load arg array ( ) { push ( argument types . length ) ; new array ( object type ) ; for ( int i = num ; i < argument types . length ; i ++ ) { dup ( ) ; push ( i ) ; load arg ( i ) ; box ( argument types [ i ] ) ; array store ( object type ) ; } }	Generates the instructions to load all the method arguments on the stack,as a single object array.
public void load local ( final int local , final type type ) { set local type ( local , type ) ; load insn ( type , local ) ; }	Generates the instruction to load the given local variable on the stack.
public void store local ( final int local , final type type ) { set local type ( local , type ) ; store insn ( type , local ) ; }	Generates the instruction to store the top stack value in the given localvariable.
public void swap ( final type prev , final type type ) { if ( type . get size ( ) == num ) { if ( prev . get size ( ) == num ) { swap ( ) ;	Generates the instructions to swap the top two stack values.
public void box ( final type type ) { if ( type . get sort ( ) == type . object || type . get sort ( ) == type . array ) { return ; } if ( type == type . void type ) { push ( ( string ) null ) ; } else { type boxed = get boxed type ( type ) ; new instance ( boxed ) ; if ( type . get size ( ) == num ) {	Generates the instructions to box the top stack value.
public void unbox ( final type type ) { type t = number type ; method sig = null ; switch ( type . get sort ( ) ) { case type . void : return ; case type . char : t = character type ; sig = char value ; break ; case type . boolean : t = boolean type ; sig = boolean value ; break ; case type . double : sig = double value ; break ; case type . float : sig = float value ; break ; case type . long : sig = long value ; break ; case type . int : case type . short : case type . byte : sig = int value ; } if ( sig == null ) { check cast ( type ) ; } else { check cast ( t ) ; invoke virtual ( t , sig ) ; } }	Generates the instructions to unbox the top stack value.
public void if cmp ( final type type , final int mode , final label label ) { switch ( type . get sort ( ) ) { case type . long : mv . visit insn ( opcodes . lcmp ) ; break ; case type . double : mv . visit insn ( mode == ge || mode == gt ? opcodes . dcmpl : opcodes . dcmpg ) ; break ; case type . float : mv . visit insn ( mode == ge || mode == gt ? opcodes . fcmpl : opcodes . fcmpg ) ; break ; case type . array : case type . object : switch ( mode ) { case eq : mv . visit jump insn ( opcodes . if acmpeq , label ) ; return ; case ne : mv . visit jump insn ( opcodes . if acmpne , label ) ; return ; } throw new illegal argument exception ( str + type ) ; default : int int op = - num ; switch ( mode ) { case eq : int op = opcodes . if icmpeq ; break ; case ne : int op = opcodes . if icmpne ; break ; case ge : int op = opcodes . if icmpge ; break ; case lt : int op = opcodes . if icmplt ; break ; case le : int op = opcodes . if icmple ; break ; case gt : int op = opcodes . if icmpgt ; break ; } mv . visit jump insn ( int op , label ) ; return ; } mv . visit jump insn ( mode , label ) ; }	Generates the instructions to jump to a label based on the comparison ofthe top two stack values.
private void field insn ( final int opcode , final type owner type , final string name , final type field type ) { mv . visit field insn ( opcode , owner type . get internal name ( ) , name , field type . get descriptor ( ) ) ; }	Generates a get field or set field instruction.
public void get static ( final type owner , final string name , final type type ) { field insn ( opcodes . getstatic , owner , name , type ) ; }	Generates the instruction to push the value of a static field on thestack.
public void put static ( final type owner , final string name , final type type ) { field insn ( opcodes . putstatic , owner , name , type ) ; }	Generates the instruction to store the top stack value in a static field.
public void get field ( final type owner , final string name , final type type ) { field insn ( opcodes . getfield , owner , name , type ) ; }	Generates the instruction to push the value of a non static field on thestack.
public void put field ( final type owner , final string name , final type type ) { field insn ( opcodes . putfield , owner , name , type ) ; }	Generates the instruction to store the top stack value in a non staticfield.
private void invoke insn ( final int opcode , final type type , final method method , final boolean itf ) { string owner = type . get sort ( ) == type . array ? type . get descriptor ( ) : type . get internal name ( ) ; mv . visit method insn ( opcode , owner , method . get name ( ) , method . get descriptor ( ) , itf ) ; }	Generates an invoke method instruction.
public void invoke virtual ( final type owner , final method method ) { invoke insn ( opcodes . invokevirtual , owner , method , bool ) ; }	Generates the instruction to invoke a normal method.
public void invoke constructor ( final type type , final method method ) { invoke insn ( opcodes . invokespecial , type , method , bool ) ; }	Generates the instruction to invoke a constructor.
public void invoke static ( final type owner , final method method ) { invoke insn ( opcodes . invokestatic , owner , method , bool ) ; }	Generates the instruction to invoke a static method.
public void invoke interface ( final type owner , final method method ) { invoke insn ( opcodes . invokeinterface , owner , method , bool ) ; }	Generates the instruction to invoke an interface method.
public void throw exception ( final type type , final string msg ) { new instance ( type ) ; dup ( ) ; push ( msg ) ; invoke constructor ( type , method . get method ( str ) ) ; throw exception ( ) ; }	Generates the instructions to create and throw an exception.
public void check cast ( final type type ) { if ( ! type . equals ( object type ) ) { type insn ( opcodes . checkcast , type ) ; } }	Generates the instruction to check that the top stack value is of thegiven type.
private void visit implicit first frame ( ) {	Visit the implicit first frame of this method.
private int start frame ( final int offset , final int n local , final int n stack ) { int n = num + n local + n stack ; if ( frame == null || frame . length < n ) { frame = new int [ n ] ; } frame [ num ] = offset ; frame [ num ] = n local ; frame [ num ] = n stack ; return num ; }	Starts the visit of a stack map frame.
item new method item ( final string owner , final string name , final string desc , final boolean itf ) { int type = itf ? imeth : meth ; key3 . set ( type , owner , name , desc ) ; item result = get ( key3 ) ; if ( result == null ) { put122 ( type , new class ( owner ) , new name type ( name , desc ) ) ; result = new item ( index ++ , key3 ) ; put ( result ) ; } return result ; }	Adds a method reference to the constant pool of the class being build.Does nothing if the constant pool already contains a similar item.
item new float ( final float value ) { key . set ( value ) ; item result = get ( key ) ; if ( result == null ) { pool . put byte ( float ) . put int ( key . int val ) ; result = new item ( index ++ , key ) ; put ( result ) ; } return result ; }	Adds a float to the constant pool of the class being build.
private item new string ( final string value ) { key2 . set ( str , value , null , null ) ; item result = get ( key2 ) ; if ( result == null ) { pool . put12 ( str , new ut ( value ) ) ; result = new item ( index ++ , key2 ) ; put ( result ) ; } return result ; }	Adds a string to the constant pool of the class being build.
item new name type item ( final string name , final string desc ) { key2 . set ( name type , name , desc , null ) ; item result = get ( key2 ) ; if ( result == null ) { put122 ( name type , new ut ( name ) , new ut ( desc ) ) ; result = new item ( index ++ , key2 ) ; put ( result ) ; } return result ; }	Adds a name and type to the constant pool of the class being build.
private item get ( final item key ) { item i = items [ key . hash code % items . length ] ; while ( i != null && ( i . type != key . type || ! key . is equal to ( i ) ) ) { i = i . next ; } return i ; }	Returns the constant pool's hash table item which is equal to the givenitem.
private void put122 ( final int b , final int s1 , final int s2 ) { pool . put12 ( b , s1 ) . put short ( s2 ) ; }	Puts one byte and two shorts into the constant pool.
private void put112 ( final int b1 , final int b2 , final int s ) { pool . put11 ( b1 , b2 ) . put short ( s ) ; }	Puts two bytes and one short into the constant pool.
public void visit enum ( string name , string desc , string value ) { if ( av != null ) { av . visit enum ( name , desc , value ) ; } }	Visits an enumeration value of the annotation.
public annotation visitor visit annotation ( string name , string desc ) { if ( av != null ) { return av . visit annotation ( name , desc ) ; } return null ; }	Visits a nested annotation value of the annotation.
private static int pos4twist ( double rank , double phase , double period , int h or w , int x or y , int y or x ) { double dy or x = math . pi * rank * y or x / h or w + phase ; double dx or y = math . sin ( dy or x ) ; return x or y + ( int ) ( dx or y * period ) ; }	2. width, y, x.
public void visit parameter ( string name , int access ) { if ( api < opcodes . as ) { throw new runtime exception ( ) ; } if ( mv != null ) { mv . visit parameter ( name , access ) ; } }	Visits a parameter of this method.
public annotation visitor visit annotation ( string desc , boolean visible ) { if ( mv != null ) { return mv . visit annotation ( desc , visible ) ; } return null ; }	Visits an annotation of this method.
public annotation visitor visit parameter annotation ( int parameter , string desc , boolean visible ) { if ( mv != null ) { return mv . visit parameter annotation ( parameter , desc , visible ) ; } return null ; }	Visits an annotation of a parameter this method.
public void visit type insn ( int opcode , string type ) { if ( mv != null ) { mv . visit type insn ( opcode , type ) ; } }	Visits a type instruction.
public void visit field insn ( int opcode , string owner , string name , string desc ) { if ( mv != null ) { mv . visit field insn ( opcode , owner , name , desc ) ; } }	Visits a field instruction.
@ deprecated public void visit method insn ( int opcode , string owner , string name , string desc ) { if ( api >= opcodes . as ) { boolean itf = opcode == opcodes . invokeinterface ; visit method insn ( opcode , owner , name , desc , itf ) ; return ; } if ( mv != null ) { mv . visit method insn ( opcode , owner , name , desc ) ; } }	Visits a method instruction.
public void visit table switch insn ( int min , int max , label dflt , label ... labels ) { if ( mv != null ) { mv . visit table switch insn ( min , max , dflt , labels ) ; } }	Visits a TABLESWITCH instruction.
public void visit lookup switch insn ( label dflt , int [ ] keys , label [ ] labels ) { if ( mv != null ) { mv . visit lookup switch insn ( dflt , keys , labels ) ; } }	Visits a LOOKUPSWITCH instruction.
public void visit multi a ( string desc , int dims ) { if ( mv != null ) { mv . visit multi a ( desc , dims ) ; } }	Visits a MULTIANEWARRAY instruction.
public void visit line number ( int line , label start ) { if ( mv != null ) { mv . visit line number ( line , start ) ; } }	Visits a line number declaration.
private int get ( final int local ) { if ( output locals == null || local >= output locals . length ) {	Returns the output frame local variable type at the given index.
private void set ( final int local , final int type ) {	Sets the output frame local variable type at the given index.
private void push ( final class writer cw , final string desc ) { int type = type ( cw , desc ) ; if ( type != num ) { push ( type ) ; if ( type == long || type == double ) { push ( top ) ; } } }	Pushes a new type onto the output frame stack.
private static int type ( final class writer cw , final string desc ) { string t ; int index = desc . char at ( num ) == str ? desc . index of ( str ) + num : num ; switch ( desc . char at ( index ) ) { case str : return num ; case str : case str : case str : case str : case str : return integer ; case str : return float ; case str : return long ; case str : return double ; case str :	Returns the int encoding of the given type.
private void pop ( final int elements ) { if ( output stack top >= elements ) { output stack top -= elements ; } else {	Pops the given number of types from the output frame stack.
private void pop ( final string desc ) { char c = desc . char at ( num ) ; if ( c == str ) { pop ( ( type . get arguments and return sizes ( desc ) > > num ) - num ) ; } else if ( c == str || c == str ) { pop ( num ) ; } else { pop ( num ) ; } }	Pops a type from the output frame stack.
private void init ( final int var ) {	Adds a new type to the list of types on which a constructor is invoked inthe basic block.
private int init ( final class writer cw , final int t ) { int s ; if ( t == uninitialized this ) { s = object | cw . add type ( cw . this name ) ; } else if ( ( t & ( dim | base kind ) ) == uninitialized ) { string type = cw . type table [ t & base value ] . str val1 ; s = object | cw . add type ( type ) ; } else { return t ; } for ( int j = num ; j < initialization count ; ++ j ) { int u = initializations [ j ] ; int dim = u & dim ; int kind = u & kind ; if ( kind == local ) { u = dim + input locals [ u & value ] ; } else if ( kind == stack ) { u = dim + input stack [ input stack . length - ( u & value ) ] ; } if ( t == u ) { return s ; } } return t ; }	Replaces the given type with the appropriate type if it is one of thetypes on which a constructor is invoked in the basic block.
public void visit source ( string source , string debug ) { if ( cv != null ) { cv . visit source ( source , debug ) ; } }	Visits the source of the class.
public void visit outer class ( string owner , string name , string desc ) { if ( cv != null ) { cv . visit outer class ( owner , name , desc ) ; } }	Visits the enclosing class of the class.
public annotation visitor visit annotation ( string desc , boolean visible ) { if ( cv != null ) { return cv . visit annotation ( desc , visible ) ; } return null ; }	Visits an annotation of the class.
public static int extract ( int bs , int low , int high ) { bs = bs > > low ; int mask = num ; for ( int i = num ; i < ( high - low ) ; i ++ ) { mask += num << i ; } return bs & mask ; }	Get part of one integer as a new integer.
public static type get object type ( final string internal name ) { char [ ] buf = internal name . to char array ( ) ; return new type ( buf [ num ] == str ? array : object , buf , num , buf . length ) ; }	Returns the Java type corresponding to the given internal name.
public static type [ ] get argument types ( final string method descriptor ) { char [ ] buf = method descriptor . to char array ( ) ; int off = num ; int size = num ; while ( bool ) { char car = buf [ off ++ ] ; if ( car == str ) { break ; } else if ( car == str ) { while ( buf [ off ++ ] != str ) { } ++ size ; } else if ( car != str ) { ++ size ; } } type [ ] args = new type [ size ] ; off = num ; size = num ; while ( buf [ off ] != str ) { args [ size ] = get type ( buf , off ) ; off += args [ size ] . len + ( args [ size ] . sort == object ? num : num ) ; size += num ; } return args ; }	Returns the Java types corresponding to the argument types of the givenmethod descriptor.
public static type get return type ( final string method descriptor ) { char [ ] buf = method descriptor . to char array ( ) ; int off = num ; while ( bool ) { char car = buf [ off ++ ] ; if ( car == str ) { return get type ( buf , off ) ; } else if ( car == str ) { while ( buf [ off ++ ] != str ) { } } } }	Returns the Java type corresponding to the return type of the givenmethod descriptor.
public static int get arguments and return sizes ( final string desc ) { int n = num ; int c = num ; while ( bool ) { char car = desc . char at ( c ++ ) ; if ( car == str ) { car = desc . char at ( c ) ; return n << num | ( car == str ? num : ( car == str || car == str ? num : num ) ) ; } else if ( car == str ) { while ( desc . char at ( c ++ ) != str ) { } n += num ; } else if ( car == str ) { while ( ( car = desc . char at ( c ) ) == str ) { ++ c ; } if ( car == str || car == str ) { n -= num ; } } else if ( car == str || car == str ) { n += num ; } else { n += num ; } } }	Computes the size of the arguments and of the return value of a method.
private static type get type ( final char [ ] buf , final int off ) { int len ; switch ( buf [ off ] ) { case str : return void type ; case str : return boolean type ; case str : return char type ; case str : return byte type ; case str : return short type ; case str : return int type ; case str : return float type ; case str : return long type ; case str : return double type ; case str : len = num ; while ( buf [ off + len ] == str ) { ++ len ; } if ( buf [ off + len ] == str ) { ++ len ; while ( buf [ off + len ] != str ) { ++ len ; } } return new type ( array , buf , off , len + num ) ; case str : len = num ; while ( buf [ off + len ] != str ) { ++ len ; } return new type ( object , buf , off + num , len - num ) ;	Returns the Java type corresponding to the given type descriptor.
private void get descriptor ( final string builder buf ) { if ( this . buf == null ) {	Appends the descriptor corresponding to this Java type to the givenstring buffer.
public static string get descriptor ( final class < ? > c ) { string builder buf = new string builder ( ) ; get descriptor ( buf , c ) ; return buf . to string ( ) ; }	Returns the descriptor corresponding to the given Java type.
public int get opcode ( final int opcode ) { if ( opcode == opcodes . iaload || opcode == opcodes . iastore ) {	Returns a JVM instruction opcode adapted to this Java type.
public byte vector put byte ( final int b ) { int length = this . length ; if ( length + num > data . length ) { enlarge ( num ) ; } data [ length ++ ] = ( byte ) b ; this . length = length ; return this ; }	Puts a byte into this byte vector.
byte vector put11 ( final int b1 , final int b2 ) { int length = this . length ; if ( length + num > data . length ) { enlarge ( num ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) b1 ; data [ length ++ ] = ( byte ) b2 ; this . length = length ; return this ; }	Puts two bytes into this byte vector.
public byte vector put short ( final int s ) { int length = this . length ; if ( length + num > data . length ) { enlarge ( num ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) ( s > > > num ) ; data [ length ++ ] = ( byte ) s ; this . length = length ; return this ; }	Puts a short into this byte vector.
byte vector put12 ( final int b , final int s ) { int length = this . length ; if ( length + num > data . length ) { enlarge ( num ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) b ; data [ length ++ ] = ( byte ) ( s > > > num ) ; data [ length ++ ] = ( byte ) s ; this . length = length ; return this ; }	Puts a byte and a short into this byte vector.
public byte vector put int ( final int i ) { int length = this . length ; if ( length + num > data . length ) { enlarge ( num ) ; } byte [ ] data = this . data ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) i ; this . length = length ; return this ; }	Puts an int into this byte vector.
public byte vector put long ( final long l ) { int length = this . length ; if ( length + num > data . length ) { enlarge ( num ) ; } byte [ ] data = this . data ; int i = ( int ) ( l > > > num ) ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) i ; i = ( int ) l ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) ( i > > > num ) ; data [ length ++ ] = ( byte ) i ; this . length = length ; return this ; }	Puts a long into this byte vector.
public byte vector put ut ( final string s ) { int char length = s . length ( ) ; if ( char length > num ) { throw new illegal argument exception ( ) ; } int len = length ; if ( len + num + char length > data . length ) { enlarge ( num + char length ) ; } byte [ ] data = this . data ;	Puts an UTF8 string into this byte vector.
public byte vector put byte array ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { system . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }	Puts an array of bytes into this byte vector.
private void enlarge ( final int size ) { int length1 = num * data . length ; int length2 = length + size ; byte [ ] new data = new byte [ length1 > length2 ? length1 : length2 ] ; system . arraycopy ( data , num , new data , num , length ) ; data = new data ; }	Enlarge this byte vector so that it can receive n more bytes.
@ override public string get column name ( int col ) { return ( col < header . length ) ? column mapping . get ( header [ col ] . to upper case ( ) ) : null ; }	Retrieves the column name for a given column position.
public void set column mapping ( map < string , string > column mapping ) { this . column mapping . clear ( ) ; for ( map . entry < string , string > entry : column mapping . entry set ( ) ) { this . column mapping . put ( entry . get key ( ) . to upper case ( ) , entry . get value ( ) ) ; } }	Sets the column mapping to those passed in.
@ override public < t > t get value ( string property name , class < t > return type ) { return get container ( ) . get value ( property name , return type ) ; }	Returns the value for the given property cast to the passed returnType.If the type of the property and the given return type are not compatible an exception will be thrown.If the passed propertyName is not a defined property, an exception is thrown.
@ override public void init ( configuration value provider ... configuration value providers ) { if ( configuration value providers != null ) { for ( configuration property property : get container ( ) . properties . values ( ) ) { property . init ( configuration value providers ) ; } } }	Override default values for properties with the given ConfigurationProviders.
public static io for name ( string name ) { if ( io . sensitive . name . equals ( name ) ) { return io . sensitive ; } if ( io . insensitive . name . equals ( name ) ) { return io . insensitive ; } if ( io . system . name . equals ( name ) ) { return io . system ; } throw new illegal argument exception ( str + name ) ; }	Factory method to create an IOCase from a name.
string convert case ( string str ) { if ( str == null ) { return null ; } return is sensitive ? str : str . to lower case ( ) ; }	Converts the case of the input String to a standard format.Subsequent operations can then use standard String methods.
public object get current value ( change change ) { try { for ( property descriptor descriptor : property utils . get instance ( ) . get descriptors ( change . get class ( ) ) ) { if ( descriptor . get display name ( ) . equals ( this . parameter name ) ) { method read method = descriptor . get read method ( ) ; if ( read method == null ) { read method = change . get class ( ) . get method ( str + string util . upper case first ( descriptor . get name ( ) ) ) ; } return read method . invoke ( change ) ; } } throw new runtime exception ( str + this . parameter name ) ; } catch ( exception e ) { throw new unexpected liquibase exception ( e ) ; } }	Returns the current value of this parameter for the given Change.
public static < t > t [ ] create if null ( t [ ] arguments ) { if ( arguments == null ) { return ( t [ ] ) new object [ num ] ; } else { return arguments ; } }	Returns a new empty array if the passed array is null.
public static < t > set < t > create if null ( set < t > current value ) { if ( current value == null ) { return new hash set < > ( ) ; } else { return current value ; } }	Returns a new empty set if the passed array is null.
private boolean get global param ( map property ) { boolean global = null ; object global obj = property . get ( str ) ; if ( global obj == null ) {	Extract the global parameter from the properties.
protected void attach params ( list < column config > cols , prepared statement stmt ) throws sql , database exception { int i = num ;	Sets the list of bind variables for the execution of a DML statement.
public string get absolute path ( string path ) { string p = path ; file f = new file ( p ) ; if ( ! f . is absolute ( ) ) { string base path = filename utils . get full path ( change set . get change log ( ) . get physical file path ( ) ) ; p = filename utils . normalize ( base path + p ) ; } return p ; }	Gets absolute and normalized path for path.If path is relative, absolute path is calculated relative to change log file.
public static check sum parse ( string checksum value ) { if ( checksum value == null ) { return null ; }	Parse the given storedCheckSum string value and return a new CheckSum object.
public static check sum compute ( string value to checksum ) { return new check sum ( m . compute m (	Compute a storedCheckSum of the given string.
protected class loader get class loader including project classpath ( ) throws mojo execution exception { try { list classpath elements = project . get compile classpath elements ( ) ; classpath elements . add ( project . get build ( ) . get output directory ( ) ) ; url urls [ ] = new url [ classpath elements . size ( ) ] ; for ( int i = num ; i < classpath elements . size ( ) ; ++ i ) { urls [ i ] = new file ( ( string ) classpath elements . get ( i ) ) . to uri ( ) . to url ( ) ; } return new url ( urls , get maven artifact class loader ( ) ) ; } catch ( exception e ) { throw new mojo execution exception ( str , e ) ; } }	Returns an isolated classloader.
protected void print settings ( string indent ) { if ( indent == null ) { indent = str ; } get log ( ) . info ( indent + str + driver ) ; get log ( ) . info ( indent + str + url ) ; get log ( ) . info ( indent + str + username ) ; get log ( ) . info ( indent + str + str ) ; get log ( ) . info ( indent + str + empty password ) ; get log ( ) . info ( indent + str + property file ) ; get log ( ) . info ( indent + str + property file will override ) ; get log ( ) . info ( indent + str + prompt on non local database ) ; get log ( ) . info ( indent + str + clear check sums ) ; }	Prints the settings that have been set of defaulted for the plugin.
protected void parse properties file ( input stream properties input stream ) throws mojo execution exception { if ( properties input stream == null ) { throw new mojo execution exception ( str ) ; } properties props = new properties ( ) ; try { props . load ( properties input stream ) ; } catch ( io e ) { throw new mojo execution exception ( str , e ) ; } for ( iterator it = props . key set ( ) . iterator ( ) ; it . has next ( ) ; ) { string key = null ; try { key = ( string ) it . next ( ) ; field field = maven utils . get declared field ( this . get class ( ) , key ) ; if ( property file will override ) { get log ( ) . debug ( str + field . get name ( ) ) ; set field value ( field , props . get ( key ) . to string ( ) ) ; } else { if ( ! is current field value specified ( field ) ) { get log ( ) . debug ( str + field . get name ( ) ) ; set field value ( field , props . get ( key ) . to string ( ) ) ; } } } catch ( exception e ) { get log ( ) . info ( str + key + str + str ) ; } } }	Parses a properties file and sets the associated fields in the plugin.
private boolean is current field value specified ( field f ) throws illegal access exception { object current value = f . get ( this ) ; if ( current value == null ) { return bool ; } object default value = get default value ( f ) ; if ( default value == null ) { return current value != null ; } else {	This method will check to see if the user has specified a value different to that ofthe default value.
public void write next ( string [ ] next line , boolean apply quotes to all ) { if ( next line == null ) { return ; } string builder sb = new string builder ( next line . length * num ) ;	Writes the next line to the file.
protected boolean string contains special characters ( string line ) { return ( line . index of ( quotechar ) != - num ) || ( line . index of ( escapechar ) != - num ) || ( line . index of ( separator ) != - num ) || line . contains ( default line end ) || line . contains ( str ) ; }	checks to see if the line contains special characters.
protected string builder process line ( string next element ) { string builder sb = new string builder ( next element . length ( ) * num ) ;	Processes all the characters in a line.
private void process character ( string builder sb , char next char ) { if ( ( escapechar != no escape character ) && check characters to escape ( next char ) ) { sb . append ( escapechar ) . append ( next char ) ; } else { sb . append ( next char ) ; } }	Appends the character to the StringBuilder adding the escape character if needed.
protected object value of ( object value ) { if ( value == null ) { return value ; } else if ( type . is assignable from ( value . get class ( ) ) ) { return value ; } else if ( value instanceof string ) { if ( type . equals ( boolean . class ) ) { return boolean . value of ( ( string ) value ) ; } else if ( type . equals ( integer . class ) ) { return integer . value of ( ( string ) value ) ; } else if ( type . equals ( big decimal . class ) ) { return new big decimal ( ( string ) value ) ; } else if ( type . equals ( long . class ) ) { return long . value of ( ( string ) value ) ; } else if ( type . equals ( list . class ) ) { return string util . split and trim ( ( string ) value , str ) ; } else { throw new unexpected liquibase exception ( str + value . get class ( ) . get simple name ( ) + str + type . get simple name ( ) ) ; } } else { throw new unexpected liquibase exception ( str + value . get class ( ) . get simple name ( ) + str + type . get simple name ( ) ) ; } }	Converts an object of a different type to the type used by this property.
public < t > t get value ( class < t > type ) { if ( ! this . type . is assignable from ( type ) ) { throw new unexpected liquibase exception ( str + name + str + this . type . get simple name ( ) + str + type . get simple name ( ) ) ; } return ( t ) value ; }	Returns the value currently stored in this property cast to the given type.
public void set value ( object value ) { if ( ( value != null ) && ! type . is assignable from ( value . get class ( ) ) ) { throw new unexpected liquibase exception ( str + name + str + type . get simple name ( ) + str + value . get class ( ) . get simple name ( ) ) ; } this . value = value ; was overridden = bool ; }	Overwrites the value currently stored in this property.
public configuration property add alias ( string ... aliases ) { if ( aliases != null ) { this . aliases . add all ( arrays . as list ( aliases ) ) ; } return this ; }	Adds an alias for this property.
public configuration property set default value ( object default value ) { if ( ( default value != null ) && ! type . is assignable from ( default value . get class ( ) ) ) { if ( ( type == long . class ) && ( default value instanceof integer ) ) { return set default value ( ( ( integer ) default value ) . long value ( ) ) ; } throw new unexpected liquibase exception ( str + name + str + type . get simple name ( ) + str + default value . get class ( ) . get simple name ( ) ) ; } this . default value = default value ; return this ; }	Sets the default value to use if no ConfigurationProviders override it.
private boolean apply is computed expression heuristic ( column config column , database database ) { string expr = column . get name ( ) ; string regex = str	An imperfect heuristic to determine if an expression is more likely a column name or a computed expression.
public void tag ( string tag string ) throws liquibase exception { lock service lock service = lock service factory . get instance ( ) . get lock service ( database ) ; lock service . wait for lock ( ) ; try { change log history service factory . get instance ( ) . get change log service ( database ) . generate deployment id ( ) ; check liquibase tables ( bool , null , new contexts ( ) , new label expression ( ) ) ; get database ( ) . tag ( tag string ) ; } finally { try { lock service . release lock ( ) ; } catch ( lock exception e ) { log . severe ( log type . log , msg could not release lock , e ) ; } } }	'Tags' the database for future rollback.
public database change log lock [ ] list locks ( ) throws liquibase exception { check liquibase tables ( bool , null , new contexts ( ) , new label expression ( ) ) ; return lock service factory . get instance ( ) . get lock service ( database ) . list locks ( ) ; }	Display change log lock information.
public list < change set status > get change set statuses ( contexts contexts , label expression label expression , boolean check liquibase tables ) throws liquibase exception { change log parameters . set contexts ( contexts ) ; change log parameters . set labels ( label expression ) ; database change log change log = get database change log ( ) ; if ( check liquibase tables ) { check liquibase tables ( bool , change log , contexts , label expression ) ; } change log . validate ( database , contexts , label expression ) ; change log iterator log iterator = get standard changelog iterator ( contexts , label expression , change log ) ; status visitor visitor = new status visitor ( database ) ; log iterator . run ( visitor , new runtime environment ( database , contexts , label expression ) ) ; return visitor . get statuses ( ) ; }	Returns the ChangeSetStatuses of all changesets in the change log file and history in the order theywould be ran.
public void clear check sums ( ) throws liquibase exception { log . info ( log type . log , str ) ; lock service lock service = lock service factory . get instance ( ) . get lock service ( database ) ; lock service . wait for lock ( ) ; try { check liquibase tables ( bool , null , new contexts ( ) , new label expression ( ) ) ; update statement update statement = new update statement ( get database ( ) . get liquibase catalog name ( ) , get database ( ) . get liquibase schema name ( ) , get database ( ) . get database change log table name ( ) ) ; update statement . add new column value ( str , null ) ; executor service . get instance ( ) . get executor ( database ) . execute ( update statement ) ; get database ( ) . commit ( ) ; } finally { try { lock service . release lock ( ) ; } catch ( lock exception e ) { log . severe ( log type . log , msg could not release lock , e ) ; } } reset services ( ) ; }	Sets checksums to null so they will be repopulated next run.
public list < t > parse ( mapping strategy < t > mapper , reader reader ) { return parse ( mapper , new csv ( reader ) ) ; }	parse the values from a csvReader constructed from the passed in Reader.
protected t process line ( mapping strategy < t > mapper , string [ ] line ) throws reflective operation exception , introspection exception { t bean = mapper . create bean ( ) ; for ( int col = num ; col < line . length ; col ++ ) { if ( mapper . is annotation driven ( ) ) { process field ( mapper , line , bean , col ) ; } else { process property ( mapper , line , bean , col ) ; } } return bean ; }	Creates a single object from a line from the csv file.
protected property editor get property editor ( property descriptor desc ) throws reflective operation exception { class < ? > cls = desc . get property editor class ( ) ; if ( null != cls ) { return ( property editor ) cls . get constructor ( ) . new instance ( ) ; } return get property editor value ( desc . get property type ( ) ) ; }	Attempt to find custom property editor on descriptor first, else try the propery editor manager.
protected void add if matching ( package scan filter test , string fqn , set < class < ? > > classes ) { try { string external name = fqn . substring ( num , fqn . index of ( str ) ) . replace ( str , str ) ; set < class loader > set = get class loaders ( ) ; boolean found = bool ; for ( class loader class loader : set ) { log . fine ( log type . log , str + external name + str + test + str + class loader ) ; try { class < ? > type = class loader . load class ( external name ) ; log . fine ( log type . log , str + type + str + class loader ) ; if ( test . matches ( type ) ) { log . fine ( log type . log , str + type + str + class loader ) ; classes . add ( type ) ; } found = bool ; break ; } catch ( class not found exception e ) { log . fine ( log type . log , str + fqn + str + class loader + str + e , e ) ; } catch ( linkage error e ) { log . fine ( log type . log , str + fqn + str + class loader + str + e , e ) ; } catch ( exception e ) { log . severe ( log type . log , str + fqn + str + class loader + str + e , e ) ; } } if ( ! found ) {	Add the class designated by the fully qualified class name provided tothe set of resolved classes if and only if it is approved by the Testsupplied.
public static class get property type ( object object , string property name ) { method read method = get read method ( object , property name ) ; if ( read method == null ) { return null ; } return read method . get return type ( ) ; }	Tried to determine the appropriate reader method for a given propertyName of a given object and, if found,returns the class of its return type.
public static boolean has property ( object object , string property name ) { return has read property ( object , property name ) && has write property ( object , property name ) ; }	Examines the given object's class and returns true if reader and writer methods both exist for thegiven property name.
private static method get read method ( object object , string property name ) { string get method name = str + property name . substring ( num , num ) . to upper case ( locale . english ) + property name . substring ( num ) ; string is method name = str + property name . substring ( num , num ) . to upper case ( locale . english ) + property name . substring ( num ) ; method [ ] methods = get methods ( object ) ; for ( method method : methods ) { if ( ( method . get name ( ) . equals ( get method name ) || method . get name ( ) . equals ( is method name ) ) && ( method . get parameter types ( ) . length == num ) ) { return method ; } } return null ; }	Tries to find the Java method to read a given propertyName for the given object.
private static method get write method ( object object , string property name ) { string method name = str + property name . substring ( num , num ) . to upper case ( locale . english ) + property name . substring ( num ) ; method [ ] methods = get methods ( object ) ; for ( method method : methods ) { if ( method . get name ( ) . equals ( method name ) && ( method . get parameter types ( ) . length == num ) ) { return method ; } } return null ; }	Tries to find the Java method to write a new value for a given propertyName to the given object.
private static method [ ] get methods ( object object ) { method [ ] methods = method cache . get ( object . get class ( ) ) ; if ( methods == null ) { methods = object . get class ( ) . get methods ( ) ; method cache . put ( object . get class ( ) , methods ) ; } return methods ; }	Determines the class of a given object and returns an array of that class's methods.
protected object undo collection ( object potential collection , object other object ) { if ( ( potential collection != null ) && ( other object != null ) && ( potential collection instanceof collection ) && ! ( other object instanceof collection ) ) { if ( ( ( ( collection ) potential collection ) . size ( ) == num ) && ( ( collection ) potential collection ) . iterator ( ) . next ( ) . get class ( ) . equals ( other object . get class ( ) ) ) { potential collection = ( ( collection ) potential collection ) . iterator ( ) . next ( ) ; } } return potential collection ; }	Sometimes an attribute in one object is a single-entity collection and on the other it is just the object.Check the passed potentialCollection and if it is a single-entry collection of the same type as the otherObject, return just the collection element.Otherwise, return the original collection.
public list < foreign key > get outgoing foreign keys ( ) { list < foreign key > fk list = get attribute ( str , list . class ) ; return ( ( fk list == null ) ? new array list < foreign key > ( num ) : fk list ) ; }	Returns the list of all outgoing FOREIGN KEYS from this table.
cdi file locked ( final string id , callable < cdi > action ) throws exception { log . info ( log type . log , string . format ( str , id ) ) ; string lock path = string . format ( str , root path ) ; file lock file = new file ( lock path ) ; if ( ! lock file . exists ( ) && lock file . create new file ( ) ) { log . info ( log type . log , string . format ( str , id , lock path ) ) ; } log . info ( log type . log , string . format ( str , id , lock path ) ) ; cdi action result = null ; file lock lock = null ; try ( file output stream file stream = new file output stream ( lock path ) ; file channel file channel = file stream . get channel ( ) ; ) { while ( null == lock ) { try { lock = file channel . try lock ( ) ; } catch ( overlapping file lock exception e ) { log . fine ( log type . log , string . format ( str , id ) ) ; } if ( null == lock ) { log . fine ( log type . log , string . format ( str , id ) ) ; thread . sleep ( file lock timeout ) ; } } log . info ( log type . log , string . format ( str , id ) ) ; action result = action . call ( ) ; lock . release ( ) ; } catch ( exception e ) { log . warning ( log type . log , e . get message ( ) , e ) ; } return action result ; }	Synchronization among multiple JVM's.
public static string get simple path for resources ( string entry name , string path ) { string [ ] components = path . split ( str ) ; if ( components . length == num ) { if ( components [ num ] . ends with ( str ) ) { return components [ num ] . substring ( num ) ; } else { return entry name . replace first ( components [ num ] , str ) . substring ( num ) ; } } return entry name ; }	Method used to simplify an entryNameEx: with path jar:/some/jar.jar!/BOOT-INF/classes!/db/changelog and entryName /BOOT-INF/classes/db/changelogThe simple entry name for Spring is db/changelog(/BOOT-INF/classes/ is not needed and break the liquibase alphabetical sort order).
public boolean is filtered by ( class < ? extends change set filter > filter type ) { if ( ! will run ) { return bool ; } if ( filter results == null ) { return bool ; } for ( change set filter result result : filter results ) { if ( result . get filter ( ) . equals ( filter type ) ) { return bool ; } } return bool ; }	Convenience method to check wither a given ChangeSetFilter type is a reason for running the change set or not.
public static string get value for column ( result set rs , string column name to check , database database ) throws sql { result set meta data metadata = rs . get meta data ( ) ; int number of columns = metadata . get column count ( ) ; string corrected column name = database . correct object name ( column name to check , column . class ) ;	Checks whether a result set has a column matching the specified column name.The column name is first changed to match the database format.E.g.
public void init ( configuration value provider ... configuration value providers ) { if ( configuration value providers == null ) { configuration value providers = new configuration value provider [ num ] ; } this . configuration value providers = configuration value providers ; this . reset ( ) ; }	Re-initialize the configuration with the given ConfigurationProviders.
public static void initialize database ( string username , string default catalog name , string default schema name , database database ) throws database exception { if ( ( ( default catalog name != null ) || ( default schema name != null ) ) && ! ( database . get connection ( ) instanceof offline connection ) ) { if ( database instanceof oracle database ) { string schema = default catalog name ; if ( schema == null ) { schema = default schema name ; } executor service . get instance ( ) . get executor ( database ) . execute ( new raw sql statement ( str + database . escape object name ( schema , schema . class ) ) ) ; } else if ( database instanceof postgres database && default schema name != null ) { executor service . get instance ( ) . get executor ( database ) . execute ( new raw sql statement ( str + database . escape object name ( default schema name , schema . class ) ) ) ; } else if ( database instanceof abstract db2 database ) { string schema = default catalog name ; if ( schema == null ) { schema = default schema name ; } executor service . get instance ( ) . get executor ( database ) . execute ( new raw sql statement ( str + schema ) ) ; } else if ( database instanceof sql ) { string schema = default catalog name ; if ( schema == null ) { schema = default schema name ; } executor service . get instance ( ) . get executor ( database ) . execute ( new raw sql statement ( str + schema ) ) ; } } }	Executes RawSqlStatements particular to each database engine to set the default schema for the given Database.
public static boolean name matches ( database object database object1 , database object database object2 , database according to ) { string object1 name = according to . correct object name ( database object1 . get name ( ) , database object1 . get class ( ) ) ; string object2 name = according to . correct object name ( database object2 . get name ( ) , database object2 . get class ( ) ) ; if ( ( object1 name == null ) && ( object2 name == null ) ) { return bool ; } if ( ( object1 name == null ) || ( object2 name == null ) ) { return bool ; } if ( according to . is case sensitive ( ) ) { return object1 name . equals ( object2 name ) ; } else { return object1 name . equals ignore case ( object2 name ) ; } }	Static so it can be used in other comparators if needed.
private void set validate option if available ( database database , foreign key foreign key , cached row cached row ) { if ( ! ( database instanceof oracle database ) ) { return ; } final string constraint validate = cached row . get string ( str ) ; final string validate = str ; if ( constraint validate != null && ! constraint validate . is empty ( ) ) { foreign key . set should validate ( validate . equals ( clean name from database ( constraint validate . trim ( ) , database ) ) ) ; } }	Method to map 'validate' option for FK. This thing works only for ORACLE.
public boolean add type ( class < ? extends database object > type , database database ) { boolean added = this . types . add ( type ) ; if ( added ) { for ( class < ? extends database object > container : snapshot generator factory . get instance ( ) . get container types ( type , database ) ) { add type ( container , database ) ; } } return added ; }	Adds a new DatabaseObject type to the list of object types to be included in snapshots.
@ override public void after properties set ( ) throws liquibase exception { configuration property should run property = liquibase configuration . get instance ( ) . get property ( global configuration . class , global configuration . should run ) ; if ( ! should run property . get value ( boolean . class ) ) { scope . get current scope ( ) . get log ( get class ( ) ) . info ( log type . log , str + liquibase configuration . get instance ( ) . describe value lookup logic ( should run property ) + str ) ; return ; } if ( ! should run ) { scope . get current scope ( ) . get log ( get class ( ) ) . info ( log type . log , str + str + str + get bean name ( ) + str ) ; return ; } connection c = null ; liquibase liquibase = null ; try { c = get data source ( ) . get connection ( ) ; liquibase = create liquibase ( c ) ; generate rollback file ( liquibase ) ; perform update ( liquibase ) ; } catch ( sql e ) { throw new database exception ( e ) ; } finally { database database = null ; if ( liquibase != null ) { database = liquibase . get database ( ) ; } if ( database != null ) { database . close ( ) ; } } }	Executed automatically when the bean is initialized.
protected string check for trim ( string s , property descriptor prop ) { return trimmable property ( prop ) ? s . trim ( ) : s ; }	Returns the trimmed value of the string only if the property the string is describing should be trimmedto be converted to that type.
protected object convert value ( string value , property descriptor prop ) throws reflective operation exception { property editor editor = get property editor ( prop ) ; object obj = value ; if ( null != editor ) { editor . set as text ( value ) ; obj = editor . get value ( ) ; } return obj ; }	Convert a string value to its Object value.
public static void main ( string [ ] args ) { int error level = num ; try { error level = run ( args ) ; } catch ( throwable e ) { system . exit ( - num ) ; } system . exit ( error level ) ; }	Entry point. This is what gets executes when starting this program from the command line. This is actuallya simple wrapper so that an errorlevel of != 0 is guaranteed in case of an uncaught exception.
@ suppress warnings ( str ) private static string [ ] split arg ( string arg ) throws command line parsing exception { string [ ] split arg = arg . split ( str , num ) ; if ( split arg . length < num ) { throw new command line parsing exception ( string . format ( core bundle . get string ( str ) , arg ) ) ; } split arg [ num ] = split arg [ num ] . replace first ( str , str ) ; return split arg ; }	What the number 2 stands for is obvious from the context.
private static boolean is no arg command ( string arg ) { return commands . migrate . equals ( arg ) || commands . migrate sql . equals ignore case ( arg ) || commands . update . equals ignore case ( arg ) || commands . update sql . equals ignore case ( arg ) || commands . future rollback sql . equals ignore case ( arg ) || commands . update testing rollback . equals ignore case ( arg ) || commands . list locks . equals ignore case ( arg ) || commands . drop all . equals ignore case ( arg ) || commands . release locks . equals ignore case ( arg ) || commands . validate . equals ignore case ( arg ) || commands . help . equals ignore case ( arg ) || commands . clear checksums . equals ignore case ( arg ) || commands . changelog sync . equals ignore case ( arg ) || commands . changelog sync sql . equals ignore case ( arg ) || commands . mark next changeset ran . equals ignore case ( arg ) || commands . mark next changeset ran sql . equals ignore case ( arg ) ; }	Returns true if the given main command arg needs no special parameters.
private static file extract ( jar file jar , jar entry entry ) throws io {	Extract a single object from a JAR file into a temporary file.
private void parse default property file from resource ( file potential property file ) throws io , command line parsing exception { try ( input stream resource as stream = get class ( ) . get class loader ( ) . get resource as stream ( potential property file . get absolute path ( ) ) ) { if ( resource as stream != null ) { parse properties file ( resource as stream ) ; } } }	Open a property file that is embedded as a Java resource and parse it.
protected string [ ] fixup args ( string [ ] args ) { list < string > fixed args = new array list < > ( ) ; for ( int i = num ; i < args . length ; i ++ ) { string arg = args [ i ] ; if ( ( arg . starts with ( str ) || arg . starts with ( str ) ) && ! arg . contains ( str ) ) { string next arg = null ; if ( ( i + num ) < args . length ) { next arg = args [ i + num ] ; } if ( ( next arg != null ) && ! next arg . starts with ( str ) && ! is command ( next arg ) ) { arg = arg + str + next arg ; i ++ ; } }	On windows machines, it splits args on '=' signs.
protected list < string > check setup ( ) { list < string > messages = new array list < > ( ) ; if ( command == null ) { messages . add ( core bundle . get string ( str ) ) ; } else if ( ! is command ( command ) ) { messages . add ( string . format ( core bundle . get string ( str ) , command ) ) ; } else { if ( string util . trim to null ( url ) == null ) { messages . add ( string . format ( core bundle . get string ( str ) , str + options . url ) ) ; } if ( is change log required ( command ) && ( string util . trim to null ( change log file ) == null ) ) { messages . add ( string . format ( core bundle . get string ( str ) , str + options . changelog file ) ) ; } if ( is no arg command ( command ) && ! command params . is empty ( ) ) { messages . add ( core bundle . get string ( errormsg unexpected parameters ) + command params ) ; } else { validate command parameters ( messages ) ; } } return messages ; }	After parsing, checks if the given combination of main command and can be executed.
private void check for missing command parameters ( final list < string > messages ) { if ( ( command params . is empty ( ) || command params . iterator ( ) . next ( ) . starts with ( str ) ) && ( commands . calculate checksum . equals ignore case ( command ) ) ) { messages . add ( core bundle . get string ( str ) ) ; } }	Checks for missing command line parameters and, if any problems are found,returns the list of issues in String form.
private void check for malformed command parameters ( final list < string > messages ) { if ( command params . is empty ( ) ) { return ; } final int changeset minimum identifier parts = num ; if ( commands . calculate checksum . equals ignore case ( command ) ) { for ( final string param : command params ) { if ( ( param != null ) && ! param . starts with ( str ) ) { final string [ ] parts = param . split ( str ) ; if ( parts . length < changeset minimum identifier parts ) { messages . add ( core bundle . get string ( str ) ) ; break ; } } } } else if ( commands . diff changelog . equals ignore case ( command ) && ( diff types != null ) && diff types . to lower case ( ) . contains ( str ) ) { messages . add ( string . format ( core bundle . get string ( str ) , options . diff types , commands . generate changelog ) ) ; } }	Checks for incorrectly written command line parameters and, if any problems are found,returns the list of issues in String form.
protected void print help ( list < string > error messages , print stream stream ) { stream . println ( core bundle . get string ( str ) ) ; for ( string message : error messages ) { stream . println ( str + message ) ; } stream . println ( ) ; }	If any errors have been found, print the list of errors first, then print the command line help text.
protected void print help ( print stream stream ) { string help text = command line help bundle . get string ( str ) ; stream . println ( help text ) ; }	Print instructions on how to use this program from the command line.
protected void parse options ( string [ ] param args ) throws command line parsing exception { string [ ] args = fixup args ( param args ) ; boolean seen command = bool ; for ( string arg : args ) { if ( is command ( arg ) ) { this . command = arg ; if ( this . command . equals ignore case ( commands . migrate ) ) { this . command = commands . update ; } else if ( this . command . equals ignore case ( commands . migrate sql ) ) { this . command = commands . update sql ; } seen command = bool ; } else if ( seen command ) {	Parses the command line options.
private string get command param ( string param name , string default value ) throws command line parsing exception { for ( string param : command params ) { if ( ! param . contains ( str ) ) { continue ; } string [ ] split arg = split arg ( param ) ; string attribute name = split arg [ num ] ; string value = split arg [ num ] ; if ( attribute name . equals ignore case ( param name ) ) { return value ; } } return default value ; }	Returns the value for a command line parameter of the form parameterName=value, or defaultValue if thatparameter has not been specified by the user.
public static integer read integer ( string value ) { if ( value == null ) { return null ; } return integer . value of ( value ) ; }	Convenience method for converting a string to an Integer object.
public boolean matches ( labels runtime labels ) { if ( ( runtime labels == null ) || runtime labels . is empty ( ) ) { return bool ; } if ( this . labels . is empty ( ) ) { return bool ; } for ( string expression : this . labels ) { if ( matches ( expression , runtime labels ) ) { return bool ; } } return bool ; }	Returns true if the passed runtime labels match this label expression.
public boolean has ( database object example , database database ) throws database exception , invalid example exception {	Checks if a specific object is present in a database.
public database snapshot create snapshot ( database object [ ] examples , database database , snapshot control snapshot control ) throws database exception , invalid example exception { database connection conn = database . get connection ( ) ; if ( conn == null ) { return new empty database snapshot ( database , snapshot control ) ; } if ( conn instanceof offline connection ) { database snapshot snapshot = ( ( offline connection ) conn ) . get snapshot ( examples ) ; if ( snapshot == null ) { throw new database exception ( str ) ; } return snapshot ; } return new jdbc database snapshot ( examples , database , snapshot control ) ; }	Creates a database snapshot for a given array of DatabaseObjects.
public < t extends database object > t create snapshot ( t example , database database ) throws database exception , invalid example exception { return create snapshot ( example , database , new snapshot control ( database ) ) ; }	Creates a DatabaseSnapshot for a single DatabaseObject.
private list < drop foreign key constraint change > generate children ( database database ) {	Iterates through all the FOREIGN KEYs of the target table and outputs a list of DropForeignKeyConstraintChangesfor a given database type.
private static void clean directory ( final file directory ) throws io { if ( ! directory . exists ( ) ) { return ; } if ( ! directory . is directory ( ) ) { return ; } io exception = null ; final file [ ] files = directory . list files ( ) ; if ( files != null ) { for ( final file file : files ) { try { clean directory ( file ) ; if ( ! file . delete ( ) ) { throw new io ( str + file . get absolute path ( ) ) ; } } catch ( final io ioe ) { exception = ioe ; } } } if ( null != exception ) { throw exception ; } }	Clean a directory without deleting it.
public static string [ ] split sql ( string multi line sql , string end delimiter ) { return process mutli line sql ( multi line sql , bool , bool , end delimiter ) ; }	Splits a candidate multi-line SQL statement along ;'s and "go"'s.
public static string pad ( string value , int length ) { value = string util . trim to empty ( value ) ; if ( value . length ( ) >= length ) { return value ; } return value + string util . repeat ( str , length - value . length ( ) ) ; }	Adds spaces to the right of the input value until the string has reached the given length.
public static string left pad ( string value , int length ) { value = string util . trim to empty ( value ) ; if ( value . length ( ) >= length ) { return value ; } return string util . repeat ( str , length - value . length ( ) ) + value ; }	Adds spaces to the left of the input value until the string has reached the given length.
public static string random identifer ( int len ) { final string ab = str ; string builder sb = new string builder ( len ) ; for ( int i = num ; i < len ; i ++ ) sb . append ( ab . char at ( rnd . next int ( ab . length ( ) ) ) ) ; return sb . to string ( ) ; }	Produce a random identifer of the given length, consisting only of uppercase letters.
public static string strip sql comments and whitespaces from the end ( string sql string ) { if ( is empty ( sql string ) ) { return sql string ; } string builder str = new string builder ( sql string ) ; boolean str modified = bool ; while ( str modified ) { str modified = bool ;	Strips the comments and whitespaces from the end of given sql string.
public static string concat consistent case ( string base string , string addition ) { boolean has lower case = has lower case ( base string ) ; boolean has upper case = has upper case ( base string ) ; if ( ( has lower case && has upper case ) || ( ! has lower case && ! has upper case ) ) {	Concatenates the addition string to the baseString string, adjusting the case of "addition" to match the base string.If the string is all caps, append addition in all caps.
protected string [ ] get database catalog names ( database database ) throws sql , database exception { list < string > return list = new array list < > ( ) ; result set catalogs = null ; try { if ( ( ( abstract jdbc database ) database ) . jdbc calls catalogs schemas ( ) ) { catalogs = ( ( jdbc connection ) database . get connection ( ) ) . get meta data ( ) . get schemas ( ) ; } else { catalogs = ( ( jdbc connection ) database . get connection ( ) ) . get meta data ( ) . get catalogs ( ) ; } while ( catalogs . next ( ) ) { if ( ( ( abstract jdbc database ) database ) . jdbc calls catalogs schemas ( ) ) { return list . add ( catalogs . get string ( str ) ) ; } else { return list . add ( catalogs . get string ( str ) ) ; } } } finally { if ( catalogs != null ) { try { catalogs . close ( ) ; } catch ( sql ignore ) { } } } return return list . to array ( new string [ return list . size ( ) ] ) ; }	Fetches an array of Strings with the catalog names in the database.
public string clauses append ( string key , string clause ) { validate . not null ( string util . trim to null ( key ) , str ) ; key = string util . trim to empty ( key ) . to lower case ( ) ; clause = string util . trim to empty ( clause ) ; if ( clauses . contains key ( key ) ) { throw new illegal argument exception ( str + key + str ) ; } clauses . put ( key , clause . trim ( ) ) ; return this ; }	Adds a new clause at the end of the list with the given key.
public string clauses append ( string key , string clauses subclauses ) { validate . not null ( string util . trim to null ( key ) , str ) ; key = string util . trim to empty ( key ) . to lower case ( ) ; if ( clauses . contains key ( key ) ) { throw new illegal argument exception ( str + key + str ) ; } clauses . put ( key , subclauses ) ; return this ; }	Adds a new sub-clause at the end of the list with the given key.
public string clauses prepend ( string key , string clause ) { return prepend impl ( key , string util . trim to empty ( clause ) ) ; }	Adds a clause with the given key to the beginning of the list.
public string clauses insert before ( string existing key , string new key , string new value ) throws illegal argument exception { return insert before impl ( existing key , new key , new value ) ; }	Inserts a new clause before the given key.
public string clauses insert after ( string existing key , string new key , string new value ) { return insert after impl ( existing key , new key , new value ) ; }	Inserts a new clause after the given key.
public string get ( string exiting key ) { exiting key = string util . trim to empty ( exiting key ) . to lower case ( ) ; object clauses = get impl ( exiting key ) ; if ( clauses == null ) { return null ; } return clauses . to string ( ) ; }	Retrieves the given key.
public string clauses get subclause ( string exiting key ) { exiting key = string util . trim to empty ( exiting key ) . to lower case ( ) ; object clauses = get impl ( exiting key ) ; if ( clauses == null ) { return null ; } if ( clauses instanceof string ) { return new string clauses ( ) . append ( ( string ) clauses ) ; } return ( string clauses ) clauses ; }	Retrieves the given key.
public void print ( print stream out , change log serializer change log serializer ) throws parser configuration exception , io , database exception { list < change set > change sets = generate change sets ( ) ; change log serializer . write ( change sets , out ) ; out . flush ( ) ; }	Prints changeLog that would bring the target database to be the same asthe reference database.
public list < database > get implemented databases ( ) { list < database > return list = new array list < > ( ) ; for ( sorted set < database > set : implemented databases . values ( ) ) { return list . add ( set . iterator ( ) . next ( ) ) ; } return return list ; }	Returns instances of all implemented database types.
public list < database > get internal databases ( ) { list < database > return list = new array list < > ( ) ; for ( sorted set < database > set : internal databases . values ( ) ) { return list . add ( set . iterator ( ) . next ( ) ) ; } return return list ; }	Returns instances of all "internal" database types.
public boolean validate ( database database ) { int max parameters = this . get max parameters ( database ) ; int min parameters = this . get min parameters ( database ) ; if ( parameters . size ( ) > max parameters ) { throw new unexpected liquibase exception ( str + get class ( ) + str + max parameters + str ) ; } if ( parameters . size ( ) < min parameters ) { throw new unexpected liquibase exception ( str + get class ( ) + str + min parameters + str ) ; } return bool ; }	Validates the correct state of this data type against a given database.
public database data type to database data type ( database database ) { if ( database instanceof mssql ) { string name = database . escape data type name ( get name ( ) ) ; int data type max parameters = database . get data type max parameters ( get name ( ) ) ; object [ ] parameters = get parameters ( ) ; if ( data type max parameters < parameters . length ) { parameters = arrays . copy of range ( parameters , num , data type max parameters ) ; } return new database data type ( name , parameters ) ; } database data type type = new database data type ( name . to upper case ( locale . us ) , get parameters ( ) ) ; type . add additional information ( additional information ) ; return type ; }	Transforms this data type into the native data type of the target DBMS.
public string object to sql ( object value , database database ) { if ( ( value == null ) || str . equals ( value . to string ( ) . to lower case ( locale . us ) ) ) { return null ; } else if ( value instanceof database function ) { return function to sql ( ( database function ) value , database ) ; } else if ( value instanceof number ) { return number to sql ( ( number ) value , database ) ; } return other to sql ( value , database ) ; }	Returns the value object in a format to include in SQL.
protected boolean is current date time function ( string string , database database ) { return string . to lower case ( locale . us ) . starts with ( str ) || string . to lower case ( locale . us ) . starts with ( database function . current date time place holder ) || database . get current date time function ( ) . to lower case ( locale . us ) . equals ( string . to lower case ( locale . us ) ) ; }	Determines if the given function name refers to the function that returns the currenttime and date for a specific DBMS.
public boolean supports boolean data type ( ) { if ( get connection ( ) == null ) return bool ;	boolean data type column are allowed for versions >= 11.1.1.1.
private string get concat sql ( list < string > values ) { if ( values . size ( ) == num ) { return values . get ( num ) ; } else { return start concat + values . get ( num ) + sep concat + get concat sql ( values . sub list ( num , values . size ( ) ) ) + end concat ; } }	Recursive way of building CONCAT instruction.
public boolean generate statements volatile ( sql statement statement , database database ) { for ( sql generator generator : get generators ( statement , database ) ) { if ( generator . generate statements is volatile ( database ) ) { return bool ; } } return bool ; }	Return true if the SqlStatement class queries the database in any way to determine Statements to execute.If the statement queries the database, it cannot be used in updateSql type operations.
private static void add artifact ( set < uri > urls , artifact artifact , log log , boolean verbose ) throws url { file f = artifact . get file ( ) ; if ( f == null ) { log . warn ( str + artifact . get group id ( ) + str + artifact . get artifact id ( ) + str ) ; } else { add file ( urls , f , log , verbose ) ; }	Adds the artifact file into the set of URLs so it can be used in a URLClassLoader.
public static field get declared field ( class clazz , string field name ) throws no such field exception { field f = get field ( clazz , field name ) ; if ( f == null ) {	Recursively searches for the field specified by the fieldName in the class and allthe super classes until it either finds it, or runs out of parents.
protected list < string > get alternate paths ( string path ) { list < string > alternate paths = new array list < > ( ) ; if ( path . starts with ( str ) ) {	Return alternate options for the given path that the user maybe meant.
public boolean matches ( contexts runtime contexts ) { if ( ( runtime contexts == null ) || runtime contexts . is empty ( ) ) { return bool ; } if ( this . contexts . is empty ( ) ) { return bool ; } for ( string expression : this . contexts ) { if ( matches ( expression , runtime contexts ) ) { return bool ; } } return bool ; }	Returns true if the passed runtime contexts match this context expression.
private resource accessor create resource accessor ( class loader class loader ) { list < resource accessor > resource accessors = new array list < resource accessor > ( ) ; resource accessors . add ( new file system resource accessor ( paths . get ( str ) . to absolute path ( ) . get root ( ) . to file ( ) ) ) ; resource accessors . add ( new class loader resource accessor ( class loader ) ) ; string change log directory = get change log directory ( ) ; if ( change log directory != null ) { change log directory = change log directory . trim ( ) . replace ( str , str ) ;	Creates a suitable ResourceAccessor for use in an Ant task..
protected void close database ( database database ) { try { if ( database != null ) { database . close ( ) ; } } catch ( database exception e ) { log ( str , e , project . msg warn ) ; } }	Convenience method to safely close the database connection.
private int append next character and advance loop ( string line , string builder sb , int i ) { sb . append ( line . char at ( i + num ) ) ; i ++ ; return i ; }	Appends the next character in the line to the stringbuffer.
private boolean is next character escaped quote ( string next line , boolean in quotes , int i ) { return in quotes	Checks to see if the character after the index is a quotation character.precondition: the current character is a quote or an escape.
protected boolean is next character escapable ( string next line , boolean in quotes , int i ) { return in quotes	Checks to see if the character after the current index in a String is an escapable character.Meaning the next character is either a quotation character or the escape char and you are insidequotes.precondition: the current character is an escape.
public list < parsed node > get children ( string namespace , string nodename ) { list < parsed node > return list = new array list < > ( ) ; for ( parsed node node : children ) { if ( node matches ( node , namespace , nodename ) ) { return list . add ( node ) ; } } return collections . unmodifiable list ( return list ) ; }	Returns all child nodes with the given namespace and name.If none match, an empty list is returned.Returned list is unmodifiableList.
public < t > t get value ( class < t > type ) throws parsed node exception { return convert object ( value , type ) ; }	Return the value associated with this node converted to the given type.
public parsed node get child ( string namespace , string name ) throws parsed node exception { parsed node return node = null ; for ( parsed node node : children ) { if ( node matches ( node , namespace , name ) ) { if ( return node != null ) { throw new parsed node exception ( str + namespace + str + name ) ; } return node = node ; } } return return node ; }	Returns the ParsedNode defined by the given namespace and name.
public < t > t get child value ( string namespace , string nodename , class < t > type ) throws parsed node exception { object raw value = get child value ( namespace , nodename ) ; if ( raw value == null ) { return null ; } return convert object ( raw value , type ) ; }	Returns the value of the given node, converted to the passed type.
public object get child value ( string namespace , string nodename ) throws parsed node exception { parsed node child = get child ( namespace , nodename ) ; if ( child == null ) { return null ; } return child . get value ( ) ; }	Returns the value of the given node with no conversion attempted.
@ override public void close ( ) throws io { for ( input stream stream : this ) { try { stream . close ( ) ; } catch ( io e ) { scope . get current scope ( ) . get log ( get class ( ) ) . severe ( str , e ) ; } } }	Close the streams in this collection.
public boolean is auto increment ( ) { return str . equals ( type . to lower case ( locale . us ) ) || str . equals ( type . to lower case ( locale . us ) ) || str . equals ( type . to lower case ( locale . us ) ) ; }	Mainly for postgres, check if the column is a serial data type.
protected boolean is compressed file ( path path ) { return path != null && ( path . to string ( ) . starts with ( str ) || path . to string ( ) . to lower case ( ) . ends with ( str ) || path . to string ( ) . to lower case ( ) . ends with ( str ) ) ; }	Returns true if the given path is a compressed file.
public column get column ( string column name ) { for ( column column : get columns ( ) ) { if ( column . get name ( ) . equals ignore case ( column name ) ) { return column ; } } return null ; }	Returns the column object for the given columnName.
public < t extends singleton object > t get singleton ( class < t > type ) { if ( get parent ( ) != null ) { return get parent ( ) . get singleton ( type ) ; } string key = type . get name ( ) ; t singleton = get ( key , type ) ; if ( singleton == null ) { try { try { constructor < t > constructor = type . get declared constructor ( scope . class ) ; constructor . set accessible ( bool ) ; singleton = constructor . new instance ( this ) ; } catch ( no such method exception e ) {	Looks up the singleton object of the given type.
@ override public void tag ( final string tag string ) throws database exception { database database = get database ( ) ; executor executor = executor service . get instance ( ) . get executor ( database ) ; int total rows = executor service . get instance ( ) . get executor ( database ) . query for int ( new select from database change log statement ( new column config ( ) . set name ( str , bool ) ) ) ; if ( total rows == num ) { change set empty change set = new change set ( string . value of ( new date ( ) . get time ( ) ) , str , bool , bool , str , null , null , get database ( ) . get object quoting strategy ( ) , null ) ; this . set exec type ( empty change set , change set . exec type . executed ) ; } executor . execute ( new tag database statement ( tag string ) ) ; get database ( ) . commit ( ) ; if ( this . ran change set list != null ) { ran change set list . get ( ran change set list . size ( ) - num ) . set tag ( tag string ) ; } }	Tags the database changelog with the given string.
public precondition create ( string tag name ) { class < ? > a class = preconditions . get ( tag name ) ; if ( a class == null ) { return null ; } try { return ( precondition ) a class . get constructor ( ) . new instance ( ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Create a new Precondition subclass based on the given tag name.
public static boolean is now or today format ( string value ) { boolean ret = bool ; if ( value != null ) { string lower value = value . to lower case ( ) ; if ( lower value . length ( ) >= now length && lower value . starts with ( now ) ) { ret = bool ; } else if ( lower value . length ( ) >= today length && lower value . starts with ( today ) ) { ret = bool ; } } return ret ; }	Checks if date starts with "NOW" or "TODAY".
public object get value ( string key , database change log change log ) { change log parameter parameter = find parameter ( key , change log ) ; return ( parameter != null ) ? parameter . get value ( ) : null ; }	Return the value of a parameter.
private void set validate option if available ( database database , unique constraint unique constraint , map < string , ? > columns metadata ) { if ( ! ( database instanceof oracle database ) ) { return ; } final object constraint validate = columns metadata . get ( str ) ; final string validate = str ; if ( constraint validate != null && ! constraint validate . to string ( ) . trim ( ) . is empty ( ) ) { unique constraint . set should validate ( validate . equals ( clean name from database ( constraint validate . to string ( ) . trim ( ) , database ) ) ) ; } }	Method to map 'validate' option for UC. This thing works only for ORACLE.
private string get unique constraints sql informix ( informix database database , schema schema , string name ) { string buffer sql buf = new string buffer ( ) ; sql buf . append ( str ) ;	Gets an SQL query that returns the constraint names and columns for all UNIQUE constraints.
public map < string , change parameter meta data > get set parameters ( change change ) { map < string , change parameter meta data > return map = new hash map < > ( ) ; for ( map . entry < string , change parameter meta data > entry : get parameters ( ) . entry set ( ) ) { if ( entry . get value ( ) . get current value ( change ) != null ) { return map . put ( entry . get key ( ) , entry . get value ( ) ) ; } } return collections . unmodifiable map ( return map ) ; }	Return the parameters of the given change that are set to a non-null value.
public map < string , change parameter meta data > get required parameters ( database database ) { map < string , change parameter meta data > return map = new hash map < > ( ) ; for ( change parameter meta data meta data : parameters . values ( ) ) { if ( meta data . is required for ( database ) ) { return map . put ( meta data . get parameter name ( ) , meta data ) ; } } return return map ; }	Returns the required parameters for this change for the given database.
private string convert to string ( object new value , database database ) { string sql string ; if ( new value == null || new value . to string ( ) . equals ( str ) || new value . to string ( ) . equals ignore case ( str ) ) { sql string = str ; } else if ( new value instanceof string && ! looks like function call ( ( ( string ) new value ) , database ) ) { sql string = str + database . escape string for database ( new value . to string ( ) ) + str ; } else if ( new value instanceof date ) { sql string = database . get date literal ( ( ( date ) new value ) ) ; } else if ( new value instanceof boolean ) { if ( ( ( boolean ) new value ) ) { sql string = data type factory . get instance ( ) . get true boolean value ( database ) ; } else { sql string = data type factory . get instance ( ) . get false boolean value ( database ) ; } } else { sql string = new value . to string ( ) ; } return sql string ; }	Copied and modified from liquibase.sqlgenerator.core.InsertOrUpdateGeneratorMySQL.
@ override public set < string > get serializable fields ( ) { return scope . get current scope ( ) . get singleton ( change factory . class ) . get change meta data ( this ) . get parameters ( ) . key set ( ) ; }	Returns the fields on this change that are serializable.
private static string do get full path ( string filename , boolean include separator ) { if ( filename == null ) { return null ; } int prefix = get prefix length ( filename ) ; if ( prefix < num ) { return null ; } if ( prefix >= filename . length ( ) ) { if ( include separator ) { return get prefix ( filename ) ;	Does the work of getting the path.
protected void create index lookup ( string [ ] values ) { if ( index lookup . is empty ( ) ) { for ( int i = num ; i < values . length ; i ++ ) { index lookup . put ( values [ i ] , i ) ; } } }	Creates an index map of column names to column position.
@ override public integer get column index ( string name ) { if ( null == header ) { throw new illegal state exception ( str ) ; } create index lookup ( header ) ; return index lookup . get ( name ) ; }	Gets the column index that corresponds to a specific colum name.If the CSV file doesn't have a header row, this method will always returnnull.
@ override public property descriptor find descriptor ( int col ) throws introspection exception { string column name = get column name ( col ) ; return ( string util . trim to null ( column name ) != null ) ? find descriptor ( column name ) : null ; }	Gets the property descriptor for a given column position.
@ override public bean field find field ( int col ) { string column name = get column name ( col ) ; return ( string util . trim to null ( column name ) != null ) ? find field ( column name ) : null ; }	Gets the field for a given column position.
public string get column name ( int col ) { return ( ( null != header ) && ( col < header . length ) ) ? header [ col ] : null ; }	Get the column name for a given column position.
protected property descriptor find descriptor ( string name ) throws introspection exception { if ( null == descriptor map ) { descriptor map = load descriptor map ( ) ;	Find the property descriptor for a given column.
protected bean field find field ( string name ) { if ( null == field map ) { field map = load field map ( ) ;	Find the field for a given column.
protected boolean matches ( string name , property descriptor desc ) { return desc . get name ( ) . equals ( name . trim ( ) ) ; }	Determines if the name of a property descriptor matches the column name.Currently only used by unit tests.
protected map < string , property descriptor > load descriptor map ( ) throws introspection exception { map < string , property descriptor > map = new hash map < > ( ) ; property descriptor [ ] descriptors ; descriptors = load descriptors ( get type ( ) ) ; for ( property descriptor descriptor : descriptors ) { map . put ( descriptor . get name ( ) . to upper case ( ) . trim ( ) , descriptor ) ; } return map ; }	builds a map of property descriptors for the Bean.
@ override public string get column name ( int col ) { return ( col < column mapping . length ) ? column mapping [ col ] : null ; }	gets a column name.
public void set column mapping ( string ... column mapping ) { this . column mapping = ( column mapping != null ) ? column mapping . clone ( ) : new string [ ] { } ; reset index map ( ) ; create index lookup ( this . column mapping ) ; }	Setter for the ColumnMappings.
protected int get size ( ) { if ( get parameters ( ) . length == num ) { return - num ; } if ( get parameters ( ) [ num ] instanceof string ) { return integer . parse int ( ( string ) get parameters ( ) [ num ] ) ; } if ( get parameters ( ) [ num ] instanceof number ) { return ( ( number ) get parameters ( ) [ num ] ) . int value ( ) ; } return - num ; }	Return the size of this data type definition. If unknown or unspecified, return -1.
public static boolean supports default value computed ( string column type , string default value ) { hash set < string > possible computed values = supported default value computed map . get ( column type ) ; return ( possible computed values != null ) && possible computed values . contains ( default value . to lower case ( ) ) ; }	Checks to see if the string is an acceptable computed value for HSQL"datetime" columns are the only columns for which HSQL supports computer values.
public list < change set status > get change sets to run ( ) { array list < change set status > return list = new array list < > ( ) ; for ( change set status status : change set statuses . values ( ) ) { if ( status . get will run ( ) ) { return list . add ( status ) ; } } return return list ; }	Return the change sets that will execute.
@ override public string escape object name ( string object name , class < ? extends database object > object type ) { if ( ( quoting strategy == object quoting strategy . legacy ) && has mixed case ( object name ) ) { return str + object name + str ; } else if ( object type != null && liquibase column . class . is assignable from ( object type ) ) { return ( object name != null && ! object name . is empty ( ) ) ? object name . trim ( ) : object name ; } return super . escape object name ( object name , object type ) ; }	This has special case logic to handle NOT quoting column names if they areof type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCKtables.
public column config set value numeric ( string value numeric ) { if ( ( value numeric == null ) || str . equals ignore case ( value numeric ) ) { this . value numeric = null ; } else { string saved = value numeric ; if ( value numeric . starts with ( str ) ) { value numeric = value numeric . replace first ( str , str ) ; value numeric = value numeric . replace first ( str , str ) ; } try { this . value numeric = value numeric . of ( locale . us , value numeric ) ; } catch ( parse exception e ) { this . value computed = new database function ( saved ) ; } } return this ; }	Set the number this column should be set to.
public column config set value boolean ( string value boolean ) { value boolean = string util . trim to null ( value boolean ) ; if ( ( value boolean == null ) || str . equals ignore case ( value boolean ) ) { this . value boolean = null ; } else { if ( str . equals ignore case ( value boolean ) || str . equals ( value boolean ) ) { this . value boolean = bool ; } else if ( str . equals ignore case ( value boolean ) || str . equals ( value boolean ) ) { this . value boolean = bool ; } else { this . value computed = new database function ( value boolean ) ; } } return this ; }	Set the valueBoolean based on a given string.If the passed value cannot be parsed as a date, it is assumed to be a function that returns a boolean.If the string "null" or an empty string is passed, it will set a null value.If "1" is passed, defaultValueBoolean is set to true.
public column config set default value boolean ( string default value boolean ) { default value boolean = string util . trim to null ( default value boolean ) ; if ( ( default value boolean == null ) || str . equals ignore case ( default value boolean ) ) { this . default value boolean = null ; } else { if ( str . equals ignore case ( default value boolean ) || str . equals ( default value boolean ) ) { this . default value boolean = bool ; } else if ( str . equals ignore case ( default value boolean ) || str . equals ( default value boolean ) ) { this . default value boolean = bool ; } else { this . default value computed = new database function ( default value boolean ) ; } } return this ; }	Set the defaultValueBoolean based on a given string.If the passed value cannot be parsed as a date, it is assumed to be a function that returns a boolean.If the string "null" or an empty string is passed, it will set a null value.If "1" is passed, defaultValueBoolean is set to true.
public void unregister ( string name ) { for ( change change : new array list < > ( find all instances ( ) ) ) { if ( get change meta data ( change ) . get name ( ) . equals ( name ) ) { this . remove instance ( change ) ; } } }	Unregister all instances of a given Change name.
public sorted set < string > get defined changes ( ) { sorted set < string > names = new tree set < > ( ) ; for ( change change : find all instances ( ) ) { names . add ( get change meta data ( change ) . get name ( ) ) ; } return collections . unmodifiable sorted set ( names ) ; }	Returns all defined changes in the registry.
public change create ( string name ) { change plugin = get plugin ( name ) ; if ( plugin == null ) { return null ; } try { return plugin . get class ( ) . get constructor ( ) . new instance ( ) ; } catch ( exception e ) { throw new unexpected liquibase exception ( e ) ; } }	Create a new Change implementation for the given change name.
@ override public boolean prompt for non local database ( database database ) throws database exception { return j . show confirm dialog ( null , str + stream util . get line separator ( ) + str + database . get connection ( ) . get url ( ) + stream util . get line separator ( ) + str + database . get connection ( ) . get connection user name ( ) + stream util . get line separator ( ) + stream util . get line separator ( ) + str , str , j . yes no option , j . warning message ) == j . no option ; }	Displays swing-based dialog about running against a non-localhost database.Returns true if the user selected that they are OK with that.
protected string get connection schema name ( ) { if ( connection == null ) { return null ; } if ( connection instanceof offline connection ) { return ( ( offline connection ) connection ) . get schema ( ) ; } try { sql statement current schema statement = get connection schema name call statement ( ) ; return executor service . get instance ( ) . get executor ( this ) . query for object ( current schema statement , string . class ) ; } catch ( exception e ) { scope . get current scope ( ) . get log ( get class ( ) ) . info ( log type . log , str , e ) ; } return null ; }	Overwrite this method to get the default schema name for the connection.If you only need to change the statement that obtains the current schema then override.
@ override public boolean is safe to run update ( ) throws database exception { database connection connection = get connection ( ) ; if ( connection == null ) { return bool ; } string url = connection . get url ( ) ; if ( url == null ) { return bool ; } return ( url . contains ( str ) ) || ( url . contains ( str ) ) ; }	Default implementation, just look for "local" IPs.
protected list < sql visitor > filter rollback visitors ( final list < sql visitor > visitors ) { final list < sql visitor > rollback visitors = new array list < > ( ) ; if ( visitors != null ) { for ( sql visitor visitor : visitors ) { if ( visitor . is apply to rollback ( ) ) { rollback visitors . add ( visitor ) ; } } } return rollback visitors ; }	Takes a list of SqlVisitors and returns a new list with only the SqlVisitors set to apply to rollbacks.
@ override public int get max fractional digits for timestamp ( ) { if ( get connection ( ) == null ) {	Most relational databases support 9 fractional digits, and subclasses must overwrite this method if theysupport less than that.
protected string check string ( string text ) throws unexpected liquibase exception { if ( null == text || text . is empty ( ) ) { return text ; } final int len = text . length ( ) ; char current ; int code point ; for ( int i = num ; i < len ; i ++ ) { current = text . char at ( i ) ; if ( character . is high surrogate ( current ) && i + num < len && character . is low surrogate ( text . char at ( i + num ) ) ) { code point = text . code point at ( i ++ ) ; } else { code point = current ; } if ( ( code point == str ) || ( code point == str ) || ( code point == str ) || ( code point == num ) || ( code point == num ) || ( ( code point >= num ) && ( code point <= num ) ) || ( ( code point >= num ) && ( code point <= num ) ) || ( ( code point >= num ) && ( code point <= num ) ) || ( ( code point >= num ) && ( code point <= num ) ) ) {	Catch any characters that will cause problems when parsing the XML down the road.
public element create node ( string node namespace , string node name , string node content ) { element element = current change log file dom . create element ns ( node namespace , node name ) ; element . set text content ( node content ) ; return element ; }	create a XML node with nodeName and simple text content.
public static void not null ( object object , string fail message ) throws unexpected liquibase exception { if ( object == null ) { fail ( fail message ) ; } }	Throws exception if passed object is null.
boolean is sybase product name ( string db product name ) { return product name . equals ( db product name ) || str . equals ( db product name ) || str . equals ( db product name ) || str . equals ( db product name ) ; }	package private to facilitate testing.
public sql visitor create ( string tag name ) { class < ? > a class = tag to class map . get ( tag name ) ; if ( a class == null ) { return null ; } try { return ( sql visitor ) a class . get constructor ( ) . new instance ( ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Create a new Change subclass based on the given tag name.
public static string get local host address ( ) throws unknown host exception , socket exception { try { return get local host ( ) . get host address ( ) ; } catch ( exception e ) { scope . get current scope ( ) . get log ( net util . class ) . fine ( log type . log , str , e ) ; return str ; } }	Returns Local Host IP Address.
public static string get local host name ( ) throws unknown host exception , socket exception { try { return get local host ( ) . get host name ( ) ; } catch ( exception e ) { scope . get current scope ( ) . get log ( net util . class ) . fine ( log type . log , str , e ) ; return str ; } }	Returns Local Host Name.
public static void surround with schema sets ( list < sql > sql , string schema name , database database ) { if ( ( string util . trim to null ( schema name ) != null ) && ! liquibase configuration . get instance ( ) . get property ( change log parser cofiguration . class , change log parser cofiguration . use procedure schema ) . get value ( boolean . class ) ) { string default schema = database . get default schema name ( ) ; if ( database instanceof oracle database ) { sql . add ( num , new unparsed sql ( str + database . escape object name ( schema name , schema . class ) ) ) ; sql . add ( new unparsed sql ( str + database . escape object name ( default schema , schema . class ) ) ) ; } else if ( database instanceof abstract db2 database ) { sql . add ( num , new unparsed sql ( str + schema name ) ) ; sql . add ( new unparsed sql ( str + default schema ) ) ; } } }	Convenience method for when the schemaName is set but we don't want to parse the body.
private static char [ ] encode hex ( byte [ ] data ) { int l = data . length ; char [ ] out = new char [ l << num ] ;	Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.The returned array will be double the length of the passed array, as it takes two characters to represent anygiven byte.
protected string [ ] get database schema names ( database database ) throws sql , database exception { list < string > return list = new array list < > ( ) ; result set schemas = null ; try { schemas = ( ( jdbc connection ) database . get connection ( ) ) . get meta data ( ) . get schemas ( ) ; while ( schemas . next ( ) ) { return list . add ( jdbc utils . get value for column ( schemas , str , database ) ) ; } } finally { if ( schemas != null ) { schemas . close ( ) ; } } return return list . to array ( new string [ return list . size ( ) ] ) ; }	Fetches an array of Strings with the schema names in the database.
public string [ ] read next ( ) throws io { string [ ] result = null ; do { string next line = get next line ( ) ; if ( ! has next ) { return validate result ( result ) ; } string [ ] r = parser . parse line multi ( next line ) ; if ( r . length > num ) { if ( result == null ) { result = r ; } else { result = combine results from multiple reads ( result , r ) ; } } } while ( parser . is pending ( ) ) ; return validate result ( result ) ; }	Reads the next line from the buffer and converts to a string array.
protected string get next line ( ) throws io { if ( is closed ( ) ) { has next = bool ; return null ; } if ( ! this . lines skiped ) { for ( int i = num ; i < skip lines ; i ++ ) { line reader . read line ( ) ; lines read ++ ; } this . lines skiped = bool ; } string next line = line reader . read line ( ) ; if ( next line == null ) { has next = bool ; } else { lines read ++ ; } return has next ? next line : null ; }	Reads the next line from the file.
private boolean is closed ( ) { if ( ! verify reader ) { return bool ; } try { br . mark ( read ahead limit ) ; int next byte = br . read ( ) ; br . reset ( ) ;	Checks to see if the file is closed.
public synchronized void start polling ( polled configuration source source , abstract polling scheduler scheduler ) { this . scheduler = scheduler ; this . source = source ; init ( source , scheduler ) ; scheduler . start polling ( source , this ) ; }	Start polling the configuration source with the specified scheduler.
public void start ( ) throws exception {	Adds a listener to the pathChildrenCache, initializes the cache, then starts the cache-management background thread.
public static void set app conf folder ( file app conf folder from config , string base config file name ) { web application properties . app conf folder = app conf folder from config ; web application properties . base config file name = base config file name ; }	The folder where the application's properties files are located.
public dynamic int property get int property ( string prop name , int default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic int property property = new dynamic int property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }	Create a new property whose value is an integer and subject to change on-the-fly.
public dynamic long property get long property ( string prop name , long default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic long property property = new dynamic long property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }	Create a new property whose value is a long and subject to change on-the-fly.
public dynamic boolean property get boolean property ( string prop name , boolean default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic boolean property property = new dynamic boolean property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }	Create a new property whose value is a boolean and subject to change on-the-fly.
public dynamic float property get float property ( string prop name , float default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic float property property = new dynamic float property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }	Create a new property whose value is a float and subject to change on-the-fly.
public dynamic double property get double property ( string prop name , double default value , final runnable property change callback ) { check and warn ( prop name ) ; dynamic double property property = new dynamic double property ( prop name , default value ) ; add callback ( property change callback , property ) ; return property ; }	Create a new property whose value is a double and subject to change on-the-fly.
@ override protected map < string , property with deployment context > load properties from table ( string table ) { map < string , property with deployment context > property map = new hash map < string , property with deployment context > ( ) ; map < string , attribute value > last keys evaluated = null ; do { scan request scan request = new scan request ( ) . with table name ( table ) . with exclusive start key ( last keys evaluated ) ; scan result result = db scan with throughput back off ( scan request ) ; for ( map < string , attribute value > item : result . get items ( ) ) { string key val = item . get ( key attribute name . get ( ) ) . get s ( ) ;	Scan the table in dynamo and create a map with the results.
public static dynamic property get instance ( string prop name ) {	Gets the DynamicProperty for a given property name.This may be a previously constructed object,or an object constructed on-demand to satisfy the request.
private static boolean update all properties ( ) { boolean changed = bool ; for ( dynamic property prop : all props . values ( ) ) { if ( prop . update value ( ) ) { prop . notify callbacks ( ) ; changed = bool ; } } return changed ; }	return true iff _some_ value actually changed.
@ override public void add callback ( runnable callback ) { if ( callback != null ) { prop . add callback ( callback ) ; callbacks . add ( callback ) ; } }	Add the callback to be triggered when the value of the property is changed.
@ override public void remove all callbacks ( ) { final set < runnable > callbacks to remove = new hash set < runnable > ( callbacks ) ; for ( runnable callback : callbacks to remove ) { prop . remove callback ( callback ) ; } callbacks . remove all ( callbacks to remove ) ; }	Remove all callbacks registered through this instance of property.
public static http verb uri regex property value get verb uri regex ( string prop value ) { http verb uri regex property value return value = null ; if ( prop value != null ) { prop value = prop value . trim ( ) ; int method separator index = prop value . index of ( method separator ) ; string uri regex = prop value ;	Expects property value to be of the form &lt;uriRegex&gt; OR &lt;HTTPVerb name&gt;&lt;space&gt;&lt;uriRegex&gt;.
public static properties load properties from input stream ( input stream fin ) throws io { properties props = new properties ( ) ; input stream reader reader = new input stream reader ( fin , str ) ; try { props . load ( reader ) ; return props ; } finally { if ( reader != null ) { reader . close ( ) ; } if ( fin != null ) { fin . close ( ) ; } } }	Load properties from InputStream with utf-8 encoding, and it will take care of closing the input stream.
@ override public void add property ( string name , object value ) { if ( contains key ( name ) ) {	Need to override this method for PDCLOUD-1809.
void add or change property ( final string name , final object new value , final configuration config ) {	Add or update the property in the underlying config depending on if it exists.
void delete property ( final string key , final configuration config ) { if ( config . contains key ( key ) ) { logger . debug ( str + key + str ) ; config . clear property ( key ) ; } }	Delete a property in the underlying config.
@ override public void clear ( ) { fire event ( event clear , null , null , bool ) ; map . clear ( ) ; fire event ( event clear , null , null , bool ) ; }	Clear the map and fire corresonding events.
public properties get properties ( ) { properties p = new properties ( ) ; for ( iterator i = get keys ( ) ; i . has next ( ) ; ) { string name = ( string ) i . next ( ) ; string value = get string ( name ) ; p . put ( name , value ) ; } return p ; }	Utility method to get a Properties object from this Configuration.
protected synchronized void initial load ( final polled configuration source source , final configuration config ) { poll result result = null ; try { result = source . poll ( bool , null ) ; check point = result . get check point ( ) ; fire event ( event type . poll success , result , null ) ; } catch ( throwable e ) { throw new runtime exception ( str + source , e ) ; } try { populate properties ( result , config ) ; } catch ( throwable e ) { throw new runtime exception ( str , e ) ; } }	Do an initial poll from the source and apply the result to the configuration.
public void add configuration at index ( abstract configuration config , string name , int index ) throws index out of bounds exception { if ( ! config list . contains ( config ) ) { check index ( index ) ; config list . add ( index , config ) ; if ( name != null ) { named configurations . put ( name , config ) ; } config . add configuration listener ( event propagater ) ; fire event ( event configuration source changed , null , null , bool ) ; } else { logger . warn ( config + str ) ; } }	Add a configuration with a name at a particular index.
public boolean remove configuration ( configuration config ) {	Remove a configuration. The container configuration cannot be removed.
public configuration remove configuration ( string name ) { configuration conf = get configuration ( name ) ; if ( conf != null && ! conf . equals ( container configuration ) ) { config list . remove ( conf ) ; named configurations . remove ( name ) ; } else if ( conf != null && conf . equals ( container configuration ) ) { throw new illegal argument exception ( str ) ; } return conf ; }	Removes the configuration with the specified name.
public iterator < string > get keys ( ) throws concurrent modification exception { set < string > keys = new linked hash set < string > ( ) ; for ( iterator < string > it = override properties . get keys ( ) ; it . has next ( ) ; ) { keys . add ( it . next ( ) ) ; } for ( configuration config : config list ) { for ( iterator < string > it = config . get keys ( ) ; it . has next ( ) ; ) { try { keys . add ( it . next ( ) ) ; } catch ( concurrent modification exception e ) { logger . error ( str + config + str + get name for configuration ( config ) ) ; throw e ; } } } return keys . iterator ( ) ; }	Get all the keys contained by sub configurations.
@ override public iterator < string > get keys ( string prefix ) { set < string > keys = new linked hash set < string > ( ) ; for ( iterator < string > it = override properties . get keys ( prefix ) ; it . has next ( ) ; ) { keys . add ( it . next ( ) ) ; } for ( configuration config : config list ) { for ( iterator < string > it = config . get keys ( prefix ) ; it . has next ( ) ; ) { keys . add ( it . next ( ) ) ; } } return keys . iterator ( ) ; }	Get the list of the keys contained in the sub configurations that match thespecified prefix.
@ override public boolean contains key ( string key ) { if ( override properties . contains key ( key ) ) { return bool ; } for ( configuration config : config list ) { if ( config . contains key ( key ) ) { return bool ; } } return bool ; }	Check if the any of the sub configurations contains the specified key.
@ override public list get list ( string key , list default value ) { list < object > list = new array list < object > ( ) ;	Get a List of objects associated with the given configuration key.If the key doesn't map to an existing object, the default valueis returned.
@ override public string [ ] get string array ( string key ) { list < object > list = get list ( key ) ;	Get an array of strings associated with the given configuration key.If the key doesn't map to an existing object an empty array is returned.
public static void load cascaded properties from resources ( string config name ) throws io { properties props = load cascaded properties ( config name ) ; if ( instance instanceof aggregated configuration ) { concurrent map configuration config = new concurrent map configuration ( ) ; config . load properties ( props ) ; ( ( aggregated configuration ) instance ) . add configuration ( config , config name ) ; } else { configuration utils . load properties ( props , instance ) ; } }	Load resource configName.properties first.
public static void load properties from configuration ( abstract configuration config ) { if ( instance == null ) { instance = get config instance ( ) ; } if ( instance instanceof aggregated configuration ) { ( ( aggregated configuration ) instance ) . add configuration ( config ) ; } else { properties props = configuration utils . get properties ( config ) ; configuration utils . load properties ( props , instance ) ; } }	Load properties from the specified configuration into system wide configuration.
public static void load properties ( properties properties ) { if ( instance == null ) { instance = get config instance ( ) ; } configuration utils . load properties ( properties , instance ) ; }	Load the specified properties into system wide configuration.
@ override public poll result poll ( boolean initial , object check point ) throws io { if ( config urls == null || config urls . length == num ) { return poll result . create full ( null ) ; } map < string , object > map = new hash map < string , object > ( ) ; for ( url url : config urls ) { input stream fin = url . open stream ( ) ; properties props = configuration utils . load properties from input stream ( fin ) ; for ( entry < object , object > entry : props . entry set ( ) ) { map . put ( ( string ) entry . get key ( ) , entry . get value ( ) ) ; } } return poll result . create full ( map ) ; }	Retrieve the content of the property files.
public double get angle ( location location ) {	The angle relative to the direction EAST.
@ override public v compute if absent ( k key , function < ? super k , ? extends v > mapping function ) {	An overridden implementation that heavily favors read access over write access speed.This is thread-safe.{.
public static void main ( string [ ] args ) { cloud balancing generator generator = new cloud balancing generator ( ) ; generator . write cloud balance ( num , num ) ; generator . write cloud balance ( num , num ) ; generator . write cloud balance ( num , num ) ;	in gigabyte per hour.
public static string get getter property name ( member member ) { if ( member instanceof field ) { return member . get name ( ) ; } else if ( member instanceof method ) { string method name = member . get name ( ) ; for ( string prefix : property accessor prefixes ) { if ( method name . starts with ( prefix ) ) { return decapitalize property name ( method name . substring ( prefix . length ( ) ) ) ; } } } return null ; }	Returns the JavaBeans property name of the given member.
public static boolean is getter method ( method method ) { if ( method . get parameter types ( ) . length != num ) { return bool ; } string method name = method . get name ( ) ; if ( method name . starts with ( property accessor prefix get ) && method . get return type ( ) != void . class ) { return bool ; } else if ( method name . starts with ( property accessor prefix is ) && method . get return type ( ) == boolean . class ) { return bool ; } return bool ; }	Checks whether the given method is a valid getter method according to the JavaBeans standard.
public void add hard constraint match ( rule context kcontext , big decimal hard weight ) { hard score = hard score . add ( hard weight ) ; register constraint match ( kcontext , ( ) -> hard score = hard score . subtract ( hard weight ) , ( ) -> hard medium soft big decimal score . of ( hard weight , big decimal . zero , big decimal . zero ) ) ; }	Add a hard constraint of specified weighting.This is typically used in Drools scoring to add a hard constraint match (negative value to indicate an infeasiblesolution).
public void add medium constraint match ( rule context kcontext , big decimal medium weight ) { medium score = medium score . add ( medium weight ) ; register constraint match ( kcontext , ( ) -> medium score = medium score . subtract ( medium weight ) , ( ) -> hard medium soft big decimal score . of ( big decimal . zero , medium weight , big decimal . zero ) ) ; }	Add a medium level constraint of specified weighting.This is typically used in Drools scoring to add a medium priority constraint match.
public void add soft constraint match ( rule context kcontext , big decimal soft weight ) { soft score = soft score . add ( soft weight ) ; register constraint match ( kcontext , ( ) -> soft score = soft score . subtract ( soft weight ) , ( ) -> hard medium soft big decimal score . of ( big decimal . zero , big decimal . zero , soft weight ) ) ; }	Add a soft constraint match of specified weighting.This is typically used in Drools scoring to add a low priority constraint match.
public static string clean path ( final url url ) { string path = url . get path ( ) ; try { path = url . decode ( path , str ) ; } catch ( unsupported encoding exception e ) { } if ( path . starts with ( str ) ) { path = path . substring ( str . length ( ) ) ; } if ( path . starts with ( str ) ) { path = path . substring ( str . length ( ) ) ; } if ( path . ends with ( str ) ) { path = path . substring ( num , path . last index of ( str ) ) + str ; } return path ; }	Cleans the URL.
public void check if problem facts exist ( ) { if ( problem fact collection member accessor map . is empty ( ) && problem fact member accessor map . is empty ( ) ) { throw new illegal state exception ( str + solution class + str + problem fact collection property . class . get simple name ( ) + str + problem fact property . class . get simple name ( ) + str + str ) ; } }	Only called if Drools score calculation is used.
public long get problem scale ( solution solution ) { long problem scale = num ; for ( iterator < object > it = extract all entities iterator ( solution ) ; it . has next ( ) ; ) { object entity = it . next ( ) ; entity descriptor < solution > entity descriptor = find entity descriptor or fail ( entity . get class ( ) ) ; problem scale += entity descriptor . get problem scale ( solution , entity ) ; } return problem scale ; }	Calculates an indication on how big this problem instance is.This is intentionally very loosely defined for now.
static string generate task name ( final request < ? > request ) { return request . get base uri template ( ) + str + operation name generator . generate ( request . get method ( ) , request . get method name ( ) ) ; }	Generates a task name for the request.
private boolean has request context timeout ( request context request context ) { object request timeout = request context . get local attr ( r2 constants . request timeout ) ; return ( request timeout instanceof number ) && ( ( ( number ) request timeout ) . int value ( ) > num ) ; }	Check whether per-request timeout is specified in the given request context.
private boolean need apply task timeout ( request context request context , config value < long > timeout ) {	check whether we need to apply timeout to a rest.li request task.
private < t > task < response < t > > create task with timeout ( final string name , final request < t > request , final request context request context , request config config ) { config value < long > timeout = config . get timeout ms ( ) ; task < response < t > > request task ; if ( request group . is batchable ( request , config ) ) { request task = create batchable task ( name , request , request context , config ) ; } else { request task = task . async ( name , ( ) -> send request ( request , request context ) ) ; } if ( ! need apply task timeout ( request context , timeout ) ) { return request task ; } else { return with timeout ( request task , timeout ) ; } }	Apply timeout to a ParSeq rest.li request task through parseq timer task.
public task < http response > build ( final string hash , final input stream body ) throws io { if ( hash == null ) {	Return task that has general HTTP status and body information based on the build task's result.
private task < exec . result > get build task ( final string hash , final input stream body ) { task < exec . result > existing = in flight build tasks . get ( hash ) ; if ( existing != null ) { log . info ( str + hash ) ; return existing . shareable ( ) ; } else { task < exec . result > new build task = create new build task ( hash , body ) ; existing = in flight build tasks . put if absent ( hash , new build task ) ; if ( existing != null ) { log . info ( str + hash ) ; return existing . shareable ( ) ; } else { return new build task ; } } }	Returns task that builds graph using graphviz.
private task < exec . result > create new build task ( final string hash , final input stream body ) { log . info ( str + hash ) ; final task < void > create dot file = task . action ( str , ( ) -> files . copy ( body , path to cache file ( hash , str ) , standard copy option . replace existing ) ) ;	Returns new task that builds graph using graphviz.
private string write generic failure info ( final exec . result result ) throws io { string builder sb = new string builder ( ) ; sb . append ( str ) . append ( result . get status ( ) ) . append ( str ) . append ( str ) ; files . lines ( result . get stdout ( ) ) . for each ( sb :: append ) ; sb . append ( str ) ; files . lines ( result . get stderr ( ) ) . for each ( sb :: append ) ; return sb . to string ( ) ; }	Writes error info to a String.
public static trace single ( shallow trace shallow trace ) { return single ( shallow trace , trace builder . unknown plan class , trace builder . unknown plan id ) ; }	Need to fix in the next major version release.
public task < t > batchable ( final string desc , final k key ) { task < t > batchable task = task . async ( desc , ctx -> { final batch promise < t > result = new batch promise < > ( ) ; final long plan id = ctx . get plan id ( ) ; final group batch builder builder = batches . compute if absent ( plan id , k -> new group batch builder ( ) ) ; final g group = classify ( key ) ; batch < k , t > full batch = builder . add ( group , key , ctx . get shallow trace builder ( ) , result ) ; if ( full batch != null ) { try { ctx . run ( task for batch ( group , full batch , bool ) ) ; } catch ( throwable t ) {	This method returns Task that returns value for a single key allowing this strategy to batch operations.
public string get batch name ( g group , batch < k , t > batch ) { return str + batch . key size ( ) + str + batch . batch size ( ) + str ; }	Overriding this method allows providing custom name for a batch.
public synchronized < t > t harvest ( function < histogram , t > consumer ) { initialize recorder ( ) ; recycle = recorder . get interval histogram ( recycle ) ; return consumer . apply ( recycle ) ; }	Allows consuming histogram and returning a result.Histogram passed to the consumer includes stable, consistent viewof all values accumulated since last harvest.This method is thread safe.
private static par seq restli client config create default config ( ) { par seq restli client config builder builder = new par seq restli client config builder ( ) ; builder . add timeout ms ( str , default timeout ) ; builder . add batching enabled ( str , default batching enabled ) ; builder . add max batch size ( str , default max batch size ) ; return builder . build ( ) ; }	Default configuration map must specify default values for all properties.
private < r > consumer3 < fusion trace context , promise < s > , settable < t > > compose ( final consumer3 < fusion trace context , promise < s > , settable < r > > predecessor , final consumer3 < fusion trace context , promise < r > , settable < t > > propagator ) { return ( trace context , src , dst ) -> { trace context . create surrogate ( ) ; predecessor . accept ( trace context , src , new settable < r > ( ) { @ override public void done ( r value ) throws promise resolved exception { try { get effective shallow trace builder ( trace context ) . set start nanos ( system . nano time ( ) ) ; propagator . accept ( trace context , promises . value ( value ) , dst ) ; } catch ( exception e ) { logger . error ( str , e ) ; } } @ override public void fail ( throwable error ) throws promise resolved exception { try { get effective shallow trace builder ( trace context ) . set start nanos ( system . nano time ( ) ) ; propagator . accept ( trace context , promises . error ( error ) , dst ) ; } catch ( exception e ) { logger . error ( str , e ) ; } } } ) ; } ; }	Composes transformation with the transformation of the predecessor.
public static < s , t > fusion task < ? , t > create ( final string name , final task < s > task , final promise propagator < s , t > propagator ) { return new fusion task < s , t > ( name , task , propagator ) ; }	Create new FusionTask with an async predecessor.
public engine builder set engine property ( string key , object value ) { properties . put ( key , value ) ; return this ; }	Sets an engine related property on the engine.That property can then be accessed by tasks via the Context.
@ suppress warnings ( str ) public static < t > promise < t > value ( final t value ) { if ( value == null ) { if ( void == null ) { return new resolved value < t > ( value ) ; } else { return ( promise < t > ) void ; } } return new resolved value < t > ( value ) ; }	Creates a new promise that is already resolved with the given value.
public static < t > void propagate result ( final promise < t > source , final settable < t > dest ) { source . add listener ( new transforming promise listener < t , t > ( dest , promise transformer . identity ( ) ) ) ; }	Copies the value or error from the source promise to the destinationpromise.
task < string > create resilient summary ( int id ) { return fetch person ( id ) . map ( this :: short summary ) . recover ( e -> str + id ) ; }	handles failures delivering degraded experience.
task < string > create responsive summary ( int id ) { return fetch person ( id ) . with timeout ( num , time unit . milliseconds ) . map ( this :: short summary ) . recover ( e -> str + id ) ; }	handles failures delivering degraded experience in timely fashion.
task < list < string > > create connections summaries ( int id ) { return fetch person ( id ) . flat map ( str , person -> create connections summaries ( person . get connections ( ) ) ) ; }	create list of summaries, one per each connection.
public static string find node with next lowest sn ( list < string > children , string node ) { list < string > sorted children = children . stream ( ) . sorted ( ( string o1 , string o2 ) -> long . compare ( get sequence number ( o1 ) , get sequence number ( o2 ) ) ) . collect ( collectors . to list ( ) ) ; int index = sorted children . index of ( node ) ; if ( index > num ) { return sorted children . get ( index - num ) ; } else if ( index == num ) { return node ; } else { return null ; } }	Finds node with next lowest sequence number than the given node withinthe given list of nodes.
private void append task stack trace ( final throwable error ) { stack trace element [ ] task stack trace = task stack trace holder != null ? task stack trace holder . get stack trace ( ) : null ;	Concatenate stack traces if kept the original stack trace from the task creation.
private void monitor ( ) { last monitoring step = clock . nano time ( ) ; next allowed logging = last monitoring step ; while ( ! stopped ) { try { clock . sleep nano ( check interval nano ) ; } catch ( interrupted exception e ) { break ; } monitor step ( ) ; } }	Main loop of monitoring thread.
private void check for stall ( long current time ) { long delta = current time - last monitoring step ; if ( delta < shortest observed delta ) { shortest observed delta = delta ; } long stall = math . max ( num , delta - shortest observed delta ) ; if ( stall > min stall nano ) { stalls . put ( last monitoring step , stall ) ; if ( stalls . size ( ) > stalls history size ) { stalls . poll first entry ( ) ; } } }	Check how much we missed scheduled wake up and if it is larger than _minStallNanothen consider it a stall and remember it.
public static < u > task < u > with retry policy ( string name , retry policy policy , function1 < integer , task < u > > task function ) { retriable task < u > retriable task = new retriable task < > ( name , policy , task function ) ; task < u > retry task wrapper = task . async ( name + str , retriable task :: run ) ; retry task wrapper . get shallow trace builder ( ) . set task type ( task type . with retry . get name ( ) ) ; return retry task wrapper ; }	A helper for creating task wrapper with associated retry policy.
private task < t > wrap ( int attempt ) { task < t > retry task = task . async ( policy . get name ( ) + str + attempt , context -> { final settable promise < t > result = promises . settable ( ) ; task < t > task = task function . apply ( attempt ) ; final task < t > recovery = task . async ( name + str , recovery context -> { final settable promise < t > recovery result = promises . settable ( ) ; if ( task . is failed ( ) ) {	Create a wrapped task with associated recovery task that will retry if necessary.
private void retry ( int attempt , throwable error , error classification error classification , context recovery context , settable promise < t > recovery result ) { long backoff time = policy . get backoff policy ( ) . next backoff ( attempt , error ) ; if ( error classification == error classification . unrecoverable ) {	Invoke event monitors and schedule a retry if policy allows.
private promise < ? extends t > run ( context context ) { started at = system . current time millis ( ) ; task < t > task = wrap ( num ) ; context . run ( task ) ; return task ; }	Starts a retriable task.
private static exception fail coercion ( final object object , final class < ? > target type ) { return new exception ( str + target type . get simple name ( ) + str + object . get class ( ) . get name ( ) + str + object . to string ( ) ) ; }	Generates a consistent exception that can be used if coercion fails.
@ deprecated public par seq restli client builder set rest client ( rest client client ) { argument util . require not null ( client , str ) ; client = client ; return this ; }	Sets the underlying Rest.li client implementation.
private task < string > acquire ( long deadline ) { final string uuid = uuid . random uuid ( ) . to string ( ) ; return safe create lock node ( uuid , deadline , bool ) . on failure ( e -> zk client . delete node has uuid ( lock path , uuid ) ) . flat map ( lock node -> try acquire ( lock node , deadline ) . with timeout ( deadline - system . current time millis ( ) , time unit . milliseconds ) . on failure ( e -> zk client . delete node ( lock node ) ) ) ; }	Try to acquire the lock within the given deadline.
private task < void > release ( ) { return plan local . get ( get plan local key ( ) , lock internal . class ) . flat map ( lock internal -> {	Try to release the lock.
private boolean try acquire permit ( string plan class ) { return concurrent plans . try acquire ( ) && ( plan based rate limiter == null || plan based rate limiter . try acquire ( plan class ) ) ; }	rate limiter and then from plan class level rate limit if specified.
public static synchronized async http client get ning client ( ) { if ( client . get ( ) == null ) { initialize ( new async http client config . builder ( ) . build ( ) ) ; } return client . get ( ) ; }	Returns raw http client.
@ suppress warnings ( str ) public static synchronized void initialize ( async http client config cfg ) { if ( ! client . compare and set ( null , new async http client ( cfg ) ) ) { throw new runtime exception ( str ) ; } }	Initializes HttpClient with custom configuration.
public string consume to any ( final char ... chars ) { buffer up ( ) ; final int start = buf pos ; final int remaining = buf length ; final char [ ] val = char buf ; outer : while ( buf pos < remaining ) { for ( char c : chars ) { if ( val [ buf pos ] == c ) break outer ; } buf pos ++ ; } return buf pos > start ? cache string ( char buf , string cache , start , buf pos - start ) : str ; }	Read characters until the first of any delimiters is found.
public static void no null elements ( object [ ] objects , string msg ) { for ( object obj : objects ) if ( obj == null ) throw new illegal argument exception ( msg ) ; }	Validates that the array contains no null elements.
public static void not empty ( string string , string msg ) { if ( string == null || string . length ( ) == num ) throw new illegal argument exception ( msg ) ; }	Validates that the string is not empty.
static matrix parse transform ( string s ) {	delims are whitespace or ,'s.
public db get file list ( final db query , final db sort ) { return files collection . find ( query ) . sort ( sort ) ; }	Gets a sorted, filtered list of files stored in this gridfs.
public list < fsdb > find ( final string filename , final db sort ) { return find ( new db ( str , filename ) , sort ) ; }	Finds a list of files matching the given filename.
public list < fsdb > find ( final db query , final db sort ) { list < fsdb > files = new array list < fsdb > ( ) ; db cursor = files collection . find ( query ) ; if ( sort != null ) { cursor . sort ( sort ) ; } try { while ( cursor . has next ( ) ) { files . add ( inject grid fs ( cursor . next ( ) ) ) ; } } finally { cursor . close ( ) ; } return collections . unmodifiable list ( files ) ; }	Finds a list of files matching the given query.
public void remove ( final object id id ) { if ( id == null ) { throw new illegal argument exception ( str ) ; } files collection . remove ( new db ( str , id ) ) ; chunks collection . remove ( new db ( str , id ) ) ; }	Removes the file matching the given id.
public void remove ( final db query ) { if ( query == null ) { throw new illegal argument exception ( str ) ; } for ( final fsdb f : find ( query ) ) { f . remove ( ) ; } }	Removes all files matching the given query.
@ override public object put ( final string key , final object v ) { return put ( get int ( key ) , v ) ; }	Puts a value at an index.
public object get ( final string key ) { int i = get int ( key ) ; if ( i < num ) { return null ; } if ( i >= size ( ) ) { return null ; } return get ( i ) ; }	Gets a value at an index.
public static < t > builder < t > builder ( final class < t > type ) { return new builder < t > ( not null ( str , type ) ) ; }	Creates a new builder for ClassTypeData.
public long get max time ( final time unit time unit ) { not null ( str , time unit ) ; return time unit . convert ( max time ms , time unit . milliseconds ) ; }	Gets the maximum execution time on the server for this operation.
public < t > mongo compressor with property ( final string key , final t value ) { return new mongo compressor ( this , key , value ) ; }	Creates a new compressor from this compressor with the given property added to it.
@ suppress warnings ( str ) @ nullable public string get name ( ) { list < server description > any = get cluster description ( ) . get any primary or secondary ( ) ; return any . is empty ( ) ? null : any . get ( num ) . get set name ( ) ; }	Get the name of the replica set.
@ suppress warnings ( str ) @ nullable public server address get master ( ) { list < server description > primaries = get cluster description ( ) . get primaries ( ) ; return primaries . is empty ( ) ? null : primaries . get ( num ) . get address ( ) ; }	Gets the ServerAddress of the master server in this replica set.
public boolean is master ( final server address server address ) { server address master server address = get master ( ) ; return master server address != null && master server address . equals ( server address ) ; }	Checks to see if a given server is the primary server in this replica set.
@ suppress warnings ( str ) public int get max bson object size ( ) { list < server description > primaries = get cluster description ( ) . get primaries ( ) ; return primaries . is empty ( ) ? server description . get default max document size ( ) : primaries . get ( num ) . get max document size ( ) ; }	Gets the maximum size for a BSON object supported by the current master server.
public query builder put ( final string key ) { current key = key ; if ( query . get ( key ) == null ) { query . put ( current key , new null object ( ) ) ; } return this ; }	Adds a new key to the query if not present yet.
private void apply majority write concern to transaction options ( ) { if ( transaction options != null ) { write concern write concern = transaction options . get write concern ( ) ; if ( write concern != null ) { transaction options = transaction options . merge ( transaction options . builder ( ) . write concern ( write concern . with w ( str ) ) . build ( ) , transaction options ) ; } else { transaction options = transaction options . merge ( transaction options . builder ( ) . write concern ( write concern . majority ) . build ( ) , transaction options ) ; } } else { transaction options = transaction options . builder ( ) . write concern ( write concern . majority ) . build ( ) ; } }	Apply majority write concern if the commit is to be retried.
public boolean ok ( ) { object ok value = get ( str ) ; if ( ok value instanceof boolean ) { return ( boolean ) ok value ; } else if ( ok value instanceof number ) { return ( ( number ) ok value ) . int value ( ) == num ; } else { return bool ; } }	Gets the "ok" field, which is whether this command executed correctly or not.
@ nullable public string get error message ( ) { object foo = get ( str ) ; if ( foo == null ) { return null ; } return foo . to string ( ) ; }	Gets the error message associated with a failed command.
public property model builder < t > read annotations ( final list < annotation > annotations ) { this . read annotations = unmodifiable list ( not null ( str , annotations ) ) ; return this ; }	Sets the read annotations, to be applied when serializing to BSON.
public static list < string > get index names ( final list < index model > indexes , final codec registry codec registry ) { list < string > index names = new array list < string > ( indexes . size ( ) ) ; for ( index model index : indexes ) { string name = index . get options ( ) . get name ( ) ; if ( name != null ) { index names . add ( name ) ; } else { index names . add ( index helper . generate index name ( index . get keys ( ) . to bson document ( bson document . class , codec registry ) ) ) ; } } return index names ; }	Get a list of index names for the given list of index models.
public static string generate index name ( final bson document index ) { string builder index name = new string builder ( ) ; for ( final string key names : index . key set ( ) ) { if ( index name . length ( ) != num ) { index name . append ( str ) ; } index name . append ( key names ) . append ( str ) ; bson value asc or desc value = index . get ( key names ) ; if ( asc or desc value instanceof bson number ) { index name . append ( ( ( bson number ) asc or desc value ) . int value ( ) ) ; } else if ( asc or desc value instanceof bson string ) { index name . append ( ( ( bson string ) asc or desc value ) . get value ( ) . replace ( str , str ) ) ; } } return index name . to string ( ) ; }	Convenience method to generate an index name from the set of fields it is over.
@ deprecated public void validate ( ) { if ( fs == null ) { throw new mongo exception ( str ) ; } if ( md5 == null ) { throw new mongo exception ( str ) ; } db cmd = new db ( str , id ) ; cmd . put ( str , fs . get bucket name ( ) ) ; db res = fs . get db ( ) . command ( cmd ) ; if ( res != null && res . contains field ( str ) ) { string m = res . get ( str ) . to string ( ) ; if ( m . equals ( md5 ) ) { return ; } throw new mongo exception ( str + md5 + str + m + str ) ; }	Verifies that the MD5 matches between the database and the local file.
public codec < ? > get ( final bson type bson type ) { codec < ? > codec = codecs [ bson type . get value ( ) ] ; if ( codec == null ) { class < ? > clazz = bson type class map . get ( bson type ) ; if ( clazz == null ) { throw new codec configuration exception ( format ( str , bson type ) ) ; } else { throw new codec configuration exception ( format ( str , clazz ) ) ; } } return codec ; }	Gets the Codec mapped to the given bson type.
private int calculate batch size ( ) { integer batch size = mongo iterable . get batch size ( ) ; if ( batch size != null ) { return batch size ; } long requested = get requested ( ) ; if ( requested <= num ) { return num ; } else if ( requested < integer . max value ) { return ( int ) requested ; } else { return integer . max value ; } }	Returns the batchSize to be used with the cursor.
public static long parse ( final string string ) { if ( string . length ( ) == num ) { throw new number format exception ( str ) ; } int radix = num ; int max safe pos = max safe digits [ radix ] - num ; long value = num ; for ( int pos = num ; pos < string . length ( ) ; pos ++ ) { int digit = character . digit ( string . char at ( pos ) , radix ) ; if ( digit == - num ) { throw new number format exception ( string ) ; } if ( pos > max safe pos && overflow in parse ( value , digit , radix ) ) { throw new number format exception ( str + string ) ; } value = ( value * radix ) + digit ; } return value ; }	Equivalent to Long.parseUnsignedLong in Java 8.
public < t > t decode with child context ( final decoder < t > decoder , final bson reader reader ) { return decoder . decode ( reader , default context ) ; }	Creates a child context and then deserializes using the reader.
protected boolean check state ( final state [ ] valid states ) { for ( final state cur : valid states ) { if ( cur == get state ( ) ) { return bool ; } } return bool ; }	Checks if this writer's current state is in the list of given states.
public void pipe ( final bson reader reader , final list < bson element > extra elements ) { not null ( str , reader ) ; not null ( str , extra elements ) ; pipe document ( reader , extra elements ) ; }	Reads a single document from the given BsonReader and writes it to this, appending the given extra elements to the document.
protected void pipe extra elements ( final list < bson element > extra elements ) { not null ( str , extra elements ) ; for ( bson element cur : extra elements ) { write name ( cur . get name ( ) ) ; pipe value ( cur . get value ( ) ) ; } }	Pipe a list of extra element to this writer.
public byte [ ] to byte array ( ) { byte buffer buffer = byte buffer . allocate ( object id length ) ; put to byte buffer ( buffer ) ; return buffer . array ( ) ;	Convert to a byte array.
public void put to byte buffer ( final byte buffer buffer ) { not null ( str , buffer ) ; is true argument ( str , buffer . remaining ( ) >= object id length ) ; buffer . put ( int3 ( timestamp ) ) ; buffer . put ( int2 ( timestamp ) ) ; buffer . put ( int1 ( timestamp ) ) ; buffer . put ( int0 ( timestamp ) ) ; buffer . put ( int2 ( random value1 ) ) ; buffer . put ( int1 ( random value1 ) ) ; buffer . put ( int0 ( random value1 ) ) ; buffer . put ( short1 ( random value2 ) ) ; buffer . put ( short0 ( random value2 ) ) ; buffer . put ( int2 ( counter ) ) ; buffer . put ( int1 ( counter ) ) ; buffer . put ( int0 ( counter ) ) ; }	Convert to bytes and put those bytes to the provided ByteBuffer.Note that the numbers are stored in big-endian order.
public string to hex string ( ) { char [ ] chars = new char [ object id length * num ] ; int i = num ; for ( byte b : to byte array ( ) ) { chars [ i ++ ] = hex chars [ b > > num & num ] ; chars [ i ++ ] = hex chars [ b & num ] ; } return new string ( chars ) ; }	Converts this instance into a 24-byte hexadecimal string representation.
public string get short description ( ) { return str + str + address + str + type + ( ! tag set . iterator ( ) . has next ( ) ? str : str + tag set ) + ( state == connected ? ( str + get round trip formatted in milliseconds ( ) + str ) : str ) + str + state + ( exception == null ? str : str + translate exception to string ( ) ) + str ; }	Returns a short, pretty description for this ServerDescription.
@ suppress warnings ( str ) public static db start ( final map document as map ) { db builder = new db ( ) ; iterator < map . entry > i = document as map . entry set ( ) . iterator ( ) ; while ( i . has next ( ) ) { map . entry entry = i . next ( ) ; builder . add ( entry . get key ( ) . to string ( ) , entry . get value ( ) ) ; } return builder ; }	Creates an object builder from an existing map of key value pairs.
public db push ( final string key ) { db o = new db ( ) ; cur ( ) . put ( key , o ) ; stack . add last ( o ) ; return this ; }	Creates an new empty object and inserts it into the current object with the given key.
public void add result ( final bulk write result result , final index map index map ) { inserted count += result . get inserted count ( ) ; matched count += result . get matched count ( ) ; deleted count += result . get deleted count ( ) ; modified count += result . get modified count ( ) ; merge upserts ( result . get upserts ( ) , index map ) ; }	Add a result.
public void add error result ( final mongo bulk write exception exception , final index map index map ) { add result ( exception . get write result ( ) , index map ) ; merge write errors ( exception . get write errors ( ) , index map ) ; merge write concern error ( exception . get write concern error ( ) ) ; }	Add an error result.
public void add write error result ( final bulk write error write error , final index map index map ) { not null ( str , write error ) ; merge write errors ( as list ( write error ) , index map ) ; }	Add a write error result.
public void add error result ( final list < bulk write error > write errors , final write concern error write concern error , final index map index map ) { merge write errors ( write errors , index map ) ; merge write concern error ( write concern error ) ; }	Add a list of error results and a write concern error.
public mongo bulk write exception get error ( ) { return has errors ( ) ? new mongo bulk write exception ( create result ( ) , new array list < bulk write error > ( write errors ) , write concern errors . is empty ( ) ? null : write concern errors . get ( write concern errors . size ( ) - num ) , server address ) : null ; }	Gets the combined errors as an exception.
private node < e > next nonmarker ( ) { node < e > f = get next ( ) ; return ( f == null || ! f . is marker ( ) ) ? f : f . get next ( ) ; }	Returns next node, ignoring deletion marker.
node < e > successor ( ) { node < e > f = next nonmarker ( ) ; for ( ; ; ) { if ( f == null ) return null ; if ( ! f . is deleted ( ) ) { if ( f . get prev ( ) != this && ! is deleted ( ) ) f . set prev ( this ) ;	Returns the next non-deleted node, swinging next pointeraround any encountered deleted nodes, and also patching upsuccessor's prev link to point back to this.
node < e > predecessor ( ) { node < e > n = this ; for ( ; ; ) { node < e > b = n . get prev ( ) ; if ( b == null ) return n . find predecessor of ( this ) ; node < e > s = b . get next ( ) ; if ( s == this ) return b ; if ( s == null || ! s . is marker ( ) ) { node < e > p = b . find predecessor of ( this ) ; if ( p != null ) return p ; } n = b ; } }	Returns the previous non-deleted node, patching up pointersas needed.
node < e > forward ( ) { node < e > f = successor ( ) ; return ( f == null || f . is special ( ) ) ? null : f ; }	Returns the next node containing a nondeleted user element.Use for forward list traversal.
node < e > back ( ) { node < e > f = predecessor ( ) ; return ( f == null || f . is special ( ) ) ? null : f ; }	Returns previous node containing a nondeleted user element, ifpossible.
node < e > append ( e element ) { for ( ; ; ) { node < e > f = get next ( ) ; if ( f == null || f . is marker ( ) ) return null ; node < e > x = new node < e > ( element , f , this ) ; if ( cas next ( f , x ) ) { f . set prev ( x ) ;	Tries to insert a node holding element as successor, failingif this node is deleted.
node < e > prepend ( e element ) { for ( ; ; ) { node < e > b = predecessor ( ) ; if ( b == null ) return null ; node < e > x = new node < e > ( element , this , b ) ; if ( b . cas next ( this , x ) ) { set prev ( x ) ;	Tries to insert a node holding element as predecessor, failingif no live predecessor can be found to link to.
boolean delete ( ) { node < e > b = get prev ( ) ; node < e > f = get next ( ) ; if ( b != null && f != null && ! f . is marker ( ) && cas next ( f , new node < e > ( f ) ) ) { if ( b . cas next ( this , f ) ) f . set prev ( b ) ; return bool ; } return bool ; }	Tries to mark this node as deleted, failing if alreadydeleted or if this node is header or trailer.
node < e > replace ( e new element ) { for ( ; ; ) { node < e > b = get prev ( ) ; node < e > f = get next ( ) ; if ( b == null || f == null || f . is marker ( ) ) return null ; node < e > x = new node < e > ( new element , f , b ) ; if ( cas next ( f , new node < e > ( x ) ) ) { b . successor ( ) ;	Tries to insert a node holding element to replace this node.failing if already deleted.
@ deprecated @ override public bson document execute ( final write binding binding ) { return with connection ( binding , new callable with connection < bson document > ( ) { @ override public bson document call ( final connection connection ) { if ( server is at least version three dot two ( connection . get description ( ) ) ) { return execute command ( binding , str , fsync unlock command , connection ) ; } else { return query unlock ( connection ) ; } } } ) ; }	Unlocks the MongoDB server, allowing write operations to go through.
public final list < server description > choose ( final cluster description cluster description ) { switch ( cluster description . get type ( ) ) { case replica set : return choose for replica set ( cluster description ) ; case sharded : case standalone : return choose for non replica set ( cluster description ) ; case unknown : return collections . empty list ( ) ; default : throw new unsupported operation exception ( str + cluster description . get type ( ) ) ; } }	Chooses the servers from the given cluster than match this read preference.
public static read preference primary preferred ( final long max staleness , final time unit time unit ) { return new primary preferred read preference ( collections . < tag set > empty list ( ) , max staleness , time unit ) ; }	Gets a read preference that forces reads to the primary if available, otherwise to a secondary.
public static read preference secondary ( final long max staleness , final time unit time unit ) { return new secondary read preference ( collections . < tag set > empty list ( ) , max staleness , time unit ) ; }	Gets a read preference that forces reads to a secondary that is less stale than the given maximum.
public static read preference nearest ( final long max staleness , final time unit time unit ) { return new nearest read preference ( collections . < tag set > empty list ( ) , max staleness , time unit ) ; }	Gets a read preference that forces reads to a primary or a secondary that is less stale than the given maximum.
public static read preference value of ( final string name ) { not null ( str , name ) ; string name to check = name . to lower case ( ) ; if ( name to check . equals ( primary . get name ( ) . to lower case ( ) ) ) { return primary ; } if ( name to check . equals ( secondary . get name ( ) . to lower case ( ) ) ) { return secondary ; } if ( name to check . equals ( secondary preferred . get name ( ) . to lower case ( ) ) ) { return secondary preferred ; } if ( name to check . equals ( primary preferred . get name ( ) . to lower case ( ) ) ) { return primary preferred ; } if ( name to check . equals ( nearest . get name ( ) . to lower case ( ) ) ) { return nearest ; } throw new illegal argument exception ( str + name ) ; }	Creates a read preference from the given read preference name.
public static taggable read preference value of ( final string name , final list < tag set > tag set list ) { return value of ( name , tag set list , null , milliseconds ) ; }	Creates a taggable read preference from the given read preference name and list of tag sets.
public static void read fully ( final input stream input stream , final byte [ ] buffer , final int offset , final int length ) throws io { if ( buffer . length < length + offset ) { throw new illegal argument exception ( str ) ; } int array offset = offset ; int bytes to read = length ; while ( bytes to read > num ) { int bytes read = input stream . read ( buffer , array offset , bytes to read ) ; if ( bytes read < num ) { throw new eof ( ) ; } bytes to read -= bytes read ; array offset += bytes read ; } }	Reads bytes from the input stream and puts them into the given byte buffer.
public static int read int ( final input stream input stream , final byte [ ] buffer ) throws io { read fully ( input stream , buffer , num ) ; return read int ( buffer ) ; }	Reads and returns a single integer value from the input stream.
public static int read int ( final byte [ ] buffer , final int offset ) { int x = num ; x |= ( num & buffer [ offset + num ] ) << num ; x |= ( num & buffer [ offset + num ] ) << num ; x |= ( num & buffer [ offset + num ] ) << num ; x |= ( num & buffer [ offset + num ] ) << num ; return x ; }	Reads and returns a single integer value from the buffer.
public static int read int be ( final byte [ ] buffer , final int offset ) { int x = num ; x |= ( num & buffer [ offset + num ] ) << num ; x |= ( num & buffer [ offset + num ] ) << num ; x |= ( num & buffer [ offset + num ] ) << num ; x |= ( num & buffer [ offset + num ] ) << num ; return x ; }	Reads and returns a single big-endian integer value.
public static long read long ( final input stream input stream , final byte [ ] buffer ) throws io { read fully ( input stream , buffer , num ) ; return read long ( buffer ) ; }	Reads and returns a single long value from the input stream.
@ deprecated public list < mongo credential > get credential list ( ) { return credential != null ? singleton list ( credential ) : collections . < mongo credential > empty list ( ) ; }	Gets the credentials in an immutable list.
private clusterable server get random server ( final list < server description > server descriptions ) { while ( ! server descriptions . is empty ( ) ) { int server pos = get random ( ) . next int ( server descriptions . size ( ) ) ; clusterable server server = get server ( server descriptions . get ( server pos ) . get address ( ) ) ; if ( server != null ) { return server ; } else { server descriptions . remove ( server pos ) ; } } return null ; }	gets a random server that still exists in the cluster.
public static mongo client create ( final connection string connection string , @ nullable final mongo driver information mongo driver information ) { return create ( mongo client settings . builder ( ) . apply connection string ( connection string ) . build ( ) , mongo driver information , connection string . get stream type ( ) ) ; }	Create a new client with the given connection string.
public object copy ( ) {	Copies this instance into a new Object.
public static < s > class model builder < s > builder ( final class < s > type ) { return new class model builder < s > ( type ) ; }	Creates a new Class Model builder instance using reflection.
public db get collection ( final string name ) { db collection = collection cache . get ( name ) ; if ( collection != null ) { return collection ; } collection = new db ( name , this , executor ) ; if ( mongo . get mongo client options ( ) . get db decoder factory ( ) != db . factory ) { collection . set db ( mongo . get mongo client options ( ) . get db decoder factory ( ) ) ; } if ( mongo . get mongo client options ( ) . get db encoder factory ( ) != db . factory ) { collection . set db ( mongo . get mongo client options ( ) . get db encoder factory ( ) ) ; } db old = collection cache . put if absent ( name , collection ) ; return old != null ? old : collection ; }	Gets a collection with a given name.
public void drop database ( ) { try { get executor ( ) . execute ( new drop database operation ( get name ( ) , get write concern ( ) ) , get read concern ( ) ) ; } catch ( mongo write concern exception e ) { throw create write concern exception ( e ) ; } }	Drops this database. Removes all data on disk. Use with caution.
public set < string > get collection names ( ) { list < string > collection names = new mongo iterable impl < db > ( null , executor , read concern . default , primary ( ) , mongo . get mongo client options ( ) . get retry reads ( ) ) { @ override public read operation < batch cursor < db > > as read operation ( ) { return new list collections operation < db > ( name , command codec ) . name only ( bool ) ; } } . map ( new function < db , string > ( ) { @ override public string apply ( final db result ) { return ( string ) result . get ( str ) ; } } ) . into ( new array list < string > ( ) ) ; collections . sort ( collection names ) ; return new linked hash set < string > ( collection names ) ; }	Returns a set containing the names of all collections in this database.
public command result command ( final db command , final read preference read preference , @ nullable final db encoder ) { try { return execute command ( wrap ( command , encoder ) , get command read preference ( command , read preference ) ) ; } catch ( mongo command exception ex ) { return new command result ( ex . get response ( ) , ex . get server address ( ) ) ; } }	Executes a database command with the selected readPreference, and encodes the command using the given encoder.
public command result command ( final db command , final read preference read preference ) { return command ( command , read preference , null ) ; }	Executes the command against the database with the given read preference.
public boolean collection exists ( final string collection name ) { set < string > collection names = get collection names ( ) ; for ( final string name : collection names ) { if ( name . equals ignore case ( collection name ) ) { return bool ; } } return bool ; }	Checks to see if a collection with a given name exists on a server.
@ deprecated public command result do eval ( final string code , final object ... args ) { db command document = new db ( str , code ) . append ( str , as list ( args ) ) ; return execute command ( wrap ( command document ) ) ; }	Evaluates JavaScript functions on the database server.
@ deprecated public command result get stats ( ) { bson document command document = new bson document ( str , new bson int32 ( num ) ) . append ( str , new bson int32 ( num ) ) ; return execute command ( command document ) ; }	Helper method for calling a 'dbStats' command.
@ deprecated public write result remove user ( final string user name ) { try { executor . execute ( new com . mongodb . operation . drop user operation ( get name ( ) , user name , get write concern ( ) ) , get read concern ( ) ) ; return new write result ( num , bool , null ) ; } catch ( mongo write concern exception e ) { throw create write concern exception ( e ) ; } }	Removes the specified user from the database.
read preference get command read preference ( final db command , @ nullable final read preference requested preference ) { string com string = command . key set ( ) . iterator ( ) . next ( ) . to lower case ( ) ; boolean primary required = ! obedient commands . contains ( com string ) ; if ( primary required ) { return read preference . primary ( ) ; } else if ( requested preference == null ) { return read preference . primary ( ) ; } else { return requested preference ; } }	Determines the read preference that should be used for the given command.
public < u > codec < u > get ( final class < u > clazz ) { if ( has cycles ( clazz ) ) { return new lazy codec < u > ( registry , clazz ) ; } else { return registry . get ( new child codec registry < u > ( this , clazz ) ) ; } }	Gets a Codec, but if it detects a cyclic dependency, return a LazyCodec which breaks the chain.
public write result update ( final db query , final db update , final db options ) { not null ( str , query ) ; not null ( str , update ) ; not null ( str , options ) ; write concern write concern = options . get write concern ( ) != null ? options . get write concern ( ) : get write concern ( ) ; com . mongodb . bulk . write request . type update type = ! update . key set ( ) . is empty ( ) && update . key set ( ) . iterator ( ) . next ( ) . starts with ( str ) ? com . mongodb . bulk . write request . type . update : com . mongodb . bulk . write request . type . replace ; update request update request = new update request ( wrap ( query ) , wrap ( update , options . get encoder ( ) ) , update type ) . upsert ( options . is upsert ( ) ) . multi ( options . is multi ( ) ) . collation ( options . get collation ( ) ) . array filters ( wrap allow null ( options . get array filters ( ) , options . get encoder ( ) ) ) ; return execute write operation ( new update operation ( get namespace ( ) , bool , write concern , retry writes , singleton list ( update request ) ) . bypass document validation ( options . get bypass document validation ( ) ) ) ; }	Modify an existing document or documents in collection.
@ nullable public db find one ( final object id , final db projection ) { return find one ( new db ( str , id ) , new db ( ) . projection ( projection ) ) ; }	Get a single document from collection by '_id'.
public db rename ( final string new name , final boolean drop target ) { try { executor . execute ( new rename collection operation ( get namespace ( ) , new mongo namespace ( get namespace ( ) . get database name ( ) , new name ) , get write concern ( ) ) . drop target ( drop target ) , get read concern ( ) ) ; return get db ( ) . get collection ( new name ) ; } catch ( mongo write concern exception e ) { throw create write concern exception ( e ) ; } }	Change the name of an existing collection.
public command result explain aggregate ( final list < ? extends db > pipeline , final aggregation options options ) { aggregate operation < bson document > operation = new aggregate operation < bson document > ( get namespace ( ) , prepare pipeline ( pipeline ) , new bson document codec ( ) ) . max time ( options . get max time ( milliseconds ) , milliseconds ) . allow disk use ( options . get allow disk use ( ) ) . collation ( options . get collation ( ) ) . retry reads ( retry reads ) ; return new command result ( executor . execute ( operation . as explainable operation ( explain verbosity . query planner ) , primary preferred ( ) , get read concern ( ) ) ) ; }	Return the explain plan for the aggregation pipeline.
public void create index ( final db keys , @ nullable final string name , final boolean unique ) { db options = new db ( ) ; if ( name != null && name . length ( ) > num ) { options . put ( str , name ) ; } if ( unique ) { options . put ( str , boolean . true ) ; } create index ( keys , options ) ; }	Forces creation of an index on a set of fields, if one does not already exist.
public void create index ( final db keys , final db options ) { try { executor . execute ( create index operation ( keys , options ) , get read concern ( ) ) ; } catch ( mongo write concern exception e ) { throw create write concern exception ( e ) ; } }	Creates an index on the field specified, if that index does not already exist.
@ nullable public db find and remove ( @ nullable final db query ) { return find and modify ( query , null , null , bool , null , bool , bool ) ; }	Atomically remove and return a single document.
public synchronized void set db ( @ nullable final db factory ) { this . decoder factory = factory ;	Set a custom decoder factory for this collection.
public synchronized void set db ( @ nullable final db factory ) { this . encoder factory = factory ;	Set a custom encoder factory for this collection.
public list < db > get index info ( ) { return new mongo iterable impl < db > ( null , executor , read concern . default , primary ( ) , retry reads ) { @ override public read operation < batch cursor < db > > as read operation ( ) { return new list indexes operation < db > ( get namespace ( ) , get default db ( ) ) . retry reads ( retry reads ) ; } } . into ( new array list < db > ( ) ) ; }	Return a list of the indexes for this collection. Each object in the list is the "info document" from MongoDB.
public void drop index ( final db index ) { try { executor . execute ( new drop index operation ( get namespace ( ) , wrap ( index ) , get write concern ( ) ) , get read concern ( ) ) ; } catch ( mongo write concern exception e ) { throw create write concern exception ( e ) ; } }	Drops an index from this collection.
public void drop index ( final string index name ) { try { executor . execute ( new drop index operation ( get namespace ( ) , index name , get write concern ( ) ) , get read concern ( ) ) ; } catch ( mongo write concern exception e ) { throw create write concern exception ( e ) ; } }	Drops the index with the given name from this collection.
public boolean is capped ( ) { command result command result = get stats ( ) ; object capped field = command result . get ( str ) ; return capped field != null && ( capped field . equals ( num ) || capped field . equals ( bool ) ) ; }	Checks whether this collection is capped.
public void set internal class ( final string path , final class < ? extends db > a class ) { set object factory ( object factory . update ( a class , as list ( path . split ( str ) ) ) ) ; }	Sets the internal class for the given path in the document hierarchy.
protected class < ? extends db > get internal class ( final string path ) { return object factory . get class for path ( as list ( path . split ( str ) ) ) ; }	Gets the internal class for the given path in the document hierarchy.
public static < t > bson set ( final string field name , @ nullable final t value ) { return new simple update < t > ( field name , value , str ) ; }	Creates an update that sets the value of the field with the given name to the given value.
public static < t > bson set on insert ( final string field name , @ nullable final t value ) { return new simple update < t > ( field name , value , str ) ; }	Creates an update that sets the value of the field with the given name to the given value, but only if the update is an upsert thatresults in an insert of a document.
public static bson rename ( final string field name , final string new field name ) { not null ( str , new field name ) ; return new simple update < string > ( field name , new field name , str ) ; }	Creates an update that renames a field.
public static bson inc ( final string field name , final number number ) { not null ( str , number ) ; return new simple update < number > ( field name , number , str ) ; }	Creates an update that increments the value of the field with the given name by the given value.
public static bson mul ( final string field name , final number number ) { not null ( str , number ) ; return new simple update < number > ( field name , number , str ) ; }	Creates an update that multiplies the value of the field with the given name by the given number.
public static < t > bson min ( final string field name , final t value ) { return new simple update < t > ( field name , value , str ) ; }	Creates an update that sets the value of the field to the given value if the given value is less than the current value of thefield.
public static < t > bson max ( final string field name , final t value ) { return new simple update < t > ( field name , value , str ) ; }	Creates an update that sets the value of the field to the given value if the given value is greater than the current value of thefield.
public static < t > bson add to set ( final string field name , @ nullable final t value ) { return new simple update < t > ( field name , value , str ) ; }	Creates an update that adds the given value to the array value of the field with the given name, unless the value isalready present, in which case it does nothing.
public static < t > bson add each to set ( final string field name , final list < t > values ) { return new with each update < t > ( field name , values , str ) ; }	Creates an update that adds each of the given values to the array value of the field with the given name, unless the value isalready present, in which case it does nothing.
public static < t > bson push ( final string field name , @ nullable final t value ) { return new simple update < t > ( field name , value , str ) ; }	Creates an update that adds the given value to the array value of the field with the given name.
public static < t > bson push each ( final string field name , final list < t > values ) { return new push update < t > ( field name , values , new push options ( ) ) ; }	Creates an update that adds each of the given values to the array value of the field with the given name.
public static < t > bson pull ( final string field name , @ nullable final t value ) { return new simple update < t > ( field name , value , str ) ; }	Creates an update that removes all instances of the given value from the array value of the field with the given name.
public static bson pull by filter ( final bson filter ) { return new bson ( ) { @ override public < t > bson document to bson document ( final class < t > t document class , final codec registry codec registry ) { bson document writer writer = new bson document writer ( new bson document ( ) ) ; writer . write start document ( ) ; writer . write name ( str ) ; encode value ( writer , filter , codec registry ) ; writer . write end document ( ) ; return writer . get document ( ) ; } } ; }	Creates an update that removes from an array all elements that match the given filter.
public static < t > bson pull all ( final string field name , final list < t > values ) { return new pull all update < t > ( field name , values ) ; }	Creates an update that removes all instances of the given values from the array value of the field with the given name.
protected void write query prologue ( final bson output bson output ) { bson output . write int32 ( get cursor flag ( ) ) ; bson output . write c ( get collection name ( ) ) ; bson output . write int32 ( skip ) ; bson output . write int32 ( number to return ) ; }	Write the query prologue to the given BSON output.
private void increment generation on socket exception ( final internal connection connection , final throwable t ) { if ( t instanceof mongo socket exception && ! ( t instanceof mongo socket read timeout exception ) ) { if ( logger . is warn enabled ( ) ) { logger . warn ( format ( str , get id ( connection ) , server id . get address ( ) , server id . get address ( ) ) ) ; } invalidate ( ) ; } }	If there was a socket exception that wasn't some form of interrupted read, increment the generation count so that any connectionscreated prior will be discarded.
public static < t > list < class < ? > > get ancestry ( final class < t > clazz ) { return class ancestry . get ancestry ( clazz ) ; }	Helper method that walks superclass and interface graph, superclasses first, then interfaces, to compute an ancestry list.
@ deprecated public static replace options create replace options ( final update options update options ) { not null ( str , update options ) ; list < ? extends bson > array filters = update options . get array filters ( ) ; is true ( str , array filters == null || array filters . is empty ( ) ) ; return new replace options ( ) . bypass document validation ( update options . get bypass document validation ( ) ) . collation ( update options . get collation ( ) ) . upsert ( update options . is upsert ( ) ) ; }	Creates replace options from updateOptions.
public static byte [ ] decode ( final string s ) { int delta = s . ends with ( str ) ? num : s . ends with ( str ) ? num : num ; byte [ ] buffer = new byte [ s . length ( ) * bytes per unencoded block / bytes per encoded block - delta ] ; int mask = num ; int pos = num ; for ( int i = num ; i < s . length ( ) ; i += bytes per encoded block ) { int c0 = decode table [ s . char at ( i ) ] ; int c1 = decode table [ s . char at ( i + num ) ] ; buffer [ pos ++ ] = ( byte ) ( ( ( c0 << num ) | ( c1 > > num ) ) & mask ) ; if ( pos >= buffer . length ) { return buffer ; } int c2 = decode table [ s . char at ( i + num ) ] ; buffer [ pos ++ ] = ( byte ) ( ( ( c1 << num ) | ( c2 > > num ) ) & mask ) ; if ( pos >= buffer . length ) { return buffer ; } int c3 = decode table [ s . char at ( i + num ) ] ; buffer [ pos ++ ] = ( byte ) ( ( ( c2 << num ) | c3 ) & mask ) ; } return buffer ; }	Decodes the given Base64-encoded string.
public static string encode ( final byte [ ] in ) { int modulus = num ; int bit work area = num ; int num encoded bytes = ( in . length / bytes per unencoded block ) * bytes per encoded block + ( ( in . length % bytes per unencoded block == num ) ? num : num ) ; byte [ ] buffer = new byte [ num encoded bytes ] ; int pos = num ; for ( int b : in ) { modulus = ( modulus + num ) % bytes per unencoded block ; if ( b < num ) { b += num ; } bit work area = ( bit work area << num ) + b ;	Encodes the given byte array into a Base64-encoded string.
@ deprecated @ suppress warnings ( str ) @ nullable public server address get address ( ) { cluster description description = get cluster description ( ) ; if ( description . get primaries ( ) . is empty ( ) ) { return null ; } return description . get primaries ( ) . get ( num ) . get address ( ) ; }	Gets the address of the current master.
@ suppress warnings ( str ) @ deprecated @ nullable public replica set status get replica set status ( ) { cluster description cluster description = get cluster description ( ) ; return cluster description . get type ( ) == replica set && cluster description . get connection mode ( ) == multiple ? new replica set status ( delegate . get cluster ( ) ) : null ;	Get the status of the replica set cluster.
@ deprecated public list < string > get database names ( ) { return new mongo iterable impl < db > ( null , create operation executor ( ) , read concern . default , primary ( ) , options . get retry reads ( ) ) { @ override public read operation < batch cursor < db > > as read operation ( ) { return new list databases operation < db > ( mongo client . get command codec ( ) ) ; } } . map ( new function < db , string > ( ) { @ override public string apply ( final db result ) { return ( string ) result . get ( str ) ; } } ) . into ( new array list < string > ( ) ) ; }	Gets a list of the names of all databases on the connected server.
@ deprecated public command result fsync ( final boolean async ) { db command = new db ( str , num ) ; if ( async ) { command . put ( str , num ) ; } return get db ( admin database name ) . command ( command ) ; }	Forces the master server to fsync the RAM data to disk This is done automatically by the server at intervals, but can be forced forbetter reliability.
@ deprecated public command result fsync and lock ( ) { db command = new db ( str , num ) ; command . put ( str , num ) ; return get db ( admin database name ) . command ( command ) ; }	Forces the master server to fsync the RAM data to disk, then lock all writes.
@ deprecated public db unlock ( ) { return db . to db ( create operation executor ( ) . execute ( new fsync unlock operation ( ) , read preference , read concern ) ) ; }	Unlocks the database, allowing the write operations to go through.
public bson number as number ( ) { if ( get bson type ( ) != bson type . in && get bson type ( ) != bson type . in && get bson type ( ) != bson type . double ) { throw new bson invalid operation exception ( format ( str , get bson type ( ) ) ) ; } return ( bson number ) this ; }	Gets this value as a BsonNumber if it is one, otherwise throws exception.
public connection id with server value ( final int server value ) { is true ( str , this . server value == null ) ; return new connection id ( server id , local value , server value ) ; }	Creates a new connectionId with the set server value.
private static list < class < ? > > compute ancestry ( final class < ? > c ) { list < class < ? > > result = new array list < class < ? > > ( ) ; result . add ( object . class ) ; compute ancestry ( c , result ) ; collections . reverse ( result ) ; return unmodifiable list ( new array list < class < ? > > ( result ) ) ; }	Starting with children and going back to parents.
@ suppress warnings ( { str , str , str } ) public string to json ( ) { string writer string writer = new string writer ( ) ; json writer writer = new json writer ( string writer , new json writer settings ( ) ) ; codec codec = get registry ( ) . get ( get class ( ) ) ; codec . encode ( writer , this , encoder context . builder ( ) . build ( ) ) ; return string writer . to string ( ) ; }	Converts to GeoJSON representation.
@ override @ suppress warnings ( str ) public map reduce batch cursor < t > execute ( final read binding binding ) { return execute command ( binding , namespace . get database name ( ) , get command creator ( binding . get session context ( ) ) , command result document codec . create ( decoder , str ) , transformer ( ) , bool ) ; }	Executing this will return a cursor with your results and the statistics in.
@ nullable public long get expire after ( final time unit time unit ) { if ( expire after seconds == null ) { return null ; } return time unit . convert ( expire after seconds , time unit . seconds ) ; }	Gets the time to live for documents in the collection.
public db to db ( ) { db args = new db ( str , collection name ) . append ( str , condition ) . append ( str , reduce ) . append ( str , initial ) ; if ( keys != null ) { args . put ( str , keys ) ; } if ( keyf != null ) { args . put ( str , keyf ) ; } if ( finalize != null ) { args . put ( str , finalize ) ; } return new db ( str , args ) ; }	Turns this group command into the DBObject format of the command.
public integer get logical session timeout minutes ( ) { integer ret val = null ; for ( server description cur : get servers by predicate ( new predicate ( ) { @ override public boolean apply ( final server description server description ) { return server description . is primary ( ) || server description . is secondary ( ) ; } } ) ) { if ( cur . get logical session timeout minutes ( ) == null ) { return null ; } if ( ret val == null ) { ret val = cur . get logical session timeout minutes ( ) ; } else { ret val = math . min ( ret val , cur . get logical session timeout minutes ( ) ) ; } } return ret val ; }	Gets the logical session timeout in minutes, or null if at least one of the known servers does not support logical sessions.
@ deprecated public set < server description > get all ( ) { set < server description > server description set = new tree set < server description > ( new comparator < server description > ( ) { @ override public int compare ( final server description o1 , final server description o2 ) { int val = o1 . get address ( ) . get host ( ) . compare to ( o2 . get address ( ) . get host ( ) ) ; if ( val != num ) { return val ; } return integer compare ( o1 . get address ( ) . get port ( ) , o2 . get address ( ) . get port ( ) ) ; } private int integer compare ( final int p1 , final int p2 ) { return ( p1 < p2 ) ? - num : ( ( p1 == p2 ) ? num : num ) ; } } ) ; server description set . add all ( server descriptions ) ; return collections . unmodifiable set ( server description set ) ; }	Returns the Set of all server descriptions in this cluster, sorted by the String value of the ServerAddress of each one.
@ deprecated public server description get by server address ( final server address server address ) { for ( final server description cur : server descriptions ) { if ( cur . is ok ( ) && cur . get address ( ) . equals ( server address ) ) { return cur ; } } return null ; }	Returns the ServerDescription for the server at the given address.
@ deprecated public list < server description > get primaries ( ) { return get servers by predicate ( new predicate ( ) { public boolean apply ( final server description server description ) { return server description . is primary ( ) ; } } ) ; }	While it may seem counter-intuitive that a MongoDB cluster can have more than one primary, it can in the case where the client's viewof the cluster is a set of mongos servers, any of which can serve as the primary.
@ deprecated public list < server description > get secondaries ( ) { return get servers by predicate ( new predicate ( ) { public boolean apply ( final server description server description ) { return server description . is secondary ( ) ; } } ) ; }	Get a list of all the secondaries in this cluster.
@ deprecated public list < server description > get secondaries ( final tag set tag set ) { return get servers by predicate ( new predicate ( ) { public boolean apply ( final server description server description ) { return server description . is secondary ( ) && server description . has tags ( tag set ) ; } } ) ; }	Get a list of all the secondaries in this cluster that match a given TagSet.
@ deprecated public list < server description > get any ( ) { return get servers by predicate ( new predicate ( ) { public boolean apply ( final server description server description ) { return server description . is ok ( ) ; } } ) ; }	Gets a list of ServerDescriptions for all the servers in this cluster which are currently accessible.
@ deprecated public list < server description > get any primary or secondary ( ) { return get servers by predicate ( new predicate ( ) { public boolean apply ( final server description server description ) { return server description . is primary ( ) || server description . is secondary ( ) ; } } ) ; }	Gets a list of all the primaries and secondaries in this cluster.
@ deprecated public list < server description > get any primary or secondary ( final tag set tag set ) { return get servers by predicate ( new predicate ( ) { public boolean apply ( final server description server description ) { return ( server description . is primary ( ) || server description . is secondary ( ) ) && server description . has tags ( tag set ) ; } } ) ; }	Gets a list of all the primaries and secondaries in this cluster that match the given replica set tags.
public string get short description ( ) { string builder server descriptions = new string builder ( ) ; string delimiter = str ; for ( final server description cur : this . server descriptions ) { server descriptions . append ( delimiter ) . append ( cur . get short description ( ) ) ; delimiter = str ; } if ( srv resolution exception == null ) { return format ( str , type , server descriptions ) ; } else { return format ( str , type , srv resolution exception , server descriptions ) ; } }	Returns a short, pretty description for this ClusterDescription.
public static mongo credential create scram sha256 credential ( final string user name , final string source , final char [ ] password ) { return new mongo credential ( scram sha 256 , user name , source , password ) ; }	Creates a MongoCredential instance for the SCRAM-SHA-256 SASL mechanism.
public static mongo credential create plain credential ( final string user name , final string source , final char [ ] password ) { return new mongo credential ( plain , user name , source , password ) ; }	Creates a MongoCredential instance for the PLAIN SASL mechanism.
public < t > mongo credential with mechanism property ( final string key , final t value ) { return new mongo credential ( this , key , value ) ; }	Creates a new MongoCredential as a copy of this instance, with the specified mechanism property added.
public mongo credential with mechanism ( final authentication mechanism mechanism ) { if ( this . mechanism != null ) { throw new illegal argument exception ( str ) ; } return new mongo credential ( mechanism , user name , source , password , mechanism properties ) ; }	Creates a new MongoCredential with the set mechanism.
@ suppress warnings ( str ) @ nullable public < t > t get mechanism property ( final string key , @ nullable final t default value ) { not null ( str , key ) ; t value = ( t ) mechanism properties . get ( key . to lower case ( ) ) ; return ( value == null ) ? default value : value ; }	Get the value of the given key to a mechanism property, or defaultValue if there is no mapping.
public byte [ ] to byte array ( ) { try { byte array output stream bout = new byte array output stream ( size ( ) ) ; pipe ( bout ) ; return bout . to byte array ( ) ; } catch ( io ioe ) { throw new runtime exception ( str , ioe ) ; } }	Gets a copy of the buffered bytes.
@ suppress warnings ( str ) void add object serializer ( final class c , final object serializer serializer ) { serializers . put ( c , serializer ) ; }	Assign a ObjectSerializer to perform a type specific serialization scheme.
public update request multi ( final boolean is multi ) { if ( is multi && update type == type . replace ) { throw new illegal argument exception ( str ) ; } this . is multi = is multi ; return this ; }	Sets whether this will update all documents matching the query filter.
public void encode ( final bson output bson output , final session context session context ) { not null ( str , session context ) ; int message start position = bson output . get position ( ) ; write message prologue ( bson output ) ; encoding metadata encoding metadata = encode message body with metadata ( bson output , session context ) ; backpatch message length ( message start position , bson output ) ; this . encoding metadata = encoding metadata ; }	Encoded the message to the given output.
protected void write message prologue ( final bson output bson output ) { bson output . write int32 ( num ) ;	Writes the message prologue to the given output.
protected void add document ( final bson document document , final bson output bson output , final field name validator validator ) { add document ( document , get codec ( document ) , encoder context . builder ( ) . build ( ) , bson output , validator , settings . get max document size ( ) + document headroom , null ) ; }	Appends a document to the message.
protected void add collectible document ( final bson document document , final bson output bson output , final field name validator validator ) { add document ( document , get codec ( document ) , encoder context . builder ( ) . is encoding collectible document ( bool ) . build ( ) , bson output , validator , settings . get max document size ( ) , null ) ; }	Appends a document to the message that is intended for storage in a collection.
protected void backpatch message length ( final int start position , final bson output bson output ) { int message length = bson output . get position ( ) - start position ; bson output . write int32 ( bson output . get position ( ) - message length , message length ) ; }	Backpatches the message length into the beginning of the message.
protected db create chunk ( final object id , final int current chunk number , final byte [ ] write buffer ) { return new db ( str , id ) . append ( str , current chunk number ) . append ( str , write buffer ) ; }	Creates a new chunk of this file.
public db copy ( ) { return new db ( collection , filter , find options , executor , decoder factory , decoder , retry reads ) ; }	Creates a copy of an existing database cursor.
@ override public boolean has next ( ) { if ( closed ) { throw new illegal state exception ( str ) ; } if ( cursor == null ) { find operation < db > operation = get query operation ( decoder ) ; if ( operation . get cursor type ( ) == cursor type . tailable ) { operation . cursor type ( cursor type . tailable await ) ; } initialize cursor ( operation ) ; } boolean has next = cursor . has next ( ) ; set server cursor on finalizer ( cursor . get server cursor ( ) ) ; return has next ; }	Checks if there is another object available. Note : Automatically adds the {.
@ nullable public db try next ( ) { if ( cursor == null ) { find operation < db > operation = get query operation ( decoder ) ; if ( ! operation . get cursor type ( ) . is tailable ( ) ) { throw new illegal argument exception ( str ) ; } initialize cursor ( operation ) ; } db next = cursor . try next ( ) ; set server cursor on finalizer ( cursor . get server cursor ( ) ) ; return current object ( next ) ; }	Non blocking check for tailable cursors to see if another object is available.
public list < db > to array ( final int max ) { check iterator or array ( iterator or array . array ) ; fill array ( max - num ) ; return all ; }	Converts this cursor to an array.
@ nullable public db one ( ) { db find one cursor = copy ( ) . limit ( - num ) ; try { return find one cursor . has next ( ) ? find one cursor . next ( ) : null ; } finally { find one cursor . close ( ) ; } }	Returns the first document that matches the query.
public read preference get read preference ( ) { read preference read preference = find options . get read preference ( ) ; if ( read preference != null ) { return read preference ; } return collection . get read preference ( ) ; }	Gets the default read preference.
read concern get read concern ( ) { read concern read concern = find options . get read concern ( ) ; if ( read concern != null ) { return read concern ; } return collection . get read concern ( ) ; }	Get the read concern for this collection.
protected void put ( final string name , final object value ) { cur ( ) . put ( name , ! bson . has decode hooks ( ) ? value : bson . apply decoding hooks ( value ) ) ; }	Puts a new value into the document.
protected void put db ( final string name , final db ref ) { db db ref document = new db ( str , ref . get collection name ( ) ) . append ( str , ref . get id ( ) ) ; if ( ref . get database name ( ) != null ) { db ref document . put ( str , ref . get database name ( ) ) ; } put object ( name , db ref document ) ; }	Deals with encoding database references.
public static bulk write result unacknowledged ( ) { return new bulk write result ( ) { @ override public boolean was acknowledged ( ) { return bool ; } @ override public int get inserted count ( ) { throw get unacknowledged write exception ( ) ; } @ override public int get matched count ( ) { throw get unacknowledged write exception ( ) ; } @ override public int get deleted count ( ) { throw get unacknowledged write exception ( ) ; } @ override @ deprecated public boolean is modified count available ( ) { throw get unacknowledged write exception ( ) ; } @ override public int get modified count ( ) { throw get unacknowledged write exception ( ) ; } @ override public list < bulk write upsert > get upserts ( ) { throw get unacknowledged write exception ( ) ; } @ override public boolean equals ( final object o ) { if ( this == o ) { return bool ; } if ( o == null || get class ( ) != o . get class ( ) ) { return bool ; } bulk write result that = ( bulk write result ) o ; return ! that . was acknowledged ( ) ; } @ override public int hash code ( ) { return num ; } @ override public string to string ( ) { return str ; } private unsupported operation exception get unacknowledged write exception ( ) { return new unsupported operation exception ( str ) ; } } ; }	Create an unacknowledged BulkWriteResult.
public inet socket address get socket address ( ) { try { return new inet socket address ( inet address . get by name ( host ) , port ) ; } catch ( unknown host exception e ) { throw new mongo socket exception ( e . get message ( ) , this , e ) ; } }	Gets the underlying socket address.
public list < inet socket address > get socket addresses ( ) { try { inet address [ ] inet addresses = inet address . get all by name ( host ) ; list < inet socket address > inet socket address list = new array list < inet socket address > ( ) ; for ( inet address inet address : inet addresses ) { inet socket address list . add ( new inet socket address ( inet address , port ) ) ; } return inet socket address list ; } catch ( unknown host exception e ) { throw new mongo socket exception ( e . get message ( ) , this , e ) ; } }	Gets all underlying socket addresses.
public static < t > bson ne ( final string field name , @ nullable final t value ) { return new operator filter < t > ( str , field name , value ) ; }	Creates a filter that matches all documents where the value of the field name does not equal the specified value.
public static < t > bson gt ( final string field name , final t value ) { return new operator filter < t > ( str , field name , value ) ; }	Creates a filter that matches all documents where the value of the given field is greater than the specified value.
public static < t > bson lt ( final string field name , final t value ) { return new operator filter < t > ( str , field name , value ) ; }	Creates a filter that matches all documents where the value of the given field is less than the specified value.
public static < t > bson gte ( final string field name , final t value ) { return new operator filter < t > ( str , field name , value ) ; }	Creates a filter that matches all documents where the value of the given field is greater than or equal to the specified value.
public static < t > bson lte ( final string field name , final t value ) { return new operator filter < t > ( str , field name , value ) ; }	Creates a filter that matches all documents where the value of the given field is less than or equal to the specified value.
public static bson or ( final iterable < bson > filters ) { return new or nor filter ( or nor filter . operator . or , filters ) ; }	Creates a filter that preforms a logical OR of the provided list of filters.
public static bson nor ( final iterable < bson > filters ) { return new or nor filter ( or nor filter . operator . nor , filters ) ; }	Creates a filter that performs a logical NOR operation on all the specified filters.
public static bson exists ( final string field name , final boolean exists ) { return new operator filter < bson boolean > ( str , field name , bson boolean . value of ( exists ) ) ; }	Creates a filter that matches all documents that either contain or do not contain the given field, depending on the value of theexists parameter.
@ deprecated public static bson text ( final string search , final string language ) { not null ( str , search ) ; return text ( search , new text search options ( ) . language ( language ) ) ; }	Creates a filter that matches all documents matching the given search term using the given language.
public static bson text ( final string search , final text search options text search options ) { not null ( str , search ) ; not null ( str , text search options ) ; return new text filter ( search , text search options ) ; }	Creates a filter that matches all documents matching the given the search term with the given text search options.
public static bson elem match ( final string field name , final bson filter ) { return new bson ( ) { @ override public < t > bson document to bson document ( final class < t > document class , final codec registry codec registry ) { return new bson document ( field name , new bson document ( str , filter . to bson document ( document class , codec registry ) ) ) ; } } ; }	Creates a filter that matches all documents containing a field that is an array where at least one member of the array matches thegiven filter.
public static bson geo within box ( final string field name , final double lower left x , final double lower left y , final double upper right x , final double upper right y ) { bson document box = new bson document ( str , new bson array ( as list ( new bson array ( as list ( new bson double ( lower left x ) , new bson double ( lower left y ) ) ) , new bson array ( as list ( new bson double ( upper right x ) , new bson double ( upper right y ) ) ) ) ) ) ; return new operator filter < bson document > ( str , field name , box ) ; }	Creates a filter that matches all documents containing a field with grid coordinates data that exist entirely within the specifiedbox.
public static bson geo within polygon ( final string field name , final list < list < double > > points ) { bson array points array = new bson array ( ) ; for ( list < double > point : points ) { points array . add ( new bson array ( as list ( new bson double ( point . get ( num ) ) , new bson double ( point . get ( num ) ) ) ) ) ; } bson document polygon = new bson document ( str , points array ) ; return new operator filter < bson document > ( str , field name , polygon ) ; }	Creates a filter that matches all documents containing a field with grid coordinates data that exist entirely within the specifiedpolygon.
public static bson geo within center ( final string field name , final double x , final double y , final double radius ) { bson document center = new bson document ( str , new bson array ( arrays . < bson value > as list ( new bson array ( as list ( new bson double ( x ) , new bson double ( y ) ) ) , new bson double ( radius ) ) ) ) ; return new operator filter < bson document > ( str , field name , center ) ; }	Creates a filter that matches all documents containing a field with grid coordinates data that exist entirely within the specifiedcircle.
public static bson near ( final string field name , final point geometry , @ nullable final double max distance , @ nullable final double min distance ) { return new geometry operator filter < point > ( str , field name , geometry , max distance , min distance ) ; }	Creates a filter that matches all documents containing a field with geospatial data that is near the specified GeoJSON point.
public static bson near ( final string field name , final double x , final double y , @ nullable final double max distance , @ nullable final double min distance ) { return create near filter document ( field name , x , y , max distance , min distance , str ) ; }	Creates a filter that matches all documents containing a field with geospatial data that is near the specified point.
public static int regex flags ( final string s ) { int flags = num ; if ( s == null ) { return flags ; } for ( final char f : s . to lower case ( ) . to char array ( ) ) { flags |= regex flag ( f ) ; } return flags ; }	Converts a sequence of regular expression modifiers from the database into Java regular expression flags.
public static int regex flag ( final char c ) { int flag = flag lookup [ c ] ; if ( flag == num ) { throw new illegal argument exception ( string . format ( str , c ) ) ; } return flag ; }	Converts a regular expression modifier from the database into Java regular expression flags.
public static string regex flags ( final int flags ) { int processed flags = flags ; string builder buf = new string builder ( ) ; for ( int i = num ; i < flag lookup . length ; i ++ ) { if ( ( processed flags & flag lookup [ i ] ) > num ) { buf . append ( ( char ) i ) ; processed flags -= flag lookup [ i ] ; } } if ( processed flags > num ) { throw new illegal argument exception ( str ) ; } return buf . to string ( ) ; }	Converts Java regular expression flags into regular expression modifiers from the database.
public index request text version ( final integer text version ) { if ( text version != null ) { is true argument ( str , valid text index versions . contains ( text version ) ) ; } this . text version = text version ; return this ; }	Set the text index version number.
public index request sphere version ( final integer sphere version ) { if ( sphere version != null ) { is true argument ( str , valid sphere index versions . contains ( sphere version ) ) ; } this . sphere version = sphere version ; return this ; }	Sets the 2dsphere index version number.
public db copy ( ) { db copied options = new db ( ) ; copied options . batch size ( batch size ) ; copied options . limit ( limit ) ; copied options . modifiers ( modifiers ) ; copied options . projection ( projection ) ; copied options . max time ( max time ms , time unit . milliseconds ) ; copied options . max await time ( max await time ms , time unit . milliseconds ) ; copied options . skip ( skip ) ; copied options . sort ( sort ) ; copied options . cursor type ( cursor type ) ; copied options . no cursor timeout ( no cursor timeout ) ; copied options . oplog replay ( oplog replay ) ; copied options . partial ( partial ) ; copied options . read preference ( read preference ) ; copied options . read concern ( read concern ) ; copied options . collation ( collation ) ; copied options . comment ( comment ) ; copied options . hint ( hint ) ; copied options . max ( max ) ; copied options . min ( min ) ; copied options . return key ( return key ) ; copied options . show record id ( show record id ) ; return copied options ; }	Copy this DBCollectionFindOptions instance into a new instance.
@ suppress warnings ( str ) public static < t > t convert to type ( final class < t > clazz , final object value , final string error message ) { if ( ! clazz . is assignable from ( value . get class ( ) ) ) { throw new illegal argument exception ( error message ) ; } return ( t ) value ; }	Cast an object to the given class and return it, or throw IllegalArgumentException if it's not assignable to that class.
@ override public void encode ( final bson writer writer , final db document , final encoder context encoder context ) { basic output buffer buffer = new basic output buffer ( ) ; try { encoder . write object ( buffer , document ) ; bson binary reader reader = new bson binary reader ( new byte buffer bson input ( new nio ( wrap ( buffer . to byte array ( ) ) ) ) ) ; try { writer . pipe ( reader ) ; } finally { reader . close ( ) ; } } finally { buffer . close ( ) ; } }	over an array of ByteBuffer instances from a PooledByteBufferOutputBuffer.
@ override public bulk write result execute ( final write binding binding ) { return with releasable connection ( binding , new callable with connection and source < bulk write result > ( ) { @ override public bulk write result call ( final connection source connection source , final connection connection ) { validate write requests and release connection if error ( connection ) ; if ( get write concern ( ) . is acknowledged ( ) || server is at least version three dot six ( connection . get description ( ) ) ) { bulk write batch bulk write batch = bulk write batch . create bulk write batch ( namespace , connection source . get server description ( ) , connection . get description ( ) , ordered , write concern , bypass document validation , retry writes , write requests , binding . get session context ( ) ) ; return execute bulk write batch ( binding , connection , bulk write batch ) ; } else { return execute legacy batches ( connection ) ; } } } ) ; }	Executes a bulk write operation.
public bulk update request builder upsert ( ) { return new bulk update request builder ( bulk write operation , query , bool , codec , replacement codec , collation , null ) ; }	Specifies that the request being built should be an upsert.
public bulk update request builder array filters ( final list < ? extends db > array filters ) { return new bulk update request builder ( bulk write operation , query , bool , codec , replacement codec , collation , array filters ) ; }	Specifies that the request being built should use the given array filters for an update. Note that this option only applies toupdate operations and will be ignored for replace operations.
@ override public map reduce statistics execute ( final write binding binding ) { return with connection ( binding , new operation helper . callable with connection < map reduce statistics > ( ) { @ override public map reduce statistics call ( final connection connection ) { validate collation ( connection , collation ) ; return execute command ( binding , namespace . get database name ( ) , get command ( connection . get description ( ) ) , connection , transformer ( ) ) ; } } ) ; }	Executing this will return a cursor with your results in.
public static synchronized void init ( final mongo embedded settings mongo embedded settings ) { if ( mongo embedded library != null ) { throw new mongo client embedded exception ( str ) ; } try { mongo embedded library = capi . create ( mongo embedded settings . get yaml config ( ) , mongo embedded settings . get log level ( ) . to capi log level ( ) , mongo embedded settings . get library path ( ) ) ; } catch ( exception e ) { throw new mongo client embedded exception ( format ( str + str , e . get message ( ) ) , e ) ; } }	Initializes the mongod library for use. The library must be called at most once per process before calling {.
public static synchronized mongo client create ( final mongo client settings mongo client settings ) { if ( mongo embedded library == null ) { throw new mongo client embedded exception ( str ) ; } try { cluster cluster = new embedded cluster ( mongo embedded library , mongo client settings ) ; return new mongo client impl ( cluster , mongo client settings . get wrapped mongo client settings ( ) , null ) ; } catch ( exception e ) { throw new mongo client embedded exception ( format ( str + str + str , e . get message ( ) ) , e ) ; } }	Creates a new client.
public static synchronized void close ( ) { if ( mongo embedded library != null ) { try { mongo embedded library . close ( ) ; } catch ( exception e ) { throw new mongo client embedded exception ( format ( str + str + str , e . get message ( ) ) , e ) ; } mongo embedded library = null ; } }	Closes down the mongod library.
public static void enable sni ( final string host , final ssl ssl parameters ) { if ( sni ssl helper != null ) { sni ssl helper . enable sni ( host , ssl parameters ) ; } }	Enable SNI if running on Java 8 or later.
@ suppress warnings ( str ) public static byte get type ( final object object ) { if ( object == null ) { return null ; } if ( object instanceof integer || object instanceof short || object instanceof byte || object instanceof atomic integer ) { return number int ; } if ( object instanceof long || object instanceof atomic long ) { return number long ; } if ( object instanceof number ) { return number ; } if ( object instanceof string ) { return string ; } if ( object instanceof java . util . list ) { return array ; } if ( object instanceof byte [ ] ) { return binary ; } if ( object instanceof object id ) { return oid ; } if ( object instanceof boolean ) { return boolean ; } if ( object instanceof java . util . date ) { return date ; } if ( object instanceof bson ) { return timestamp ; } if ( object instanceof java . util . regex . pattern ) { return regex ; } if ( object instanceof db || object instanceof db ) { return object ; } if ( object instanceof w ) { return code w scope ; } if ( object instanceof code ) { return code ; } return - num ; }	Gets the type byte for a given object.
public db to db ( ) { db cmd = new db ( ) ; cmd . put ( str , map reduce ) ; cmd . put ( str , map ) ; cmd . put ( str , reduce ) ; if ( verbose != null ) { cmd . put ( str , verbose ) ; } db out = new db ( ) ; switch ( output type ) { case inline : out . put ( str , num ) ; break ; case replace : out . put ( str , output collection ) ; break ; case merge : out . put ( str , output collection ) ; break ; case reduce : out . put ( str , output collection ) ; break ; default : throw new illegal argument exception ( str ) ; } if ( output db != null ) { out . put ( str , output db ) ; } cmd . put ( str , out ) ; if ( query != null ) { cmd . put ( str , query ) ; } if ( finalize != null ) { cmd . put ( str , finalize ) ; } if ( sort != null ) { cmd . put ( str , sort ) ; } if ( limit > num ) { cmd . put ( str , limit ) ; } if ( scope != null ) { cmd . put ( str , scope ) ; } if ( js mode != null ) { cmd . put ( str , js mode ) ; } if ( max time ms != num ) { cmd . put ( str , max time ms ) ; } return cmd ; }	Turns this command into a DBObject representation of this map reduce command.
public string get short description ( ) { return str + ( hosts . is empty ( ) ? str : str + hosts ) + ( srv host == null ? str : str + srv host ) + str + mode + str + required cluster type + str + server selection timeout ms + str + str + str + max wait queue size + ( required replica set name == null ? str : str + required replica set name + str ) + ( description == null ? str : str + description + str ) + str ; }	Returns a short, pretty description for these ClusterSettings.
public static update result acknowledged ( final long matched count , @ nullable final long modified count , @ nullable final bson value upserted id ) { return new acknowledged update result ( matched count , modified count , upserted id ) ; }	Create an acknowledged UpdateResult.
@ deprecated public string get content type ( ) { if ( extra elements != null && extra elements . contains key ( str ) ) { return extra elements . get string ( str ) ; } else { throw new fs ( str ) ; } }	The content type of the file.
@ deprecated @ suppress warnings ( str ) public list < string > get aliases ( ) { if ( extra elements != null && extra elements . contains key ( str ) ) { return ( list < string > ) extra elements . get ( str ) ; } else { throw new fs ( str ) ; } }	The aliases for the file.
public string get first key ( ) { return find in document ( new finder < string > ( ) { @ override public string find ( final bson reader bson reader ) { return bson reader . read name ( ) ; } @ override public string not found ( ) { throw new no such element exception ( ) ; } } ) ; }	Gets the first key in this document, or null if the document is empty.
public < t > void encode with child context ( final encoder < t > encoder , final bson writer writer , final t value ) { encoder . encode ( writer , value , default context ) ; }	Creates a child context based on this and serializes the value with it to the writer.
public bson document as document ( ) { bson document read concern = new bson document ( ) ; if ( level != null ) { read concern . put ( str , new bson string ( level . get value ( ) ) ) ; } return read concern ; }	Gets this read concern as a document.
@ override public void compress ( final list < byte buf > source , final bson output target ) { int uncompressed size = get uncompressed size ( source ) ; byte [ ] single byte array source = new byte [ uncompressed size ] ; copy ( source , single byte array source ) ; try { byte [ ] out = new byte [ snappy . max compressed length ( uncompressed size ) ] ; int compressed size = snappy . compress ( single byte array source , num , single byte array source . length , out , num ) ; target . write bytes ( out , num , compressed size ) ; } catch ( io e ) { throw new mongo internal exception ( str , e ) ; } }	be copied into a single byte array.
public string get string ( final string key ) { object foo = get ( key ) ; if ( foo == null ) { return null ; } return foo . to string ( ) ; }	Returns the value of a field as a string.
public boolean get boolean ( final string key , final boolean def ) { object foo = get ( key ) ; if ( foo == null ) { return def ; } if ( foo instanceof number ) { return ( ( number ) foo ) . int value ( ) > num ; } if ( foo instanceof boolean ) { return ( boolean ) foo ; } throw new illegal argument exception ( str + foo . get class ( ) ) ; }	Returns the value of a field as a boolean.
public object id get object id ( final string field , final object id def ) { object foo = get ( field ) ; return ( foo != null ) ? ( object id ) foo : def ; }	Returns the object id or def if not set.
public date get date ( final string field , final date def ) { object foo = get ( field ) ; return ( foo != null ) ? ( date ) foo : def ; }	Returns the date or def if not set.
@ suppress warnings ( str ) private static object canonicalize ( final object from ) { if ( from instanceof bson && ! ( from instanceof bson ) ) { return canonicalize bson ( ( bson ) from ) ; } else if ( from instanceof list ) { return canonicalize list ( ( list < object > ) from ) ; } else if ( from instanceof map ) { return canonicalize map ( ( map < string , object > ) from ) ; } else { return from ; } }	create a copy of "from", but with keys ordered alphabetically.
@ nullable public mongo credential get credential ( ) { if ( get credentials list ( ) . size ( ) > num ) { throw new illegal state exception ( str ) ; } else if ( get credentials list ( ) . is empty ( ) ) { return null ; } else { return get credentials list ( ) . get ( num ) ; } }	Gets the credential that this client authenticates all connections with.
public client session start session ( final client session options options ) { client session client session = create client session ( not null ( str , options ) ) ; if ( client session == null ) { throw new mongo client exception ( str ) ; } return client session ; }	Creates a client session.
@ nullable public integer get w ( final time unit time unit ) { not null ( str , time unit ) ; return w timeout ms == null ? null : ( int ) time unit . convert ( w timeout ms , time unit . milliseconds ) ; }	Gets the wTimeout in the given time unit.
public bson document as document ( ) { bson document document = new bson document ( ) ; add w ( document ) ; add w ( document ) ; add f ( document ) ; add j ( document ) ; return document ; }	Gets this write concern as a document.
public boolean is acknowledged ( ) { if ( w instanceof integer ) { return ( integer ) w > num || ( journal != null && journal ) || ( fsync != null && fsync ) ; } return bool ; }	Returns true if this write concern indicates that write operations must be acknowledged.
public write concern with w ( final int w ) { return new write concern ( integer . value of ( w ) , w timeout ms , fsync , journal ) ; }	Constructs a new WriteConcern from the current one and the specified integer-based value for w.
public write concern with w ( final string w ) { not null ( str , w ) ; return new write concern ( w , w timeout ms , fsync , journal ) ; }	Constructs a new WriteConcern from the current one and the specified tag-set based value for w.
public write concern with w ( final long w timeout , final time unit time unit ) { not null ( str , time unit ) ; long new w ms = time unit . milliseconds . convert ( w timeout , time unit ) ; is true argument ( str , w timeout >= num ) ; is true argument ( str + integer . max value + str , new w ms <= integer . max value ) ; return new write concern ( w , ( int ) new w ms , fsync , journal ) ; }	Constructs a new WriteConcern from the current one and the specified wTimeout in the given time unit.
@ deprecated public static majority majority write concern ( final int wtimeout , final boolean fsync , final boolean j ) { return new majority ( wtimeout , fsync , j ) ; }	Create a Majority Write Concern that requires a majority of servers to acknowledge the write.
public void insert ( final db document ) { is true ( str , ! closed ) ; if ( document . get ( id field name ) == null ) { document . put ( id field name , new object id ( ) ) ; } add request ( new insert request ( document , collection . get object codec ( ) ) ) ; }	Add an insert request to the bulk operation.
public bulk write request builder find ( final db query ) { is true ( str , ! closed ) ; return new bulk write request builder ( this , query , collection . get default db ( ) , collection . get object codec ( ) ) ; }	Start building a write request to add to the bulk write operation.
public bulk write result execute ( ) { is true ( str , ! closed ) ; closed = bool ; return collection . execute bulk write operation ( ordered , bypass document validation , requests ) ; }	Execute the bulk write operation with the default write concern of the collection from which this came.
public object copy ( ) {	Creates a new instance which is a copy of this BasicDBObject.
public static bson geo haystack ( final string field name , final bson additional ) { not null ( str , field name ) ; return compound index ( new bson document ( field name , new bson string ( str ) ) , additional ) ; }	Create an index key for a geohaystack index on the given field.
public list < string > get index names ( ) { list < string > index names = new array list < string > ( requests . size ( ) ) ; for ( index request request : requests ) { if ( request . get name ( ) != null ) { index names . add ( request . get name ( ) ) ; } else { index names . add ( index helper . generate index name ( request . get keys ( ) ) ) ; } } return index names ; }	Gets the index names.
public bson value get ( final object key , final bson value default value ) { bson value value = get ( key ) ; return value != null ? value : default value ; }	If the document does not contain the given key, return the given default value.
public bson document get document ( final object key , final bson document default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as document ( ) ; }	If the document does not contain the given key, return the given default value.
public bson array get array ( final object key , final bson array default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as array ( ) ; }	If the document does not contain the given key, return the given default value.
public bson number get number ( final object key , final bson number default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as number ( ) ; }	If the document does not contain the given key, return the given default value.
public bson int32 get int32 ( final object key , final bson int32 default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as int32 ( ) ; }	If the document does not contain the given key, return the given default value.
public bson int64 get int64 ( final object key , final bson int64 default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as int64 ( ) ; }	If the document does not contain the given key, return the given default value.
public bson decimal128 get decimal128 ( final object key , final bson decimal128 default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as decimal128 ( ) ; }	If the document does not contain the given key, return the given default value.
public bson double get double ( final object key , final bson double default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as double ( ) ; }	If the document does not contain the given key, return the given default value.
public bson boolean get boolean ( final object key , final bson boolean default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as boolean ( ) ; }	If the document does not contain the given key, return the given default value.
public bson string get string ( final object key , final bson string default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as string ( ) ; }	If the document does not contain the given key, return the given default value.
public bson date time get date time ( final object key , final bson date time default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as date time ( ) ; }	If the document does not contain the given key, return the given default value.
public bson timestamp get timestamp ( final object key , final bson timestamp default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as timestamp ( ) ; }	If the document does not contain the given key, return the given default value.
public bson object id get object id ( final object key , final bson object id default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as object id ( ) ; }	If the document does not contain the given key, return the given default value.
public bson binary get binary ( final object key , final bson binary default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as binary ( ) ; }	If the document does not contain the given key, return the given default value.
public bson regular expression get regular expression ( final object key , final bson regular expression default value ) { if ( ! contains key ( key ) ) { return default value ; } return get ( key ) . as regular expression ( ) ; }	If the document does not contain the given key, return the given default value.
private void write handling tasks ( final registered socket socket , final write operation op ) throws io { while ( bool ) { try { socket . tls channel . write ( op . buffer set . array , op . buffer set . offset , op . buffer set . length ) ; return ; } catch ( needs task exception e ) { warn about need task ( ) ; e . get task ( ) . run ( ) ; } } }	Intended use of the channel group is with sockets that run tasks internally, but out of tolerance, run tasks inthread in case the socket does not.
@ suppress warnings ( { str , str } ) public static bson document as bson document ( final object document , final codec registry codec registry ) { if ( document == null ) { return null ; } if ( document instanceof bson document ) { return ( bson document ) document ; } else { return new bson document wrapper ( document , codec registry . get ( document . get class ( ) ) ) ; } }	A helper to convert an document of type Object to a BsonDocument If not already a BsonDocument it looks up the documents' class in the codecRegistry and wraps it into a BsonDocumentWrapper .
public static < t > t not null ( final string name , final t value , final single result callback < ? > callback ) { if ( value == null ) { illegal argument exception exception = new illegal argument exception ( name + str ) ; callback . on result ( null , exception ) ; throw exception ; } return value ; }	Throw IllegalArgumentException if the value is null.
public static void is true ( final string name , final boolean condition , final single result callback < ? > callback ) { if ( ! condition ) { illegal state exception exception = new illegal state exception ( str + name ) ; callback . on result ( null , exception ) ; throw exception ; } }	Throw IllegalStateException if the condition if false.
public property model builder < ? > get property ( final string property name ) { not null ( str , property name ) ; for ( property model builder < ? > property model builder : property model builders ) { if ( property model builder . get name ( ) . equals ( property name ) ) { return property model builder ; } } return null ; }	Gets a property by the property name.
public class model < t > build ( ) { list < property model < ? > > property models = new array list < property model < ? > > ( ) ; property model < ? > id property model = null ; state not null ( str , type ) ; for ( convention convention : conventions ) { convention . apply ( this ) ; } state not null ( str , instance creator factory ) ; if ( discriminator enabled ) { state not null ( str , discriminator key ) ; state not null ( str , discriminator ) ; } for ( property model builder < ? > property model builder : property model builders ) { boolean is id property = property model builder . get name ( ) . equals ( id property name ) ; if ( is id property ) { property model builder . read name ( id property name ) . write name ( id property name ) ; } property model < ? > model = property model builder . build ( ) ; property models . add ( model ) ; if ( is id property ) { id property model = model ; } } validate property models ( type . get simple name ( ) , property models ) ; return new class model < t > ( type , property name to type parameter map , instance creator factory , discriminator enabled , discriminator key , discriminator , id property model holder . create ( type , id property model , id generator ) , unmodifiable list ( property models ) ) ; }	Creates a new ClassModel instance based on the mapping data provided.
@ deprecated public update options get options ( ) { return new update options ( ) . bypass document validation ( options . get bypass document validation ( ) ) . collation ( options . get collation ( ) ) . upsert ( options . is upsert ( ) ) ; }	Gets the options to apply.
@ nullable public static java wrapper get wrapper if reflection object ( final class c ) { if ( db . class . is assignable from ( c ) ) { return get wrapper ( c ) ; } return null ; }	Returns the wrapper if this object can be assigned from this class.
public static java wrapper get wrapper ( final class c ) { java wrapper w = wrappers . get ( c ) ; if ( w == null ) { w = new java wrapper ( c ) ; wrappers . put ( c , w ) ; } return w ; }	Returns an existing Wrapper instance associated with a class, or creates a new one.
public uuid as uuid ( ) { if ( ! bson binary sub type . is uuid ( type ) ) { throw new bson invalid operation exception ( str ) ; } if ( type != bson binary sub type . uuid standard . get value ( ) ) { throw new bson invalid operation exception ( str ) ; } return uuid helper . decode binary to uuid ( this . data . clone ( ) , this . type , uuid representation . standard ) ; }	Returns the binary as a UUID.
public uuid as uuid ( final uuid representation uuid representation ) { assertions . not null ( str , uuid representation ) ; final byte uuid type = uuid representation == uuid representation . standard ? bson binary sub type . uuid standard . get value ( ) : bson binary sub type . uuid legacy . get value ( ) ; if ( type != uuid type ) { throw new bson invalid operation exception ( str ) ; } return uuid helper . decode binary to uuid ( data . clone ( ) , type , uuid representation ) ; }	Returns the binary as a UUID.
protected object parse ( final string name ) { object value = null ; char current = get ( ) ; switch ( current ) {	Parse an unknown type.
public void read hex ( ) { if ( pos < s . length ( ) && ( ( s . char at ( pos ) >= str && s . char at ( pos ) <= str ) || ( s . char at ( pos ) >= str && s . char at ( pos ) <= str ) || ( s . char at ( pos ) >= str && s . char at ( pos ) <= str ) ) ) { pos ++ ; } else { throw new json ( s , pos ) ; } }	Read the current character, making sure that it is a hexidecimal character.
public void skip ws ( ) { while ( pos < s . length ( ) && character . is whitespace ( s . char at ( pos ) ) ) { pos ++ ; } }	Advances the position in the string past any whitespace.
public string parse string ( final boolean need quote ) { char quot = num ; if ( check ( str ) ) { quot = str ; } else if ( check ( str ) ) { quot = str ; } else if ( need quote ) { throw new json ( s , pos ) ; } char current ; if ( quot > num ) { read ( quot ) ; } string builder buf = new string builder ( ) ; int start = pos ; while ( pos < s . length ( ) ) { current = s . char at ( pos ) ; if ( quot > num ) { if ( current == quot ) { break ; } } else { if ( current == str || current == str ) { break ; } } if ( current == str ) { pos ++ ; char x = get ( ) ; char special = num ;	Parses a string.
public number parse number ( ) { get ( ) ; int start = this . pos ; boolean is double = bool ; if ( check ( str ) || check ( str ) ) { pos ++ ; } outer : while ( pos < s . length ( ) ) { switch ( s . char at ( pos ) ) { case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : pos ++ ; break ; case str : is double = bool ; parse fraction ( ) ; break ; case str : case str : is double = bool ; parse exponent ( ) ; break ; default : break outer ; } } try { if ( is double ) { return double . value of ( s . substring ( start , pos ) ) ; } long val = long . value of ( s . substring ( start , pos ) ) ; if ( val <= integer . max value && val >= integer . min value ) { return val . int value ( ) ; } return val ; } catch ( number format exception e ) { throw new json ( s , start , e ) ; } }	Parses a number.
public void parse exponent ( ) {	Advances the pointer through the exponent.
protected object parse array ( final string name ) { if ( name != null ) { callback . array start ( name ) ; } else { callback . array start ( ) ; } read ( str ) ; int i = num ; char current = get ( ) ; while ( current != str ) { string elem name = string . value of ( i ++ ) ; object elem = parse ( elem name ) ; do callback ( elem name , elem ) ; if ( ( current = get ( ) ) == str ) { read ( str ) ; } else if ( current == str ) { break ; } else { throw new json ( s , pos ) ; } } read ( str ) ; return callback . array done ( ) ; }	Parses the next array.
public void update one ( final db update ) { bulk write operation . add request ( new update request ( query , update , bool , upsert , query codec , collation , array filters ) ) ; }	Adds a request to update one document in the collection that matches the query with which this builder was created.
public connection description with connection id ( final connection id connection id ) { not null ( str , connection id ) ; return new connection description ( connection id , server version , max wire version , server type , max batch count , max document size , max message size , compressors ) ; }	Creates a new connection description with the set connection id.
public static write concern result acknowledged ( final int count , final boolean is update of existing , @ nullable final bson value upserted id ) { return new write concern result ( ) { @ override public boolean was acknowledged ( ) { return bool ; } @ override public int get count ( ) { return count ; } @ override public boolean is update of existing ( ) { return is update of existing ; } @ override @ nullable public bson value get upserted id ( ) { return upserted id ; } @ override public boolean equals ( final object o ) { if ( this == o ) { return bool ; } if ( o == null || get class ( ) != o . get class ( ) ) { return bool ; } write concern result that = ( write concern result ) o ; if ( ! that . was acknowledged ( ) ) { return bool ; } if ( count != that . get count ( ) ) { return bool ; } if ( is update of existing != that . is update of existing ( ) ) { return bool ; } if ( upserted id != null ? ! upserted id . equals ( that . get upserted id ( ) ) : that . get upserted id ( ) != null ) { return bool ; } return bool ; } @ override public int hash code ( ) { int result = count ; result = num * result + ( is update of existing ? num : num ) ; result = num * result + ( upserted id != null ? upserted id . hash code ( ) : num ) ; return result ; } @ override public string to string ( ) { return str + str + count + str + is update of existing + str + upserted id + str ; } } ; }	Create an acknowledged WriteConcernResult.
public static write concern result unacknowledged ( ) { return new write concern result ( ) { @ override public boolean was acknowledged ( ) { return bool ; } @ override public int get count ( ) { throw get unacknowledged write exception ( ) ; } @ override public boolean is update of existing ( ) { throw get unacknowledged write exception ( ) ; } @ override public bson value get upserted id ( ) { throw get unacknowledged write exception ( ) ; } @ override public boolean equals ( final object o ) { if ( this == o ) { return bool ; } if ( o == null || get class ( ) != o . get class ( ) ) { return bool ; } write concern result that = ( write concern result ) o ; return ! that . was acknowledged ( ) ; } @ override public int hash code ( ) { return num ; } @ override public string to string ( ) { return str ; } private unsupported operation exception get unacknowledged write exception ( ) { return new unsupported operation exception ( str ) ; } } ; }	Create an unacknowledged WriteConcernResult.
@ suppress warnings ( str ) private < t > t get embedded value ( final list < ? > keys , final class < t > clazz , final t default value ) { object value = this ; iterator < ? > key iterator = keys . iterator ( ) ; while ( key iterator . has next ( ) ) { object key = key iterator . next ( ) ; value = ( ( document ) value ) . get ( key ) ; if ( ! ( value instanceof document ) ) { if ( value == null ) { return default value ; } else if ( key iterator . has next ( ) ) { throw new class cast exception ( format ( str , key , value . get class ( ) . get name ( ) ) ) ; } } } return clazz != null ? clazz . cast ( value ) : ( t ) value ; }	Throws ClassCastException if any of the intermediate embedded values is not a Document.
@ suppress warnings ( str ) private < t > list < t > construct values list ( final object key , final class < t > clazz , final list < t > default value ) { list < ? > value = get ( key , list . class ) ; if ( value == null ) { return default value ; } for ( object item : value ) { if ( ! clazz . is assignable from ( item . get class ( ) ) ) { throw new class cast exception ( format ( str , clazz . get name ( ) ) ) ; } } return ( list < t > ) value ; }	A ClassCastException will be thrown if an element in the list is not of type T.
public static transaction options merge ( final transaction options options , final transaction options default options ) { not null ( str , options ) ; not null ( str , default options ) ; return transaction options . builder ( ) . write concern ( options . get write concern ( ) == null ? default options . get write concern ( ) : options . get write concern ( ) ) . read concern ( options . get read concern ( ) == null ? default options . get read concern ( ) : options . get read concern ( ) ) . read preference ( options . get read preference ( ) == null ? default options . get read preference ( ) : options . get read preference ( ) ) . build ( ) ; }	Merge the two provided transaction options, with the first taking precedence over the second.
@ override public void release ( final t t , final boolean prune ) { if ( t == null ) { throw new illegal argument exception ( str ) ; } if ( closed ) { close ( t ) ; return ; } if ( prune ) { close ( t ) ; } else { available . add last ( t ) ; } release permit ( ) ; }	call done when you are done with an object from the pool if there is room and the object is ok will get added.
@ override public t get ( final long timeout , final time unit time unit ) { if ( closed ) { throw new illegal state exception ( str ) ; } if ( ! acquire permit ( timeout , time unit ) ) { throw new mongo timeout exception ( string . format ( str , timeout , time unit ) ) ; } t t = available . poll last ( ) ; if ( t == null ) { t = create new and release permit if failure ( bool ) ; } return t ; }	Gets an object from the pool - will block if none are available.
@ override public void close ( ) { closed = bool ; iterator < t > iter = available . iterator ( ) ; while ( iter . has next ( ) ) { t t = iter . next ( ) ; close ( t ) ; iter . remove ( ) ; } }	Clears the pool of all objects.
public int pipe ( final output stream os ) throws io { writable byte channel channel = channels . new channel ( os ) ; return channel . write ( get buffer for internal bytes ( ) ) ; }	Pipe the raw bytes into the given output stream.
protected void throw invalid context type ( final string method name , final bson context type actual context type , final bson context type ... valid context types ) { string valid context types string = string utils . join ( str , as list ( valid context types ) ) ; string message = format ( str , method name , valid context types string , actual context type ) ; throw new bson invalid operation exception ( message ) ; }	Throws an InvalidOperationException when the method called is not valid for the current ContextType.
protected void throw invalid state ( final string method name , final state ... valid states ) { string valid states string = string utils . join ( str , as list ( valid states ) ) ; string message = format ( str , method name , valid states string , state ) ; throw new bson invalid operation exception ( message ) ; }	Throws an InvalidOperationException when the method called is not valid for the current state.
protected void verify bson ( final string method name , final bson type required bson type ) { if ( state == state . initial || state == state . scope document || state == state . type ) { read bson type ( ) ; } if ( state == state . name ) {	Verifies the current state and BSONType of the reader.
protected void verify name ( final string expected name ) { read bson type ( ) ; string actual name = read name ( ) ; if ( ! actual name . equals ( expected name ) ) { throw new bson serialization exception ( format ( str , expected name , actual name ) ) ; } }	Verifies the name of the current element.
protected void check preconditions ( final string method name , final bson type type ) { if ( is closed ( ) ) { throw new illegal state exception ( str ) ; } verify bson ( method name , type ) ; }	Ensures any conditions are met before reading commences.
public static decimal128 parse ( final string value ) { string lower cased value = value . to lower case ( ) ; if ( n strings . contains ( lower cased value ) ) { return n ; } if ( negative n strings . contains ( lower cased value ) ) { return negative n ; } if ( positive infinity strings . contains ( lower cased value ) ) { return positive infinity ; } if ( negative infinity strings . contains ( lower cased value ) ) { return negative infinity ; } return new decimal128 ( new big decimal ( value ) , value . char at ( num ) == str ) ; }	Returns a Decimal128 value representing the given String.
public big decimal big decimal value ( ) { if ( is na n ( ) ) { throw new arithmetic exception ( str ) ; } if ( is infinite ( ) ) { throw new arithmetic exception ( str ) ; } big decimal big decimal = big decimal value no negative zero check ( ) ;	Gets a BigDecimal that is equivalent to this Decimal128.
private byte [ ] get bytes ( ) { byte [ ] bytes = new byte [ num ] ; long mask = num ; for ( int i = num ; i >= num ; i -- ) { bytes [ i ] = ( byte ) ( ( low & mask ) > > > ( ( num - i ) << num ) ) ; mask = mask << num ; } mask = num ; for ( int i = num ; i >= num ; i -- ) { bytes [ i ] = ( byte ) ( ( high & mask ) > > > ( ( num - i ) << num ) ) ; mask = mask << num ; } mask = num ; bytes [ num ] = ( byte ) ( ( high & mask ) > > > num ) ; return bytes ; }	May have leading zeros. Strip them before considering making this method public.
public aggregate explain operation hint ( final bson value hint ) { is true argument ( str , hint == null || hint . is document ( ) || hint . is string ( ) ) ; this . hint = hint ; return this ; }	Sets the hint for which index to use.
public bson document as document ( ) { bson document collation = new bson document ( ) ; if ( locale != null ) { collation . put ( str , new bson string ( locale ) ) ; } if ( case level != null ) { collation . put ( str , new bson boolean ( case level ) ) ; } if ( case first != null ) { collation . put ( str , new bson string ( case first . get value ( ) ) ) ; } if ( strength != null ) { collation . put ( str , new bson int32 ( strength . get int representation ( ) ) ) ; } if ( numeric ordering != null ) { collation . put ( str , new bson boolean ( numeric ordering ) ) ; } if ( alternate != null ) { collation . put ( str , new bson string ( alternate . get value ( ) ) ) ; } if ( max variable != null ) { collation . put ( str , new bson string ( max variable . get value ( ) ) ) ; } if ( normalization != null ) { collation . put ( str , new bson boolean ( normalization ) ) ; } if ( backwards != null ) { collation . put ( str , new bson boolean ( backwards ) ) ; } return collation ; }	Gets this collation options as a document.
public long write to ( final file file ) throws io { file output stream out = null ; try { out = new file output stream ( file ) ; return write to ( out ) ; } finally { if ( out != null ) { out . close ( ) ; } } }	Writes the file's data to a file on disk.
public long write to ( final output stream out ) throws io { int nc = num chunks ( ) ; for ( int i = num ; i < nc ; i ++ ) { out . write ( get chunk ( i ) ) ; } return length ; }	Writes the file's data to an OutputStream.
void remove ( ) { fs . get files collection ( ) . remove ( new db ( str , id ) ) ; fs . get chunks collection ( ) . remove ( new db ( str , id ) ) ; }	Removes file from GridFS i.e.
public push options sort ( @ nullable final integer sort ) { if ( sort document != null ) { throw new illegal state exception ( str ) ; } this . sort = sort ; return this ; }	Sets the sort direction for sorting array elements that are not documents.
public push options sort document ( @ nullable final bson sort document ) { if ( sort != null ) { throw new illegal state exception ( str ) ; } this . sort document = sort document ; return this ; }	Sets the sort direction for sorting array elements that are documents.
@ bson ignore @ nullable public mongo namespace get namespace ( ) { if ( namespace document == null ) { return null ; } if ( ! namespace document . contains key ( str ) || ! namespace document . contains key ( str ) ) { return null ; } return new mongo namespace ( namespace document . get string ( str ) . get value ( ) , namespace document . get string ( str ) . get value ( ) ) ; }	Returns the namespaceThe invalidate operation type does include a MongoNamespace in the ChangeStreamDocument response.
@ bson ignore @ nullable public string get database name ( ) { if ( namespace document == null ) { return null ; } if ( ! namespace document . contains key ( str ) ) { return null ; } return namespace document . get string ( str ) . get value ( ) ; }	Returns the database name.
public static < t > codec < change stream document < t > > create codec ( final class < t > full document class , final codec registry codec registry ) { return new change stream document codec < t > ( full document class , codec registry ) ; }	Creates the codec for the specific ChangeStreamOutput type.
public static builder builder ( final client session options options ) { not null ( str , options ) ; builder builder = new builder ( ) ; builder . causally consistent = options . is causally consistent ( ) ; builder . default transaction options = options . get default transaction options ( ) ; return builder ; }	Gets an instance of a builder initialized with the given options.
public void reset ( ) { connections per host = num ; threads allowed to block for connection multiplier = num ; max wait time = num * num * num ; connect timeout = num * num ; socket factory = socket factory . get default ( ) ; socket timeout = num ; socket keep alive = bool ; read preference = null ; write concern = null ; safe = bool ; w = num ; wtimeout = num ; fsync = bool ; j = bool ; db decoder factory = db . factory ; db encoder factory = db . factory ; description = null ; cursor finalizer enabled = bool ; always use m = bool ; required replica set name = null ; }	Reset all settings to the default.
public mongo options copy ( ) { mongo options m = new mongo options ( ) ; m . connections per host = connections per host ; m . threads allowed to block for connection multiplier = threads allowed to block for connection multiplier ; m . max wait time = max wait time ; m . connect timeout = connect timeout ; m . socket factory = socket factory ; m . socket timeout = socket timeout ; m . socket keep alive = socket keep alive ; m . read preference = read preference ; m . write concern = write concern ; m . safe = safe ; m . w = w ; m . wtimeout = wtimeout ; m . fsync = fsync ; m . j = j ; m . db decoder factory = db decoder factory ; m . db encoder factory = db encoder factory ; m . description = description ; m . cursor finalizer enabled = cursor finalizer enabled ; m . always use m = always use m ; m . required replica set name = required replica set name ; return m ; }	Copy this MongoOptions instance into a new instance.
@ suppress warnings ( str ) public write concern get write concern ( ) { write concern ret val ; if ( write concern != null ) { ret val = write concern ; } else if ( w != num || wtimeout != num || fsync | j ) { ret val = write concern . acknowledged ; if ( w != num ) { ret val = ret val . with w ( w ) ; } if ( wtimeout != num ) { ret val = ret val . with w ( wtimeout , time unit . milliseconds ) ; } if ( fsync ) { ret val = ret val . with fsync ( fsync ) ; } if ( j ) { ret val = ret val . with j ( j ) ; } } else if ( safe ) { ret val = write concern . acknowledged ; } else { ret val = write concern . unacknowledged ; } return ret val ; }	Helper method to return the appropriate WriteConcern instance based on the current related options settings.
public static string get user agent ( string service name , boolean allow telemetry ) { string mac address = str ; if ( allow telemetry ) { mac address = get hash mac . get hash mac ( ) ; } return string . format ( service name + str , mac address ) ; }	Generate UserAgent string for given service.
@ fb ( str ) private void populate properties ( configurable environment environment , vcap pojo [ ] pojos ) { final map < string , object > map = new hash map < > ( ) ; populate default storage properties ( map , find pojo for service type ( vcap service type . azure storage , pojos ) ) ; populate default service bus properties ( map , find pojo for service type ( vcap service type . azure servicebus , pojos ) ) ; populate default document db ( map , find pojo for service type ( vcap service type . azure documentdb , pojos ) ) ; add or replace ( environment . get property sources ( ) , map ) ; }	Populates default properties during .
private boolean is matching user group key ( final json node node ) { return node . get ( aad authentication properties . get user group ( ) . get key ( ) ) . as text ( ) . equals ( aad authentication properties . get user group ( ) . get value ( ) ) ; }	Checks that the JSON Node is a valid User Group to extract User Groups from.
public set < granted authority > convert groups to granted authorities ( final list < user group > groups ) {	Converts UserGroup list to Set of GrantedAutorities.
public service endpoints get service endpoints ( string environment ) { assert . not empty ( endpoints , str ) ; if ( ! endpoints . contains key ( environment ) ) { throw new illegal argument exception ( environment + str + str + endpoints . key set ( ) ) ; } return endpoints . get ( environment ) ; }	Get ServiceEndpoints data for the given environment.
@ bean @ scope ( bean definition . scope singleton ) @ conditional on missing bean ( aad . class ) public aad azure ad ( ) { log . info ( str ) ; return new aad ( aad auth props , service endpoints props , get jwt ( ) ) ; }	Declare AADAuthenticationFilter bean.
public live reload register ( final path path , final string ... includes ) { if ( files . exists ( path ) ) { paths . add ( new object [ ] { path , arrays . as list ( includes ) } ) ; } return this ; }	Add the given path to the watcher.
public map < string , list < file > > build ( final string dist , final file dir ) throws exception { log . debug ( str , dist , aggregators ) ; aggregators ( aggregators , conf ) ; return build internal ( dist , dir ) ; }	Build assets using the given distribution and write output to the provided directory.Build process is defined as follow:1.
private void register ( final path dir ) throws io { watch key key = dir . register ( watcher , new kind [ ] { entry create , entry delete , entry modify } , high ) ; keys . put ( key , dir ) ; }	Register the given directory with the WatchService.
public raml type new property ( string name , string type , boolean required , string ... values ) { if ( properties == null ) { properties = new linked hash map < > ( ) ; } if ( values . length > num ) { properties . put ( required ? name : name + str , immutable map . of ( str , values ) ) ; } else { properties . put ( required ? name : name + str , type ) ; } return this ; }	Defines a new property.
public static raml type value of ( string name ) { switch ( name . to lower case ( ) ) { case str : return boolean ; case str : case str : case str : case str : case str : return integer ; case str : case str : return number ; case str : case str : case str : return string ; case str : case str : case str : case str : return file ; case str : case str : case str : return date time ; } return new raml type ( str , name ) ; }	Get a RAML type from string.
public file event options kind ( final watch event . kind < path > kind ) { require non null ( kind , str ) ; kinds . add ( kind ) ; return this ; }	Append a kind filter.The default filter is: {.
public hbs do with ( final consumer < handlebars > callback ) { require non null ( callback , str ) ; return do with ( ( hbs , conf ) -> callback . accept ( hbs ) ) ; }	Set a handlebars callback. {.
public micrometer do with ( @ nonnull final consumer < composite meter registry > configurer ) { return do with ( ( registry , conf ) -> configurer . accept ( registry ) ) ; }	Advanced configuration of main registry.
public thl do with ( final consumer < template engine > callback ) { require non null ( callback , str ) ; return do with ( ( e , c ) -> callback . accept ( e ) ) ; }	Set a configuration callback. {.
public auth form ( final string pattern , final class < ? extends authenticator < username password credentials > > authenticator ) { bindings . put ( pattern , ( binder , conf ) -> { type literal < authenticator < username password credentials > > username password authenticator = new type literal < authenticator < username password credentials > > ( ) { } ; binder . bind ( username password authenticator . get raw type ( ) ) . to ( authenticator ) ; bind profile ( binder , common profile . class ) ; multibinder . new set binder ( binder , client . class ) . add binding ( ) . to provider ( form auth . class ) ; return new form filter ( conf . get string ( str ) , conf . get string ( str ) + auth callback path ( conf ) ) ; } ) ; return this ; }	Add a form auth client.
public auth basic ( final string pattern , final class < ? extends authenticator < username password credentials > > authenticator ) { bindings . put ( pattern , ( binder , config ) -> { type literal < authenticator < username password credentials > > username password authenticator = new type literal < authenticator < username password credentials > > ( ) { } ; binder . bind ( username password authenticator . get raw type ( ) ) . to ( authenticator ) ; bind profile ( binder , common profile . class ) ; multibinder . new set binder ( binder , client . class ) . add binding ( ) . to provider ( basic auth . class ) ; return new auth filter ( indirect basic auth client . class , common profile . class ) ; } ) ; return this ; }	Add a basic auth client.
public void resolve ( @ nullable final object value ) { if ( value == null ) { handler . handle ( null , null ) ; } else { result result ; if ( value instanceof result ) { super . set ( value ) ; result = ( result ) value ; } else { super . set ( value ) ; result = clone ( ) ; } handler . handle ( result , null ) ; } }	Resolve the deferred value and handle it.
public raml path path ( string pattern ) { raml path path = resources . get ( pattern ) ; if ( path == null ) { path = new raml path ( ) ; resources . put ( pattern , path ) ; } return path ; }	Get a path for the given pattern.
public raml type define ( type type ) { if ( types == null ) { types = new linked hash map < > ( ) ; } type component type = component type ( type ) ; string type name = more types . get raw type ( component type ) . get simple name ( ) ; raml type raml type = raml type . value of ( type name ) ; if ( raml type . is object ( ) ) { raml type existing = types . get ( type name ) ; if ( existing == null ) { model converters converter = model converters . get instance ( ) ; property property = converter . read as property ( component type ) ; map < property builder . property id , object > args = new enum map < > ( property builder . property id . class ) ; for ( map . entry < string , model > entry : converter . read all ( component type ) . entry set ( ) ) { define ( entry . get key ( ) , entry . get value ( ) ) ; } raml type = define ( type name , property builder . to model ( property builder . merge ( property , args ) ) ) ; } else { raml type = existing ; } } return type != component type ? raml type . to array ( ) : raml type ; }	Register a Java type and produces an equivalent RAML type.
public string to yaml ( ) throws io { yaml mapper = new yaml ( ) ; mapper . set serialization inclusion ( json include . include . non null ) ; mapper . configure ( yaml . feature . always quote numbers as strings , bool ) ; mapper . configure ( yaml . feature . minimize quotes , bool ) ; return str + mapper . writer ( ) . with default pretty printer ( ) . write value as string ( this ) ; }	Convert this RAML object to Yaml.
public map < integer , string > status ( ) { return optional . of nullable ( status ) . or else ( immutable map . of ( ) ) ; }	Get status codes.
public int status code ( ) { return status ( ) . entry set ( ) . stream ( ) . map ( it -> it . get key ( ) ) . filter ( code -> code >= num && code < num ) . find first ( ) . or else get ( ( ) -> type ( ) == void . class ? num : num ) ; }	Status code.
public route response status ( final map < integer , string > status ) { if ( status != null ) { if ( this . status == null ) { this . status = new linked hash map < > ( ) ; this . status . put all ( status ) ; } } return this ; }	Set status code map.
public void set media type ( final string media type , raml type body ) { if ( this . media type == null ) { this . media type = new linked hash map < > ( ) ; } this . media type . put ( media type , body ) ; }	Set media type.
static throwing . runnable run enhancer ( ) { return ( ) -> { set < string > packages = pkg . get and set ( null ) ; if ( packages != null ) { ebean enhancer . new enhancer ( ) . run ( packages ) ; } } ; }	package for test.
public void set media type ( final list < string > media type ) { this . media type = media type == null ? null : ( media type . is empty ( ) ? null : media type ) ; }	Set media types.
public raml parameter query parameter ( string name ) { if ( query parameters == null ) { query parameters = new linked hash map < > ( ) ; } raml parameter param = query parameters . get ( name ) ; if ( param == null ) { param = new raml parameter ( name ) ; query parameters . put ( name , param ) ; } return param ; }	Get or create a query parameter using the giving name.
public raml parameter form parameter ( string name ) { if ( form parameters == null ) { form parameters = new linked hash map < > ( ) ; } raml parameter param = form parameters . get ( name ) ; if ( param == null ) { param = new raml parameter ( name ) ; form parameters . put ( name , param ) ; } return param ; }	Get or create a form parameter using the giving name.
public raml parameter header parameter ( string name ) { if ( headers == null ) { headers = new linked hash map < > ( ) ; } raml parameter param = headers . get ( name ) ; if ( param == null ) { param = new raml parameter ( name ) ; headers . put ( name , param ) ; } return param ; }	Get or create a header parameter using the giving name.
public raml response response ( integer status ) { if ( responses == null ) { responses = new linked hash map < > ( ) ; } raml response response = responses . get ( status ) ; if ( response == null ) { response = new raml response ( ) ; responses . put ( status , response ) ; } return response ; }	Get or create a response using the given status code.
public hbv do with ( final consumer < hibernate validator configuration > configurer ) { require non null ( configurer , str ) ; this . configurer = ( hvc , conf ) -> configurer . accept ( hvc ) ; return this ; }	Setup a configurer callback.
@ override public int read ( final byte [ ] b , int off , int len ) throws io { int read = num ; while ( len > num ) { if ( encoder out . position ( ) > num ) { encoder out . flip ( ) ; int c = math . min ( encoder out . remaining ( ) , len ) ; encoder out . get ( b , off , c ) ; off += c ; len -= c ; read += c ; encoder out . compact ( ) ; } else { if ( ! end of input && ( last coder result == null || last coder result . is underflow ( ) ) ) { encoder in . compact ( ) ; int position = encoder in . position ( ) ;	Read the specified number of bytes into an array.
public static requery reactive ( final string name , final entity model model ) { return new requery ( name , reactive entity store . class , model , conf -> reactive support . to reactive store ( new entity data store < > ( conf ) ) ) ; }	Creates a Requery module with RxJava data store. {.
public static requery reactor ( final string name , final entity model model ) { return new requery ( name , reactor entity store . class , model , conf -> new reactor entity store < > ( new entity data store < > ( conf ) ) ) ; }	Creates a Requery module with Reactor data store. {.
public static requery completion stage ( final string name , final entity model model ) { return new requery ( name , completion stage entity store . class , model , conf -> new completable entity store ( new entity data store < > ( conf ) ) ) ; }	Creates an async Requery module with Java 8 data store. {.
public static requery kotlin ( final string name , final entity model model ) { return new requery ( name , kotlin entity data store . class , model , conf -> new kotlin entity data store < > ( conf ) ) ; }	Creates a Kotlin Requery module. {.
public xss js ( final java script escape type type , final java script escape level level ) { this . jslevel = require non null ( level , str ) ; this . jstype = require non null ( type , str ) ; return this ; }	Set JavaScript escape type and level.
public xss html ( final html escape type type , final html escape level level ) { this . htmllevel = require non null ( level , str ) ; this . htmltype = require non null ( type , str ) ; return this ; }	Set HTML escape type and level.
public xss json ( final json escape type type , final json escape level level ) { this . jsonlevel = require non null ( level , str ) ; this . jsontype = require non null ( type , str ) ; return this ; }	Set JSON escape type and level.
public xss css ( final css string escape type type , final css string escape level level ) { this . csslevel = require non null ( level , str ) ; this . csstype = require non null ( type , str ) ; return this ; }	Set CSS escape type and level.
private map < string , object > attrs ( final string path , final string ... without ) { map < string , object > attrs = new linked hash map < > ( get ( path ) ) ; arrays . as list ( without ) . for each ( attrs :: remove ) ; return attrs ; }	Read an object path and optionally filter some child paths.
private char sequence css ( final string id , final element svg ) { throwing . function < string , tuple < tuple < number , string > , tuple < number , string > > > view box = throwing . < string , tuple < tuple < number , string > , tuple < number , string > > > throwing function ( name -> { string vbox = svg . attr ( name ) ; string [ ] dimension = vbox . split ( str ) ; return new tuple ( parse ( dimension [ num ] ) , parse ( dimension [ 3 ] ) ) ; } ) . memoized ( ) ; tuple < number , string > w = optional . of nullable ( strings . empty to null ( svg . attr ( str ) ) ) . map ( this :: parse ) . or else get ( ( ) -> view box . apply ( str ) . 1 ) ; tuple < number , string > h = optional . of nullable ( strings . empty to null ( svg . attr ( str ) ) ) . map ( this :: parse ) . or else get ( ( ) -> view box . apply ( str ) . 2 ) ; string builder css = new string builder ( ) ; css . append ( get ( str ) . to string ( ) ) . append ( str ) . append ( id ) . append ( str ) . append ( w . 1 ) . append ( w . 2 ) . append ( str ) . append ( str ) . append ( h . 1 ) . append ( h . 2 ) . append ( str ) ; return css ; }	Generate a CSS rule, it reads the width and height attributes of the svg element or fallback toviewBox attribute.
private tuple < number , string > parse ( final string value ) { matcher matcher = size . matcher ( value ) ; if ( matcher . find ( ) ) { string number = matcher . group ( num ) ; string unit = matcher . group ( 3 ) ; boolean round = get ( str ) ; number num = double . parse double ( number ) ; return new tuple ( round ? math . round ( num . double value ( ) ) : num , unit ) ; } return null ; }	Parse a css size unit value, like 10px or 18.919px and optionally round the value to theclosest integer.
private void write ( final path path , final list < char sequence > sequence ) throws io { log . debug ( str , path . normalize ( ) . to absolute path ( ) ) ; path . to file ( ) . get parent file ( ) . mkdirs ( ) ; files . write ( path , sequence ) ; }	Write content to file.
public transactional request handle ( string name ) { this . handle key = key . get ( handle . class , names . named ( name ) ) ; return this ; }	Use a named key for accessing to the request scoped Handle.
private model do model ( type type , model model ) { map < string , property > properties = model . get properties ( ) ; if ( properties != null ) { bean description desc = json . mapper ( ) . get serialization config ( ) . introspect ( json . mapper ( ) . construct type ( type ) ) ; for ( bean property definition bean property : desc . find properties ( ) ) { property property = properties . get ( bean property . get name ( ) ) ; if ( property != null ) { property . set required ( bean property . is required ( ) ) ; } } } return model ; }	Mostly for kotlin null safe operator and immutable properties.
@ nonnull public < t > optional < t > last event id ( final class < t > type ) { return last event id . to optional ( type ) ; }	Server sent event will send a Last-Event-ID header if the server goes down.
@ nonnull public completable future < optional < object > > send ( final object data ) { return event ( data ) . send ( ) ; }	Send an event. {.
@ nonnull public view put ( final string name , final object value ) { require non null ( name , str ) ; model . put ( name , value ) ; return this ; }	Set a model attribute and override existing attribute.
@ nonnull public view put ( final map < string , ? > values ) { values . for each ( ( k , v ) -> model . put ( k , v ) ) ; return this ; }	Set model attributes and override existing values.
public static class loader class loader ( final class loader parent ) throws io { return class loader ( parent , new file ( system . get property ( str ) ) ) ; }	Constructs a new AssetClassLoader that includes the 'public' dir if present in the current working dir.
public static class loader class loader ( final class loader parent , file project dir ) throws io { require non null ( parent , str ) ; file public dir = new file ( project dir , str ) ; if ( public dir . exists ( ) ) { return new url ( new url [ ] { public dir . to uri ( ) . to url ( ) } , parent ) ; } return parent ; }	Constructs a new AssetClassLoader that includes the 'public' dir if present in the provided working dir.
public route method attributes ( map < string , object > attributes ) { if ( attributes != null ) { if ( this . attributes == null ) { this . attributes = new linked hash map < > ( ) ; } this . attributes . put all ( attributes ) ; } return this ; }	Set route attributes.
public route method attribute ( string name , object value ) { if ( this . attributes == null ) { this . attributes = new linked hash map < > ( ) ; } this . attributes . put ( name , value ) ; return this ; }	Set route attribute.
public route method param ( string name , consumer < route parameter > customizer ) { parameters ( ) . stream ( ) . filter ( p -> name . equals ( p . name ( ) ) ) . find first ( ) . if present ( customizer ) ; return this ; }	Find a parameter by name and invoke the given callback.
public static status value of ( final int status code ) { integer key = integer . value of ( status code ) ; status status = status map . get ( key ) ; return status == null ? new status ( key , key . to string ( ) ) : status ; }	Return the enum constant of this type with the specified numeric value.
public jdbi3 do with ( consumer < jdbi > configurer ) { return do with ( ( jdbi , conf ) -> configurer . accept ( jdbi ) ) ; }	Configurer a jdbi instance.
@ override public rewritten statement rewrite ( final string sql , final binding params , final statement context ctx ) { final parsed statement stmt = new parsed statement ( ) ; try { final string parsed sql = parse string ( sql , stmt , params ) ; return new my rewritten statement ( parsed sql , stmt , ctx ) ; } catch ( illegal argument exception e ) { throw new unable to create statement exception ( str , e , ctx ) ; } }	Munge up the SQL as desired.
protected void send ( final request req , final response rsp , final asset asset ) throws throwable { rsp . send ( asset ) ; }	Send an asset to the client.
public jdbi do with ( consumer < dbi > configurer ) { return do with ( ( dbi , conf ) -> configurer . accept ( dbi ) ) ; }	Configure DBI instance.
public j ooq do with ( consumer < configuration > configurer ) { return do with ( ( configuration , conf ) -> configurer . accept ( configuration ) ) ; }	Configuration callback.
public quartz with ( final job detail job , final trigger trigger ) { require non null ( job , str ) ; require non null ( trigger , str ) ; job map . put ( job , trigger ) ; return this ; }	Schedule the provided job and trigger.
public quartz with ( final class < ? extends job > job class , final bi consumer < job builder , trigger builder < trigger > > configurer ) { require non null ( job class , str ) ; job builder job = job builder . new job ( job class ) . with identity ( job key . job key ( job class . get simple name ( ) , job class . get package ( ) . get name ( ) ) ) ; trigger builder < trigger > trigger = trigger builder . new trigger ( ) . with identity ( trigger key . trigger key ( job class . get simple name ( ) , job class . get package ( ) . get name ( ) ) ) ; configurer . accept ( job , trigger ) ; return with ( job . build ( ) , trigger . build ( ) ) ; }	Schedule the provided job and trigger.
private void shutdown gracefully ( final iterator < event executor group > iterator ) { if ( iterator . has next ( ) ) { event executor group group = iterator . next ( ) ; if ( ! group . is shutting down ( ) ) { group . shutdown gracefully ( ) . add listener ( future -> { if ( ! future . is success ( ) ) { log . debug ( str , group , future . cause ( ) ) ; } shutdown gracefully ( iterator ) ; } ) ; } } }	Shutdown executor in order.
public cassandra do with cluster ( final consumer < cluster > configurer ) { require non null ( configurer , str ) ; return do with cluster ( ( cc , c ) -> configurer . accept ( cc ) ) ; }	Configure a cluster after creation.
@ nonnull public static result with ( final status status ) { require non null ( status , str ) ; return new result ( ) . status ( status ) ; }	Set the response status.
public jackson module ( final module module ) { require non null ( module , str ) ; modules . add ( binder -> binder . add binding ( ) . to instance ( module ) ) ; return this ; }	Register the provided module.
public pac4j unauthenticated ( supplier < user profile > provider ) { require non null ( provider , str ) ; return unauthenticated ( req -> provider . get ( ) ) ; }	Set a default action which is execute when no user is logged in. {.
public pac4j form ( string pattern ) { return client internal ( pattern , conf -> { show dev login = bool ; return new form client ( str , new simple test username password authenticator ( ) ) ; } , null ) ; }	Add a simple login form.
public list < route method > parse ( string application ) throws exception { return new bytecode route parser ( loader , dir ) . parse ( application ) . stream ( ) . filter ( filter ) . collect ( collectors . to list ( ) ) ; }	Parse application bytecode and build route methods from it.
public scanner scan ( final class < ? > type ) {	Add a scan criteria like an annotation, interface or class.
public api tool swagger ( string path , consumer < swagger > swagger ) { return swagger ( new options ( path , options ) , swagger ) ; }	Mount Swagger at the given path and customize Swagger objects.
public api tool swagger ( options options , consumer < swagger > swagger ) { this . swagger options = objects . require non null ( options , str ) ; this . swagger = swagger ; return this ; }	Mount Swagger using the given options.
public api tool raml ( string path , consumer < raml > raml ) { return raml ( new options ( path , options ) , raml ) ; }	Mount RAML at the given path and customize RAML objects.
public api tool raml ( options options , consumer < raml > raml ) { this . raml options = objects . require non null ( options , str ) ; this . raml = raml ; return this ; }	Mount RAML using the given options.
public string process ( string filename , string source , config conf ) throws exception { return process ( filename , source , conf , get class ( ) . get class loader ( ) ) ; }	Method that processes the provided source and returns the processed contents.
public void receive resultcte recepcao os ( com . fincatto . documentofiscal . cte300 . webservices . recepcao os . os . os result ) { }	auto generated Axis2 call back method for cteRecepcaoOS methodoverride this method for handling normal response from cteRecepcaoOS operation.
public void receive resultmdfe recepcao lote ( com . fincatto . documentofiscal . mdfe3 . webservices . recepcao . md . mdfe recepcao lote result result ) { }	auto generated Axis2 call back method for mdfeRecepcaoLote methodoverride this method for handling normal response from mdfeRecepcaoLote operation.
public void receive resultcte inutilizacao ct ( com . fincatto . documentofiscal . cte300 . webservices . inutilizacao . cte inutilizacao stub . ct result ) { }	auto generated Axis2 call back method for cteInutilizacaoCT methodoverride this method for handling normal response from cteInutilizacaoCT operation.
public void receive resultmdfe recepcao evento ( com . fincatto . documentofiscal . mdfe3 . webservices . recepcaoevento . md . mdfe recepcao evento result result ) { }	auto generated Axis2 call back method for mdfeRecepcaoEvento methodoverride this method for handling normal response from mdfeRecepcaoEvento operation.
public void receive resultcte consulta ct ( com . fincatto . documentofiscal . cte300 . webservices . consulta . cte consulta stub . ct result ) { }	auto generated Axis2 call back method for cteConsultaCT methodoverride this method for handling normal response from cteConsultaCT operation.
public void receive resultmdfe cons nao enc ( com . fincatto . documentofiscal . mdfe3 . webservices . consultanaoencerrado . md . mdfe cons nao enc result result ) { }	auto generated Axis2 call back method for mdfeConsNaoEnc methodoverride this method for handling normal response from mdfeConsNaoEnc operation.
@ suppress warnings ( str ) private org . apache . axiom . soap . soap to envelope ( final org . apache . axiom . soap . soap factory ) { return factory . get default envelope ( ) ; }	get the default envelope.
private java . util . map get envelope namespaces ( final org . apache . axiom . soap . soap env ) { final java . util . map return map = new java . util . hash map ( ) ; final java . util . iterator namespace iterator = env . get all declared namespaces ( ) ; while ( namespace iterator . has next ( ) ) { final org . apache . axiom . om . om ns = ( org . apache . axiom . om . om ) namespace iterator . next ( ) ; return map . put ( ns . get prefix ( ) , ns . get namespace uri ( ) ) ; } return return map ; }	A utility method that copies the namepaces from the SOAPEnvelope.
public void receive resultnfe consulta nf ( com . fincatto . documentofiscal . nfe310 . webservices . nota . consulta . nfe consulta stub . nf result ) { }	auto generated Axis2 call back method for nfeConsultaNF methodoverride this method for handling normal response from nfeConsultaNF operation.
nf get lote assinado ( final nf lote ) throws exception {	Retorna o Lote assinado.
public nf envia lote ( final nf lote ) throws exception { if ( lote . get indicador processamento ( ) . equals ( nf . processamento sincrono ) && lote . get notas ( ) . size ( ) > num ) { throw new illegal argument exception ( str ) ; } else if ( lote . get notas ( ) . size ( ) == num ) { throw new illegal argument exception ( str ) ; } return this . ws lote envio . envia lote ( lote ) ; }	Faz o envio de lote para a Sefaz.
public nf consulta status ( final df uf , final df modelo ) throws exception { return this . ws status consulta . consulta status ( uf , modelo ) ; }	Faz a consulta de status responsavel pela UF.
public nf corrige nota ( final string chave de acesso , final string texto correcao , final int numero sequencial evento ) throws exception { return this . ws carta correcao . corrige nota ( chave de acesso , texto correcao , numero sequencial evento ) ; }	Faz a correcao da nota.
public nf cancela nota ( final string chave , final string numero protocolo , final string motivo ) throws exception { return this . ws cancelamento . cancela nota ( chave , numero protocolo , motivo ) ; }	Faz o cancelamento da nota.
public nf inutiliza nota ( final int ano inutilizacao numeracao , final string cnpj emitente , final string serie , final string numero inicial , final string numero final , final string justificativa , final df modelo ) throws exception { return this . ws inutilizacao . inutiliza nota ( ano inutilizacao numeracao , cnpj emitente , serie , numero inicial , numero final , justificativa , modelo ) ; }	Inutiliza a nota.
public nf consulta cadastro ( final string cnpj , final df uf ) throws exception { return this . ws consulta cadastro . consulta cadastro ( cnpj , uf ) ; }	Realiza a consulta de cadastro de pessoa juridica com inscricao estadual.
public void receive resultcte recepcao lote ( com . fincatto . documentofiscal . cte300 . webservices . recepcao . cte recepcao stub . cte recepcao lote result result ) { }	auto generated Axis2 call back method for cteRecepcaoLote methodoverride this method for handling normal response from cteRecepcaoLote operation.
public void receive resultcte ret recepcao ( com . fincatto . documentofiscal . cte300 . webservices . retrecepcao . cte ret recepcao stub . cte ret recepcao result result ) { }	auto generated Axis2 call back method for cteRetRecepcao methodoverride this method for handling normal response from cteRetRecepcao operation.
public string get xml assinado ( final string chave acesso , final string texto correcao , final int numero sequencial evento ) throws exception { final string carta correcao xml = this . gerar dados carta correcao ( chave acesso , texto correcao , numero sequencial evento ) . to string ( ) ; return new assinatura digital ( this . config ) . assinar documento ( carta correcao xml ) ; }	Retorna XML assinado para uso externo.
public void receive resultcte recepcao evento ( com . fincatto . documentofiscal . cte300 . webservices . recepcaoevento . recepcao evento stub . cte recepcao evento result result ) { }	auto generated Axis2 call back method for cteRecepcaoEvento methodoverride this method for handling normal response from cteRecepcaoEvento operation.
public c cancela nota ( final string chave , final string numero protocolo , final string motivo ) throws exception { return this . ws cancelamento . cancela nota ( chave , numero protocolo , motivo ) ; }	Faz o cancelamento do CTe.
public void receive resultmdfe consulta mdf ( com . fincatto . documentofiscal . mdfe3 . webservices . consulta . md . mdf result ) { }	auto generated Axis2 call back method for mdfeConsultaMDF methodoverride this method for handling normal response from mdfeConsultaMDF operation.
public void receive resultmdfe ret recepcao ( com . fincatto . documentofiscal . mdfe3 . webservices . retornorecepcao . md . mdfe ret recepcao result result ) { }	auto generated Axis2 call back method for mdfeRetRecepcao methodoverride this method for handling normal response from mdfeRetRecepcao operation.
public md cancela mdfe ( final string chave , final string numero protocolo , final string motivo ) throws exception { return this . ws cancelamento . cancela nota ( chave , numero protocolo , motivo ) ; }	Faz o cancelamento do MDFe.
public md encerramento assinado ( final string chave acesso , final string evento assinado xml ) throws exception { return this . ws encerramento . encerramento mdfe assinado ( chave acesso , evento assinado xml ) ; }	Faz o encerramento do MDFe assinado.
public void receive resultmdfe status servico mdf ( com . fincatto . documentofiscal . mdfe3 . webservices . statusservico . md . mdf result ) { }	auto generated Axis2 call back method for mdfeStatusServicoMDF methodoverride this method for handling normal response from mdfeStatusServicoMDF operation.
private om efetua consulta status bahia ( final om om element ) throws remote exception { final nfe status servico stub . nfe cabec msg cabec = new nfe status servico stub . nfe cabec msg ( ) ; cabec . set cuf ( df . ba . get codigo ibge ( ) ) ; cabec . set versao dados ( this . config . get versao ( ) ) ; final nfe status servico stub . e cabec env = new nfe status servico stub . e ( ) ; cabec env . set nfe cabec msg ( cabec ) ; final nfe status servico stub . nfe dados msg dados = new nfe status servico stub . nfe dados msg ( ) ; dados . set extra element ( om element ) ; final nf autorizador = nf . value of codigo uf ( df . ba ) ; final string endpoint = autorizador . get nfe status servico ( this . config . get ambiente ( ) ) ; if ( endpoint == null ) { throw new illegal argument exception ( str + df . nfe . name ( ) + str + autorizador . name ( ) + str + df . ba . name ( ) ) ; } return new nfe status servico stub ( endpoint ) . nfe status servico nf ( dados , cabec env ) . get extra element ( ) ; }	este metodo teve que ser implementado pois a Bahia trata de forma diferente.
public static double cosine similarity ( float [ ] x , float [ ] y , double norm y ) { int length = x . length ; double dot = num ; double total x = num ; for ( int i = num ; i < length ; i ++ ) { double xi = x [ i ] ; total x += xi * xi ; dot += xi * y [ i ] ; } return dot / ( math . sqrt ( total x ) * norm y ) ; }	Computes cosine similarity of values in two given arrays, when the norm of one array isknown in advance, which is a not-uncommon case.
public void compute ( ) {	Proactively try to compute the solver asynchronously, if not already computed.Does not block.
public static void delete recursively ( path root dir ) throws io { if ( root dir == null || ! files . exists ( root dir ) ) { return ; } files . walk file tree ( root dir , new simple file visitor < path > ( ) { @ override public file visit result visit file ( path file , basic file attributes attrs ) throws io { files . delete ( file ) ; return file visit result . continue ; } @ override public file visit result post visit directory ( path dir , io exc ) throws io { files . delete ( dir ) ; return file visit result . continue ; } } ) ; }	Deletes the given path, and if it is a directory, all files and subdirectories within it.
public static < t > t load instance of ( string impl class name , class < t > super class , class < ? > [ ] constructor types , object [ ] constructor args ) { try { class < ? extends t > config class = load class ( impl class name , super class ) ; constructor < ? extends t > constructor = config class . get constructor ( constructor types ) ; return constructor . new instance ( constructor args ) ; } catch ( no such method exception | instantiation exception | illegal access exception e ) { throw new illegal argument exception ( str + super class + str , e ) ; } catch ( invocation target exception ite ) { throw new illegal state exception ( str + super class + str , ite . get cause ( ) ) ; } }	Loads and instantiates a named implementation class, a subclass of a given supertype,whose constructor takes the given arguments.
public void publish additional model data ( java spark context spark context , pmml pmml , rdd < m > new data , rdd < m > past data , path model parent path , topic producer < string , string > model update topic ) {	Optionally, publish additional model-related information to the update topic,after the model has been written.
public void open custom tab ( final context context , final custom tabs intent custom tabs intent , final uri uri , custom tab fallback fallback ) { final string package name = get package name to use ( context ) ; if ( package name != null ) { final custom tabs service connection connection = new custom tabs service connection ( ) { @ override public void on custom tabs service connected ( component name component name , custom tabs client client ) { client . warmup ( num ) ;	Opens the URL on a Custom Tab if possible.
@ nullable public string get package name to use ( context context ) { if ( package name to use != null ) return package name to use ; package manager pm = context . get package manager ( ) ;	Goes through all apps that handle VIEW intents and have a warmup service.
private boolean has specialized handler intents ( context context , intent intent ) { try { package manager pm = context . get package manager ( ) ; list < resolve info > handlers = pm . query intent activities ( intent , package manager . get resolved filter ) ; if ( handlers == null || handlers . size ( ) == num ) { return bool ; } for ( resolve info resolve info : handlers ) { intent filter filter = resolve info . filter ; if ( filter == null ) continue ; if ( filter . count data authorities ( ) == num || filter . count data paths ( ) == num ) continue ; if ( resolve info . activity info == null ) continue ; return bool ; } } catch ( runtime exception e ) { log . e ( tag , str ) ; } return bool ; }	Used to check whether there is a specialized handler for a given intent.
private void load ( ) { access token access token = access token storage . get access token ( ) ; if ( access token != null ) { access token session session = new access token session ( session configuration , access token storage ) ; ride request view . set session ( session ) ; load ride request view ( ) ; } else { login ( ) ; } }	Loads the appropriate view in the activity based on whether user is successfully authorized or not.
public void execute ( ) { final custom tabs intent intent = new custom tabs intent . builder ( ) . build ( ) ; custom tabs helper . open custom tab ( context , intent , uri , new custom tabs helper . browser fallback ( ) ) ; }	Executes the deeplink to launch the Uber app.
private void validate configuration ( session configuration configuration ) { string null error = str ; string sample error = str + str + str ; check not null ( configuration , string . format ( null error , str ) ) ; check not null ( configuration . get client id ( ) , string . format ( null error , str ) ) ; check not null ( configuration . get redirect uri ( ) , string . format ( null error , str ) ) ; check state ( ! configuration . get client id ( ) . equals ( str ) , string . format ( sample error , str ) ) ; check state ( ! configuration . get redirect uri ( ) . equals ( str ) , string . format ( sample error , str ) ) ; }	Validates the local variables needed by the Uber SDK used in the sample project.
public static intent new response intent ( context context , uri response uri ) { intent intent = new intent ( context , login activity . class ) ; intent . set data ( response uri ) ; intent . add flags ( intent . flag activity clear top | intent . flag activity single top ) ; return intent ; }	Used to handle Redirect URI response from customtab or browser.
public boolean edit map ( configuration handler configuration handler ) { string method = configuration handler . get method ( ) . to upper case ( ) ; if ( configuration handler map . contains key ( method . value of ( method ) ) ) { configuration handler map . put ( method . value of ( method ) , configuration handler ) ; return bool ; } return bool ; }	Edit representation for method specified in sent parameter after controller calls for it.
public static void main ( string [ ] args ) { if ( args . length != num ) { system . err . println ( str ) ; system . exit ( num ) ; } int num tasks = num ; int num iters = num ; blocking queue < task request > task queue = new linked blocking queue < > ( ) ; final task generator task generator = new task generator ( task queue , num iters , num tasks ) ; final sample framework framework = new sample framework ( task queue , args [ num ] ,	Main method to run the task generator.
public void shutdown ( ) { system . out . println ( str ) ; protos . status status = mesos scheduler driver . stop ( ) ; is shutdown . set ( bool ) ; }	Shuts down the Mesos driver.
@ override public result evaluate ( task request task request , virtual machine current state target vm , task tracker state task tracker state ) { collection < task request > running tasks = target vm . get running tasks ( ) ; if ( running tasks != null && ! running tasks . is empty ( ) ) return new result ( bool , str + running tasks . size ( ) + str ) ; collection < task assignment result > tasks currently assigned = target vm . get tasks currently assigned ( ) ; if ( tasks currently assigned != null && ! tasks currently assigned . is empty ( ) ) return new result ( bool , str + tasks currently assigned . size ( ) + str ) ; return new result ( bool , str ) ; }	Determines whether the prospective host already has tasks either running on it or assigned to be run onit, and returns a false Result if either of those things is the case.
@ override public result evaluate ( task request task request , virtual machine current state target vm , task tracker state task tracker state ) { string target host attr val = get attr value ( target vm . get curr available resources ( ) ) ; if ( target host attr val == null || target host attr val . is empty ( ) ) { return new result ( bool , host attribute name + str + target vm . get curr available resources ( ) . hostname ( ) ) ; } string required attr val = host attribute value getter . call ( task request . get id ( ) ) ; return target host attr val . equals ( required attr val ) ? new result ( bool , str ) : new result ( bool , str + host attribute name + str + required attr val + str + target host attr val ) ; }	Tests a host to determine whether it has an attribute of the required value for this task request.
public void set autoscaler callback ( action1 < auto scale action > callback ) throws illegal state exception { check if shutdown ( ) ; if ( auto scaler == null ) { throw new illegal state exception ( str ) ; } auto scaler . set callback ( callback ) ; }	Set the autoscale call back action.
public void disable vm ( string hostname , long duration millis ) throws illegal state exception { logger . debug ( str + hostname + str + duration millis + str ) ; assignable v . disable until ( hostname , system . current time millis ( ) + duration millis ) ; }	Disable the virtual machine with the specified hostname.
public boolean disable vm vm ( string vm id , long duration millis ) throws illegal state exception { final string hostname = assignable v . get hostname from vm ( vm id ) ; if ( hostname == null ) { return bool ; } disable vm ( hostname , duration millis ) ; return bool ; }	Disable the virtual machine with the specified ID.
public void enable vm ( string hostname ) throws illegal state exception { logger . debug ( str + hostname ) ; assignable v . enable vm ( hostname ) ; }	Enable the VM with the specified host name.
public void shutdown ( ) { if ( is shutdown . compare and set ( bool , bool ) ) { executor service . shutdown ( ) ; if ( auto scaler != null ) { auto scaler . shutdown ( ) ; } } }	Mark task scheduler as shutdown and shutdown any thread pool executors created.
public boolean has properties ( string ... properties ) { for ( string property : properties ) { if ( ! has property ( property ) ) { return bool ; } } return bool ; }	Check if this entity contains all of the given properties.
public static demo . c info for source ( final source source ) throws io { engine type engine type = source . read engine type ( ) ; source . set position ( source . read fixed int32 ( ) ) ; packet instance < generated message > pi = engine type . get next packet instance ( source ) ; return ( demo . c ) pi . parse ( ) ; }	Retrieves summary-data from the given input source.
private static s2 dota match metadata . cdota metadata for stream ( input stream stream ) throws io { return packet . parse ( s2 dota match metadata . cdota . class , byte string . read from ( stream ) ) ; }	reads a metadata stream and returns it's contents.
private byte [ ] read packet ( source source ) throws io { int size = source . read fixed int32 ( ) ; return packet reader . read from source ( source , size , bool ) ; }	alternative to 6? Similar to dota?.
public int read var int32 ( ) throws io { byte tmp = read byte ( ) ; if ( tmp >= num ) { return tmp ; } int result = tmp & num ; if ( ( tmp = read byte ( ) ) >= num ) { result |= tmp << num ; } else { result |= ( tmp & num ) << num ; if ( ( tmp = read byte ( ) ) >= num ) { result |= tmp << num ; } else { result |= ( tmp & num ) << num ; if ( ( tmp = read byte ( ) ) >= num ) { result |= tmp << num ; } else { result |= ( tmp & num ) << num ; result |= ( tmp = read byte ( ) ) << num ; if ( tmp < num ) { throw new io ( str ) ; } } } } return result ; }	reads a variable int32 from the current position.
public int read fixed int32 ( ) throws io { return byte buffer . wrap ( read bytes ( num ) ) . order ( byte order . little endian ) . as int buffer ( ) . get ( ) ; }	reads a fixed int32 from the current position.
public engine type read engine type ( ) throws io { try { engine type = engine id . type for magic ( new string ( read bytes ( num ) ) ) ; if ( engine type == null ) { throw new io ( ) ; } return engine type ; } catch ( io e ) { throw new io ( str ) ; } }	reads the magic of a demo file, identifying the engine type.
public container tag with ( dom content child ) { if ( this == child ) { throw new runtime exception ( str ) ; } if ( child == null ) { return this ;	Appends a DomContent-object to the end of this element.
public container tag with ( iterable < ? extends dom content > children ) { if ( children != null ) { for ( dom content child : children ) { this . with ( child ) ; } } return this ; }	Appends a list of DomContent-objects to the end of this element.
@ suppress warnings ( str ) public static < t , u > t iff ( optional < u > optional , function < u , t > if function ) { if ( objects . non null ( optional ) && optional . is present ( ) ) { return optional . map ( if function ) . or else ( null ) ; } return null ; }	Generic if-expression to if'ing inside method calls.
public static string document ( container tag html tag ) { if ( html tag . get tag name ( ) . equals ( str ) ) { return document ( ) . render ( ) + html tag . render ( ) ; } throw new illegal argument exception ( str ) ; }	Return a complete html document string.
boolean set attribute ( string name , string value ) { if ( value == null ) { return attributes . add ( new attribute ( name ) ) ; } for ( attribute attribute : attributes ) { if ( attribute . get name ( ) . equals ( name ) ) { attribute . set value ( value ) ;	Sets an attribute on an element.
public t attr ( string attribute , object value ) { set attribute ( attribute , value == null ? null : string . value of ( value ) ) ; return ( t ) this ; }	Sets a custom attribute.
public t attr ( attribute attribute ) { iterator < attribute > iterator = attributes . iterator ( ) ; string name = attribute . get name ( ) ; if ( name != null ) {	Adds the specified attribute.
public t with classes ( string ... classes ) { string builder sb = new string builder ( ) ; for ( string s : classes ) { sb . append ( s != null ? s : str ) . append ( str ) ; } return attr ( attr . class , sb . to string ( ) . trim ( ) ) ; }	Convenience methods that call attr with predefined attributes.
public static string compress js ( string code ) { input stream in stream = new byte array input stream ( code . get bytes ( ) ) ; byte array output stream out stream = new byte array output stream ( ) ; js jsmin = new js ( in stream , out stream ) ; try { jsmin . jsmin ( ) ; return out stream . to string ( ) . trim ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; return str ; } }	Compress a JS-string.
private array list < property > parse properties ( string contents ) { array list < string > parts = new array list < > ( ) ; boolean b inside string = bool , b inside url = bool ; int j = num ; string substr ; for ( int i = num ; i < contents . length ( ) ; i ++ ) { if ( b inside string ) {	Parses out the properties of a selector's body.
private part [ ] parse values ( string contents ) { string [ ] parts = contents . split ( str ) ; part [ ] results = new part [ parts . length ] ; for ( int i = num ; i < parts . length ; i ++ ) { try { results [ i ] = new part ( parts [ i ] , property ) ; } catch ( exception e ) { log . warning ( e . get message ( ) ) ; results [ i ] = null ; } } return results ; }	Parse the values out of a property.
private void handle on visible menu items width changed ( int menu items width ) { if ( menu items width == num ) { m clear button . set translation x ( - util . dp to px ( num ) ) ; int padding right = util . dp to px ( num ) ; if ( m is focused ) { padding right += util . dp to px ( clear btn width dp ) ; } else { padding right += util . dp to px ( num ) ; } m search input . set padding ( num , num , padding right , num ) ; } else { m clear button . set translation x ( - menu items width ) ; int padding right = menu items width ; if ( m is focused ) { padding right += util . dp to px ( clear btn width dp ) ; } m search input . set padding ( num , num , padding right , num ) ; } }	ensures that the end margin of the search input is according to Material specs.
public void set left action icon color ( int color ) { m left action icon color = color ; m menu btn drawable . set color ( color ) ; drawable compat . set tint ( m icon back arrow , color ) ; drawable compat . set tint ( m icon search , color ) ; }	Sets the menu button's color.
public void set background color ( int color ) { m background color = color ; if ( m query section != null && m suggestions list != null ) { m query section . set card background color ( color ) ; m suggestions list . set background color ( color ) ; } }	Sets the background color of the searchview including the suggestions section.
public void open menu ( boolean with anim ) { m menu open = bool ; open menu drawable ( m menu btn drawable , with anim ) ; if ( m on menu click listener != null ) { m on menu click listener . on menu opened ( ) ; } }	Mimics a menu click that opens the menu.
public void close menu ( boolean with anim ) { m menu open = bool ; close menu drawable ( m menu btn drawable , with anim ) ; if ( m on menu click listener != null ) { m on menu click listener . on menu closed ( ) ; } }	Mimics a menu click that closes.
public void inflate overflow menu ( int menu id ) { m menu id = menu id ; m menu view . reset ( menu id , action menu avail width ( ) ) ; if ( m is focused ) { m menu view . hide if room items ( bool ) ; } }	Inflates the menu items froman xml resource.
public void set show search key ( boolean show ) { m show search key = show ; if ( show ) { m search input . set ime options ( editor info . ime action search ) ; } else { m search input . set ime options ( editor info . ime action none ) ; } }	Sets whether the the button with the search iconwill appear in the soft-keyboard or not.
public void set dismiss on outside click ( boolean enable ) { m dismiss on outside touch = enable ; m suggestions section . set on touch listener ( new on touch listener ( ) { @ override public boolean on touch ( view v , motion event event ) {	Set whether a touch outside of thesearch bar's bounds will cause the search bar toloos focus.
public boolean set search focused ( final boolean focused ) { boolean updated to not focused = ! focused && this . m is focused ; if ( ( focused != this . m is focused ) && m suggestion sec height listener == null ) { if ( m is suggestions section height set ) { set search focused internal ( focused ) ; } else { m suggestion sec height listener = new on suggestion sec height set listener ( ) { @ override public void on suggestion sec height set ( ) { set search focused internal ( focused ) ; m suggestion sec height listener = null ; } } ; } } return updated to not focused ; }	Sets whether the search is focused or not.
private boolean update suggestions section height ( list < ? extends search suggestion > new search suggestions , boolean with anim ) { final int card top bottom shadow padding = util . dp to px ( card view corners and top bottom shadow height ) ; final int card radius size = util . dp to px ( card view top bottom shadow height ) ; int visible suggestion height = calculate suggestion items height ( new search suggestions , m suggestion list container . get height ( ) ) ; int diff = m suggestion list container . get height ( ) - visible suggestion height ; int added translation y = ( diff <= card top bottom shadow padding ) ? - ( card top bottom shadow padding - diff ) : diff < ( m suggestion list container . get height ( ) - card top bottom shadow padding ) ? card radius size : num ; final float new translation y = - m suggestion list container . get height ( ) + visible suggestion height + added translation y ;	returns true if the suggestion items occupy the full RecyclerView's height, false otherwise.
private int calculate suggestion items height ( list < ? extends search suggestion > suggestions , int max ) {	results is >= max.
public void set on bind suggestion callback ( search suggestions adapter . on bind suggestion callback callback ) { this . m on bind suggestion callback = callback ; if ( m suggestions adapter != null ) { m suggestions adapter . set on bind suggestion callback ( m on bind suggestion callback ) ; } }	Set a callback that will be called after each suggestion view in the suggestions recyclerlist is bound.
public static string get m ( string filename ) { try { byte [ ] b = create checksum ( filename ) ; string result = str ; for ( int i = num ; i < b . length ; i ++ ) { result += integer . to string ( ( b [ i ] & num ) + num , num ) . substring ( num ) ; } return result ; } catch ( exception e ) { return str ; } }	a byte array to a HEX string.
public static ok http client . builder configure to ignore certificate ( ok http client . builder builder ) { log . warn ( str ) ; try { final trust manager [ ] trust all certs = new trust manager [ ] { new x509 trust manager ( ) { @ override public void check client trusted ( java . security . cert . x509 certificate [ ] chain , string auth type ) { } @ override public void check server trusted ( java . security . cert . x509 certificate [ ] chain , string auth type ) { } @ override public java . security . cert . x509 certificate [ ] get accepted issuers ( ) { return new java . security . cert . x509 certificate [ ] { } ; } } } ; final ssl ssl context = ssl . get instance ( str ) ; ssl context . init ( null , trust all certs , new java . security . secure random ( ) ) ; final ssl ssl socket factory = ssl context . get socket factory ( ) ; builder . ssl socket factory ( ssl socket factory , ( x509 trust manager ) trust all certs [ num ] ) ; builder . hostname verifier ( new hostname verifier ( ) { @ override public boolean verify ( string hostname , ssl session ) { return bool ; } } ) ; } catch ( exception e ) { log . warn ( str + e , e ) ; } return builder ; }	Setting testMode configuration. If set as testMode, the connection will skip certification check.
@ suppress warnings ( str ) @ override public t read ( json reader in ) throws io { list < exception > exceptions = new array list < > ( subtypes . length ) ; reader supplier reader supplier = read for supplier ( in ) ; for ( type adapter < ? > type adapter : adapters ) { try { return ( t ) type adapter . read ( reader supplier . create ( ) ) ; } catch ( exception ex ) { exceptions . add ( ex ) ; } } json parse exception failure = new json parse exception ( string . format ( str , type , arrays . to string ( subtypes ) ) ) ; for ( exception exception : exceptions ) { failure . add suppressed ( exception ) ; } throw failure ; }	enforced by constructor parameters.
@ value . lazy public name forms type abstract ( ) { if ( protoclass ( ) . kind ( ) . is constructor ( ) ) { return type value ( ) ; } list < string > class segments = lists . new array list with expected size ( num ) ; element e = source names . collect class segments ( protoclass ( ) . source element ( ) , class segments ) ; verify ( e instanceof package element ) ; string package of = ( ( package element ) e ) . get qualified name ( ) . to string ( ) ; string relative = dot joiner . join ( class segments ) ; boolean relative already qualified = bool ; if ( ! implementation package ( ) . equals ( package of ) ) { relative = dot joiner . join ( package of , relative ) ; relative already qualified = bool ; } return immutable constitution . name forms . builder ( ) . simple ( names ( ) . type abstract ) . relative raw ( relative ) . package of ( package of ) . generic args ( generics ( ) . args ( ) ) . relative already qualified ( relative already qualified ) . visibility ( protoclass ( ) . visibility ( ) ) . build ( ) ; }	Actual abstract value type that is definitive model for the value type.
private string in package ( string top level , string ... nested ) { return dot joiner . join ( null , top level , ( object [ ] ) nested ) ; }	Package relative path.
@ value . lazy public name forms type immutable ( ) { string simple , relative ; if ( protoclass ( ) . kind ( ) . is nested ( ) ) { string enclosing simple name = type immutable enclosing simple name ( ) ; simple = names ( ) . type immutable nested ( ) ; relative = in package ( enclosing simple name , simple ) ; } else if ( has immutable in builder ( ) ) { simple = names ( ) . type immutable ; relative = in package ( type builder simple name ( ) , simple ) ; } else { simple = names ( ) . type immutable ; relative = in package ( simple ) ; } return immutable constitution . name forms . builder ( ) . simple ( simple ) . relative raw ( relative ) . generic args ( generics ( ) . args ( ) ) . package of ( implementation package ( ) ) . visibility ( implementation visibility ( ) ) . build ( ) ; }	Actual immutable value type generated implementation.
@ suppress warnings ( str ) @ override @ nullable public < t > type adapter < t > create ( gson gson , type token < t > type ) { if ( id type token . equals ( type ) ) { return ( type adapter < t > ) wrapped id adapter ; } if ( time instant type token . equals ( type ) ) { return ( type adapter < t > ) wrapped time instant adapter ; } if ( binary type token . equals ( type ) ) { return ( type adapter < t > ) wrapped binary adapter ; } if ( pattern type token . equals ( type ) ) { return ( type adapter < t > ) pattern adapter ; } if ( decima type token . equals ( type ) ) { return ( type adapter < t > ) decima adapter ; } return null ; }	safe unchecked, typecheck performed by type token equality.
@ suppress warnings ( str ) public static < e extends ordinal value < e > > immutable ordinal set < e > of ( ) {	Returns singleton empty immutable ordinal set.
@ override public iterator < e > iterator ( ) { return new abstract iterator < e > ( ) { private final int length = length ( ) ; private int index = num ; @ override protected e compute next ( ) { int p = index ++ ; if ( p < length ) { return get ( p ) ; } return end of data ( ) ; } } ; }	Iterator over all present inhabitants of ordinal domain.
private static string caching key ( value attribute value attribute ) { return string . format ( str , value attribute . contained type element . get qualified name ( ) , joiner . on ( str ) . join ( value attribute . containing type . constitution . style ( ) . attribute builder ( ) ) ) ; }	The same class included in two parents, may or may not be nested builders based on that discovery pattern.
public string get serialized name ( ) { if ( serialized name == null ) { optional < serialized name mirror > serialized name annotation = serialized name mirror . find ( element ) ; if ( serialized name annotation . is present ( ) ) { serialized name mirror m = serialized name annotation . get ( ) ; serialized name = m . value ( ) ; alternate serialized names = m . alternate ( ) ; return serialized name ; } optional < named mirror > named annotation = named mirror . find ( element ) ; if ( named annotation . is present ( ) ) { string value = named annotation . get ( ) . value ( ) ; if ( ! value . is empty ( ) ) { serialized name = value ; return serialized name ; } } optional < ok named mirror > ok named annotation = ok named mirror . find ( element ) ; if ( ok named annotation . is present ( ) ) { string value = ok named annotation . get ( ) . name ( ) ; if ( ! value . is empty ( ) ) { serialized name = value ; return serialized name ; } } if ( is marked as mongo id ( ) ) { serialized name = id attribute name ; return serialized name ; } serialized name = str ; return serialized name ; } return serialized name ; }	Serialized name, actully specified via annotation.
public string get marshaled name ( ) { string serialized name = get serialized name ( ) ; if ( ! serialized name . is empty ( ) ) { return serialized name ; } return names . raw ; }	Marshaled name for compatibility with repository.
public static < t > predicate < t > of ( expression < t > expression ) { if ( expressions . is nil ( expression ) ) {	Factory method to create evaluator instance.
public static < v > fluent future < v > from ( listenable future < v > future ) { if ( future instanceof fluent future < ? > ) { return ( fluent future < v > ) future ; } return new wraping fluent future < > ( future , more executors . direct executor ( ) ) ; }	Wraps listenable future with a fluent future.
@ encoding . expose public optional < immutable map < k , v > > get immutable ( ) { return optional . of nullable ( map ) ; }	alternatively it can be exposed as Optional of ImmutableMap.
protected string stringify ( declared type input , typevar context context ) { return to type element ( input ) . get qualified name ( ) . to string ( ) ; }	overridable stringify.
public final token buffer next token buffer ( ) throws io { token buffer buffer = new token buffer ( parser ) ;	Reads current value including objects and array as effiecient token buffer.Use of Jackson's own mechanisms is important to preserve custom elementssuch as special embedded objects in BSON or other data formats.
void close ( ) { lock . lock ( ) ; condition . signal ( ) ; set auto accept ( bool ) ; lock . unlock ( ) ; holder = null ; }	Closes the current window.
public object execute ( string script body , object [ ] parameters ) { try { async result = new async script result ( ) ; function function = create injected script function ( script body , async result ) ; try { page . execute java script function ( function , function , parameters , page . get document element ( ) ) ; } catch ( script exception e ) { throw new web driver exception ( e ) ; } try { return async result . wait for result ( timeout millis ) ; } catch ( interrupted exception e ) { throw new web driver exception ( e ) ; } } finally { async result = null ; } }	Injects an asynchronous script for execution and waits for its result.
public void set http ( string host , int port , list < string > no proxy hosts ) { proxy config = new proxy config ( ) ; proxy config . set proxy host ( host ) ; proxy config . set proxy port ( port ) ; if ( no proxy hosts != null && no proxy hosts . size ( ) > num ) { for ( string no proxy host : no proxy hosts ) { proxy config . add hosts to proxy bypass ( no proxy host ) ; } } get web client ( ) . get options ( ) . set proxy config ( proxy config ) ; }	Sets HTTP proxy for WebClient with bypass proxy hosts.
public void set auto proxy ( string auto proxy url ) { proxy config = new proxy config ( ) ; proxy config . set proxy auto config url ( auto proxy url ) ; get web client ( ) . get options ( ) . set proxy config ( proxy config ) ; }	Sets Proxy Autoconfiguration URL for WebClient.
public static api user client ( string user id ) { if ( user id == null ) {	Get a BoxDeveloperEditionAPIConnection that can be used by an App user to access Box.
public void update modified fields from entity ( process definition entity updating process definition ) { if ( ! this . key . equals ( updating process definition . key ) || ! this . deployment id . equals ( updating process definition . deployment id ) ) { throw new process engine exception ( str ) ; }	Updates all modifiable fields from another process definition entity.
private void add four eyes task listener ( activity impl activity ) { user task activity behavior user task activity behavior = ( user task activity behavior ) activity . get activity behavior ( ) ; boolean listener already exists = bool ;	Add TaskListener on "complete" event generically every time, so we don'thave to add it in the XML.
@ post deploy public void deploy processes to tenant engines ( ) {	private static final String PROCESS_DEFINITION_KEY = "tenantdemo-process-application";.
private void check task selected via bridge ( ) { string bridge task id = ( string ) get shared session attribute ( bridge task id ) ; string selected task id = ( string ) get shared session attribute ( associated task id ) ; if ( selected task id == null && bridge task id != null ) { switch task id ( bridge task id ) ; } if ( selected task id != null && bridge task id != null && ! selected task id . equals ( bridge task id ) ) {	"lazy" load task if bridge state has changed in the meantime.
public static string get servlet context path ( process engine process engine , string process definition id ) { return get servlet context path ( get process application info ( process engine , process definition id ) ) ; }	Retrieve the servlet context path of a process definition from a known process engine.
public static string get servlet context path ( string process definition id ) { process application info process application info = get process application info ( process definition id ) ; if ( process application info == null ) { return null ; } return process application info . get properties ( ) . get ( process application info . prop servlet context path ) ; }	Retrieve the servlet context path of a process definition from any process engine.
public static process application info get process application info ( process engine process engine , string process definition id ) { process definition process definition = process engine . get repository service ( ) . get process definition ( process definition id ) ;	Retrieve the application info of a process definition from a known process engine.
public static process application info get process application info ( string process definition id ) { process engine service process engine service = bpm platform . get process engine service ( ) ; process application service process app service = bpm platform . get process application service ( ) ;	Retrieve the application info path of a process definition from any process engine.
@ suppress warnings ( str ) @ bean public user details service user details service ( ) { in memory user details manager manager = new in memory user details manager ( ) ; manager . create user ( user . with default password encoder ( ) . username ( str ) . password ( str ) . roles ( str , str ) . build ( ) ) ; manager . create user ( user . with default password encoder ( ) . username ( str ) . password ( str ) . roles ( str ) . build ( ) ) ; return manager ; }	In real world scenarios, this would be replaced by the actual IAM solution.
@ suppress warnings ( str ) public static final < t extends serializable > t cast value ( final object value ) { return value != null ? ( t ) value : null ; }	Type- and null-safe cast of variable-value.
@ post construct public void init ( ) throws exception { log . info ( str ) ; log . info ( str ) ; log . info ( str ) ; camunda bpm component component = new camunda bpm component ( process engine ) ; component . set camel context ( cdi camel context ) ; cdi camel context . add component ( str , component ) ;	private QueueConnectionFactory queueConnectionFactory;.
public static void check is set ( final delegate execution execution , final string variable name ) { check argument ( variable name != null , variable name must be not null ) ; final object variable local = execution . get variable local ( variable name ) ; final object variable = execution . get variable ( variable name ) ; check state ( variable local != null || variable != null , format ( condition violated + str , execution . get current activity id ( ) , variable name ) ) ; }	Checks if a variable is set.
public static void check is set global ( final delegate execution execution , final string variable name ) { check argument ( variable name != null , variable name must be not null ) ; final object variable = execution . get variable ( variable name ) ; check state ( variable != null , format ( condition violated + str , execution . get current activity id ( ) , variable name ) ) ; }	Checks if a global variable is set.
public void open ( boolean animated ) {	Simply opens the menu by doing necessary calculations.
public void close ( boolean animated ) {	Closes the menu.
public void update item positions ( ) {	Recalculates the positions of each sub action item on demand.
private point get action view coordinates ( ) { int [ ] coords = new int [ num ] ;	Gets the coordinates of the main action viewThis method should only be called after the main layout of the Activity is drawn,such as when a user clicks the action button.
public point get action view center ( ) { point point = get action view coordinates ( ) ; point . x += main action view . get measured width ( ) / num ; point . y += main action view . get measured height ( ) / num ; return point ; }	Returns the center point of the main action view.
private point calculate item positions ( ) {	Calculates the desired positions of all items.
public view get activity content view ( ) { try { return ( ( activity ) main action view . get context ( ) ) . get window ( ) . get decor view ( ) . find view by id ( android . r . id . content ) ; } catch ( class cast exception e ) { throw new class cast exception ( str ) ; } }	Finds and returns the main content view from the Activity context.
private point get screen size ( ) { point size = new point ( ) ; get window manager ( ) . get default display ( ) . get size ( size ) ; return size ; }	Retrieves the screen size from the Activity context.
public void set content view ( view content view , frame layout . layout params params ) { if ( params == null ) { params = new frame layout . layout params ( layout params . wrap content , layout params . wrap content , gravity . center ) ; final int margin = get resources ( ) . get dimension pixel size ( r . dimen . sub action button content margin ) ; params . set margins ( margin , margin , margin , margin ) ; } content view . set clickable ( bool ) ; this . add view ( content view , params ) ; }	Sets a content view with custom LayoutParams that will be displayed inside this SubActionButton.
public void set position ( int position , view group . layout params layout params ) { boolean set default margin = bool ; int gravity ; switch ( position ) { case position top center : gravity = gravity . top | gravity . center horizontal ; break ; case position top right : gravity = gravity . top | gravity . right ; break ; case position right center : gravity = gravity . right | gravity . center vertical ; break ; case position bottom center : gravity = gravity . bottom | gravity . center horizontal ; break ; case position bottom left : gravity = gravity . bottom | gravity . left ; break ; case position left center : gravity = gravity . left | gravity . center vertical ; break ; case position top left : gravity = gravity . top | gravity . left ; break ; case position bottom right : default : set default margin = bool ; gravity = gravity . bottom | gravity . right ; break ; } if ( ! system overlay ) { try { frame layout . layout params lp = ( frame layout . layout params ) layout params ; lp . gravity = gravity ; set layout params ( lp ) ; } catch ( class cast exception e ) { throw new class cast exception ( str + str ) ; } } else { try { window manager . layout params lp = ( window manager . layout params ) layout params ; lp . gravity = gravity ; if ( set default margin ) { int margin = get context ( ) . get resources ( ) . get dimension pixel size ( r . dimen . action button margin ) ; lp . x = margin ; lp . y = margin ; } set layout params ( lp ) ; } catch ( class cast exception e ) { throw new class cast exception ( str + str ) ; } } }	Sets the position of the button by calculating its Gravity from the position parameter.
public void attach ( view group . layout params layout params ) { if ( system overlay ) { try { get window manager ( ) . add view ( this , layout params ) ; } catch ( security exception e ) { throw new security exception ( str + str ) ; } } else { ( ( view group ) get activity content view ( ) ) . add view ( this , layout params ) ; } }	Attaches it to the content view with specified LayoutParams.
public state configuration < s , t > permit ( t trigger , s destination state ) { enforce not identity transition ( destination state ) ; return public permit ( trigger , destination state ) ; }	Accept the specified trigger and transition to the destination state.
public state configuration < s , t > permit if ( t trigger , s destination state , func boolean guard ) { enforce not identity transition ( destination state ) ; return public permit if ( trigger , destination state , guard ) ; }	Accept the specified trigger and transition to the destination state if guard is true.
public state configuration < s , t > permit if otherwise ignore ( t trigger , s destination state , final func boolean guard ) { enforce not identity transition ( destination state ) ; ignore if ( trigger , new func boolean ( ) { @ override public boolean call ( ) { return ! guard . call ( ) ; } } ) ; return public permit if ( trigger , destination state , guard ) ; }	Accept the specified trigger and transition to the destination state if guard true, otherwise ignore.
public state configuration < s , t > ignore if ( t trigger , func boolean guard ) { assert guard != null : guard is null ; representation . add trigger behaviour ( new internal trigger behaviour < s , t > ( trigger , guard , no action ) ) ; return this ; }	ignore the specified trigger when in the configured state, if the guard returns true.
private state representation < t , t > get or create representation ( t state ) { state representation < t , t > result = state configuration . get ( state ) ; if ( result == null ) { result = new state representation < > ( state ) ; state configuration . put ( state , result ) ; } return result ; }	Return StateRepresentation for the specified state.
public void add instance ( object instance ) throws exception { state current state = state . get ( ) ; if ( ( current state == state . stopping ) || ( current state == state . stopped ) ) { throw new illegal state exception ( ) ; } else { start instance ( instance ) ; if ( methods map . get ( instance . get class ( ) ) . has for ( pre destroy . class ) ) { managed instances . add ( instance ) ; } } }	Add an additional managed instance.
private boolean set overflow ( int bucket , int overflow ) { for ( int i = num ; i < overflows ; i ++ ) { if ( overflow buckets [ i ] == bucket ) { overflow values [ i ] = ( byte ) overflow ; return bool ; } } return bool ; }	Returns false if not overflow bucket matching the given bucket id was found.
public dense hll merge with ( dense hll other ) { if ( index bit length != other . index bit length ) { throw new illegal argument exception ( string . format ( str , number of buckets ( index bit length ) , number of buckets ( other . index bit length ) ) ) ; } int baseline = math . max ( this . baseline , other . baseline ) ; int baseline count = num ; int overflows = num ; int [ ] overflow buckets = new int [ overflow grow increment ] ; byte [ ] overflow values = new byte [ overflow grow increment ] ; int number of buckets = number of buckets ( index bit length ) ; for ( int i = num ; i < number of buckets ; i ++ ) { int value = math . max ( get value ( i ) , other . get value ( i ) ) ; int delta = value - baseline ; if ( delta == num ) { baseline count ++ ; } else if ( delta > max delta ) {	Returns "this" for chaining.
public static byte [ ] encode sequence ( byte [ ] ... encoded values ) { int length = num ; for ( byte [ ] encoded value : encoded values ) { length += encoded value . length ; } byte [ ] length encoded = encode length ( length ) ; byte array data output out = byte streams . new data output ( num + length encoded . length + length ) ; out . write ( sequence tag ) ; out . write ( length encoded ) ; for ( byte [ ] entry : encoded values ) { out . write ( entry ) ; } return out . to byte array ( ) ; }	Encodes a sequence of encoded values.
public static list < byte [ ] > decode sequence ( byte [ ] sequence ) { int index = num ;	Decodes a sequence of encoded values.
public static byte [ ] decode sequence optional element ( byte [ ] element ) { int index = num ;	Decodes a optional element of a sequence.
public static byte [ ] encode bit string ( int pad bits , byte [ ] value ) { check argument ( pad bits >= num && pad bits < num , str ) ; byte [ ] length encoded = encode length ( value . length + num ) ; byte array data output out = byte streams . new data output ( num + length encoded . length + value . length ) ; out . write ( bit string tag ) ; out . write ( length encoded ) ; out . write ( pad bits ) ; out . write ( value ) ; return out . to byte array ( ) ; }	Encodes a bit string padded with the specified number of bits.The encoding is a byte containing the padBits followed by the value bytes.
public static byte [ ] encode octet string ( byte [ ] value ) { byte [ ] length encoded = encode length ( value . length ) ; byte array data output out = byte streams . new data output ( num + length encoded . length + value . length ) ; out . write ( octet string tag ) ; out . write ( length encoded ) ; out . write ( value ) ; return out . to byte array ( ) ; }	Encodes an octet string.
public static byte [ ] encode length ( int length ) { if ( length < num ) { return new byte [ ] { ( byte ) length } ; } int number of bits = num - integer . number of leading zeros ( length ) ; int number of bytes = ( number of bits + num ) / num ; byte [ ] encoded = new byte [ num + number of bytes ] ; encoded [ num ] = ( byte ) ( number of bytes | num ) ; for ( int i = num ; i < number of bytes ; i ++ ) { int byte to encode = ( number of bytes - i ) ; int shift size = ( byte to encode - num ) * num ; encoded [ i + num ] = ( byte ) ( length > > > shift size ) ; } return encoded ; }	Encodes the length of a DER value.
public static logger get ( string name ) { java . util . logging . logger logger = java . util . logging . logger . get logger ( name ) ; return new logger ( logger ) ; }	Gets a named logger.
public void debug ( throwable exception , string message ) { logger . log ( fine , message , exception ) ; }	Logs a message at DEBUG level.
public void warn ( throwable exception , string message ) { logger . log ( warning , message , exception ) ; }	Logs a message at WARN level.
public void error ( throwable exception , string message ) { logger . log ( severe , message , exception ) ; }	Logs a message at ERROR level.
public http uri builder replace path ( string path ) { require non null ( path , str ) ; if ( ! path . is empty ( ) && ! path . starts with ( str ) ) { path = str + path ; } this . path = path ; return this ; }	Replace the current path with the given unencoded path.
private static string percent decode ( string encoded ) { preconditions . check argument ( ascii ( ) . matches all of ( encoded ) , str ) ; byte array output stream out = new byte array output stream ( encoded . length ( ) ) ; for ( int i = num ; i < encoded . length ( ) ; i ++ ) { char c = encoded . char at ( i ) ; if ( c == str ) { preconditions . check argument ( i + num < encoded . length ( ) , str ) ; int high = character . digit ( encoded . char at ( i + num ) , num ) ; int low = character . digit ( encoded . char at ( i + num ) , num ) ; preconditions . check argument ( high != - num && low != - num , str , encoded . substring ( i , i + num ) ) ; int value = ( high << num ) | ( low ) ; out . write ( value ) ; i += num ; } else { out . write ( ( int ) c ) ; } } try { return utf 8 . new decoder ( ) . on malformed input ( coding error action . report ) . decode ( byte buffer . wrap ( out . to byte array ( ) ) ) . to string ( ) ; } catch ( character coding exception e ) { throw new illegal argument exception ( str ) ; } }	input must be an ASCII string representing a percent-encoded UTF-8 byte sequence.
@ nullable private static double summary stats process content timestamps ( list < long > content timestamps ) { require non null ( content timestamps , str ) ;	Calculate the summary statistics for the interarrival time of the onResponseContent callbacks.
< t > t build ( configuration provider < t > configuration provider ) { require non null ( configuration provider , str ) ; register configuration provider ( configuration provider , optional . empty ( ) ) ;	This is used by the configuration provider.
public void update ( long value , long timestamp ) { lock for regular usage ( ) ; try { final double priority = weight ( timestamp - start time ) / random ( ) ; final long new count = count . increment and get ( ) ; if ( new count <= reservoir size ) { values . put ( priority , value ) ; } else { double first = values . first key ( ) ; if ( first < priority ) { if ( values . put if absent ( priority , value ) == null ) {	Adds an old value with a fixed timestamp to the sample.
public static string base64 encode ( byte [ ] bytes ) {	Encodes the specified data into a base64 string.
public static byte [ ] base64 decode ( string encoded ) { int padding = num ; for ( int i = encoded . length ( ) - num ; encoded . char at ( i ) == str ; i -- ) { padding ++ ; } int length = encoded . length ( ) * num / num - padding ; byte [ ] bytes = new byte [ length ] ; for ( int i = num , index = num , n = encoded . length ( ) ; i < n ; i += num ) { int word = reverse lookup [ encoded . char at ( i ) ] << num ; word += reverse lookup [ encoded . char at ( i + num ) ] << num ; word += reverse lookup [ encoded . char at ( i + num ) ] << num ; word += reverse lookup [ encoded . char at ( i + num ) ] ; for ( int j = num ; j < num && index + j < length ; j ++ ) { bytes [ index + j ] = ( byte ) ( word > > ( num * ( num - j ) ) ) ; } index += num ; } return bytes ; }	Decodes the specified base64 string back into its raw data.
@ override public synchronized void flush ( ) throws io { super . flush ( ) ; string record = this . to string ( ) ; reset ( ) ; if ( record . is empty ( ) || record . equals ( line separator ) ) {	write the current buffer contents to the underlying logger.
@ suppress warnings ( str ) public string dump destination ( uri uri ) { destination destination = http client . get destination ( uri . get scheme ( ) , uri . get host ( ) , uri . get port ( ) ) ; if ( destination == null ) { return null ; } return dump destination ( destination ) ; }	todo this should be .
public static double compute alpha ( double target weight , long target age in seconds ) { check argument ( target age in seconds > num , str ) ; check argument ( target weight > num && target weight < num , str ) ; return - math . log ( target weight ) / target age in seconds ; }	Compute the alpha decay factor such that the weight of an entry with age 'targetAgeInSeconds' is targetWeight'.
public static < x , y > void propagate cancellation ( listenable future < ? extends x > source , future < ? extends y > destination , boolean may interrupt if running ) { source . add listener ( ( ) -> { if ( source . is cancelled ( ) ) { destination . cancel ( may interrupt if running ) ; } } , direct executor ( ) ) ; }	Cancels the destination Future if the source Future is cancelled.
@ deprecated public static < v > completable future < v > unmodifiable future ( completable future < v > future ) { return unmodifiable future ( future , bool ) ; }	Returns a future that can not be completed or canceled.
@ deprecated public static < v > completable future < v > unmodifiable future ( completable future < v > future , boolean propagate cancel ) { require non null ( future , str ) ; function < boolean , boolean > on cancel function ; if ( propagate cancel ) { on cancel function = future :: cancel ; } else { on cancel function = may interrupt -> bool ; } unmodifiable completable future < v > unmodifiable future = new unmodifiable completable future < > ( on cancel function ) ; future . when complete ( ( value , exception ) -> { if ( exception != null ) { unmodifiable future . internal complete exceptionally ( exception ) ; } else { unmodifiable future . internal complete ( value ) ; } } ) ; return unmodifiable future ; }	Returns a future that can not be completed or optionally canceled.
@ deprecated public static < v > completable future < v > failed future ( throwable throwable ) { require non null ( throwable , str ) ; completable future < v > future = new completable future < > ( ) ; future . complete exceptionally ( throwable ) ; return future ; }	Returns a failed future containing the specified throwable.
public static < v , e extends exception > v get future value ( future < v > future , class < e > exception type ) throws e { require non null ( future , str ) ; require non null ( exception type , str ) ; try { return future . get ( ) ; } catch ( interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; throw new runtime exception ( str , e ) ; } catch ( execution exception e ) { throwable cause = e . get cause ( ) == null ? e : e . get cause ( ) ; propagate if possible ( cause , exception type ) ; throw new runtime exception ( cause ) ; } }	Waits for the value from the future.
public static < t > optional < t > try get future value ( future < t > future ) { require non null ( future , str ) ; if ( ! future . is done ( ) ) { return optional . empty ( ) ; } return try get future value ( future , num , milliseconds ) ; }	Gets the current value of the future without waiting.
public static < v > optional < v > try get future value ( future < v > future , int timeout , time unit time unit ) { return try get future value ( future , timeout , time unit , runtime exception . class ) ; }	Waits for the the value from the future for the specified time.
public static < v , e extends exception > optional < v > try get future value ( future < v > future , int timeout , time unit time unit , class < e > exception type ) throws e { require non null ( future , str ) ; check argument ( timeout >= num , str ) ; require non null ( time unit , str ) ; require non null ( exception type , str ) ; try { return optional . of nullable ( future . get ( timeout , time unit ) ) ; } catch ( interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; throw new runtime exception ( str , e ) ; } catch ( execution exception e ) { throwable cause = e . get cause ( ) == null ? e : e . get cause ( ) ; propagate if possible ( cause , exception type ) ; throw new runtime exception ( cause ) ; } catch ( timeout exception expected ) {	Waits for the the value from the future for the specified time.
public static void check success ( future < ? > future , string error message ) { require non null ( future , str ) ; require non null ( error message , str ) ; check argument ( future . is done ( ) , str ) ; try { get future value ( future ) ; } catch ( runtime exception e ) { throw new illegal argument exception ( error message , e ) ; } }	Checks that the completed future completed successfully.
public static < v > listenable future < v > when any complete ( iterable < ? extends listenable future < ? extends v > > futures ) { require non null ( futures , str ) ; check argument ( ! is empty ( futures ) , str ) ; extended settable future < v > first completed future = extended settable future . create ( ) ; for ( listenable future < ? extends v > future : futures ) { first completed future . set async ( future ) ; } return first completed future ; }	Creates a future that completes when the first future completes either normallyor exceptionally.
@ deprecated public static < v > completable future < v > first completed future ( iterable < ? extends completion stage < ? extends v > > futures ) { return first completed future ( futures , bool ) ; }	Creates a future that completes when the first future completes either normallyor exceptionally.
@ deprecated public static < v > completable future < v > first completed future ( iterable < ? extends completion stage < ? extends v > > futures , boolean propagate cancel ) { require non null ( futures , str ) ; check argument ( ! is empty ( futures ) , str ) ; completable future < v > future = new completable future < > ( ) ; for ( completion stage < ? extends v > stage : futures ) { stage . when complete ( ( value , exception ) -> { if ( exception != null ) { future . complete exceptionally ( exception ) ; } else { future . complete ( value ) ; } } ) ; } if ( propagate cancel ) { future . exceptionally ( throwable -> { if ( throwable instanceof cancellation exception ) { for ( completion stage < ? extends v > source future : futures ) { if ( source future instanceof future ) { ( ( future < ? > ) source future ) . cancel ( bool ) ; } } } return null ; } ) ; } return future ; }	Creates a future that completes when the first future completes either normallyor exceptionally.
@ deprecated public static < v > completable future < list < v > > all as list ( list < completable future < ? extends v > > futures ) { completable future < void > all done future = completable future . all of ( futures . to array ( new completable future [ futures . size ( ) ] ) ) ;	Returns an unmodifiable future that is completed when all of the givenfutures complete.
public static < v > completable future < v > to completable future ( listenable future < v > listenable future ) { require non null ( listenable future , str ) ; completable future < v > future = new completable future < > ( ) ; future . exceptionally ( throwable -> { if ( throwable instanceof cancellation exception ) { listenable future . cancel ( bool ) ; } return null ; } ) ; future callback < v > callback = new future callback < v > ( ) { @ override public void on success ( v result ) { future . complete ( result ) ; } @ override public void on failure ( throwable t ) { future . complete exceptionally ( t ) ; } } ; futures . add callback ( listenable future , callback , direct executor ( ) ) ; return future ; }	Converts a ListenableFuture to a CompletableFuture.
public static < v > listenable future < v > to listenable future ( completable future < v > completable future ) { require non null ( completable future , str ) ; settable future < v > future = settable future . create ( ) ; propagate cancellation ( future , completable future , bool ) ; completable future . when complete ( ( value , exception ) -> { if ( exception != null ) { future . set exception ( exception ) ; } else { future . set ( value ) ; } } ) ; return future ; }	Converts a CompletableFuture to a ListenableFuture.
public static < t > void add exception callback ( listenable future < t > future , runnable exception callback , executor executor ) { require non null ( exception callback , str ) ; add exception callback ( future , t -> exception callback . run ( ) , executor ) ; }	Invokes the callback, using the specified executor, if the future fails.
private int try remove ( int node ) { check argument ( node != - num , str ) ; int left = lefts [ node ] ; int right = rights [ node ] ; if ( left == - num && right == - num ) {	Remove the node if possible or set its count to 0 if it has children andit needs to be kept around.
private double compute max path weight ( int node ) { if ( node == - num || levels [ node ] == num ) { return num ; } double left max weight = compute max path weight ( lefts [ node ] ) ; double right max weight = compute max path weight ( rights [ node ] ) ; return math . max ( left max weight , right max weight ) + counts [ node ] ; }	Computes the max "weight" of any path starting at node and ending at a leaf in thehypothetical complete tree. The weight is the sum of counts in the ancestors of a given node.
public void add hash ( long hash ) { instance . insert hash ( hash ) ; if ( instance instanceof sparse hll ) { instance = make dense if necessary ( ( sparse hll ) instance ) ; } }	Adds a value that has already been hashed to the set of values tracked by this HyperLogLog instance.
public static map < string , string > load properties from ( string path ) throws io { properties properties = new properties ( ) ; try ( input stream input stream = new file input stream ( path ) ) { properties . load ( input stream ) ; } return from properties ( properties ) ; }	Loads properties from the given file.
public < t > void bind config global defaults ( class < t > config class , config defaults < t > config defaults ) { key < t > key = key . get ( config class , global defaults . class ) ; binder . bind config defaults ( new config defaults holder < > ( key , config defaults ) ) ; }	Binds default values for all the instances of given config class for the current binder.
public duration next ( int poll count , duration previous duration ) { return new duration ( fibonacci ( offset + poll count ) , time unit ) ; }	Generate the next duration.
private int fib ( int value , int current , int previous ) { if ( value == num ) { return previous ; } else if ( value == num ) { return current ; } return fib ( value - num , current + previous , current ) ; }	Tail recursive implementation of fibonacci.
public duration multiply ( long amount ) { return new multiply ( ) . apply ( this , unit == null ? forever : new duration ( amount , unit ) ) ; }	Multiply this amount with the given amount.
public duration divide ( long amount ) { return new divide ( ) . apply ( this , unit == null ? forever : new duration ( amount , unit ) ) ; }	Divide this duration amount with the given amount.
private static field find single field using strategy ( field matcher strategy strategy , object object , boolean check hierarchy , class < ? > start class ) { assert object in get internal state is not null ( object ) ; field found field = null ; final class < ? > original start class = start class ; while ( start class != null ) { final field [ ] declared fields = start class . get declared fields ( ) ; for ( field field : declared fields ) { if ( strategy . matches ( field ) && has field proper modifier ( object , field ) ) { if ( found field != null ) { throw new too many fields found exception ( str + strategy + str ) ; } found field = field ; } } if ( found field != null ) { break ; } else if ( ! check hierarchy ) { break ; } start class = start class . get superclass ( ) ; } if ( found field == null ) { strategy . not found ( original start class , ! is class ( object ) ) ; return null ; } found field . set accessible ( bool ) ; return found field ; }	Find single field using strategy.
private static boolean has field proper modifier ( object object , field field ) { return ( ( object instanceof class < ? > && modifier . is static ( field . get modifiers ( ) ) ) || ! ( object instanceof class < ? > || modifier . is static ( field . get modifiers ( ) ) ) ) ; }	Checks for field proper modifier.
public static void throw exception if field was not found ( class < ? > type , string field name , field field ) { if ( field == null ) { throw new field not found exception ( str + field name + str + type . get name ( ) + str ) ; } }	Throw exception if field was not found.
public static field get field annotated with ( object object , class < ? extends annotation > annotation type ) { return find single field using strategy ( new field annotation matcher strategy ( annotation type ) , object , bool , get type ( object ) ) ; }	Get field annotated with a particular annotation.
public condition factory condition evaluation listener ( condition evaluation listener condition evaluation listener ) { return new condition factory ( alias , timeout constraint , poll interval , poll delay , catch uncaught exceptions , exceptions ignorer , condition evaluation listener , executor lifecycle ) ; }	Handle condition evaluation results each time evaluation of a condition occurs.
public condition factory poll executor service ( executor service executor service ) { if ( executor service != null && executor service instanceof scheduled executor service ) { throw new illegal argument exception ( str + scheduled executor service . class . get name ( ) ) ; } return new condition factory ( alias , timeout constraint , poll interval , poll delay , bool , exceptions ignorer , condition evaluation listener , executor lifecycle . without cleanup ( executor service ) ) ; }	Specify the executor service whose threads will be used to evaluate the poll condition in Awaitility.Note that the executor service must be shutdown manually!This is an advanced feature and it should only be used sparingly.
public void until true ( final atomic boolean atomic ) { until atomic ( atomic , any of ( is ( boolean . true ) , is ( bool ) ) ) ; }	Await until a Atomic boolean becomes true.
public void until false ( final atomic boolean atomic ) { until atomic ( atomic , any of ( is ( boolean . false ) , is ( bool ) ) ) ; }	Await until a Atomic boolean becomes false.
public static condition factory catch uncaught exceptions ( ) { return new condition factory ( null , default wait constraint , default poll interval , default poll delay , default catch uncaught exceptions , default exception ignorer , default condition evaluation listener , default executor lifecycle ) ; }	Catching uncaught exceptions in other threads.
public static void set default timeout ( long timeout , time unit unit ) { default wait constraint = default wait constraint . with max wait time ( new duration ( timeout , unit ) ) ; }	Sets the default timeout all await statements will use.
public static void set default timeout ( duration default timeout ) { if ( default timeout == null ) { throw new illegal argument exception ( str ) ; } default wait constraint = default wait constraint . with max wait time ( default timeout ) ; }	Sets the default timeout that all await statements will use.
public static list < string > tokenize ( string arguments , boolean stringify ) { linked list < string > arg list = new linked list < > ( ) ; string builder curr arg = new string builder ( ) ; boolean escaped = bool ; int state = no token state ;	Tokenizes the given String into String tokens.
protected static string escape quotes and backslashes ( string s ) { final string builder buf = new string builder ( s ) ;	Inserts backslashes before any occurrences of a backslash orquote in the given string.
public result serve static ( ) { object renderable = new renderable ( ) { @ override public void render ( context context , result result ) { string file name = get file name from path or return request path ( context ) ; url url = get static file from assets dir ( file name ) ; stream out url entity ( url , context , result ) ; } } ; return results . ok ( ) . render ( renderable ) ; }	Serves resources from the assets directory of your application.For instance:route: /robots.txtA request to /robots.txt will be served from /assets/robots.txt.You can also use a path like the following to serve files:route: /assets/{fileName: .*}matches/assets/app/app.cssand will return/assets/app/app.css (from your jar).
private properties configuration load language configuration ( string file or url ) { properties configuration configuration = swiss knife . load configuration in utf8 ( file or url ) ; if ( configuration != null && ninja properties . is dev ( ) ) {	Attempts to load a message file and sets the file changed reloadingstrategy on the configuration if the runtime mode is Dev.
private map < string , configuration > load all message files for registered languages ( ) { map < string , configuration > lang to key and values mapping mutable = maps . new hash map ( ) ;	Does all the loading of message files.Only registered messages in application.conf are loaded.
protected static url get url for string from classpath as file or url ( string logback configuration file ) { url url = null ; try { url = resources . get resource ( logback configuration file ) ; } catch ( illegal argument exception ex ) {	Looks up a potential file from1) The classpahth2) From the filesystem3) From an URL.
protected static string generate secret ( random random ) { string charset for secret = str ; string builder string builder = new string builder ( num ) ; for ( int i = num ; i < num ; i ++ ) { int char to po pick from charset = random . next int ( charset for secret . length ( ) ) ; string builder . append ( charset for secret . char at ( char to po pick from charset ) ) ; } return string builder . to string ( ) ; }	!!!! Only for testing purposes !!!!Usually you want to use {.
protected run class in separate jvm machine build run class in separate jvm machine ( string name , string class name with main to run , list < string > classpath , list < string > jvm arguments , file maven base dir ) { return new run class in separate jvm machine ( name , class name with main to run , classpath , build jvm arguments ( ) , maven base dir ) ; }	so we can mock a fake one for unit testing.
static public class < ? extends standalone > resolve standalone class ( ) { return resolve standalone class ( system . get property ( standalone . key ninja standalone class ) , forwarding service loader . load with system service loader ( standalone . class ) , standalone . default standalone class ) ; }	Resolves which standalone class to use.
public string encrypt ( string data ) { objects . require non null ( data , str ) ; if ( ! secret key spec . is present ( ) ) { return data ; } try {	Encrypts data with secret key.
public string decrypt ( string data ) { objects . require non null ( data , str ) ; if ( ! secret key spec . is present ( ) ) { return data ; }	Decrypts data with secret key.
private final string read ninja version ( ) {	Simply reads a property resource file that contains the version of thisNinja build.
private void register ( path path ) throws io {	Register the given path with the WatchService.
public static ninja mode determine mode from system properties or prod if not set ( ) { optional < ninja mode > ninja mode optional = determine mode from system properties ( ) ; ninja mode ninja mode ; if ( ! ninja mode optional . is present ( ) ) { ninja mode = ninja mode . prod ; } else { ninja mode = ninja mode optional . get ( ) ; } logger . info ( str , ninja mode . to string ( ) ) ; return ninja mode ; }	returns NinjaMode.dev if no mode is set.
public boolean is valid mime type ( string mime type ) { if ( mime type == null ) { return bool ; } else if ( mime type . index of ( str ) != - num ) { return mimetypes . contains ( mime type . split ( str ) [ num ] ) ; } else { return mimetypes . contains ( mime type ) ; } }	check the mimetype is referenced in the mimetypes database.
public route build route ( injector injector ) { if ( functional method == null ) { log . error ( str , uri ) ; throw new illegal state exception ( str ) ; }	Build the route.
@ override final public void run ( ) {	Configure, start, add shutdown hook, and join.
protected string create server url ( string scheme , string host , integer port ) { string builder sb = new string builder ( ) ; sb . append ( scheme ) ; sb . append ( str ) ; sb . append ( ( host != null ? host : str ) ) ; if ( ( str . equals ( scheme ) && port != num ) || ( str . equals ( scheme ) && port != num ) ) { sb . append ( str ) ; sb . append ( port ) ; } return sb . to string ( ) ; }	helpful utilities for subclasses.
@ override public void init ( router router ) { this . router = router ; configure reflections ( ) ; controllers = maps . new hash map ( ) ; methods = sets . new hash set ( ) ; process found methods ( ) ; sort methods ( ) ; register methods ( ) ; }	Scans, identifies, and registers annotated controller methods for thecurrent runtime settings.
private void process found methods ( ) { for ( method method : find controller methods ( ) ) { if ( allow method ( method ) ) {	Takes the found methods and checks if they have a valid format.If they do, the controller path classes for these methods are generated.
private void sort methods ( ) { list < method > method list = new array list < > ( methods ) ; collections . sort ( method list , new comparator < method > ( ) { @ override public int compare ( method m1 , method m2 ) { int o1 = integer . max value ; if ( m1 . is annotation present ( order . class ) ) { order order = m1 . get annotation ( order . class ) ; o1 = order . value ( ) ; } int o2 = integer . max value ; if ( m2 . is annotation present ( order . class ) ) { order order = m2 . get annotation ( order . class ) ; o2 = order . value ( ) ; } if ( o1 == o2 ) {	Sorts the methods into registration order.
@ suppress warnings ( str ) private set < method > find controller methods ( ) { set < method > methods = sets . new linked hash set ( ) ; methods . add all ( reflections . get methods annotated with ( path . class ) ) ; boolean enable custom http methods = ninja properties . get boolean with default ( ninja custom http methods , bool ) ; if ( enable custom http methods ) { reflections annotation reflections = new reflections ( str , new type annotations scanner ( ) , new sub types scanner ( ) ) ; for ( class < ? > http method : annotation reflections . get types annotated with ( http method . class ) ) { if ( http method . is annotation ( ) ) { methods . add all ( reflections . get methods annotated with ( ( class < ? extends annotation > ) http method ) ) ; } } } else {	Searches for Methods that have either a Path Annotation or a HTTP-Method Annotation.
private void configure reflections ( ) { optional < string > base package = optional . of nullable ( ninja properties . get ( ninja constant . application modules base package ) ) ; if ( base package . is present ( ) ) { reflections = new reflections ( base package . get ( ) + str + ninja constant . controllers dir , new method annotations scanner ( ) ) ; } else { reflections = new reflections ( ninja constant . controllers dir , new method annotations scanner ( ) ) ; } }	Configures the set of packages to scan for annotated controller methods.
private boolean allow method ( method method ) {	Determines if this method may be registered as a route.
private string get http method ( method method ) { for ( annotation annotation : method . get annotations ( ) ) { class < ? extends annotation > annotation class = annotation . annotation type ( ) ; if ( annotation class . is annotation present ( http method . class ) ) { http method http method = annotation class . get annotation ( http method . class ) ; return http method . value ( ) ; } }	Returns the HTTP method for the controller method.
public static controller method invoker build ( method functional method , method implementation method , injector injector , ninja properties ninja properties ) {	Builds an invoker for a functional method.
public static string get real class name lower camel case ( object object ) { return case format . upper camel . to ( case format . lower camel , object . get class ( ) . get simple name ( ) ) ; }	Returns the lower class name.
public static boolean does class exist ( string name with package , object instance to get classloader from ) { boolean exists = bool ; try { class . for name ( name with package , bool , instance to get classloader from . get class ( ) . get class loader ( ) ) ; exists = bool ; } catch ( class not found exception e ) { exists = bool ; } return exists ; }	Used to check whether a class exists on the classpath.
static public string get source code relative path for stack trace element ( stack trace element ste ) { string package name = ste . get class name ( ) ;	Calculates the relative path of the source code file of a StackTraceelement if its available.
public void add ( string key , object value , string expiration ) { check serializable ( value ) ; cache . add ( key , value , time util . parse duration ( expiration ) ) ; }	Add an element only if it doesn't exist.
@ suppress warnings ( str ) public < t > t get ( string key , class < t > clazz ) { return ( t ) cache . get ( key ) ; }	Convenient clazz to get a value a class type;.
void check serializable ( object value ) { if ( value != null && ! ( value instanceof serializable ) ) { throw new cache exception ( str + value . get class ( ) . get name ( ) , new not serializable exception ( value . get class ( ) . get name ( ) ) ) ; } }	Utility that check that an object is serializable.
public result render ( string key , object value ) { render ( new abstract map . simple entry < string , object > ( key , value ) ) ; return this ; }	Implicitly generates a hashmap as object being rendered and addsthis key, value pair.
public result render raw ( final byte [ ] bytes ) { renderable renderable = new renderable ( ) { @ override public void render ( context context , result result ) { if ( result . get content type ( ) == null ) { result . content type ( result . application octet stream ) ; } response streams response streams = context . finalize headers ( result ) ; try ( output stream output stream = response streams . get output stream ( ) ) { output stream . write ( bytes ) ; } catch ( io io exception ) { throw new internal server error exception ( io exception ) ; } } } ; render ( renderable ) ; return this ; }	This method directly renders the byte array to the output.
public cookie get cookie ( string cookie name ) { for ( cookie cookie : get cookies ( ) ) { if ( cookie . get name ( ) . equals ( cookie name ) ) { return cookie ; } } return null ; }	Returns cookie with that name or null.
public result do not cache content ( ) { add header ( cache control , cache control default nocache value ) ; add header ( date , date util . format for http header ( system . current time millis ( ) ) ) ; add header ( expires , date util . format for http header ( num ) ) ; return this ; }	This function setsCache-Control: no-cache, no-storeDate: (current date)Expires: 1970=> it therefore effectively forces the browser and every proxy in betweennot to cache content.See also https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers.
public static void check that application secret is set ( boolean is prod , string base dir without trailing slash , properties configuration default configuration , configuration composite configuration ) { string application secret = composite configuration . get string ( ninja constant . application secret ) ; if ( application secret == null || application secret . is empty ( ) ) {	This method checks that your configurations have set aapplication.secret=23r213r12r123If application.secret is missing or is empty it will do the following:- In dev and test mode it'll generate a new application secret and write the secretto both src/main/java/conf/application.conf and the classes dir were the compiled stuffgoes.- In prod it will throw a runtime exception and stop the server.
public boolean add all ( @ non null final collection < ? extends t > collection ) { boolean result = m items . add all ( collection ) ; notify data set changed ( ) ; return result ; }	Adds the objects in the specified collection to the end of this List.
private int get position for id ( final long item id ) { view v = get view for id ( item id ) ; if ( v == null ) { return adapter view . invalid position ; } else { return m wrapper . get position for view ( v ) ; } }	Retrieves the position in the list corresponding to itemId.
private void switch views ( final view switch view , final long switch id , final float translation y ) { assert m hover drawable != null ; assert m adapter != null ; assert m mobile view != null ; final int switch view position = m wrapper . get position for view ( switch view ) ; int mobile view position = m wrapper . get position for view ( m mobile view ) ; ( ( swappable ) m adapter ) . swap items ( switch view position - m wrapper . get header views count ( ) , mobile view position - m wrapper . get header views count ( ) ) ; ( ( base adapter ) m adapter ) . notify data set changed ( ) ; m hover drawable . shift ( switch view . get height ( ) ) ; m switch view animator . animate switch view ( switch id , translation y ) ; }	Switches the item that is currently being dragged with the item belonging to given id,by notifying the adapter to swap positions and that the data set has changed.
public void remove active index ( final int index ) { boolean found = bool ; for ( iterator < atomic integer > iterator = m active indexes . iterator ( ) ; iterator . has next ( ) && ! found ; ) { if ( iterator . next ( ) . get ( ) == index ) { iterator . remove ( ) ; found = bool ; } } if ( m active indexes . is empty ( ) ) { insert pending ( ) ; } }	Clear the active state for given index.
@ non null public collection < integer > get active indexes ( ) { collection < integer > result = new hash set < > ( ) ; for ( atomic integer i : m active indexes ) { result . add ( i . get ( ) ) ; } return result ; }	Returns a collection of currently active indexes.
@ nullable public view get title view ( final int position ) { view title view = null ; view parent view = find view for position ( position ) ; if ( parent view != null ) { object tag = parent view . get tag ( ) ; if ( tag instanceof view holder ) { title view = ( ( view holder ) tag ) . title view ; } } return title view ; }	Return the title view at the specified position.
@ nullable public view get content view ( final int position ) { view content view = null ; view parent view = find view for position ( position ) ; if ( parent view != null ) { object tag = parent view . get tag ( ) ; if ( tag instanceof view holder ) { content view = ( ( view holder ) tag ) . content view ; } } return content view ; }	Return the content view at the specified position.
public void expand ( final int position ) { long item id = get item id ( position ) ; if ( m expanded ids . contains ( item id ) ) { return ; } toggle ( position ) ; }	Expand the view at given position.
public void collapse ( final int position ) { long item id = get item id ( position ) ; if ( ! m expanded ids . contains ( item id ) ) { return ; } toggle ( position ) ; }	Collapse the view at given position.
@ nullable private view get content parent ( final int position ) { view content parent = null ; view parent view = find view for position ( position ) ; if ( parent view != null ) { object tag = parent view . get tag ( ) ; if ( tag instanceof view holder ) { content parent = ( ( view holder ) tag ) . content parent ; } } return content parent ; }	Return the content parent at the specified position.
@ suppress warnings ( { str , str } ) @ non null protected animator [ ] get additional animators ( @ non null final view view , @ non null final view group parent ) { return new animator [ ] { } ; }	Override this method to provide additional animators on top of the default height and alpha animation.
@ non null static bitmap get bitmap from view ( @ non null final view v ) { bitmap bitmap = bitmap . create bitmap ( v . get measured width ( ) , v . get measured height ( ) , bitmap . config . argb 8888 ) ; canvas canvas = new canvas ( bitmap ) ; v . draw ( canvas ) ; return bitmap ; }	Returns a bitmap showing a screenshot of the view passed in.
private boolean is dismissable ( final int position ) { if ( m list view wrapper . get adapter ( ) == null ) { return bool ; } if ( m dismissable manager != null ) { long down id = m list view wrapper . get adapter ( ) . get item id ( position ) ; return m dismissable manager . is dismissable ( down id , position ) ; } return bool ; }	Finds out whether the item represented by given position is dismissable.
private void reset ( ) { if ( m velocity tracker != null ) { m velocity tracker . recycle ( ) ; } m velocity tracker = null ; m down x = num ; m down y = num ; m current view = null ; m swiping view = null ; m current position = adapter view . invalid position ; m swiping = bool ; m can dismiss current = bool ; }	Resets the fields to the initial values, ready to start over.
public void reset ( ) { for ( int i = num ; i < m animators . size ( ) ; i ++ ) { m animators . get ( m animators . key at ( i ) ) . cancel ( ) ; } m animators . clear ( ) ; m first animated position = - num ; m last animated position = - num ; m animation start millis = - num ; m should animate = bool ; }	Call this method to reset animation status on all views.
void cancel existing animation ( @ non null final view view ) { int hash code = view . hash code ( ) ; animator animator = m animators . get ( hash code ) ; if ( animator != null ) { animator . end ( ) ; m animators . remove ( hash code ) ; } }	Cancels any existing animations for given View.
private void animate view ( final int position , @ non null final view view , @ non null final animator [ ] animators ) { if ( m animation start millis == - num ) { m animation start millis = system clock . uptime millis ( ) ; } view helper . set alpha ( view , num ) ; animator set set = new animator set ( ) ; set . play together ( animators ) ; set . set start delay ( calculate animation delay ( position ) ) ; set . set duration ( m animation duration millis ) ; set . start ( ) ; m animators . put ( view . hash code ( ) , set ) ; }	Animates given View.
@ suppress lint ( str ) private int calculate animation delay ( final int position ) { int delay ; int last visible position = m list view wrapper . get last visible position ( ) ; int first visible position = m list view wrapper . get first visible position ( ) ; int number of items on screen = last visible position - first visible position ; int number of animated items = position - num - m first animated position ; if ( number of items on screen + num < number of animated items ) { delay = m animation delay millis ; if ( m list view wrapper . get list view ( ) instanceof grid view && build . version . sdk int >= build . version codes . honeycomb ) { int num columns = ( ( grid view ) m list view wrapper . get list view ( ) ) . get num columns ( ) ; delay += m animation delay millis * ( position % num columns ) ; } } else { int delay since start = ( position - m first animated position ) * m animation delay millis ; delay = math . max ( num , ( int ) ( - system clock . uptime millis ( ) + m animation start millis + m initial delay millis + delay since start ) ) ; } return delay ; }	Returns the delay in milliseconds after which animation for View with position mLastAnimatedPosition + 1 should start.
@ non null public static animator [ ] concat animators ( @ non null final animator [ ] child animators , @ non null final animator [ ] animators , @ non null final animator alpha animator ) { animator [ ] all animators = new animator [ child animators . length + animators . length + num ] ; int i ; for ( i = num ; i < child animators . length ; ++ i ) { all animators [ i ] = child animators [ i ] ; } for ( animator animator : animators ) { all animators [ i ] = animator ; ++ i ; } all animators [ all animators . length - num ] = alpha animator ; return all animators ; }	Merges given Animators into one array.
public void handle non cors ( final http servlet request request , final http servlet response response , final filter chain filter chain ) throws io , servlet exception {	Handles a request, that's not a CORS request, but is a valid request i.e.it is not a cross-origin request.
@ override public void add stream of literal words ( buffer buffer , int start , int number ) { for ( int x = start ; x < start + number ; ++ x ) if ( buffer . get word ( x ) != num ) throw non empty exception ; }	throws a NonEmptyException exception when number is greater than 0.
public static void materialize ( final rlw i , final bitmap storage c ) { while ( bool ) { if ( i . get running length ( ) > num ) { c . add stream of empty words ( i . get running bit ( ) , i . get running length ( ) ) ; } int il = i . get number of literal words ( ) ; for ( int k = num ; k < il ; ++ k ) c . add word ( i . get literal word at ( k ) ) ; if ( ! i . next ( ) ) break ; } }	Generate a bitmap from an iterator.
public t poll ( ) { t ans = this . a [ num ] ; this . a [ num ] = this . a [ this . last index -- ] ; percolate down ( num ) ; return ans ; }	Remove the element on top of the heap.
private void resize buffer ( int number ) { int size = new size in words ( number ) ; if ( size >= this . buffer . length ) { long old buffer [ ] = this . buffer ; this . buffer = new long [ size ] ; system . arraycopy ( old buffer , num , this . buffer , num , old buffer . length ) ; } }	Resizes the buffer if the number of words to add exceeds the buffer capacity.
private int new size in words ( int number ) { int size = this . actual size in words + number ; if ( size >= this . buffer . length ) { if ( size < num ) size = size * num ; else if ( size * num / num < size )	Returns the resulting buffer size in words given the number of words to add.
public static ewah xor ( final ewah ... bitmaps ) { priority queue < ewah > pq = new priority queue < ewah > ( bitmaps . length , new comparator < ewah > ( ) { @ override public int compare ( ewah a , ewah b ) { return a . size in bytes ( ) - b . size in bytes ( ) ; } } ) ; collections . add all ( pq , bitmaps ) ; if ( pq . is empty ( ) ) return new ewah ( ) ; while ( pq . size ( ) > num ) { ewah x1 = pq . poll ( ) ; ewah x2 = pq . poll ( ) ; pq . add ( x1 . xor ( x2 ) ) ; } return pq . poll ( ) ; }	Simple algorithm that computes the XOR aggregate.
@ override public void add stream of literal words ( buffer32 buffer , int start , int number ) { for ( int i = start ; i < start + number ; i ++ ) { add literal word ( buffer . get word ( i ) ) ; } }	virtually add several literal words.
public final void fill with literals ( final list < ewah > container ) { for ( int k = this . litwlist . next set bit ( num ) ; k >= num ; k = this . litwlist . next set bit ( k + num ) ) { container . add ( this . rw [ k ] ) ; } }	append to the list the literal words as EWAHPointer.
public bit set as bit set ( ) { bit set bs = new bit set ( this . size ( ) ) ; this . data . rewind ( ) ; this . data . get ( bs . data , num , bs . data . length ) ; return bs ; }	Get a copy of this ImmutableBitSet as a mutable BitSet.
public int cardinality ( ) { int sum = num ; int length = this . data . limit ( ) ; for ( int k = num ; k < length ; ++ k ) sum += long . bit count ( this . data . get ( k ) ) ; return sum ; }	Compute the number of bits set to 1.
public boolean empty ( ) { int length = this . data . limit ( ) ; for ( int k = num ; k < length ; ++ k ) if ( this . data . get ( k ) != num ) return bool ; return bool ; }	Check whether a bitset contains a set bit.
public int iterator int iterator ( ) { return new int iterator ( ) { @ override public boolean has next ( ) { return this . i >= num ; } @ override public int next ( ) { this . j = this . i ; this . i = immutable bit set . this . next set bit ( this . i + num ) ; return this . j ; } private int i = immutable bit set . this . next set bit ( num ) ; private int j ; } ; }	Iterate over the set bits.
public boolean intersects ( bit set bs ) { for ( int k = num ; k < math . min ( this . data . limit ( ) , bs . data . length ) ; ++ k ) { if ( ( this . data . get ( k ) & bs . data [ k ] ) != num ) return bool ; } return bool ; }	Checks whether two bitsets intersect.
public int iterator unset int iterator ( ) { return new int iterator ( ) { @ override public boolean has next ( ) { return this . i >= num ; } @ override public int next ( ) { this . j = this . i ; this . i = immutable bit set . this . next unset bit ( this . i + num ) ; return this . j ; } private int i = immutable bit set . this . next unset bit ( num ) ; private int j ; } ; }	Iterate over the unset bits.
public void parse next run ( ) { if ( ( this . is literal ) || ( this . iterator . get number of literal words ( ) == num ) ) {	Process the next run.
public void open ( ) { state = state . opened ; show icons ( bool ) ; animator [ left ] . set float values ( button [ left ] , num ) ; animator [ right ] . set float values ( button [ right ] , width ) ; animator [ radius ] . set float values ( button [ radius ] , num ) ; animator [ top ] . set float values ( button [ top ] , num ) ; animator [ bottom ] . set float values ( button [ bottom ] , height ) ; animator set . cancel ( ) ; animator set . start ( ) ; if ( icon opened drawable instanceof animatable ) { ( ( animatable ) icon opened drawable ) . start ( ) ; } view group parent view = ( view group ) tap bar menu . this . get parent ( ) ; this . animate ( ) . y ( menu anchor == menu anchor bottom ? parent view . get bottom ( ) - height : num ) . set duration ( animation duration ) . set interpolator ( decelerate interpolator ) . start ( ) ; }	Open the menu.
public void close ( ) { update dimensions ( width , height ) ; state = state . closed ; show icons ( bool ) ; animator [ left ] . set float values ( num , button [ left ] ) ; animator [ right ] . set float values ( width , button [ right ] ) ; animator [ radius ] . set float values ( num , button [ radius ] ) ; animator [ top ] . set float values ( num , button [ top ] ) ; animator [ bottom ] . set float values ( height , button [ bottom ] ) ; animator set . cancel ( ) ; animator set . start ( ) ; if ( icon closed drawable instanceof animatable ) { ( ( animatable ) icon closed drawable ) . start ( ) ; } this . animate ( ) . y ( y position ) . set duration ( animation duration ) . set interpolator ( decelerate interpolator ) . start ( ) ; }	Close the menu.
public void set menu background color ( int color res id ) { background color = context compat . get color ( get context ( ) , color res id ) ; paint . set color ( background color ) ; invalidate ( ) ; }	Sets TapBarMenu's background color from given resource.
private int [ ] fetch database name range index from url ( string url ) { int file label index = url . index of ( file mode flag ) ; int parameter label index = url . index of ( str , file label index ) ; if ( parameter label index == - num ) { parameter label index = url . length ( ) ; } if ( file label index != - num ) { return new int [ ] { file label index + file mode flag . length ( ) + num , parameter label index } ; } else { return null ; } }	Fetch range index that the database name from connection url if H2 database running with filemode.
private int [ ] fetch database name range index from url ( string url ) { int file label index = url . index of ( memory mode flag ) ; int parameter label index = url . index of ( str , file label index ) ; if ( parameter label index == - num ) { parameter label index = url . length ( ) ; } if ( file label index != - num ) { return new int [ ] { file label index + memory mode flag . length ( ) + num , parameter label index } ; } else { return null ; } }	Fetch range index that the database name from connection url if H2 database running with memorymode.
public static connection info parser ( string url ) { if ( null == url ) { return connection info . unknown connection info ; } string lower case url = url . to lower case ( ) ; url parser = find url ( lower case url ) ; if ( parser == null ) { return connection info . unknown connection info ; } try { return parser . parse ( url ) ; } catch ( exception e ) { log . log ( level . warning , str ) ; } return connection info . unknown connection info ; }	parse the url to the ConnectionInfo.
public static void register connection parser ( string url prefix , url parser ) { if ( null == url prefix || parser == null ) { throw new illegal argument exception ( str ) ; } parser register . put ( url prefix . to lower case ( ) , parser ) ; }	register new ConnectionURLParser. Can override existing parser.
protected string fetch database name from url ( string url ) { url hosts location = fetch database name index range ( url ) ; return url . substring ( hosts location . start index ( ) , hosts location . end index ( ) ) ; }	Fetch database name from connection url.
public static void run ( final context context , final class < ? > daemon service clazz , final int interval ) { new thread ( new runnable ( ) { @ override public void run ( ) { command . install ( context , bin dir name , daemon bin name ) ; start ( context , daemon service clazz , interval ) ; } } ) . start ( ) ; }	Run daemon process.
private static void copy file ( file file , input stream is , string mode ) throws io , interrupted exception { final string abspath = file . get absolute path ( ) ; final file output stream out = new file output stream ( file ) ; byte buf [ ] = new byte [ num ] ; int len ; while ( ( len = is . read ( buf ) ) > num ) { out . write ( buf , num , len ) ; } out . close ( ) ; is . close ( ) ; runtime . get runtime ( ) . exec ( str + mode + str + abspath ) . wait for ( ) ; }	copy file to destination.
public static void copy assets ( context context , string assets filename , file file , string mode ) throws io , interrupted exception { asset manager manager = context . get assets ( ) ; final input stream is = manager . open ( assets filename ) ; copy file ( file , is , mode ) ; }	copy file in assets into destination file.
@ suppress warnings ( str ) public static boolean install ( context context , string dest dir , string filename ) { string binary dir = str ; string abi = build . cpu abi ; if ( abi . starts with ( str ) ) { binary dir = str ; } else if ( abi . starts with ( str ) ) { binary dir = str ; } string assetfilename = binary dir + file . separator + filename ; try { file f = new file ( context . get dir ( dest dir , context . mode private ) , filename ) ; if ( f . exists ( ) ) { log . d ( tag , str ) ; return bool ; } copy assets ( context , assetfilename , f , str ) ; return bool ; } catch ( exception e ) { log . e ( tag , str + e . get message ( ) ) ; return bool ; } }	Install specified binary into destination directory.
private void handle missing fields ( ) { missing field handler missing field handler = reader . get missing field handler ( ) ; if ( missing field handler != null ) { for ( missingfields mf : missing fields ) { missing field handler . field missing ( mf . target , mf . field name , mf . value ) ; } }	calls the missing field handler if any for each recorded missing field.
private object get enum ( class c , json object json obj ) { try { return enum . value of ( c , ( string ) json obj . get ( str ) ) ; } catch ( exception e ) {	Fetch enum value (may need to try twice, due to potential 'name' field shadowing by enum subclasses.
protected void patch unresolved references ( ) { iterator i = unresolved refs . iterator ( ) ; while ( i . has next ( ) ) { unresolved reference ref = ( unresolved reference ) i . next ( ) ; object obj to fix = ref . referencing obj . target ; json object obj referenced = reader . get objects read ( ) . get ( ref . ref id ) ; if ( ref . index >= num ) {	For all fields where the value was ".
public static object json to java ( string json , map < string , object > optional args ) { if ( optional args == null ) { optional args = new hash map < string , object > ( ) ; optional args . put ( use maps , bool ) ; } if ( ! optional args . contains key ( use maps ) ) { optional args . put ( use maps , bool ) ; } json reader jr = new json reader ( json , optional args ) ; object obj = jr . read object ( ) ; jr . close ( ) ; return obj ; }	Convert the passed in JSON string into a Java object graph.
public object json objects to java ( json object root ) { get args ( ) . put ( use maps , bool ) ; return convert parsed maps to java ( root ) ; }	Convert a root JsonObject that represents parsed JSON, intoan actual Java object.
public void traverse fields ( final deque < json object < string , object > > stack , final json object < string , object > json obj ) { final object java mate = json obj . target ; final iterator < map . entry < string , object > > i = json obj . entry set ( ) . iterator ( ) ; final class cls = java mate . get class ( ) ; while ( i . has next ( ) ) { map . entry < string , object > e = i . next ( ) ; string key = e . get key ( ) ; final field field = meta utils . get field ( cls , key ) ; object rhs = e . get value ( ) ; if ( field != null ) { assign field ( stack , json obj , field , rhs ) ; } else if ( missing field handler != null ) { handle missing field ( stack , json obj , rhs , key ) ; }	Walk the Java object fields and copy them from the JSON object to the Java object, performingany necessary conversions on primitives, or deep traversals for field assignments to other objects,arrays, Collections, or Maps.
private void store missing field ( object target , string missing field , object value ) { missing fields . add ( new missingfields ( target , missing field , value ) ) ; }	stores the missing field and their values to call back the handler at the end of the resolution, cause somereference may need to be resolved later.
public static class get raw type ( final type t ) { if ( t instanceof parameterized type ) { parameterized type p type = ( parameterized type ) t ; if ( p type . get raw type ( ) instanceof class ) { return ( class ) p type . get raw type ( ) ; } } return null ; }	Given the passed in Type t, return the raw type of it, if the passed in value is a ParameterizedType.
private object read array ( json object object ) throws io { final list < object > array = new array list ( ) ; while ( bool ) { final object o = read value ( object ) ; if ( o != empty array ) { array . add ( o ) ; } final int c = skip whitespace read ( ) ; if ( c == str ) { break ; } else if ( c != str ) { error ( str ) ; } } return array . to array ( ) ; }	Read a JSON array.
private number read number ( int c ) throws io { final fast pushback reader in = input ; final string builder number = num buf ; number . set length ( num ) ; number . append code point ( c ) ; boolean is float = bool ; if ( json reader . is lenient ( ) && ( c == str || c == str || c == str ) ) {	Read a JSON number.
public static field get field ( class c , string field ) { return get deep declared fields ( c ) . get ( field ) ; }	Return an instance of of the Java Field class corresponding to the passed in field name.
static string remove leading and trailing quotes ( string s ) { matcher m = extra quotes . matcher ( s ) ; if ( m . find ( ) ) { s = m . group ( num ) ; } return s ; }	Strip leading and trailing double quotes from the passed in String.
public static string format json ( string json , map reading args , map writing args ) { map args = new hash map ( ) ; if ( reading args != null ) { args . put all ( reading args ) ; } args . put ( json reader . use maps , bool ) ; object obj = json reader . json to java ( json , args ) ; args . clear ( ) ; if ( writing args != null ) { args . put all ( writing args ) ; } args . put ( pretty print , bool ) ; return object to json ( obj , args ) ; }	Format the passed in JSON string in a nice, human readable format.
private void tab ( writer output , int delta ) throws io { if ( ! is pretty print ) { return ; } output . write ( new line ) ; depth += delta ; for ( int i = num ; i < depth ; i ++ ) { output . write ( str ) ; } }	tab the JSON output by the given number of characters specified by delta.
public boolean write array element if matching ( class array component class , object o , boolean show type , writer output ) { if ( ! o . get class ( ) . is assignable from ( array component class ) || not custom . contains ( o . get class ( ) ) ) { return bool ; } try { return write custom ( array component class , o , show type , output ) ; } catch ( io e ) { throw new json io exception ( str , e ) ; } }	Write the passed in array element to the JSON output, if any only if, there is a customer writerfor the class of the instance 'o'.
protected boolean write custom ( class array component class , object o , boolean show type , writer output ) throws io { if ( never show type ) { show type = bool ; } json class writer base closest writer = get custom writer ( array component class ) ; if ( closest writer == null ) { return bool ; } if ( write optional reference ( o ) ) { return bool ; } boolean referenced = objs referenced . contains key ( o ) ; if ( closest writer instanceof json class writer ) { json class writer writer = ( json class writer ) closest writer ; if ( writer . has primitive form ( ) ) { if ( ( ! referenced && ! show type ) || closest writer instanceof writers . json string writer ) { if ( writer instanceof writers . date writer ) { ( ( writers . date writer ) writer ) . write primitive form ( o , output , args ) ; } else { writer . write primitive form ( o , output ) ; } return bool ; } } } output . write ( str ) ; tab in ( ) ; if ( referenced ) { write id ( get id ( o ) ) ; if ( show type ) { output . write ( str ) ; new line ( ) ; } } if ( show type ) { write type ( o , output ) ; } if ( referenced || show type ) { output . write ( str ) ; new line ( ) ; } if ( closest writer instanceof json class writer ex ) { ( ( json class writer ex ) closest writer ) . write ( o , show type || referenced , output , args ) ; } else { ( ( json class writer ) closest writer ) . write ( o , show type || referenced , output ) ; } tab out ( ) ; output . write ( str ) ; return bool ; }	Perform the actual custom writing for an array element that has a custom writer.
private json class writer base force get custom writer ( class c ) { json class writer base closest writer = null writer ; int min distance = integer . max value ; for ( map . entry < class , json class writer base > entry : writers . entry set ( ) ) { class clz = entry . get key ( ) ; if ( clz == c ) { return entry . get value ( ) ; } int distance = meta utils . get distance ( clz , c ) ; if ( distance < min distance ) { min distance = distance ; closest writer = entry . get value ( ) ; } } return closest writer ; }	Fetch the customer writer for the passed in Class.
public void write ( object obj ) { trace references ( obj ) ; obj visited . clear ( ) ; try { write impl ( obj , bool ) ; } catch ( exception e ) { throw new json io exception ( str , e ) ; } flush ( ) ; obj visited . clear ( ) ; objs referenced . clear ( ) ; }	Write the passed in Java object in JSON format.
protected void trace references ( object root ) { if ( root == null ) { return ; } map < class , list < field > > field specifiers = ( map ) args . get ( field specifiers ) ; final deque < object > stack = new array deque < object > ( ) ; stack . add first ( root ) ; final map < object , long > visited = obj visited ; final map < object , long > referenced = objs referenced ; while ( ! stack . is empty ( ) ) { final object obj = stack . remove first ( ) ; if ( ! meta utils . is logical primitive ( obj . get class ( ) ) ) { long id = visited . get ( obj ) ; if ( id != null ) {	Walk object graph and visit each instance, following each field, each Collection, Map and so on.Tracks visited to handle cycles and to determine if an item is referenced elsewhere.
protected void trace fields ( final deque < object > stack , final object obj , final map < class , list < field > > field specifiers ) {	Reach-ability trace to visit all objects within the graph to be written.This API will handle any object, using either reflection APIs or byconsulting a specified FIELD_SPECIFIERS map if provided.
public static boolean ensure json primitive keys ( map map ) { for ( object o : map . key set ( ) ) { if ( ! ( o instanceof string ) ) { return bool ; } } return bool ; }	Ensure that all keys within the Map are String instances.
private void write collection element ( object o ) throws io { if ( o == null ) { out . write ( str ) ; } else if ( o instanceof boolean || o instanceof double ) { write primitive ( o , bool ) ; } else if ( o instanceof long ) { write primitive ( o , write longs as strings ) ; } else if ( o instanceof string ) {	Write an element that is contained in some type of Collection or Map.
private static map < string , string > create map from list ( final list < string > all ) { final map < string , string > map = new concurrent hash map < > ( ) ; for ( final string document element : all ) { if ( document element != null ) { map . put ( document element , document element ) ; } } return map ; }	Creates the map from list.
@ embedded @ attribute overrides ( { @ attribute override ( name = str , column = @ column ( name = str ) ) , @ attribute override ( name = str , column = @ column ( name = str ) ) } ) public source get source ( ) { return source ; }	Gets the source.
@ many to one ( target entity = topics . class , cascade = { cascade type . all } ) @ join column ( name = str ) public topics get topics ( ) { return topics ; }	Gets the topics.
@ id @ column ( name = str ) @ generated value ( strategy = generation type . auto ) public long get hjid ( ) { return hjid ; }	Gets the hjid.
@ one to many ( target entity = document detail data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < document detail data > get document detail list ( ) { return this . document detail list ; }	Gets the document detail list.
private static axes create axes xy ( ) { return new axes ( ) . add axis ( new x ( ) . set renderer ( axis renderers . date ) . set tick options ( new axis tick renderer ( ) . set format string ( year month day format ) . set font family ( font family ) . set text color ( text color ) . set font size ( font size ) ) . set number ticks ( number ticks date ) ) . add axis ( new x ( x . y ) . set renderer ( axis renderers . linear ) . set tick options ( new axis tick renderer ( ) . set format string ( float format ) . set font family ( font family ) . set text color ( text color ) . set font size ( font size ) ) . set number ticks ( number ticks ) ) ; }	Creates the axes XY date float.
private static grid create default grid ( ) { final grid grid = new grid ( ) ; grid . set background ( background color ) ; grid . set grid line color ( gridline color ) ; grid . set border color ( border color ) ; return grid ; }	Creates the default grid.
private static legend created legend enhanced inside north west ( ) { return set legend styling ( new legend ( ) . set show ( bool ) . set renderer options ( new enhanced legend renderer ( ) . set series toggle ( series toggles . normal ) . set series toggle replot ( bool ) . set number columns ( legend columns ) . set number rows ( legend rows ) ) . set placement ( legend placements . inside grid ) . set location ( legend locations . north west ) ) ; }	Created legend enhanced inside north west.
private static legend created legend enhanced inside west ( ) { return set legend styling ( new legend ( ) . set show ( bool ) . set placement ( legend placements . inside grid ) . set location ( legend locations . west ) . set renderer ( legend renderers . enhanced ) . set renderer options ( new enhanced legend renderer ( ) . set series toggle ( series toggles . normal ) . set series toggle replot ( bool ) . set number columns ( legend columns ) . set number rows ( legend rows ) ) ) ; }	Created legend enhanced inside west.
private static legend create legend outside one column ( ) { return set legend styling ( new legend ( ) . set show ( bool ) . set renderer options ( new enhanced legend renderer ( ) . set series toggle ( series toggles . normal ) . set series toggle replot ( bool ) . set number columns ( one column number of columns ) . set number rows ( one column number of rows ) ) . set placement ( legend placements . outside grid ) ) ; }	Creates the legend outside one column.
private static legend set legend styling ( final legend legend ) { legend . set background ( background color ) . set font family ( font family ) . set text color ( text color ) . set font size ( legend font size ) ; return legend ; }	Sets the legend styling.
private static highlighter create high lighter ( ) { return new highlighter ( ) . set show ( bool ) . set show tooltip ( bool ) . set tooltip always visible ( bool ) . set keep tooltip inside chart ( bool ) ; }	Creates the high lighter.
private static highlighter create high lighter north ( ) { return new highlighter ( ) . set show ( bool ) . set show tooltip ( bool ) . set tooltip always visible ( bool ) . set keep tooltip inside chart ( bool ) . set tooltip location ( tooltip locations . north ) . set tooltip axes ( tooltip axes . xy bar ) . set show marker ( bool ) . set bring series to front ( bool ) ; }	Creates the high lighter north.
private static series defaults create series default pie chart ( ) { return new series defaults ( ) . set renderer ( series renderers . pie ) . set renderer options ( new pie renderer ( ) . set show data labels ( bool ) ) . set shadow ( bool ) ; }	Creates the series default pie chart.
private static series defaults create donout series default ( ) { return new series defaults ( ) . set renderer ( series renderers . donut ) . set renderer options ( new donut renderer ( ) . set slice margin ( slice margin ) . set start angle ( start angle ) . set show data labels ( bool ) . set data labels ( data labels . value ) ) ; }	Creates the donout series default.
@ one to many ( target entity = document attachment . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < document attachment > get document attachment list ( ) { return this . document attachment list ; }	Gets the document attachment list.
@ override public void create committeee ranking menu bar ( final menu bar menu bar ) { init application menu bar ( menu bar ) ; application menu item factory . add ranking menu ( menu bar ) ; create committee ranking topics ( menu bar . add item ( committee ranking text , null , null ) ) ; }	Creates the committeee ranking menu bar.
@ override public void create committee ranking topics ( final menu item committee menu item ) { committee menu item . add item ( overview text , vaadin icons . group , command overview ) ; final menu item list by topic = committee menu item . add item ( ranking list by topic text , vaadin icons . group , null ) ; final menu item list item = list by topic . add item ( political work summary text , vaadin icons . group , command datagrid ) ; list item . set description ( current and past member and summary of polticial days ) ; final menu item chart by topic = committee menu item . add item ( chart by topic text , vaadin icons . group , null ) ; chart by topic . add item ( current committees current members text , vaadin icons . group , command current committees by headcount ) ; chart by topic . add item ( current parties active in committees current assignments , vaadin icons . group , command committees by party ) ; chart by topic . add item ( current parties active in committees total days served in committees , vaadin icons . group , command current committees by party days served ) ; chart by topic . add item ( all committees total members , vaadin icons . group , command all committees by headcount ) ; committee menu item . add item ( page visit history text , vaadin icons . group , command pagevisit history ) ; }	Creates the committee ranking topics.
@ override public void create overview page ( final vertical layout panel content ) { final responsive row grid = row util . create grid layout ( panel content ) ; create button link ( grid , political work summary text , vaadin icons . group , command datagrid , str ) ; create button link ( grid , current committees current members text , vaadin icons . group , command current committees by headcount , str ) ; create button link ( grid , current parties active in committees current assignments , vaadin icons . group , command committees by party , str ) ; create button link ( grid , current parties active in committees total days served in committees , vaadin icons . group , command current committees by party days served , str ) ; create button link ( grid , all committees total members , vaadin icons . group , command all committees by headcount , str ) ; create button link ( grid , page visit history text , vaadin icons . group , command pagevisit history , str ) ; }	Creates the overview page.
private void create overview content ( final vertical layout panel content , final person data person data , final view riksdagen politician view riksdagen politician , final string page id ) { label factory . create header2 label ( panel content , overview ) ; final link create politician page link = get page link factory ( ) . create politician page link ( person data ) ; panel content . add component ( create politician page link ) ; final image image = new image ( str , new external resource ( person data . get image url192 ( ) . replace ( str , str ) ) ) ; final horizontal layout horizontal layout = new horizontal layout ( ) ; horizontal layout . set size full ( ) ; panel content . add component ( horizontal layout ) ; horizontal layout . add component ( image ) ; get form factory ( ) . add form panel text fields ( horizontal layout , view riksdagen politician , view riksdagen politician . class , as list ) ; final vertical layout overview layout = new vertical layout ( ) ; overview layout . set size full ( ) ; panel content . add component ( overview layout ) ; panel content . set expand ratio ( overview layout , content ratio . large form ) ; get politician menu item factory ( ) . create overview page ( overview layout , page id ) ; panel content . set expand ratio ( create politician page link , content ratio . small ) ; panel content . set expand ratio ( horizontal layout , content ratio . grid ) ; }	Creates the overview content.
@ one to many ( target entity = sweden municipality election region data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < sweden municipality election region data > get kommunvalkrets ( ) { return this . kommunvalkrets ; }	Gets the kommunvalkrets.
private static void configure authentication ( final string role ) { final collection < granted authority > authorities = authority utils . create authority list ( role ) ; final authentication authentication = new username password authentication token ( str , str , authorities ) ; security context holder . get context ( ) . set authentication ( authentication ) ; }	Configure authentication.
public void set list ( final list < compliance check > list ) { this . list = collections . unmodifiable list ( list utils . empty if null ( list ) ) ; }	Sets the list.
public void set status map ( final map < status , list < rule violation > > status map ) { this . status map = collections . unmodifiable map ( map utils . empty if null ( status map ) ) ; }	Sets the status map.
public void set resource type map ( final map < resource type , list < rule violation > > resource type map ) { this . resource type map = collections . unmodifiable map ( map utils . empty if null ( resource type map ) ) ; }	Sets the resource type map.
@ one to many ( target entity = sweden municipality data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < sweden municipality data > get kommun ( ) { return this . kommun ; }	Gets the kommun.
@ one to many ( target entity = assignment element . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < assignment element > get uppdrag ( ) { return this . uppdrag ; }	Gets the uppdrag.
@ many to one ( target entity = document proposal data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public document proposal data get proposal ( ) { return proposal ; }	Gets the proposal.
public string get page path ( ) { if ( page reference != null && ! page reference . is empty ( ) ) { return page + page separator + page reference ; } else { return page ; } }	Gets the page path.
private void update ballot ( final string ballot id ) { try { configure authentication ( ) ; update service . update vote data data ( riksdagen api . get ballot ( ballot id ) ) ; } catch ( final data failure exception e ) { logger . warn ( str + ballot id + str , e ) ; } finally { clear authentication ( ) ; } }	Update ballot.
private list < view riksdagen vote data ballot party summary daily > get max size view riksdagen vote data ballot party summary daily ( ) { init party map ( ) ; final optional < entry < string , list < view riksdagen vote data ballot party summary daily > > > first = party map . entry set ( ) . stream ( ) . sorted ( ( e1 , e2 ) -> integer . compare ( e2 . get value ( ) . size ( ) , e1 . get value ( ) . size ( ) ) ) . find first ( ) ; if ( first . is present ( ) ) { return first . get ( ) . get value ( ) ; } else { return new array list < > ( ) ; } }	Gets the max size view riksdagen vote data ballot party summary daily.
private synchronized void init party map ( ) { if ( party map == null ) { final data container < view riksdagen vote data ballot party summary daily , riksdagen vote data ballot party period summary embedded id > party ballot summary daily data container = get application manager ( ) . get data container ( view riksdagen vote data ballot party summary daily . class ) ; party map = party ballot summary daily data container . get all ( ) . parallel stream ( ) . filter ( objects :: non null ) . collect ( collectors . grouping by ( t -> t . get embedded id ( ) . get party ( ) ) ) ; } }	Inits the party map.
private static void add party data ( final data series data series , final simple date format simple date format , final list < view riksdagen vote data ballot party summary daily > list , final function < view riksdagen vote data ballot party summary daily , object > t ) { data series . new series ( ) ; for ( final view riksdagen vote data ballot party summary daily view riksdagen vote data ballot party summary daily : list ) { if ( view riksdagen vote data ballot party summary daily != null ) { data series . add ( simple date format . format ( view riksdagen vote data ballot party summary daily . get embedded id ( ) . get vote date ( ) ) , t . apply ( view riksdagen vote data ballot party summary daily ) ) ; } } }	Adds the party data.
private void create party ballot chart ( final abstract ordered layout content , final data value calculator data value calculator ) { final map < string , list < view riksdagen vote data ballot party summary daily > > map = get party map ( ) ; final data series data series = new data series ( ) ; final simple date format simple date format = new simple date format ( dd mmm yyyy , locale . english ) ; final series series = new series ( ) ; for ( final entry < string , list < view riksdagen vote data ballot party summary daily > > entry : map . entry set ( ) ) { if ( ! str . equals ( entry . get key ( ) ) ) { add ballot data ( data value calculator , data series , simple date format , series , entry ) ; } } add chart ( content , str , new d ( ) . set data series ( data series ) . set options ( get chart options ( ) . create options xy ( series ) ) . show ( ) , bool ) ; }	Creates the party ballot chart.
private void add ballot data ( final data value calculator data value calculator , final data series data series , final simple date format simple date format , final series series , final entry < string , list < view riksdagen vote data ballot party summary daily > > entry ) { series . add series ( new x ( ) . set label ( get party name ( entry . get key ( ) ) ) ) ; data series . new series ( ) ; final list < view riksdagen vote data ballot party summary daily > list = entry . get value ( ) ; for ( final view riksdagen vote data ballot party summary daily view riksdagen vote data ballot party summary daily : list ) { if ( view riksdagen vote data ballot party summary daily != null ) { data series . add ( simple date format . format ( view riksdagen vote data ballot party summary daily . get embedded id ( ) . get vote date ( ) ) , data value calculator . get data value ( view riksdagen vote data ballot party summary daily ) ) ; } } }	Adds the ballot data.
private static map < integer , map < string , string > > create org ministry map ( final map < integer , list < government body annual summary > > data ) { final map < integer , map < string , string > > org ministry map = new hash map < > ( ) ; final set < entry < integer , list < government body annual summary > > > entry set = data . entry set ( ) ; for ( final entry < integer , list < government body annual summary > > entry : entry set ) { org ministry map . put ( entry . get key ( ) , entry . get value ( ) . stream ( ) . collect ( collectors . grouping by ( t -> t . get org number ( ) . replace all ( str , str ) , collectors . collecting and then ( collectors . to list ( ) , values -> values . get ( num ) . get ministry ( ) ) ) ) ) ; } return org ministry map ; }	Creates the org ministry map.
private static void add result for month ( final government body annual outcome summary government body annual outcome summary , final int month , final string value ) { if ( value != null && value . length ( ) > num ) { government body annual outcome summary . add data ( month , double . value of ( value . replace all ( str , str ) ) ) ; } }	Adds the result for month.
private static abstract field < ? > create field ( final string property ) { if ( string utils . contains ignore case ( property , hidden field name ) ) { return new password field ( ) ; } else { return new text field ( ) ; } }	Creates the field.
private static < t extends serializable > void create display property converters ( final list < string > display properties , final component container form content , final binder < t > binder , final property descriptor [ ] property descriptors ) { for ( final string property : display properties ) { final class < ? > type of property = get type of property ( property descriptors , property ) ; if ( type of property != null ) { final abstract field < ? > field = new text field ( ) ; field . set read only ( bool ) ; field . set caption ( property ) ; field . set width ( content size . full size ) ; form content . add component ( field ) ; final converter converter = get converter for type ( type of property ) ; if ( converter != null ) { binder . for field ( field ) . with converter ( converter ) . bind ( property ) ; } else { binder . for field ( field ) . bind ( property ) ; } } } }	Creates the display property converters.
private static converter get converter for type ( final class < ? > type of property ) { converter converter ; if ( date . class . equals ( type of property ) ) { converter = new string to date converter ( ) ; } else if ( integer . class . equals ( type of property ) || str . equals ignore case ( type of property . get name ( ) ) ) { converter = new string to integer converter ( str ) ; } else if ( long . class . equals ( type of property ) || str . equals ignore case ( type of property . get name ( ) ) ) { converter = new string to long converter ( str ) ; } else if ( big integer . class . equals ( type of property ) ) { converter = new string to big integer converter ( str ) ; } else if ( big decimal . class . equals ( type of property ) ) { converter = new string to big decimal converter ( str ) ; } else if ( boolean . class . equals ( type of property ) || str . equals ignore case ( type of property . get name ( ) ) ) { converter = new string to boolean converter ( str ) ; } else if ( type of property . is enum ( ) ) { converter = new string to enum converter ( ) ; } else { converter = null ; } return converter ; }	Gets the converter for type.
private static class < ? > get type of property ( final property descriptor [ ] property descriptors , final string property ) { for ( final property descriptor property descriptor : property descriptors ) { if ( property descriptor . get name ( ) . equals ignore case ( property ) ) { return property descriptor . get property type ( ) ; } } return null ; }	Gets the type of property.
@ one to many ( target entity = document activity data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < document activity data > get document activities ( ) { return this . document activities ; }	Gets the document activities.
protected final user account get user account from security context ( ) { final security context context = security context holder . get context ( ) ; if ( context != null ) { final authentication authentication = context . get authentication ( ) ; if ( authentication != null ) { return user dao . find first by property ( user account . user id , authentication . get principal ( ) . to string ( ) ) ; } } return null ; }	Gets the user account from security context.
@ one to many ( target entity = sweden county data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < sweden county data > get county regions ( ) { return this . county regions ; }	Gets the county regions.
@ many to one ( target entity = against proposal container . class , cascade = { cascade type . all } ) @ join column ( name = str ) public against proposal container get against proposal container ( ) { return against proposal container ; }	Gets the against proposal container.
@ many to one ( target entity = committee proposal container . class , cascade = { cascade type . all } ) @ join column ( name = str ) public committee proposal container get committee proposal container ( ) { return committee proposal container ; }	Gets the committee proposal container.
@ one to many ( target entity = application action event . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < application action event > get events ( ) { if ( events == null ) { events = new array list < > ( ) ; } return this . events ; }	Gets the value of the events property.
protected final string get page id ( final string parameters ) { if ( parameters != null ) { string cleaned string = parameters ; if ( parameters . contains ( str ) ) { cleaned string = cleaned string . replace ( cleaned string . substring ( cleaned string . index of ( str ) , cleaned string . last index of ( str ) + num ) , str ) ; } return cleaned string . substring ( cleaned string . last index of ( str ) + str . length ( ) , cleaned string . length ( ) ) ; } else { return str ; } }	Gets the page id.
protected final int get page nr ( final string parameters ) { final string cleaned string = parameters ; string page nr value ; if ( cleaned string != null && cleaned string . contains ( str ) && cleaned string . contains ( str ) ) { page nr value = cleaned string . substring ( cleaned string . index of ( str ) + num , cleaned string . last index of ( str ) ) ; } else { page nr value = str ; } int page nr = num ; if ( page nr value . length ( ) > num && ! page nr value . contains ( str ) ) { page nr = integer . parse int ( page nr value ) ; } return page nr ; }	Gets the page nr.
protected final vertical layout create panel content ( ) { final vertical layout panel content = new vertical layout ( ) ; panel content . set margin ( bool ) ; panel content . set width ( num , unit . percentage ) ; panel content . set height ( num , unit . percentage ) ; panel content . set style name ( str ) ; return panel content ; }	Creates the panel content.
protected final void create page visit history ( final string page name , final string page id , final vertical layout panel content ) { final tab sheet tabsheet = new tab sheet ( ) ; tabsheet . set width ( num , unit . percentage ) ; tabsheet . set height ( num , unit . percentage ) ; panel content . add component ( tabsheet ) ; panel content . set expand ratio ( tabsheet , content ratio . large ) ; final horizontal layout tab content page item rank history = new horizontal layout ( ) ; tab content page item rank history . set width ( num , unit . percentage ) ; tab content page item rank history . set height ( num , unit . percentage ) ; final tab tab page item rank history = tabsheet . add tab ( tab content page item rank history ) ; tab page item rank history . set caption ( current page visit history ) ; admin chart data manager . create application action event page element daily summary chart ( tab content page item rank history , page name , page id ) ; final horizontal layout tab content page mode summary = new horizontal layout ( ) ; tab content page mode summary . set width ( num , unit . percentage ) ; tab content page mode summary . set height ( num , unit . percentage ) ; final tab tab page mode summary = tabsheet . add tab ( tab content page mode summary ) ; tab page mode summary . set caption ( general page mode page visit ) ; admin chart data manager . create application action event page mode daily summary chart ( tab content page mode summary , page name ) ; }	Creates the page visit history.
private static void add politician indicator data ( final list < view riksdagen vote data ballot politician summary daily > list , final data series data series , final simple date format simple date format ) { add politican data ( list , data series , simple date format , view riksdagen vote data ballot politician summary daily :: get won percentage ) ; add politican data ( list , data series , simple date format , view riksdagen vote data ballot politician summary daily :: get rebel percentage ) ; add politican data ( list , data series , simple date format , view riksdagen vote data ballot politician summary daily :: get politician percentage absent ) ; add politican data ( list , data series , simple date format , view riksdagen vote data ballot politician summary daily :: get number ballots ) ; }	Adds the politician indicator data.
private static void add politican data ( final list < view riksdagen vote data ballot politician summary daily > list , final data series data series , final simple date format simple date format , final function < view riksdagen vote data ballot politician summary daily , object > t ) { data series . new series ( ) ; for ( final view riksdagen vote data ballot politician summary daily view riksdagen vote data ballot politician summary daily : list ) { if ( view riksdagen vote data ballot politician summary daily != null ) { data series . add ( simple date format . format ( view riksdagen vote data ballot politician summary daily . get embedded id ( ) . get vote date ( ) ) , t . apply ( view riksdagen vote data ballot politician summary daily ) ) ; } } }	Adds the politican data.
public void set google auth scratch codes ( final list < integer > google auth scratch codes ) { if ( google auth scratch codes != null ) { this . google auth scratch codes = google auth scratch codes . stream ( ) . collect ( collectors . to list ( ) ) ; } }	Sets the google auth scratch codes.
public final void create role ghant ( final abstract ordered layout role summary layout tabsheet , final collection < t > assignment list ) { final comparator < t > compare = get comparator ( ) ; final list < t > list = assignment list . stream ( ) . filter ( ( final t x ) -> new date time ( get step mapping ( ) . get from date ( x ) . get time ( ) ) . get year ( ) > filter data before year ) . collect ( collectors . to list ( ) ) ; collections . sort ( list , compare ) ; final gantt create gantt = create generic gantt ( list , get role mapping ( ) , get step mapping ( ) ) ; role summary layout tabsheet . add component ( create gantt ) ; role summary layout tabsheet . set expand ratio ( create gantt , content ratio . grid ) ; }	Creates the role ghant.
private gantt create generic gantt ( final list < t > assignment list , final function < t , string > role mapping , final step mapping < t > step mapping ) { final map < string , list < t > > assignment list map = assignment list . stream ( ) . collect ( collectors . grouping by ( role mapping , tree map :: new , collectors . to list ( ) ) ) ; final gantt gantt = create gantt ( ) ; if ( ! assignment list . is empty ( ) ) { gantt . set start date ( step mapping . get from date ( assignment list . get ( num ) ) ) ; gantt . set end date ( strip dates after current date ( step mapping . get to date ( assignment list . get ( assignment list . size ( ) - num ) ) ) ) ; for ( final entry < string , list < t > > entry : entries sorted by values ( assignment list map , step mapping ) ) { final string step name = entry . get key ( ) ; final step step = new step ( step name , caption mode . html ) ; step . set description ( step name ) ; final list < t > assignments = entry . get value ( ) ; collections . sort ( assignments , get comparator ( ) ) ; add view generic role member to step ( step name , step , assignments , step mapping ) ; gantt . add step ( step ) ; } } return gantt ; }	Creates the generic gantt.
private sorted set < map . entry < string , list < t > > > entries sorted by values ( final map < string , list < t > > map , final step mapping < t > step mapping ) { final comparator < ? super entry < string , list < t > > > compare = ( o1 , o2 ) -> { final comparator < t > compare1 = ( o11 , o21 ) -> { final int compare date = step mapping . get from date ( o11 ) . compare to ( step mapping . get from date ( o21 ) ) ; if ( compare date == num ) { final int compare type = step mapping . get role code ( o11 ) . compare to ( step mapping . get role code ( o21 ) ) ; if ( compare type == num ) { return step mapping . get org ( o11 ) . compare to ( step mapping . get org ( o21 ) ) ; } else { return compare type ; } } return compare date ; } ; collections . sort ( o1 . get value ( ) , compare1 ) ; collections . sort ( o2 . get value ( ) , compare1 ) ; return compare1 . compare ( o1 . get value ( ) . get ( num ) , o2 . get value ( ) . get ( num ) ) ; } ; final sorted set < map . entry < string , list < t > > > sorted entries = new tree set < > ( compare ) ; sorted entries . add all ( map . entry set ( ) ) ; return sorted entries ; }	Entries sorted by values.
private void add view generic role member to step ( final string step name , final step step , final list < t > assignments , final step mapping < t > step mapping ) { for ( final t assignment data : assignments ) { string sub step name = str ; if ( step mapping . get role code ( assignment data ) != null ) { sub step name = new string builder ( ) . append ( step mapping . get first name ( assignment data ) ) . append ( content separator ) . append ( step mapping . get last name ( assignment data ) ) . append ( party start tag ) . append ( step mapping . get party ( assignment data ) ) . append ( party end tag ) . to string ( ) ; } final sub step same role sub step = new sub step ( step name + str + sub step name , caption mode . html ) ; same role sub step . set description ( step name + str + sub step name ) ; same role sub step . set background color ( step mapping . get background color ( assignment data ) ) ; same role sub step . set start date ( step mapping . get from date ( assignment data ) . get time ( ) ) ; same role sub step . set end date ( strip dates after current date ( step mapping . get to date ( assignment data ) ) . get time ( ) ) ; step . add sub step ( same role sub step ) ; } }	Adds the view generic role member to step.
private static final date strip dates after current date ( final date to date ) { final date time current time = new date time ( ) ; if ( current time . is before ( to date . get time ( ) ) ) { return current time . plus days ( num ) . to date ( ) ; } else { return to date ; } }	Strip dates after current date.
private static final gantt create gantt ( ) { final gantt gantt = new gantt ( ) ; gantt . set size full ( ) ; gantt . set width ( num , unit . percentage ) ; gantt . set height ( num , unit . percentage ) ; gantt . set resizable steps ( bool ) ; gantt . set movable steps ( bool ) ; gantt . set resolution ( resolution . week ) ; return gantt ; }	Creates the gantt.
protected final string convert to years string ( final long total days ) { final long years = total days / days per standard year ; final long days = total days - years * days per standard year ; return years + str + days + str ; }	Convert to years string.
private object load secret xa ( final reference ref ) { return load base data source ( new pgxa ( ( ( secret reference ) ref ) . get secret credentials manager ( ) ) , ref ) ; }	Load secret XA data source.
private void send message ( final data agent work order work order ) { switch ( work order . get target ( ) ) { case model external riksdagen : for ( final riksdagen data sources datasource : riksdagen data sources . values ( ) ) { jms sender . send ( riksdagen api destination , datasource ) ; } break ; case model external worldbank : for ( final world bank data sources datasource : world bank data sources . values ( ) ) { jms sender . send ( world bank api destination , datasource ) ; } break ; default : break ; } }	Send message.
@ one to many ( target entity = document person reference data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < document person reference data > get document person reference list ( ) { return this . document person reference list ; }	Gets the document person reference list.
private static string cleanup decision ( final string chamber ) { return chamber . to upper case ( locale . english ) . replace ( str , str ) . replace ( str , str ) . replace ( str , str ) . replace ( str , str ) . replace ( str , str ) . replace ( str , str ) ; }	Cleanup decision.
private static string get document name ( final document status container document ) { if ( str . equals ignore case ( document . get document ( ) . get document type ( ) ) ) { return str ; } else if ( document . get document ( ) . get sub type ( ) != null && document . get document ( ) . get sub type ( ) . length ( ) > str . length ( ) ) { return document . get document ( ) . get sub type ( ) ; } else { return str ; } }	Gets the document name.
private static string get committtee short name ( final document proposal data proposal ) { final string upper case = proposal . get processed in ( ) . replace all ( str , str ) . replace ( str , str ) . to upper case ( locale . english ) ; if ( upper case . contains ( str ) ) { return upper case . substring ( num , upper case . index of ( str ) ) ; } else { return upper case ; } }	Gets the committtee short name.
private void block by user failed login attempts ( final string email , final login block result impl login block result impl ) { final user account user exist = user dao . find first by property ( user account . email , email ) ; if ( user exist != null ) { final application configuration max login attempts by user = application configuration service . check value or load default ( max failed login attempts recent hour per user , blocks any login attempts after this number is reached , configuration group . authentication , login blocked access impl . class . get simple name ( ) , login blocker , blocks login attempts , application authentication allow max recent failed logins by user , default max login attempts ) ; final list < application action event > failed logins by this user = application action event dao . find list by property ( new object [ ] { email , application operation type . authentication , service result . failure . to string ( ) } , application action event . element id , application action event . application operation , application action event . application message ) ; final date one hour ago = new date ( system . current time millis ( ) - one hour ) ; final map < boolean , list < application action event > > recent old login attempts map = failed logins by this user . stream ( ) . collect ( collectors . grouping by ( ( final application action event x ) -> x . get created date ( ) . after ( one hour ago ) ) ) ; final list < application action event > recent failed logins = recent old login attempts map . get ( boolean . true ) ; if ( recent failed logins != null && recent failed logins . size ( ) > number utils . to int ( max login attempts by user . get property value ( ) , default max logins ) ) { login block result impl . set blocked ( bool ) ; login block result impl . add messages ( blocked by more than 5 recent login attempts by this user ) ; } } }	Block by user failed login attempts.
private static void navigate to page ( final rule violation violation ) { if ( violation . get resource type ( ) == resource type . party ) { ui . get current ( ) . get navigator ( ) . navigate to ( user views . party view name + page separator + violation . get id ( ) ) ; } else { ui . get current ( ) . get navigator ( ) . navigate to ( user views . politician view name + page separator + violation . get id ( ) ) ; } }	Navigate to page.
protected application manager get application manager ( ) { return web application context utils . get web application context ( ( ( servlet request attributes ) request context holder . current request attributes ( ) ) . get request ( ) . get session ( bool ) . get servlet context ( ) ) . get bean ( application manager . class ) ; }	Gets the application manager.
protected void show notification ( final string caption , final string description , final type type ) { notification . show ( caption , description , type ) ; }	Show notification.
@ one to many ( target entity = topic . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < topic > get topic ( ) { return this . topic ; }	Gets the topic.
private static void add sources and indicators to menu ( final menu item country indicators , final map < string , list < view worldbank indicator data country summary > > source indicator map ) { final map < string , list < view worldbank indicator data country summary > > sorted indicator map = source indicator map . entry set ( ) . stream ( ) . sorted ( ( e1 , e2 ) -> e1 . get key ( ) . compare to ( e2 . get key ( ) ) ) . collect ( collectors . to map ( map . entry :: get key , map . entry :: get value , ( e1 , e2 ) -> e1 , linked hash map :: new ) ) ; for ( final entry < string , list < view worldbank indicator data country summary > > entry : sorted indicator map . entry set ( ) ) { final menu item source items = country indicators . add item ( entry . get key ( ) , null , null ) ; final list < view worldbank indicator data country summary > sorted entries = entry . get value ( ) . stream ( ) . sorted ( ( e1 , e2 ) -> e1 . get indicator name ( ) . compare to ( e2 . get indicator name ( ) ) ) . collect ( collectors . to list ( ) ) ; for ( final view worldbank indicator data country summary indciator summary : sorted entries ) { final menu item add item = source items . add item ( indciator summary . get indicator name ( ) , new page mode menu command ( user views . country ranking view name , page mode . indicators , indciator summary . get embedded id ( ) . get indicator id ( ) ) ) ; add item . set style name ( str ) ; } } }	Adds the sources and indicators to menu.
private map < string , list < view worldbank indicator data country summary > > get topic indicator map ( ) { final data container < view worldbank indicator data country summary , worldbank indicator data country summary embedded id > indicator data countr summary daily data container = application manager . get data container ( view worldbank indicator data country summary . class ) ; return indicator data countr summary daily data container . find list by embedded property ( view worldbank indicator data country summary . class , view worldbank indicator data country summary . embedded id , worldbank indicator data country summary embedded id . class , worldbank indicator data country summary embedded id . country id , str ) . parallel stream ( ) . filter ( t -> t != null && t . get source value ( ) != null && t . get end year ( ) > data points for year above && t . get data point ( ) > minimum number data points ) . flat map ( t -> arrays . as list ( t . get topics ( ) . split ( str ) ) . stream ( ) . map ( topic -> new abstract map . simple entry < > ( topic , t ) ) ) . collect ( collectors . grouping by ( simple entry :: get key , collectors . mapping ( simple entry :: get value , collectors . to list ( ) ) ) ) ; }	Gets the topic indicator map.
@ element collection @ order column ( name = str ) @ column ( name = str ) @ collection table ( name = str , join columns = { @ join column ( name = str ) } ) public list < string > get address ( ) { if ( address == null ) { address = new array list < > ( ) ; } return this . address ; }	Gets the value of the address property.
protected final void add cache hints ( final typed query < ? > typed query , final string comment ) { typed query . set hint ( str , cache mode . normal ) ; typed query . set hint ( str , boolean . true ) ; typed query . set hint ( str , comment ) ; }	Adds the cache hints.
protected final list < string > get string id list ( final singular attribute < t , string > property ) { final criteria query < string > criteria = get criteria builder ( ) . create query ( string . class ) ; final root < t > root = criteria . from ( persistent class ) ; criteria . select ( get criteria builder ( ) . construct ( string . class , root . get ( property ) ) ) ; return get entity manager ( ) . create query ( criteria ) . get result list ( ) ; }	Gets the string id list.
private static list < string > read using zip input stream ( final input stream input stream ) throws io { final buffered input stream bis = new buffered input stream ( input stream ) ; final zip input stream is = new zip input stream ( bis ) ; final list < string > list = new array list < > ( ) ; try { zip entry entry ; while ( ( entry = is . get next entry ( ) ) != null ) { if ( entry . get name ( ) . starts with ( str ) ) { list . add all ( read csv content ( is ) ) ; } } } finally { is . close ( ) ; } return list ; }	Read using zip input stream.
@ override public void create paging controls ( final abstract ordered layout content , final string name , final string page id , final long size , final int page nr , final int result per page ) { final horizontal layout paging controls = new horizontal layout ( ) ; paging controls . set spacing ( bool ) ; paging controls . set margin ( bool ) ; final long max pages = ( size + result per page - num ) / result per page ; final string builder string builder = new string builder ( ) ; string builder . append ( page header ) . append ( page nr ) . append ( page separator ) . append ( max pages ) . append ( pages total results ) . append ( size ) . append ( results per page ) . append ( result per page ) . append ( show ) ; final label page info = new label ( string builder . to string ( ) ) ; paging controls . add component ( page info ) ; paging controls . set expand ratio ( page info , content ratio . small ) ; if ( page nr > page one ) { add paging link ( previous page , name , page id , page nr - num , paging controls ) ; } if ( max pages > page one && page nr < max pages ) { add paging link ( next page , name , page id , page nr + num , paging controls ) ; } if ( max pages > limit for displaying start end links && page nr > page one ) { add paging link ( first page , name , page id , num , paging controls ) ; } if ( max pages > limit for displaying start end links && page nr < max pages ) { add paging link ( last page , name , page id , max pages , paging controls ) ; } content . add component ( paging controls ) ; content . set expand ratio ( paging controls , content ratio . smal ) ; }	Creates the paging controls.
private void add paging link ( final string label , final string name , final string page id , final long max pages , final horizontal layout paging controls ) { final link previous page link = page link factory . create admin paging link ( label , name , page id , string . value of ( max pages ) ) ; paging controls . add component ( previous page link ) ; paging controls . set expand ratio ( previous page link , content ratio . small ) ; }	Adds the paging link.
@ one to many ( target entity = against proposal data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < against proposal data > get against proposal list ( ) { return this . against proposal list ; }	Gets the against proposal list.
private static void add data serie value ( final data series data series , final entry entry , final int value ) { if ( entry . get key ( ) != null && value > num ) { data series . add ( first of jan + entry . get key ( ) , value ) ; } }	Adds the data serie value.
private void add annual summary ( final map < string , list < government body annual outcome summary > > report , final vertical layout content , final string label ) { final data series data series = new data series ( ) ; final series series = new series ( ) ; for ( final entry < string , list < government body annual outcome summary > > entry : report . entry set ( ) ) { final list < government body annual outcome summary > all values = entry . get value ( ) ; if ( ! all values . is empty ( ) ) { add annual summary data ( data series , series , entry , all values ) ; } } add chart ( content , label , new d ( ) . set data series ( data series ) . set options ( get chart options ( ) . create options xy y ( series ) ) . show ( ) , bool ) ; }	Adds the annual summary.
private static void add annual summary data ( final data series data series , final series series , final entry < string , list < government body annual outcome summary > > entry , final list < government body annual outcome summary > all values ) { series . add series ( new x ( ) . set label ( entry . get key ( ) ) . set show label ( bool ) ) ; data series . new series ( ) ; final map < integer , list < government body annual outcome summary > > map = all values . stream ( ) . collect ( collectors . grouping by ( government body annual outcome summary :: get year ) ) ; for ( final entry < integer , list < government body annual outcome summary > > data : map . entry set ( ) ) { final list < government body annual outcome summary > values = data . get value ( ) ; final double sum = values . stream ( ) . map to double ( government body annual outcome summary :: get year total ) . sum ( ) ; if ( sum > num ) { data series . add ( data . get key ( ) + first jan data suffix , ( int ) sum ) ; } } }	Adds the annual summary data.
private void add annual data ( final vertical layout content , final string name , final string label , final map < string , list < government body annual outcome summary > > collect ) { final data series data series = new data series ( ) ; final series series = new series ( ) ; final simple date format simple date format = new simple date format ( str , locale . english ) ; for ( final entry < string , list < government body annual outcome summary > > entry : collect . entry set ( ) ) { series . add series ( new x ( ) . set label ( entry . get key ( ) ) ) ; data series . new series ( ) ; add entry data ( data series , simple date format , entry ) ; } add chart ( content , name + label , new d ( ) . set data series ( data series ) . set options ( get chart options ( ) . create options xy y ( series ) ) . show ( ) , bool ) ; }	Adds the annual data.
private static void add entry data ( final data series data series , final simple date format simple date format , final entry < string , list < government body annual outcome summary > > entry ) { for ( final government body annual outcome summary data : entry . get value ( ) ) { final map < date , double > value map = data . get value map ( ) ; for ( final entry < date , double > entry data : value map . entry set ( ) ) { if ( entry data . get value ( ) != null && entry data . get value ( ) . int value ( ) > num ) { data series . add ( simple date format . format ( entry data . get key ( ) ) , entry data . get value ( ) . int value ( ) ) ; } } } }	Adds the entry data.
private void create ministry summary ( final abstract ordered layout content , final string field , final string label ) { final data series data series = new data series ( ) ; final series series = new series ( ) ; final map < string , list < government body annual outcome summary > > report by ministry = esv api . get government body report by ministry ( ) ; for ( final entry < string , list < government body annual outcome summary > > entry : report by ministry . entry set ( ) ) { series . add series ( new x ( ) . set label ( entry . get key ( ) ) ) ; data series . new series ( ) ; final map < integer , double > annual summary map = entry . get value ( ) . stream ( ) . filter ( t -> t . get description fields ( ) . get ( field ) != null ) . collect ( collectors . grouping by ( government body annual outcome summary :: get year , collectors . summing double ( government body annual outcome summary :: get year total ) ) ) ; for ( final entry < integer , double > entry data : annual summary map . entry set ( ) ) { if ( entry data . get value ( ) != null && entry data . get value ( ) . int value ( ) > num ) { data series . add ( entry data . get key ( ) + num + str , entry data . get value ( ) ) ; } } } add chart ( content , label , new d ( ) . set data series ( data series ) . set options ( get chart options ( ) . create options xy y ( series ) ) . show ( ) , bool ) ; }	Creates the ministry summary.
private void create role list ( final vertical layout role summary layout tabsheet , final list < assignment data > assignment list ) { final comparator < assignment data > compare = ( o1 , o2 ) -> o1 . get from date ( ) . compare to ( o2 . get from date ( ) ) ; collections . sort ( assignment list , compare ) ; get grid factory ( ) . create basic bean item grid ( role summary layout tabsheet , assignment data . class , assignment list , assignments , column order , hide columns , null , null , null ) ; }	Creates the role list.
private static void process all ( final list < document element > dokument , final process data strategy < document element > process strategy ) { for ( final document element document element : dokument ) { try { process strategy . process ( document element ) ; } catch ( final runtime exception e ) { logger . warn ( error processing document , document element . get id ( ) , e ) ; } } }	Process all.
private void load and process document list ( final string url , final process data strategy < document element > process strategy ) throws xml agent exception { final document container element dokument lista = ( ( jaxb < document container element > ) xml agent . unmarshall xml ( riksdagen document list marshaller , url , http dokumentlista riksdagen external model cia hac com impl , null , null ) ) . get value ( ) ; int result size = dokument lista . get dokument ( ) . size ( ) ; process all ( dokument lista . get dokument ( ) , process strategy ) ; final big integer pages = dokument lista . get total pages ( ) ; for ( int i = num ; i < pages . int value ( ) ; i ++ ) { final document container element other pagesdokument lista = ( ( jaxb < document container element > ) xml agent . unmarshall xml ( riksdagen document list marshaller , url + page property + i , http dokumentlista riksdagen external model cia hac com impl , null , null ) ) . get value ( ) ; result size = result size + other pagesdokument lista . get dokument ( ) . size ( ) ; process all ( other pagesdokument lista . get dokument ( ) , process strategy ) ; logger . info ( loading documents , result size , dokument lista . get hits ( ) ) ; } }	Load and process document list.
private list < document element > load document list ( final string url , final int max number pages ) throws xml agent exception { final list < document element > result = new array list < > ( ) ; document container element dokument lista = ( ( jaxb < document container element > ) xml agent . unmarshall xml ( riksdagen document list marshaller , url , http dokumentlista riksdagen external model cia hac com impl , null , null ) ) . get value ( ) ; result . add all ( dokument lista . get dokument ( ) ) ; final big integer pages = dokument lista . get total pages ( ) ; for ( int i = num ; i < pages . int value ( ) && i < max number pages ; i ++ ) { dokument lista = ( ( jaxb < document container element > ) xml agent . unmarshall xml ( riksdagen document list marshaller , fix broken url ( dokument lista . get next page ( ) ) , http dokumentlista riksdagen external model cia hac com impl , null , null ) ) . get value ( ) ; result . add all ( dokument lista . get dokument ( ) ) ; logger . info ( loading documents , result . size ( ) , dokument lista . get hits ( ) ) ; } return result ; }	Load document list.
private static string read with string buffer ( final reader fr ) throws io { final buffered reader br = new buffered reader ( fr ) ; string line ; final string builder result = new string builder ( ) ; while ( ( line = br . read line ( ) ) != null ) { result . append ( line ) ; } return result . to string ( ) ; }	Read with string buffer.
private static string read input stream ( final string access url ) throws io { final url url = new url ( access url . replace ( str , str ) ) ; return read with string buffer ( new buffered reader ( new input stream reader ( url . open connection ( ) . get input stream ( ) , standard charsets . utf 8 ) ) ) ; }	Read input stream.
@ one to many ( target entity = ballot document element . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < ballot document element > get votering ( ) { return this . votering ; }	Gets the votering.
private list < government body annual outcome summary > get government body list ( ) { final list < government body annual outcome summary > result = new array list < > ( ) ; try { result . add all ( esv government body operation outcome reader . read income csv ( ) ) ; result . add all ( esv government body operation outcome reader . read outgoing csv ( ) ) ; } catch ( final io e ) { logger . error ( get government body report , e ) ; return result ; } return result ; }	Gets the government body list.
@ many to one ( target entity = person assignment element . class , cascade = { cascade type . all } ) @ join column ( name = str ) public person assignment element get person assignment element ( ) { return person assignment element ; }	Gets the person assignment element.
@ many to one ( target entity = person detail element . class , cascade = { cascade type . all } ) @ join column ( name = str ) public person detail element get person detail element ( ) { return person detail element ; }	Gets the person detail element.
public static void create row item ( final responsive row row , final button button , final string description ) { final css layout layout = new css layout ( ) ; layout . add style name ( str ) ; responsive . make responsive ( layout ) ; layout . set size undefined ( ) ; button . add style name ( itembox ) ; button . add style name ( title ) ; responsive . make responsive ( button ) ; button . set width ( num , unit . percentage ) ; layout . add component ( button ) ; final label description label = new label ( description ) ; description label . add style name ( itembox ) ; responsive . make responsive ( description label ) ; description label . set width ( num , unit . percentage ) ; layout . add component ( description label ) ; row . add column ( ) . with display rules ( display size xs device , displays size xm device , display size md device , display size lg device ) . with component ( layout ) ; }	Creates the row item.
public static responsive row create grid layout ( final abstract ordered layout panel content ) { final responsive layout layout = new responsive layout ( ) ; responsive . make responsive ( layout ) ; layout . add style name ( str ) ; layout . set width ( num , unit . percentage ) ; layout . set height ( num , unit . percentage ) ; panel content . add component ( layout ) ; panel content . set expand ratio ( layout , content ratio . large ) ; return layout . add row ( ) ; }	Creates the grid layout.
private void send country indicator work order ( final map < string , string > current saved , final list < string > indicators , final string country iso2 code ) { for ( final string indicator : indicators ) { if ( country iso2 code != null && country iso2 code . length ( ) > num && ! current saved . contains key ( country iso2 code + str + indicator ) ) { final list < string > load = new array list < > ( ) ; load . add ( country iso2 code ) ; load . add ( indicator ) ; get jms sender ( ) . send ( data workdestination , ( serializable ) load ) ; } } }	Send country indicator work order.
@ many to one ( target entity = document proposal container . class , cascade = { cascade type . all } ) @ join column ( name = str ) public document proposal container get document proposal ( ) { return document proposal ; }	Gets the document proposal.
@ many to one ( target entity = document activity container . class , cascade = { cascade type . all } ) @ join column ( name = str ) public document activity container get document activity container ( ) { return document activity container ; }	Gets the document activity container.
@ many to one ( target entity = document detail container . class , cascade = { cascade type . all } ) @ join column ( name = str ) public document detail container get document detail container ( ) { return document detail container ; }	Gets the document detail container.
@ many to one ( target entity = document attachment container . class , cascade = { cascade type . all } ) @ join column ( name = str ) public document attachment container get document attachment container ( ) { return document attachment container ; }	Gets the document attachment container.
@ many to one ( target entity = document reference container . class , cascade = { cascade type . all } ) @ join column ( name = str ) public document reference container get document reference container ( ) { return document reference container ; }	Gets the document reference container.
@ many to one ( target entity = document person reference container . class , cascade = { cascade type . all } ) @ join column ( name = str ) public document person reference container get document person reference container ( ) { return document person reference container ; }	Gets the document person reference container.
private map < string , list < view riksdagen party document daily summary > > get view riksdagen party document daily summary map ( ) { final data container < view riksdagen party document daily summary , riksdagen document party summary embedded id > politician ballot summary daily data container = get application manager ( ) . get data container ( view riksdagen party document daily summary . class ) ; return politician ballot summary daily data container . get all ( ) . parallel stream ( ) . filter ( objects :: non null ) . collect ( collectors . grouping by ( t -> t . get embedded id ( ) . get party short code ( ) . to upper case ( locale . english ) . replace ( under score , empty string ) . trim ( ) ) ) ; }	Gets the view riksdagen party document daily summary map.
private static void add document history by party data ( final data series data series , final series series , final map < string , list < view riksdagen party document daily summary > > map ) { final simple date format simple date format = new simple date format ( dd mmm yyyy , locale . english ) ; for ( final entry < string , list < view riksdagen party document daily summary > > entry : map . entry set ( ) ) { series . add series ( new x ( ) . set label ( entry . get key ( ) ) ) ; data series . new series ( ) ; if ( entry . get value ( ) != null ) { for ( final view riksdagen party document daily summary item : entry . get value ( ) ) { data series . add ( simple date format . format ( item . get embedded id ( ) . get public date ( ) ) , item . get total ( ) ) ; } } else { logger . info ( log msg missing data for key , entry ) ; } } }	Adds the document history by party data.
private static string [ ] read missing person list ( ) { final scanner sc = new scanner ( riksdagen persons work generator impl . class . get resource as stream ( str ) , standard charsets . utf 8 . name ( ) ) ; final list < string > lines = new array list < > ( ) ; while ( sc . has next line ( ) ) { lines . add ( sc . next line ( ) ) ; } sc . close ( ) ; return lines . to array ( new string [ num ] ) ; }	Read missing person list.
private void append object presentation ( final string builder string builder , final object object ) { try { final string bean property = bean utils . get property ( object , property ) ; if ( bean property != null ) { string builder . append ( bean property ) ; } else { add fallback value ( string builder , object ) ; } } catch ( final illegal access exception | invocation target exception | no such method exception e ) { logger . warn ( str , property , object , e ) ; } string builder . append ( content separator ) ; }	Append object presentation.
private void add fallback value ( final string builder string builder , final object object ) throws illegal access exception , invocation target exception , no such method exception { if ( fallback column != null ) { final string bean property fall back = bean utils . get property ( object , fallback column ) ; if ( bean property fall back != null ) { string builder . append ( bean property fall back ) ; } } }	Adds the fallback value.
private void reencrypt vault values ( final change password request service request , final user account user account ) { final string auth key = vault manager . get encrypted value ( service request . get current password ( ) , user account ) ; if ( auth key != null ) { final encrypted value encrypted value = encrypted value dao . find first by property ( encrypted value . user id , user account . get user id ( ) ) ; encrypted value . set storage ( vault manager . encrypt value ( service request . get new password ( ) , user account . get user id ( ) , auth key ) ) ; encrypted value dao . merge ( encrypted value ) ; } }	Reencrypt vault values.
@ one to many ( target entity = sweden county electoral area . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < sweden county electoral area > get landstingsvalkrets ( ) { return this . landstingsvalkrets ; }	Gets the landstingsvalkrets.
private static void add commitee summary ( final string builder string builder , final entry < string , list < proposal committeee summary > > entry , final optional < view riksdagen committee > vew riksdagen committee ) { if ( vew riksdagen committee . is present ( ) ) { final map < string , list < proposal committeee summary > > doc type map = entry . get value ( ) . stream ( ) . collect ( collectors . grouping by ( proposal committeee summary :: get doc type ) ) ; string builder . append ( str ) . append ( vew riksdagen committee . get ( ) . get embedded id ( ) . get detail ( ) ) ; for ( final entry < string , list < proposal committeee summary > > doc entry : doc type map . entry set ( ) ) { if ( doc entry . get key ( ) . length ( ) > num && entry . get key ( ) . length ( ) > num ) { add entry ( string builder , entry , doc entry ) ; } } } }	Adds the commitee summary.
private static void add entry ( final string builder string builder , final entry < string , list < proposal committeee summary > > entry , final entry < string , list < proposal committeee summary > > doc entry ) { string builder . append ( str ) . append ( doc entry . get value ( ) . size ( ) ) . append ( str ) . append ( doc entry . get key ( ) ) . append ( str ) ; final map < string , list < proposal committeee summary > > decision map = doc entry . get value ( ) . stream ( ) . collect ( collectors . grouping by ( proposal committeee summary :: get decision ) ) ; for ( final entry < string , list < proposal committeee summary > > decision entry : decision map . entry set ( ) ) { if ( decision entry . get key ( ) . length ( ) > num && entry . get key ( ) . length ( ) > num ) { string builder . append ( decision entry . get value ( ) . size ( ) ) . append ( str ) . append ( decision entry . get key ( ) ) . append ( str ) ; } } string builder . append ( str ) ; }	Adds the entry.
private static void add decision data rows ( final sankey chart chart , final entry < string , list < proposal committeee summary > > entry , final view riksdagen committee vew riksdagen committee ) { final map < string , list < proposal committeee summary > > decision map = entry . get value ( ) . stream ( ) . collect ( collectors . grouping by ( proposal committeee summary :: get decision ) ) ; for ( final entry < string , list < proposal committeee summary > > decision entry : decision map . entry set ( ) ) { if ( decision entry . get key ( ) . length ( ) > num && entry . get key ( ) . length ( ) > num ) { chart . add data row ( vew riksdagen committee . get embedded id ( ) . get detail ( ) , decision entry . get key ( ) , decision entry . get value ( ) . size ( ) ) ; } } }	Adds the decision data rows.
private static void add doc type data rows ( final sankey chart chart , final entry < string , list < proposal committeee summary > > entry , final view riksdagen committee vew riksdagen committee ) { final map < string , list < proposal committeee summary > > doc type map = entry . get value ( ) . stream ( ) . collect ( collectors . grouping by ( proposal committeee summary :: get doc type ) ) ; for ( final entry < string , list < proposal committeee summary > > doc entry : doc type map . entry set ( ) ) { if ( doc entry . get key ( ) . length ( ) > num && entry . get key ( ) . length ( ) > num ) { chart . add data row ( doc entry . get key ( ) , vew riksdagen committee . get embedded id ( ) . get detail ( ) , doc entry . get value ( ) . size ( ) ) ; } } }	Adds the doc type data rows.
private static void add doc type decision data rows ( final sankey chart chart , final entry < string , list < proposal committeee summary > > entry ) { final map < string , list < proposal committeee summary > > doc type map = entry . get value ( ) . stream ( ) . collect ( collectors . grouping by ( proposal committeee summary :: get doc type ) ) ; for ( final entry < string , list < proposal committeee summary > > doc entry : doc type map . entry set ( ) ) { final map < string , list < proposal committeee summary > > decision map = doc entry . get value ( ) . stream ( ) . collect ( collectors . grouping by ( proposal committeee summary :: get decision ) ) ; for ( final entry < string , list < proposal committeee summary > > decision entry : decision map . entry set ( ) ) { if ( decision entry . get key ( ) . length ( ) > num && entry . get key ( ) . length ( ) > num ) { chart . add data row ( doc entry . get key ( ) , decision entry . get key ( ) , decision entry . get value ( ) . size ( ) ) ; } } } }	Adds the doc type decision data rows.
public static string get user id from security context ( ) { final security context context = security context holder . get context ( ) ; if ( context != null ) { final authentication authentication = context . get authentication ( ) ; if ( authentication != null ) { return authentication . get principal ( ) . to string ( ) ; } } return null ; }	Gets the user id from security context.
public static string get request url ( final page current ) { if ( current != null ) { return current . get location ( ) . to string ( ) ; } else { final http servlet request http request = ( ( servlet request attributes ) request context holder . current request attributes ( ) ) . get request ( ) ; return http request . get request url ( ) . to string ( ) ; } }	Gets the request url.
public static boolean allow role in security context ( final string role ) { boolean result = bool ; final security context context = security context holder . get context ( ) ; if ( context != null && context . get authentication ( ) != null ) { final collection < ? extends granted authority > authorities = context . get authentication ( ) . get authorities ( ) ; for ( final granted authority granted authority : authorities ) { if ( role . equals ignore case ( granted authority . get authority ( ) ) ) { result = bool ; } } } return result ; }	Allow role in security context.
private map < string , list < view application action event page daily summary > > get application action event page daily summary map ( ) { final data container < view application action event page daily summary , application action event page period summary embedded id > document type summary daily data container = get application manager ( ) . get data container ( view application action event page daily summary . class ) ; return document type summary daily data container . get all ( ) . parallel stream ( ) . filter ( objects :: non null ) . collect ( collectors . grouping by ( t -> t . get embedded id ( ) . get page ( ) ) ) ; }	Gets the application action event page daily summary map.
private map < string , list < view application action event page mode daily summary > > get application action event page mode daily summary map ( final string page ) { final data container < view application action event page mode daily summary , application action event page mode period summary embedded id > document type summary daily data container = get application manager ( ) . get data container ( view application action event page mode daily summary . class ) ; final list < view application action event page mode daily summary > find ordered list by embedded property = document type summary daily data container . find ordered list by embedded property ( view application action event page mode daily summary . class , view application action event page mode daily summary . embedded id , application action event page mode period summary embedded id . class , application action event page mode period summary embedded id . page , page , application action event page mode period summary embedded id . created date ) ; return find ordered list by embedded property . parallel stream ( ) . filter ( objects :: non null ) . collect ( collectors . grouping by ( t -> t . get embedded id ( ) . get page mode ( ) ) ) ; }	Gets the application action event page mode daily summary map.
private list < view application action event page element daily summary > get application action event page element daily summary list ( final string page , final string element id ) { final data container < view application action event page element daily summary , application action event page element period summary embedded id > document type summary daily data container = get application manager ( ) . get data container ( view application action event page element daily summary . class ) ; final list < view application action event page element daily summary > find ordered list by embedded property = document type summary daily data container . find ordered list by embedded property ( view application action event page element daily summary . class , view application action event page element daily summary . embedded id , application action event page element period summary embedded id . class , application action event page element period summary embedded id . element id , element id , application action event page element period summary embedded id . created date ) ; return find ordered list by embedded property . parallel stream ( ) . filter ( t -> t != null && t . get embedded id ( ) . get page ( ) . equals ( page ) ) . collect ( collectors . to list ( ) ) ; }	Gets the application action event page element daily summary list.
private static void add view application action event page element daily summary values ( final string label , final series series , final list < view application action event page element daily summary > list , final data series data series , final simple date format simple date format , final to long function < view application action event page element daily summary > t ) { series . add series ( new x ( ) . set label ( label ) ) ; data series . new series ( ) ; for ( final view application action event page element daily summary item : list ) { data series . add ( simple date format . format ( item . get embedded id ( ) . get created date ( ) ) , t . apply as long ( item ) ) ; } }	Adds the view application action event page element daily summary values.
private static void update person assignment data ( final person assignment data exist , final person assignment data update ) { final list < assignment data > assignment list = update . get assignment list ( ) ; for ( final assignment data assignment data : assignment list ) { update assignment data ( exist . get assignment list ( ) , assignment data ) ; } }	Update person assignment data.
private static void update assignment data ( final list < assignment data > assignment list , final assignment data assignment data ) { for ( final assignment data match assignment data : assignment list ) { if ( match assignment data . get from date ( ) . equals ( assignment data . get from date ( ) ) && match assignment data . get org code ( ) . equals ( assignment data . get org code ( ) ) && match assignment data . get role code ( ) . equals ( assignment data . get role code ( ) ) ) { match assignment data . set status ( assignment data . get status ( ) ) ; match assignment data . set to date ( assignment data . get to date ( ) ) ; return ; } } assignment list . add ( assignment data ) ; }	Update assignment data.
protected final v input validation ( final t service request ) { final set < constraint violation < t > > validate request = validate request ( service request ) ; if ( ! validate request . is empty ( ) ) { final create application event request event request = create application event for service ( service request ) ; final v response = create error response ( ) ; handle input violations ( event request , validate request , response ) ; create application event service . process service ( event request ) ; return response ; } else { return null ; } }	Input validation.
protected final create application event request create base application event request ( ) { final create application event request event request = new create application event request ( ) ; final user account user account = get user account from security context ( ) ; if ( user account != null ) { event request . set user id ( user account . get user id ( ) ) ; } return event request ; }	Creates the base application event request.
private set < constraint violation < t > > validate request ( final t request ) { final validator factory factory = validation . build default validator factory ( ) ; return factory . get validator ( ) . validate ( request ) ; }	Validate request.
private string get human message ( final set < constraint violation < t > > request constraint violations ) { return request constraint violations . stream ( ) . sorted ( ( p1 , p2 ) -> p1 . get property path ( ) . to string ( ) . compare to ( p2 . get property path ( ) . to string ( ) ) ) . map ( p -> p . get property path ( ) . to string ( ) + str + p . get message ( ) ) . collect ( collectors . joining ( str ) ) ; }	Gets the human message.
private void handle input violations ( final create application event request event request , final set < constraint violation < t > > request constraint violations , final v response ) { final string error message = get human message ( request constraint violations ) ; ( ( abstract response ) response ) . set error message ( error message ) ; event request . set error message ( error message ) ; }	Handle input violations.
private void create data indicator summary chart panel ( final vertical layout vertical layout , final string indicator ) { final data container < view worldbank indicator data country summary , worldbank indicator data country summary embedded id > indicator data countr summary daily data container = get application manager ( ) . get data container ( view worldbank indicator data country summary . class ) ; final optional < view worldbank indicator data country summary > indicator summary = indicator data countr summary daily data container . get all ( ) . parallel stream ( ) . filter ( t -> t != null && t . get embedded id ( ) . get indicator id ( ) . equals ( indicator ) ) . find first ( ) ; view worldbank indicator data country summary indicator summary value = null ; if ( indicator summary . is present ( ) ) { indicator summary value = indicator summary . get ( ) ; get form factory ( ) . add form panel text fields ( vertical layout , indicator summary value , view worldbank indicator data country summary . class , as list ) ; } final data container < world bank data , serializable > data container = get application manager ( ) . get data container ( world bank data . class ) ; final list < world bank data > data list = data container . find list by embedded property ( world bank data . class , world bank data . indicator , indicator . class , indicator . id , indicator ) ; chart data manager . create indicator chart ( vertical layout , data list , indicator summary value ) ; }	Creates the data indicator summary chart panel.
protected final void init application menu bar ( final menu bar menu bar ) { menu bar . remove items ( ) ; menu bar . set width ( menu bar width ) ; menu bar . set style name ( header style name ) ; final menu item main view item = menu bar . add item ( application , vaadin icons . server , null ) ; main view item . add item ( start text , vaadin icons . star , command mainview overview ) ; final menu item main item = main view item . add item ( main , vaadin icons . star , null ) ; main item . add item ( page visit history text , vaadin icons . line chart , command mainview pagevisithistory ) ; if ( user context util . allow role in security context ( role admin ) || user context util . allow role in security context ( role user ) ) { main view item . add item ( userhome , vaadin icons . user , command userhome ) ; create admin menu ( main view item ) ; main view item . add item ( logout , vaadin icons . sign out , command logout ) ; } else { main view item . add item ( login , vaadin icons . sign in , command login ) ; main view item . add item ( register , vaadin icons . file add , command register ) ; } }	Inits the application menu bar.
private static void create admin menu ( final menu item main view item ) { if ( user context util . allow role in security context ( role admin ) ) { final menu item admin menu item = main view item . add item ( admin text , vaadin icons . server , null ) ; final menu item configuration menu item = admin menu item . add item ( configuration , vaadin icons . tools , null ) ; configuration menu item . add item ( application configuration , vaadin icons . tools , command application configuration ) ; configuration menu item . add item ( agency , vaadin icons . server , command agency ) ; configuration menu item . add item ( portal , vaadin icons . sitemap , command portal ) ; configuration menu item . add item ( country , vaadin icons . flag , command country ) ; configuration menu item . add item ( language , vaadin icons . accessibility , command language ) ; configuration menu item . add item ( language content , vaadin icons . file text , command language content ) ; final menu item management menu item = admin menu item . add item ( management , vaadin icons . server , null ) ; management menu item . add item ( agent operations text , vaadin icons . briefcase , command agent operation ) ; management menu item . add item ( data summary text , vaadin icons . database , command datasummary ) ; management menu item . add item ( data author summary , vaadin icons . database , command author datasummary ) ; management menu item . add item ( email , vaadin icons . mailbox , command email ) ; management menu item . add item ( system performance , vaadin icons . dashboard , command monitoring ) ; final menu item user activity menu item = admin menu item . add item ( user activity , vaadin icons . database , null ) ; user activity menu item . add item ( application session , vaadin icons . laptop , command application session ) ; user activity menu item . add item ( application event , vaadin icons . arrows , command application events ) ; user activity menu item . add item ( application event charts , vaadin icons . arrows , command application events charts ) ; user activity menu item . add item ( useraccount , vaadin icons . group , command useraccount ) ; } }	Creates the admin menu.
protected final void create button link ( final responsive row row , final string link text , final resource icon , final click listener command , final string description ) { final css layout layout = new css layout ( ) ; layout . add style name ( str ) ; responsive . make responsive ( layout ) ; layout . set size undefined ( ) ; final button button = new button ( link text ) ; responsive . make responsive ( button ) ; button . set style name ( link style name ) ; button . add style name ( str ) ; button . add click listener ( command ) ; button . set icon ( icon ) ; button . set width ( num , unit . percentage ) ; layout . add component ( button ) ; final label description label = new label ( description ) ; description label . add style name ( str ) ; responsive . make responsive ( description label ) ; description label . set width ( num , unit . percentage ) ; layout . add component ( description label ) ; row . add column ( ) . with display rules ( display size xs device , displays size xm device , display size md device , display size lg device ) . with component ( layout ) ; }	Creates the button link.
public void set result element ( final list < document element > result element ) { if ( result element != null ) { this . result element = result element . stream ( ) . collect ( collectors . to list ( ) ) ; } }	Sets the result element.
@ bean public kie container kie container ( ) { final kie services kie services = kie services . factory . get ( ) ; final kie container k container = kie services . get kie classpath container ( ) ; logger . info ( str , k container . get class loader ( ) , k container . get class loader ( ) . get parent ( ) ) ; final results verify results = k container . verify ( ) ; for ( final message m : verify results . get messages ( ) ) { logger . warn ( str , m ) ; } final kie base kie base = k container . get kie base ( ) ; for ( final kie package kp : kie base . get kie packages ( ) ) { for ( final rule rule : kp . get rules ( ) ) { logger . info ( str , kp , rule . get name ( ) ) ; } } return k container ; }	Kie container.
@ bean public javers get javers ( final platform transaction manager tx manager ) { final javers sql repository sql repository = sql repository builder . sql repository ( ) . with connection provider ( new connection provider ( ) { @ override public connection get connection ( ) { final session impl session = ( session impl ) entity manager . unwrap ( session . class ) ; return session . connection ( ) ; } } ) . with dialect ( dialect name . postgres ) . build ( ) ; return transactional javers builder . javers ( ) . with tx manager ( tx manager ) . with object access hook ( new hibernate unproxy object access hook ( ) ) . register javers repository ( sql repository ) . with mapping style ( mapping style . bean ) . build ( ) ; }	Gets the javers.
@ bean public javers auditable aspect javers auditable aspect ( final javers javers , final author provider author provider , final commit properties provider commit properties provider ) { return new javers auditable aspect ( javers , author provider , commit properties provider ) ; }	Javers auditable aspect.
@ bean public author provider author provider ( ) { return ( ) -> { final security context context = security context holder . get context ( ) ; if ( context != null && context . get authentication ( ) != null ) { return context . get authentication ( ) . get principal ( ) . to string ( ) ; } else { return str ; } } ; }	Author provider.
private void create role summary ( final vertical layout role summary layout tabsheet , final list < assignment data > assignment list , final view riksdagen politician view riksdagen politician ) { final vertical layout layout = new vertical layout ( ) ; layout . set size full ( ) ; layout . add component ( new label ( total assignments + assignment list . size ( ) ) ) ; if ( view riksdagen politician != null ) { layout . add component ( new label ( government experience + convert to years string ( view riksdagen politician . get total days served government ( ) ) ) ) ; layout . add component ( new label ( speaker experience + convert to years string ( view riksdagen politician . get total days served speaker ( ) ) ) ) ; layout . add component ( new label ( committee experience + convert to years string ( view riksdagen politician . get total days served committee ( ) ) ) ) ; layout . add component ( new label ( eu experience + convert to years string ( view riksdagen politician . get total days served eu ( ) ) ) ) ; layout . add component ( new label ( parliament experience + convert to years string ( view riksdagen politician . get total days served parliament ( ) ) ) ) ; layout . add component ( new label ( party experience + convert to years string ( view riksdagen politician . get total days served party ( ) ) ) ) ; } role summary layout tabsheet . add component ( layout ) ; role summary layout tabsheet . set expand ratio ( layout , content ratio . grid ) ; }	Creates the role summary.
private static void add ministry per year to map ( final string name , final map < integer , list < government body annual summary > > map , final hssf my sheet ) { if ( my sheet . get sheet name ( ) . chars ( ) . all match ( character :: is digit ) ) { final int year = integer . parse int ( my sheet . get sheet name ( ) ) ; final list < government body annual summary > year list = new array list < > ( ) ; final iterator < row > row iterator = my sheet . iterator ( ) ;	Adds the ministry per year to map.
private static void add government body annual summary to list ( final string name , final int year , final list < government body annual summary > year list , final row row ) { if ( row . get last cell num ( ) >= expected column length ) { final government body annual summary government body annual summary = create government body annual summary from row ( year , row ) ; if ( name == null || name . equals ignore case ( government body annual summary . get ministry ( ) ) ) { year list . add ( government body annual summary ) ; } } }	Adds the government body annual summary to list.
private static int get integer ( final string str ) { if ( str == null || str . trim ( ) . length ( ) == num ) { return num ; } else { return integer . parse int ( str ) ; } }	Gets the integer.
private static void add data for year to map ( final string name , final map < integer , government body annual summary > map , final hssf my sheet ) { if ( my sheet . get sheet name ( ) . chars ( ) . all match ( character :: is digit ) ) { final int year = integer . parse int ( my sheet . get sheet name ( ) ) ; final iterator < row > row iterator = my sheet . iterator ( ) ; row iterator . next ( ) ; while ( row iterator . has next ( ) ) { add government body annual summary to map ( name , map , year , row iterator . next ( ) ) ; } } }	Adds the data for year to map.
private static void add government body annual summary to map ( final string name , final map < integer , government body annual summary > map , final int year , final row row ) { if ( row . get last cell num ( ) >= expected column length ) { final government body annual summary government body annual summary = create government body annual summary from row ( year , row ) ; if ( name == null || name . equals ignore case ( government body annual summary . get name ( ) ) ) { map . put ( year , government body annual summary ) ; } } }	Adds the government body annual summary to map.
private static government body annual summary create government body annual summary from row ( final int year , final row row ) { return new government body annual summary ( year , default value if null ( row . get cell ( name cell ) ) , get integer ( default value if null ( row . get cell ( consecutive number cell ) ) ) , default value if null ( row . get cell ( government body id cell ) ) , default value if null ( row . get cell ( mcode cell ) ) , default value if null ( row . get cell ( ministry cell ) ) , default value if null ( row . get cell ( org number cell ) ) , get integer ( default value if null ( row . get cell ( headcount cell ) ) ) , get integer ( default value if null ( row . get cell ( annual headcount cell ) ) ) , default value if null ( row . get cell ( vat cell ) ) , default value if null ( row . get cell ( comment cell ) ) ) ; }	Creates the government body annual summary from row.
@ many to one ( target entity = person assignment data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public person assignment data get person assignment data ( ) { return person assignment data ; }	Gets the person assignment data.
@ many to one ( target entity = person detail data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public person detail data get person detail data ( ) { return person detail data ; }	Gets the person detail data.
private map < string , list < view riksdagen committee decision type daily summary > > get committee decision type map ( ) { final data container < view riksdagen committee decision type daily summary , riksdagen committee decision type summary embedded id > committee ballot decision party data container = get application manager ( ) . get data container ( view riksdagen committee decision type daily summary . class ) ; final date now = new date ( ) ; final date not before = new gregorian calendar ( num , calendar . january , num ) . get time ( ) ; return committee ballot decision party data container . get all ( ) . parallel stream ( ) . filter ( t -> t != null && ! t . get embedded id ( ) . get decision date ( ) . after ( now ) && ! not before . after ( t . get embedded id ( ) . get decision date ( ) ) ) . collect ( collectors . grouping by ( t -> t . get embedded id ( ) . get decision type ( ) ) ) ; }	Gets the committee decision type map.
private map < string , list < view riksdagen committee decision type org daily summary > > get committee decision type org map ( ) { final data container < view riksdagen committee decision type org daily summary , riksdagen committee decision type org summary embedded id > committee ballot decision party data container = get application manager ( ) . get data container ( view riksdagen committee decision type org daily summary . class ) ; return committee ballot decision party data container . get all ( ) . parallel stream ( ) . filter ( objects :: non null ) . collect ( collectors . grouping by ( t -> t . get embedded id ( ) . get org ( ) ) ) ; }	Gets the committee decision type org map.
private static void add decision type by org data ( final simple date format simple date format , final data series data series , final series series , final map < string , list < view riksdagen committee decision type org daily summary > > map ) { for ( final entry < string , list < view riksdagen committee decision type org daily summary > > entry : map . entry set ( ) ) { if ( ! empty string . equals ( entry . get key ( ) ) ) { final x label = new x ( ) ; label . set label ( entry . get key ( ) ) ; series . add series ( label ) ; data series . new series ( ) ; for ( final view riksdagen committee decision type org daily summary item : entry . get value ( ) ) { data series . add ( simple date format . format ( item . get embedded id ( ) . get decision date ( ) ) , item . get total ( ) ) ; } } } }	Adds the decision type by org data.
private static void display document attachements ( final vertical layout panel content , final list < document attachment > document attachment list ) { for ( final document attachment document attachment : document attachment list ) { if ( pdf . equals ignore case ( document attachment . get file type ( ) ) ) { final wt wt pdf viewer = new wt ( ) ; wt pdf viewer . set size full ( ) ; wt pdf viewer . set resource ( new stream resource ( new stream source implementation ( document attachment . get file url ( ) ) , document attachment . get file name ( ) ) ) ; panel content . add component ( wt pdf viewer ) ; panel content . set expand ratio ( wt pdf viewer , content ratio . large ) ; } else { final vertical layout vertical layout = new vertical layout ( ) ; panel content . add component ( vertical layout ) ; panel content . set expand ratio ( vertical layout , content ratio . small ) ; final external attachment download link link = new external attachment download link ( document attachment . get file name ( ) , document attachment . get file type ( ) , document attachment . get file url ( ) ) ; vertical layout . add component ( link ) ; } } }	Display document attachements.
public static void create header2 label ( final abstract ordered layout panel , final string content ) { final label label = new label ( content ) ; label . set style name ( str ) ; panel . add component ( label ) ; panel . set expand ratio ( label , content ratio . small ) ; }	Creates a new Label object.
private static key build key ( final string userid , final string password ) { return new secret key spec ( arrays . copy of ( new sh . digest512 ( ) . digest ( ( userid + str + password ) . get bytes ( standard charsets . utf 8 ) ) , key size in bytes ) , algorithm ) ; }	Builds the key.
@ override public final string get rule summary ( ) { final collection < rule violation > values = rule violation map . values ( ) ; final string builder builder = new string builder ( ) ; for ( final rule violation rule violation : values ) { builder . append ( str ) . append ( rule violation . get rule name ( ) ) . append ( str ) . append ( rule violation . get status ( ) ) . append ( str ) ; } return builder . to string ( ) ; }	Gets the rule summary.
public final void add violation ( final status status , final string rule name , final string rule group , final string rule description , final string positive ) { final rule violation current rule violation = rule violation map . get ( rule name ) ; if ( current rule violation == null || status . ordinal ( ) > current rule violation . get status ( ) . ordinal ( ) ) { rule violation map . put ( rule name , new rule violation ( get id ( ) , get name ( ) , resource type , rule name , rule description , rule group , status , positive ) ) ; } }	Adds the violation.
private static map < string , string > create map from list vote ( final list < vote data embedded id > list ) { final map < string , string > map = new concurrent hash map < > ( ) ; for ( final vote data embedded id document element : list ) { map . put ( document element . get ballot id ( ) , document element . get ballot id ( ) ) ; } return map ; }	Creates the map from list vote.
private static boolean check include date ( final date after , final list < string > document type values , final document element document element ) { try { if ( document element . get made public date ( ) != null && document element . get made public date ( ) . length ( ) > num ) { return get date ( document element . get made public date ( ) ) . after ( after ) && document type values . contains ( document element . get document type ( ) ) ; } else { return get date ( document element . get created date ( ) ) . after ( after ) && document type values . contains ( document element . get document type ( ) ) ; } } catch ( final parse exception e ) { logger . warn ( str , document element , e ) ; return bool ; } }	Check include date.
private static date get date ( final string date ) throws parse exception { if ( riksdagen java simple date format . length ( ) > date . length ( ) ) { return new simple date format ( riksdagen java simple date time format , locale . english ) . parse ( date ) ; } else { return new simple date format ( riksdagen java simple date format , locale . english ) . parse ( date ) ; } }	Gets the date.
@ one to many ( target entity = sweden political party . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < sweden political party > get parties ( ) { return this . parties ; }	Gets the parties.
private vertical layout create enable google auth button ( ) { final vertical layout form layout = new vertical layout ( ) ; form layout . set size full ( ) ; final panel form panel = new panel ( ) ; form panel . set size full ( ) ; form layout . add component ( form panel ) ; final form layout form content = new form layout ( ) ; form panel . set content ( form content ) ; final set google authenticator credential request request = new set google authenticator credential request ( ) ; request . set session id ( request context holder . current request attributes ( ) . get session id ( ) ) ; request . set userpassword ( str ) ; final click listener listener = new set google authenticator credential click listener ( request ) ; get form factory ( ) . add request input form fields ( form content , request , set google authenticator credential request . class , as list , enable google authenticator , listener ) ; return form layout ; }	Creates the enable google auth button.
private vertical layout create disable google auth button ( ) { final vertical layout form layout = new vertical layout ( ) ; form layout . set size full ( ) ; final panel form panel = new panel ( ) ; form panel . set size full ( ) ; form layout . add component ( form panel ) ; final form layout form content = new form layout ( ) ; form panel . set content ( form content ) ; final disable google authenticator credential request request = new disable google authenticator credential request ( ) ; request . set session id ( request context holder . current request attributes ( ) . get session id ( ) ) ; request . set userpassword ( str ) ; final click listener listener = new disable google authenticator credential click listener ( request ) ; get form factory ( ) . add request input form fields ( form content , request , disable google authenticator credential request . class , as list , disable google authenticator , listener ) ; return form layout ; }	Creates the disable google auth button.
private vertical layout create change password button ( ) { final vertical layout form layout = new vertical layout ( ) ; form layout . set size full ( ) ; final panel form panel = new panel ( ) ; form panel . set size full ( ) ; form layout . add component ( form panel ) ; final form layout form content = new form layout ( ) ; form panel . set content ( form content ) ; final change password request request = new change password request ( ) ; request . set session id ( request context holder . current request attributes ( ) . get session id ( ) ) ; request . set current password ( str ) ; request . set new password ( str ) ; request . set repeat new password ( str ) ; final click listener listener = new change password click listener ( request ) ; get form factory ( ) . add request input form fields ( form content , request , change password request . class , arrays . as list ( str , str , str ) , str , listener ) ; return form layout ; }	Creates the change password button.
@ one to many ( target entity = document reference data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < document reference data > get document reference list ( ) { return this . document reference list ; }	Gets the document reference list.
private static date best guess vote date ( final ballot container ballot container ) throws parse exception { final com . hack23 . cia . model . external . riksdagen . votering . impl . ballot document element ballot document element = ballot container . get ballot document element ( ) ; date result ; final string created date = ballot container . get ballot document element ( ) . get created date ( ) ; if ( created date != null && created date . length ( ) >= yyyy mm dd . length ( ) ) { result = new simple date format ( yyyy mm dd , locale . english ) . parse ( created date ) ; } else { final string system date = ballot document element . get system date ( ) ; if ( system date != null && system date . length ( ) >= yyyy mm dd . length ( ) ) { result = new simple date format ( yyyy mm dd , locale . english ) . parse ( system date ) ; } else { result = new simple date format ( yyyy mm dd , locale . english ) . parse ( ballot document element . get made public date ( ) ) ; } } return result ; }	Best guess vote date.
private static date check same date ( final list < vote data dto > vote list ) throws parse exception { final set < string > set = new hash set < > ( ) ; date result = null ; for ( final vote data dto vote data : vote list ) { final string vote date = vote data . get vote date ( ) ; if ( vote date != null && vote date . length ( ) >= yyyy mm dd . length ( ) ) { set . add ( vote data . get vote date ( ) ) ; } } if ( set . size ( ) == contains one ) { final string date string = set . iterator ( ) . next ( ) ; result = new simple date format ( yyyy mm dd , locale . english ) . parse ( date string ) ; } return result ; }	Check same date.
public date try to find valid vote date ( final ballot container ballot container , final list < vote data dto > vote data list ) throws parse exception { date ballot date ; final date same date = check same date ( vote data list ) ; if ( same date != null ) { ballot date = same date ; } else { ballot date = best guess vote date ( ballot container ) ; } return ballot date ; }	Try to find valid vote date.
public static string get ip information ( final web browser web browser ) { string ip information = web browser . get address ( ) ; final http servlet request http request = ( ( servlet request attributes ) request context holder . current request attributes ( ) ) . get request ( ) ; final string x forwarded for header = http request . get header ( x forwarded for ) ; if ( x forwarded for header != null ) { final string [ ] split = x forwarded for header . split ( str ) ; if ( split . length != num ) { ip information = split [ num ] ; } } return ip information ; }	Gets the ip information.
public static string get operating system ( final web browser web browser ) { synchronized ( user agent analyzer ) { final user agent user agent = user agent analyzer . parse ( web browser . get browser application ( ) ) ; return user agent . get value ( user agent . device class ) + str + user agent . get value ( user agent . operating system name ) + str + user agent . get value ( user agent . operating system version ) ; } }	Gets the operating system.
@ one to many ( target entity = committee proposal data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < committee proposal data > get committee proposal list ( ) { return this . committee proposal list ; }	Gets the committee proposal list.
@ one to many ( target entity = sweden parliament electoral region . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < sweden parliament electoral region > get parliament electoral regions ( ) { return this . parliament electoral regions ; }	Gets the parliament electoral regions.
private map < string , list < view riksdagen org document daily summary > > get view riksdagen org document daily summary map ( ) { final data container < view riksdagen org document daily summary , riksdagen document org summary embedded id > politician ballot summary daily data container = get application manager ( ) . get data container ( view riksdagen org document daily summary . class ) ; return politician ballot summary daily data container . get all ( ) . parallel stream ( ) . filter ( t -> t != null && ! t . get embedded id ( ) . get public date ( ) . starts with ( year prefix ) ) . collect ( collectors . grouping by ( t -> string escape utils . unescape html4 ( t . get embedded id ( ) . get org ( ) ) . to upper case ( locale . english ) . replace ( under score , empty string ) . replace ( minus sign , empty string ) . trim ( ) ) ) ; }	Gets the view riksdagen org document daily summary map.
private static void add document history by org data ( final data series data series , final series series , final list < view riksdagen org document daily summary > item list ) { final map < string , list < view riksdagen org document daily summary > > map = item list . parallel stream ( ) . filter ( objects :: non null ) . collect ( collectors . grouping by ( t -> string utils . default if blank ( t . get document type ( ) , no info ) ) ) ; final simple date format simple date format = new simple date format ( dd mmm yyyy , locale . english ) ; final simple date format parse incoming date format = new simple date format ( str , locale . english ) ; for ( final entry < string , list < view riksdagen org document daily summary > > entry : map . entry set ( ) ) { add new data serie ( data series , series , simple date format , parse incoming date format , entry ) ; } }	Adds the document history by org data.
private static void add new data serie ( final data series data series , final series series , final simple date format simple date format , final simple date format parse incoming date format , final entry < string , list < view riksdagen org document daily summary > > entry ) { series . add series ( new x ( ) . set label ( entry . get key ( ) ) ) ; data series . new series ( ) ; if ( entry . get value ( ) != null ) { for ( final view riksdagen org document daily summary item : entry . get value ( ) ) { add data item ( data series , simple date format , parse incoming date format , item ) ; } } }	Adds the new data serie.
private static void add data item ( final data series data series , final simple date format simple date format , final simple date format parse incoming date format , final view riksdagen org document daily summary item ) { if ( item != null && item . get embedded id ( ) . get public date ( ) . length ( ) > num ) { try { data series . add ( simple date format . format ( parse incoming date format . parse ( item . get embedded id ( ) . get public date ( ) ) ) , item . get total ( ) ) ; } catch ( final parse exception e ) { logger . warn ( str , item . get embedded id ( ) . get public date ( ) ) ; } } }	Adds the data item.
@ post construct public void init user command map ( ) { user command map . put ( manage user account request . account operation . delete , account -> { remove data manager . remove user account application history ( account . get user id ( ) ) ; get user dao ( ) . delete ( account ) ; return new manage user account response ( service result . success ) ; } ) ; user command map . put ( manage user account request . account operation . unlock , account -> { account . set user lock status ( user lock status . unlocked ) ; get user dao ( ) . persist ( account ) ; return new manage user account response ( service result . success ) ; } ) ; user command map . put ( manage user account request . account operation . lock , account -> { account . set user lock status ( user lock status . locked ) ; get user dao ( ) . persist ( account ) ; return new manage user account response ( service result . success ) ; } ) ; }	Inits the user command map.
private manage user account response perform operation ( final manage user account request service request , final create application event request event request ) { manage user account response response ; event request . set element id ( service request . get user acount id ( ) ) ; event request . set application message ( service request . get account operation ( ) . to string ( ) ) ; final user account account to modify = get user dao ( ) . find first by property ( user account . user id , service request . get user acount id ( ) ) ; final user command user command = user command map . get ( service request . get account operation ( ) ) ; if ( account to modify != null && user command != null ) { response = user command . execute ( account to modify ) ; } else { response = new manage user account response ( service result . failure ) ; } event request . set application message ( response . get result ( ) . to string ( ) ) ; return response ; }	Perform operation.
@ one to many ( target entity = vote data dto . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < vote data dto > get vote data list ( ) { return this . vote data list ; }	Gets the vote data list.
@ one to many ( target entity = assignment data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < assignment data > get assignment list ( ) { return this . assignment list ; }	Gets the assignment list.
private static void configure column orders and hidden fields ( final string [ ] column order , final string [ ] hide columns , final grid grid ) { if ( column order != null ) { grid . set column order ( column order ) ; } if ( hide columns != null ) { for ( final string o : hide columns ) { grid . remove column ( o ) ; } } }	Configure column orders and hidden fields.
private static void configure listeners ( final selection listener listener , final grid grid ) { if ( listener != null ) { grid . add selection listener ( listener ) ; } }	Configure listeners.
private static void create grid cell filter ( final string [ ] column order , final grid grid , final class data type ) { if ( column order != null ) { final grid cell filter filter = new grid cell filter ( grid , data type ) ; for ( final string column : column order ) { if ( grid . get column ( column ) != null ) { filter . set text filter ( column , bool , bool ) ; } } } }	Creates the grid cell filter.
private static void set column converters ( final list property converter [ ] collection property converter , final grid grid ) { if ( collection property converter != null ) { for ( final list property converter converter : collection property converter ) { grid . remove column ( converter . get column ( ) ) ; final column column = grid . add column ( converter ) ; column . set caption ( word utils . capitalize ( converter . get column ( ) ) ) ; column . set id ( converter . get column ( ) ) ; } } }	Sets the column converters.
private map < string , list < view riksdagen document type daily summary > > get document type map ( ) { final data container < view riksdagen document type daily summary , riksdagen document type summary embedded id > document type summary daily data container = get application manager ( ) . get data container ( view riksdagen document type daily summary . class ) ; return document type summary daily data container . get all ( ) . parallel stream ( ) . filter ( t -> t != null && ! t . get embedded id ( ) . get public date ( ) . starts with ( year prefix ) && string utils . contains ignore case ( mot prop bet , t . get embedded id ( ) . get document type ( ) ) ) . collect ( collectors . grouping by ( t -> t . get embedded id ( ) . get document type ( ) ) ) ; }	Gets the document type map.
private static void add data series ( final simple date format simple date format , final simple date format parse input date format , final data series data series , final series series , final entry < string , list < view riksdagen document type daily summary > > entry ) { series . add series ( new x ( ) . set label ( entry . get key ( ) ) ) ; data series . new series ( ) ; for ( final view riksdagen document type daily summary item : entry . get value ( ) ) { if ( item != null && item . get embedded id ( ) . get public date ( ) . length ( ) > num ) { try { data series . add ( simple date format . format ( parse input date format . parse ( item . get embedded id ( ) . get public date ( ) ) ) , item . get total ( ) ) ; } catch ( final parse exception e ) { logger . warn ( str , item . get embedded id ( ) . get public date ( ) ) ; } } } }	Adds the data series.
@ one to many ( target entity = sweden election type . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < sweden election type > get election types ( ) { return this . election types ; }	Gets the election types.
@ basic @ column ( name = str ) @ lob public string get ballot summary item ( ) { return xml adapter utils . unmarshall ( element as string . class , this . get ballot summary ( ) ) ; }	Gets the ballot summary item.
@ embedded @ attribute overrides ( { @ attribute override ( name = str , column = @ column ( name = str ) ) , @ attribute override ( name = str , column = @ column ( name = str ) ) } ) public adminregion get adminregion ( ) { return adminregion ; }	Gets the adminregion.
@ embedded @ attribute overrides ( { @ attribute override ( name = str , column = @ column ( name = str ) ) , @ attribute override ( name = str , column = @ column ( name = str ) ) } ) public income level get income level ( ) { return income level ; }	Gets the income level.
@ embedded @ attribute overrides ( { @ attribute override ( name = str , column = @ column ( name = str ) ) , @ attribute override ( name = str , column = @ column ( name = str ) ) } ) public lending type get lending type ( ) { return lending type ; }	Gets the lending type.
@ many to one ( target entity = ballot document data . class , cascade = { cascade type . all } ) @ join column ( name = str ) public ballot document data get ballot document data ( ) { return ballot document data ; }	Gets the ballot document data.
@ many to one ( target entity = ballot document element . class , cascade = { cascade type . all } ) @ join column ( name = str ) public ballot document element get ballot document element ( ) { return ballot document element ; }	Gets the ballot document element.
public static void main ( string [ ] args ) { if ( args . length == expected number args ) { final string encrypt value = new encrypt property ( ) . encrypt value ( args [ num ] , args [ num ] ) ; system . out . println ( encrypted value + encrypt value ) ; system . out . println ( encrypted property value + enc content prefix + encrypt value + enc content suffix ) ; } else { system . out . println ( help message ) ; } }	The main method.
public string encrypt value ( final string symmetric key , final string value ) { return get encryptor ( symmetric key ) . encrypt ( value ) ; }	Encrypt value.
private static pbe get encryptor ( final string symmetric key ) { security . add provider ( new bouncy castle provider ( ) ) ; final pbe my second encryptor = new pbe ( ) ; my second encryptor . set provider name ( bc provider name ) ; my second encryptor . set algorithm ( pbewithsh an bitaes cbc bc ) ; my second encryptor . set password ( symmetric key ) ; return my second encryptor ; }	Gets the encryptor.
public string decrypt value ( final string symmetric key , final string value ) { return get encryptor ( symmetric key ) . decrypt ( value ) ; }	Decrypt value.
@ one to many ( target entity = sweden county electoral region . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < sweden county electoral region > get county electoral regions ( ) { return this . county electoral regions ; }	Gets the county electoral regions.
protected final job context holder get job context holder ( final job execution context job context ) { final scheduler scheduler = job context . get scheduler ( ) ; job context holder bean = null ; try { final scheduler context scheduler context = scheduler . get context ( ) ; final application context app context = ( application context ) scheduler context . get ( application context ) ; bean = app context . get bean ( job context holder . class ) ; } catch ( final scheduler exception e ) { logger . error ( str , e ) ; } return bean ; }	Gets the job context holder.
@ one to many ( target entity = portal . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < portal > get portals ( ) { if ( portals == null ) { portals = new array list < > ( ) ; } return this . portals ; }	Gets the value of the portals property.
protected final optional < user account > get active user account ( ) { final data container < user account , long > data container = get application manager ( ) . get data container ( user account . class ) ; return data container . get all by ( user account . user id , user context util . get user id from security context ( ) ) . stream ( ) . find first ( ) ; }	Gets the active user account.
@ one to many ( target entity = document element . class , cascade = { cascade type . all } ) @ join column ( name = str ) public list < document element > get dokument ( ) { return this . dokument ; }	Gets the dokument.
protected final void create basic layout with panel and footer ( final string panel name ) { final vertical layout layout = create full size vertical layout ( ) ; final vertical layout page mode content = create full size vertical layout ( bool , bool ) ; layout . add component ( page mode content ) ; final horizontal layout top header = new horizontal layout ( ) ; add logo to header ( top header ) ; create top title header ( top header ) ; top header right panel . remove all components ( ) ; top header . add component ( top header right panel ) ; top header . set component alignment ( top header right panel , alignment . middle right ) ; top header . set expand ratio ( top header right panel , content ratio . large ) ; create top header actions for user context ( ) ; top header right panel . set width ( str ) ; top header right panel . set height ( str ) ; top header . set width ( str ) ; top header . set height ( str ) ; page mode content . add component ( top header ) ; page mode content . set component alignment ( top header , alignment . top center ) ; page mode content . add component ( get barmenu ( ) ) ; page mode content . set component alignment ( get barmenu ( ) , alignment . top center ) ; panel = new panel ( panel name ) ; panel . add style name ( str ) ; panel . set size full ( ) ; page mode content . add component ( panel ) ; page mode content . set expand ratio ( panel , content ratio . full size ) ; page mode content . add component ( page link factory . create main view page link ( ) ) ; set content ( layout ) ; set width ( num , unit . percentage ) ; set height ( num , unit . percentage ) ; set size full ( ) ; }	Creates the basic layout with panel and footer.
private void create top header actions for user context ( ) { if ( user context util . allow role in security context ( role admin ) || user context util . allow role in security context ( role user ) ) { final link user home page link = page link factory . create user home view page link ( ) ; top header right panel . add component ( user home page link ) ; top header right panel . set component alignment ( user home page link , alignment . middle right ) ; final button logout button = new button ( logout , vaadin icons . sign out ) ; final logout request logout request = new logout request ( ) ; logout request . set session id ( request context holder . current request attributes ( ) . get session id ( ) ) ; logout button . add click listener ( new logout click listener ( logout request ) ) ; top header right panel . add component ( logout button ) ; top header right panel . set component alignment ( logout button , alignment . middle right ) ; } else { final link create register page link = page link factory . create register page link ( ) ; top header right panel . add component ( create register page link ) ; top header right panel . set component alignment ( create register page link , alignment . middle right ) ; final link create login page link = page link factory . create login page link ( ) ; top header right panel . add component ( create login page link ) ; top header right panel . set component alignment ( create login page link , alignment . middle right ) ; } }	Creates the top header actions for user context.
private static vertical layout create full size vertical layout ( final boolean margin , final boolean spacing ) { final vertical layout layout = new vertical layout ( ) ; layout . set margin ( margin ) ; layout . set spacing ( spacing ) ; layout . set width ( num , unit . percentage ) ; layout . set height ( num , unit . percentage ) ; return layout ; }	Creates the full size vertical layout.
private static void add logo to header ( final horizontal layout top header ) { final theme resource cia logo resource = new theme resource ( str ) ; final image cia logo image = new image ( null , cia logo resource ) ; top header . add component ( cia logo image ) ; cia logo image . set width ( str ) ; cia logo image . set height ( str ) ; top header . set component alignment ( cia logo image , alignment . middle left ) ; top header . set expand ratio ( cia logo image , content ratio . small ) ; }	Adds the logo to header.
private static void create top title header ( final horizontal layout top header ) { final horizontal layout top title headert panel = new horizontal layout ( ) ; final label title label = new label ( str ) ; title label . set style name ( str ) ; top title headert panel . add component ( title label ) ; top title headert panel . set component alignment ( title label , alignment . middle left ) ; final label slogan label = new label ( str ) ; slogan label . set style name ( str ) ; top title headert panel . add component ( slogan label ) ; top title headert panel . set component alignment ( slogan label , alignment . middle right ) ; top header . add component ( top title headert panel ) ; top header . set component alignment ( top title headert panel , alignment . middle left ) ; top header . set expand ratio ( top title headert panel , content ratio . grid ) ; }	Creates the top title header.
private static int get smtp port ( final application configuration smtp port ) { if ( string utils . is numeric ( smtp port . get property value ( ) ) ) { return integer . parse int ( smtp port . get property value ( ) ) ; } else { return integer . parse int ( default smtp port ) ; } }	Gets the smtp port.
private language data find language ( final string locale ) { for ( final language data language data : language data dao . get all ( ) ) { if ( language data . get language code ( ) . equals ignore case ( locale ) ) { return language data ; } } return null ; }	Find language.
private static list < language data > get supported locales language data ( ) { final list < language data > languages = new array list < > ( ) ; for ( final locale locale : date format . get available locales ( ) ) { final string locale string = locale . to string ( ) . trim ( ) ; if ( locale . get display country ( locale . english ) . length ( ) == num && ! string utils . is empty ( locale string ) && locale string . length ( ) == expected locale length ) { languages . add ( new language data ( ) . with created date ( new date ( ) ) . with language code ( locale string ) . with language name ( locale . get display name ( locale . english ) ) . with language enabled ( boolean . false ) ) ; } } return languages ; }	Gets the supported locales language data.
private static map < string , list < view riksdagen vote data ballot party summary > > create issue concern map ( final list < view riksdagen vote data ballot party summary > party ballot list ) { final map < string , list < view riksdagen vote data ballot party summary > > concern issue party ballot summary map = new hash map < > ( ) ; for ( final view riksdagen vote data ballot party summary party summary : party ballot list ) { if ( party summary . get embedded id ( ) . get issue ( ) != null || party summary . get embedded id ( ) . get concern ( ) != null ) { final string key = party summary . get embedded id ( ) . get issue ( ) + party summary . get embedded id ( ) . get concern ( ) ; final list < view riksdagen vote data ballot party summary > party summar list = concern issue party ballot summary map . compute if absent ( key , k -> new array list < > ( ) ) ; party summar list . add ( party summary ) ; } } return concern issue party ballot summary map ; }	Creates the issue concern map.
public static source set name space on xml stream ( final input stream in , final string name space ) throws jdom , io { final sax sb = new sax ( new xml sa ( bool ) ) ; final document doc = sb . build ( in ) ; doc . get root element ( ) . set namespace ( namespace . get namespace ( name space ) ) ; return new jdom ( doc ) ; }	Sets the name space on xml stream.
protected final void add chart ( final abstract ordered layout content , final string caption , final d chart , final boolean full page ) { final horizontal layout horizontal layout = new horizontal layout ( ) ; final int browser window width = get chart window width ( ) ; final int browser window height = get chart window height ( full page ) ; horizontal layout . set width ( browser window width , unit . pixels ) ; horizontal layout . set height ( browser window height , unit . pixels ) ; horizontal layout . set margin ( bool ) ; horizontal layout . set spacing ( bool ) ; horizontal layout . add style name ( str ) ; final panel form panel = new panel ( ) ; form panel . set size full ( ) ; form panel . set content ( horizontal layout ) ; form panel . set caption ( caption ) ; content . add component ( form panel ) ; content . set expand ratio ( form panel , content ratio . large ) ; chart . set width ( num , unit . percentage ) ; chart . set height ( num , unit . percentage ) ; chart . set margin right ( chart right margin ) ; chart . set margin left ( chart left margin ) ; chart . set margin bottom ( chart bottom margin size ) ; chart . set margin top ( chart top margin size ) ; horizontal layout . add component ( chart ) ; chart . set caption ( caption ) ; }	Adds the chart.
private static int get chart window height ( final boolean full page ) { if ( full page ) { return math . max ( ( int ) ( page . get current ( ) . get browser window height ( ) * height percentage full page ) , minimum chart height full page ) ; } else { return math . max ( ( int ) ( page . get current ( ) . get browser window height ( ) * height percetage half page ) , ninimum chart height half page ) ; } }	Gets the chart window height.
protected final string get party name ( final string party ) { final data container < view riksdagen party , string > data container = application manager . get data container ( view riksdagen party . class ) ; final optional < view riksdagen party > matching objects = data container . get all ( ) . stream ( ) . filter ( ( final view riksdagen party p ) -> p . get party id ( ) . equals ignore case ( party ) ) . find first ( ) ; if ( matching objects . is present ( ) ) { return matching objects . get ( ) . get party name ( ) ; } else { return party ; } }	Gets the party name.
private map < string , list < view riksdagen politician document daily summary > > get view riksdagen politician document daily summary map ( ) { final data container < view riksdagen politician document daily summary , riksdagen document person summary embedded id > politician ballot summary daily data container = get application manager ( ) . get data container ( view riksdagen politician document daily summary . class ) ; return politician ballot summary daily data container . get all ( ) . parallel stream ( ) . filter ( objects :: non null ) . collect ( collectors . grouping by ( t -> t . get embedded id ( ) . get person id ( ) ) ) ; }	Gets the view riksdagen politician document daily summary map.
@ override public user identity login ( string username , object password , servlet request request ) { user identity user = super . login ( username , password , request ) ; if ( user != null ) { http session session = ( ( http servlet request ) request ) . get session ( bool ) ; authentication cached = new session authentication ( get auth method ( ) , user , password ) ; session . set attribute ( session authentication . j authenticated , cached ) ; } return user ; }	"login" is copied without changes from FormAuthenticator.
private boolean is windows ( ) { boolean result ; if ( os name . to lower case ( ) . contains ( str ) ) { result = bool ; } else { result = bool ; } get log ( ) . debug ( str + result ) ; return result ; }	Are we running on a flavour of Windows.
protected void start android emulator ( ) throws mojo execution exception { parse parameters ( ) ; command executor executor = command executor . factory . create default commmand executor ( ) ; executor . set logger ( this . get log ( ) ) ; try { string filename ; if ( is windows ( ) ) { filename = write emulator start script windows ( ) ; } else { filename = write emulator start script unix ( ) ; } final android debug bridge android debug bridge = init android debug bridge ( ) ; if ( android debug bridge . is connected ( ) ) { wait for initial device list ( android debug bridge ) ; list < i > devices = arrays . as list ( android debug bridge . get devices ( ) ) ; int number of devices = devices . size ( ) ; get log ( ) . info ( str + number of devices + str ) ; i existing emulator = find existing emulator ( devices ) ; if ( existing emulator == null ) { get log ( ) . info ( start emulator msg + filename ) ; executor . execute command ( filename , null ) ; get log ( ) . info ( start emulator wait msg + parsed wait ) ;	Start the Android Emulator with the specified options.
void unlock emulator ( android debug bridge android debug bridge ) { if ( emulator unlock ) { i my emulator = find existing emulator ( arrays . as list ( android debug bridge . get devices ( ) ) ) ; int device port = extract port from device ( my emulator ) ; if ( device port == - num ) { get log ( ) . info ( str + device helper . get descriptive name ( my emulator ) ) ; } else { get log ( ) . info ( str + device helper . get descriptive name ( my emulator ) ) ; send emulator command ( device port , str ) ; send emulator command ( device port , str ) ; send emulator command ( device port , str ) ; send emulator command ( device port , str ) ; } } }	Unlocks the emulator.
private string write emulator start script windows ( ) throws mojo execution exception { string filename = script folder + str ; file file = new file ( filename ) ; print writer writer = null ; try { writer = new print writer ( new file writer ( file ) ) ;	Writes the script to start the emulator in the background for windows based environments.
private string write emulator start script unix ( ) throws mojo execution exception { string filename = script folder + str ; file sh ; sh = new file ( str ) ; if ( ! sh . exists ( ) ) { sh = new file ( str ) ; } if ( ! sh . exists ( ) ) { sh = new file ( str ) ; } file file = new file ( filename ) ; print writer writer = null ; try { writer = new print writer ( new file writer ( file ) ) ; writer . println ( str + sh . get absolute path ( ) ) ; writer . print ( assemble start command line ( ) ) ; writer . print ( str ) ;	Writes the script to start the emulator in the background for unix based environments.
protected void stop android emulator ( ) throws mojo execution exception { parse parameters ( ) ; final android debug bridge android debug bridge = init android debug bridge ( ) ; if ( android debug bridge . is connected ( ) ) { list < i > devices = arrays . as list ( android debug bridge . get devices ( ) ) ; int number of devices = devices . size ( ) ; get log ( ) . info ( str + number of devices + str ) ; for ( i device : devices ) { if ( device . is emulator ( ) ) { if ( is existing emulator ( device ) ) { stop emulator ( device ) ; } } else { get log ( ) . info ( str + device helper . get descriptive name ( device ) ) ; } } } }	Stop the running Android Emulator.
private void stop emulator ( i device ) { int device port = extract port from device ( device ) ; if ( device port == - num ) { get log ( ) . info ( str + device helper . get descriptive name ( device ) ) ; } else { get log ( ) . info ( str + device helper . get descriptive name ( device ) ) ; send emulator command ( device port , str ) ; boolean killed = send emulator command ( device port , str ) ; if ( ! killed ) { get log ( ) . info ( str + device helper . get descriptive name ( device ) ) ; } else { get log ( ) . info ( str + device helper . get descriptive name ( device ) ) ; } } }	This method contains the code required to stop an emulator.
private string assemble start command line ( ) throws mojo execution exception { string emulator path ; if ( ! str . equals ( parsed emulator location ) ) { emulator path = new file ( parsed emulator location , parsed executable ) . get absolute path ( ) ; } else { emulator path = new file ( get android sdk ( ) . get tools path ( ) , parsed executable ) . get absolute path ( ) ; } string builder start commandline = new string builder ( str ) . append ( emulator path ) . append ( str ) . append ( str ) . append ( parsed avd ) . append ( str ) ; if ( ! string utils . is empty ( parsed options ) ) { start commandline . append ( parsed options ) ; } get log ( ) . info ( str + start commandline ) ; return start commandline . to string ( ) ; }	Assemble the command line for starting the emulator based on the parameters supplied in the pom file and on thecommand line.
private string determine executable ( ) { string emulator ; if ( emulator executable != null ) { emulator = emulator executable ; } else { emulator = str ; } return emulator ; }	Get executable value for emulator from command line options or default to "emulator".
string determine wait ( ) { string wait ; if ( emulator wait != null ) { wait = emulator wait ; } else { wait = str ; } return wait ; }	Get wait value for emulator from command line option.
private string determine options ( ) { string options ; if ( emulator options != null ) { options = emulator options ; } else { options = str ; } return options ; }	Get options value for emulator from command line option.
string determine avd ( ) { string avd ; if ( emulator avd != null ) { avd = emulator avd ; } else { avd = str ; } return avd ; }	Get avd value for emulator from command line option.
string determine emulator location ( ) { string location ; if ( emulator location != null ) { location = emulator location ; } else { location = str ; } return location ; }	Get location value for emulator from command line option.
public static void unjar ( jar file jar file , file output directory , unjar listener unjar listener ) throws io { for ( enumeration en = jar file . entries ( ) ; en . has more elements ( ) ; ) { jar entry entry = ( jar entry ) en . next element ( ) ; file entry file = new file ( output directory , entry . get name ( ) ) ; if ( unjar listener . include ( entry ) ) {	Unjars the specified jar file into the the specified directory.
private map < string , string > calculate source destination mapping ( ) throws mojo execution exception { map < string , string > result = new hash map < string , string > ( ) ; file source file = new file ( parsed source ) ; final string destination path ; if ( parsed destination . ends with ( str ) ) { destination path = parsed destination + source file . get name ( ) ; } else { destination path = parsed destination ; } if ( source file . is file ( ) ) {	Calculates a map which contains all files to be pushed to the device oremulator.
public void visit ( dependency node node , boolean collecting ) { if ( collecting ) { dependencies . add ( node . get artifact ( ) ) ; } if ( matches target ( node . get artifact ( ) ) ) { collecting = bool ; log . debug ( str + node . get artifact ( ) ) ; } for ( final dependency node child : node . get children ( ) ) { visit ( child , collecting ) ; } }	Visits all nodes from the given node and collects dependencies.
private artifact resolve artifact ( artifact artifact ) throws mojo execution exception { final artifact resolution request artifact resolution request = new artifact resolution request ( ) ; artifact resolution request . set artifact ( artifact ) ; if ( remote artifact repositories != null && ! remote artifact repositories . is empty ( ) ) { artifact resolution request . set remote repositories ( remote artifact repositories ) ; } final artifact resolution result resolution result = this . artifact resolver . resolve ( artifact resolution request ) ; log . debug ( str + artifact ) ; if ( resolution result . get artifacts ( ) . size ( ) == num ) { throw new mojo execution exception ( str + artifact + str + str ) ; } if ( resolution result . get artifacts ( ) . size ( ) > num ) { log . debug ( str + resolution result . get artifacts ( ) ) ; throw new mojo execution exception ( str + artifact + str + resolution result . get artifacts ( ) ) ; } final artifact resolved artifact = resolution result . get artifacts ( ) . iterator ( ) . next ( ) ; log . debug ( str + resolved artifact ) ; return resolved artifact ; }	Resolves an artifact to a particular repository.
private void wait until connected ( android debug bridge adb ) { int trials = num ; final int connection wait time = num ; while ( trials > num ) { try { thread . sleep ( connection wait time ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } if ( adb . is connected ( ) ) { break ; } trials -- ; } }	Run a wait loop until adb is connected or trials run out.
protected void wait for initial device list ( final android debug bridge android debug bridge ) throws mojo execution exception { if ( ! android debug bridge . has initial device list ( ) ) { get log ( ) . info ( str ) ; long limit time = system . current time millis ( ) + adb timeout ms ; while ( ! android debug bridge . has initial device list ( ) && ( system . current time millis ( ) < limit time ) ) { try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { throw new mojo execution exception ( str ) ; } } if ( ! android debug bridge . has initial device list ( ) ) { get log ( ) . error ( str ) ; } } }	Wait for the Android Debug Bridge to return an initial device list.
protected void deploy apk ( final file apk file ) throws mojo execution exception , mojo failure exception { if ( undeploy before deploy ) { undeploy apk ( apk file ) ; } do with devices ( new device callback ( ) { public void do with device ( final i device ) throws mojo execution exception { string device log line prefix = device helper . get device log line prefix ( device ) ; try { device . install package ( apk file . get absolute path ( ) , bool ) ; get log ( ) . info ( device log line prefix + str + apk file . get absolute path ( ) ) ; get log ( ) . debug ( str + device helper . get descriptive name ( device ) ) ; } catch ( install exception e ) { throw new mojo execution exception ( device log line prefix + str + apk file . get absolute path ( ) + str , e ) ; } } } ) ; }	Deploys an apk file to a connected emulator or usb device.
protected void deploy built apk ( ) throws mojo execution exception , mojo failure exception { if ( project . get packaging ( ) . equals ( apk ) ) { file apk file = new file ( target directory , final name + str + apk ) ; deploy apk ( apk file ) ; } else { get log ( ) . info ( str ) ; } }	Deploy the apk built with the current projects to all attached devices and emulators.Skips other projects in a multi-module build without terminating.
protected boolean undeploy apk ( file apk file ) throws mojo execution exception , mojo failure exception { final string package name ; package name = extract package name from apk ( apk file ) ; return undeploy apk ( package name ) ; }	Undeploys an apk from a connected emulator or usb device.
protected boolean undeploy apk ( final string package name ) throws mojo execution exception , mojo failure exception { final atomic boolean result = new atomic boolean ( bool ) ;	Undeploys an apk, specified by package name, from a connected emulatoror usb device.
protected string extract package name from apk ( file apk file ) throws mojo execution exception { command executor executor = command executor . factory . create default commmand executor ( ) ; executor . set logger ( this . get log ( ) ) ; executor . set capture std out ( bool ) ; executor . set capture std err ( bool ) ; aapt command builder command builder = aapt command builder . dump ( get log ( ) ) . xml tree ( ) . set path to apk ( apk file . get absolute path ( ) ) . add asset file ( str ) ; get log ( ) . info ( get android sdk ( ) . get aapt path ( ) + str + command builder . to string ( ) ) ; try { executor . execute command ( get android sdk ( ) . get aapt path ( ) , command builder . build ( ) , bool ) ; final string xml tree = executor . get standard out ( ) ; return extract package name from android manifest xml tree ( xml tree ) ; } catch ( execution exception e ) { throw new mojo execution exception ( str + apk file ) ; } finally { string errout = executor . get standard error ( ) ; if ( ( errout != null ) && ( errout . trim ( ) . length ( ) > num ) ) { get log ( ) . error ( errout ) ; } } }	Extracts the package name from an apk file.
protected string extract package name from android artifact ( artifact artifact ) throws mojo execution exception { final file unpacked lib folder = get unpacked lib folder ( artifact ) ; final file manifest = new file ( unpacked lib folder , str ) ; if ( ! manifest . exists ( ) ) { throw new mojo execution exception ( str + unpacked lib folder ) ; } return extract package name from android manifest ( manifest ) ; }	Provides package name for android artifact.
protected string extract instrumentation runner from android manifest ( file manifest file ) throws mojo execution exception { final url xml url ; try { xml url = manifest file . to uri ( ) . to url ( ) ; } catch ( url e ) { throw new mojo execution exception ( str + manifest file , e ) ; } final document container document container = new document container ( xml url ) ; final object instrumentation runner ; try { instrumentation runner = jx . new context ( document container ) . get value ( str , string . class ) ; } catch ( jx e ) { return null ; } return ( string ) instrumentation runner ; }	Attempts to find the instrumentation test runner from inside the AndroidManifest.xml file.
public void execute ( ) throws mojo execution exception , mojo failure exception { do with devices ( new device callback ( ) { public void do with device ( final i device ) throws mojo execution exception { get log ( ) . info ( device helper . get descriptive name with status ( device ) ) ; } } ) ; }	Display a list of attached devices.
private static void copy stream without closing ( input stream in , output stream out ) throws io { final int buffer size = num ; byte [ ] b = new byte [ buffer size ] ; int n ; while ( ( n = in . read ( b ) ) != - num ) { out . write ( b , num , n ) ; } }	Copies an input stream into an output stream but does not close the streams.
private void copy gdb server ( file destination directory , string architecture ) throws mojo execution exception { try { final file dest dir = new file ( destination directory , architecture ) ; if ( dest dir . exists ( ) ) {	Copy the Ndk GdbServer into the architecture output folder if the folder exists but the GdbServer doesn't.
private static file get java executable ( ) { final string java home = system . get property ( str ) ; final string slash = file . separator ; return new file ( java home + slash + str + slash + str ) ; }	Figure out the full path to the current java executable.
public string get proguard jar path ( ) { file directory = new file ( get tools path ( ) , str + file . separator + str + file . separator ) ; file proguard jar = new file ( directory , str ) ; if ( proguard jar . exists ( ) ) { return proguard jar . get absolute path ( ) ; } throw new invalid sdk exception ( str + proguard jar ) ; }	Get the path for proguard.jar.
public string get shrinked android jar path ( ) { file shrinked android jar = new file ( get build tools lib directory path ( ) , str ) ; if ( shrinked android jar . exists ( ) ) { return shrinked android jar . get absolute path ( ) ; } throw new invalid sdk exception ( str + shrinked android jar ) ; }	Get the path for shrinkedAndroid.jar.
public string get build tools lib directory path ( ) { file build tools lib = new file ( get build tool info ( ) . get location ( ) , str ) ; if ( build tools lib . exists ( ) ) { return build tools lib . get absolute path ( ) ; } throw new invalid sdk exception ( str + build tools lib ) ; }	Get the path for build-tools lib directory.
public string get main dex classes rules path ( ) { file main dex classes rules = new file ( get build tool info ( ) . get location ( ) , str ) ; if ( main dex classes rules . exists ( ) ) { return main dex classes rules . get absolute path ( ) ; } throw new invalid sdk exception ( str + main dex classes rules ) ; }	Get the path for mainDexClasses.rules.
public string get android path ( ) { string cmd = str ; string ext = sdk constants . current platform ( ) == num ? str : str ; return get path for tool ( cmd + ext ) ; }	Get the android tool path.
public file get android jar ( ) throws mojo execution exception { final string android jar path = android target . get path ( i . android jar ) ; if ( android jar path == null ) { throw new mojo execution exception ( str + android target . get location ( ) ) ; } return new file ( android jar path ) ; }	Resolves the android.jar from this SDK.
public file get platform ( ) { assert path is directory ( sdk path ) ; final file platforms directory = new file ( sdk path , platforms folder name ) ; assert path is directory ( platforms directory ) ; final file platform directory ; if ( android target == null ) { i latest target = null ; android target manager target manager = sdk manager . get android target manager ( progress indicator ) ; for ( i target : target manager . get targets ( progress indicator ) ) { if ( target . is platform ( ) ) { if ( latest target == null || target . get version ( ) . get api level ( ) > latest target . get version ( ) . get api level ( ) ) { latest target = target ; } } } platform directory = new file ( latest target . get location ( ) ) ; } else { platform directory = new file ( android target . get location ( ) ) ; } assert path is directory ( platform directory ) ; return platform directory ; }	This method returns the previously specified version.
private void load sdk ( ) { file prop file = new file ( sdk path , str + source properties filename ) ; properties properties = new properties ( ) ; try { properties . load ( new file input stream ( prop file ) ) ; } catch ( io e ) { throw new invalid sdk exception ( str + prop file . get absolute file ( ) ) ; } if ( properties . contains key ( sdk tools revision property ) ) { try { string version string = properties . get property ( sdk tools revision property ) ; string major version ; if ( version string . matches ( str ) ) { string [ ] versions = version string . split ( str ) ; major version = versions [ num ] ; } else { major version = version string ; } sdk major version = integer . parse int ( major version ) ; } catch ( number format exception e ) { throw new invalid sdk exception ( str + sdk tools revision property + str + properties . get property ( sdk tools revision property ) ) ; } } }	Loads the SDK Tools version.
public void execute ( ) throws mojo execution exception , mojo failure exception {	Generates the sources.
protected void copy manifest ( ) throws mojo execution exception { get log ( ) . debug ( str + android manifest file + str + destination manifest file ) ; if ( android manifest file == null ) { get log ( ) . debug ( str ) ; return ; } try { document builder factory dbf = document builder factory . new instance ( ) ; document builder db = dbf . new document builder ( ) ; document doc = db . parse ( android manifest file ) ; source source = new dom ( doc ) ; transformer factory xfactory = transformer factory . new instance ( ) ; transformer xformer = xfactory . new transformer ( ) ; xformer . set output property ( output keys . omit xml declaration , str ) ; file writer writer = null ; try { destination manifest file . get parent file ( ) . mkdirs ( ) ; writer = new file writer ( destination manifest file , bool ) ; if ( doc . get xml encoding ( ) != null && doc . get xml version ( ) != null ) { string xmldecl = string . format ( str , doc . get xml version ( ) , doc . get xml encoding ( ) ) ; writer . write ( xmldecl ) ; } result result = new stream result ( writer ) ; xformer . transform ( source , result ) ; get log ( ) . info ( str + android manifest file + str + destination manifest file ) ; } finally { io . close quietly ( writer ) ; } } catch ( exception e ) { get log ( ) . error ( str ) ; throw new mojo execution exception ( str , e ) ; } }	Copy the AndroidManifest.xml from androidManifestFile to destinationManifestFile.
protected void extract source dependencies ( ) throws mojo execution exception { for ( artifact artifact : get direct dependency artifacts ( ) ) { string type = artifact . get type ( ) ; if ( type . equals ( apksources ) ) { get log ( ) . debug ( str + artifact + str + artifact . get file ( ) + str ) ; final file apksources file = resolve artifact to file ( artifact ) ; get log ( ) . debug ( str + apksources file + str ) ; extract apksources ( apksources file ) ; } } if ( extracted dependencies java resources . exists ( ) ) { project helper . add resource ( project , extracted dependencies java resources . get absolute path ( ) , null , null ) ; project . add compile source root ( extracted dependencies java sources . get absolute path ( ) ) ; } }	Extract the source dependencies.
private void extract apklib ( artifact apklib artifact ) throws mojo execution exception { get unpacked lib helper ( ) . extract apklib ( apklib artifact ) ;	Extracts ApkLib and adds the assets and apklib sources and resources to the build.
private void extract aar lib ( artifact aar artifact ) throws mojo execution exception { get unpacked lib helper ( ) . extract aar lib ( aar artifact ) ;	Extracts AarLib and if this is an APK build then adds the assets and resources to the build.
private void check for apklib dependencies ( ) throws mojo execution exception { final boolean is aar build = project . get packaging ( ) . equals ( aar ) ; final dependency resolver dependency resolver = get dependency resolver ( ) ; final set < artifact > all artifacts = project . get artifacts ( ) ; set < artifact > dependency artifacts = get artifact resolver helper ( ) . get filtered artifacts ( all artifacts ) ; boolean found apklib = bool ; for ( artifact artifact : dependency artifacts ) { final string type = artifact . get type ( ) ; if ( type . equals ( apklib ) && is aar build ) { get log ( ) . warn ( str + artifact . get id ( ) ) ; found apklib = bool ; } else if ( type . equals ( aar ) ) { final set < artifact > dependencies = dependency resolver . get library dependencies for ( session , repository system , artifact ) ; for ( artifact dependency : dependencies ) { if ( dependency . get type ( ) . equals ( apklib ) ) { get log ( ) . warn ( str + artifact . get id ( ) + str + dependency . get id ( ) ) ; found apklib = bool ; } } } } if ( found apklib ) { get log ( ) . warn ( str + str + str ) ; } }	Traverses the list of project dependencies looking for &quot;AAR depends on APKLIB&quot; artifact combinationthat has been deprecated.
map < string , set < artifact > > get package compare map ( set < artifact > dependency artifacts ) throws mojo execution exception { if ( dependency artifacts == null ) { throw new illegal argument exception ( str ) ; } map < string , set < artifact > > package compare map = new hash map < string , set < artifact > > ( ) ; set < artifact > artifact set = new hash set < artifact > ( ) ; artifact set . add ( project . get artifact ( ) ) ; package compare map . put ( get android manifest package name ( ) , artifact set ) ; for ( artifact artifact : dependency artifacts ) { string lib package = extract package name from android artifact ( artifact ) ; set < artifact > artifacts = package compare map . get ( lib package ) ; if ( artifacts == null ) { artifacts = new hash set < artifact > ( ) ; package compare map . put ( lib package , artifacts ) ; } artifacts . add ( artifact ) ; } return package compare map ; }	Provides map with all provided dependencies or project itself grouped by package name.
private void generate correct r ( resource class generator resource generator ) throws mojo execution exception { get log ( ) . debug ( str ) ; get log ( ) . debug ( str ) ;	Generate correct R.java for apklibs dependencies of a current project.
private void generate correct r ( resource class generator resource generator ) throws mojo execution exception {	Generate correct R.java for aar dependencies of a current project.
private void generate r ( artifact apklib artifact ) throws mojo execution exception { final file unpack dir = get unpacked lib folder ( apklib artifact ) ; get log ( ) . debug ( str + apklib artifact . get group id ( ) + str + apklib artifact . get artifact id ( ) ) ; final file apklib manifest = new file ( unpack dir , str ) ; final file apklib res dir = new file ( unpack dir , str ) ; list < file > dependencies res directories = new array list < file > ( ) ; final set < artifact > apklib deps = get dependency resolver ( ) . get library dependencies for ( this . session , this . repository system , apklib artifact ) ; get log ( ) . debug ( str + apklib artifact + str + apklib deps ) ; for ( artifact dependency : apklib deps ) {	Executes aapt to generate the R class for the given apklib.
private boolean is build config present ( artifact artifact ) throws mojo execution exception { string dep package name = extract package name from android artifact ( artifact ) ; return is build config present ( artifact , dep package name ) ; }	Check if given artifact includes a matching BuildConfig class.
private boolean is build config present ( artifact artifact , string package name ) throws mojo execution exception { try { jar file jar = new jar file ( get unpacked aar classes jar ( artifact ) ) ; jar entry entry = jar . get jar entry ( package name . replace ( str , str ) + str ) ; return ( entry != null ) ; } catch ( io e ) { get log ( ) . error ( str , e ) ; throw new mojo execution exception ( str , e ) ; } }	Check whether the artifact includes a BuildConfig located in a given package.
private set < file > get dex input files ( ) throws mojo execution exception { set < file > inputs = new hash set < file > ( ) ; if ( obfuscated jar != null && obfuscated jar . exists ( ) ) {	Gets the input files for dex.
public void execute ( ) throws mojo execution exception , mojo failure exception {	Execute the mojo by parsing the confign and actually doing the zipalign.
private static void check client secrets file ( google client secrets client secrets ) { if ( client secrets . get details ( ) . get client id ( ) . starts with ( str ) || client secrets . get details ( ) . get client secret ( ) . starts with ( str ) ) { log . error ( str + str ) ; system . exit ( num ) ; } }	Ensure the client secrets file has been filled out.
private void add libs jars to class path ( unpacked lib helper helper , maven project project , artifact artifact ) throws maven execution exception { try { final file unpack lib folder = helper . get unpacked lib folder ( artifact ) ; final file artifact file = helper . get artifact to file ( artifact ) ; zip file zip file = new zip file ( artifact file ) ; enumeration enumeration = zip file . entries ( ) ; while ( enumeration . has more elements ( ) ) { zip entry entry = ( zip entry ) enumeration . next element ( ) ; string entry name = entry . get name ( ) ;	Add jar files in libs into the project classpath.
private void add classes to classpath ( unpacked lib helper helper , maven project project , artifact artifact ) throws maven execution exception {	Add the dependent library classes to the project classpath.
public static string get gav ( ) { string builder builder = new string builder ( ) . append ( group id ) . append ( colon ) . append ( artifact id ) . append ( colon ) . append ( version ) ; return builder . to string ( ) ; }	Get the Maven GAV string of the plugin.
private void collect jvm arguments ( list < string > commands ) { if ( parsed jvm arguments != null ) { for ( string jvm argument : parsed jvm arguments ) {	Convert the jvm arguments in parsedJvmArguments as populated by the config in format as needed by the javacommand.
private file get jvm ( string file name ) { file lib file = new file ( get java lib dir ( ) , file name ) ; if ( ! lib file . exists ( ) ) { lib file = new file ( get alt java lib dir ( ) , file name ) ; if ( ! lib file . exists ( ) ) { lib file = null ; } } return lib file ; }	Finds a library file in either the primary or alternate lib directory.
public string get toolchain ( file file ) throws mojo execution exception { string resolved ndk toolchain = null ;	Tries to resolve the toolchain based on the path of the file.
public string get ndk build path ( ) { if ( system utils . is os windows ) { return new file ( ndk path , str ) . get absolute path ( ) ; } else { return new file ( ndk path , str ) . get absolute path ( ) ; } }	Returns the complete path for the ndk-build tool, based on this NDK.
private document read manifest ( file manifest file ) throws io , parser configuration exception , sax { document builder factory dbf = document builder factory . new instance ( ) ; document builder db = dbf . new document builder ( ) ; document doc = db . parse ( manifest file ) ; return doc ; }	Read manifest using JAXP.
private void write manifest ( file manifest file , document doc ) throws io , transformer exception { transformer factory xfactory = transformer factory . new instance ( ) ; transformer xformer = xfactory . new transformer ( ) ; xformer . set output property ( output keys . omit xml declaration , str ) ; source source = new dom ( doc ) ; output stream writer writer = null ; try { manifest file . get parent file ( ) . mkdirs ( ) ; string encoding = doc . get xml encoding ( ) != null ? doc . get xml encoding ( ) : str ; writer = new output stream writer ( new file output stream ( manifest file , bool ) , encoding ) ; if ( doc . get xml encoding ( ) != null && doc . get xml version ( ) != null ) { string xmldecl = string . format ( str , doc . get xml version ( ) , doc . get xml encoding ( ) ) ; writer . write ( xmldecl ) ; } result result = new stream result ( writer ) ; xformer . transform ( source , result ) ; } finally { io . close quietly ( writer ) ; } }	Write manifest using JAXP transformer.
private void export properties ( ) { project . get properties ( ) . set property ( str , parsed version name ) ; project . get properties ( ) . set property ( str , string . value of ( parsed version code auto increment ) ) ; project . get properties ( ) . set property ( str , string . value of ( parsed version code update from version ) ) ; project . get properties ( ) . set property ( str , string . value of ( parsed debuggable ) ) ; if ( parsed shared user id != null ) { project . get properties ( ) . set property ( str , parsed shared user id ) ; } }	Expose the version properties and other simple parsed manifest entries.
private void perform version code update from version ( element manifest element ) throws mojo execution exception { string ver string = project . get version ( ) ; get log ( ) . debug ( str + ver string ) ; string ver code = generate version code from version name ( ver string ) ; get log ( ) . info ( str + attr version code + str + ver code ) ; manifest element . set attribute ( attr version code , ver code ) ; project . get properties ( ) . set property ( str , string . value of ( ver code ) ) ; }	If the specified version name cannot be properly parsed then fall back toan automatic method.If the version can be parsed then generate a version code from theversion components.
public static string extract architecture from artifact ( artifact artifact , final string default architecture ) { string classifier = artifact . get classifier ( ) ; if ( classifier != null ) {	Extracts, if embedded correctly, the artifacts architecture from its classifier.
public string [ ] get file names ( file base directory ) { if ( ! base directory . exists ( ) ) { return new string [ num ] ; } final directory scanner directory scanner = new directory scanner ( ) ; directory scanner . set basedir ( base directory ) ; directory scanner . set includes ( includes ) ; directory scanner . add default excludes ( ) ; directory scanner . scan ( ) ; return directory scanner . get included files ( ) ; }	Finds the files in the supplied folder that match the configured includes.
public static string encrypt ( string data , string key ) { try { cipher c = cipher . get instance ( str ) ; c . init ( cipher . encrypt mode , secret key factory . get instance ( str ) . generate secret ( new des ( key . get bytes ( ) ) ) ) ; return hex . encode hex string ( c . do final ( data . get bytes ( ) ) ) ; } catch ( exception e ) { e . print stack trace ( ) ; } return null ; }	Convert data to encrypted hex string.
public static string decrypt ( string data , string key ) { try { cipher c = cipher . get instance ( str ) ; c . init ( cipher . decrypt mode , secret key factory . get instance ( str ) . generate secret ( new des ( key . get bytes ( ) ) ) ) ; return new string ( c . do final ( hex . decode hex ( data . to char array ( ) ) ) , charset . default charset ( ) ) ; } catch ( exception e ) { e . print stack trace ( ) ; } return null ; }	Convert encrypted hex string to UTF-8 string.
private static string read name ( byte data [ ] , int offset , hash set < integer > jumps ) throws io { int c = data [ offset ] & num ; if ( ( c & num ) == num ) { c = ( ( c & num ) << num ) + ( data [ offset + num ] & num ) ; if ( jumps . contains ( c ) ) { throw new dns exception ( str , str ) ; } jumps . add ( c ) ; return read name ( data , c , jumps ) ; } if ( c == num ) { return str ; } string s = new string ( data , offset + num , c ) ; string t = read name ( data , offset + num + c , jumps ) ; if ( t . length ( ) > num ) { s = s + str + t ; } return s ; }	Parse a domain name starting at the given offset.
protected static int to digit ( final char ch , final int index ) throws hex decode exception { final int digit = character . digit ( ch , num ) ; if ( digit == - num ) { throw new hex decode exception ( str + ch + str + index ) ; } return digit ; }	Converts a hexadecimal character to an integer.
private boolean try to move ( float delta y ) {	if deltaY > 0, tryToMove the content down.
public synchronized void start listening ( context context ) { if ( ! m listening ) { m context = context ; intent filter filter = new intent filter ( ) ; filter . add action ( connectivity manager . connectivity action ) ; context . register receiver ( m receiver , filter ) ; m listening = bool ; } }	This method starts listening for network connectivity state changes.
public synchronized void stop listening ( ) { if ( m listening ) { m context . unregister receiver ( m receiver ) ; m context = null ; m network info = null ; m other network info = null ; m is fail over = bool ; m reason = null ; m listening = bool ; } }	This method stops this class from listening for network changes.
public void send ( ) throws io { hash map < string , request data . upload file info > upload files = m request data . get upload files ( ) ; hash map < string , object > m post data = m request data . get post data ( ) ;	post data to Server.
public void add form field ( string name , string value ) { m writer . append ( str + m boundary ) . append ( line feed ) ; m writer . append ( str + name + str ) . append ( line feed ) ; m writer . append ( str + m charset ) . append ( line feed ) ; m writer . append ( line feed ) ; m writer . append ( value ) . append ( line feed ) ; m writer . flush ( ) ; }	Adds a form field to the request.
public void add file part ( string field name , file upload file , string file name ) throws io { if ( text utils . is empty ( file name ) ) { file name = upload file . get name ( ) ; } m writer . append ( str + m boundary ) . append ( line feed ) ; m writer . append ( str + field name + str + file name + str ) . append ( line feed ) ; m writer . append ( str + url . guess content type from name ( file name ) ) . append ( line feed ) ; m writer . append ( str ) . append ( line feed ) ; m writer . append ( line feed ) ; m writer . flush ( ) ; file input stream input stream = new file input stream ( upload file ) ; byte [ ] buffer = new byte [ num ] ; int bytes read = - num ; while ( ( bytes read = input stream . read ( buffer ) ) != - num ) { m output stream . write ( buffer , num , bytes read ) ; } m output stream . flush ( ) ; input stream . close ( ) ; m writer . append ( line feed ) ; m writer . flush ( ) ; }	Adds a upload file section to the request.
public bitmap drawable create bitmap drawable ( resources resources , bitmap bitmap ) { if ( bitmap == null ) { return null ; } bitmap drawable drawable = null ; if ( bitmap != null ) { if ( version . has honeycomb ( ) ) {	Create a BitmapDrawable which can be managed in ImageProvider.
public void pre load images ( string [ ] urls ) { int len = urls . length ; for ( int i = num ; i < len ; i ++ ) { image load request request = new image load request ( urls [ i ] ) ; final image task image task = create image task ( request ) ; image task . set is pre load ( ) ; add image task ( image task , null ) ; } }	Load the image in advance.
public void detach image view from image task ( image task image task , cube image view image view ) { image task . remove image view ( image view ) ; if ( image task . is loading ( ) ) { if ( ! image task . is pre load ( ) && ! image task . still has related image view ( ) ) { load image task task = m load work list . get ( image task . get identity key ( ) ) ; if ( task != null ) { task . cancel ( ) ; } if ( debug ) { c . d ( log tag , str , image task ) ; } } } if ( ! image task . still has related image view ( ) ) { image task . try to recycle ( ) ; } }	Detach the ImageView from the ImageTask.
public void add image task ( image task image task , cube image view image view ) { if ( ! m has been added to component manager ) { c . w ( log tag , str , this ) ; } load image task running task = m load work list . get ( image task . get identity key ( ) ) ; if ( running task != null ) { if ( image view != null ) { if ( debug ) { c . d ( log tag , msg attack to running task , image task , running task . get image task ( ) ) ; } running task . get image task ( ) . add image view ( image view ) ; running task . get image task ( ) . notify loading ( m image load handler , image view ) ; } return ; } else { image task . add image view ( image view ) ; } image task . on loading ( m image load handler ) ; load image task load image task = create load image task ( image task ) ; m load work list . put ( image task . get identity key ( ) , load image task ) ; m image task executor . execute ( load image task ) ; }	Add the ImageTask into loading list.
public boolean query cache ( image task image task , cube image view image view ) { if ( null == m image provider ) { return bool ; } bitmap drawable drawable = m image provider . get bitmap from mem cache ( image task ) ; if ( image task . get statistics ( ) != null ) { image task . get statistics ( ) . s0 after check memory cache ( drawable != null ) ; } if ( drawable == null ) { return bool ; } if ( debug ) { c . d ( log tag , msg hit cache , image task , drawable . get intrinsic width ( ) , drawable . get intrinsic height ( ) ) ; } image task . add image view ( image view ) ; image task . on load task finish ( drawable , m image load handler ) ; return bool ; }	Check weather this imageTask has cache Drawable data.
public void recover work ( ) { if ( debug ) { c . d ( log tag , str , this ) ; } m exit tasks early = bool ; set pause ( bool ) ; iterator < entry < string , load image task > > it = ( iterator < entry < string , load image task > > ) m load work list . entry set ( ) . iterator ( ) ; while ( it . has next ( ) ) { entry < string , load image task > item = it . next ( ) ; load image task task = item . get value ( ) ; task . restart ( ) ; m image task executor . execute ( task ) ; } }	Recover the from the work list.
public void stop work ( ) { if ( debug ) { c . d ( log tag , str , this ) ; } m exit tasks early = bool ; set pause ( bool ) ; flush file cache ( ) ; }	Drop all the work, and leave it in the work list.
public void destroy ( ) { if ( debug ) { c . d ( log tag , str , this ) ; } m exit tasks early = bool ; set pause ( bool ) ; iterator < entry < string , load image task > > it = ( iterator < entry < string , load image task > > ) m load work list . entry set ( ) . iterator ( ) ; while ( it . has next ( ) ) { entry < string , load image task > item = it . next ( ) ; final load image task task = item . get value ( ) ; it . remove ( ) ; if ( task != null ) { task . cancel ( ) ; } } m load work list . clear ( ) ; }	Drop all the work, clear the work list.
public image loader attach to cube fragment ( cube fragment fragment ) { if ( fragment != null ) { if ( life cycle component manager . try add component to container ( this , fragment , bool ) ) { m has been added to component manager = bool ; } } return this ; }	LiefCycle phase will be same to CubeFragment, an will be processed automatically.
public void invalidate cache ( string key ) { if ( debug ) { c . d ( log tag , str , key ) ; } try { m file cache . get disk cache ( ) . delete ( key ) ; } catch ( io e ) { if ( debug ) { e . print stack trace ( ) ; } } m memory cache . remove ( key ) ; }	delete cache by key.
public void clear disk cache ( ) { if ( null != m file cache ) { try { m file cache . get disk cache ( ) . clear ( ) ; } catch ( io e ) { if ( debug ) { e . print stack trace ( ) ; } } } }	clear the disk cache.
private simple hash set entry < t > [ ] make table ( int new capacity ) { @ suppress warnings ( str ) simple hash set entry < t > [ ] new table = ( simple hash set entry < t > [ ] ) new simple hash set entry [ new capacity ] ; m table = new table ; threshold = ( new capacity > > num ) + ( new capacity > > num ) ;	Allocate a table of the given capacity and set the threshold accordingly.
private simple hash set entry < t > [ ] double capacity ( ) { simple hash set entry < t > [ ] old table = m table ; int old capacity = old table . length ; if ( old capacity == maximum capacity ) { return old table ; } int new capacity = old capacity * num ; simple hash set entry < t > [ ] new table = make table ( new capacity ) ; if ( m size == num ) { return new table ; } for ( int j = num ; j < old capacity ; j ++ ) { simple hash set entry < t > e = old table [ j ] ; if ( e == null ) { continue ; } int high bit = e . m hash & old capacity ; simple hash set entry < t > broken = null ; new table [ j | high bit ] = e ; for ( simple hash set entry < t > n = e . m next ; n != null ; e = n , n = n . m next ) { int next high bit = n . m hash & old capacity ; if ( next high bit != high bit ) { if ( broken == null ) { new table [ j | next high bit ] = n ; } else { broken . m next = n ; } broken = e ; high bit = next high bit ; } } if ( broken != null ) broken . m next = null ; } return new table ; }	Doubles the capacity of the hash table.
public void write ( string key , bitmap bitmap ) { if ( key == null || bitmap == null ) { return ; }	Adds a bitmap to both memory and disk cache.
public string get string ( ) throws io { input stream in = get input stream ( ) ; return in != null ? input stream to string ( in ) : null ; }	Returns the last committed value as a string, or null if no valuehas been committed.
public void commit ( ) throws io { if ( ! m is under edit ) { throw new io ( str ) ; } if ( has errors ) { m disk cache . delete ( m key ) ; } else { file dirty = get temp file ( ) ; if ( dirty . exists ( ) ) { file clean = get cache file ( ) ; dirty . rename to ( clean ) ; m old size = m size ; m size = clean . length ( ) ; m disk cache . commit edit ( this ) ; } else { abort edit ( ) ; } } m is under edit = bool ; }	Commits this edit so it is visible to readers.
@ suppress warnings ( { str } ) public request data add file ( string field name , string upload file , string file name ) { add file ( field name , new file ( upload file ) , file name ) ; return this ; }	add file to be uploaded.
@ override public void clear ( ) { if ( m memory cache != null ) { m memory cache . evict all ( ) ; if ( debug ) { log . d ( log tag , str ) ; } } }	clear the memory cache.
public void try to resume ( ) throws io { if ( m journal file . exists ( ) ) { try { read journal ( ) ; process journal ( ) ; m journal writer = new buffered writer ( new file writer ( m journal file , bool ) , io buffer size ) ; if ( simple disk lru cache . debug ) { c . d ( simple disk lru cache . log tag , str ) ; } } catch ( io journal is corrupt ) { journal is corrupt . print stack trace ( ) ; if ( simple disk lru cache . debug ) { c . d ( simple disk lru cache . log tag , str ) ; } clear ( ) ; } } else { if ( simple disk lru cache . debug ) { c . d ( simple disk lru cache . log tag , str ) ; }	try to resume last status when we got off.
private void process journal ( ) throws io { file utils . delete if exists ( m journal file tmp ) ; for ( iterator < cache entry > i = m lru entries . values ( ) . iterator ( ) ; i . has next ( ) ; ) { cache entry cache entry = i . next ( ) ; if ( ! cache entry . is under edit ( ) ) { m size += cache entry . get size ( ) ; } else { cache entry . delete ( ) ; i . remove ( ) ; } } }	Computes the initial size and collects garbage as a part of opening thecache.
private void rebuild journal ( ) throws io { if ( m journal writer != null ) { m journal writer . close ( ) ; } writer writer = new buffered writer ( new file writer ( m journal file tmp ) , io buffer size ) ; writer . write ( magic ) ; writer . write ( str ) ; writer . write ( version 1 ) ; writer . write ( str ) ; writer . write ( integer . to string ( m app version ) ) ; writer . write ( str ) ; writer . write ( str ) ; for ( cache entry cache entry : m lru entries . values ( ) ) { if ( cache entry . is under edit ( ) ) { writer . write ( s action list [ action dirty ] + str + cache entry . get key ( ) + str + cache entry . get size ( ) + str ) ; } else { writer . write ( s action list [ action clean ] + str + cache entry . get key ( ) + str + cache entry . get size ( ) + str ) ; } } writer . close ( ) ; m journal file tmp . rename to ( m journal file ) ; m journal writer = new buffered writer ( new file writer ( m journal file , bool ) , io buffer size ) ; }	Creates a new journal that omits redundant information.
private synchronized void trim to size ( ) { if ( m size > m capacity ) { if ( simple disk lru cache . debug ) { c . d ( simple disk lru cache . log tag , str , m size ) ; } } while ( m size > m capacity ) { map . entry < string , cache entry > to evict = m lru entries . entry set ( ) . iterator ( ) . next ( ) ; string key = to evict . get key ( ) ; cache entry cache entry = to evict . get value ( ) ; m lru entries . remove ( key ) ; m size -= cache entry . get size ( ) ; add action log ( action pending delete , cache entry ) ; if ( simple disk lru cache . debug ) { c . d ( simple disk lru cache . log tag , str , key , cache entry . get size ( ) , m size ) ; } } }	remove files from list, delete files.
@ override public void load more finish ( boolean empty result , boolean has more ) { m load error = bool ; m list empty = empty result ; m is loading = bool ; m has more = has more ; if ( m load more ui != null ) { m load more ui . on load finish ( this , empty result , has more ) ; } }	page has loaded.
public image reuse info create ( string this size ) { array list < string > list = new array list < string > ( ) ; boolean can be reused = bool ; for ( int i = num ; i < m size list . length ; i ++ ) { string size = m size list [ i ] ; if ( ! can be reused && this size . equals ( size ) ) { can be reused = bool ; continue ; } if ( can be reused && ! this size . equals ( size ) ) { list . add ( size ) ; } } if ( list . size ( ) == num ) { return new image reuse info ( this size , null ) ; } else { string [ ] size list = new string [ list . size ( ) ] ; list . to array ( size list ) ; return new image reuse info ( this size , size list ) ; } }	Find out the size list can be re-sued.
@ override protected t do request sync ( ) { t data = request cache manager . get instance ( ) . request cache sync ( this ) ; if ( data == null ) { data = request manager . get instance ( ) . get request proxy ( this ) . request sync ( this ) ; } return data ; }	Timeout will not be considerate.
private void notify request finish ( result type type , t cache data , boolean out of date ) { if ( debug ) { c . d ( log tag , str , get cache key ( ) , type , out of date ) ; } if ( m has notified ) { return ; } m has notified = bool ; m handler . on cache able request finish ( cache data , type , out of date ) ; }	will only notify once.
public void get response ( string builder sb ) throws io {	Completes the request and receives response from the server.
public void set loading bitmap ( bitmap loading bitmap ) { if ( version . has honeycomb ( ) ) { m loading drawable = new bitmap drawable ( m context . get resources ( ) , loading bitmap ) ; } }	set the placeholder bitmap.
public void set customized right view ( view view ) { relative layout . layout params lp = make layout params ( view ) ; lp . add rule ( center vertical ) ; lp . add rule ( align parent right ) ; get right view container ( ) . add view ( view , lp ) ; }	set customized view to right side.
public boolean download to stream ( image task image task , string url string , output stream output stream , progress update handler progress update handler ) { disable connection reuse if necessary ( ) ; url url connection = null ; buffered output stream out = null ; buffered input stream in = null ; try { final url url = new url ( url string ) ; url connection = ( url ) url . open connection ( ) ; url connection . set read timeout ( num ) ; int len = url connection . get content length ( ) ; int total = num ; in = new buffered input stream ( url connection . get input stream ( ) , io buffer size ) ; out = new buffered output stream ( output stream , io buffer size ) ; int b ; while ( ( b = in . read ( ) ) != - num ) { total ++ ; out . write ( b ) ; if ( progress update handler != null ) { progress update handler . on progress update ( total , len ) ; } } return bool ; } catch ( final io e ) { c . e ( log tag , str + e ) ; } finally { if ( url connection != null ) { url connection . disconnect ( ) ; } try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( final io e ) { } } return bool ; }	Download a bitmap from a URL and write the content to an output stream.
public void add image view ( cube image view image view ) { if ( null == image view ) { return ; } if ( null == m first image view holder ) { m first image view holder = new image view holder ( image view ) ; return ; } image view holder holder = m first image view holder ; for ( ; ; holder = holder . m next ) { if ( holder . contains ( image view ) ) { return ; } if ( holder . m next == null ) { break ; } } image view holder new holder = new image view holder ( image view ) ; new holder . m prev = holder ; holder . m next = new holder ; }	Bind ImageView with ImageTask.
public void remove image view ( cube image view image view ) { if ( null == image view || null == m first image view holder ) { return ; } image view holder holder = m first image view holder ; do { if ( holder . contains ( image view ) ) {	Remove the ImageView from ImageTask.
public void on loading ( image load handler handler ) { m flag = m flag | status loading ; if ( null == handler ) { return ; } if ( m first image view holder == null ) { handler . on loading ( this , null ) ; } else { image view holder holder = m first image view holder ; do { final cube image view image view = holder . get image view ( ) ; if ( null != image view ) { handler . on loading ( this , image view ) ; } } while ( ( holder = holder . m next ) != null ) ; } }	When loading from network.
public void on load task finish ( bitmap drawable drawable , image load handler handler ) { m flag &= ~ status loading ; if ( null == handler ) { return ; } int error code = m flag & error code mask ; if ( error code > num ) { on load error ( error code , handler ) ; return ; } if ( null != m image task statistics ) { m image task statistics . s5 before show ( ) ; } if ( m first image view holder == null ) { handler . on load finish ( this , null , drawable ) ; } else { image view holder holder = m first image view holder ; do { final cube image view image view = holder . get image view ( ) ; if ( null != image view ) { image view . on load finish ( ) ; handler . on load finish ( this , image view , drawable ) ; } } while ( ( holder = holder . m next ) != null ) ; } if ( null != m image task statistics ) { m image task statistics . s6 after show ( image provider . get bitmap size ( drawable ) ) ; image performance statistics . on image loaded ( this , m image task statistics ) ; } }	Will be called when begin load image data from dish or network.
public static string join size info to key ( string key , int w , int h ) { if ( w > num && h != integer . max value && h > num && h != integer . max value ) { return new string builder ( key ) . append ( size sp ) . append ( w ) . append ( size sp ) . append ( h ) . to string ( ) ; } return key ; }	Join the key and the size information.
public static string join size tag to key ( string key , string tag ) { return new string builder ( key ) . append ( size sp ) . append ( tag ) . to string ( ) ; }	Join the tag with the key.
public void open disk cache async ( ) { if ( debug ) { c . d ( log tag , str , m disk cache ) ; } synchronized ( m disk cache lock ) { m disk cache starting = bool ; new file cache task ( task init cache ) . execute now ( ) ; } }	initiate the disk cache.
public void flush disk cache async with delay ( int delay ) { if ( debug ) { c . d ( log tag , str , delay ) ; } if ( m is delay flushing ) { return ; } m is delay flushing = bool ; new file cache task ( task flush cache ) . execute after ( delay ) ; }	flush the data to disk cache.
public disk cache get disk cache ( ) { if ( ! m disk cache ready ) { if ( debug ) { c . d ( log tag , str , m disk cache ) ; } open disk cache async ( ) ; } synchronized ( m disk cache lock ) { while ( m disk cache starting ) { try { if ( debug ) { c . d ( log tag , str , m disk cache ) ; } m disk cache lock . wait ( ) ; } catch ( interrupted exception e ) { } } } return m disk cache ; }	If disk is not read, will prepare it first.
public static void delete directory quickly ( file dir ) throws io { if ( ! dir . exists ( ) ) { return ; } final file to = new file ( dir . get absolute path ( ) + system . current time millis ( ) ) ; dir . rename to ( to ) ; if ( ! dir . exists ( ) ) {	Try to delete directory in a fast way.
@ target api ( build . version codes . froyo ) public static file get external cache dir ( context context ) { if ( version . has froyo ( ) ) { file path = context . get external cache dir ( ) ;	Get the external application cache directory.
@ suppress warnings ( str ) @ target api ( build . version codes . gingerbread ) public static long get usable space ( file path ) { if ( path == null ) { return - num ; } if ( version . has gingerbread ( ) ) { return path . get usable space ( ) ; } else { if ( ! path . exists ( ) ) { return num ; } else { final stat fs stats = new stat fs ( path . get path ( ) ) ; return ( long ) stats . get block size ( ) * ( long ) stats . get available blocks ( ) ; } } }	Check how much usable space is available at a given path.
private static void notify drawable ( drawable drawable , final boolean is displayed ) { if ( drawable instanceof recycling bitmap drawable ) {	Notifies the drawable that it's displayed state has changed.
@ override public void on resume ( ) { super . on resume ( ) ; if ( ! m first resume ) { on back ( ) ; } if ( m first resume ) { m first resume = bool ; } if ( debug ) { show status ( str ) ; } }	Only when Activity resume, not very precise.When activity recover from partly invisible, onBecomesPartiallyInvisible will be triggered.
public t last item ( ) { if ( m data list == null || m data list . size ( ) == num ) { return null ; } return m data list . get ( m data list . size ( ) - num ) ; }	the last item in list.
@ override public void hide ( ) {	Hides the FAB.
public void align sheet with fab ( view fab ) {	Aligns the sheet's position with the FAB.
public void morph from fab ( view fab , long show sheet duration , long show sheet color duration , animation listener listener ) { sheet . set visibility ( view . visible ) ; reveal sheet with fab ( fab , get fab reveal radius ( fab ) , get sheet reveal radius ( ) , show sheet duration , fab color , sheet color , show sheet color duration , listener ) ; }	Shows the sheet by morphing the FAB into the sheet.
public void morph into fab ( view fab , long hide sheet duration , long hide sheet color duration , animation listener listener ) { reveal sheet with fab ( fab , get sheet reveal radius ( ) , get fab reveal radius ( fab ) , hide sheet duration , sheet color , fab color , hide sheet color duration , listener ) ; }	Hides the sheet by morphing the sheet into the FAB.
public void hide ( long duration , final animation listener listener ) { overlay . animate ( ) . alpha ( num ) . set duration ( duration ) . set interpolator ( interpolator ) . set listener ( new animator listener adapter ( ) { @ override public void on animation start ( animator animation ) { if ( listener != null ) { listener . on start ( ) ; } } @ override public void on animation end ( animator animation ) { overlay . set visibility ( view . gone ) ; if ( listener != null ) { listener . on end ( ) ; } } } ) . start ( ) ; }	Hides the overlay.
public void show sheet ( ) { if ( is animating ( ) ) { return ; } is showing = bool ;	Shows the sheet.
private void setup action bar ( ) { set support action bar ( ( toolbar ) find view by id ( r . id . toolbar ) ) ; get support action bar ( ) . set display home as up enabled ( bool ) ; }	Sets up the action bar.
private void setup drawer ( ) { drawer layout = ( drawer layout ) find view by id ( r . id . drawer layout ) ; drawer toggle = new action bar drawer toggle ( this , drawer layout , r . string . opendrawer , r . string . closedrawer ) ; drawer layout . set drawer listener ( drawer toggle ) ; }	Sets up the navigation drawer.
private void setup tabs ( ) {	Sets up the tabs.
private void setup fab ( ) { fab fab = ( fab ) find view by id ( r . id . fab ) ; view sheet view = find view by id ( r . id . fab sheet ) ; view overlay = find view by id ( r . id . overlay ) ; int sheet color = get resources ( ) . get color ( r . color . background card ) ; int fab color = get resources ( ) . get color ( r . color . theme accent ) ;	Sets up the Floating action button.
private void update fab ( int selected page ) { switch ( selected page ) { case main pager adapter . all pos : material sheet fab . show fab ( ) ; break ; case main pager adapter . shared pos : material sheet fab . show fab ( num , - get resources ( ) . get dimension pixel size ( r . dimen . snackbar height ) ) ; break ; case main pager adapter . favorites pos : default : material sheet fab . hide sheet then fab ( ) ; break ; } }	Updates the FAB based on the selected page.
private void update snackbar ( int selected page ) { view snackbar = find view by id ( r . id . snackbar ) ; switch ( selected page ) { case main pager adapter . shared pos : snackbar . set visibility ( view . visible ) ; break ; case main pager adapter . all pos : case main pager adapter . favorites pos : default : snackbar . set visibility ( view . gone ) ; break ; } }	Updates the snackbar based on the selected page.
public void morph into sheet ( int end x , int end y , side side , int arc degrees , float scale factor , long duration , animation listener listener ) { morph ( end x , end y , side , arc degrees , scale factor , duration , listener ) ; }	Animates the FAB as if the FAB is morphing into a sheet.
public void morph from sheet ( int end x , int end y , side side , int arc degrees , float scale factor , long duration , animation listener listener ) { fab . set visibility ( view . visible ) ; morph ( end x , end y , side , arc degrees , scale factor , duration , listener ) ; }	Animates the FAB as if a sheet is being morphed into a FAB.
private void hide suggestions if necessary ( final @ non null query token current query , final @ non null token source source ) { string query ts = current query . get token string ( ) ; string current ts = source . get current token string ( ) ; if ( ! is waiting for results ( current query ) && query ts != null && query ts . equals ( current ts ) ) { m suggestions visibility manager . display suggestions ( bool ) ; } }	Hides the suggestions if there are no more incoming queries.
public boolean contains explicit char ( final @ non null char sequence input ) { if ( ! text utils . is empty ( input ) ) { for ( int i = num ; i < input . length ( ) ; i ++ ) { char c = input . char at ( i ) ; if ( is explicit char ( c ) ) { return bool ; } } } return bool ; }	Returns true if the input string contains an explicit character.
public boolean contains word breaking char ( final @ non null char sequence input ) { if ( ! text utils . is empty ( input ) ) { for ( int i = num ; i < input . length ( ) ; i ++ ) { char c = input . char at ( i ) ; if ( is word breaking char ( c ) ) { return bool ; } } } return bool ; }	Returns true if the input string contains a word-breaking character.
public boolean only letters or digits ( final @ non null char sequence input , final int num chars to check , final int start ) {	Given a string and starting index, return true if the first "numCharsToCheck" characters atthe starting index are either a letter or a digit.
protected int get search start index ( final @ non null spanned text , int cursor ) { if ( cursor < num || cursor > text . length ( ) ) { cursor = num ; }	Returns the index of the end of the last span before the cursor orthe start of the current line if there are no spans before the cursor.
protected int get search end index ( final @ non null spanned text , int cursor ) { if ( cursor < num || cursor > text . length ( ) ) { cursor = num ; }	Returns the index of the beginning of the first span after the cursor orlength of the text if there are no spans after the cursor.
public void display text counter ( boolean display ) { if ( display ) { m text counter view . set visibility ( text view . visible ) ; } else { m text counter view . set visibility ( text view . gone ) ; } }	Show or hide the text counter view.
private void disable spelling suggestions ( boolean disable ) {	Disables spelling suggestions from the user's keyboard.This is necessary because some keyboards will replace the input text withspelling suggestions automatically, which changes the suggestion results.This results in a confusing user experience.
private void update editor text count ( ) { if ( m mentions edit text != null && m text counter view != null ) { int text count = m mentions edit text . get mentions text ( ) . length ( ) ; m text counter view . set text ( string . value of ( text count ) ) ; if ( m text count limit > num && text count > m text count limit ) { m text counter view . set text color ( m beyond count limit text color ) ; } else { m text counter view . set text color ( m within count limit text color ) ; } } }	Updates the TextView counting the number of characters in the editor.
public void set mention span factory ( @ non null final mentions edit text . mention span factory factory ) { if ( m mentions edit text != null ) { m mentions edit text . set mention span factory ( factory ) ; } }	Sets the factory used to create MentionSpans within this class.
private void copy ( @ int range ( from = num ) int start , @ int range ( from = num ) int end ) { mentions editable text = get mentions text ( ) ; spannable string builder copied text = ( spannable string builder ) text . sub sequence ( start , end ) ; mention span [ ] spans = text . get spans ( start , end , mention span . class ) ; intent intent = null ; if ( spans . length > num ) {	Copy the text between start and end in clipboard.If no span is present, text is saved as plain text but if span is presentsave it in Clipboard using intent.
private void paste ( @ int range ( from = num ) int min , @ int range ( from = num ) int max ) { if ( android . os . build . version . sdk int < android . os . build . version codes . honeycomb ) { android . text . clipboard manager clipboard = ( android . text . clipboard manager ) get context ( ) . get system service ( context . clipboard service ) ; mentions editable text = get mentions text ( ) ; text . replace ( text . length ( ) , text . length ( ) , clipboard . get text ( ) ) ; } else { paste honeycomb impl ( min , max ) ; } }	Paste clipboard content between min and max positions.
@ target api ( build . version codes . honeycomb ) private void paste honeycomb impl ( @ int range ( from = num ) int min , @ int range ( from = num ) int max ) { clipboard manager clipboard = ( clipboard manager ) get context ( ) . get system service ( context . clipboard service ) ; clip data clip = clipboard . get primary clip ( ) ; if ( clip != null ) { for ( int i = num ; i < clip . get item count ( ) ; i ++ ) { clip data . item item = clip . get item at ( i ) ; string selected text = item . coerce to text ( get context ( ) ) . to string ( ) ; mentions editable text = get mentions text ( ) ; mention span [ ] spans = text . get spans ( min , max , mention span . class ) ; for ( mention span span : spans ) { if ( text . get span end ( span ) == min ) {	Paste clipboard content between min and max positions.
private void update selection if required ( final int sel start , final int sel end ) { mentions editable text = get mentions text ( ) ; mention span start mention span = text . get mention span at offset ( sel start ) ; mention span end mention span = text . get mention span at offset ( sel end ) ; boolean sel changed = bool ; int start = sel start ; int end = sel end ; if ( text . get span start ( start mention span ) < sel start && sel start < text . get span end ( start mention span ) ) { start = text . get span start ( start mention span ) ; sel changed = bool ; } if ( text . get span start ( end mention span ) < sel end && sel end < text . get span end ( end mention span ) ) { end = text . get span end ( end mention span ) ; sel changed = bool ; } if ( sel changed ) { set selection ( start , end ) ; } }	Don't allow user to set starting position or ending position of selection within the mention.
private boolean on cursor changed ( final int index ) { editable text = get text ( ) ; if ( text == null ) { return bool ; } mention span [ ] all spans = text . get spans ( num , text . length ( ) , mention span . class ) ; for ( mention span span : all spans ) {	Method to handle the cursor changing positions.
public void deselect all spans ( ) { m block completion = bool ; editable text = get text ( ) ; mention span [ ] spans = text . get spans ( num , text . length ( ) , mention span . class ) ; for ( mention span span : spans ) { if ( span . is selected ( ) ) { span . set selected ( bool ) ; update span ( span ) ; } } m block completion = bool ; }	Deselects any spans in the editor that are currently selected.
public static string escape for xml ( string source ) { args . null not permitted ( source , str ) ; string builder sb = new string builder ( ) ; for ( int i = num ; i < source . length ( ) ; i ++ ) { char c = source . char at ( i ) ; switch ( c ) { case str : { sb . append ( str ) ; break ; } case str : { sb . append ( str ) ; break ; } case str : { string next = source . substring ( i , math . min ( i + num , source . length ( ) ) ) ; if ( next . starts with ( str ) || next . starts with ( str ) || next . starts with ( str ) || next . starts with ( str ) || next . starts with ( str ) ) { sb . append ( c ) ; } else { sb . append ( str ) ; } break ; } case str : { sb . append ( str ) ; break ; } case str : { sb . append ( str ) ; break ; } default : sb . append ( c ) ; } } return sb . to string ( ) ; }	Returns a new string where any special characters in the source stringhave been encoded.
public static void write to html ( file file , string title , string svg element ) throws io { buffered writer writer = null ; try { file output stream fos = new file output stream ( file ) ; output stream writer osw = new output stream writer ( fos , str ) ; writer = new buffered writer ( osw ) ; writer . write ( str ) ; writer . write ( str ) ; writer . write ( str ) ; writer . write ( str + title + str ) ; writer . write ( str ) ; writer . write ( str ) ; writer . write ( str ) ; writer . write ( svg element + str ) ; writer . write ( str ) ; writer . write ( str ) ; writer . flush ( ) ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch ( io ex ) { logger . get logger ( svg . class . get name ( ) ) . log ( level . severe , null , ex ) ; } } }	Writes an HTML file containing an SVG element.
@ override public buffered image create compatible image ( int width , int height ) { color model model = get color model ( ) ; writable raster raster = model . create compatible writable raster ( width , height ) ; return new buffered image ( model , raster , model . is alpha premultiplied ( ) , null ) ; }	Creates a compatible image.
@ override public volatile image create compatible volatile image ( int width , int height , image capabilities caps , int transparency ) throws awt { if ( img == null ) { img = new buffered image ( num , num , buffered image . type int argb ) ; gc = img . create graphics ( ) . get device configuration ( ) ; } return gc . create compatible volatile image ( width , height , caps , transparency ) ; }	Returns a volatile image.
public string value str ( ) { return new string builder ( ) . append ( this . min x ) . append ( str ) . append ( this . min y ) . append ( str ) . append ( this . width ) . append ( str ) . append ( this . height ) . to string ( ) ; }	Returns a string containing the view box coordinates and dimensions.
@ override public string map font ( string family ) { args . null not permitted ( family , str ) ; string alternate = this . alternates . get ( family ) ; if ( alternate != null ) { return alternate ; } return family ; }	Maps the specified font family name to an alternative, or else returnsthe same family name.
public void set shape rendering ( string value ) { if ( ! value . equals ( str ) && ! value . equals ( str ) && ! value . equals ( str ) && ! value . equals ( str ) ) { throw new illegal argument exception ( str + value ) ; } this . shape rendering = value ; }	Sets the value of the 'shape-rendering' property that will be written tothe SVG element.
public void set text rendering ( string value ) { if ( ! value . equals ( str ) && ! value . equals ( str ) && ! value . equals ( str ) && ! value . equals ( str ) ) { throw new illegal argument exception ( str + value ) ; } this . text rendering = value ; }	Sets the value of the 'text-rendering' property that will be written tothe SVG element.
private void append optional element id ( string builder sb ) { string element id = ( string ) this . hints . get ( svg . key element id ) ; if ( element id != null ) { this . hints . put ( svg . key element id , null ) ;	A utility method that appends an optional element id if one isspecified via the rendering hints.
private string rgb color str ( color c ) { string builder b = new string builder ( str ) ; b . append ( c . get red ( ) ) . append ( str ) . append ( c . get green ( ) ) . append ( str ) . append ( c . get blue ( ) ) . append ( str ) ; return b . to string ( ) ; }	Returns the SVG RGB color string for the specified color.
private string rgba color str ( color c ) { string builder b = new string builder ( str ) ; double alpha percent = c . get alpha ( ) / num ; b . append ( c . get red ( ) ) . append ( str ) . append ( c . get green ( ) ) . append ( str ) . append ( c . get blue ( ) ) ; b . append ( str ) . append ( transform dp ( alpha percent ) ) ; b . append ( str ) ; return b . to string ( ) ; }	Returns a string representing the specified color in RGBA format.
private string stroke style ( ) { double stroke width = num ; string stroke cap = default stroke cap ; string stroke join = default stroke join ; float miter limit = default miter limit ; float [ ] dash array = new float [ num ] ; if ( this . stroke instanceof basic stroke ) { basic stroke bs = ( basic stroke ) this . stroke ; stroke width = bs . get line width ( ) > num ? bs . get line width ( ) : this . zero stroke width ; switch ( bs . get end cap ( ) ) { case basic stroke . cap round : stroke cap = str ; break ; case basic stroke . cap square : stroke cap = str ; break ; case basic stroke . cap butt : default :	Returns a stroke style string based on the current stroke andalpha settings.
private string get svg ( ) { string builder b = new string builder ( ) ; b . append ( str ) . append ( svg color str ( ) ) . append ( str ) ; b . append ( str ) . append ( get color alpha ( ) * get alpha ( ) ) ; return b . to string ( ) ; }	Returns a fill style string based on the current paint andalpha settings.
private string get svg ( ) { string builder b = new string builder ( ) ; b . append ( str ) . append ( svg color str ( ) ) . append ( str ) ; b . append ( str ) . append ( get color alpha ( ) * get alpha ( ) ) . append ( str ) ; string font family = this . font mapper . map font ( this . font . get family ( ) ) ; b . append ( str ) . append ( font family ) . append ( str ) ; b . append ( str ) . append ( this . font . get size ( ) ) . append ( this . font size units ) . append ( str ) ; if ( this . font . is bold ( ) ) { b . append ( str ) ; } if ( this . font . is italic ( ) ) { b . append ( str ) ; } return b . to string ( ) ; }	Returns a string containing font style info.
@ override public font metrics get font metrics ( font f ) { if ( this . fm image == null ) { this . fm image = new buffered image ( num , num , buffered image . type int rgb ) ; this . fm image g2 d = this . fm image . create graphics ( ) ; this . fm image g2 d . set rendering hint ( rendering hints . key fractionalmetrics , rendering hints . value fractionalmetrics on ) ; } return this . fm image g2 d . get font metrics ( f ) ; }	Returns the font metrics for the specified font.
@ override public void scale ( double sx , double sy ) { affine transform t = get transform ( ) ; t . scale ( sx , sy ) ; set transform ( t ) ; }	Applies a scale transformation.
@ override public void transform ( affine transform t ) { affine transform tx = get transform ( ) ; tx . concatenate ( t ) ; set transform ( tx ) ; }	Applies this transform to the existing transform by concatenating it.
@ override public void set transform ( affine transform t ) { if ( t == null ) { this . transform = new affine transform ( ) ; } else { this . transform = new affine transform ( t ) ; } this . clip ref = null ; }	Sets the transform.
@ override public void set clip ( shape shape ) {	Sets the user clipping region.
private string register clip ( shape clip ) { if ( clip == null ) { this . clip ref = null ; return null ; }	Registers the clip so that we can later write out all the clipdefinitions in the DEFS element.
@ override public void clip ( shape s ) { if ( s instanceof d ) { s = s . get bounds2 d ( ) ; } if ( this . clip == null ) { set clip ( s ) ; return ; } shape ts = this . transform . create transformed shape ( s ) ; if ( ! ts . intersects ( this . clip . get bounds2 d ( ) ) ) { set clip ( new d . double ( ) ) ; } else { area a1 = new area ( ts ) ; area a2 = new area ( this . clip ) ; a1 . intersect ( a2 ) ; this . clip = new d . double ( a1 ) ; } this . clip ref = null ; }	Clips to the intersection of the current clipping region and thespecified shape.According to the Oracle API specification, this method will accept a{.
@ override public void clip rect ( int x , int y , int width , int height ) { set rect ( x , y , width , height ) ; clip ( this . rect ) ; }	Clips to the intersection of the current clipping region and thespecified rectangle.
@ override public void set clip ( int x , int y , int width , int height ) { set rect ( x , y , width , height ) ; set clip ( this . rect ) ; }	Sets the user clipping region to the specified rectangle.
private byte [ ] get png ( image img ) { rendered image ri ; if ( img instanceof rendered image ) { ri = ( rendered image ) img ; } else { buffered image bi = new buffered image ( img . get width ( null ) , img . get height ( null ) , buffered image . type int argb ) ; d g2 = bi . create graphics ( ) ; g2 . draw image ( img , num , num , null ) ; ri = bi ; } byte array output stream baos = new byte array output stream ( ) ; try { io . write ( ri , str , baos ) ; } catch ( io ex ) { logger . get logger ( svg d . class . get name ( ) ) . log ( level . severe , str , ex ) ; } return baos . to byte array ( ) ; }	Returns the bytes representing a PNG format image.
@ override public void draw rendered image ( rendered image img , affine transform xform ) { buffered image bi = graphics utils . convert rendered image ( img ) ; draw image ( bi , xform , null ) ; }	Draws the rendered image.
@ override public void draw renderable image ( renderable image img , affine transform xform ) { rendered image ri = img . create default rendering ( ) ; draw rendered image ( ri , xform ) ; }	Draws the renderable image.
private string get clip path ref ( ) { if ( this . clip == null ) { return str ; } if ( this . clip ref == null ) { this . clip ref = register clip ( get clip ( ) ) ; } string builder b = new string builder ( ) ; b . append ( str ) . append ( this . clip ref ) . append ( str ) ; return b . to string ( ) ; }	Returns a clip path reference for the current user clip.
public static list < string > get parts ( string string , final string ... regexp list ) { final list < string > parts = new array list < > ( ) ; for ( final string regexp : regexp list ) { final pattern pattern = pattern . compile ( regexp ) ; final matcher matcher = pattern . matcher ( string ) ; final boolean found = matcher . find ( ) ; if ( ! found ) { return new array list < > ( ) ; } final string part = matcher . group ( num ) . trim ( ) ; parts . add ( part ) ; string = string . replace first ( quote ( matcher . group ( ) ) , str ) . trim ( ) ; } return parts ; }	Match one regexp at a time.
protected void record level ( final string stat key , final long level ) { final string long key = get actual stat key ( stat key ) ; stats collector . record level ( long key , level ) ; }	Prefixes the stats key with the stat key prefix, and then calls statsCollector.recordLevel.
protected void record timing ( string stat key , long time span ) { final string long key = get actual stat key ( stat key ) ; stats collector . record timing ( long key , time span ) ; }	Prefixes the stats key with the stat key prefix, and then calls statsCollector.recordTiming.
private void track timeouts ( ) { new array list < > ( http request holder list ) . for each ( http request holder -> { if ( http request holder . request . is handled ( ) ) { http request holder list . remove ( http request holder ) ; return ; } final long duration = time - http request holder . start time ; if ( duration > time out interval ms ) { http request holder . request . handled ( ) ; http request holder . request . get receiver ( ) . timeout with message ( string . format ( str , http request holder . request . address ( ) , http request holder . request . get remote address ( ) , http request holder . start time ) ) ; http request holder list . remove ( http request holder ) ;	Tracks timeouts periodically if timeout tracking is enabled.
private void check client ( ) { try { if ( error count . get ( ) > num ) { error count . set ( num ) ; if ( backend service http client == null || backend service http client . is closed ( ) ) { if ( backend service http client != null ) { try { backend service http client . stop ( ) ; } catch ( exception ex ) { logger . debug ( str , ex ) ; } } backend service http client = http client builder . build and start ( ) ; last http client start = time ; } } if ( ping builder . is present ( ) ) { if ( backend service http client != null ) { ping builder . get ( ) . set binary receiver ( ( code , content type , body ) -> { if ( code >= num && code < num ) { ping count . increment and get ( ) ; } else { error count . increment and get ( ) ; } } ) . set error handler ( e -> { logger . error ( str , e ) ; error count . increment and get ( ) ; } ) ; final http request http request = ping builder . get ( ) . build ( ) ; backend service http client . send http request ( http request ) ; } } } catch ( exception ex ) { error handler . accept ( ex ) ; logger . error ( str ) ; } }	Checks client health periodically to see if we are connected.
@ override public void handle request ( final http request client request ) { if ( track time outs ) { http request holder list . add ( new http request holder ( client request , time ) ) ; } if ( http client request predicate . test ( client request ) ) { create back end request populate and forward ( client request ) ; } }	Request coming from the client side.
private void create back end request populate and forward ( final http request client request ) { try { if ( backend service http client == null ) { handle http client errors for backend ( client request , new http client closed connection exception ( str ) ) ; long time since last start = time - last http client start ; if ( time since last start > num ) { check client ( ) ; } return ; } final http request builder http request builder = http request builder . http request builder ( ) . copy request ( client request ) . set binary receiver ( new http binary receiver ( ) { @ override public void response ( final int code , final string content type , final byte [ ] body , final multi map < string , string > headers ) { handle backend client responses ( client request , code , content type , body , headers ) ; } @ override public void response ( int code , string content type , byte [ ] body ) { response ( code , content type , body , multi map . empty ( ) ) ; } } ) . set error handler ( e -> handle http client errors for backend ( client request , e ) ) ; before send . accept ( http request builder ) ; backend service http client . send http request ( http request builder . build ( ) ) ; } catch ( http client closed connection exception http client closed connection exception ) { error count . increment and get ( ) ; error handler . accept ( http client closed connection exception ) ; logger . error ( str , http client closed connection exception ) ; handle http client errors for backend ( client request , http client closed connection exception ) ; backend service http client = null ; long time since last start = time - last http client start ; if ( time since last start > num ) { check client ( ) ; } } catch ( exception ex ) { error count . increment and get ( ) ; error handler . accept ( ex ) ; logger . error ( str , ex ) ; handle http client errors for backend ( client request , ex ) ; long time since last start = time - last http client start ; if ( time since last start > num ) { check client ( ) ; } } }	Creates a backend request from the client request and then forwards it.
private void handle http client errors for backend ( final http request client request , final exception e ) { error handler . accept ( e ) ; error count . increment and get ( ) ; final string error message = string . format ( str , client request . address ( ) ) ; logger . error ( error message , e ) ; if ( ! client request . is handled ( ) ) { client request . handled ( ) ; client request . get receiver ( ) . error ( string . format ( str , error message ) ) ; } }	Handle errors.
private void handle backend client responses ( final http request client request , final int code , final string content type , final byte [ ] body , final multi map < string , string > headers ) { if ( ! client request . is handled ( ) ) { client request . handled ( ) ; client request . get receiver ( ) . response ( code , content type , body , headers ) ; } }	Handle a response from the backend service.
@ queue callback ( { queue callback type . empty , queue callback type . idle , queue callback type . limit } ) public void process ( ) { reactor . process ( ) ; time = timer . time ( ) ; }	Manage periodic jobs.
public static service discovery create lokate service discovery ( final list < uri > configs ) { return service discovery builder ( ) . set service discovery provider ( new lokate service discovery provider ( discovery service . create ( configs ) ) ) . build ( ) ; }	Create service discovery that can talk via Lokate.
private void do call ( method call < object > method call ) { if ( debug ) { logger . debug ( service bundle impl . class . get name ( ) , str , method call . name ( ) , method call . address ( ) , str , method call ) ; } try { if ( method call . has callback ( ) ) { callback manager . register callbacks ( method call ) ; } boolean [ ] continue flag = new boolean [ num ] ; method call = handle before method call ( method call , continue flag ) ; if ( ! continue flag [ num ] ) { if ( debug ) { logger . debug ( service bundle impl . class . get name ( ) + str + str ) ; } } else { final consumer < method call < object > > method dispatcher = get method dispatcher ( method call ) ; method dispatcher . accept ( method call ) ; } } catch ( exception ex ) { response < object > response = new response impl < > ( method call , ex ) ; this . response queue . send queue ( ) . send and flush ( response ) ; } }	Handles calling a method.
@ override @ suppress warnings ( str ) public void call ( final method call < object > method call ) { if ( debug ) { logger . debug ( service bundle impl . class . get name ( ) + str + method call . name ( ) + str + str + method call . address ( ) + str + method call ) ; } method send queue . send ( method call ) ; }	Call the method.
@ override public < t > t create local proxy ( final class < t > service interface , final string my service ) { final consumer < method call < object > > call consumer = this . service mapping . get ( my service ) ; if ( call consumer == null ) { logger . error ( str + my service ) ; } return factory . create local proxy ( service interface , my service , this , before method sent ) ; }	Creates a proxy interface to a particular client.
private method call < object > before method call ( method call < object > method call , boolean [ ] continue call ) { if ( this . before method call . before ( method call ) ) { continue call [ num ] = bool ; method call = transform before method call ( method call ) ; continue call [ num ] = this . before method call after transform . before ( method call ) ; return method call ; } else { continue call [ num ] = bool ; } return method call ; }	Handles before call operation.
private method call < object > transform before method call ( method call < object > method call ) { if ( arg transformer == null || arg transformer == service constants . no op arg transform ) { return method call ; } object arg = this . arg transformer . transform ( method call ) ; return method call builder . transformed ( method call , arg ) ; }	Handles the before argument transformer.
@ suppress warnings ( str ) public void stop ( ) { if ( debug ) { logger . debug ( service bundle impl . class . get name ( ) , str ) ; } method queue . stop ( ) ; for ( stoppable service : services to stop ) { service . stop ( ) ; } try { response queue . stop ( ) ; } catch ( exception ex ) { logger . debug ( str , ex ) ; } try { web response queue . stop ( ) ; } catch ( exception ex ) { logger . debug ( str , ex ) ; } if ( system manager != null ) system manager . service shut down ( ) ; }	Stop the client bundle.
public service bundle start up call queue ( ) { method queue . start listener ( new receive queue listener < method call < object > > ( ) { long time ; long last time auto flush ; @ override public void receive ( method call < object > item ) { do call ( item ) ;	Start the client bundle.
public string find service name ( final string dns service name ) { string service name = dns service name to service name . get ( dns service name ) ; service name = service name == null ? dns service name : service name ; if ( debug ) logger . debug ( str , dns service name , service name ) ; return service name ; }	Looks up a service name based on its dns service name.
public void load service endpoints by service name ( final callback < list < endpoint definition > > callback , final string service name ) { load service endpoints by dns ( callback , find dns service name ( service name ) ) ; }	Load the service nodes based on the internal service name.DB, Ingester, RadarAggregator, etc.
private endpoint definition convert srv record to endpoint definition ( final srv record srv record ) { return new endpoint definition ( find service name ( srv record . service ( ) ) , srv record . target ( ) , srv record . port ( ) ) ; }	Convert a single srvRecord into an EndpointDefinition.
protected cors check request type ( final http request holder request ) { cors request type = cors . invalid cors ; if ( request == null ) { throw new illegal argument exception ( cors support . cors null request ) ; } string origin header = request . get headers ( ) . get ( request header origin ) ;	Determines the request type.
private void handle http request ( final http server request request ) { if ( debug ) { setup metrics ( request ) ; logger . debug ( str , request . method ( ) , request . uri ( ) ) ; } switch ( request . method ( ) . to string ( ) ) { case str : case str : case str : case str : case str : case str : handle request with body ( request ) ; break ; case str : case str : handle request with no body ( request ) ; break ; default : throw new illegal state exception ( str + request . method ( ) ) ; } }	Handle a vertx request by converting it into a QBit request.
private boolean do handle method call ( method call < object > method call , final service method handler service method handler ) { if ( debug ) { logger . debug ( str + method call ) ; } if ( callback manager != null ) { if ( method call . has callback ( ) && service method handler . could have callback ( method call . name ( ) ) ) { callback manager . register callbacks ( method call ) ; } }	This method is where all of the action is.
public static consul consul ( final string host , final int port ) { try { return new consul ( new url ( str , host , port , str ) . to string ( ) ) ; } catch ( url e ) { throw new consul exception ( str , e ) ; } }	Creates a new client given a host and a port.
@ override public dns client get ( ) { final uri uri = address list . get ( index ) ; try { if ( debug ) logger . debug ( str , uri . get port ( ) , uri . get host ( ) ) ; return vertx . create dns client ( uri . get port ( ) , uri . get host ( ) ) ; } catch ( exception ex ) { logger . error ( str , ex ) ; logger . error ( str , uri . get port ( ) , uri . get host ( ) ) ; return get if errors ( ) ; } }	Get a DNS client.
@ override public receive queue < t > receive queue ( ) { if ( debug ) logger . debug ( str , name ) ; return new basic receive queue < > ( queue , poll time wait , poll time time unit , limit ) ; }	This returns a new instance of ReceiveQueue every time you call itso call it only once per thread.
@ override public send queue < t > send queue ( ) { if ( debug ) logger . debug ( str , name ) ; return send queue supplier . get ( ) ; }	This returns a new instance of SendQueue every time you call itso call it only once per thread.
public static < t > callback < t > convert promise ( final promise < t > promise ) { return convert promise to callback ( promise , callback builder . callback builder ( ) ) ; }	Converts a Reakt promise into a QBit callback.
public static < t > callback < t > convert promise ( final reactor reactor , final promise < t > promise ) { return convert promise to callback ( promise , reactor . callback builder ( ) ) ; }	Converts a Reakt promise into a QBit callback.Reactor is used to manage timeouts and ensure callback happens on same thread as caller.
public < t > callback < t > callback ( final consumer < promise < t > > promise consumer ) { promise < t > promise = promises . promise ( ) ; promise consumer . accept ( promise ) ; return reakt . convert promise ( promise ) ; }	Creates a QBit callback based on promise created.
private void load healthy services ( ) { try { string service name = done queue . poll ( ) ; while ( service name != null ) { final string service name to fetch = service name ; if ( ! service names being loaded . contains ( service name to fetch ) ) { service names being loaded . add ( service name to fetch ) ; executor service . submit ( ( ) -> { do load health services ( service name to fetch ) ; } ) ; } service name = done queue . poll ( ) ; } } catch ( exception ex ) { ex . print stack trace ( ) ; } }	Iterate through the health service queue and load the services.
private void do fail over health services load ( final string service name to fetch , exception ex ) { if ( backup provider != null ) { if ( debug ) logger . debug ( str + str + str + service name to fetch , ex ) ; final list < endpoint definition > healthy services = backup provider . load services ( service name to fetch ) ; populate service map ( service name to fetch , healthy services ) ; service names being loaded . remove ( service name to fetch ) ; } else { logger . error ( str + str + str + service name to fetch , ex ) ; } sys . sleep ( num ) ;	If the primary load failed, we could have a backup provider registered.
@ override public dns client get ( ) { if ( debug ) logger . debug ( str , host , port ) ; return vertx . create dns client ( port , host ) ; }	Supply an instance of DnsClient.
public void add one shot after task ( final long fire after , final time unit time unit , final runnable task ) { fire once after tasks . add ( new fire once task ( task , time unit , fire after ) ) ; }	Add a task that gets executed once.
public void process ( ) { drain queues ( ) ; current time = timer . now ( ) ; monitor call backs ( ) ; monitor callback coordinators ( ) ; collaborating services . for each ( service proxy utils :: flush service proxy ) ; process repeating tasks ( ) ; process fire once tasks ( ) ; }	Process items in reactor.
public < t > async future callback < t > remove future ( async future callback < t > async future callback ) { this . remove future queue . offer ( async future callback ) ; return async future callback ; }	Remove a callback from the list of callbacks that we are managing.
private void monitor call backs ( ) { if ( future list . size ( ) > num ) { final list < async future callback < ? > > remove list = new array list < > ( future list . size ( ) ) ; long now = current time ; for ( async future callback < ? > callback : future list ) { if ( callback . is done ( ) ) { callback . run ( ) ; remove list . add ( callback ) ; } else { if ( callback . check time out ( now ) ) { remove list . add ( callback ) ; } } } future list . remove all ( remove list ) ; } }	Monitors timeouts. If the callback timed-out trigger it, and then remove callback from the list.
private void monitor callback coordinators ( ) { if ( coordinator list . size ( ) > num ) { final list < callback coordinator > remove list = new array list < > ( coordinator list . size ( ) ) ; for ( callback coordinator callable : coordinator list ) { if ( callable . check complete ( ) ) { callable . finished ( ) ; remove list . add ( callable ) ; } else if ( callable . timed out ( current time ) ) { remove list . add ( callable ) ; } } coordinator list . remove all ( remove list ) ; } }	Monitors Callback Coordinators.Trigger timeouts if needed and remove coordinators from list that timed out.
public < t > callback < t > wrap callback with timeout ( final string operation description , final callback < t > callback , final logger logger , final time unit time unit , final long timeout duration ) { return callback builder ( ) . set callback ( new callback < t > ( ) { @ override public void accept ( t t ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str , operation description , t ) ; } callback . resolve ( t ) ; } } ) . set on error ( error -> { logger . error ( string . format ( str , operation description ) , error ) ; callback . on error ( error ) ; } ) . set on timeout ( ( ) -> { logger . error ( str , operation description ) ; callback . on timeout ( ) ; } ) . set timeout time unit ( time unit ) . set timeout duration ( timeout duration ) . build ( ) ; }	Used for quickly delegating one callback to another.This allows one liners so you don't have to create a builder for this common case.
public proxy service build ( ) { return new proxy service impl ( get reactor ( ) , get timer ( ) , get http client builder ( ) , get before send ( ) , get error handler ( ) , get http client request predicate ( ) , get check client duration ( ) , ping builder == null ? optional . < http request builder > empty ( ) : optional . of ( ping builder ) , is track time outs ( ) , get time out interval ( ) ) ; }	Build the impl.
public proxy service build proxy ( ) { return get service builder ( ) . set service object ( build ( ) ) . build and start ( ) . create proxy with auto flush ( proxy service . class , duration . hundred millis ) ; }	Builds a proxy queue service to the impl.
public void handle web socket call ( final web socket message web socket message ) { if ( debug ) logger . debug ( str + web socket message ) ; web socket delegate web socket delegate = web socket delegate map . get ( web socket message . get remote address ( ) ) ; if ( web socket delegate == null ) { web socket delegate = new web socket delegate ( protocol batch size , web socket message ) ; web socket delegate map . put ( web socket message . get remote address ( ) , web socket delegate ) ; } protocol parser thread pool . execute ( ( ) -> { try { final list < method call < object > > method call list to be parsed from body = create method call list to be parsed from body ( web socket message . get remote address ( ) , web socket message . get message ( ) , web socket message ) ; if ( method call list to be parsed from body . size ( ) > num ) { method call send queue . send batch ( method call list to be parsed from body ) ; } } catch ( exception ex ) { logger . error ( str , ex ) ; } } ) ; }	All WebSocket calls come through here.
public void add ( final event listener < t > event listener ) { if ( event listener . subscriber ( ) ) { if ( debug ) logger . debug ( str , name , event listener ) ; listeners . add ( event listener ) ; stats . record level ( event bus name + str + name , listeners . size ( ) ) ; } else { if ( debug ) logger . debug ( str , name , event listener ) ; consumer = event listener ; } }	Add an event listener to the channelThere can only be one consumer and many listeners.
public static service discovery create dns service discovery ( ) { final service discovery builder service discovery builder = service discovery builder . service discovery builder ( ) ; final vertx vertx = vertx . vertx ( ) ; final dns support builder dns support builder = dns support builder . dns support builder ( vertx ) . set dns client supplier ( new dns client from resolve conf supplier ( vertx ) ) ; final dns service discovery provider builder dns service discovery provider builder = dns service discovery provider builder . dns service discovery provider builder ( ) . set dns support ( dns support builder . build ( ) ) ; return service discovery builder . set service discovery provider ( dns service discovery provider builder . build ( ) ) . build ( ) ; }	Create service discovery that can talk DNS.
@ override public < t > t from json ( string json , class < t > cls ) { return parser . get ( ) . parse ( cls , json ) ; }	Convert from json string using Class as a suggestion for how to do the parse.
@ override public < t > list < t > from json array ( string json , class < t > component class ) { return parser . get ( ) . parse list ( component class , json ) ; }	Converts from a json string using componentClass as a guide to a List.
@ override public string to json ( object object ) { return serializer . get ( ) . serialize ( object ) . to string ( ) ; }	Converts from Object into JSON string.
@ override public < k , v > map < k , v > from json map ( string json , class < k > component class key , class < v > component class value ) { map map = ( map ) parser . get ( ) . parse ( json ) ; final mapper mapper = this . mapper . get ( ) ; return extract map ( component class key , component class value , map , mapper ) ; }	Converts from a json string using componentClassKey and componentClassValue as a guide to a Map.
private < v > v convert to map ( value map value map ) { final map < string , object > map = new linked hash map < > ( value map . size ( ) ) ; value map . entry set ( ) . for each ( new consumer < map . entry < string , object > > ( ) { @ override public void accept ( map . entry < string , object > entry ) { object value = entry . get value ( ) ; if ( value instanceof value container ) { value container value container = ( ( value container ) entry . get value ( ) ) ; value = value container . to value ( ) ; } if ( value instanceof value ) { map . put ( entry . get key ( ) , ( ( value ) value ) . to value ( ) ) ; } else if ( value instanceof value map ) { map . put ( entry . get key ( ) , convert to map ( ( ( value map ) value ) ) ) ; } else if ( value instanceof list ) { map . put ( entry . get key ( ) , convert list ( value , mapper . get ( ) ) ) ; } else { map . put ( entry . get key ( ) , value ) ; } } } ) ; return ( v ) map ; }	Helper method.Converts a value map into a regular map of Java basic types.
public boolean could have callback ( final string name ) { final boolean has = has handler map . get ( name ) ; if ( has == null ) { return bool ; } return has ; }	False is unknown, true is no callbacks.
public < t > callback builder set callback ( final class < t > return type , final callback < t > callback ) { return with callback ( return type , callback ) ; }	Builder method to add a callback handler.
public < t > callback builder wrap ( final callback < t > callback ) { this . with error handler ( callback :: on error ) ; this . with timeout handler ( callback :: on timeout ) ; this . with callback ( callback ) ; return this ; }	Builder method to wrap and delegate, timeout and error handling and callback itself.
public < t > callback builder with list callback ( final class < t > component class , final callback < list < t > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes a list.
public < t > callback builder with set callback ( final class < t > component class , final callback < set < t > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes a set.
public < t > callback builder with collection callback ( final class < t > component class , final callback < collection < t > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes a collection.
public < k , v > callback builder with map callback ( final class < k > key class , final class < v > value class , final callback < map < k , v > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes a map.
public < t > callback builder with optional callback ( final class < t > cls , final callback < optional < t > > callback ) { this . callback = callback ; return this ; }	Builder method to set callback handler that takes an optional string.
public http response builder add header ( final string name , final string value ) { get headers ( ) . put ( name , value ) ; return this ; }	Add a header.
public boolean is service registered ( final string service id ) { map < string , service > service id to service = get services ( ) ; return service id to service . contains key ( service id ) ; }	Checks to see if a service is registered with the local agent..
public void ping agent ( ) { http . response response = http . get response ( create uri ( str ) . to string ( ) ) ; if ( response . status ( ) != num ) { die ( str , response . payload as string ( ) ) ; } }	Pings the Consul Agent.
public void register ( final registration registration ) { final uri uri = create uri ( str ) ; http . response response = http . json rest call via put ( uri . to string ( ) , to json ( registration ) ) ; if ( response . status ( ) != num ) { die ( str , uri , registration , response . payload as string ( ) ) ; } }	Register a service with Consul.
public void deregister ( final string service id ) { final uri uri = create uri ( str + service id ) ; http . response response = http . get response ( uri . to string ( ) ) ; if ( response . status ( ) != num ) { die ( str , uri , service id , response . status ( ) , response . payload as string ( ) ) ; } }	Remove registration of a particular service.
public void deregister check ( string check id ) { final uri uri = create uri ( str + check id ) ; http . response response = http . get response ( uri . to string ( ) ) ; if ( response . status ( ) != num ) { die ( str , uri , check id , response . status ( ) , response . status message as string ( ) , response . payload as string ( ) ) ; } }	De-registers a Health Check with the Agent.
public void check ( string check id , status status , string note ) { final uri uri = create uri ( str + status . get uri ( ) + str + check id ) ; final http . response http response = str . is empty ( note ) ? http . get response ( uri . to string ( ) ) : http . get response ( uri . to string ( ) + str + note ) ; if ( http response . code ( ) != num ) { not registered ( str , uri , http response . code ( ) , http response . status message as string ( ) , http response . body ( ) ) ; } }	Checks in with Consul.
public void pass ( string check id , @ suppress warnings ( str ) string note ) throws not registered exception { check ttl ( check id , status . pass , note ) ; }	Sets a TTL check to "passing" state with a note.
public void warn ( string check id , string note ) throws not registered exception { check ttl ( check id , status . warn , note ) ; }	Sets a TTL check to "warning" state with a note.
public void stop ( ) { flush ( ) ; if ( http server proxy != null ) { try { http server proxy . stop ( ) ; } catch ( exception ex ) { logger . warn ( str , ex ) ; } } }	Stop client. Stops processing call backs.
private void handle async callback ( final response < object > response , final callback < object > handler ) { if ( response . was errors ( ) ) { handler . on error ( new exception ( response . body ( ) . to string ( ) ) ) ; } else { handler . accept ( response . body ( ) ) ; } }	Handles an async callbackWithTimeout.
private void send ( final string service name , final string message , final consumer < exception > exception consumer ) { if ( web socket == null ) { string web socket uri ; if ( service name . starts with ( uri ) ) { web socket uri = service name ; } else { web socket uri = str . add ( uri , str , service name ) ; } this . web socket = http server proxy . create web socket ( web socket uri ) ; wire web socket ( service name , message ) ; } try { if ( web socket . is closed ( ) && connected ( ) ) { this . web socket . open and notify ( net socket -> { connected . set ( bool ) ; web socket . send text ( message , exception consumer ) ; } , exception consumer ) ; } else { web socket . send text ( message ) ; } } catch ( exception ex ) { this . connected . set ( bool ) ; if ( debug ) throw ex ; } }	Sends a message over websocket.
public < t > t create proxy ( final class < t > service interface , final string service name ) { return create proxy ( service interface , service name , str . join ( str , uri , service name , uuid . random uuid ( ) . to string ( ) ) ) ; }	Creates a new client proxy given a client interface.
private receive queue listener < response < object > > create response queue listener ( ) { return new receive queue listener < response < object > > ( ) { @ override public void receive ( final response < object > response ) { if ( debug ) { logger . debug ( str + response ) ; } handle response from service bundle ( response , response . request ( ) . originating request ( ) ) ; } @ override public void limit ( ) { http request server handler . check timeouts for requests ( ) ; web socket handler . check response batch send ( ) ; } @ override public void empty ( ) { http request server handler . check timeouts for requests ( ) ; web socket handler . check response batch send ( ) ; } @ override public void idle ( ) { http request server handler . check timeouts for requests ( ) ; web socket handler . check response batch send ( ) ; } } ; }	Creates the queue listener for method call responses from the client bundle.
@ override public receive queue < t > receive queue ( ) { final receive queue < string > receive queue = queue . receive queue ( ) ; return new receive queue < t > ( ) { @ override public t poll wait ( ) { final string item = receive queue . poll wait ( ) ; return get parsed item ( item ) ; } private t get parsed item ( string item ) { if ( item != null ) { return from json function . apply ( item ) ; } else { return null ; } } @ override public t poll ( ) { final string item = receive queue . poll wait ( ) ; return get parsed item ( item ) ; } @ override public t take ( ) { final string item = receive queue . take ( ) ; return get parsed item ( item ) ; } @ override public iterable < t > read batch ( int max ) { final iterable < string > iterable = receive queue . read batch ( max ) ; return get parsed items ( iterable ) ; } private iterable < t > get parsed items ( iterable < string > iterable ) { int size = num ; if ( iterable instanceof list ) { size = ( ( list ) iterable ) . size ( ) ; } final list < t > items = new array list < > ( size ) ; for ( string item : iterable ) { items . add ( get parsed item ( item ) ) ; } return items ; } @ override public iterable < t > read batch ( ) { final iterable < string > iterable = receive queue . read batch ( ) ; return get parsed items ( iterable ) ; } @ override public void stop ( ) { receive queue . stop ( ) ; } } ; }	Create a wrapper ReceiveQueue that does decoding on the fly.
private send queue < t > create json send queue ( final send queue < string > send queue ) { return new send queue < t > ( ) { @ override public boolean send ( t item ) { send queue . send ( to json function . apply ( item ) ) ; return bool ; } @ override public void send and flush ( t item ) { send queue . send and flush ( to json function . apply ( item ) ) ; } @ override public void send many ( t ... items ) { for ( t item : items ) { send queue . send ( to json function . apply ( item ) ) ; } } @ override public void send batch ( collection < t > items ) { for ( t item : items ) { send queue . send ( to json function . apply ( item ) ) ; } } @ override public void send batch ( iterable < t > items ) { for ( t item : items ) { send queue . send ( to json function . apply ( item ) ) ; } } @ override public boolean should batch ( ) { return send queue . should batch ( ) ; } @ override public void flush sends ( ) { send queue . flush sends ( ) ; } @ override public int size ( ) { return send queue . size ( ) ; } @ override public string name ( ) { return send queue . name ( ) ; } @ override public void stop ( ) { send queue . stop ( ) ; } } ; }	Helper method to create SendQueue wrappers that do JSON encoding.
@ override public void start listener ( final receive queue listener < t > listener ) { queue . start listener ( item -> listener . receive ( from json function . apply ( item ) ) ) ; }	Start a listener.
public service queue build ( ) { if ( debug ) logger . debug ( str ) ; service queue sizer service queue sizer = null ; if ( stats config != null ) { service queue sizer = new service queue sizer ( ) ; this . add queue callback handler ( new service stats listener ( stats config . service name , stats config . stats collector , get timer ( ) , stats config . flush time seconds , time unit . seconds , stats config . sample every , service queue sizer ) ) ; } service queue service queue = new service queue impl ( this . get root address ( ) , this . get service address ( ) , this . get service object ( ) , this . get request queue builder ( ) , this . get response queue builder ( ) , this . get service method handler ( ) , this . get response queue ( ) , this . is async response ( ) , this . is handle callbacks ( ) , this . get system manager ( ) , this . get before method call ( ) , this . get before method call after transform ( ) , this . get after method call ( ) , this . get after method call after transform ( ) , build queue call back handler ( ) , get callback manager ( ) , get before method sent ( ) , get event manager ( ) , is join event manager ( ) ) ; if ( service queue sizer != null ) { service queue sizer . set service queue ( service queue ) ; } if ( q bit system manager != null ) { q bit system manager . register service ( service queue ) ; } return service queue ; }	Builds a service.
@ override public void check in ok ( final string name ) { if ( debug ) logger . debug ( str , name ) ; final node health stat node health stat = get service health stat ( name ) ; node health stat . set last check in ( super . time ) ; node health stat . set reason ( null ) ; node health stat . set status ( health status . pass ) ; super . increment count ( str ) ; on check in . if present ( check in -> check in . accept ( bean utils . copy ( node health stat ) ) ) ; }	Check in the service.
@ override public void fail with error ( final string name , final throwable error ) { logger . error ( str , name ) ; super . increment count ( str ) ; final node health stat node health stat = get service health stat ( name ) ; node health stat . set status ( health status . fail ) ; node health stat . set reason ( health fail reason . error ) ; node health stat . set last check in ( super . time ) ; node health stat . set error ( error ) ; on fail . if present ( check in -> check in . accept ( bean utils . copy ( node health stat ) ) ) ; }	Fail the node for the service with a specific status.
public managed service builder enable logging mapped diagnostic context ( final set < string > request headers ) { this . enable request chain = bool ; this . enable logging mapped diagnostic context = bool ; this . request headers to track for mapped diagnostic context = collections . unmodifiable set ( request headers ) ; return this ; }	Enable the logging diagnostic context.
public managed service builder enable consul service discovery ( final string data center ) { final consul service discovery builder consul service discovery builder = consul service discovery builder ( ) ; consul service discovery builder . set datacenter ( data center ) ; service discovery supplier = consul service discovery builder :: build ; return this ; }	Enable consul discovery.
public admin builder get admin builder ( ) { if ( admin builder == null ) { admin builder = admin builder . admin builder ( ) ; final string qbit admin port = find admin port ( ) ; if ( qbit admin port != null && ! qbit admin port . is empty ( ) ) { admin builder . set port ( integer . parse int ( qbit admin port ) ) ; } admin builder . set context builder ( this . get context meta builder ( ) ) ; admin builder . set health service ( get health service ( ) ) ; admin builder . register java vm ( get stat service builder ( ) . build stats collector ( ) ) ; } return admin builder ; }	Get the Admin builder.
public context meta builder get context meta builder ( ) { if ( context meta builder == null ) { context meta builder = context meta builder . context meta builder ( ) ; context meta builder . set host address ( this . get public host ( ) + str + this . get public port ( ) ) . set root uri ( this . get root uri ( ) ) ; } return context meta builder ; }	Get context meta builder.
public managed service builder add endpoint service with service managment bundle ( final object endpoint service , final service management bundle service management bundle ) { add endpoint service with alias and queue handler callbacks ( null , endpoint service , new queue call back handler ( ) { @ override public void queue process ( ) { service management bundle . process ( ) ; } } ) ; return this ; }	Add an endpoint with a managment bundle.
public managed service builder add endpoint service with alias and service managment bundle ( final string alias , final object endpoint service , final service management bundle service management bundle ) { add endpoint service with alias and queue handler callbacks ( alias , endpoint service , new queue call back handler ( ) { @ override public void queue process ( ) { service management bundle . process ( ) ; } } ) ; return this ; }	Add an endpoint with a managment bundle and an alias.
public managed service builder add endpoint service ( final object endpoint service ) { get context meta builder ( ) . add service ( endpoint service . get class ( ) ) ; get endpoint services ( ) . add ( endpoint service ) ; return this ; }	Add an endpoint service.
public managed service builder add endpoint service ( final string alias , final object endpoint service ) { get context meta builder ( ) . add service ( alias , endpoint service . get class ( ) ) ; get endpoint service map with alias ( ) . put ( alias , endpoint service ) ; return this ; }	Add endpoint service with alias.
public service endpoint server get service endpoint server ( ) { final service endpoint server service endpoint server = get endpoint server builder ( ) . build ( ) ; if ( managed service definition list != null ) { managed service definition list . for each ( service def -> { if ( service def . get alias ( ) == null ) { service endpoint server . add service with queue call back handlers ( service def . get service object ( ) , service def . get queue call back handlers ( ) ) ; } else { service endpoint server . add service object with queue call back handlers ( service def . get alias ( ) , service def . get service object ( ) , service def . get queue call back handlers ( ) ) ; } } ) ; } return service endpoint server ; }	Get the ServiceEndpointServer constructed with all of the service endpionts thatyou registered.
private interceptors configure interceptors ( ) { interceptors interceptors = new interceptors ( ) ; setup mdc for http request interceptor setup mdc for http request interceptor ; if ( enable logging mapped diagnostic context ) { enable request chain = bool ; if ( request headers to track for mapped diagnostic context != null && request headers to track for mapped diagnostic context . size ( ) > num ) { setup mdc for http request interceptor = new setup mdc for http request interceptor ( request headers to track for mapped diagnostic context ) ; } else { setup mdc for http request interceptor = new setup mdc for http request interceptor ( collections . empty set ( ) ) ; } interceptors . before . add ( setup mdc for http request interceptor ) ; interceptors . after . add ( setup mdc for http request interceptor ) ; } if ( enable request chain ) { final capture request interceptor capture request interceptor = new capture request interceptor ( ) ; interceptors . before . add ( capture request interceptor ) ; interceptors . after . add ( capture request interceptor ) ; interceptors . before sent . add ( new forward call method interceptor ( new request context ( ) ) ) ; } return interceptors ; }	Configure a list of common interceptors.
public boolean destroy ( final string session id , final session session , final string datacenter ) { final uri uri = create uri ( str + session id ) ; final http request builder http request builder = request utils . get http request builder ( datacenter , null , null , str ) ; http . response http response = http . json rest call via put ( uri . to string ( ) + str + http request builder . param string ( ) , to json ( session ) ) ; if ( http response == null || http response . code ( ) != num ) { die ( str , session id , uri , http response ) ; } return http response . code ( ) == num ; }	Destroy the session.
@ override public list < endpoint definition > load services ( final string service name ) { if ( debug ) logger . debug ( str , service name ) ; final count down latch count down latch = new count down latch ( num ) ; final atomic reference < list < endpoint definition > > end points ref = new atomic reference < > ( ) ; final atomic reference < throwable > exception atomic reference = new atomic reference < > ( ) ; dns support . load service endpoints by service name ( callback builder . new callback builder ( ) . with list callback ( endpoint definition . class , endpoint definitions -> { end points ref . set ( endpoint definitions ) ; count down latch . count down ( ) ; } ) . with error handler ( exception atomic reference :: set ) . build ( ) , service name ) ; try { if ( debug ) logger . debug ( str , timeout , time unit ) ; count down latch . await ( timeout , time unit ) ; } catch ( interrupted exception e ) { throw new illegal state exception ( str , e ) ; } if ( exception atomic reference . get ( ) != null ) { logger . error ( str , exception atomic reference . get ( ) ) ; throw new illegal state exception ( str , exception atomic reference . get ( ) ) ; } else { if ( debug ) logger . debug ( str ) ; return end points ref . get ( ) ; } }	Load the services.
private void delete ( string key , map < string , string > params ) { final uri uri = create uri ( str + key ) ; final http request builder http request builder = request utils . get http request builder ( null , null , request options . blank , str ) ; final set < map . entry < string , string > > entries = params . entry set ( ) ; for ( map . entry < string , string > entry : entries ) { http request builder . add param ( entry . get key ( ) , entry . get value ( ) ) ; } http request builder . set method delete ( ) ; final http . response http response = http . delete response ( uri . to string ( ) + str + http request builder . param string ( ) ) ; if ( http response . code ( ) != num ) { die ( str , uri , key , http response . code ( ) , http response . body ( ) ) ; } }	Deletes a specified key.
public void handle request ( final http request request ) { if ( debug ) { system . out . println ( str + request ) ; logger . debug ( str + request ) ; } if ( should continue http request . test ( request ) ) { http request consumer . accept ( request ) ; } }	Main entry point.
public void process ( ) { if ( ! receive queue . is present ( ) ) { init queue ( ) ; } receive queue . if present ( receive queue -> { t item ; do { try { item = receive queue . poll ( ) ; } catch ( exception ex ) { logger . debug ( str , ex ) ; init queue ( ) ; item = null ; } if ( item != null ) { send to event manager ( item ) ; } } while ( item != null ) ; } ) ; }	Process. This can be called periodically and it will check to see if there are messages on the queue.
private void send to event manager ( t item ) { if ( debug ) { logger . debug ( str , item ) ; } try { if ( lock . try lock ( ) ) { event manager . send arguments ( channel , item ) ; } else { lock . lock ( ) ; event manager . send arguments ( channel , item ) ; } } finally { lock . unlock ( ) ; } }	Send the queue item to the event.
public void start ( ) { if ( ! queue . is present ( ) ) { init queue ( ) ; } queue . if present ( actual queue -> actual queue . start listener ( event bus queue adapter . this :: send to event manager ) ) ; }	Start listener. Once this is called messages can come in on a foreign thread.
public optional < http request > get http request ( ) { final optional < request < object > > request = this . get request ( ) ; if ( request . is present ( ) ) { return find http request ( request . get ( ) ) ; } else { return optional . empty ( ) ; } }	Grab the current http request.
public void remove ( final event connector event connector ) { if ( event connector != null ) { try { if ( event connector instanceof tcp ) { final tcp remote tcp = ( tcp ) event connector ; logger . info ( str . sputs ( str , remote tcp . host ( ) , str , remote tcp . port ( ) , str , remote tcp . connected ( ) ) ) ; remote tcp . silent close ( ) ; } this . event connectors . remove ( event connector ) ; } catch ( exception ex ) { logger . error ( str , ex ) ; } } }	Remove an event connector.
@ override public void forward event ( final event transfer object < object > event ) { if ( debug ) logger . debug ( str + event . channel ( ) + str + event connectors . size ( ) ) ; for ( int index = num ; index < event connectors . size ( ) ; index ++ ) { event connector event connector = null ; try { event connector = event connectors . get ( index ) ; event connector . forward event ( event ) ; } catch ( exception ex ) { logger . error ( str , ex ) ; if ( event connector instanceof tcp ) { if ( ! ( ( tcp ) event connector ) . connected ( ) ) { event connectors . remove ( event connector ) ; } } } } if ( debug ) logger . debug ( str + event . channel ( ) ) ; }	Forwards en event to another event system.
@ override public void flush ( ) { for ( int index = num ; index < event connectors . size ( ) ; index ++ ) { event connector event connector = null ; try { event connector = event connectors . get ( index ) ; if ( event connector instanceof client proxy ) { service proxy utils . flush service proxy ( event connector ) ; } else { event connector . flush ( ) ; } } catch ( exception ex ) { logger . debug ( str , ex ) ; if ( event connector instanceof tcp ) { if ( ! ( ( tcp ) event connector ) . connected ( ) ) { event connectors . remove ( event connector ) ; } } } } }	Flushes the pool used to optimize flushing of IO operations.
public static microservice config read config ( final string service name ) { final logger logger = logger factory . get logger ( microservice config . class ) ; if ( new file ( resource location ) . exists ( ) ) { final string json = io . read ( resource location ) ; return json factory . from json ( json , microservice config . class ) ; } else if ( resource location env != null && new file ( resource location env ) . exists ( ) ) { final string json = io . read ( resource location env ) ; return json factory . from json ( json , microservice config . class ) ; } else { logger . info ( str ) ; final string qbit env = system . getenv ( str ) ; final string resource location on classpath = qbit env != null && ! qbit env . is empty ( ) ? service name + str + qbit env + str : service name + str ; final string json = io . read ( thread . current thread ( ) . get context class loader ( ) . get resource as stream ( resource location on classpath ) ) ; return json factory . from json ( json , microservice config . class ) ; } }	Reads the readConfig file, which can be a classpath or file system resource.
private void register handler callback for client ( final method call < object > method call , final callback < object > handler ) { final handler key handler key = new handler key ( method call . return address ( ) , method call . address ( ) , method call . id ( ) , method call . timestamp ( ) ) ; if ( debug ) { if ( handlers . contains key ( handler key ) ) { logger . debug ( str , handler key ) ; } } handlers . put ( handler key , handler ) ; }	Register a callbackWithTimeout handler.
@ override public boolean before ( final method call method call ) { final optional < http request > http request = find http request ( method call ) ; if ( http request . is present ( ) ) { extract request info and put it into mapped diagnostic context ( http request . get ( ) ) ; } return bool ; }	Gets called before a method gets invoked on a service.This adds request URI, remote address and request headers of the HttpRequest if found.
private void extract request info and put it into mapped diagnostic context ( final http request http request ) { mdc . put ( request uri , http request . get uri ( ) ) ; mdc . put ( request remote address , http request . get remote address ( ) ) ; mdc . put ( request http method , http request . get method ( ) ) ; mdc . put ( request id , long . to string ( http request . get message id ( ) ) ) ; extract headers ( http request ) ; }	Extract request data and put it into the logging Mapped Diagnostic Context.
private void extract headers ( final http request http request ) { if ( headers to add to logging mapping diagnostics context . size ( ) > num ) { final multi map < string , string > headers = http request . get headers ( ) ; headers to add to logging mapping diagnostics context . for each ( header -> { string value = headers . get first ( header ) ; if ( ! str . is empty ( value ) ) { mdc . put ( request header prefix + header , value ) ; } } ) ; } }	Extract headersToAddToLoggingMappingDiagnosticsContext data and put them into the logging mapping diagnostics context.
@ override public void handle rest call ( final http request request ) { final list < string > error list = new array list < > ( num ) ; final method call < object > method call = standard request transformer . transform ( request , error list ) ; if ( method call != null && error list . size ( ) == num ) { if ( ! add request to check for timeouts ( request ) ) { handle overflow ( request ) ; return ; } send method to service bundle ( method call ) ; } else { if ( ! request . is handled ( ) ) { handle error converting ( request , error list , method call ) ; } return ; } final request meta data request meta data = meta data provider map . get ( request method . value of ( request . get method ( ) ) ) . get ( request . address ( ) ) ; final service method meta service method = request meta data . get method ( ) ; if ( service method . get method access ( ) . return type ( ) == void . class && ! service method . has call back ( ) ) { request . handled ( ) ; final int response code = service method . get response code ( ) ; write response ( request . get receiver ( ) , response code == - num ? http status . accepted : response code , service method . get content type ( ) , str , request meta data . get request ( ) . get response headers ( ) ) ; } }	MOST IMPORTANT METHOD FOR DEBUGGING WHY SOMETHING IS NOT CALLED.
@ override public void handle response from service to http response ( final response < object > response , final http request originating request ) { final string key = str . add ( str + originating request . id ( ) , str , originating request . return address ( ) ) ; this . outstanding request map . remove ( key ) ; if ( response . was errors ( ) ) { handle error ( response , originating request ) ; } else { if ( response . body ( ) instanceof http response ) { write http response ( originating request . get receiver ( ) , ( ( http response ) response . body ( ) ) ) ; } else { final request meta data request meta data = meta data provider map . get ( request method . value of ( originating request . get method ( ) ) ) . get ( originating request . address ( ) ) ; final service method meta service method meta = request meta data . get method ( ) ; final int response code = service method meta . get response code ( ) ; multi map < string , string > headers = response . headers ( ) ; if ( request meta data . get request ( ) . has response headers ( ) ) { if ( response . headers ( ) == multi map . empty ) { headers = new multi map impl < > ( ) ; } else { headers = response . headers ( ) ; } headers . put all copy lists ( request meta data . get request ( ) . get response headers ( ) ) ; } write response ( originating request . get receiver ( ) , response code == - num ? http status . ok : response code , service method meta . get content type ( ) , json mapper . to json ( response . body ( ) ) , headers ) ; } } }	2nd MOST IMPORTANT METHOD FOR DEBUGGING WHY SOMETHING IS NOT CALLED.
private boolean add request to check for timeouts ( final request < object > request ) { string key = str . add ( str + request . id ( ) , str , request . return address ( ) ) ; this . outstanding request map . put ( key , request ) ; return outstanding request map . size ( ) < number of outstanding requests ; }	Add a request to the timeout queue.
@ override public boolean add ( long integer ) { if ( end + num >= values . length ) { values = lng . grow ( values ) ; } values [ end ] = integer ; end ++ ; return bool ; }	Add a new value to the list.
@ suppress warnings ( str ) public stat list add ( int integer ) { if ( end + num >= values . length ) { values = lng . grow ( values ) ; } values [ end ] = integer ; end ++ ; return this ; }	Add a new value to the list but don't employ a wrapper.
public boolean add array ( long ... new values ) { if ( end + new values . length >= values . length ) { values = lng . grow ( values , ( values . length + new values . length ) * num ) ; } system . arraycopy ( new values , num , values , end , new values . length ) ; end += new values . length ; return bool ; }	Add a new array to the list.
@ override public long set ( int index , long element ) { long old value = values [ index ] ; values [ index ] = element ; return old value ; }	Set a value in the list.
public long reduce by ( object function , string name ) { return lng . reduce by ( values , end , function , name ) ; }	This would be a good opportunity to reintroduce dynamic invoke.
@ override public void before method sent ( final method call builder method builder ) { if ( method builder . get originating request ( ) == null ) { final optional < request < object > > request = request context . get request ( ) ; if ( request . is present ( ) ) { method builder . set originating request ( request . get ( ) ) ; } } }	Intercept the call before it gets sent to the service queue.
private void notify listener ( change notification < t > change notification , boolean new listener ) { lock . lock ( ) ; try { check not null ( change notification , str ) ; final listener < t > listener = listener ref . get ( ) ; if ( listener != null ) { try { final boolean notified = listener notified . get and set ( bool ) ; if ( ! ( new listener && notified ) ) { listener . on change ( change notification ) ; } } catch ( throwable e ) { log . error ( str , e ) ; } } } finally { lock . unlock ( ) ; } }	Notify the listener about a change.
public static kryo add default serializers ( kryo kryo ) { array list sub list serializer . add default serializer ( kryo ) ; abstract list sub list serializer . add default serializer ( kryo ) ; java util sub list serializer . add default serializer ( kryo ) ; return kryo ; }	Adds appropriate sublist serializers as default serializers.
private method get parse from method ( class < ? extends t > type ) throws no such method exception { if ( parse from method == null ) { parse from method = type . get method ( str , byte [ ] . class ) ; } return parse from method ; }	Caches method reflection lookup.
private char verify no leading zeroes ( ) throws io , json parse exception {	Method called when we have seen one zero, and want to ensureit is not followed by another.
protected string parse unquoted field name ( int i ) throws io , json parse exception {	Method called when we see non-white space character otherthan double quote, when expecting a field name.In standard mode will just throw an expection; butin non-standard modes may be able to parse name.
protected json token handle unexpected value ( int i ) throws io , json parse exception {	Method for handling cases where first non-space characterof an expected value token is not legal for standard JSON content.
protected void skip string ( ) throws io , json parse exception { token incomplete = bool ; int input ptr = input ptr ; int input len = input end ; char [ ] input buffer = input buffer ; while ( bool ) { if ( input ptr >= input len ) { input ptr = input ptr ; if ( ! load more ( ) ) { report invalid eof ( str ) ; } input ptr = input ptr ; input len = input end ; } char c = input buffer [ input ptr ++ ] ; if ( c == int apostrophe ) { input ptr = input ptr ; break ; } else if ( c == str ) { input ptr = input ptr ; decode escaped ( ) ; input ptr = input ptr ; input len = input end ; } } }	Method called to skim through rest of unparsed String value,if it is not needed.
protected void match token ( string match str , int i ) throws io , json parse exception { final int len = match str . length ( ) ; do { if ( input ptr >= input end ) { if ( ! load more ( ) ) { report invalid eof ( ) ; } } if ( input buffer [ input ptr ] != match str . char at ( i ) ) { report invalid token ( match str . substring ( num , i ) , str ) ; } ++ input ptr ; } while ( ++ i < len ) ;	Helper method for checking whether input matches expected token.
protected byte [ ] decode base64 ( base64 variant b64variant ) throws io , json parse exception { byte array builder builder = get byte array builder ( ) ;	Efficient handling for incremental parsing of base64-encodedtextual content.
public static boolean is id strict ( string string ) { int len = string . length ( ) ; if ( len == num ) { return bool ; } if ( ! is id start strict ( string . char at ( num ) ) ) { return bool ; } for ( int i = num ; i < len ; i ++ ) { if ( ! is id char strict ( string . char at ( i ) ) ) { return bool ; } } return bool ; }	Returns true if a string does not need to be quoted when serialized.Uses the strict definition described in the Rison specification, appropriate for encoding.
public static boolean is id strict ( char [ ] chars , int offset , int len ) { if ( len == num ) { return bool ; } int end = offset + len ; if ( ! is id start strict ( chars [ offset ++ ] ) ) { return bool ; } while ( offset < end ) { if ( ! is id char strict ( chars [ offset ++ ] ) ) { return bool ; } } return bool ; }	Returns true if the string represented by the specified character array does notUses the strict definition described in the Rison specification, appropriate for encoding.
private void write string ( char [ ] text , int offset , int len ) throws io , json generation exception { len += offset ;	This method called when the string content is already ina char buffer, and need not be copied for processing.
private int prepend or write ( char [ ] buffer , int ptr , char esc ) throws io , json generation exception { if ( ptr > num ) {	Method called to try to either prepend character escape at front ofgiven buffer; or if not possible, to write it out directly.
private void append character escape ( char esc , char ch ) throws io , json generation exception { if ( ( output tail + num ) >= output end ) { flush buffer ( ) ; } output buffer [ output tail ++ ] = esc ; output buffer [ output tail ++ ] = ch ; }	Method called to append escape sequence for given character, at theend of standard output buffer; or if not possible, write out directly.
public static void set conversion properties ( configuration conf ) { if ( conf != null ) { use enum id = conf . get boolean ( use enum id conf key , bool ) ; log . debug ( str + use enum id ) ; } }	Set the flags that can be used by the conversion.
public static string to pig script ( class < ? extends t < ? , ? > > thrift class , class < ? extends load func > pig loader ) { string builder sb = new string builder ( ) ; string builder prefix = new string builder ( str ) ; sb . append ( str ) . append ( pig loader . get name ( ) ) . append ( str ) . append ( thrift class . get name ( ) ) . append ( str ) . append ( prefix ) . append ( str ) ; prefix . append ( str ) ; try { stringify schema ( sb , to schema ( thrift class ) , data type . tuple , prefix ) ; } catch ( frontend exception e ) { throw new runtime exception ( e ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	Turn a Thrift Struct into a loading schema for a pig script.
public static void stringify schema ( string builder sb , schema schema , byte type , string builder prefix ) throws frontend exception {	type can only be BAG or TUPLE.
protected index reader open index ( path path , configuration conf ) throws io { return directory reader . open ( new lucene hdfs directory ( path , path . get file system ( conf ) ) ) ; }	Open an index stored in pathOverride if you want more control over how indexes are opened.
@ override public float get progress ( ) { if ( num indexes < num ) { return num ; } float index progress = ( float ) current index path iter . previous index ( ) / ( float ) num indexes ; float queries progress = num ; if ( queries . size ( ) > num ) { queries progress = ( float ) current query iter . previous index ( ) / ( float ) queries . size ( ) ; } queries progress *= num / num indexes ; return index progress + queries progress ; }	This is sort of an approximation of progress.It splits the progress equally among all indexes, then among all queries for that index.So it won't move linearly, since we don't know how many hits there will be per query.
public tuple to tuple ( message msg ) { if ( msg == null ) {	Turn a generic message into a Tuple.
@ suppress warnings ( str ) protected object message to tuple ( field descriptor field descriptor , object field value ) { if ( field value == null ) {	Translate a nested message to a tuple.
@ suppress warnings ( str ) protected object single field to tuple ( field descriptor field descriptor , object field value ) { assert field descriptor . get type ( ) != field descriptor . type . message : str + field descriptor . get type ( ) ; if ( field descriptor . is repeated ( ) ) {	Translate a single field to a tuple.
private object coerce to pig types ( field descriptor field descriptor , object field value ) { if ( field descriptor . get type ( ) == field descriptor . type . enum && field value != null ) { enum value descriptor enum value descriptor = ( enum value descriptor ) field value ; return enum value descriptor . get name ( ) ; } else if ( field descriptor . get type ( ) == field descriptor . type . bool && field value != null ) { boolean bool value = ( boolean ) field value ; return new integer ( bool value ? num : num ) ; } else if ( field descriptor . get type ( ) == field descriptor . type . bytes && field value != null ) { byte string bs value = ( byte string ) field value ; return new data byte array ( bs value . to byte array ( ) ) ; } return field value ; }	If the given field value is an enum, translate it to the enum's name as a string, since Pig cannot handle enums.Also, if the given field value is a bool, translate it to 0 or 1 to avoid Pig bools, which can be sketchy.
public schema to schema ( descriptor msg descriptor ) { schema schema = new schema ( ) ; try {	Turn a generic message descriptor into a Schema.
private field schema message to field schema ( field descriptor field descriptor ) throws frontend exception { assert field descriptor . get type ( ) == field descriptor . type . message : str + field descriptor . get type ( ) ; schema inner schema = to schema ( field descriptor . get message type ( ) ) ; if ( field descriptor . is repeated ( ) ) { schema tuple schema = new schema ( ) ; tuple schema . add ( new field schema ( field descriptor . get name ( ) + str , inner schema , data type . tuple ) ) ; return new field schema ( field descriptor . get name ( ) , tuple schema , data type . bag ) ; } else { return new field schema ( field descriptor . get name ( ) , inner schema , data type . tuple ) ; } }	Turn a nested message into a Schema object.
private field schema single field to field schema ( field descriptor field descriptor ) throws frontend exception { assert field descriptor . get type ( ) != field descriptor . type . message : str + field descriptor . get type ( ) ; if ( field descriptor . is repeated ( ) ) { schema item schema = new schema ( ) ; item schema . add ( new field schema ( field descriptor . get name ( ) , null , get pig data type ( field descriptor ) ) ) ; schema item tuple schema = new schema ( ) ; item tuple schema . add ( new field schema ( field descriptor . get name ( ) + str , item schema , data type . tuple ) ) ; return new field schema ( field descriptor . get name ( ) + str , item tuple schema , data type . bag ) ; } else { return new field schema ( field descriptor . get name ( ) , null , get pig data type ( field descriptor ) ) ; } }	Turn a single field into a Schema object.
public string to pig script ( descriptor msg descriptor , string loader class name ) { string buffer sb = new string buffer ( ) ; final int initial tab offset = num ; sb . append ( str + loader class name + str ) . append ( str ) ; sb . append ( tabs ( initial tab offset ) ) . append ( str ) . append ( str ) ; sb . append ( to pig script internal ( msg descriptor , initial tab offset ) ) ; sb . append ( tabs ( initial tab offset ) ) . append ( str ) . append ( str ) . append ( str ) ; return sb . to string ( ) ; }	Turn a generic message descriptor into a loading schema for a pig script.
private string buffer to pig script internal ( descriptor msg descriptor , int num tabs ) { string buffer sb = new string buffer ( ) ; try {	Turn a generic message descriptor into a loading schema for a pig script.
private string buffer message to pig script ( field descriptor field descriptor , int num tabs , boolean is last ) throws frontend exception { assert field descriptor . get type ( ) == field descriptor . type . message : str + field descriptor . get type ( ) ; if ( field descriptor . is repeated ( ) ) { return new string buffer ( ) . append ( tabs ( num tabs ) ) . append ( field descriptor . get name ( ) ) . append ( str ) . append ( str ) . append ( tabs ( num tabs + num ) ) . append ( field descriptor . get name ( ) ) . append ( str ) . append ( str ) . append ( to pig script internal ( field descriptor . get message type ( ) , num tabs + num ) ) . append ( tabs ( num tabs + num ) ) . append ( str ) . append ( str ) . append ( tabs ( num tabs ) ) . append ( str ) . append ( is last ? str : str ) . append ( str ) ; } else { return new string buffer ( ) . append ( tabs ( num tabs ) ) . append ( field descriptor . get name ( ) ) . append ( str ) . append ( str ) . append ( to pig script internal ( field descriptor . get message type ( ) , num tabs + num ) ) . append ( tabs ( num tabs ) ) . append ( str ) . append ( is last ? str : str ) . append ( str ) ; } }	Turn a nested message into a pig script load string.
private string buffer single field to pig script ( field descriptor field descriptor , int num tabs , boolean is last ) throws frontend exception { assert field descriptor . get type ( ) != field descriptor . type . message : str + field descriptor . get type ( ) ; if ( field descriptor . is repeated ( ) ) { return new string buffer ( ) . append ( tabs ( num tabs ) ) . append ( field descriptor . get name ( ) ) . append ( str ) . append ( str ) . append ( tabs ( num tabs + num ) ) . append ( field descriptor . get name ( ) ) . append ( str ) . append ( str ) . append ( tabs ( num tabs + num ) ) . append ( field descriptor . get name ( ) ) . append ( str ) . append ( get pig script data type ( field descriptor ) ) . append ( str ) . append ( tabs ( num tabs + num ) ) . append ( str ) . append ( str ) . append ( tabs ( num tabs ) ) . append ( str ) . append ( is last ? str : str ) . append ( str ) ; } else { return new string buffer ( ) . append ( tabs ( num tabs ) ) . append ( field descriptor . get name ( ) ) . append ( str ) . append ( get pig script data type ( field descriptor ) ) . append ( is last ? str : str ) . append ( str ) ; } }	Turn a single field into a pig script load string.
public static t get instance ( class < ? extends t < ? , ? > > t class ) { synchronized ( struct map ) { t desc = struct map . get ( t class ) ; if ( desc == null ) { desc = new t ( ) ; desc . t class = t class ; struct map . put ( t class , desc ) ; desc . build ( t class ) ; } return desc ; } }	Creates a descriptor for a Thrift class.
static private map < string , t > extract enum map ( class < ? extends t > enum class ) { immutable map . builder < string , t > builder = immutable map . builder ( ) ; for ( t e : enum class . get enum constants ( ) ) { builder . put ( e . to string ( ) , e ) ; } return builder . build ( ) ; }	returns 'enum name -> enum object' mapping.Currently used for converting Tuple to a Thrift object.
public static path filter new index dir filter ( configuration conf ) { return new path filters . composite path filter ( path filters . new exclude files filter ( conf ) , path filters . exclude hidden paths filter , new path filter ( ) { @ override public boolean accept ( path path ) { return path . get name ( ) . starts with ( str ) ; } } ) ; }	Creates a path filter that accepts non-hidden directories that start with "index-"This is what the indexes created by this output format look like,so this is useful for finding them when traversing the file system.
public static boolean use dynamic proto message ( class < ? > proto class ) { return proto class == null || proto class . get canonical name ( ) . equals ( dynamic message . class . get canonical name ( ) ) ; }	For a configured protoClass, should the message be dynamic or is it a pre-generated Message class? If protoClass isnull or set to DynamicMessage.class, then the configurer intends for a dynamically generated protobuf to be used.
public static < m extends message > type ref < m > get type ref ( string proto class name ) { return new type ref < m > ( get protobuf class ( proto class name ) ) { } ; }	Returns typeref for a Protobuf class.
@ override public float get progress ( ) { if ( start == end ) { return num ; } else { return math . min ( num , ( pos - start ) / ( float ) ( end - start ) ) ; } }	Get the progress within the split.
private byte [ ] serialize ( ) { if ( message bytes == null && message != null ) { check converter ( ) ; message bytes = converter . to bytes ( message ) ; if ( message bytes == null ) {	Converts the message to raw bytes, and caches the converted value.
public static void set input format ( class < ? > real input format class , configuration conf ) { conf . set class ( str , deprecated input format wrapper . class , org . apache . hadoop . mapred . input format . class ) ; hadoop utils . set class conf ( conf , class conf key , real input format class ) ; }	For cases where we need to set hadoop1 input format in a hadoop2 Configuration object.
public static void set class conf ( configuration conf , string config key , class < ? > clazz ) { string existing class = conf . get ( config key ) ; string class name = clazz . get name ( ) ; if ( existing class != null && ! existing class . equals ( class name ) ) { throw new runtime exception ( str + config key + str + existing class + str + class name ) ; } else { conf . set ( config key , class name ) ; } }	A helper to set configuration to class name.Throws a RuntimeExcpetion if theconfiguration is already set to a different class name.
public static void write string list to conf as json ( string key , list < string > list , configuration conf ) { preconditions . check not null ( list ) ; conf . set ( key , json . to json ( list ) ) ; }	Writes a list of strings into a configuration by converting it to a json array.
@ suppress warnings ( str ) public static list < string > read string list from conf as json ( string key , configuration conf ) { string json = conf . get ( key ) ; if ( json == null ) { return null ; } return lists . < string > new array list ( ( ( json ) json . parse ( json ) ) ) ; }	Reads a list of strings stored as a json array from a configuration.
public static void write string list to conf as base64 ( string key , list < string > list , configuration conf ) { preconditions . check not null ( list ) ; iterator < string > iter = list . iterator ( ) ; string builder sb = new string builder ( ) ; while ( iter . has next ( ) ) { byte [ ] bytes = base64 . encode base64 ( iter . next ( ) . get bytes ( charsets . utf 8 ) , bool ) ; sb . append ( new string ( bytes , charsets . utf 8 ) ) ; if ( iter . has next ( ) ) { sb . append ( str ) ; } } conf . set ( key , sb . to string ( ) ) ; }	Writes a list of strings into a configuration by base64 encoding them and separatingthem with commas.
@ suppress warnings ( str ) public static list < string > read string list from conf as base64 ( string key , configuration conf ) { string b64 list = conf . get ( key ) ; if ( b64 list == null ) { return null ; } list < string > strings = lists . new array list ( ) ; for ( string b64 : comma splitter . split ( b64 list ) ) { byte [ ] bytes = base64 . decode base64 ( b64 . get bytes ( charsets . utf 8 ) ) ; strings . add ( new string ( bytes , charsets . utf 8 ) ) ; } return strings ; }	Reads a list of strings stored as comma separated base64.
private static void verify ancestry ( class < ? > t class ) { if ( ! t . class . is assignable from ( t class ) ) { utils . ensure class loader consistency ( t . class , t class . get class loader ( ) ) ; throw new class cast exception ( t class . get name ( ) + str ) ; } }	Verify that clazz is a Thrift class.
public static < m > m get field value ( object containing object , string field name , class < m > field class ) { return get field value ( containing object . get class ( ) , containing object , field name , field class ) ; }	Returns value of a fieldName in an object.
public static < m > m get field value ( class < ? > containing class , string field name , class < m > field class ) { return get field value ( containing class , null , field name , field class ) ; }	Returns value of a static field with given name in containingClass.
public static class < ? > get field value type ( field field ) { switch ( field . get type ( ) ) { case t . bool : return boolean . class ; case t . byte : return byte . class ; case t . double : return double . class ; case t . enum : return field . get enum class ( ) ; case t . i16 : return short . class ; case t . i32 : return integer . class ; case t . i64 : return long . class ; case t . list : return list . class ; case t . map : return map . class ; case t . set : return set . class ; case t . stop : return null ; case t . string : return string . class ; case t . struct : return field . gett struct descriptor ( ) . get thrift class ( ) ; case t . void : return null ; } return null ; }	Returns the value class of the given thrift field.
public static void write field no tag ( t proto , field field , object value ) throws t { if ( value == null ) { return ; } field inner field = null ; switch ( field . get type ( ) ) { case t . list : inner field = field . get list elem field ( ) ; break ; case t . set : inner field = field . get set elem field ( ) ; break ; case t . map : inner field = field . get map key field ( ) ; break ; default : write single field no tag ( proto , field , value ) ; return ; }	Serializes a single field of a thrift struct.
public static message tuple to message ( builder builder , tuple tuple ) { return tuple to message ( builder , builder . get descriptor for type ( ) . get fields ( ) , tuple ) ; }	Turn a Tuple into a Message with the given type.
private static object tuple field to single field ( field descriptor field descriptor , object tuple field ) {	Converts a tupleField string to its corresponding protobuf enum type if necessary, otherwisereturns the tupleField as is.
private static void add field ( descriptor proto . builder builder , string name , int field id , type type ) { field descriptor proto . builder fd builder = field descriptor proto . new builder ( ) . set name ( name ) . set number ( field id ) . set type ( type ) ; builder . add field ( fd builder . build ( ) ) ; }	Add a field to a protobuf builder.
private static type pig type to proto type ( byte pig type id ) { switch ( pig type id ) { case data type . boolean : return type . type bool ; case data type . integer : return type . type in ; case data type . long : return type . type in ; case data type . float : return type . type float ; case data type . double : return type . type double ; case data type . chararray : return type . type string ; case data type . bytearray : return type . type bytes ; default : throw new illegal argument exception ( str + pig type id + str ) ; } }	For a given Pig type, return the protobufs type that maps to it.
@ suppress warnings ( str ) private static t < ? , ? > to thrift ( t t desc , tuple tuple ) { int size = t desc . get fields ( ) . size ( ) ; int tuple size = tuple . size ( ) ; @ suppress warnings ( str ) t t obj = new t ( t desc . get thrift class ( ) ) ; for ( int i = num ; i < size && i < tuple size ; i ++ ) { object p obj ; try { p obj = tuple . get ( i ) ; } catch ( exec exception e ) { throw new runtime exception ( e ) ; } if ( p obj != null ) { field field = t desc . get field at ( i ) ; try { t obj . set field value ( field . get field id enum ( ) , to thrift value ( field , p obj ) ) ; } catch ( exception e ) { string value = string . value of ( t obj ) ; final int max length = num ; if ( max length < value . length ( ) ) { value = value . substring ( num , max length - num ) + str ; } string type = t obj == null ? str : t obj . get class ( ) . get name ( ) ; throw new runtime exception ( string . format ( str , field . get name ( ) , value , type , i ) , e ) ; } }	Construct a Thrift object from the tuple.
@ suppress warnings ( str ) public static object to thrift value ( field thrift field , object pig value ) { try { switch ( thrift field . get type ( ) ) { case t . bool : return boolean . value of ( ( ( integer ) pig value ) != num ) ; case t . byte : return ( ( integer ) pig value ) . byte value ( ) ; case t . i16 : return short . value of ( ( ( integer ) pig value ) . short value ( ) ) ; case t . string : return to string type ( pig value ) ; case t . struct : return to thrift ( thrift field . gett struct descriptor ( ) , ( tuple ) pig value ) ; case t . map : return to thrift map ( thrift field , ( map < string , object > ) pig value ) ; case t . set : return to thrift set ( thrift field . get set elem field ( ) , ( data bag ) pig value ) ; case t . list : return to thrift list ( thrift field . get list elem field ( ) , ( data bag ) pig value ) ; case t . enum : return to thrift enum ( thrift field , ( string ) pig value ) ; default :	For a given Pig value, return a Thrift object of the same type as the Thrift field passed.
private static t < ? , ? > new t ( class < ? > t class ) { try { return ( t < ? , ? > ) t class . new instance ( ) ; } catch ( exception e ) {	return an instance assuming tClass is a Thrift class.
public static void set combined input format delegate ( configuration conf , class < ? extends input format > clazz ) { hadoop utils . set class conf ( conf , combined input format delegate , clazz ) ; }	This sets configures the delegate, though it does not configure DelegateCombineFileInputFormat.
protected priority queue < lucene index input split > find splits ( configuration conf ) throws io { priority queue < lucene index input split > splits = new priority queue < lucene index input split > ( ) ; list < path > index dirs = lists . new linked list ( ) ;	Finds and creates all the index splits based on the input paths set in conf.
public static void set input paths ( list < path > paths , configuration conf ) throws io { preconditions . check not null ( paths ) ; preconditions . check argument ( ! paths . is empty ( ) ) ; string [ ] path strs = new string [ paths . size ( ) ] ; int i = num ; for ( path p : paths ) { file system fs = p . get file system ( conf ) ; path strs [ i ++ ] = fs . make qualified ( p ) . to string ( ) ; } conf . set strings ( input paths key , path strs ) ; }	Sets the input paths for for this input format.All paths will be searched for indexes recursively.
public static path [ ] get input paths ( configuration conf ) { string [ ] path strs = preconditions . check not null ( conf . get strings ( input paths key ) , str ) ; path [ ] paths = new path [ path strs . length ] ; for ( int i = num ; i < path strs . length ; i ++ ) { paths [ i ] = new path ( path strs [ i ] ) ; } return paths ; }	Gets the input paths for this input format.
public void add ( input split split ) throws io , interrupted exception { splits . add ( split ) ; total split sizes += split . get length ( ) ; locations = null ; }	Add an InputSplit to this collection.
public static byte evaluate delimiter ( string input delimiter ) { if ( input delimiter . length ( ) == num ) { return input delimiter . get bytes ( ) [ num ] ; } else if ( input delimiter . length ( ) > num && input delimiter . char at ( num ) == str ) { switch ( input delimiter . char at ( num ) ) { case str : return ( byte ) str ; case str : case str : return integer . value of ( input delimiter . substring ( num ) ) . byte value ( ) ; default : throw new illegal argument exception ( str + input delimiter ) ; } } else { throw new illegal argument exception ( str ) ; } }	Parse an input delimiter string, as with PigStorage, and return the byte it represents.
public static resource field schema create resource field schema ( required field field ) throws io { resource field schema schema = new resource field schema ( ) . set name ( field . get alias ( ) ) . set type ( field . get type ( ) ) ; list < required field > sub fields = field . get sub fields ( ) ; if ( sub fields != null && ! sub fields . is empty ( ) ) { resource field schema [ ] sub schema fields = new resource field schema [ sub fields . size ( ) ] ; int i = num ; for ( required field sub field : sub fields ) { sub schema fields [ i ++ ] = create resource field schema ( sub field ) ; } resource schema sub schema = new resource schema ( ) ; sub schema . set fields ( sub schema fields ) ; schema . set schema ( sub schema ) ; } return schema ; }	Creates a new ResourceFieldSchema which reflects data from an input RequiredField.
public static void read fully ( input stream in , byte array output stream out , byte [ ] buffer ) { try { int num read = num ; while ( ( num read = in . read ( buffer , num , buffer . length ) ) != - num ) { out . write ( buffer , num , num read ) ; } out . flush ( ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	Method used to read a protobuf input stream into a byte array.
@ override public tuple get next ( ) throws io { if ( reader == null ) { return null ; } pattern pattern = get pattern ( ) ; matcher matcher = pattern . matcher ( str ) ; object line obj ; string line ; tuple t = null ;	Read the file line by line, returning lines the match the regex in Tuplesbased on the regex match groups.
public static base64 create standard base64 ( ) { try { return base64 . class . get constructor ( int . class ) . new instance ( num ) ; } catch ( security exception e ) { } catch ( no such method exception e ) { } catch ( illegal argument exception e ) { } catch ( instantiation exception e ) { } catch ( illegal access exception e ) { } catch ( invocation target exception e ) { } return new base64 ( ) ; }	Get a instance of standard base64 implementation from apachecommons-codec library.
public static < m extends message > protobuf converter < m > new instance ( class < m > proto class ) { return new protobuf converter < m > ( new type ref < m > ( proto class ) { } ) ; }	Returns a ProtobufConverter for a given Protobuf class.
public boolean read next ( binary writable < m > writable ) throws io { byte [ ] blob = read next proto bytes ( ) ; if ( blob != null ) { writable . set ( proto converter . from bytes ( blob ) ) ; return bool ; } return bool ; }	Returns true if new proto object was read into writable, false other wise.
public byte [ ] read next proto bytes ( ) throws io { while ( bool ) { if ( ! setup new block if needed ( ) ) { return null ; } int blob index = cur blobs . size ( ) - num left to read this block ; num left to read this block -- ; byte [ ] blob = cur blobs . get ( blob index ) . to byte array ( ) ; if ( blob . length == num && skip empty records ) { continue ; } return blob ; } }	Return byte blob for the next proto object. null indicates end of stream;.
public boolean read next proto bytes ( bytes writable writable ) throws io { byte [ ] blob = read next proto bytes ( ) ; if ( blob != null ) { writable . set ( blob , num , blob . length ) ; return bool ; } return bool ; }	returns true if bytes for next object are written to writable, falseother wise.
public static task attempt context new task attempt context ( configuration conf , id task attempt id ) { return ( task attempt context ) new instance ( task context constructor , conf , task attempt id ) ; }	Creates TaskAttempContext from a JobConf and jobId using the correctconstructor for based on Hadoop version.
public static map context new map context ( configuration conf , id task attempt id , record reader record reader , record writer record writer , output committer output committer , status reporter status reporter , input split input split ) { return ( map context ) new instance ( map context constructor , conf , task attempt id , record reader , record writer , output committer , status reporter , input split ) ; }	Instantiates MapContext under Hadoop 1 and MapContextImpl under Hadoop 2.
public static < m extends t < ? , ? > > thrift writable < m > new instance ( class < m > t class ) { return new thrift writable < m > ( new type ref < m > ( t class ) { } ) ; }	Returns a ThriftWritable for a given Thrift class.
@ suppress warnings ( str ) public t new instance ( ) throws no such method exception , illegal access exception , invocation target exception , instantiation exception { if ( constructor == null ) { constructor = get raw class ( ) . get constructor ( ) ; } return ( t ) constructor . new instance ( ) ; }	Use the typeRef's parameter to create a new instance of the TypeRef's template parameter.
public t safe new instance ( ) { try { return new instance ( ) ; } catch ( no such method exception e ) { throw new illegal argument exception ( e ) ; } catch ( illegal access exception e ) { throw new illegal argument exception ( e ) ; } catch ( invocation target exception e ) { throw new illegal argument exception ( e ) ; } catch ( instantiation exception e ) { throw new illegal argument exception ( e ) ; } }	The cheap, ugly version of the above, for when you don't want to catch 900 exceptions atthe calling site.
public message . builder get builder ( class < ? extends t < ? , ? > > thrift class ) { return message builder map . get ( proto message type ( thrift class ) ) . clone ( ) ; }	For the given thriftClass, return a Protobufs builder to build a similar protobuf class.
private message . builder map entry proto builder ( t descriptor , field field ) { return message builder map . get ( map proto message type ( descriptor , field ) ) . clone ( ) ; }	Return Protobufs builder for a Map field.
private descriptor protos . descriptor proto . builder map descriptor proto builder ( field field , string type name ) throws descriptor validation exception { descriptor protos . descriptor proto . builder map builder = descriptor protos . descriptor proto . new builder ( ) . set name ( type name ) ; field key field = field . get map key field ( ) ; field value field = field . get map value field ( ) ; descriptor protos . field descriptor proto . builder key builder = map key proto builder ( ) ; descriptor protos . field descriptor proto . builder value builder = map value proto builder ( ) ; set builder type from field ( key field , key builder ) ; set builder type from field ( value field , value builder ) ; map builder . add field ( key builder . build ( ) ) ; map builder . add field ( value builder . build ( ) ) ; return map builder ; }	Generate a DescriptorProto.Builder for the Message type that will be usedto represent the entries of the input Map field.
private string resolve message type name ( t descriptor ) throws descriptor validation exception { string type name = proto message type ( descriptor . get thrift class ( ) ) ;	For a TStructDescriptor, resolves the typeName and optionally converts and memoizes it'sschema.
@ suppress warnings ( str ) public message convert ( t thrift obj ) { return do convert ( ( t < ? , ? > ) preconditions . check not null ( thrift obj , str ) ) ; }	Convert a thrift object to a protobuf message.
@ suppress warnings ( str ) public < f extends t > message do convert ( t < ? , f > thrift obj ) { if ( thrift obj == null ) { return null ; } class < t < ? , f > > clazz = ( class < t < ? , f > > ) thrift obj . get class ( ) ; check state ( clazz ) ; message . builder builder = get builder ( clazz ) ; t field desc = t . get instance ( clazz ) ; int field id = num ; for ( field t field : field desc . get fields ( ) ) {	conver TBase object to Message object.
private message build map entry message ( message . builder map builder , field field , object map key , object map value ) { field descriptor key field descriptor = map builder . get descriptor for type ( ) . find field by name ( map key field name ) ; field descriptor value field descriptor = map builder . get descriptor for type ( ) . find field by name ( map value field name ) ; boolean is key struct = field . get map key field ( ) . is struct ( ) ; boolean is value struct = field . get map value field ( ) . is struct ( ) ; object converted key ; if ( is key struct ) { converted key = do convert ( ( t < ? , ? > ) map key ) ; } else { converted key = sanitize raw value ( map key , field . get map key field ( ) ) ; } object converted value ; if ( is value struct ) { converted value = do convert ( ( t < ? , ? > ) map value ) ; } else { converted value = sanitize raw value ( map value , field . get map value field ( ) ) ; } map builder . set field ( key field descriptor , converted key ) ; map builder . set field ( value field descriptor , converted value ) ; return map builder . build ( ) ; }	Builds a Message that contains the key value pair of a Map entry.
private string map proto message type ( t descriptor , field field ) { return string . format ( str , proto message type ( descriptor . get thrift class ( ) ) , field . get name ( ) ) ; }	name the proto message used for Map types after the thrift class name of the enclosingstruct and the field name.
public static void walk path ( path path , file system fs , path filter filter , path visitor visitor ) throws io { file status file status = fs . get file status ( path ) ; if ( filter . accept ( path ) ) { visitor . visit ( file status ) ; } if ( file status . is dir ( ) ) { file status [ ] children = fs . list status ( path ) ; for ( file status child status : children ) { walk path ( child status . get path ( ) , fs , filter , visitor ) ; } } }	Recursively walk a path applying visitor to each path accepted byfilter.
public static void collect paths ( path path , file system fs , path filter filter , final list < path > accumulator ) throws io { walk path ( path , fs , filter , new path visitor ( ) { @ override public void visit ( file status file status ) { accumulator . add ( file status . get path ( ) ) ; } } ) ; }	Recursively walk a path, adding paths that are accepted by filter to accumulator.
public static void set column number ( configuration conf , int column num ) { assert column num > num ; conf . set int ( rc . column number conf str , column num ) ; }	set number of columns into the given configuration.
private static void update job conf for local settings ( job conf conf ) { string local set compression enabled = conf . get ( compress enable ) ; if ( local set compression enabled != null ) { conf . set ( mr compress enable , local set compression enabled ) ; } string local set compression type = conf . get ( compress type ) ; if ( local set compression type != null ) { conf . set ( mr compress type , local set compression type ) ; } string local set compression codec = conf . get ( compress codec ) ; if ( local set compression codec != null ) { conf . set ( mr compress codec , local set compression codec ) ; } }	We can allow overriding the compression settings for just this scheme here.
public static method parse method for ( class < message > klass ) { try { return klass . get method ( str , new class [ ] { input stream . class } ) ; } catch ( security exception e ) { throw new runtime exception ( e ) ; } catch ( no such method exception e ) { throw new runtime exception ( e ) ; } }	Parse the method for a message.
public static message parse message ( method parse method , input stream in ) { try { return ( message ) parse method . invoke ( null , in ) ; } catch ( illegal argument exception e ) { throw new runtime exception ( e ) ; } catch ( illegal access exception e ) { throw new runtime exception ( e ) ; } catch ( invocation target exception e ) { throw new runtime exception ( e ) ; } }	Parse the message in a given InputStream using scpecified Method.
public static message parse message ( class < message > klass , input stream in ) { method parse method = parse method for ( klass ) ; return parse message ( parse method , in ) ; }	Parse the message in a given Message container.
@ override @ suppress warnings ( str ) public void put next ( tuple tuple ) throws io { json . clear ( ) ; if ( tuple != null && tuple . size ( ) >= num ) { map < string , object > map = ( map < string , object > ) tuple . get ( num ) ; if ( keys to keep == null ) { json . put all ( map ) ; } else { for ( map . entry < string , object > entry : map . entry set ( ) ) { if ( keys to keep . contains ( entry . get key ( ) ) ) { json . put ( entry . get key ( ) , entry . get value ( ) ) ; } } } } try { writer . write ( null , new text ( json . to string ( ) ) ) ; } catch ( interrupted exception e ) {	The first element is expected to be a map, or null.
public static < m extends message > void set class conf ( class < m > proto class , configuration job conf ) { protobufs . set class conf ( job conf , lzo protobuf b64 line output format . class , proto class ) ; }	Sets an internal configuration in jobConf so that remote Tasksinstantiate appropriate object for this generic class based on protoClass.
private void set type ref ( configuration conf ) { string class name = conf . get ( class conf key ) ; if ( class name == null ) { throw new runtime exception ( class conf key + str ) ; } class < ? > clazz = null ; try { clazz = conf . get class by name ( class name ) ; } catch ( class not found exception e ) { throw new runtime exception ( str + class name + str , e ) ; } type ref = new type ref < m > ( clazz ) { } ; }	set typeRef from conf.
protected void check container size ( int size ) throws t { if ( size < num ) { throw new t ( str + size ) ; } if ( check read length && ( read length - size ) < num ) { throw new t ( str + read length + str + size ) ; } }	Check if the container size is valid.NOTE: This assumes that the elements are one byte each.
public void set pattern ( byte [ ] pattern ) { pattern = arrays . copy of ( pattern , pattern . length ) ; borders = new int [ pattern . length + num ] ; pre process ( ) ; }	Sets a new pattern for this StreamSearcher to use.
public static string underscore ( string word ) { string first pattern = str ; string second pattern = str ; string replacement pattern = str ;	Underscore the given word.
public static string ordinalize ( int n ) { int mod100 = n % num ; if ( mod100 == num || mod100 == num || mod100 == num ) { return string . value of ( n ) + str ; } switch ( n % num ) { case num : return string . value of ( n ) + str ; case num : return string . value of ( n ) + str ; case num : return string . value of ( n ) + str ; default : return string . value of ( n ) + str ; } }	Return the ordinal for the given number.
public static < m extends message > protobuf writable < m > new instance ( class < m > t class ) { return new protobuf writable < m > ( new type ref < m > ( t class ) { } ) ; }	Returns a ProtobufWritable for a given Protobuf class.
public static c new instance ( final string field definition file ) { return new c ( ) { @ override public record reader < long writable , map writable > create record reader ( input split split , task attempt context context ) throws io , interrupted exception { record reader < long writable , map writable > reader = new c ( ) { @ override protected string get field definition file ( ) { return field definition file ; } } ; reader . initialize ( split , context ) ; return reader ; } } ; }	Use this method to create valid instances of LzoW3CLogInputFormat.
public static void set output format ( class < ? > real output format class , configuration conf ) { conf . set class ( str , deprecated output format wrapper . class , org . apache . hadoop . mapred . output format . class ) ; hadoop utils . set class conf ( conf , class conf key , real output format class ) ; }	For cases where we need to set hadoop1 output format in a hadoop2 Configuration object.
public boolean match ( string word ) { int flags = ignore case ? pattern . case insensitive : num ; return pattern . compile ( pattern , flags ) . matcher ( word ) . find ( ) ; }	Does the given word match?.
public string replace ( string word ) { int flags = ignore case ? pattern . case insensitive : num ; return pattern . compile ( pattern , flags ) . matcher ( word ) . replace all ( replacement ) ; }	Replace the word with its pattern.
public static string pluralize ( string word ) { if ( is uncountable ( word ) ) { return word ; } else { for ( inflection inflection : plurals ) { if ( inflection . match ( word ) ) { return inflection . replace ( word ) ; } } return word ; } }	Return the pluralized version of a word.
public static boolean is uncountable ( string word ) { for ( string w : uncountables ) { if ( w . equals ignore case ( word ) ) { return bool ; } } return bool ; }	Return true if the word is uncountable.
protected data output stream get output stream ( task attempt context job ) throws io , interrupted exception { return lzo utils . get indexed lzo output stream ( hadoop compat . get configuration ( job ) , get default work file ( job , lzop codec . default lzo extension ) ) ; }	Helper method to create lzo output file needed to create RecordWriter.
private static < w extends writable > void verify writable class ( class < w > writable class , boolean is key class , writable converter < w > writable converter ) { preconditions . check not null ( writable class , str + str + str , is key class ? str : str , writable converter . get class ( ) . get name ( ) ) ; }	Tests validity of Writable class, ensures consistent error message for both key and valuetests.
public static < m extends t < ? , ? > > thrift converter < m > new instance ( class < m > t class ) { return new thrift converter < m > ( new type ref < m > ( t class ) { } ) ; }	Returns a ThriftConverter for a given Thrift class.
public static class < ? > get class ( string class name ) { try { return pig context . resolve class name ( class name ) ; } catch ( io e ) { throw new runtime exception ( str + class name , e ) ; } }	Returns class using Pig's class loader.
public static < t extends t < ? , ? > > type ref < t > get thrift type ref ( string thrift class name ) { return thrift utils . get type ref ( get class ( thrift class name ) ) ; }	Returns TypeRef using Pig class loader.
public static array list < integer > find columns to read ( configuration conf , list < integer > curr field ids , columnar metadata stored info ) throws io { array list < integer > columns to read = lists . new array list ( ) ;	Returns list of columns that need to be read from the RCFile.These columns are the intersection of currently required columns andcolumns stored in the file.If any required column does not exist in the file, we need to readthe "unknown fields" column, which is usually the last last one.
public static < m extends t < ? , ? > > void set class conf ( class < m > thrift class , configuration job conf ) { thrift utils . set class conf ( job conf , lzo thrift b64 line output format . class , thrift class ) ; }	Sets an internal configuration in jobConf so that remote Tasksinstantiate appropriate object for this generic class based on thriftClass.
private string execute http request ( http uri request request ) { try {	Execute the given HTTP request.
private void add authorization ( http request request , reddit token r token ) { request . add header ( str , r token . get token type ( ) + str + r token . get access token ( ) ) ; }	Add authorization to the HTTP request.
public void validate ( object response ) throws reddit parse exception {	Validate that it is indeed the starting of a listing of reddit things.
private thing parse thing ( kind kind , json data ) {	Parse the data into a thing if possible.
public list < mixed listing element > parse ( string json text ) throws reddit parse exception {	Parse JSON received from reddit into a list of submissions and comments.This parser expects the JSON to be of a listing of submissions and comments.
public static string format comma separated list ( list < string > list ) { string builder builder = new string builder ( ) ; for ( int i = num ; i < list . size ( ) ; i ++ ) { if ( i != num ) { builder . append ( str ) ; } builder . append ( list . get ( i ) ) ; } return builder . to string ( ) ; }	Format a comma separated list of the given list.
private void wait if needed ( ) {	Wait if required.
private void add basic authentication ( o request , reddit app app ) { string auth string = app . get client id ( ) + str + app . get client secret ( ) ; string auth string enc = datatype converter . print base64 binary ( auth string . get bytes ( ) ) ; request . add header ( header authorization , str + auth string enc ) ; }	Add the basic authentication protocol to the OAuth request usingthe credentials of the Reddit application provided.
public void refresh ( o json token ) { this . access token = token . get access token ( ) ; this . expiration = current time seconds ( ) + token . get expires in ( ) ; this . expiration span = token . get expires in ( ) ; this . scopes = new reddit token complete scope ( token . get scope ( ) ) ; this . token type = token . get param ( param token type ) ; }	Refresh this reddit token with data received from the new token.
public static string print comment tree ( list < comment tree element > cs ) { string builder builder = new string builder ( ) ; for ( comment tree element c : cs ) { builder . append ( print comment tree ( c , num ) ) ; } return builder . to string ( ) ; }	Get printable version of the given comment tree.
public static integer safe json to integer ( object obj ) { integer int value = null ; try { string str = safe json to string ( obj ) ; int value = str != null ? integer . parse int ( str ) : null ; } catch ( number format exception e ) { logger . warn ( str , e ) ; } return int value ; }	Safely converts an object into an integer.
public static double safe json to double ( object obj ) { double double value = null ; try { string str = safe json to string ( obj ) ; double value = str != null ? double . parse double ( str ) : null ; } catch ( number format exception e ) { logger . warn ( str , e ) ; } return double value ; }	Safely converts an object into an double.
public static boolean safe json to boolean ( object obj ) { string str = safe json to string ( obj ) ; boolean boolean value = str != null ? boolean . parse boolean ( str ) : null ; return boolean value ; }	Safely converts an object into an boolean.
public static long safe json to long ( object obj ) { long long value = null ; try { string str = safe json to string ( obj ) ; long value = str != null ? long . parse long ( str ) : null ; } catch ( number format exception e ) { logger . warn ( str , e ) ; } return long value ; }	Safely converts an object into an long.
protected list < comment tree element > parse recursive ( json main ) throws reddit parse exception { list < comment tree element > comment tree = new array list < comment tree element > ( ) ;	Parse a JSON object consisting of comments and add themto the already existing list of comments.
public list < subreddit > parse ( string json text ) throws reddit parse exception {	Parse JSON received from reddit into a list of subreddits.This parser expects the JSON to be of a listing of subreddits.
public static string signature ( string endpoint , map < string , string > params , string client secret ) throws instagram exception { secret key spec key spec = new secret key spec ( client secret . get bytes ( utf 8 ) , hmac sh ) ;	signature returns the HmacSHA256 encoded signature used for signed Instagram requests.
public static map < string , string > sort ( map < string , string > map ) { preconditions . check not null ( map , str ) ; map < string , string > sorted = new linked hash map < string , string > ( ) ; for ( string key : get sorted keys ( map ) ) { sorted . put ( key , map . get ( key ) ) ; } return sorted ; }	Sorts a Map.
public oembed information get oembed information ( string url ) throws instagram exception { string api method = string . format ( methods . oembed information , url ) ; return create instagram object ( verbs . get , oembed information . class , api method , null ) ; }	Returns information about the media associated with that link.
private static < t > t create instagram object ( verbs verbs , class < t > clazz , string method name , map < string , string > params ) throws instagram exception { response response ; try { response = get api response ( verbs , method name , params ) ; } catch ( io e ) { throw new instagram exception ( str , e ) ; } if ( response . get code ( ) >= num && response . get code ( ) < num ) { return create object from response ( clazz , response . get body ( ) ) ; } throw handle instagram error ( response ) ; }	Create an Instagram object based on class-name and response.
private static < t > t create object from response ( class < t > clazz , final string response ) throws instagram exception { gson gson = new gson ( ) ; t object ; try { object = gson . from json ( response , clazz ) ; } catch ( exception e ) { throw new instagram exception ( str + clazz . get name ( ) , e ) ; } return object ; }	Creates an object from the JSON response and the class which the object would be mapped to.
public static void check both not null ( object object1 , object object2 , string error msg ) { check ( ! ( object1 == null && object2 == null ) , error msg ) ; }	Checks that at least one of object1 or object2 is not null.
public static void check empty string ( string string , string error msg ) { check ( string utils . is not blank ( string ) , error msg ) ; }	Checks that a string is not null or empty.
public static void check valid url ( string url , string error msg ) { check empty string ( url , error msg ) ; check ( is url ( url ) , error msg ) ; }	Checks that a URL is valid.
public static void check valid o ( string url , string error msg ) { check empty string ( url , error msg ) ; if ( url . to lower case ( ) . compare to ignore case ( o . out of band ) != num ) { check ( is url ( url ) , error msg ) ; } }	Checks that a URL is a valid OAuth callback.
@ deprecated public instagram client get signed header instagram ( token access token , string ip address ) { return new instagram ( access token . get token ( ) , config . get api secret ( ) , ip address ) ; }	Return an Instagram object with enforced signed header.
public static void configure connection settings ( final request request , final instagram config config ) { request . set connect timeout ( config . get connection timeout mills ( ) , time unit . milliseconds ) ; request . set read timeout ( config . get read timeout mills ( ) , time unit . milliseconds ) ;	Configure the request with the connection settings of config.
public string get body contents ( ) { try { return new string ( get byte body contents ( ) , get charset ( ) ) ; } catch ( unsupported encoding exception uee ) { throw new o ( str + charset , uee ) ; } }	Returns the body of the request.
public static void pretty print json ( logger logger , string json string ) { if ( logger . is debug enabled ( ) ) {	Pretty print the JSON response in the logs.
public instagram subscription callback ( string callback ) { preconditions . check valid url ( callback , str ) ; this . params . put ( constants . callback url , callback ) ; return this ; }	Configures the callback url.
public instagram subscription client id ( string client id ) { preconditions . check empty string ( client id , str ) ; this . params . put ( constants . client id , client id ) ; return this ; }	Configures the clientId.
public instagram subscription client secret ( string client secret ) { preconditions . check empty string ( client secret , str ) ; this . params . put ( constants . client secret , client secret ) ; return this ; }	Configure the clientSecret.
public instagram subscription object ( subscription type type ) { this . params . put ( constants . subscription type , type . to string ( ) ) ; return this ; }	Configure the subscription type.
public instagram subscription verify token ( string verify token ) { preconditions . check empty string ( verify token , str ) ; this . params . put ( constants . verify token , verify token ) ; return this ; }	Configure the verifyToken for the subscription.
public instagram subscription aspect ( string aspect ) { preconditions . check empty string ( aspect , str ) ; this . params . put ( constants . aspect , aspect ) ; return this ; }	Configure the aspect for the subscription.
public instagram subscription latitute ( string latitude ) { preconditions . check valid lat long ( latitude , str ) ; this . params . put ( constants . latitude , latitude ) ; return this ; }	Configure the latitude for geography subscription.
public instagram subscription longitude ( string longitude ) { preconditions . check valid lat long ( longitude , str ) ; this . params . put ( constants . longitude , longitude ) ; return this ; }	Configure the longitude for geography subscription.
public instagram subscription radius ( string radius ) { preconditions . check valid radius ( radius , str ) ; this . params . put ( constants . radius , radius ) ; return this ; }	Configure the radius for geography subscription.
public subscription response delete subscription ( string id ) throws instagram exception { final o request = prepare o ( verbs . delete ) ; request . add querystring parameter ( str , id ) ; try { final response response = request . send ( ) ; return get subscription response ( response . get body ( ) ) ; } catch ( io e ) { throw new instagram exception ( str + id + str , e ) ; } }	Deletes a subscription with the specified identifier.
public subscription response delete all subscription ( ) throws instagram exception { final o request = prepare o ( verbs . delete ) ; request . add querystring parameter ( constants . subscription type , str ) ; try { final response response = request . send ( ) ; return get subscription response ( response . get body ( ) ) ; } catch ( io e ) { throw new instagram exception ( str , e ) ; } }	Deletes all the known subscription.
public subscriptions list response get subscription list ( ) throws instagram exception { final o request = prepare o ( verbs . get ) ; try { final response response = request . send ( ) ; return get subscriptions list response ( response . get body ( ) ) ; } catch ( io e ) { throw new instagram exception ( str , e ) ; } }	Returns the currently active subscription.
public static string form url ( map < string , string > map ) { preconditions . check not null ( map , str ) ; return ( map . size ( ) <= num ) ? empty string : do form url encode ( map ) ; }	Turns a map into a form-urlencoded string.
public static string percent encode ( string string ) { string encoded = form url ( string ) ; for ( encoding rule rule : encoding rules ) { encoded = rule . apply ( encoded ) ; } return encoded ; }	Percent encodes a string.
public static string append parameters to query string ( string url , map < string , string > params ) { preconditions . check not null ( url , str ) ; string query string = url . form url ( params ) ; if ( query string . equals ( empty string ) ) { return url ; } else { url += ( url . index of ( query string separator ) != - num ) ? param separator : query string separator ; url += query string ; return url ; } }	Append given parameters to the query string of the url.
public static string concat sorted percent encoded params ( map < string , string > params ) { string builder result = new string builder ( ) ; for ( map . entry < string , string > entry : params . entry set ( ) ) { result . append ( entry . get key ( ) ) . append ( pair separator ) ; result . append ( entry . get value ( ) ) . append ( param separator ) ; } return result . to string ( ) . substring ( num , result . length ( ) - num ) ; }	Concats a key-value map into a querystring-like String.
public static map < string , string > query string to map ( string query string ) { map < string , string > result = new hash map < string , string > ( ) ; if ( ( query string != null ) && ( query string . length ( ) > num ) ) { for ( string param : query string . split ( param separator ) ) { string pair [ ] = param . split ( pair separator ) ; string key = form url ( pair [ num ] ) ; string value = ( pair . length > num ) ? form url ( pair [ num ] ) : empty string ; result . put ( key , value ) ; } } return result ; }	Parses and form-urldecodes a querystring-like string into a map.
public void throw exception ( ) throws instagram exception { if ( error meta != null ) { string msg = error meta . get error type ( ) + str + error meta . get error message ( ) ; switch ( error meta . get code ( ) ) { case num : throw new instagram bad request exception ( error meta . get error type ( ) , msg , this . headers ) ; case num : throw new instagram rate limit exception ( error meta . get error type ( ) , msg , this . headers ) ; default : throw new instagram exception ( error meta . get error type ( ) , msg , this . headers ) ; } } else { throw new instagram exception ( str , this . headers ) ; } }	Throw instagram exception to the client.
public void add trade ( decimal trade volume , decimal trade price ) { if ( open price == null ) { open price = trade price ; } close price = trade price ; if ( max price == null ) { max price = trade price ; } else { max price = max price . is less than ( trade price ) ? trade price : max price ; } if ( min price == null ) { min price = trade price ; } else { min price = min price . is greater than ( trade price ) ? trade price : min price ; } volume = volume . plus ( trade volume ) ; amount = amount . plus ( trade volume . multiplied by ( trade price ) ) ; trades ++ ; }	Adds a trade at the end of tick period.
private void increase length to ( int index , int max length ) { if ( highest result index > - num ) { int new results count = math . min ( index - highest result index , max length ) ; if ( new results count == max length ) { results . clear ( ) ; results . add all ( collections . < t > n copies ( max length , null ) ) ; } else if ( new results count > num ) { results . add all ( collections . < t > n copies ( new results count , null ) ) ; remove exceeding results ( max length ) ; } } else {	Increases the size of cached results buffer.
private decimal calculate maximum drawdown ( time series series , cash flow cash flow ) { decimal maximum drawdown = decimal . zero ; decimal max peak = decimal . zero ; if ( ! series . is empty ( ) ) {	Calculates the maximum drawdown from a cash flow over a series.
public static list < integer > get split begin indexes ( time series series , duration split duration ) { array list < integer > begin indexes = new array list < > ( ) ; int begin index = series . get begin index ( ) ; int end index = series . get end index ( ) ;	Builds a list of split indexes from splitDuration.
private void calculate regression line ( int start index , int end index ) {	Calculates the regression line.
public order operate ( int index , decimal price , decimal amount ) { order order = null ; if ( is new ( ) ) { order = new order ( index , starting type , price , amount ) ; entry = order ; } else if ( is opened ( ) ) { if ( index < entry . get index ( ) ) { throw new illegal state exception ( str ) ; } order = new order ( index , starting type . complement type ( ) , price , amount ) ; exit = order ; } return order ; }	Operates the trade at the index-th position.
private static org . jfree . data . time . time series build chart time series ( time series tick series , indicator < decimal > indicator , string name ) { org . jfree . data . time . time series chart time series = new org . jfree . data . time . time series ( name ) ; for ( int i = num ; i < tick series . get tick count ( ) ; i ++ ) { tick tick = tick series . get tick ( i ) ; chart time series . add ( new minute ( date . from ( tick . get end time ( ) . to instant ( ) ) ) , indicator . get value ( i ) . to double ( ) ) ; } return chart time series ; }	Builds a JFreeChart time series from a Ta4j time series and an indicator.
private static decimal rand decimal ( decimal min , decimal max ) { decimal random decimal = null ; if ( min != null && max != null && min . is less than ( max ) ) { random decimal = max . minus ( min ) . multiplied by ( decimal . value of ( math . random ( ) ) ) . plus ( min ) ; } return random decimal ; }	Generates a random decimal number between min and max.
private static tick generate random tick ( ) { final decimal max range = decimal . value of ( str ) ;	Generates a random tick.
private void increment acceleration ( ) { if ( acceleration . is greater than or equal ( acceleration threshold ) ) { acceleration = max acceleration ; } else { acceleration = acceleration . plus ( acceleration increment ) ; } }	Increments the acceleration factor.
private decimal calculate sar ( int index ) { decimal previous sar = get value ( index - num ) ; return extreme point . multiplied by ( acceleration ) . plus ( decimal . one . minus ( acceleration ) . multiplied by ( previous sar ) ) ; }	Calculates the SAR.
private void calculate ( trade trade ) { final int entry index = trade . get entry ( ) . get index ( ) ; int begin = entry index + num ; if ( begin > values . size ( ) ) { decimal last value = values . get ( values . size ( ) - num ) ; values . add all ( collections . n copies ( begin - values . size ( ) , last value ) ) ; } int end = trade . get exit ( ) . get index ( ) ; for ( int i = math . max ( begin , num ) ; i <= end ; i ++ ) { decimal ratio ; if ( trade . get entry ( ) . is buy ( ) ) { ratio = time series . get tick ( i ) . get close price ( ) . divided by ( time series . get tick ( entry index ) . get close price ( ) ) ; } else { ratio = time series . get tick ( entry index ) . get close price ( ) . divided by ( time series . get tick ( i ) . get close price ( ) ) ; } values . add ( values . get ( entry index ) . multiplied by ( ratio ) ) ; } }	Calculates the cash flow for a single trade.
private void fill to the end ( ) { if ( time series . get end index ( ) >= values . size ( ) ) { decimal last value = values . get ( values . size ( ) - num ) ; values . add all ( collections . n copies ( time series . get end index ( ) - values . size ( ) + num , last value ) ) ; } }	Fills with last value till the end of the series.
private static void load logger configuration ( ) { logger context context = ( logger context ) logger factory . get i ( ) ; context . reset ( ) ; joran configurator configurator = new joran configurator ( ) ; configurator . set context ( context ) ; try { configurator . do configure ( logback conf file ) ; } catch ( joran exception je ) { logger . get logger ( strategy execution logging . class . get name ( ) ) . log ( level . severe , str , je ) ; } }	Loads the Logback configuration from a resource file.Only here to avoid polluting other examples with logs.
private static ohlc create ohlc ( time series series ) { final int nb ticks = series . get tick count ( ) ; date [ ] dates = new date [ nb ticks ] ; double [ ] opens = new double [ nb ticks ] ; double [ ] highs = new double [ nb ticks ] ; double [ ] lows = new double [ nb ticks ] ; double [ ] closes = new double [ nb ticks ] ; double [ ] volumes = new double [ nb ticks ] ; for ( int i = num ; i < nb ticks ; i ++ ) { tick tick = series . get tick ( i ) ; dates [ i ] = new date ( tick . get end time ( ) . to epoch second ( ) * num ) ; opens [ i ] = tick . get open price ( ) . to double ( ) ; highs [ i ] = tick . get max price ( ) . to double ( ) ; lows [ i ] = tick . get min price ( ) . to double ( ) ; closes [ i ] = tick . get close price ( ) . to double ( ) ; volumes [ i ] = tick . get volume ( ) . to double ( ) ; } ohlc dataset = new default high low dataset ( str , dates , highs , lows , opens , closes , volumes ) ; return dataset ; }	Builds a JFreeChart OHLC dataset from a ta4j time series.
private static time series collection create additional dataset ( time series series ) { close price indicator indicator = new close price indicator ( series ) ; time series collection dataset = new time series collection ( ) ; org . jfree . data . time . time series chart time series = new org . jfree . data . time . time series ( str ) ; for ( int i = num ; i < series . get tick count ( ) ; i ++ ) { tick tick = series . get tick ( i ) ; chart time series . add ( new second ( new date ( tick . get end time ( ) . to epoch second ( ) * num ) ) , indicator . get value ( i ) . to double ( ) ) ; } dataset . add series ( chart time series ) ; return dataset ; }	Builds an additional JFreeChart dataset from a ta4j time series.
private static void add cash flow axis ( xy plot , time series collection dataset ) { final number axis cash axis = new number axis ( str ) ; cash axis . set auto range includes zero ( bool ) ; plot . set range axis ( num , cash axis ) ; plot . set dataset ( num , dataset ) ; plot . map dataset to range axis ( num , num ) ; final xy cash flow renderer = new xy ( ) ; cash flow renderer . set series paint ( num , color . blue ) ; plot . set renderer ( num , cash flow renderer ) ; }	Adds the cash flow axis to the plot.
private static void display chart ( j chart ) {	Displays a chart in a frame.
private void remove exceeding ticks ( ) { int tick count = ticks . size ( ) ; if ( tick count > maximum tick count ) {	Removes the N first ticks which exceed the maximum tick count.
private static list < tick > build empty ticks ( zoned date time begin time , zoned date time end time , int duration ) { list < tick > empty ticks = new array list < > ( ) ; duration tick duration = duration . of seconds ( duration ) ; zoned date time tick end time = begin time ; do { tick end time = tick end time . plus ( tick duration ) ; empty ticks . add ( new base tick ( tick duration , tick end time ) ) ; } while ( tick end time . is before ( end time ) ) ; return empty ticks ; }	Builds a list of empty ticks.
void destroy ( ) { destroyed = bool ; for ( map < string , managed observable < ? > > observable map : group map . values ( ) ) { for ( managed observable < ? > managed observable : observable map . values ( ) ) { managed observable . cancel ( ) ; } observable map . clear ( ) ; } group map . clear ( ) ; }	Cancels all subscriptions and releases references to Observables and Observers.
public void on save instance state ( bundle out state ) { has saved state = bool ; out state . put parcelable ( key state , new state ( observable manager . id ( ) , group . id ( ) ) ) ; }	Call this method from your Activity or Fragment's onSaveInstanceState method.
final void signal event ( watch event . kind < path > kind , path context ) { post ( new event < > ( kind , num , context ) ) ; signal ( ) ; }	WatchEvent not WatchEvent.Kind.
public completable future < void > watch async ( executor executor ) { return completable future . supply async ( ( ) -> { watch ( ) ; return null ; } , executor ) ; }	Asynchronously watch the directories.
private void register ( path directory , boolean use file tree modifier ) throws io { logger . debug ( str , directory ) ; watchable watchable = is mac ? new watchable path ( directory ) : directory ; watch event . modifier [ ] modifiers = use file tree modifier ? new watch event . modifier [ ] { extended watch event modifier . file tree } : new watch event . modifier [ ] { } ; watch event . kind < ? > [ ] kinds = new watch event . kind < ? > [ ] { entry create , entry delete , entry modify } ; watch key watch key = watchable . register ( watch service , kinds , modifiers ) ; key roots . put ( watch key , directory ) ; }	Internal method to be used by registerAll.
private class loader get class loader ( ) throws mojo execution exception { list < path > classpath ur = new array list < > ( ) ; this . add relevant plugin dependencies to classpath ( classpath ur ) ; this . add relevant project dependencies to classpath ( classpath ur ) ; this . add additional classpath elements ( classpath ur ) ; try { return loader finder . find ( classpath ur , main class ) ; } catch ( null pointer exception | io e ) { throw new mojo execution exception ( e . get message ( ) , e ) ; } }	Set up a classloader for the execution of the main class.
private void add relevant plugin dependencies to classpath ( list < path > path ) throws mojo execution exception { if ( has commandline args ( ) ) { arguments = parse commandline args ( ) ; } for ( artifact class path element : this . determine relevant plugin dependencies ( ) ) { get log ( ) . debug ( str + class path element . get artifact id ( ) + str ) ; path . add ( class path element . get file ( ) . to path ( ) ) ; } }	Add any relevant project dependencies to the classpath.
private void add relevant project dependencies to classpath ( list < path > path ) throws mojo execution exception { if ( this . include project dependencies ) { get log ( ) . debug ( str ) ; list < artifact > artifacts = new array list < > ( ) ; list < path > the classpath files = new array list < > ( ) ; collect project artifacts and classpath ( artifacts , the classpath files ) ; for ( path classpath file : the classpath files ) { get log ( ) . debug ( str + classpath file ) ; path . add ( classpath file ) ; } for ( artifact class path element : artifacts ) { get log ( ) . debug ( str + class path element . get artifact id ( ) + str ) ; path . add ( class path element . get file ( ) . to path ( ) ) ; } } else { get log ( ) . debug ( str ) ; } }	Add any relevant project dependencies to the classpath.
private set < artifact > resolve executable dependencies ( artifact executable pom artifact ) throws mojo execution exception { set < artifact > executable dependencies = new linked hash set < > ( ) ; try { project building request building request = get session ( ) . get project building request ( ) ; maven project executable project = this . project builder . build ( executable pom artifact , building request ) . get project ( ) ; for ( artifact result artifact result : dependency resolver . resolve dependencies ( building request , executable project . get model ( ) , null ) ) { executable dependencies . add ( artifact result . get artifact ( ) ) ; } } catch ( exception ex ) { throw new mojo execution exception ( str + str , ex ) ; } return executable dependencies ; }	Resolve the executable dependencies for the specified project.
protected artifact find executable artifact ( ) throws mojo execution exception {	Examine the plugin dependencies to find the executable artifact.
private void handle working directory ( ) throws mojo execution exception { if ( working directory == null ) { working directory = basedir ; } if ( ! working directory . exists ( ) ) { get log ( ) . debug ( str + working directory . get absolute path ( ) + str ) ; if ( ! working directory . mkdirs ( ) ) { throw new mojo execution exception ( str + working directory . get absolute path ( ) + str ) ; } } }	This is a convenient method to make the execute method a little bit more readable.
public local date get calendar service range start ( ) { int start date = num ; for ( service service : feed . services . values ( ) ) { if ( service . calendar == null ) continue ;	returns null for schedules without calendar service schedules.
public d get bounds ( ) { d ret = null ; for ( stop stop : feed . stops . values ( ) ) {	Get the bounding box of this GTFS feed.We use a Rectangle2D rather than a Geotools envelope because GTFS is always in WGS 84.Note that stops do not have agencies in GTFS.
private boolean check distance and time ( double distance meters , double travel time seconds , stop time stop time ) { boolean good = bool ;	This just pulls some of the range checking logic out of the main trip checking loop so it's more readable.
private table load result load ( table table ) {	This wraps the main internal table loader method to catch exceptions and figure out how many errors happened.
private int get table size ( table table ) { zip entry zip entry = zip . get entry ( table . name + str ) ; if ( zip entry == null ) return num ; return ( int ) zip entry . get size ( ) ; }	Get the uncompressed file size in bytes for the specified GTFS table.
private void set field to null ( boolean postgres text , string [ ] transformed strings , int field index , field field ) { if ( postgres text ) transformed strings [ field index + num ] = postgres null text ;	Sets field to null in statement or string array depending on whether postgres is being used.
public snapshot result copy tables ( ) {	Copy primary entity tables as well as Pattern and PatternStops tables.
private boolean table exists ( string namespace , string table name ) {	Helper method to determine if a table exists within a namespace.
private void add editor specific fields ( connection connection , string table prefix , table table ) throws sql { log . info ( str , table prefix + table . name ) ; statement statement = connection . create statement ( ) ; for ( field field : table . editor fields ( ) ) {	Add columns for any required, optional, or editor fields that don't already exist as columns on the table.This method contains a SQL statement that requires PostgreSQL 9.6+.
private void register snapshot ( ) { try {	Add a line to the list of loaded feeds to record the snapshot and which feed the snapshot replicates.
public string get id ( ) { string builder sb = new string builder ( ) ; sb . append ( trip id ) ; sb . append ( str ) ; sb . append ( convert to gtfs time ( start time ) ) ; sb . append ( str ) ; sb . append ( convert to gtfs time ( end time ) ) ; sb . append ( str ) ; sb . append ( string . format ( str , headway secs / num , headway secs % num ) ) ; if ( exact times == num ) sb . append ( str ) ; return sb . to string ( ) ; }	Frequency entries have no ID in GTFS so we define one based on the fields in the frequency entry.It is possible to have two identical frequency entries in the GTFS, which under our understanding of the situationwould mean that two sets of vehicles were randomly running the same trip at the same headway, but uncorrelatedwith each other, which is almost certain to be an error.
public int execute remaining ( ) throws sql { if ( current batch size > num ) { total records processed += current batch size ; prepared statement . execute batch ( ) ; current batch size = num ; }	Execute any remaining statements and return the total records processed.
private void clean up zip file ( ) { long start time = system . current time millis ( ) ;	Removes any empty zip files from the final zip file.
private table load result export ( table table , string filter sql ) { long start time = system . current time millis ( ) ; table load result table load result = new table load result ( ) ; try { if ( filter sql == null ) { throw new illegal argument exception ( str ) ; } else {	Export a table to the zipOutputStream to be written to the GTFS.
public void register error ( entity entity , gtfs error type ) { error storage . store error ( gtfs . for entity ( entity , error type ) ) ; }	Store an error that affects a single line of a single table.
public void register error ( entity entity , gtfs error type , object bad value ) { error storage . store error ( gtfs . for entity ( entity , error type ) . set bad value ( bad value . to string ( ) ) ) ; }	Store an error that affects a single line of a single table.Add a bad value to it.
public static feed load result export ( string feed id , string out file , data source data source , boolean from editor ) { jdbc gtfs exporter exporter = new jdbc gtfs exporter ( feed id , out file , data source , from editor ) ; feed load result result = exporter . export tables ( ) ; return result ; }	Export a feed ID from the database to a zipped GTFS file in the specified export directory.
public static validation result validate ( string feed id , data source data source ) { feed feed = new feed ( data source , feed id ) ; validation result result = feed . validate ( ) ; return result ; }	Once a feed has been loaded into the database, examine its contents looking for various problems and errors.
public static void delete ( string feed id , data source data source ) throws sql , invalid namespace exception { log . info ( str , feed id ) ; connection connection = null ; try { connection = data source . get connection ( ) ; ensure valid namespace ( feed id ) ;	Deletes all tables for the specified feed.
public gtfs add info ( string key , string value ) { error info . put ( key , value ) ; return this ; }	Add a single key-value pair of supplemental info to this error.
public static gtfs for line ( table table , int line number , gtfs error type , string bad value ) { gtfs error = new gtfs ( table . get entity class ( ) , error type ) ; error . line number = line number ; error . bad value = bad value ; return error ; }	Factory Builder for cases where an entity has not yet been constructed, but we know the line number.
public static gtfs for entity ( entity entity , gtfs error type ) { gtfs error = new gtfs ( entity . get class ( ) , error type ) ; error . line number = entity . id ; error . entity id = entity . get id ( ) ; error . entity sequence number = entity . get sequence number ( ) ; return error ; }	Factory Builder for cases where the entity has already been decoded and an error is discovered during validation.
public static gtfs for feed ( gtfs error type , string bad value ) { return new gtfs ( null , error type ) . set bad value ( bad value ) ; }	Factory Builder for feed-wide error.
public double get pattern speed ( string pattern id , local date date , local time from , local time to ) { list < trip > trips = get trips for date ( pattern id , date ) ; return get average speed for trips ( trips , from , to ) ; }	Gets the pattern speed for a given pattern for a specified date and time window.
public double get average speed for trips ( collection < trip > trips , local time from , local time to ) { t speeds = new t ( ) ; for ( trip trip : trips ) { stop time first stop time = feed . stop times . ceiling entry ( fun . t2 ( trip . trip id , null ) ) . get value ( ) ; local time trip begin time = local time . of second of day ( first stop time . departure time % num ) ;	Get average speed for set of trips that begin within the time window in meters per second.
public local time get start time for trips ( collection < trip > trips ) { int earliest departure = integer . max value ; for ( trip trip : trips ) { stop time st = feed . get ordered stop times for trip ( trip . trip id ) . iterator ( ) . next ( ) ; int dep = st . departure time ;	Get earliest departure time for a set of trips.
public local time get end time for trips ( collection < trip > trips ) { int latest arrival = integer . min value ; for ( trip trip : trips ) { stop time st = feed . get ordered stop times for trip ( trip . trip id ) . iterator ( ) . next ( ) ; if ( st . arrival time >= latest arrival ) { latest arrival = st . arrival time ; } }	Get last arrival time for a set of trips.
public double get pattern distance ( string pattern id ) { pattern pattern = feed . patterns . get ( pattern id ) ; return feed . get trip distance ( pattern . associated trips . iterator ( ) . next ( ) , bool ) ; }	Get distance for a pattern.
public double get average stop spacing ( string pattern id ) { pattern pattern = feed . patterns . get ( pattern id ) ; return get pattern distance ( pattern id ) / pattern . ordered stops . size ( ) ; }	Get average stop spacing for a pattern.
private < e extends entity > void copy entity to sql ( iterable < e > entities , table table ) throws sql { table . create sql table ( connection , namespace , bool ) ; string entity insert sql = table . generate insert sql ( namespace , bool ) ; prepared statement insert statement = connection . prepare statement ( entity insert sql ) ;	Creates table for the specified Table, inserts all entities for the iterable in batches, and, finally, createsindexes on the table.
public static validate field result < string > from ( validate field result result ) { validate field result < string > string result = new validate field result < > ( ) ; string result . clean = string . value of ( result . clean ) ; string result . errors . add all ( result . errors ) ; return string result ; }	Builder method that constructs a ValidateFieldResult with type String from the input result.
public int get error count ( ) { try {	Commits any outstanding error inserts and returns the error count via a SQL query.
private void commit ( ) { try {	This executes any remaining inserts and commits the transaction.
@ override public validate field result < string > validate and convert ( string hhmmss ) { return validate field result . from ( get seconds ( hhmmss ) ) ; }	Actually this is converting the string. Can we use some JDBC existing functions for this?.
@ override public int compare to ( gtfs o ) { int compare = super . compare to ( o ) ; if ( compare != num ) return compare ; return this . bad reference . compare to ( ( ( ( referential integrity error ) o ) . bad reference ) ) ; }	must be comparable to put into mapdb.
public static double get distance ( line string trip geometry ) { double distance = num ; for ( int i = num ; i < trip geometry . get num points ( ) - num ; i ++ ) { try { distance += jts . orthodromic distance ( trip geometry . get coordinate n ( i ) , trip geometry . get coordinate n ( i + num ) , crs . wg ) ; } catch ( transform exception e ) { throw new runtime exception ( e ) ; } } return distance ; }	Get the length of a linestring in meters.
public static ql field ( string field name , string table name ) { return new field definition ( ) . name ( field name ) . type ( ql ) . data fetcher ( new row count fetcher ( table name ) ) . build ( ) ; }	Convenience method to create a field in a GraphQL schema that fetches the number of rows in a table.Must be on a type that has a "namespace" field for context.
public static ql grouped field ( string table name , string group by column ) { return new field definition ( ) . name ( group by column ) . type ( group count type ) . argument ( string arg ( str ) ) . type ( new ql ( group count type ) ) . data fetcher ( new row count fetcher ( table name , null , group by column ) ) . build ( ) ; }	A GraphQL field used to deliver lists of group counts.
public int [ ] deduplicate int array ( int [ ] original ) { if ( original == null ) return null ; int array int array = new int array ( original ) ; int array canonical = canonical int arrays . get ( int array ) ; if ( canonical == null ) { canonical = int array ; canonical int arrays . put ( canonical , canonical ) ; } return canonical . array ; }	Used to deduplicate time and stop sequence arrays.
public list < trip > get trips for date ( string stop id , local date date ) { list < string > trip ids = stats . get trips for date ( date ) . stream ( ) . map ( trip -> trip . trip id ) . collect ( collectors . to list ( ) ) ; return feed . get distinct trips for stop ( stop id ) . stream ( ) . filter ( t -> trip ids . contains ( t . trip id ) )	Get list of trips that visit a stop for a specified date of service.
public int get average headway for stop ( string stop id , local date date , local time from , local time to ) { list < trip > trips for stop = get trips for date ( stop id , date ) ; return get stop headway for trips ( stop id , trips for stop , from , to ) ; }	Get the average headway, in seconds, for all trips at a stop over a time window.
public map < string , integer > get route headways for stop ( string stop id , local date date , local time from , local time to ) { map < string , integer > route headway map = new hash map < > ( ) ; list < route > routes = feed . patterns . values ( ) . stream ( ) . filter ( p -> p . ordered stops . contains ( stop id ) ) . map ( p -> feed . routes . get ( p . route id ) ) . collect ( collectors . to list ( ) ) ; for ( route route : routes ) { route headway map . put ( route . route id , get headway for stop by route ( stop id , route . route id , date , from , to ) ) ; } return route headway map ; }	Get the route headway for a given service date at a stop over a time window, in seconds.
public int get headway for stop by route ( string stop id , string route id , local date date , local time from , local time to ) { list < trip > trips for stop = feed . get distinct trips for stop ( stop id ) . stream ( ) . filter ( trip -> feed . trips . get ( trip . trip id ) . route id . equals ( route id ) ) . filter ( trip -> feed . services . get ( trip . service id ) . active on ( date ) ) . collect ( collectors . to list ( ) ) ; return get stop headway for trips ( stop id , trips for stop , from , to ) ; }	Get the average headway, in seconds, for a route at a stop over a time window.
private static json node get json node ( string json ) throws io { try { return mapper . read tree ( json ) ; } catch ( io e ) { log . error ( str , e ) ; throw e ; } }	Wrapper method to call Jackson to deserialize a JSON string into JsonNode.
@ override public string create ( string json , boolean auto commit ) throws sql , io { return update ( null , json , auto commit ) ; }	Create a new entity in the database from the provided JSON string.
private int update stop times for pattern stop ( object node pattern stop , int previous travel time ) throws sql { string sql = string . format ( str + str , table prefix , table prefix ) ;	Updates the stop times that reference the specified pattern stop.
private void verify references exist ( string referring table name , multimap < table , string > references per table ) throws sql { for ( table referenced table : references per table . key set ( ) ) { log . info ( str , referring table name , referenced table . name ) ; collection < string > reference strings = references per table . get ( referenced table ) ; string reference field name = referenced table . get key field name ( ) ; string question marks = string . join ( str , collections . n copies ( reference strings . size ( ) , str ) ) ; string check count sql = string . format ( str , reference field name , table prefix , referenced table . name , reference field name , question marks ) ; prepared statement prepared statement = connection . prepare statement ( check count sql ) ; int one based index = num ; for ( string ref : reference strings ) { prepared statement . set string ( one based index ++ , ref ) ; } log . info ( prepared statement . to string ( ) ) ; result set result set = prepared statement . execute query ( ) ; set < string > found references = new hash set < > ( ) ; while ( result set . next ( ) ) { string reference value = result set . get string ( num ) ; found references . add ( reference value ) ; }	Checks that a set of string references to a set of reference tables are all valid.
private static void verify interior stops are unchanged ( list < string > original stop ids , list < pattern stop > new stops , int first different index , int last different index , boolean moved right ) {	Check the stops in the changed region to ensure they remain in the same order.
private void insert blank stop times ( list < string > trip ids , list < pattern stop > new stops , int starting stop sequence , int stop times to add , connection connection ) throws sql { if ( trip ids . is empty ( ) ) {	You must call this method after updating sequences for any stop times following the starting stop sequence toavoid overwriting these other stop times.
@ override public int delete ( integer id , boolean auto commit ) throws sql { try {	Deletes an entity for the specified ID.
private static long handle statement execution ( prepared statement statement , boolean is creating ) throws sql {	Handle executing a prepared statement and return the ID for the newly-generated or updated entity.
private static int get row count ( string table name , connection connection ) throws sql { string row count sql = string . format ( str , table name ) ; log . info ( row count sql ) ;	Get number of rows for a table.
private static set < table > get referencing tables ( table table ) { set < table > referencing tables = new hash set < > ( ) ; for ( table gtfs table : table . tables in order ) {	Finds the set of tables that reference the parent entity being updated.
private static string get value for id ( int id , string field name , string namespace , table table , connection connection ) throws sql { string table name = string . join ( str , namespace , table . name ) ; string select id sql = string . format ( str , field name , table name , id ) ; log . info ( select id sql ) ; statement select id statement = connection . create statement ( ) ; result set select results = select id statement . execute query ( select id sql ) ; string value = null ; while ( select results . next ( ) ) { value = select results . get string ( num ) ; } return value ; }	For a given integer ID, return the value for the specified field name for that entity.
public t put ( string id , file feed file ) throws exception { return put ( id , feed file , null ) ; }	Add a GTFS feed to this cache with the given ID.
public t put ( function < gtfs , string > id generator , file feed file ) throws exception { return put ( null , feed file , id generator ) ; }	Add a GTFS feed to this cache where the ID is calculated from the feed itself.
public boolean active on ( local date date ) {	Is this service active on the specified date?.
public static void initialize ( data source data source ) { gtfs ql . data source = data source ; graphql = ql . new graph ql ( ql . feed based schema ) . build ( ) ; }	Username and password can be null if connecting to a local instance with host-based authentication.
public list < field > editor fields ( ) { list < field > editor fields = new array list < > ( ) ; for ( field f : fields ) if ( f . requirement == required || f . requirement == optional || f . requirement == editor ) { editor fields . add ( f ) ; } return editor fields ; }	Get only those fields included in the official GTFS specification for this table or used by the editor.
public list < field > required fields ( ) {	Get only those fields marked as required in the official GTFS specification for this table.
public list < field > spec fields ( ) { list < field > spec fields = new array list < > ( ) ; for ( field f : fields ) if ( f . requirement == required || f . requirement == optional ) spec fields . add ( f ) ; return spec fields ; }	Get only those fields included in the official GTFS specification for this table, i.e., filter out fields usedin the editor or extensions.
public boolean create sql table ( connection connection , string namespace , boolean make id serial , string [ ] primary key fields ) {	Create an SQL table with all the fields specified by this table object,plus an integer CSV line number field in the first position.
public string generate insert sql ( string namespace , boolean set default id ) { string table name = namespace == null ? name : string . join ( str , namespace , name ) ; string joined field names = comma separated names ( editor fields ( ) ) ; string id value = set default id ? str : str ; return string . format ( str , table name , joined field names , id value , string . join ( str , collections . n copies ( editor fields ( ) . size ( ) , str ) ) ) ; }	Create SQL string for use in insert statement.
public static string comma separated names ( list < field > fields to join , string prefix , boolean csv output ) { return fields to join . stream ( )	Prepend a prefix string to each field and join them with a comma + space separator.Also, if an export to GTFS is being performed, certain fields need a translation from the database format to theGTFS format.
public string generate update sql ( string namespace , int id ) {	Create SQL string for use in update statement.
public string generate select sql ( string namespace , requirement minimum requirement ) { string fields string ; string table name = string . join ( str , namespace , name ) ; string field prefix = table name + str ; if ( minimum requirement . equals ( editor ) ) { fields string = comma separated names ( editor fields ( ) , field prefix , bool ) ; } else if ( minimum requirement . equals ( optional ) ) { fields string = comma separated names ( spec fields ( ) , field prefix , bool ) ; } else if ( minimum requirement . equals ( required ) ) { fields string = comma separated names ( required fields ( ) , field prefix , bool ) ; } else fields string = str ; return string . format ( str , fields string , table name ) ; }	Generate select all SQL string.
public string generate select all existing fields sql ( connection connection , string namespace ) throws sql {	Generate a select statement from the columns that actually exist in the database table.
public string generate delete sql ( string namespace , string field name ) { string where field = field name == null ? str : field name ; return string . format ( str , string . join ( str , namespace , name ) , where field ) ; }	Generate delete SQL string.
public boolean create sql table from ( connection connection , string table to clone ) { long start time = system . current time millis ( ) ; try { statement statement = connection . create statement ( ) ;	Creates a SQL table from the table to clone.
public int get key field index ( field [ ] fields ) { string key field = get key field name ( ) ; return field . get field index ( fields , key field ) ; }	Returns the index of the key field within the array of fields provided for a given table.
public static void ensure valid namespace ( string namespace ) throws invalid namespace exception { pattern pattern = pattern . compile ( str ) ; matcher matcher = pattern . matcher ( namespace ) ; if ( matcher . find ( ) ) { throw new invalid namespace exception ( ) ; } }	Ensures namespace is valid by ensuring it only has alphanumeric characters or the underscorefor all characters in the string.
public static int get field index ( field [ ] fields , string name ) {	Finds the index of the field given a string name.
@ override public set < integer > key set ( ) {	We currently just expose them as immutable sets in RAM, since all of the modification operations are optional.
public static gtfs from file ( string file , string feed id ) { gtfs feed = new gtfs ( ) ; zip file zip ; try { zip = new zip file ( file ) ; if ( feed id == null ) { feed . load from file ( zip ) ; } else { feed . load from file ( zip , feed id ) ; } zip . close ( ) ; return feed ; } catch ( exception e ) { log . error ( str , e . get message ( ) ) ; throw new runtime exception ( e ) ; } }	Static factory method returning a new instance of GTFSFeed containing the contents ofthe GTFS file at the supplied filesystem path.
public void find patterns ( ) { pattern finder pattern finder = new pattern finder ( ) ;	MapDB-based implementation to find patterns.FIXME: Remove and make pattern finding happen during validation? We want to share the pattern finder between thetwo implementations (MapDB and RDBMS), apply the same validation process to both kinds of storage, and producePatterns in the same way in both cases, during validation.
public double get trip distance ( string trip id , boolean straight line ) { return straight line ? geo utils . get distance ( this . get straight line for stops ( trip id ) ) : geo utils . get distance ( this . get trip geometry ( trip id ) ) ; }	Get the length of a trip in meters.
public double get trip speed ( string trip id , boolean straight line ) { stop time first stop time = this . stop times . ceiling entry ( fun . t2 ( trip id , null ) ) . get value ( ) ; stop time last stop time = this . stop times . floor entry ( fun . t2 ( trip id , fun . hi ) ) . get value ( ) ;	Get trip speed in meters per second.
public list < stop time > get stop times for stop ( string stop id ) { sorted set < tuple2 < string , tuple2 > > index = this . stop stop time set . sub set ( new tuple2 < > ( stop id , null ) , new tuple2 ( stop id , fun . hi ) ) ; return index . stream ( ) . map ( tuple -> this . stop times . get ( tuple . b ) ) . collect ( collectors . to list ( ) ) ; }	Get list of stop_times for a given stop_id.
public list < service > get services for date ( local date date ) { string date string = date . format ( date formatter ) ; sorted set < tuple2 < string , string > > index = this . services per date . sub set ( new tuple2 < > ( date string , null ) , new tuple2 ( date string , fun . hi ) ) ; return index . stream ( ) . map ( tuple -> this . services . get ( tuple . b ) ) . collect ( collectors . to list ( ) ) ; }	Get list of services for each date of service.
public zone id get agency time zone for stop ( string stop id ) { stop time stop time = get stop times for stop ( stop id ) . iterator ( ) . next ( ) ; trip trip = this . trips . get ( stop time . trip id ) ; route route = this . routes . get ( trip . route id ) ; agency agency = route . agency id != null ? this . agency . get ( route . agency id ) : this . agency . get ( num ) ; return zone id . of ( agency . agency timezone ) ; }	Get the likely time zone for a stop using the agency of the first stop time encountered for the stop.
public map < trip pattern key , pattern > create pattern objects ( map < string , stop > stop by id , sql error storage ) {	Once all trips have been processed, call this method to produce the final Pattern objects representing all theunique sequences of stops encountered.
private static void set anyway timer ( context context ) { alarm manager am = ( alarm manager ) context . get system service ( context . alarm service ) ; intent intent = new intent ( context , idle receiver . class ) ; intent . set action ( action trigger idle ) ; pending intent pending intent = pending intent . get broadcast ( context , num , intent , num ) ; final long now elapsed = system clock . elapsed realtime ( ) ; final long when = now elapsed + inactivity anyway threshold ; compat set window ( am , alarm manager . elapsed realtime wakeup , when , idle window slop , pending intent ) ; }	We can't get idle broadcasts while the app is not running.
public static void enable receiver ( context context ) { intent filter filter = get filter ( ) ; s receiver = new idle receiver ( ) ; context . get application context ( ) . register receiver ( s receiver , filter ) ; }	Call this as soon as we get a chance, it will be unregistered whenever our app is killed.
void report new idle state ( context context , boolean is idle ) { job store job store = job store . init and get ( context ) ; synchronized ( job store ) { array set < job status > jobs = job store . get jobs ( ) ; for ( int i = num ; i < jobs . size ( ) ; i ++ ) { job status ts = jobs . value at ( i ) ; ts . idle constraint satisfied . set ( is idle ) ; } } start wakeful service ( context , job service compat . maybe run jobs ( context ) ) ; }	Interaction with the task manager service.
public boolean add ( job status job status ) { boolean replaced = m job set . remove ( job status ) ; m job set . add ( job status ) ; if ( ! job status . is persisted ( ) ) { mark for boot session ( job status ) ; } maybe write status to disk async ( ) ; return replaced ; }	Add a job to the master list, persisting it if necessary.
public boolean contains job id ( int job id ) { for ( int i = m job set . size ( ) - num ; i >= num ; i -- ) { job status ts = m job set . value at ( i ) ; if ( ts . matches ( job id ) ) { return bool ; } } return bool ; }	Whether this jobStatus object already exists in the JobStore.
public boolean remove ( job status job status ) { boolean removed = m job set . remove ( job status ) ; if ( ! removed ) { return bool ; } if ( ! job status . is persisted ( ) ) { unmark for boot session ( job status ) ; } maybe write status to disk async ( ) ; return removed ; }	Remove the provided job.
private job status reschedule failed job ( job status job ) { if ( job . has idle constraint ( ) ) {	A job is rescheduled with exponential back-off if the client requests this from theirexecution logic.A caveat is for idle-mode jobs, for which the idle-mode constraint will usurp thetimeliness of the reschedule.
@ override public void clear ( ) { if ( m size != num ) { free arrays ( m hashes , m array , m size ) ; m hashes = empty array . int ; m array = empty array . object ; m size = num ; } }	Make the array map empty.
public void on received start job ( job parameters params ) { m show start view . set background color ( start job color ) ; message m = message . obtain ( m handler , msg uncolour start ) ; m handler . send message delayed ( m , num ) ;	Receives callback from the service when a job has landed on the app.
public void on received stop job ( ) { m show stop view . set background color ( stop job color ) ; message m = message . obtain ( m handler , msg uncolour stop ) ; m handler . send message delayed ( m , num ) ;	Receives callback from the service when a job that previously landed on the app must stopexecuting.
private static boolean can stop tracking job ( job status job ) { return ( ! job . has timing delay constraint ( ) || job . time delay constraint satisfied . get ( ) ) && ( ! job . has deadline constraint ( ) || job . deadline constraint satisfied . get ( ) ) ; }	Determines whether this controller can stop tracking the given job.The controller is no longer interested in a job once its time constraint is satisfied, andthe job's deadline is fulfilled - unlike other controllers a time constraint can't toggleback and forth.
public void put string ( string key , string value ) { persistable bundle compat . put string ( bundle , key , value ) ; }	Inserts a String value into the mapping of this Bundle, replacing any existing value for thegiven key.
public void put string array ( string key , string [ ] value ) { persistable bundle compat . put string array ( bundle , key , value ) ; }	Inserts a String array value into the mapping of this Bundle, replacing any existing valuefor the given key.
public string get string ( string key , string default value ) { return persistable bundle compat . get string ( bundle , key , default value ) ; }	Returns the value associated with the given key, or defaultValue if no mapping of the desiredtype exists for the given key or if a null value is explicitly associated with the givenkey.
public void put persistable bundle ( string key , persistable bundle value ) { persistable bundle compat . put persistable bundle ( bundle , key , value . bundle ) ; }	Inserts a PersistableBundle value into the mapping of this Bundle, replacing any existingvalue for the given key.
public void write to parcel ( parcel out , int flags ) { out . write string ( m message ) ; out . write string ( m action message ) ; out . write int ( m action icon ) ; out . write parcelable ( m token , num ) ; out . write int ( ( int ) m duration ) ; out . write parcelable ( m btn text color , num ) ; out . write parcelable ( m background color , num ) ; out . write int ( m height ) ; out . write value ( m typeface ) ; }	writes data to parcel.
public int get height ( ) { m parent view . measure ( view . measure spec . make measure spec ( m parent view . get width ( ) , view . measure spec . exactly ) , view . measure spec . make measure spec ( m parent view . get height ( ) , view . measure spec . at most ) ) ; return m parent view . get measured height ( ) ; }	Calculates the height of the SnackBar.
public static void d print ( string str ) { if ( verbose print ) { system . out . println ( str ) ; } m log . fine ( str ) ; }	Simple Debug Print Mechanism.
public static boolean check properties ( properties post prop , string url , string method , string oauth consumer key , string oauth consumer secret ) { return check properties ( convert to map ( post prop ) , url , method , oauth consumer key , oauth consumer secret ) ; }	Check if the properties are properly signed.
public static boolean check properties ( map < string , string > post prop , string url , string method , string oauth consumer key , string oauth consumer secret ) { o oam = new o ( method , url , post prop . entry set ( ) ) ; o cons = new o ( str , oauth consumer key , oauth consumer secret , null ) ; o oav = new o ( ) ; o acc = new o ( cons ) ; string base string = null ; try { base string = o . get base string ( oam ) ; } catch ( exception e ) { m log . warning ( e . get localized message ( ) ) ; base string = null ; return bool ; } try { oav . validate message ( oam , acc ) ; } catch ( exception e ) { m log . warning ( str ) ; m log . warning ( e . get localized message ( ) ) ; if ( base string != null ) { m log . warning ( base string ) ; } return bool ; } return bool ; }	Check if the fields are properly signed.
public static string prepare for export ( string descriptor ) { map < string , object > tm = null ; try { tm = xml . get full map ( descriptor . trim ( ) ) ; } catch ( exception e ) { m log . warning ( str + e . get message ( ) ) ; return null ; } if ( tm == null ) { m log . warning ( str ) ; return null ; } xml . remove sub map ( tm , str ) ; string retval = xml . get xml ( tm , bool ) ; return retval ; }	Remove fields that should not be exported.
public static void set property ( properties props , string key , string value ) { if ( value == null ) { return ; } if ( value . trim ( ) . length ( ) < num ) { return ; } props . set property ( key , value ) ; }	Mutates the passed Properties props variable.
public static string htmlspecialchars ( string input ) { if ( input == null ) { return null ; } string retval = input . replace ( str , str ) ; retval = retval . replace ( str , str ) ; retval = retval . replace ( str , str ) ; retval = retval . replace ( str , str ) ; retval = retval . replace ( str , str ) ; retval = retval . replace ( str , str ) ; return retval ; }	Basic utility to encode form text - handle the "safe cases".
static public string get real path ( string servlet url , string ext url ) { pattern pat = pattern . compile ( str ) ;	Simple utility method deal with a request that has the wrong URL whenbehind a proxy.
@ override public lti verification result verify ( http servlet request request , string secret ) throws lti verification exception { o oam = o . get message ( request , o . get request url ( request ) ) ; string oauth consumer key = null ; try { oauth consumer key = oam . get consumer key ( ) ; } catch ( exception e ) { return new lti verification result ( bool , lti error . bad request , str ) ; } o oav = new o ( ) ; o cons = new o ( null , oauth consumer key , secret , null ) ; o acc = new o ( cons ) ; try { oav . validate message ( oam , acc ) ; } catch ( exception e ) { return new lti verification result ( bool , lti error . bad request , str + e . get localized message ( ) ) ; } return new lti verification result ( bool , new lti launch ( request ) ) ; }	This method verifies the signed HttpServletRequest.
@ override public lti verification result verify parameters ( map < string , string > parameters , string url , string method , string secret ) throws lti verification exception { o oam = new o ( method , url , parameters . entry set ( ) ) ; o cons = new o ( null , parameters . get ( oauth key parameter ) , secret , null ) ; o oav = new o ( ) ; o acc = new o ( cons ) ; try { oav . validate message ( oam , acc ) ; } catch ( exception e ) { return new lti verification result ( bool , lti error . bad request , str + e . get localized message ( ) + str + arrays . to string ( parameters . entry set ( ) . to array ( ) ) ) ; } return new lti verification result ( bool , new lti launch ( parameters ) ) ; }	This method will verify a collection of parameters.
public void validate request ( string oauth consumer key , string oauth secret , http servlet request request ) { validate request ( oauth consumer key , oauth secret , request , null ) ; }	Assumes data is all loaded.
protected tool consumer build tool consumer profile ( http servlet request request , map < string , object > deploy , string profile id ) {	it is always null and we allow everything.
public static string validate services ( tool consumer consumer , json provider profile ) {	Validate the incoming tool_services against a tool consumer.
public static string validate capabilities ( tool consumer consumer , json provider profile ) { list < properties > the tools = new array list < properties > ( ) ; properties info = new properties ( ) ;	Validate incoming capabilities requested against out ToolConsumer.
public static void add custom to launch ( properties lti props , properties custom ) { enumeration < ? > e = custom . property names ( ) ; while ( e . has more elements ( ) ) { string key str = ( string ) e . next element ( ) ; string value = custom . get property ( key str ) ; set property ( lti props , str + key str , value ) ; } }	Place the custom values into the launch.
private void toogle list view ( view v ) { if ( m last view touch id != v . get id ( ) ) { if ( m last view touch id == m list view left . get id ( ) ) { is left list enabled = bool ; is right list enabled = bool ; } else { is left list enabled = bool ; is right list enabled = bool ; } } }	Each time we touch the opposite ListView than the last one we have selectedwe need to activate it as the enable one.
@ override public void on list scroll ( view view , float delta y ) { int speed ; if ( view . get id ( ) == m list view left . get id ( ) && ! is left list enabled ) { speed = get speed ( bool , delta y ) ; m list view right . smooth scroll by ( speed , num ) ; } else if ( view . get id ( ) == m list view right . get id ( ) && ! is right list enabled ) { speed = get speed ( bool , delta y ) ; m list view left . smooth scroll by ( speed , num ) ; } }	Receives the distance scroll on listView.
public static safe url proto to proto ( safe url url ) { return safe url proto . new builder ( ) . set private do not access or else safe url wrapped value ( url . get safe url string ( ) ) . build ( ) ; }	Serializes a SafeUrl into its opaque protocol message representation.
public static safe style proto to proto ( safe style style ) { return safe style proto . new builder ( ) . set private do not access or else safe style wrapped value ( style . get safe style string ( ) ) . build ( ) ; }	Serializes a SafeStyle into its opaque protocol message representation.
public static safe script proto to proto ( safe script script ) { return safe script proto . new builder ( ) . set private do not access or else safe script wrapped value ( script . get safe script string ( ) ) . build ( ) ; }	Serializes a SafeScript into its opaque protocol message representation.
public static safe style sheet proto to proto ( safe style sheet style ) { return safe style sheet proto . new builder ( ) . set private do not access or else safe style sheet wrapped value ( style . get safe style sheet string ( ) ) . build ( ) ; }	Serializes a SafeStyleSheet into its opaque protocol message representation.
public static trusted resource url proto to proto ( trusted resource url url ) { return trusted resource url proto . new builder ( ) . set private do not access or else trusted resource url wrapped value ( url . get trusted resource url string ( ) ) . build ( ) ; }	Serializes a TrustedResourceUrl into its opaque protocol message representation.
public static safe html proto to proto ( safe html safe html ) { return safe html proto . new builder ( ) . set private do not access or else safe html wrapped value ( safe html . get safe html string ( ) ) . build ( ) ; }	Serializes a SafeHtml into its opaque protocol message representation.
public static double wrap angle rad ( double angle ) { angle %= trig math . two pi ; if ( angle <= - trig math . pi ) { return angle + trig math . two pi ; } if ( angle > trig math . pi ) { return angle - trig math . two pi ; } return angle ; }	Wraps the radian between -PI and PI.
public static double round ( double input , int decimals ) { final double p = math . pow ( num , decimals ) ; return math . round ( input * p ) / p ; }	Rounds a number to the amount of decimals specified.
public static double lerp ( double x , double x1 , double x2 , double q0 , double q1 ) { return ( ( x2 - x ) / ( x2 - x1 ) ) * q0 + ( ( x - x1 ) / ( x2 - x1 ) ) * q1 ; }	Calculates the value at x using linear interpolation.
public static quaternionf slerp ( quaternionf a , quaternionf b , float percent ) { final float inverted ; float cosine theta = a . dot ( b ) ; if ( cosine theta < num ) { cosine theta = - cosine theta ; inverted = - num ; } else { inverted = num ; } if ( num - cosine theta < generic math . flt epsilon ) { return a . mul ( num - percent ) . add ( b . mul ( percent * inverted ) ) ; } final float theta = ( float ) trig math . acos ( cosine theta ) ; final float sine theta = trig math . sin ( theta ) ; final float coefficient1 = trig math . sin ( ( num - percent ) * theta ) / sine theta ; final float coefficient2 = trig math . sin ( percent * theta ) / sine theta * inverted ; return a . mul ( coefficient1 ) . add ( b . mul ( coefficient2 ) ) ; }	Interpolates a quaternion between two others using spherical linear interpolation.
public static double bi lerp ( double x , double y , double q00 , double q01 , double q10 , double q11 , double x1 , double x2 , double y1 , double y2 ) { double q0 = lerp ( x , x1 , x2 , q00 , q10 ) ; double q1 = lerp ( x , x1 , x2 , q01 , q11 ) ; return lerp ( y , y1 , y2 , q0 , q1 ) ; }	Calculates the value at x,y using bilinear interpolation.
public static color blend ( color a , color b ) { return lerp ( a , b , a . get alpha ( ) / num ) ; }	Blends two colors into one.
public static double clamp ( double value , double low , double high ) { if ( value < low ) { return low ; } if ( value > high ) { return high ; } return value ; }	Clamps the value between the low and high boundaries.
public static double inverse sqrt ( double a ) { final double half a = num * a ; a = double . long bits to double ( num - ( double . double to raw long bits ( a ) > > num ) ) ; return a * ( num - half a * a * a ) ; }	Returns a fast estimate of the inverse square root of the value.
public static float cast float ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . float value ( ) ; } try { return float . value of ( o . to string ( ) ) ; } catch ( number format exception e ) { return null ; } }	Casts a value to a float.
public static byte cast byte ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . byte value ( ) ; } try { return byte . value of ( o . to string ( ) ) ; } catch ( number format exception e ) { return null ; } }	Casts a value to a byte.
public static short cast short ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . short value ( ) ; } try { return short . value of ( o . to string ( ) ) ; } catch ( number format exception e ) { return null ; } }	Casts a value to a short.
public static integer cast int ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . int value ( ) ; } try { return integer . value of ( o . to string ( ) ) ; } catch ( number format exception e ) { return null ; } }	Casts a value to an integer.
public static double cast double ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . double value ( ) ; } try { return double . value of ( o . to string ( ) ) ; } catch ( number format exception e ) { return null ; } }	Casts a value to a double.
public static long cast long ( object o ) { if ( o == null ) { return null ; } if ( o instanceof number ) { return ( ( number ) o ) . long value ( ) ; } try { return long . value of ( o . to string ( ) ) ; } catch ( number format exception e ) { return null ; } }	Casts a value to a long.
public static boolean cast boolean ( object o ) { if ( o == null ) { return null ; } if ( o instanceof boolean ) { return ( boolean ) o ; } else if ( o instanceof string ) { try { return boolean . parse boolean ( ( string ) o ) ; } catch ( illegal argument exception e ) { return null ; } } return null ; }	Casts a value to a boolean.
public static int mean ( int ... values ) { int sum = num ; for ( int v : values ) { sum += v ; } return sum / values . length ; }	Calculates the mean of a set of values.
public static double mod ( double a , double div ) { final double remainder = a % div ; return remainder < num ? remainder + div : remainder ; }	Returns the modulo of 'a' by 'div' with corrections for negative numbers.
public static int multiply to shift ( int a ) { if ( a < num ) { throw new illegal argument exception ( str ) ; } int shift = num - integer . number of leading zeros ( a ) ; if ( ( num << shift ) != a ) { throw new illegal argument exception ( str ) ; } return shift ; }	Converts a multiplication into a shift.
@ override public quaterniond mul ( double a ) { return new quaterniond ( x * a , y * a , z * a , w * a ) ; }	Multiplies the components of this quaternion by a double scalar.
@ override public quaterniond div ( double a ) { return new quaterniond ( x / a , y / a , z / a , w / a ) ; }	Divides the components of this quaternion by a double scalar.
public vector3d rotate ( double x , double y , double z ) { final double length = length ( ) ; if ( math . abs ( length ) < generic math . dbl epsilon ) { throw new arithmetic exception ( str ) ; } final double nx = this . x / length ; final double ny = this . y / length ; final double nz = this . z / length ; final double nw = this . w / length ; final double px = nw * x + ny * z - nz * y ; final double py = nw * y + nz * x - nx * z ; final double pz = nw * z + nx * y - ny * x ; final double pw = - nx * x - ny * y - nz * z ; return new vector3d ( pw * - nx + px * nw - py * nz + pz * ny , pw * - ny + py * nw - pz * nx + px * nz , pw * - nz + pz * nw - px * ny + py * nx ) ; }	Rotates the double components of a vector by this quaternion.
@ override public double length squared ( ) { return x * x + y * y + z * z + w * w ; }	Returns the square of the length of this quaternion.
@ override public quaterniond normalize ( ) { final double length = length ( ) ; if ( math . abs ( length ) < generic math . dbl epsilon ) { throw new arithmetic exception ( str ) ; } return new quaterniond ( x / length , y / length , z / length , w / length ) ; }	Normalizes this quaternion.
public static quaterniond from imaginary ( double x , double y , double z ) { return x == num && y == num && z == num ? zero : new quaterniond ( x , y , z , num ) ; }	Creates a new quaternion from the double imaginary components. The {.
public static quaterniond from ( double x , double y , double z , double w ) { return x == num && y == num && z == num && w == num ? zero : new quaterniond ( x , y , z , w ) ; }	Creates a new quaternion from the double components. The {.
public static quaterniond from axes angles deg ( double pitch , double yaw , double roll ) { return quaterniond . from angle deg axis ( yaw , vector3d . unit y ) . mul ( quaterniond . from angle deg axis ( pitch , vector3d . unit x ) ) . mul ( quaterniond . from angle deg axis ( roll , vector3d . unit z ) ) ; }	Creates a new quaternion from the double angles in degrees around the x, y and z axes.
public static quaterniond from axes angles rad ( double pitch , double yaw , double roll ) { return quaterniond . from angle rad axis ( yaw , vector3d . unit y ) . mul ( quaterniond . from angle rad axis ( pitch , vector3d . unit x ) ) . mul ( quaterniond . from angle rad axis ( roll , vector3d . unit z ) ) ; }	Creates a new quaternion from the double angles in radians around the x, y and z axes.
public static quaterniond from angle rad axis ( double angle , vector3d axis ) { return from angle rad axis ( angle , axis . get x ( ) , axis . get y ( ) , axis . get z ( ) ) ; }	Creates a new quaternion from the rotation double angle in radians around the axis vector.
public static quaterniond from angle deg axis ( float angle , float x , float y , float z ) { return from angle rad axis ( math . to radians ( angle ) , x , y , z ) ; }	Creates a new quaternion from the rotation float angle in degrees around the axis vector float components.
@ override public int get min axis ( ) { int value = x ; int axis = num ; if ( y < value ) { value = y ; axis = num ; } if ( z < value ) { value = z ; axis = num ; } if ( w < value ) { axis = num ; } return axis ; }	Return the axis with the minimal value.
public complexf mul ( float x , float y ) { return new complexf ( this . x * x - this . y * y , this . x * y + this . y * x ) ; }	Multiplies the float components of another complex with this one.
public complexf div ( float x , float y ) { final float d = x * x + y * y ; return new complexf ( ( this . x * x + this . y * y ) / d , ( this . y * x - this . x * y ) / d ) ; }	Divides this complex by the float components of another one.
public vector2f rotate ( float x , float y ) { final float length = length ( ) ; if ( math . abs ( length ) < generic math . flt epsilon ) { throw new arithmetic exception ( str ) ; } final float nx = this . x / length ; final float ny = this . y / length ; return new vector2f ( x * nx - y * ny , y * nx + x * ny ) ; }	Rotates the float components of a vector by this complex.
@ override public complexf normalize ( ) { final float length = length ( ) ; if ( math . abs ( length ) < generic math . flt epsilon ) { throw new arithmetic exception ( str ) ; } return new complexf ( x / length , y / length ) ; }	Normalizes this complex.
public quaternionf to quaternion ( float x , float y , float z ) { return quaternionf . from angle rad axis ( get angle rad ( ) , x , y , z ) ; }	Converts this complex to a quaternion byusing the provided float components vectoras a rotation axis.
public static complexf from ( float x , float y ) { return x == num && y == num ? zero : new complexf ( x , y ) ; }	Creates a new complex from the float components. The {.
public static complexf from angle rad ( float angle ) { return new complexf ( trig math . cos ( angle ) , trig math . sin ( angle ) ) ; }	Creates a new complex from the float angle in radians.
@ override public int get max axis ( ) { long value = x ; int axis = num ; if ( y > value ) { value = y ; axis = num ; } if ( z > value ) { value = z ; axis = num ; } if ( w > value ) { axis = num ; } return axis ; }	Return the axis with the maximum value.
public static int hash ( double value ) { assert ! double . is na n ( value ) : str ; long bits = double . double to long bits ( value ) ; return ( int ) ( bits ^ ( bits > > > num ) ) ;	Returns a hashcode for the specified value.
public quaternionf add ( float x , float y , float z , float w ) { return new quaternionf ( this . x + x , this . y + y , this . z + z , this . w + w ) ; }	Adds the float components of another quaternion to this one.
@ override public quaternionf mul ( float a ) { return new quaternionf ( x * a , y * a , z * a , w * a ) ; }	Multiplies the components of this quaternion by a float scalar.
@ override public quaternionf div ( float a ) { return new quaternionf ( x / a , y / a , z / a , w / a ) ; }	Divides the components of this quaternion by a float scalar.
public vector3f get axis ( ) { final float q = ( float ) math . sqrt ( num - w * w ) ; return new vector3f ( x / q , y / q , z / q ) ; }	Returns the axis of rotation for this quaternion.
public vector3f get axes angles rad ( ) { final double roll ; final double pitch ; double yaw ; final double test = w * x - y * z ; if ( math . abs ( test ) < num ) { roll = trig math . atan2 ( num * ( w * z + x * y ) , num - num * ( x * x + z * z ) ) ; pitch = trig math . asin ( num * test ) ; yaw = trig math . atan2 ( num * ( w * y + z * x ) , num - num * ( x * x + y * y ) ) ; } else { final int sign = ( test < num ) ? - num : num ; roll = num ; pitch = sign * math . pi / num ; yaw = - sign * num * trig math . atan2 ( z , w ) ; } return new vector3f ( pitch , yaw , roll ) ; }	Returns the angles in radians around the x, y and z axes that correspond to the rotation represented by this quaternion.
public static quaternionf from imaginary ( float x , float y , float z ) { return x == num && y == num && z == num ? zero : new quaternionf ( x , y , z , num ) ; }	Creates a new quaternion from the float imaginary components. The {.
public static quaternionf from ( float x , float y , float z , float w ) { return x == num && y == num && z == num && w == num ? zero : new quaternionf ( x , y , z , w ) ; }	Creates a new quaternion from the float components. The {.
public static quaternionf from axes angles deg ( float pitch , float yaw , float roll ) { return quaternionf . from angle deg axis ( yaw , vector3f . unit y ) . mul ( quaternionf . from angle deg axis ( pitch , vector3f . unit x ) ) . mul ( quaternionf . from angle deg axis ( roll , vector3f . unit z ) ) ; }	Creates a new quaternion from the float angles in degrees around the x, y and z axes.
public static quaternionf from axes angles rad ( float pitch , float yaw , float roll ) { return quaternionf . from angle rad axis ( yaw , vector3f . unit y ) . mul ( quaternionf . from angle rad axis ( pitch , vector3f . unit x ) ) . mul ( quaternionf . from angle rad axis ( roll , vector3f . unit z ) ) ; }	Creates a new quaternion from the float angles in radians around the x, y and z axes.
public static quaternionf from angle rad axis ( float angle , vector3f axis ) { return from angle rad axis ( angle , axis . get x ( ) , axis . get y ( ) , axis . get z ( ) ) ; }	Creates a new quaternion from the rotation float angle in radians around the axis vector.
public static quaternionf from angle rad axis ( double angle , double x , double y , double z ) { return from angle rad axis ( ( float ) angle , ( float ) x , ( float ) y , ( float ) z ) ; }	Creates a new quaternion from the rotation double angle in radians around the axis vector double components.
public complexd mul ( double x , double y ) { return new complexd ( this . x * x - this . y * y , this . x * y + this . y * x ) ; }	Multiplies the double components of another complex with this one.
public complexd div ( double x , double y ) { final double d = x * x + y * y ; return new complexd ( ( this . x * x + this . y * y ) / d , ( this . y * x - this . x * y ) / d ) ; }	Divides this complex by the double components of another one.
public vector2d rotate ( double x , double y ) { final double length = length ( ) ; if ( math . abs ( length ) < generic math . dbl epsilon ) { throw new arithmetic exception ( str ) ; } final double nx = this . x / length ; final double ny = this . y / length ; return new vector2d ( x * nx - y * ny , y * nx + x * ny ) ; }	Rotates the double components of a vector by this complex.
public quaterniond to quaternion ( double x , double y , double z ) { return quaterniond . from angle rad axis ( get angle rad ( ) , x , y , z ) ; }	Converts this complex to a quaternion byusing the provided double components vectoras a rotation axis.
public static complexd from ( double x , double y ) { return x == num && y == num ? zero : new complexd ( x , y ) ; }	Creates a new complex from the double components. The {.
public static complexd from angle rad ( double angle ) { return new complexd ( trig math . cos ( angle ) , trig math . sin ( angle ) ) ; }	Creates a new complex from the double angle in radians.
public void move child view ( view p child view , float p scale , float p scale ) { scalable layout . layout params l sllp = get child layout params ( p child view ) ; l sllp . m scale = p scale ; l sllp . m scale = p scale ; post invalidate ( ) ; }	move childView inside ScalableLayout.
public void move child view ( view p child view , float p scale , float p scale , float p scale , float p scale ) { scalable layout . layout params l sllp = get child layout params ( p child view ) ; l sllp . m scale = p scale ; l sllp . m scale = p scale ; l sllp . m scale = p scale ; l sllp . m scale = p scale ; post invalidate ( ) ; }	move and resize childView inside ScalableLayout.
private static void set block span ( spannable string builder builder , object what ) { int length = math . max ( num , builder . length ( ) - num ) ; builder . set span ( what , num , length , spannable . span exclusive exclusive ) ; }	These have trailing newlines that we want to avoid spanning.
public bound set reduce ( type solver type solver ) { list < constraint formula > constraints = new linked list < > ( constraint formulas ) ; bound set bound set = bound set . empty ( ) ; while ( constraints . size ( ) > num ) { constraint formula constraint formula = constraints . remove ( num ) ; constraint formula . reduction result reduction result = constraint formula . reduce ( bound set ) ; constraints . add all ( reduction result . get constraint formulas ( ) ) ; bound set . incorporate ( reduction result . get bound set ( ) , type solver ) ; } return bound set ; }	Takes a compatibility assertion about an expression or type, called a constraint formula, and reduces it to aset of bounds on inference variables.
@ override public resolved type transform type parameters ( resolved type transformer transformer ) { resolved type result = this ; int i = num ; for ( resolved type tp : this . type parameters values ( ) ) { resolved type transformed tp = transformer . transform ( tp ) ;	Execute a transformation on all the type parameters of this element.
public static < s extends resolved declaration , s2 extends s > symbol reference < s > solved ( s2 symbol declaration ) { return new symbol reference < s > ( optional . of ( symbol declaration ) ) ; }	Create a solve reference to the given symbol.
public static < s extends resolved declaration , s2 extends s > symbol reference < s > unsolved ( class < s2 > clazz ) { return new symbol reference < > ( optional . empty ( ) ) ; }	Create an unsolved reference specifying the type of the value expected.
public static boolean is proper type ( resolved type type ) { if ( type instanceof inference variable ) { return bool ; } if ( type instanceof resolved reference type ) { resolved reference type reference type = ( resolved reference type ) type ; return reference type . type parameters values ( ) . stream ( ) . all match ( it -> is proper type ( it ) ) ; } if ( type instanceof resolved wildcard ) { resolved wildcard wildcard = ( resolved wildcard ) type ; if ( wildcard . is bounded ( ) ) { return is proper type ( wildcard . get bounded type ( ) ) ; } else { return bool ; } } if ( type . is primitive ( ) ) { return bool ; } if ( type . is type variable ( ) ) {	The term proper type excludes such "types" that mention inference variables.
public static resolved type glb ( set < resolved type > types ) { if ( types . size ( ) == num ) { throw new illegal argument exception ( ) ; } if ( types . size ( ) == num ) { return types . iterator ( ) . next ( ) ; } return new resolved intersection type ( types ) ; }	See JLS 5.1.10. Capture Conversion.
private resolved type solve dot expression type ( resolved reference type declaration parent type , field access expr node ) {	Java Parser can't differentiate between packages, internal types, and fields.All three are lumped together into FieldAccessExpr.
public symbol reference < resolved constructor declaration > solve ( object creation expr object creation expr , boolean solve lambdas ) { list < resolved type > argument types = new linked list < > ( ) ; list < lambda argument type placeholder > placeholders = new linked list < > ( ) ; solve arguments ( object creation expr , object creation expr . get arguments ( ) , solve lambdas , argument types , placeholders ) ; resolved type class decl = java parser facade . get ( type solver ) . convert ( object creation expr . get type ( ) , object creation expr ) ; if ( ! class decl . is reference type ( ) ) { return symbol reference . unsolved ( resolved constructor declaration . class ) ; } symbol reference < resolved constructor declaration > res = constructor resolution logic . find most applicable ( ( ( resolved class declaration ) class decl . as reference type ( ) . get type declaration ( ) ) . get constructors ( ) , argument types , type solver ) ; for ( lambda argument type placeholder placeholder : placeholders ) { placeholder . set method ( res ) ; } return res ; }	Given a constructor call find out to which constructor declaration it corresponds.
public symbol reference < resolved method declaration > solve ( method call expr method call expr , boolean solve lambdas ) { list < resolved type > argument types = new linked list < > ( ) ; list < lambda argument type placeholder > placeholders = new linked list < > ( ) ; solve arguments ( method call expr , method call expr . get arguments ( ) , solve lambdas , argument types , placeholders ) ; symbol reference < resolved method declaration > res = java parser factory . get context ( method call expr , type solver ) . solve method ( method call expr . get name ( ) . get id ( ) , argument types , bool , type solver ) ; for ( lambda argument type placeholder placeholder : placeholders ) { placeholder . set method ( res ) ; } return res ; }	Given a method call find out to which method declaration it corresponds.
private optional < resolved type > find ( map < node , resolved type > map , lambda expr lambda expr ) { for ( node key : map . key set ( ) ) { if ( key instanceof lambda expr ) { lambda expr key lambda expr = ( lambda expr ) key ; if ( key lambda expr . to string ( ) . equals ( lambda expr . to string ( ) ) && get parent node ( key lambda expr ) == get parent node ( lambda expr ) ) { return optional . of ( map . get ( key lambda expr ) ) ; } } } return optional . empty ( ) ; }	For some reasons LambdaExprs are duplicate and the equals method is not implemented correctly.
private string q name ( class or interface type class or interface type ) { string name = class or interface type . get name ( ) . get id ( ) ; if ( class or interface type . get scope ( ) . is present ( ) ) { return q name ( class or interface type . get scope ( ) . get ( ) ) + str + name ; } else { return name ; } }	This is an hack around an issue in JavaParser.
public resolved type get type of this in ( node node ) {	"this" inserted in the given point, which type would have?.
public boolean exit the statement ( break stmt break stmt ) { if ( ! is reachable ( break stmt ) ) { return bool ; } statement break target = break target ( break stmt ) ; for ( try stmt try stmt : contained try stmts ( break target ) ) { if ( contains ( try stmt . get try block ( ) , break stmt ) ) { if ( ! try stmt . get finally block ( ) . is present ( ) && ! can complete normally ( try stmt . get finally block ( ) . get ( ) ) ) { return bool ; } } } return bool ; }	A reachable break statement exits a statement if, within the break target, either there are no try statementswhose try blocks contain the break statement, or there are try statements whose try blocks contain the breakstatement and all finally clauses of those try statements can complete normally.
@ deprecated public symbol reference < resolved type declaration > solve type in type ( resolved type declaration type declaration , string name ) { if ( type declaration instanceof java parser class declaration ) { return ( ( java parser class declaration ) type declaration ) . solve type ( name , type solver ) ; } if ( type declaration instanceof java parser interface declaration ) { return ( ( java parser interface declaration ) type declaration ) . solve type ( name , type solver ) ; } return symbol reference . unsolved ( resolved reference type declaration . class ) ; }	Try to solve a symbol just in the declaration, it does not delegate to the container.
public static value from ( resolved value declaration decl ) { resolved type type = decl . get type ( ) ; return new value ( type , decl . get name ( ) ) ; }	Create a Value from a ValueDeclaration.
public boolean invocation applicability inference ( method call expr method call expr , resolved method declaration method declaration ) { if ( ! method call expr . get name as string ( ) . equals ( method declaration . get name ( ) ) ) { throw new illegal argument exception ( ) ; } optional < instantiation set > partial = instantiation inference ( method call expr , method declaration ) ; if ( ! partial . is present ( ) ) { return bool ; } int n actual params = method call expr . get arguments ( ) . size ( ) ; int n formal params = method declaration . get number of params ( ) ; if ( n actual params != n formal params ) { if ( method declaration . has variadic parameter ( ) ) { if ( n actual params < ( n formal params - num ) ) { return bool ; } } else { return bool ; } }	Determine whether a potentially applicable generic method m is applicable for a method invocation thatprovides no explicit type arguments.
private static boolean appears in assignment context ( expression expression ) { if ( expression . get parent node ( ) . is present ( ) ) { node parent = expression . get parent node ( ) . get ( ) ; if ( parent instanceof expression stmt ) { return bool ; } if ( parent instanceof method call expr ) { return bool ; } if ( parent instanceof return stmt ) { return bool ; } throw new unsupported operation exception ( parent . get class ( ) . get canonical name ( ) ) ; } return bool ; }	Not sure if should look if the parent is an assignment context.
public float [ ] predict ( f feat , boolean output margin , int ntree limit ) { float [ ] preds = predict raw ( feat , ntree limit ) ; if ( ! output margin ) { preds = obj . pred transform ( preds ) ; } return preds ; }	Generates predictions for given feature vector.
public void load model ( model reader reader ) throws io { param = new param ( reader ) ; nodes = new node [ param . num nodes ] ; for ( int i = num ; i < param . num nodes ; i ++ ) { nodes [ i ] = new node ( reader ) ; } stats = new r [ param . num nodes ] ; for ( int i = num ; i < param . num nodes ; i ++ ) { stats [ i ] = new r ( reader ) ; } }	Loads model from stream.
@ override public int get leaf index ( f feat , int root id ) { int pid = root id ; node n ; while ( ! ( n = nodes [ pid ] ) . is leaf ) { pid = n . next ( feat ) ; } return pid ; }	Retrieves nodes from root to leaf and returns leaf index.
@ override public float get leaf value ( f feat , int root id ) { node n = nodes [ root id ] ; while ( ! n . is leaf ) { n = nodes [ n . next ( feat ) ] ; } return n . leaf value ; }	Retrieves nodes from root to leaf and returns leaf value.
public string unflatten ( ) { string writer sw = new string writer ( ) ; if ( root . is array ( ) ) { try { unflatten array ( root . as array ( ) ) . write to ( sw , get writer config ( ) ) ; } catch ( io e ) { } return sw . to string ( ) ; } if ( ! root . is object ( ) ) { return root . to string ( ) ; } json object flattened = root . as object ( ) ; json value unflattened = flattened . names ( ) . is empty ( ) ? json . object ( ) : null ; for ( string key : flattened . names ( ) ) { json value current val = unflattened ; string obj key = null ; integer ary idx = null ; matcher matcher = key part pattern ( ) . matcher ( key ) ; while ( matcher . find ( ) ) { string key part = matcher . group ( ) ; if ( obj key != null ^ ary idx != null ) { if ( is json array ( key part ) ) { current val = find or create json array ( current val , obj key , ary idx ) ; obj key = null ; ary idx = extract index ( key part ) ; } else {	Returns a JSON string of nested objects by the given flattened JSON string.
public string flatten ( ) { flatten as map ( ) ; if ( source . is object ( ) || is objectifiable array ( ) ) return flattened map . to string ( print mode ) ; else return java obj2 json ( flattened map . get ( root ) ) ; }	Returns a flattened JSON string.
public map < string , object > flatten as map ( ) { if ( flattened map != null ) return flattened map ; flattened map = new jsonify linked hash map ( ) ; reduce ( source ) ; while ( ! element iters . is empty ( ) ) { indexed peek iterator < ? > deepest iter = element iters . get last ( ) ; if ( ! deepest iter . has next ( ) ) { element iters . remove last ( ) ; } else if ( deepest iter . peek ( ) instanceof member ) { member mem = ( member ) deepest iter . next ( ) ; reduce ( mem . get value ( ) ) ; } else {	Returns a flattened JSON as Map.
public static < e > list < e > concat view ( list < list < ? extends e > > lists ) { if ( lists . is empty ( ) ) { return collections . empty list ( ) ; } else { return concat view . create ( lists ) ; } }	Returns a list that is a concatenation of the given lists.
public static event stream < void > invalidations of ( observable observable ) { return new event stream base < void > ( ) { @ override protected subscription observe inputs ( ) { invalidation listener listener = obs -> emit ( null ) ; observable . add listener ( listener ) ; return ( ) -> observable . remove listener ( listener ) ; } } ; }	Creates an event stream that emits an impulse on every invalidationof the given observable.
public static < o extends observable > event stream < o > repeat on invalidation ( o observable ) { return new event stream base < o > ( ) { @ override protected subscription observe inputs ( ) { invalidation listener listener = obs -> emit ( observable ) ; observable . add listener ( listener ) ; return ( ) -> observable . remove listener ( listener ) ; } @ override protected void new observer ( consumer < ? super o > subscriber ) { subscriber . accept ( observable ) ; } } ; }	Creates an event stream that emits the given observable immediately forevery subscriber and re-emits it on every subsequent invalidation of theobservable.
public static event stream < long > animation frames ( ) { return animation ticks ( ) . accumulate ( t ( num , - num ) , ( state , now ) -> state . map ( ( d , last ) -> { return t ( last == - num ? num : now - last , now ) ; } ) ) . map ( t -> t . 1 ) ; }	Returns a stream that, on each animation frame, emits the durationelapsed since the previous animation frame, in nanoseconds.
public static < t > event stream < t > merge ( observable set < ? extends event stream < t > > set ) { return new event stream base < t > ( ) { @ override protected subscription observe inputs ( ) { return subscription . dynamic ( set , s -> s . subscribe ( this :: emit ) ) ; } } ; }	Returns an event stream that emits all the events emitted from any ofthe event streams in the given observable set.
@ deprecated public static < e > observable list < e > wrap ( javafx . collections . observable list < e > delegate ) { return live list . suspendable ( delegate ) ; }	Creates an ObservableList wrapper that is able to temporarily blocklist change notifications.
public < t > t on while ( supplier < t > f ) { try ( guard g = on ( ) ) { return f . get ( ) ; } }	Runs the given computation, making sure this indicator is on.When done, this indicator is reset to the previous state.
@ override public final subscription observe ( o observer ) { p adapted = adapt observer ( observer ) ; underlying . add observer ( adapted ) ; return ( ) -> underlying . remove observer ( adapted ) ; }	Overridden to avoid second transformation on removeObserver.
public metadata copy ( ) { metadata result = new metadata ( ) ; result . set encoding ( encoding ) ; result . set trailing slash ( trailing slash ) ; result . set leading slash ( leading slash ) ; return result ; }	Return a copy of this Metadata.
protected string strip known prefix ( string str , string prefix ) { int start index = str . last index of ( prefix ) ; if ( start index != - num ) { return str . substring ( start index + prefix . length ( ) ) ; } return null ; }	Strip everything up to and including a given prefix from a string.
private digester configure digester ( final digester digester ) { digester . set use context class loader ( bool ) ; digester . add object create ( str , rewrite rule . class ) ; digester . add set properties ( str ) ; digester . add set next ( str , str ) ; digester . add object create ( str , url mapping . class ) ; digester . add set properties ( str ) ; digester . add call method ( str , str , num ) ; digester . add call param ( str , num , str ) ; digester . add call method ( str , str , num ) ; digester . add call method ( str , str , num ) ; digester . add call param ( str , num , str ) ; digester . add call method ( str , str , num ) ; digester . add object create ( str , path validator . class ) ; digester . add set properties ( str ) ; digester . add set next ( str , str ) ; digester . add object create ( str , query parameter . class ) ; digester . add set properties ( str ) ; digester . add call method ( str , str , num ) ; digester . add set next ( str , str ) ; digester . add object create ( str , url action . class ) ; digester . add set properties ( str ) ; digester . add call method ( str , str , num ) ; digester . add set next ( str , str ) ; digester . add set next ( str , str ) ; return digester ; }	Configure the digester. Assume that the builder object will be pushedafter this method is called.
public string [ ] process class mapping annotations ( class < ? > clazz ) {	Checks for PrettyFaces mapping annotations on a single class.
private static string join ( string [ ] values , string separator ) { string builder result = new string builder ( ) ; if ( values != null ) { for ( int i = num ; i < values . length ; i ++ ) { if ( i > num ) { result . append ( separator ) ; } result . append ( values [ i ] ) ; } } return result . to string ( ) ; }	Joins the list of values.
public void init device scan ( ) {	Initialize Key Stored Values.
public boolean detect iphone ( ) { if ( ( this . init completed == bool ) || ( this . is iphone == bool ) ) return this . is iphone ;	Detects if the current device is an iPhone.
public boolean detect webkit ( ) { if ( ( this . init completed == bool ) || ( this . is webkit == bool ) ) return this . is webkit ; if ( user agent . index of ( engine web kit ) != - num ) { return bool ; } return bool ; }	Detects if the current browser is based on WebKit.
public boolean detect windows mobile ( ) { if ( detect windows phone ( ) ) { return bool ; }	Detects if the current browser is a Windows Mobile device.
public boolean detect black berry ( ) { if ( user agent . index of ( device bb ) != - num || http accept . index of ( vnd rim ) != - num ) return bool ; if ( detect black berry10 phone ( ) ) return bool ; return bool ; }	Detects if the current browser is any BlackBerry.
public boolean detect s60 oss browser ( ) {	Detects if the current browser is the Symbian S60 Open Source Browser.
public boolean detect palm os ( ) {	Detects if the current browser is on a PalmOS device.
public boolean detect opera android phone ( ) { if ( user agent . index of ( engine opera ) != - num && ( user agent . index of ( device android ) != - num && user agent . index of ( mobi ) != - num ) ) { return bool ; } return bool ; }	Detects Opera Mobile on an Android phone.
public boolean detect opera android tablet ( ) { if ( user agent . index of ( engine opera ) != - num && ( user agent . index of ( device android ) != - num && user agent . index of ( device tablet ) != - num ) ) { return bool ; } return bool ; }	Detects Opera Mobile on an Android tablet.
public boolean detect maemo tablet ( ) { if ( user agent . index of ( maemo ) != - num ) { return bool ; } else if ( user agent . index of ( linux ) != - num && user agent . index of ( device tablet ) != - num && ! detect web os ( ) && ! detect android ( ) ) { return bool ; } return bool ; }	Detects if the current device is on one of the Maemo-based Nokia Internet Tablets.
public boolean detect mobile quick ( ) {	Detects if the current device is a mobile device.
public boolean detect tier iphone ( ) { if ( ( this . init completed == bool ) || ( this . is tier iphone == bool ) ) return this . is tier iphone ; if ( detect iphone or ipod ( ) || detect android phone ( ) || detect windows phone ( ) || detect black berry10 phone ( ) || ( detect black berry web kit ( ) && detect black berry touch ( ) ) || detect palm web os ( ) || detect bada ( ) || detect tizen ( ) || detect gaming handheld ( ) ) { return bool ; } return bool ; }	The quick way to detect for a tier of devices.
public boolean detect tier other phones ( ) { if ( ( this . init completed == bool ) || ( this . is tier generic mobile == bool ) ) return this . is tier generic mobile ;	The quick way to detect for a tier of devices.
public static boolean is el ( final string value ) { if ( value == null ) { return bool ; } return el pattern . matcher ( value ) . matches ( ) ; }	Return true if the value is an EL expression.
public static boolean contains el ( final string value ) { if ( value == null ) { return bool ; } return el pattern . matcher ( value ) . find ( ) ; }	Return true if the value contains an EL expression.
private string build script internal ( final string url ) { string builder builder = new string builder ( ) ; builder . append ( str ) ; builder . append ( url ) ; builder . append ( str ) ; return builder . to string ( ) ; }	Creates the required script for the supplied URL.
public static el method ( final string retrieve , final string submit ) { return new el method ( new constant expression ( retrieve ) , new constant expression ( submit ) ) ; }	Create a new EL Method binding using distinct expressions to submit and retrieve values.
private boolean contains field descriptor ( string str ) { for ( string descriptor : field descriptors ) { if ( str . contains ( descriptor ) ) { return bool ; } } return bool ; }	Returns true if the given string contains a field descriptor of one of the annotations we are looking for.
protected void copy response headers ( http response proxy response , http servlet response servlet response ) { for ( header header : proxy response . get all headers ( ) ) { if ( hop by hop headers . contains header ( header . get name ( ) ) ) continue ; servlet response . add header ( header . get name ( ) , header . get value ( ) ) ; } }	Copy proxied response headers back to the servlet client.
protected static char sequence encode uri query ( char sequence in ) { string builder out buf = null ; formatter formatter = null ; for ( int i = num ; i < in . length ( ) ; i ++ ) { char c = in . char at ( i ) ; boolean escape = bool ; if ( c < num ) { if ( ascii query chars . get ( c ) ) { escape = bool ; } } else if ( ! character . is iso ( c ) && ! character . is space char ( c ) ) { escape = bool ; } if ( ! escape ) { if ( out buf != null ) out buf . append ( c ) ; } else { if ( out buf == null ) { out buf = new string builder ( in . length ( ) + num * num ) ; out buf . append ( in , num , i ) ; formatter = new formatter ( out buf ) ; } formatter . format ( str , ( int ) c ) ;	Encodes characters in the query or fragment part of the URI.
public uri to uri ( ) { try { uri uri = new uri ( to url ( ) ) ; return uri ; } catch ( uri e ) { throw new illegal state exception ( str , e ) ; } }	Return a URI representation of this URL including path and query string.
public static query string build ( final string url ) { query string query string = new query string ( ) ; query string . add parameters ( url ) ; return query string ; }	Build a query string from the given URL.
public string get parameter ( final string name ) { list < string > values = parameters . get ( name ) ; if ( values == null ) { return null ; } if ( values . size ( ) == num ) { return str ; } return values . get ( num ) ; }	Get the first value of given parameter name.
public string [ ] get parameter values ( final string name ) { list < string > values = parameters . get ( name ) ; if ( values == null ) { return null ; } return values . to array ( new string [ values . size ( ) ] ) ; }	Get the array of values for a given parameter name.
public void add parameters ( string url ) { if ( ( url != null ) && ! str . equals ( url ) ) { url = url . trim ( ) ; if ( url . length ( ) > num ) { if ( url . contains ( str ) ) { url = url . substring ( url . index of ( str ) + num ) ; } string pairs [ ] = url . split ( str ) ; for ( string pair : pairs ) { string name ; string value ; int pos = pair . index of ( str ) ;	Add parameters from the given URL.
@ override public string derive view id ( final faces context context , final string raw view id ) { string canonical view id = new url ( ) . canonicalize ( raw view id ) ; return parent . derive view id ( context , canonical view id ) ; }	Canonicalize the given viewId, then pass that viewId to the next ViewHandler in the chain.
public url get pattern parser ( ) { if ( ( parser == null ) && ( pattern != null ) ) { this . parser = new url ( pattern ) ; } return parser ; }	Get this patterns pattern parser instance.
public list < path validator > get validators for path param ( final path parameter param ) { list < path validator > result = new array list < path validator > ( ) ; for ( path validator pv : path validators ) { if ( pv . get index ( ) == param . get position ( ) ) { result . add ( pv ) ; } } return result ; }	Return a list of validators that belong to the given parameter.
public static query string builder create from encoded ( final string parameters ) { query string builder query string = new query string builder ( ) ; query string . add parameters ( parameters ) ; return query string ; }	Build a query string from the given URL.
public static string extract query ( string url ) { if ( url != null ) { int index = url . index of ( str ) ; if ( index >= num ) { url = url . substring ( index + num ) ; } } return url ; }	Get the query string portion of the given URL.
public void add parameter ( final string name , final string ... values ) { map < string , string [ ] > parameter = new linked hash map < string , string [ ] > ( ) ; parameter . put ( name , values ) ; add parameter arrays ( parameter ) ; }	Add a single parameter with the given values.
@ suppress warnings ( str ) private list < dispatcher type provider > get dispatcher type providers ( http servlet rewrite event ) { list < dispatcher type provider > providers = ( list < dispatcher type provider > ) event . get request ( ) . get attribute ( provider key ) ; if ( providers == null ) { providers = iterators . as list ( service loader . load typesafe ( dispatcher type provider . class ) . iterator ( ) ) ; collections . sort ( providers , new weighted comparator ( ) ) ; event . get request ( ) . set attribute ( provider key , providers ) ; } return providers ; }	Simple caching mechanism for the providers on a per request basis.
public static int get negation count ( final evaluation context context ) { if ( context == null ) return num ; integer count = ( integer ) context . get ( negation count key ) ; return count == null ? num : count ; }	Returns the number of "Not"s that have been evaluated in the current evaluation process.For example, when(Not.any(MyCondition)) would have a "NotCount" of "1" during the evaluation of "MyCondition".when(Not.any(Not.any(MyCondition))) would have a "NotCount" of "2" during the evaluation of "MyCondition".This is useful for conditions that may have side effects, as they will know whether or not their condition is beingnegated.
public navigate with ( char sequence name , object value ) { assert . not null ( name , str ) ; if ( value != null ) { parameters . put ( name . to string ( ) , value . to string ( ) ) ; } return this ; }	Set a query parameter to be passed to the specified View Id.
private string build standard outcome ( ) { string builder outcome = new string builder ( ) ; outcome . append ( view id ) ; boolean first = bool ; for ( entry < string , list < string > > param : parameters . entry set ( ) ) { for ( string value : param . get value ( ) ) { outcome . append ( first ? str : str ) ; outcome . append ( param . get key ( ) ) ; outcome . append ( str ) ; outcome . append ( value ) ; first = bool ; } } return outcome . to string ( ) ; }	Builds a standard JSF 2.0 implicit navigation outcome.
private void handle class entry ( string entry name , class visitor visitor ) {	Handles class entry in a WEB-INF.
address builder query query literal ( string query ) { if ( query != null ) { if ( query . starts with ( str ) ) query = query . substring ( num ) ; map < char sequence , list < char sequence > > params = new linked hash map < char sequence , list < char sequence > > ( ) ; query = decode html ( query ) ; int index = num ; while ( ( index = query . index of ( str ) ) >= num || ! query . is empty ( ) ) { string pair = query ; if ( index >= num ) { pair = query . substring ( num , index ) ; query = query . substring ( index ) ; if ( ! query . is empty ( ) ) query = query . substring ( num ) ; } else query = str ; string name ; string value ; int pos = pair . index of ( str ) ;	Set a literal query string without additional encoding or decoding.
public encode query excluding ( final string ... params ) { if ( ( params != null ) && ( params . length > num ) ) this . excluded params . add all ( arrays . as list ( params ) ) ; return this ; }	Exclude the given query-parameter names from encoding.
public url build url ( final url mapping mapping ) { url result = null ; string expression = str ; object value = null ; try { faces context context = faces context . get current instance ( ) ; url parser = mapping . get pattern parser ( ) ; list < path parameter > parameters = parser . get path parameters ( ) ; list < string > parameter values = new array list < string > ( ) ; for ( path parameter injection : parameters ) {	For all required values of the given PrettyUrlMapping, extract values from their mapped backing beans and create aURL based on the url-pattern.
public void send error ( int code , string message , http servlet response response ) { assert . not null ( response , str ) ; try { if ( message != null ) { response . send error ( code , message ) ; } else { response . send error ( code ) ; } } catch ( io e ) { throw new illegal state exception ( str + code , e ) ; } }	Sends an error response to the client using the specified HTTP statuscode.
@ override public void visit ( class < ? > clazz ) { class context impl context = new class context impl ( builder , clazz ) ; context . put ( clazz , payload ) ; if ( log . is trace enabled ( ) ) { log . trace ( str , clazz . get name ( ) ) ; }	Processes the annotation on the supplied class.
private string prepend context path ( external context external context , string url ) { string context path = external context . get request context path ( ) ; if ( str . equals ( context path ) || ( url . starts with ( context path ) ) ) { return url ; } return context path + url ; }	Adds the context path to the given context-relative URL.
private string strip context path ( final string context path , string uri ) { if ( ! context path . equals ( str ) && uri . starts with ( context path ) ) { uri = uri . substring ( context path . length ( ) ) ; } return uri ; }	If the given URL is prefixed with this request's context-path, return the URI without the context path.
private string translate ( string lang , string value ) { string translatation = null ; if ( value != null ) { if ( ! bundle map . contains key ( lang ) ) { locale locale = new locale ( lang ) ; try { resource bundle loaded bundle = resource bundle . get bundle ( bundle name , locale , resource bundle . control . get no fallback control ( resource bundle . control . format default ) ) ; bundle map . put ( lang , loaded bundle ) ; } catch ( missing resource exception e ) { return null ; } } try {	Translate a value into the matching one from a resource bundle in specified language.
public string build dyna view id ( final string faces servlet mapping ) { string buffer result = new string buffer ( ) ; map < pattern , string > patterns = new linked hash map < pattern , string > ( ) ; pattern path mapping = pattern . compile ( str ) ; pattern extension mapping = pattern . compile ( str ) ; pattern default mapping = pattern . compile ( str ) ; patterns . put ( path mapping , str + dynaview + str ) ; patterns . put ( extension mapping , str + dynaview + str ) ; patterns . put ( default mapping , str + dynaview + str ) ; boolean matched = bool ; iterator < pattern > iterator = patterns . key set ( ) . iterator ( ) ; while ( ( matched == bool ) && iterator . has next ( ) ) { pattern p = iterator . next ( ) ; matcher m = p . matcher ( faces servlet mapping ) ; if ( m . matches ( ) ) { string replacement = patterns . get ( p ) ; m . append replacement ( result , replacement ) ; matched = bool ; } } if ( matched == bool ) {	Given the string value of the Faces Servlet mapping, return a string that is guaranteed to match when a servletforward is issued.
public void process dyna view ( final pretty context pretty context , final faces context faces context ) { log . trace ( str + pretty context . get request url ( ) ) ; string view id = str ; try { view id = pretty context . get current view id ( ) ; log . trace ( str + view id ) ; object result = compute dyna view id ( faces context ) ; if ( result instanceof string ) { view id = ( string ) result ; log . trace ( str + view id ) ; pretty context . set dynaview processed ( bool ) ; faces context . get external context ( ) . dispatch ( view id ) ; faces context . response complete ( ) ; } } catch ( exception e ) { log . error ( str , e ) ; pretty redirector pretty redirector = new pretty redirector ( ) ; pretty redirector . send404 ( faces context ) ; throw new pretty exception ( str + view id + str , e ) ; } }	Handle DynaView processing. This method will end the Faces life-cycle.
private type get required type ( class < ? > clazz ) { type variable < ? > [ ] type parameters = clazz . get type parameters ( ) ; if ( type parameters . length > num ) { type [ ] actual type parameters = new type [ type parameters . length ] ; for ( int i = num ; i < type parameters . length ; i ++ ) { actual type parameters [ i ] = new wildcard type impl ( new type [ ] { object . class } , new type [ ] { } ) ; } return new parameterized type impl ( clazz , actual type parameters , null ) ; } return clazz ; }	Builds the correct "required type" including actual type arguments in case of parameterized types.
@ suppress warnings ( str ) public static < t extends annotation > t get annotation proxy ( annotation custom annotation , class < t > reference annotation ) { invocation handler handler = new annotation invocation handler ( custom annotation ) ; return ( t ) proxy . new proxy instance ( reference annotation . get class loader ( ) , new class [ ] { reference annotation } , handler ) ; }	Returns a proxy on the customAnnotation, having the same type than the referenceAnnotation.
private collection < field > get filtered fields ( class < ? > ref class ) { soft reference < collection < field > > ref = field cache . get ( ref class ) ; collection < field > field list = ref != null ? ref . get ( ) : null ; if ( field list != null ) { return field list ; } else { collection < field > result ; result = size of filter . filter fields ( ref class , get all fields ( ref class ) ) ; if ( use verbose debug logging && log . is debug enabled ( ) ) { for ( field field : result ) { if ( modifier . is transient ( field . get modifiers ( ) ) ) { log . debug ( str , field . get name ( ) , ref class . get name ( ) ) ; } } } field cache . put ( ref class , new soft reference < > ( result ) ) ; return result ; } }	Returns the filtered fields for a particular type.
private static collection < field > get all fields ( class < ? > ref class ) { collection < field > fields = new array list < > ( ) ; for ( class < ? > klazz = ref class ; klazz != null ; klazz = klazz . get superclass ( ) ) { for ( field field : klazz . get declared fields ( ) ) { if ( ! modifier . is static ( field . get modifiers ( ) ) && ! field . get type ( ) . is primitive ( ) ) { try { field . set accessible ( bool ) ; } catch ( security exception e ) { log . error ( str + str , field , e ) ; continue ; } fields . add ( field ) ; } } } return fields ; }	Returns all non-primitive fields for the entire class hierarchy of a type.
public v put ( k key , v value ) { clean up ( ) ; return map . put ( new identity weak reference < > ( key , queue ) , value ) ; }	Puts into the underlying.
public v remove ( k key ) { clean up ( ) ; return map . remove ( new identity weak reference < > ( key , queue ) ) ; }	Remove from the underlying.
static boolean load agent ( ) { synchronized ( agent loader . class . get name ( ) . intern ( ) ) { if ( ! agent is available ( ) && virtual machine load agent != null ) { try { warn if osx ( ) ; string name = management factory . get runtime mx ( ) . get name ( ) ; object vm = virtual machine attach . invoke ( null , name . substring ( num , name . index of ( str ) ) ) ; try { file agent = get agent file ( ) ; logger . info ( str , agent ) ; if ( agent != null ) { virtual machine load agent . invoke ( vm , agent . get absolute path ( ) ) ; } } finally { virtual machine detach . invoke ( vm ) ; } } catch ( invocation target exception ite ) { throwable cause = ite . get cause ( ) ; logger . info ( str , cause . get class ( ) , cause . get message ( ) ) ; } catch ( throwable t ) { logger . info ( str , t . get class ( ) , t . get message ( ) ) ; } } final boolean b = agent is available ( ) ; if ( b ) { logger . info ( str ) ; } return b ; } }	Attempts to load the agent through the Attach API.
static boolean agent is available ( ) { try { if ( instrumentation == null ) { instrumentation = ( instrumentation ) system . get properties ( ) . get ( instrumentation instance system property name ) ; } if ( instrumentation == null ) { class < ? > size of agent class = class loader . get system class loader ( ) . load class ( sizeof agent classname ) ; method get instrumentation method = size of agent class . get method ( str ) ; instrumentation = ( instrumentation ) get instrumentation method . invoke ( size of agent class ) ; } return instrumentation != null ; } catch ( security exception e ) { logger . warn ( str + str + str + str + str ) ; return bool ; } catch ( throwable e ) { return bool ; } }	Checks whether the agent is available.
public static void copy file ( plexus io resource in , file out file ) throws io { input stream input = null ; output stream output = null ; try { input = in . get contents ( ) ; output = new file output stream ( out file ) ; io . copy ( input , output ) ; } finally { io . close ( input ) ; io . close ( output ) ; } }	Copies the sources contents to the given destination file.
public static boolean is same ( plexus io resource resource , file file ) { if ( resource instanceof file supplier ) { file resource file = ( ( file supplier ) resource ) . get file ( ) ; return file . equals ( resource file ) ; } return bool ; }	Checks, whether the resource and the file are identical.
public void add webinf ( file directory name , string [ ] includes , string [ ] excludes ) throws archiver exception { add directory ( directory name , str , includes , excludes ) ; }	files to add under WEB-INF;.
protected void init zip output stream ( zip archive output stream z out ) throws archiver exception , io {	override of parent; validates configurationbefore initializing the output stream.
protected void zip file ( archive entry entry , zip archive output stream z out , string v path ) throws io , archiver exception {	Overridden from ZipArchiver class to deal with web.xml.
public static manifest get default manifest ( ) throws archiver exception { try { string def manifest = str ; input stream in = manifest . class . get resource as stream ( def manifest ) ; if ( in == null ) { throw new archiver exception ( str + def manifest ) ; } try { manifest default manifest = new manifest ( new input stream reader ( in , str ) ) ; default manifest . get main attributes ( ) . put value ( str , system . get property ( str ) + str + system . get property ( str ) + str ) ; return default manifest ; } catch ( unsupported encoding exception e ) { return new manifest ( new input stream reader ( in ) ) ; } finally { io . close ( in ) ; } } catch ( manifest exception e ) { throw new archiver exception ( str , e ) ; } catch ( io e ) { throw new archiver exception ( str , e ) ; } }	Construct a manifest from Ant's default manifest file.
public void add configured section ( section section ) throws manifest exception { string section name = section . get name ( ) ; if ( section name == null ) { throw new manifest exception ( str ) ; } attributes attributes = get or create attributes ( section name ) ; for ( string s : section . attributes . key set ( ) ) { attribute attribute = section . get attribute ( s ) ; attributes . put value ( attribute . get name ( ) , attribute . get value ( ) ) ; } }	Add a section to the manifest.
public void write ( print writer writer ) throws io { byte array output stream byte array output stream = new byte array output stream ( ) ; super . write ( byte array output stream ) ; for ( byte b : byte array output stream . to byte array ( ) ) { writer . write ( ( char ) b ) ; } }	Write the manifest out to a print writer.
enumeration < string > get warnings ( ) { vector < string > warnings = new vector < string > ( ) ; enumeration < string > warn enum = main section . get warnings ( ) ; while ( warn enum . has more elements ( ) ) { warnings . add element ( warn enum . next element ( ) ) ; } return warnings . elements ( ) ; }	Get the warnings for this manifest.
public existing section get section ( string name ) { attributes attributes = get attributes ( name ) ; if ( attributes != null ) { return new existing section ( attributes , name ) ; } return null ; }	Get a particular section from the manifest.
protected void copy file ( final archive entry entry , final string v path ) throws archiver exception , io {	Copies the specified file to the specified path, creating any ancestor directory structure as necessary.
public void add configured manifest ( manifest new manifest ) throws manifest exception { if ( configured manifest == null ) { configured manifest = new manifest ; } else { jdk manifest factory . merge ( configured manifest , new manifest , bool ) ; } saved configured manifest = configured manifest ; }	Allows the manifest for the archive file to be provided inlinein the build file rather than in an external file.
protected void zip file ( input stream is , zip archive output stream z out , string v path , long last modified , file from archive , int mode , string symlink destination ) throws io , archiver exception { if ( manifest name . equals ignore case ( v path ) ) { if ( ! double file pass || skip writing ) { fileset manifest ( from archive , is ) ; } } else if ( index name . equals ignore case ( v path ) && index ) { get logger ( ) . warn ( str + archive type + str + str ) ; } else { if ( index && ( ! v path . contains ( str ) ) ) { root entries . add element ( v path ) ; } super . zip file ( is , z out , v path , last modified , from archive , mode , symlink destination ) ; } }	Overridden from Zip class to deal with manifests and index lists.
protected void clean up ( ) throws io { super . clean up ( ) ;	Make sure we don't think we already have a MANIFEST next time this taskgets executed.
public void reset ( ) { super . reset ( ) ; configured manifest = null ; fileset manifest config = null ; merge manifests main = bool ; manifest file = null ; index = bool ; }	reset to default values.
protected final void write index like list ( list < string > dirs , list < string > files , print writer writer ) {	Writes the directory entries from the first and the filenamesfrom the second list to the given writer, one entry per line.
protected static void grab files and dirs ( string file , list < string > dirs , list < string > files ) throws io { file zip file = new file ( file ) ; if ( ! zip file . exists ( ) ) { logger logger = new console logger ( logger . level info , str ) ; logger . error ( str + zip file . get absolute path ( ) ) ; } else if ( zip file . is directory ( ) ) { logger logger = new console logger ( logger . level info , str ) ; logger . info ( str + zip file + str ) ; } else { org . apache . commons . compress . archivers . zip . zip file zf = null ; try { zf = new org . apache . commons . compress . archivers . zip . zip file ( file , str ) ; enumeration < zip archive entry > entries = zf . get entries ( ) ; hash set < string > dir set = new hash set < string > ( ) ; while ( entries . has more elements ( ) ) { zip archive entry ze = entries . next element ( ) ; string name = ze . get name ( ) ;	Grab lists of all root-level files and all directoriescontained in the given archive.
private input stream decompress ( untar compression method compression , final file file , final input stream istream ) throws io , archiver exception { if ( compression == untar compression method . gzip ) { return new gzip ( istream ) ; } else if ( compression == untar compression method . bzi ) { return new b ( istream ) ; } else if ( compression == untar compression method . snappy ) { return new snappy input stream ( istream ) ; } return istream ; }	This method wraps the input stream with thecorresponding decompression method.
public void compress ( ) throws archiver exception { try { z out = new gzip ( streams . buffered output stream ( new file output stream ( get dest file ( ) ) ) ) ; compress ( get source ( ) , z out ) ; } catch ( io ioe ) { string msg = str + ioe . get message ( ) ; throw new archiver exception ( msg , ioe ) ; } }	perform the GZip compression operation.
public static void merge attributes ( java . util . jar . attributes target , java . util . jar . attributes section ) { for ( object o : section . key set ( ) ) { java . util . jar . attributes . name key = ( attributes . name ) o ; final object value = section . get ( o ) ;	Merge in another section.
public void set appxml ( file descr ) throws archiver exception { deployment descriptor = descr ; if ( ! deployment descriptor . exists ( ) ) { throw new archiver exception ( str + deployment descriptor + str ) ; } add file ( descr , str ) ; }	File to incorporate as application.xml.
public void compress ( ) throws archiver exception { try { z out = new snappy output stream ( buffered output stream ( file output stream ( get dest file ( ) ) ) ) ; compress ( get source ( ) , z out ) ; } catch ( io ioe ) { string msg = str + ioe . get message ( ) ; throw new archiver exception ( msg , ioe ) ; } }	perform the Snappy compression operation.
@ suppress warnings ( { str } ) protected final void add resources ( resource iterator resources , zip archive output stream z out ) throws io , archiver exception { file base = null ; while ( resources . has next ( ) ) { archive entry entry = resources . next ( ) ; string name = entry . get name ( ) ; name = name . replace ( file . separator char , str ) ; if ( str . equals ( name ) ) { continue ; } if ( entry . get resource ( ) . is directory ( ) && ! name . ends with ( str ) ) { name = name + str ; } add parent dirs ( entry , base , name , z out , str ) ; if ( entry . get resource ( ) . is file ( ) ) { zip file ( entry , z out , name ) ; } else { zip dir ( entry . get resource ( ) , z out , name , entry . get mode ( ) ) ; } } }	Add the given resources.
@ suppress warnings ( { str } ) private void add parent dirs ( archive entry archive entry , file base dir , string entry , zip archive output stream z out , string prefix ) throws io { if ( ! do filesonly && get include empty dirs ( ) ) { stack < string > directories = new stack < string > ( ) ;	Ensure all parent dirs of a given entry have been added.This method is computed in terms of the potentially remapped entry (that may be disconnected from the file system)we do not *relly* know the entry's connection to the file system so establishing the attributes of the parents canbe impossible and is not really supported.
@ suppress warnings ( { str } ) protected boolean create empty zip ( file zip file ) throws archiver exception {	Create an empty zip file.
public void reset ( ) { set dest file ( null ) ;	Makes this instance reset all attributes to their defaultvalues and forget all children.
private void compress file ( input stream in , output stream z out ) throws io { byte [ ] buffer = new byte [ num * num ] ; int count = num ; do { z out . write ( buffer , num , count ) ; count = in . read ( buffer , num , buffer . length ) ; } while ( count != - num ) ; }	compress a stream to an output stream.
protected void compress ( plexus io resource resource , output stream z out ) throws io { input stream in = streams . buffered input stream ( resource . get contents ( ) ) ; try { compress file ( in , z out ) ; } finally { io . close ( in ) ; } }	compress a resource to an output stream.
public void set max header table size ( int max header table size ) { max dynamic table size = max header table size ; if ( max dynamic table size < encoder max dynamic table size ) {	Set the maximum table size.If this is below the maximum size of the dynamic table used by the encoder,the beginning of the next header block MUST signal this change.
private static int decode ul ( input stream in ) throws io { in . mark ( num ) ; int result = num ; int shift = num ; while ( shift < num ) { if ( in . available ( ) == num ) {	Unsigned Little Endian Base 128 Variable-Length Integer Encoding.
static int get index ( byte [ ] name ) { string name string = new string ( name , num , name . length , iso 8859 1 ) ; integer index = static index by name . get ( name string ) ; if ( index == null ) { return - num ; } return index ; }	Returns the lowest index value for the given header field name in the static table.Returns -1 if the header field name is not in the static table.
static int get index ( byte [ ] name , byte [ ] value ) { int index = get index ( name ) ; if ( index == - num ) { return - num ; }	Returns the index value for the given header field in the static table.Returns -1 if the header field is not in the static table.
private static map < string , integer > create map ( ) { int length = static table . size ( ) ; hash map < string , integer > ret = new hash map < string , integer > ( length ) ;	create a map of header name to index value to allow quick lookup.
public int get encoded length ( byte [ ] data ) { if ( data == null ) { throw new null pointer exception ( str ) ; } long len = num ; for ( byte b : data ) { len += lengths [ b & num ] ; } return ( int ) ( ( len + num ) > > num ) ; }	Returns the number of bytes required to Huffman encode the input string literal.
public int length ( ) { int length ; if ( head < tail ) { length = header fields . length - tail + head ; } else { length = head - tail ; } return length ; }	Return the number of header fields in the dynamic table.
public void add ( header field header ) { int header size = header . size ( ) ; if ( header size > capacity ) { clear ( ) ; return ; } while ( size + header size > capacity ) { remove ( ) ; } header fields [ head ++ ] = header ; size += header . size ( ) ; if ( head == header fields . length ) { head = num ; } }	Add the header field to the dynamic table.Entries are evicted from the dynamic table until the size of the tableand the new header field is less than or equal to the table's capacity.If the size of the new entry is larger than the table's capacity,the dynamic table will be cleared.
public void set capacity ( int capacity ) { if ( capacity < num ) { throw new illegal argument exception ( str + capacity ) ; }	Set the maximum size of the dynamic table.Entries are evicted from the dynamic table until the size of the tableis less than or equal to the maximum size.
public void encode header ( output stream out , byte [ ] name , byte [ ] value , boolean sensitive ) throws io {	Encode the header field into the header block.
public void set max header table size ( output stream out , int max header table size ) throws io { if ( max header table size < num ) { throw new illegal argument exception ( str + max header table size ) ; } if ( capacity == max header table size ) { return ; } capacity = max header table size ; ensure capacity ( num ) ; encode integer ( out , num , num , max header table size ) ; }	Set the maximum table size.
private static void encode integer ( output stream out , int mask , int n , int i ) throws io { if ( n < num || n > num ) { throw new illegal argument exception ( str + n ) ; } int nbits = num > > > ( num - n ) ; if ( i < nbits ) { out . write ( mask | i ) ; } else { out . write ( mask | nbits ) ; int length = i - nbits ; while ( bool ) { if ( ( length & ~ num ) == num ) { out . write ( length ) ; return ; } else { out . write ( ( length & num ) | num ) ; length >>>= num ; } } } }	Encode integer according to Section 5.1.
private void encode string literal ( output stream out , byte [ ] string ) throws io { int huffman length = huffman . encoder . get encoded length ( string ) ; if ( ( huffman length < string . length && ! force huffman off ) || force huffman on ) { encode integer ( out , num , num , huffman length ) ; huffman . encoder . encode ( out , string ) ; } else { encode integer ( out , num , num , string . length ) ; out . write ( string , num , string . length ) ; } }	Encode string literal according to Section 5.2.
private void encode literal ( output stream out , byte [ ] name , byte [ ] value , index type index type , int name index ) throws io { int mask ; int prefix bits ; switch ( index type ) { case incremental : mask = num ; prefix bits = num ; break ; case none : mask = num ; prefix bits = num ; break ; case never : mask = num ; prefix bits = num ; break ; default : throw new illegal state exception ( str ) ; } encode integer ( out , mask , prefix bits , name index == - num ? num : name index ) ; if ( name index == - num ) { encode string literal ( out , name ) ; } encode string literal ( out , value ) ; }	Encode literal header field according to Section 6.2.
private void ensure capacity ( int header size ) throws io { while ( size + header size > capacity ) { int index = length ( ) ; if ( index == num ) { break ; } remove ( ) ; } }	Ensure that the dynamic table has enough room to hold 'headerSize' more bytes.Removes the oldest entry from the dynamic table until sufficient space is available.
header field get header field ( int index ) { header entry entry = head ; while ( index -- >= num ) { entry = entry . before ; } return entry ; }	Return the header field at the given index.Exposed for testing.
private header entry get entry ( byte [ ] name , byte [ ] value ) { if ( length ( ) == num || name == null || value == null ) { return null ; } int h = hash ( name ) ; int i = index ( h ) ; for ( header entry e = header fields [ i ] ; e != null ; e = e . next ) { if ( e . hash == h && hpack util . equals ( name , e . name ) && hpack util . equals ( value , e . value ) ) { return e ; } } return null ; }	Returns the header entry with the lowest index value for the header field.Returns null if header field is not in the dynamic table.
private int get index ( byte [ ] name ) { if ( length ( ) == num || name == null ) { return - num ; } int h = hash ( name ) ; int i = index ( h ) ; int index = - num ; for ( header entry e = header fields [ i ] ; e != null ; e = e . next ) { if ( e . hash == h && hpack util . equals ( name , e . name ) ) { index = e . index ; break ; } } return get index ( index ) ; }	Returns the lowest index value for the header field name in the dynamic table.Returns -1 if the header field name is not in the dynamic table.
private void add ( byte [ ] name , byte [ ] value ) { int header size = header field . size of ( name , value ) ;	Add the header field to the dynamic table.Entries are evicted from the dynamic table until the size of the tableand the new header field is less than the table's capacity.If the size of the new entry is larger than the table's capacity,the dynamic table will be cleared.
private static int hash ( byte [ ] name ) { int h = num ; for ( int i = num ; i < name . length ; i ++ ) { h = num * h + name [ i ] ; } if ( h > num ) { return h ; } else if ( h == integer . min value ) { return integer . max value ; } else { return - h ; } }	Returns the hash code for the given header field name.
public byte [ ] decode ( byte [ ] buf ) throws io { byte array output stream baos = new byte array output stream ( ) ; node node = root ; int current = num ; int bits = num ; for ( int i = num ; i < buf . length ; i ++ ) { int b = buf [ i ] & num ; current = ( current << num ) | b ; bits += num ; while ( bits >= num ) { int c = ( current > > > ( bits - num ) ) & num ; node = node . children [ c ] ; bits -= node . bits ; if ( node . is terminal ( ) ) { if ( node . symbol == hpack util . huffman eos ) { throw eos decoded ; } baos . write ( node . symbol ) ; node = root ; } } } while ( bits > num ) { int c = ( current << ( num - bits ) ) & num ; node = node . children [ c ] ; if ( node . is terminal ( ) && node . bits <= bits ) { bits -= node . bits ; baos . write ( node . symbol ) ; node = root ; } else { break ; } }	Decompresses the given Huffman coded string literal.
public void set default script names ( string script names ) { if ( ! script names . trim ( ) . is empty ( ) ) service . set default scripts ( as list ( script names . split ( str ) ) ) ; }	Set the comma delimited list of default scripts.
public void assert equal to ( description description , short actual , short expected ) { assert not null ( description , actual ) ; if ( ! is equal to ( actual , expected ) ) { throw failures . failure ( description , should be equal ( actual , expected ) ) ; } }	Verifies that two shorts are equal.
public void assert not equal to ( description description , short actual , short expected ) { assert not null ( description , actual ) ; if ( is equal to ( actual , expected ) ) { throw failures . failure ( description , should not be equal ( actual , expected ) ) ; } }	Verifies that two integers are not equal.
public void assert greater than ( description description , short actual , short expected ) { assert not null ( description , actual ) ; if ( ! is greater than ( actual , expected ) ) { throw failures . failure ( description , should be greater than . should be greater than ( actual , expected ) ) ; } }	Verifies that the actual value is greater than the expected one.
public void assert greater than ( description description , float actual , float expected ) { assert not null ( description , actual ) ; if ( ! is greater than ( actual , expected ) ) { throw failures . failure ( description , should be greater than ( actual , expected ) ) ; } }	Verifies that the actual value is great than the expected one.
public void assert equal ( description description , character actual , char expected ) { assert not null ( description , actual ) ; if ( actual . char value ( ) != expected ) { throw failures . failure ( description , should be equal ( actual , expected ) ) ; } }	Asserts that two characters are equal.
public void assert not equal ( description description , character actual , char other ) { assert not null ( description , actual ) ; if ( actual . char value ( ) == other ) { throw failures . failure ( description , should not be equal ( actual , other ) ) ; } }	Asserts that two characters are not equal.
public void assert less than ( description description , character actual , char other ) { assert not null ( description , actual ) ; if ( ! is less than ( actual , other ) ) { throw failures . failure ( description , should be less than ( actual , other ) ) ; } }	Asserts that the actual value is less than the other one.
public void assert not greater than ( description description , character actual , char other ) { assert not null ( description , actual ) ; if ( is greater than ( actual , other ) ) { throw failures . failure ( description , should not be greater than ( actual , other ) ) ; } }	Asserts that the actual value is less than or equal to the other one.
public void assert greater than ( description description , character actual , char other ) { assert not null ( description , actual ) ; if ( ! is greater than ( actual , other ) ) { throw failures . failure ( description , should be greater than ( actual , other ) ) ; } }	Asserts that the actual value is greater than the other one.
public void assert not less than ( description description , character actual , char other ) { assert not null ( description , actual ) ; if ( is less than ( actual , other ) ) { throw failures . failure ( description , should not be less than . should not be less than ( actual , other ) ) ; } }	Asserts that the actual value is greater than or equal to the other one.
public void assert lower case ( description description , character actual ) { assert not null ( description , actual ) ; if ( ! is lower case ( actual ) ) { throw failures . failure ( description , should be lower case ( actual ) ) ; } }	Asserts that the actual value is a lowercase character.
public void assert upper case ( description description , character actual ) { assert not null ( description , actual ) ; if ( ! is upper case ( actual ) ) { throw failures . failure ( description , should be upper case ( actual ) ) ; } }	Asserts that the actual value is a uppercase character.
public void assert has size ( description description , int [ ] actual , int expected size ) { arrays . assert has size ( description , actual , expected size ) ; }	Asserts that the number of elements in the given array is equal to the expected one.
public void assert contains ( description description , int [ ] actual , int [ ] values ) { arrays . assert contains ( description , actual , values ) ; }	Asserts that the given array contains the given values, in any order.
public < k > void assert contains key ( description description , map < ? , ? > actual , k key ) { assert not null ( description , actual ) ; if ( ! actual . contains key ( key ) ) { throw failures . failure ( description , should contain key ( actual , key ) ) ; } }	Asserts that the actual map contain the given key.
public < k > void assert does not contain key ( description description , map < ? , ? > actual , k key ) { assert not null ( description , actual ) ; if ( actual . contains key ( key ) ) { throw failures . failure ( description , should not contain key ( actual , key ) ) ; } }	Asserts that the actual map not contains the given key.
public < v > void assert contains value ( description description , map < ? , ? > actual , v value ) { assert not null ( description , actual ) ; if ( ! actual . contains value ( value ) ) { throw failures . failure ( description , should contain value ( actual , value ) ) ; } }	Asserts that the actual map contain the given value.
public < v > void assert does not contain value ( description description , map < ? , ? > actual , v value ) { assert not null ( description , actual ) ; if ( actual . contains value ( value ) ) { throw failures . failure ( description , should not contain value ( actual , value ) ) ; } }	Asserts that the actual map does not contain the given value.
public < k , v > void assert does not contain duplicate values ( description description , map < k , v > actual ) { assert not null ( description , actual ) ; collection < ? > duplicates = duplicates from ( actual . values ( ) ) ; if ( ! duplicates . is empty ( ) ) { throw failures . failure ( description , should not have duplicates ( actual , duplicates ) ) ; } }	Asserts that the actual map does not contain the duplicate values.
public void assert equal ( description description , big decimal actual , big decimal expected ) { check number is not null ( expected ) ; assert not null ( description , actual ) ; comparables . assert equal ( description , actual , expected ) ; }	Verifies that two BigDecimals are equal.
public void assert is zero ( description description , big decimal actual ) { comparables . assert equal ( description , actual , zero ) ; }	Verifies that the actual value is zero.
public void assert is not zero ( description description , big decimal actual ) { comparables . assert not equal ( description , actual , zero ) ; }	Verifies that the actual value is not zero.
public void assert is positive ( description description , big decimal actual ) { comparables . assert greater than ( description , actual , zero ) ; }	Verifies that the actual value is positive.
public void assert is negative ( description description , big decimal actual ) { comparables . assert less than ( description , actual , zero ) ; }	Verifies that the actual value is negative.
public float assert is equal to ( float expected , offset < float > offset ) { floats . assert equal ( description , actual , expected , offset ) ; return this ; }	Verifies that the actual value is equal to the given one, within a positive offset.
public byte array assert contains ( byte value , index index ) { arrays . assert contains ( description , actual , value , index ) ; return this ; }	Verifies that the given array contains the given value at the given index.
public void assert not equal ( description description , double actual , double expected , offset < double > offset ) { check offset is not null ( offset ) ; check number is not null ( expected ) ; assert not null ( description , actual ) ; if ( is equal to ( actual , expected , offset ) ) { throw failures . failure ( description , should not be equal ( actual , expected ) ) ; } }	Verifies that two doubles are not equal.
public void assert not greater than ( description description , double actual , double expected ) { assert not null ( description , actual ) ; if ( is greater than ( actual , expected ) ) { throw failures . failure ( description , should not be greater than ( actual , expected ) ) ; } }	Verifies that the actual value is not greater than the expected.
public void assert less than ( description description , double actual , double expected ) { assert not null ( description , actual ) ; if ( ! is less than ( actual , expected ) ) { throw failures . failure ( description , should be less than ( actual , expected ) ) ; } }	Verifies that the actual value is less than the expected.
public void assert not less than ( description description , double actual , double expected ) { assert not null ( description , actual ) ; if ( is less than ( actual , expected ) ) { throw failures . failure ( description , should not be less than ( actual , expected ) ) ; } }	Verifies that the actual value is not less than the expected.
public void assert contains only ( description description , byte [ ] actual , byte [ ] values ) { arrays . assert contains only ( description , actual , values ) ; }	Asserts that the given array contains only the given values and nothing else, in any order.
public void assert contains sequence ( description description , byte [ ] actual , byte [ ] sequence ) { arrays . assert contains sequence ( description , actual , sequence ) ; }	Verifies that the given array contains the given sequence of values, without any other values between them.
public void assert equal ( description description , object actual , object expected ) { if ( ! are equal ( actual , expected ) ) { throw should be equal ( actual , expected ) . new assertion error ( description ) ; } }	Asserts that two objects are equal.
public void assert not equal ( description description , object actual , object other ) { if ( are equal ( actual , other ) ) { throw failures . failure ( description , should not be equal ( actual , other ) ) ; } }	Asserts that two objects are not equal.
public void assert same ( description description , object actual , object expected ) { if ( actual != expected ) { string format = str ; throw failures . failure ( description , new basic error message factory ( format , expected , actual ) ) ; } }	Asserts that two objects refer to the same instance.
public void assert not same ( description description , object actual , object other ) { if ( actual == other ) { string format = str ; throw failures . failure ( description , new basic error message factory ( format , actual ) ) ; } }	Asserts that two objects do not refer to the same instance.
public void assert does not contain ( description description , char [ ] actual , char [ ] values ) { arrays . assert does not contain ( description , actual , values ) ; }	Asserts that the given array does not contain the given values.
public void assert is sorted ( description description , char [ ] actual ) { if ( actual == null ) { throw failures . failure ( str ) ; } if ( actual . length == num ) { return ; } for ( int i = num ; i < actual . length - num ; i ++ ) { if ( actual [ i ] > actual [ i + num ] ) { throw failures . failure ( description , should be sorted ( i , actual ) ) ; } } }	Verifies that the actual is sorted into ascending order according to the natural ordering of its elements.Empty arrays are considered sorted.
@ factory public static < t > matcher < t > named ( string name , matcher < t > matcher ) { return described as ( str , matcher , name , matcher ) ; }	Wraps an existing matcher, decorating its description with the name specified.
@ factory public static matcher < string > not empty string ( ) { return new custom type safe matcher < string > ( str ) { @ override protected boolean matches safely ( string s ) { return ! s . is empty ( ) ; } } ; }	A matcher matching non-null and non-empty stringsExample: assertThat("this is not an empty string", notEmptyString()) .
static string get middle name for prefixing as accessor mutator java beans spec compliance ( string field name ) { if ( field name . length ( ) > num && character . is upper case ( field name . char at ( num ) ) ) { return field name ; } return field name . substring ( num , num ) . to upper case ( ) + field name . substring ( num ) ; }	Get the middle part of the method name in compliance with the naming convention in the JavaBeans APIspecification.
private boolean exists ( j type , j field , string field name , boolean is setter ) { if ( field instanceof j ) { return bool ; } j [ ] args ; if ( is setter ) { args = new j [ ] { field . get type ( ) } ; } else { args = new j [ ] { } ; } j m = type . find method ( field name , args ) ; if ( null != m ) { if ( is ignored ( m ) ) { return bool ; } if ( is setter ) { return bool ; } j return type = m . get return type ( ) . is class or interface ( ) ; j field type = field . get type ( ) . is class or interface ( ) ; if ( return type == null || field type == null ) {	checks whether a getter or setter exists on the specified type or any ofits super classes excluding Object.
public static list < annotation resolver > get annotation resolvers ( generator context context , tree logger logger ) {	access all annotationresolvers that are registered.
public method expect ( int ... statuses ) { if ( statuses . length == num && statuses [ num ] < num ) { any status = bool ; } else { any status = bool ; expected statuses . clear ( ) ; for ( int status : statuses ) { expected statuses . add ( status ) ; } } return this ; }	sets the expected response status code.
private string reduce name ( string new class name , string suffix ) { if ( new class name . length ( ) < max file name length ) { return new class name ; }	Lets have class name less than 200 to allow new generators safelly to add more sufixes there if needed.
protected static boolean get boolean property ( tree logger logger , property oracle property oracle , string property name , boolean default value ) { try { selection property prop = property oracle . get selection property ( logger , property name ) ; string prop val = prop . get current value ( ) ; return boolean . parse boolean ( prop val ) ; } catch ( bad property value exception e ) {	Returns the boolean value of the property or the default value.
@ override public request callback filter ( method method , response response , request callback callback ) { int code = response . get status code ( ) ; final cache key ck = cache key ( method . builder ) ; final list < request callback > removed callbacks = cache . remove callbacks ( ck ) ; if ( removed callbacks != null ) { callback = new request callback ( ) { @ override public void on response received ( request request , response response ) { if ( gwt . is client ( ) && log configuration . logging is enabled ( ) ) { logger . get logger ( caching callback filter . class . get name ( ) ) . finer ( str + removed callbacks . size ( ) + str + ck ) ; }	the real filter method, called independent of the response codeTODO method.getResponse() is not equal to response.
@ suppress warnings ( str ) private string [ ] get annotations as string array ( class [ ] classes ) { if ( null == classes ) { return null ; } list < string > ret = new array list < string > ( ) ; for ( class c : classes ) { ret . add ( c . get name ( ) ) ; } return ret . to array ( new string [ ret . size ( ) ] ) ; }	convert an array of classes to an array of strings to be usable in js context.
public object send ( async callback < java script object > callback ) { return jsonp builder . request object ( resource . get uri ( ) , callback ) ; }	helper method to make RestServiceClassCreator easier to maintain.
private response process ( multivalued map < string , string > parameters , string client id , string client secret , string [ ] client certificate path ) {	Process the parameters of the token request.
private response handle password ( token response response ) {	Process the token request whose flow is "Resource Owner Password Credentials".
private response process ( string ticket , string [ ] claim names , string [ ] claim locales ) {	Process the end-user's decision.
private map < string , object > collect claims ( string subject , string [ ] claim names , string [ ] claim locales ) {	Collect claims of the end-user.
public response user info issue ( string access token , map < string , object > claims ) {	Issue a JSON or a JWT containing user information.
private static string compute login id ( authorization response info ) { if ( info . get subject ( ) != null ) { return info . get subject ( ) ; } return info . get login hint ( ) ; }	Compute the initial value for the login ID field in theauthorization page.
private string create service owner credentials ( authlete configuration configuration ) { if ( configuration . get service owner access token ( ) != null ) { return str + configuration . get service owner access token ( ) ; } else { string key = configuration . get service owner api key ( ) ; string secret = configuration . get service owner api secret ( ) ; return new basic credentials ( key , secret ) . format ( ) ; } }	Create an authorization header for the service owner.
private string create service credentials ( authlete configuration configuration ) { if ( configuration . get service access token ( ) != null ) { return str + configuration . get service access token ( ) ; } else { string key = configuration . get service api key ( ) ; string secret = configuration . get service api secret ( ) ; return new basic credentials ( key , secret ) . format ( ) ; } }	Create an authorization header for the service.
private javax . ws . rs . client . client get jax rs client ( ) {	Get an instance of JAX-RS client.
private javax . ws . rs . client . client create jax rs client ( ) { if ( get jax rs client builder ( ) != null ) {	Create an instance of JAX-RS client.
private void set connection timeout ( javax . ws . rs . client . client client ) {	Set a connection timeout.
private void set read timeout ( javax . ws . rs . client . client client ) {	Set a read timeout.
private < t > t execute api call ( authlete api call < t > api call ) throws authlete api exception { try {	Execute an Authlete API call.
private response process ( multivalued map < string , string > parameters ) {	Process the parameters of the introspection request.
private response process ( string access token ) {	Process the userinfo request with the access token.
private response process ( multivalued map < string , string > parameters ) {	Process the authorization request.
private void no interaction check authentication ( authorization response response ) {	Check whether an end-user has already logged in or not.
private response process ( multivalued map < string , string > parameters , string client id , string client secret ) {	Process the parameters of the revocation request.
protected string extract client certificate ( http servlet request request ) { string [ ] certs = extract client certificate chain ( request ) ; if ( certs != null && certs . length > num ) { return certs [ num ] ; } else { return null ; } }	Utility method for extracting a single client certificate from the defaultcertificate extractors.
public void update implied stores ( @ observes final artifact store pre update event event ) { if ( ! store manager . is started ( ) ) { return ; } if ( ! config . is enabled ( ) ) { logger . debug ( str ) ; return ; } try {	We cannot currently remove formerly implied repos because we can't distinguish between the above states.
public static x509 certificate generate x509 certificate ( key pair pair , string dn , int days , string algorithm ) throws general security exception , io { private key private key = pair . get private ( ) ; x509 cert info info = new x509 cert info ( ) ; date from = new date ( ) ; date to = new date ( from . get time ( ) + time unit . days . to millis ( days ) ) ; certificate validity interval = new certificate validity ( from , to ) ; big integer sn = new big integer ( num , new secure random ( ) ) ; x500 name owner = new x500 name ( dn ) ; info . set ( x509 cert info . validity , interval ) ; info . set ( x509 cert info . serial number , new certificate serial number ( sn ) ) ; info . set ( x509 cert info . subject , owner ) ; info . set ( x509 cert info . issuer , owner ) ; info . set ( x509 cert info . key , new certificate x509 key ( pair . get public ( ) ) ) ; info . set ( x509 cert info . version , new certificate version ( certificate version . v3 ) ) ; algorithm id algo = new algorithm id ( algorithm id . sha256 with rsa oid ) ; info . set ( x509 cert info . algorithm id , new certificate algorithm id ( algo ) ) ;	Create a self-signed X.509 cert.
public static string get name ( string node prefix , string name , string default name , string ... suffix ) { if ( is blank ( name ) || name . equals ( default ) ) { name = default name ; } return name ( name ( node prefix , name ) , suffix ) ; }	Get the metric fullname.
public transfer generate relationship file ( transfer transfer , transfer operation op ) { final logger logger = logger factory . get logger ( get class ( ) ) ; if ( ! config . is enabled ( ) ) { logger . debug ( str ) ; return null ; } logger . debug ( str , transfer ) ; if ( transfer == null ) { logger . debug ( str ) ; return null ; } string txfr path = transfer . get path ( ) ; if ( ! txfr path . ends with ( str ) ) { logger . debug ( str ) ; return null ; } artifact path info art path info = artifact path info . parse ( txfr path ) ; if ( art path info == null ) { logger . debug ( str , txfr path ) ; return null ; } concrete resource pom resource = transfer . get resource ( ) ; store key store key = store key . from string ( transfer . get location ( ) . get name ( ) ) ; artifact store store ; try { store = store manager . get artifact store ( store key ) ; } catch ( final indy data exception ex ) { logger . error ( str + store key , ex ) ; return null ; } logger . debug ( str , store key , pom resource . get path ( ) ) ; try { uri source = new uri ( pom resource . get location ( ) . get uri ( ) + rel suffix ) ; project version ref ref = art path info . get project id ( ) ;	Generate relationship file for pom transfer.
public int commit ( ) throws git subsystem exception { int committed = lock and ( me -> { final int size = changelog entries . size ( ) ; if ( ! changelog entries . is empty ( ) ) { try { commit command commit = git . commit ( ) ; string builder sb = new string builder ( ) . append ( commit changelog entries + str ) ; for ( changelog entry et : changelog entries ) { sb . append ( et . get username ( ) + str + et . get timestamp ( ) + str + et . get message ( ) ) ; sb . append ( str ) ; } string message = sb . to string ( ) ; logger . info ( message ) ; commit . set message ( message ) . set author ( system user , email ) . call ( ) ; changelog entries . clear ( ) ; } catch ( final j | api e ) { throw new git subsystem exception ( str + e . get message ( ) , e ) ; } } return size ; } ) ; return committed ; }	Commit the changelog entries.
private void add snapshot data object ( string key , snapshot snapshot , long clock , list < data object > data object list ) { data object list . add ( to data object ( key , str , snapshot . get min ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get max ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get mean ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get std dev ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get median ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get75th percentile ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get95th percentile ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get98th percentile ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get99th percentile ( ) , clock ) ) ; data object list . add ( to data object ( key , str , snapshot . get999th percentile ( ) , clock ) ) ; }	for histograms.
private string get remote repository name ( url url ) throws indy data exception { final string name = repo creator . format id ( url . get host ( ) , get port ( url ) , num , null , store type . remote ) ; logger . debug ( str , name ) ; abstract proxy repository creator abstract proxy repository creator = null ; if ( repo creator instanceof abstract proxy repository creator ) { abstract proxy repository creator = ( abstract proxy repository creator ) repo creator ; } if ( abstract proxy repository creator == null ) { return name ; } predicate < artifact store > filter = abstract proxy repository creator . get name filter ( name ) ; list < string > l = store manager . query ( ) . package type ( generic pkg key ) . store type ( remote repository . class ) . stream ( filter ) . map ( repository -> repository . get name ( ) ) . collect ( collectors . to list ( ) ) ; if ( l . is empty ( ) ) { return name ; } return abstract proxy repository creator . get next name ( l ) ; }	if repo with this name already exists, we need to use a different name.
public string get next name ( list < string > names ) { if ( names . is empty ( ) ) { return null ; } string name0 = names . get ( num ) ; if ( names . size ( ) == num ) { return name0 + str ; } collections . sort ( names ) ; string last = names . get ( names . size ( ) - num ) ; string index = last . substring ( last . last index of ( str ) + num ) ; return name0 + str + ( integer . parse int ( index ) + num ) ; }	Get the next distinct name based on the query result by filter of getNameFilter.
public void send ( string topic , string message , logback formatter formatter ) throws io { do kafka send ( topic , message , formatter ) ; }	Non-blocking send with a logback formatter to format the message.
public void send ( string topic , string message , long timeout millis ) throws io , interrupted exception , execution exception , timeout exception { send ( topic , message , null , timeout millis ) ; }	Blocking send. The message will be available to consumers immediately. Wait for at most the given timefor the operation to complete.
public void send ( string topic , string message , logback formatter formatter , long timeout millis ) throws io , interrupted exception , execution exception , timeout exception { future future = do kafka send ( topic , message , formatter ) ; if ( future != null ) { future . get ( timeout millis , time unit . milliseconds ) ; } }	Blocking send with a logback formatter to format the message.
public set < string > get cache names ( ) { set < string > ret = new hash set < > ( ) ; if ( koji config . is enabled ( ) && koji config . is query cache enabled ( ) ) { ret . add ( koji tags ) ; ret . add ( koji build info ) ; ret . add ( koji build info containing artifact ) ; ret . add ( koji archives for build ) ; ret . add ( koji archives matching ga ) ; } return ret ; }	This is to register ISPN caches produced by this provider so that the Metrics knows them.
public static void zip tracked content ( file out , set < tracked content > sealed ) throws io { logger . info ( str , out . get absolute path ( ) ) ; try ( zip output stream zip = new zip output stream ( new file output stream ( out ) ) ) { for ( tracked content f : sealed ) { string name = sealed . get value ( ) + str + f . get key ( ) . get id ( ) ; logger . trace ( str , name ) ; zip . put next entry ( new zip entry ( name ) ) ; copy ( to input stream ( f ) , zip ) ; } } }	Write sealed records to a zip file.
public static int read zip input stream and ( input stream input stream , consumer < tracked content > consumer ) throws io , class not found exception { int count = num ; try ( zip input stream stream = new zip input stream ( input stream ) ) { zip entry entry ; while ( ( entry = stream . get next entry ( ) ) != null ) { logger . trace ( str , entry . get name ( ) , entry . get size ( ) ) ; byte array output stream bos = new byte array output stream ( ) ; int len ; byte [ ] buffer = new byte [ num ] ; while ( ( len = stream . read ( buffer ) ) > num ) { bos . write ( buffer , num , len ) ; } bos . close ( ) ; object input stream ois = new object input stream ( new byte array input stream ( bos . to byte array ( ) ) ) ; tracked content record = ( tracked content ) ois . read object ( ) ; consumer . accept ( record ) ; count ++ ; } } return count ; }	Read records from input stream and execute consumer function.
private store key get target key ( final string target name ) { return target group key map . compute if absent ( target name , k -> new store key ( maven package type descriptor . maven pkg key , store type . group , target name ) ) ; }	Provides target group store key for a given group name.
private void clear obsolete files ( transfer item ) { transfer http meta = item . get sibling meta ( http metadata ext ) ; try { http meta . delete ( ) ; } catch ( io e ) { logger . warn ( str , http meta . get resource ( ) ) ; } }	Clear obsolete files after a meta is generated.
public string parse ( string repo name ) { string prefix = null ; if ( repo name . starts with ( koji binary ) ) { prefix = koji binary ; } else if ( repo name . starts with ( koji ) ) { prefix = koji ; } if ( prefix != null ) { return repo name . substring ( prefix . length ( ) ) ; } return null ; }	Retrieve what is behind koji- or koji-binary-.
@ api operation ( str ) @ api responses ( { @ api response ( code = num , message = str ) , @ api response ( code = num , message = str ) } ) @ path ( str ) @ head public response exists ( final @ path param ( str ) string package type , final @ api param ( allowable values = str , required = bool ) @ path param ( str ) string type , @ api param ( required = bool ) @ path param ( str ) final string name ) { response response ; final store type st = store type . get ( type ) ; logger . info ( str , package type , st , name ) ; if ( admin controller . exists ( new store key ( package type , st , name ) ) ) { logger . info ( str ) ; response = response . ok ( ) . build ( ) ; } else { logger . info ( str ) ; response = response . status ( status . not found ) . build ( ) ; } return response ; }	private HttpServletRequest request;.
public static void load from disk and ( data file manager manager , indy object mapper serializer , final change summary summary , consumer < artifact store > consumer ) { load from disk and ( manager , serializer , null , summary , consumer ) ; }	Load all store definitions from disk and apply consumer function.
public static void load from disk and ( data file manager manager , indy object mapper serializer , store key key , final change summary summary , consumer < artifact store > consumer ) { if ( key != null )	Load store definitions from disk and apply consumer function.
public hosted repository create store by arc ( final input stream file input , final string repo name , final string user , final string ignored prefix ) throws indy workflow exception { final hosted repository repo = create hosted by name ( repo name , user , str ) ; store zip content in hosted ( file input , ignored prefix , repo ) ; return repo ; }	private ExecutorService executors;.
public http client context create context ( final string site id ) throws indy http exception { try { return http factory . create context ( site config lookup . lookup ( site id ) ) ; } catch ( j c e ) { throw new indy http exception ( str , e , e . get message ( ) ) ; } }	Create http request context and apply site config.
public closeable http client create client ( final string site id ) throws indy http exception { try { return http factory . create client ( site config lookup . lookup ( site id ) ) ; } catch ( j c e ) { throw new indy http exception ( str , e , e . get message ( ) ) ; } }	Create http client and apply site config.
private koji repair result . repair result do repair ( string package type , remote repository repository , koji build info build info , string user , boolean is dry run ) throws koji repair exception { store key store key ; if ( repository != null ) { store key = repository . get key ( ) ; } else { string name = koji utils . get repository name ( build info ) ; store key = new store key ( package type , store type . remote , name ) ; try { repository = ( remote repository ) store manager . get artifact store ( store key ) ; } catch ( indy data exception e ) { throw new koji repair exception ( str , e , store key , e . get message ( ) ) ; } } koji repair result . repair result repair result = new koji repair result . repair result ( store key ) ; string url = repository . get url ( ) ; string new url ; try { new url = koji utils . format storage url ( config . get storage root url ( ) , build info ) ;	Repair one remote repository.
private void handle group members changed ( final artifact store store , final map < artifact store , artifact store > change map ) { final store key key = store . get key ( ) ; if ( store type . group == key . get type ( ) ) { final list < store key > new members = ( ( group ) store ) . get constituents ( ) ; logger . trace ( str , store . get key ( ) , new members ) ; final group group = ( group ) change map . get ( store ) ; final list < store key > old members = group . get constituents ( ) ; logger . trace ( str , group . get name ( ) , old members ) ; boolean members changed = bool ; if ( new members . size ( ) != old members . size ( ) ) { members changed = bool ; } else { for ( store key store key : new members ) { if ( ! old members . contains ( store key ) ) { members changed = bool ; } } } if ( members changed ) { logger . trace ( str , group . get key ( ) ) ; clear group meta cache ( group , group ) ; try { store manager . query ( ) . get groups affected by ( group . get key ( ) ) . for each ( g -> clear group meta cache ( g , group ) ) ; } catch ( indy data exception e ) { logger . error ( string . format ( str , group . get key ( ) ) , e ) ; } } else { logger . trace ( str ) ; } } }	If group members changed, should clear the cascading groups metadata cache.
public keycloak config set system properties ( ) { if ( ! is enabled ( ) ) { return this ; } final properties properties = system . get properties ( ) ; properties . set property ( keycloak realm , get realm ( ) ) ; properties . set property ( keycloak url , get url ( ) ) ; if ( get server resource ( ) != null ) { properties . set property ( keycloak server resource , get server resource ( ) ) ; } if ( get server credential secret ( ) != null ) { properties . set property ( keycloak server credential secret , get server credential secret ( ) ) ; } if ( get realm public key ( ) != null ) { properties . set property ( keycloak realm public key , get realm public key ( ) ) ; } system . set properties ( properties ) ; return this ; }	Set system properties for keycloak to use when filtering keycloak.json...
protected static array list < file range > get file ranges ( input stream stream ref ) throws parser configuration exception , sax , io { sax sax parser = utility . get sax ( ) ; file range handler handler = new file range handler ( ) ; sax parser . parse ( stream ref , handler ) ; return handler . file ranges ; }	Returns an ArrayList of File Ranges for the given stream.
public static array list < cloud queue message > read messages ( final input stream stream , final boolean should encode message ) throws sax , io , parser configuration exception { sax sax parser = utility . get sax ( ) ; queue message handler handler = new queue message handler ( should encode message ) ; sax parser . parse ( stream , handler ) ; return handler . messages ; }	Populates CloudQueueMessage objects from the XMLStreamReader; the reader must be at the Start element ofQueuesElement.
@ does service request public void delete ( table request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = table request options . populate and apply defaults ( options , this . table service client ) ; utility . assert not null or empty ( str , this . name ) ; final dynamic table entity table entry = new dynamic table entity ( ) ; table entry . get properties ( ) . put ( table constants . table name , new entity property ( this . name ) ) ; table operation delete op = new table operation ( table entry , table operation type . delete ) ; delete op . execute ( this . table service client , table constants . tables service tables name , options , op context ) ; }	Deletes the table from the storage service, using the specified request options and operation context.
@ does service request public void upload permissions ( final table permissions permissions , table request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = table request options . populate and apply defaults ( options , this . table service client ) ; execution engine . execute with retry ( this . table service client , this , this . upload permissions impl ( permissions , options ) , options . get retry policy factory ( ) , op context ) ; }	Uploads the table's permissions using the specified request options and operation context.
@ does service request public table permissions download permissions ( table request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = table request options . populate and apply defaults ( options , this . table service client ) ; return execution engine . execute with retry ( this . table service client , this , this . download permissions impl ( options ) , options . get retry policy factory ( ) , op context ) ; }	Downloads the permissions settings for the table using the specified request options and operation context.
protected static void apply base defaults internal ( final request options modified options ) { utility . assert not null ( str , modified options ) ; if ( modified options . get retry policy factory ( ) == null ) { modified options . set retry policy factory ( new retry exponential retry ( ) ) ; } if ( modified options . get location mode ( ) == null ) { modified options . set location mode ( location mode . primary only ) ; } }	Populates the default timeout, retry policy, and location mode from client if they are null.
public static storage extended error information get extended error information ( final input stream stream ) throws sax , io , parser configuration exception { sax sax parser = utility . get sax ( ) ; storage error handler handler = new storage error handler ( ) ; sax parser . parse ( stream , handler ) ; return handler . error info ; }	Gets the Extended Error information from the response stream.
public static access condition generate if sequence number less than or equal condition ( long sequence number ) { access condition ret condition = new access condition ( ) ; ret condition . if sequence number less than or equal = sequence number ; return ret condition ; }	Returns an access condition such that an operation will be performed only if resource's current sequencenumber is less than or equal to the specified value.
public static access condition generate if sequence number less than condition ( long sequence number ) { access condition ret condition = new access condition ( ) ; ret condition . if sequence number less than = sequence number ; return ret condition ; }	Returns an access condition such that an operation will be performed only if resource's current sequencenumber is less than the specified value.
public static access condition generate if sequence number equal condition ( long sequence number ) { access condition ret condition = new access condition ( ) ; ret condition . if sequence number equal = sequence number ; return ret condition ; }	Returns an access condition such that an operation will be performed only if resource's current sequencenumber is equal to the specified value.
public void apply condition to request ( final url request ) { apply lease condition to request ( request ) ; if ( this . if modified since date != null ) { request . set request property ( constants . header constants . if modified since , utility . get gmt ( this . if modified since date ) ) ; } if ( this . if unmodified since date != null ) { request . set request property ( constants . header constants . if unmodified since , utility . get gmt ( this . if unmodified since date ) ) ; } if ( ! utility . is null or empty ( this . if match e ) ) { request . set request property ( constants . header constants . if match , this . if match e ) ; } if ( ! utility . is null or empty ( this . if none match e ) ) { request . set request property ( constants . header constants . if none match , this . if none match e ) ; } }	RESERVED FOR INTERNAL USE.
public void apply source condition to request ( final url request ) { if ( ! utility . is null or empty ( this . lease id ) ) {	RESERVED FOR INTERNAL USE.
public void apply append condition to request ( final url request ) { if ( this . if max size less than or equal != null ) { request . set request property ( constants . header constants . if max size less than or equal , this . if max size less than or equal . to string ( ) ) ; } if ( this . if append position equal != null ) { request . set request property ( constants . header constants . if append position equal header , this . if append position equal . to string ( ) ) ; } }	RESERVED FOR INTERNAL USE.
public void apply lease condition to request ( final url request ) { if ( ! utility . is null or empty ( this . lease id ) ) { request . set request property ( constants . header constants . lease id header , this . lease id ) ; } }	RESERVED FOR INTERNAL USE.
public void apply sequence condition to request ( final url request ) { if ( this . if sequence number less than or equal != null ) { request . set request property ( constants . header constants . if sequence number less than or equal , this . if sequence number less than or equal . to string ( ) ) ; } if ( this . if sequence number less than != null ) { request . set request property ( constants . header constants . if sequence number less than , this . if sequence number less than . to string ( ) ) ; } if ( this . if sequence number equal != null ) { request . set request property ( constants . header constants . if sequence number equal , this . if sequence number equal . to string ( ) ) ; } }	RESERVED FOR INTERNAL USE.
public boolean verify conditional ( final string etag , final date last modified ) { if ( this . if modified since date != null ) {	RESERVED FOR INTERNAL USE.
public static string combine filters ( string filter a , string operator , string filter b ) { return string . format ( str , filter a , operator , filter b ) ; }	Creates a filter condition using the specified logical operator on two filter conditions.
protected final void set storage uri ( final storage uri storage uri ) { this . use path style uris = utility . determine path style from uri ( storage uri . get primary uri ( ) ) ; this . storage uri = storage uri ; }	Sets the list of URIs for all locations.
public static < t extends shared access policy > void write shared access identifiers to stream ( final hash map < string , t > shared access policies , final string writer out writer ) throws illegal argument exception , illegal state exception , io { utility . assert not null ( str , shared access policies ) ; utility . assert not null ( str , out writer ) ; final xml serializer xmlw = utility . get xml serializer ( out writer ) ; if ( shared access policies . key set ( ) . size ( ) > constants . max shared access policy identifiers ) { final string error message = string . format ( sr . too many shared access policy identifiers , shared access policies . key set ( ) . size ( ) , constants . max shared access policy identifiers ) ; throw new illegal argument exception ( error message ) ; }	RESERVED FOR INTERNAL USE.
public static byte [ ] generate message request body ( final string message ) throws illegal argument exception , illegal state exception , io { final string writer out writer = new string writer ( ) ; final xml serializer xmlw = utility . get xml serializer ( out writer ) ;	Generates the message request body from a string containing the message.The message must be encodable as UTF-8.
private static void add canonicalized headers ( final url conn , final string builder canonicalized string ) {	Add x-ms- prefixed headers in a fixed order.
protected static void append canonicalized element ( final string builder builder , final string element ) { builder . append ( str ) ; builder . append ( element ) ; }	Append a string to a string builder with a newline constant.
protected static string canonicalize http request ( final java . net . url address , final string account name , final string method , final string content type , final long content length , final string date , final url conn ) throws storage exception {	Constructs a canonicalized string from the request's headers that will be used to construct the signature stringfor signing a Blob or Queue service request under the Shared Key Full authentication scheme.
protected static string canonicalize table http request ( final java . net . url address , final string account name , final string method , final string content type , final long content length , final string date , final url conn ) throws storage exception {	Constructs a canonicalized string that will be used to construct the signature stringfor signing a Table service request under the Shared Key authentication scheme.
public static synchronized string compute hmac256 ( final storage credentials creds , final string value ) throws invalid key exception { if ( creds . get class ( ) . equals ( storage credentials account and key . class ) ) { byte [ ] utf8 bytes = null ; try { utf8 bytes = value . get bytes ( constants . ut charset ) ; } catch ( final unsupported encoding exception e ) { throw new illegal argument exception ( e ) ; } return base64 . encode ( ( ( storage credentials account and key ) creds ) . get hmac256 ( ) . do final ( utf8 bytes ) ) ; } else { return null ; } }	Computes a signature for the specified string using the HMAC-SHA256 algorithm.
public static void sign table request ( final storage credentials creds , final java . net . url request , final long content length , operation context op context ) throws invalid key exception , storage exception { if ( creds . get class ( ) . equals ( storage credentials account and key . class ) ) { op context = op context == null ? new operation context ( ) : op context ; request . set request property ( constants . header constants . date , utility . get gmt ( ) ) ; final canonicalizer canonicalizer = canonicalizer factory . get table canonicalizer ( request ) ; final string string to sign = canonicalizer . canonicalize ( request , creds . get account name ( ) , content length ) ; final string computed base64 signature = storage credentials helper . compute hmac256 ( creds , string to sign ) ; logger . debug ( op context , log constants . signing , string to sign ) ; request . set request property ( constants . header constants . authorization , string . format ( str , str , creds . get account name ( ) , computed base64 signature ) ) ; } }	Signs a request using the specified operation context under the Shared Key authentication scheme.
private static cloud queue message get first or null ( final iterable < cloud queue message > messages ) { for ( final cloud queue message m : messages ) { return m ; } return null ; }	Gets the first message from a list of queue messages, if any.
@ does service request public void clear ( queue request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = queue request options . populate and apply defaults ( options , this . queue service client ) ; execution engine . execute with retry ( this . queue service client , this , this . clear impl ( options ) , options . get retry policy factory ( ) , op context ) ; }	Clears all messages from the queue, using the specified request options and operation context.
@ does service request public void create ( queue request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = queue request options . populate and apply defaults ( options , this . queue service client ) ; execution engine . execute with retry ( this . queue service client , this , this . create impl ( options ) , options . get retry policy factory ( ) , op context ) ; }	Creates the queue, using the specified request options and operation context.
@ does service request public void delete ( queue request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = queue request options . populate and apply defaults ( options , this . queue service client ) ; execution engine . execute with retry ( this . queue service client , this , this . delete impl ( options ) , options . get retry policy factory ( ) , op context ) ; }	Deletes the queue, using the specified request options and operation context.
@ does service request public void download attributes ( queue request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = queue request options . populate and apply defaults ( options , this . queue service client ) ; execution engine . execute with retry ( this . queue service client , this , this . download attributes impl ( options ) , options . get retry policy factory ( ) , op context ) ; }	Downloads the queue's metadata and approximate message count value, using the specified request options andoperation context.
@ does service request public iterable < cloud queue message > peek messages ( final int number of messages ) throws storage exception { return this . peek messages ( number of messages , null , null ) ; }	Peeks a specified number of messages from the queue.
@ does service request public iterable < cloud queue message > retrieve messages ( final int number of messages ) throws storage exception { return this . retrieve messages ( number of messages , queue constants . default visibility message timeout in seconds , null , null ) ; }	Retrieves the specified number of messages from the front of the queue using the default request options.
public void update message ( final cloud queue message message , final int visibility timeout in seconds ) throws storage exception { this . update message ( message , visibility timeout in seconds , enum set . of ( message update fields . visibility ) , null , null ) ; }	Updates the specified message in the queue with a new visibility timeout value in seconds.
@ does service request public void upload permissions ( final queue permissions permissions , queue request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = queue request options . populate and apply defaults ( options , this . queue service client ) ; execution engine . execute with retry ( this . queue service client , this , this . upload permissions impl ( permissions , options ) , options . get retry policy factory ( ) , op context ) ; }	Uploads the queue's permissions using the specified request options and operation context.
@ does service request public queue permissions download permissions ( queue request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } op context . initialize ( ) ; options = queue request options . populate and apply defaults ( options , this . queue service client ) ; return execution engine . execute with retry ( this . queue service client , this , this . download permissions impl ( options ) , options . get retry policy factory ( ) , op context ) ; }	Downloads the permissions settings for the queue using the specified request options and operation context.
private final storage uri get transformed address ( final operation context op context ) throws uri , storage exception { return this . queue service client . get credentials ( ) . transform uri ( this . get storage uri ( ) , op context ) ; }	Returns the transformed URI for the resource if the given credentials require transformation.
public cloud table get hour metrics table ( storage service service , storage location location ) throws uri , storage exception { utility . assert not null ( str , service ) ; if ( location == null ) { location = storage location . primary ; } switch ( service ) { case blob : if ( location == storage location . primary ) { return this . table client . get table reference ( constants . analytics constants . metrics hour primary transactions blob ) ; } else { return this . table client . get table reference ( constants . analytics constants . metrics hour secondary transactions blob ) ; } case file : if ( location == storage location . primary ) { return this . table client . get table reference ( constants . analytics constants . metrics hour primary transactions file ) ; } else { return this . table client . get table reference ( constants . analytics constants . metrics hour secondary transactions file ) ; } case queue : if ( location == storage location . primary ) { return this . table client . get table reference ( constants . analytics constants . metrics hour primary transactions queue ) ; } else { return this . table client . get table reference ( constants . analytics constants . metrics hour secondary transactions queue ) ; } case table : if ( location == storage location . primary ) { return this . table client . get table reference ( constants . analytics constants . metrics hour primary transactions table ) ; } else { return this . table client . get table reference ( constants . analytics constants . metrics hour secondary transactions table ) ; } default : throw new illegal argument exception ( sr . invalid storage service ) ; } }	Gets the hour metrics table for a specific storage service.
public cloud table get minute metrics table ( storage service service , storage location location ) throws uri , storage exception { utility . assert not null ( str , service ) ; if ( location == null ) { location = storage location . primary ; } switch ( service ) { case blob : if ( location == storage location . primary ) { return this . table client . get table reference ( constants . analytics constants . metrics minute primary transactions blob ) ; } else { return this . table client . get table reference ( constants . analytics constants . metrics minute secondary transactions blob ) ; } case file : if ( location == storage location . primary ) { return this . table client . get table reference ( constants . analytics constants . metrics minute primary transactions file ) ; } else { return this . table client . get table reference ( constants . analytics constants . metrics minute secondary transactions file ) ; } case queue : if ( location == storage location . primary ) { return this . table client . get table reference ( constants . analytics constants . metrics minute primary transactions queue ) ; } else { return this . table client . get table reference ( constants . analytics constants . metrics minute secondary transactions queue ) ; } case table : if ( location == storage location . primary ) { return this . table client . get table reference ( constants . analytics constants . metrics minute primary transactions table ) ; } else { return this . table client . get table reference ( constants . analytics constants . metrics minute secondary transactions table ) ; } default : throw new illegal argument exception ( sr . invalid storage service ) ; } }	Gets the minute metrics table for a specific storage service.
public final byte [ ] get message content as byte ( ) throws storage exception { if ( utility . is null or empty ( this . message content ) ) { return new byte [ num ] ; } if ( this . message type == queue message type . raw string ) { try { return this . message content . get bytes ( constants . ut charset ) ; } catch ( final unsupported encoding exception e ) { throw utility . generate new unexpected storage exception ( e ) ; } } else { return base64 . decode ( this . message content ) ; } }	Gets the content of the message as a byte array.
public final string get message content as string ( ) throws storage exception { if ( this . message type == queue message type . raw string ) { return this . message content ; } else { if ( utility . is null or empty ( this . message content ) ) { return null ; } try { return new string ( base64 . decode ( this . message content ) , constants . ut charset ) ; } catch ( final unsupported encoding exception e ) { throw utility . generate new unexpected storage exception ( e ) ; } } }	Gets the content of the message as a string.
public static list response < list file item > get file and directory list ( final input stream stream , final cloud file directory directory ) throws parser configuration exception , sax , io { sax sax parser = utility . get sax ( ) ; file list handler handler = new file list handler ( directory ) ; sax parser . parse ( stream , handler ) ; return handler . response ; }	Parse and return the response.
private static void apply continuation to query builder ( final uri query builder builder , final result continuation continuation token ) throws storage exception { if ( continuation token != null ) { if ( continuation token . get next partition key ( ) != null ) { builder . add ( table constants . table service next partition key , continuation token . get next partition key ( ) ) ; } if ( continuation token . get next row key ( ) != null ) { builder . add ( table constants . table service next row key , continuation token . get next row key ( ) ) ; } if ( continuation token . get next table name ( ) != null ) { builder . add ( table constants . table service next table name , continuation token . get next table name ( ) ) ; } } }	Reserved for internal use.
public static url set acl ( final uri root uri , final table request options options , final operation context op context ) throws io , uri , storage exception { uri query builder query builder = new uri query builder ( ) ; query builder . add ( constants . query constants . component , str ) ; final url ret connection = base request . create url ( root uri , options , query builder , op context ) ; ret connection . set request method ( str ) ; ret connection . set do output ( bool ) ; return ret connection ; }	Sets the ACL for the table.
public static byte [ ] serialize to byte array ( final service properties properties ) throws illegal argument exception , illegal state exception , io { final string writer out writer = new string writer ( ) ; final xml serializer xmlw = utility . get xml serializer ( out writer ) ;	Writes the contents of the ServiceProperties to the stream in xml format.
private static void write retention policy ( final xml serializer xmlw , final integer val ) throws illegal argument exception , illegal state exception , io { xmlw . start tag ( constants . empty string , constants . analytics constants . retention policy element ) ;	Writes the retention policy to the XMLStreamWriter.
private static void write cors properties ( final xml serializer xmlw , final cors properties cors ) throws illegal argument exception , illegal state exception , io { utility . assert not null ( str , cors . get cors rules ( ) ) ;	Writes the given CORS properties to the XMLStreamWriter.
private static void write metrics properties ( final xml serializer xmlw , final metrics properties metrics , final string metrics name ) throws illegal argument exception , illegal state exception , io { utility . assert not null ( str , metrics . get metrics level ( ) ) ;	Writes the given metrics properties to the XMLStreamWriter.
private static void write logging properties ( final xml serializer xmlw , final logging properties logging ) throws illegal argument exception , illegal state exception , io { utility . assert not null ( str , logging . get log operation types ( ) ) ;	Writes the given logging properties to the XMLStreamWriter.
public static void add share snapshot ( final uri query builder builder , final string snapshot version ) throws storage exception { if ( snapshot version != null ) { builder . add ( constants . query constants . share snapshot , snapshot version ) ; } }	Adds the share snapshot if present.Only for listing files and directories which requires a different query param.
private static uri query builder get share uri query builder ( ) throws storage exception { final uri query builder uri builder = new uri query builder ( ) ; try { uri builder . add ( constants . query constants . resourcetype , str ) ; } catch ( final illegal argument exception e ) { throw utility . generate new unexpected storage exception ( e ) ; } return uri builder ; }	Gets the share Uri query builder.A UriQueryBuilder for the share.
public static url create directory ( final uri uri , final file request options file options , final operation context op context ) throws io , uri , storage exception { final uri query builder directory builder = get directory uri query builder ( ) ; return base request . create ( uri , file options , directory builder , op context ) ; }	Constructs a web request to create a new directory.
@ override public synchronized void close ( ) throws io { this . current buffer = null ; this . stream faulted = bool ; this . last error = new io ( sr . stream closed ) ; }	Closes this input stream and releases any system resources associated with the stream.
@ does service request private synchronized void dispatch read ( final int read length ) throws io { try { final byte [ ] byte buffer = new byte [ read length ] ; this . parent file ref . download range internal ( this . current absolute read position , ( long ) read length , byte buffer , num , null , this . options , this . op context ) ;	Dispatches a read operation of N bytes.
@ override public synchronized void reset ( ) throws io { if ( this . marked position + this . mark expiry < this . current absolute read position ) { throw new io ( sr . mark expired ) ; } this . validate file md5 = bool ; this . md5 digest = null ; this . reposition ( this . marked position ) ; }	Repositions this stream to the position at the time the mark method was last called on this input stream.
public void run blob getting started sample ( view view ) { new blob getting started task ( this , ( text view ) find view by id ( r . id . text view ) ) . execute ( ) ; }	Runs the blob getting started sample.
public void run queue getting started sample ( view view ) { new queue getting started task ( this , ( text view ) find view by id ( r . id . text view ) ) . execute ( ) ; }	Runs the queue getting started sample.
public void run table getting started sample ( view view ) { new table getting started task ( this , ( text view ) find view by id ( r . id . text view ) ) . execute ( ) ; }	Runs the table getting started sample.
public void run table payload format sample ( view view ) { new table payload format task ( this , ( text view ) find view by id ( r . id . text view ) ) . execute ( ) ; }	Runs the table payload format sample.
public void output text ( final text view view , final string value ) { run on ui thread ( new runnable ( ) { @ override public void run ( ) { view . append ( value + str ) ; system . out . println ( view ) ; } } ) ; }	Prints the specified text value to the view and to LogCat.
public void print exception ( throwable t ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; t . print stack trace ( print writer ) ; output text ( ( text view ) find view by id ( r . id . text view ) , string . format ( str , string writer . to string ( ) ) ) ; }	Prints out the exception information .
public void print sample start info ( string sample name ) { text view view = ( text view ) find view by id ( r . id . text view ) ; clear text ( view ) ; output text ( view , string . format ( str , sample name ) ) ; }	Prints out the sample start information .
public void print sample complete info ( string sample name ) { output text ( ( text view ) find view by id ( r . id . text view ) , string . format ( str , sample name ) ) ; }	Prints out the sample complete information .
@ override protected string canonicalize ( final url conn , final string account name , final long content length ) throws storage exception { if ( content length < - num ) { throw new invalid parameter exception ( sr . invalid content length ) ; } return canonicalize table http request ( conn . get url ( ) , account name , conn . get request method ( ) , utility . get standard header value ( conn , constants . header constants . content type ) , content length , null , conn ) ; }	Constructs a canonicalized string for signing a request.
public synchronized request result get last result ( ) { if ( this . request results == null || this . request results . size ( ) == num ) { return null ; } else { return this . request results . get ( this . request results . size ( ) - num ) ; } }	Gets the last request result encountered for the operation.
private boolean is correct log type ( list blob item current ) { hash map < string , string > metadata = ( ( cloud blob ) current ) . get metadata ( ) ; string log type = metadata . get ( str ) ; if ( log type == null ) { return bool ; } if ( this . operations . contains ( logging operations . read ) && log type . contains ( str ) ) { return bool ; } if ( this . operations . contains ( logging operations . write ) && log type . contains ( str ) ) { return bool ; } if ( this . operations . contains ( logging operations . delete ) && log type . contains ( str ) ) { return bool ; } return bool ; }	Validates that the log given is of the correct log type.
private void update iterator ( ) throws storage exception , uri { if ( this . current prefix time != null && this . current prefix time . is empty ( ) ) {	Makes the next listBlob call if necessary and updates the currentIterator.
@ does service request public final string start copy ( final cloud blob source blob ) throws storage exception , uri { return this . start copy ( source blob , null , null , null , null ) ; }	Requests the service to start copying a blob's contents, properties, and metadata to a new file.
@ does service request public final string start copy ( final cloud file source file ) throws storage exception , uri { return this . start copy ( source file , null , null , null , null ) ; }	Requests the service to start copying an Azure File's contents, properties, and metadata to a new Azure File.
@ does service request public final string start copy ( final uri source ) throws storage exception , uri { return this . start copy ( source , null , null , null , null ) ; }	Requests the service to start copying a URI's contents, properties, and metadata to a new Azure File.
@ does service request public void create ( final long size ) throws storage exception , uri { this . create ( size , null , null , null ) ; }	Creates a file. If the file already exists, this will replace it.
private void delete empty file on exception ( output stream output stream , string path ) { try { output stream . close ( ) ; file file to delete = new file ( path ) ; file to delete . delete ( ) ; } catch ( exception e ) {	Helper to delete an empty file in the case of an exception.
@ does service request public file output stream open write existing ( ) throws storage exception , uri { return this . open output stream internal ( null , null , null , null ) ; }	Opens an output stream object to write data to the file.
public void upload from file ( final string path ) throws storage exception , io , uri { upload from file ( path , null , null , null ) ; }	Uploads a local file.
public void upload text ( final string content ) throws storage exception , io , uri { this . upload text ( content , null , null , null , null ) ; }	Uploads a file from a string using the platform's default encoding.
@ does service request public void upload range ( final input stream source stream , final long offset , final long length ) throws storage exception , io , uri { this . upload range ( source stream , offset , length , null , null , null ) ; }	Uploads a range to a file.
@ does service request public void upload ( final input stream source stream , final long length ) throws storage exception , io , uri { this . upload ( source stream , length , null , null , null ) ; }	Uploads the source stream data to the file.
protected static string get parent name from uri ( final storage uri resource address , final cloud file share share ) throws uri { utility . assert not null ( str , resource address ) ; utility . assert not null ( str , share ) ; string delimiter = str ; string share name = share . get name ( ) + delimiter ; string relative uri = utility . safe relativize ( share . get storage uri ( ) . get primary uri ( ) , resource address . get primary uri ( ) ) ; if ( relative uri . ends with ( delimiter ) ) { relative uri = relative uri . substring ( num , relative uri . length ( ) - delimiter . length ( ) ) ; } string parent name ; if ( utility . is null or empty ( relative uri ) ) {	Retrieves the parent name for a file URI.
@ override public final cloud file share get share ( ) throws storage exception , uri { if ( this . share == null ) { final storage uri share uri = path utility . get share uri ( this . get storage uri ( ) , this . file service client . is use path style uris ( ) ) ; this . share = new cloud file share ( share uri , this . file service client . get credentials ( ) ) ; } return this . share ; }	Returns the file's share.
public static uri append path to single uri ( final uri uri , final string relative uri , final string separator ) throws uri { if ( uri == null ) { return null ; } if ( relative uri == null || relative uri . is empty ( ) ) { return uri ; } if ( uri . get path ( ) . length ( ) == num && relative uri . starts with ( separator ) ) { return new uri ( uri . get scheme ( ) , uri . get authority ( ) , relative uri , uri . get raw query ( ) , uri . get raw fragment ( ) ) ; } final string builder path string = new string builder ( uri . get path ( ) ) ; if ( uri . get path ( ) . ends with ( separator ) ) { path string . append ( relative uri ) ; } else { path string . append ( separator ) ; path string . append ( relative uri ) ; } return new uri ( uri . get scheme ( ) , uri . get authority ( ) , path string . to string ( ) , uri . get query ( ) , uri . get fragment ( ) ) ; }	Appends a path to a URI correctly using the given separator.
public static string get blob name from uri ( final uri in uri , final boolean use path style uris ) throws uri { return utility . safe relativize ( new uri ( get container uri ( new storage uri ( in uri ) , use path style uris ) . get primary uri ( ) . to string ( ) . concat ( str ) ) , in uri ) ; }	Gets the blob name from the URI.
public static string get canonical path from credentials ( final storage credentials credentials , final string absolute path ) { final string account = credentials . get account name ( ) ; if ( account == null ) { final string error message = sr . cannot create sas for given credentials ; throw new illegal argument exception ( error message ) ; } final string builder builder = new string builder ( str ) ; builder . append ( account ) ; builder . append ( absolute path ) ; return builder . to string ( ) ; }	Gets the canonical path for an object from the credentials.
public static string get container name from uri ( final uri resource address , final boolean use path style uris ) { return get resource name from uri ( resource address , use path style uris , string . format ( str , resource address ) ) ; }	Get the container name from address from the URI.
public static string get file name from uri ( final uri resource address , final boolean use path style uris ) {	Gets the file name from the URI.
public static string get share name from uri ( final uri resource address , final boolean use path style uris ) { return get resource name from uri ( resource address , use path style uris , string . format ( str , resource address ) ) ; }	Get the share name from address from the URI.
public static string get table name from uri ( final uri resource address , final boolean use path style uris ) { return get resource name from uri ( resource address , use path style uris , string . format ( str , resource address ) ) ; }	Get the table name from address from the URI.
private static string get resource name from uri ( final uri resource address , final boolean use path style uris , final string error ) { utility . assert not null ( str , resource address ) ; final string [ ] path segments = resource address . get raw path ( ) . split ( str ) ; final int expected parts length = use path style uris ? num : num ; if ( path segments . length < expected parts length ) { throw new illegal argument exception ( error ) ; } final string resource name = use path style uris ? path segments [ num ] : path segments [ num ] ; return utility . trim end ( resource name , str ) ; }	Get the container, queue or table name from address from the URI.
public static storage uri get container uri ( final storage uri blob address , final boolean use path style uris ) throws uri { final string container name = get container name from uri ( blob address . get primary uri ( ) , use path style uris ) ; final storage uri container uri = append path to uri ( get service client base address ( blob address , use path style uris ) , container name ) ; return container uri ; }	Gets the container URI from a blob address.
public static storage uri get share uri ( final storage uri file address , final boolean use path style uris ) throws uri { final string share name = get share name from uri ( file address . get primary uri ( ) , use path style uris ) ; final storage uri share uri = append path to uri ( get service client base address ( file address , use path style uris ) , share name ) ; return share uri ; }	Gets the share URI from a file address.
public static hash map < string , string [ ] > parse query string ( string parse string ) throws storage exception { final hash map < string , string [ ] > ret vals = new hash map < string , string [ ] > ( ) ; if ( utility . is null or empty ( parse string ) ) { return ret vals ; }	Parses a query string into a one to many hashmap.
public static string generate shared access signature hash for blob and file ( final shared access policy policy , shared access headers headers , final string access policy identifier , final string resource name , final ip ip range , final shared access protocols protocols , final service client client ) throws invalid key exception , storage exception { string string to sign = generate shared access signature string to sign ( policy , resource name , ip range , protocols , access policy identifier ) ; string cache control = null ; string content disposition = null ; string content encoding = null ; string content language = null ; string content type = null ; if ( headers != null ) { cache control = headers . get cache control ( ) ; content disposition = headers . get content disposition ( ) ; content encoding = headers . get content encoding ( ) ; content language = headers . get content language ( ) ; content type = headers . get content type ( ) ; } string to sign = string . format ( str , string to sign , cache control == null ? constants . empty string : cache control , content disposition == null ? constants . empty string : content disposition , content encoding == null ? constants . empty string : content encoding , content language == null ? constants . empty string : content language , content type == null ? constants . empty string : content type ) ; return generate shared access signature hash helper ( string to sign , client . get credentials ( ) ) ; }	Get the signature hash embedded inside the Shared Access Signature for the blob or file service.
public static string generate shared access signature hash for queue ( final shared access queue policy policy , final string access policy identifier , final string resource name , final ip ip range , final shared access protocols protocols , final service client client ) throws invalid key exception , storage exception { final string string to sign = generate shared access signature string to sign ( policy , resource name , ip range , protocols , access policy identifier ) ; return generate shared access signature hash helper ( string to sign , client . get credentials ( ) ) ; }	Get the signature hash embedded inside the Shared Access Signature for queue service.
@ does service request public void create ( file request options options , operation context op context ) throws storage exception , uri { if ( op context == null ) { op context = new operation context ( ) ; } this . get share ( ) . assert no snapshot ( ) ; op context . initialize ( ) ; options = file request options . populate and apply defaults ( options , this . file service client ) ; execution engine . execute with retry ( this . file service client , this , create directory impl ( options ) , options . get retry policy factory ( ) , op context ) ; }	Creates the directory using the specified options and operation context.
@ does service request public result segment < list file item > list files and directories segmented ( ) throws storage exception { return this . list files and directories segmented ( null , null , null , null , null ) ; }	Returns a result segment of an enumerable collection of files and directories for this File service client.
@ override public cloud file share get share ( ) throws storage exception , uri { if ( this . share == null ) { this . share = this . file service client . get share reference ( path utility . get share name from uri ( this . get uri ( ) , this . file service client . is use path style uris ( ) ) ) ; } return this . share ; }	Returns the share for this directory.
public static url set acl ( final uri uri , final queue request options queue options , final operation context op context ) throws io , uri , storage exception { final uri query builder builder = new uri query builder ( ) ; builder . add ( constants . query constants . component , constants . query constants . acl ) ; final url request = base request . create url ( uri , queue options , builder , op context ) ; request . set do output ( bool ) ; request . set request method ( constants . http put ) ; return request ; }	Sets the ACL for the queue.
public static url get acl ( final uri uri , final queue request options queue options , final operation context op context ) throws io , uri , storage exception { final uri query builder builder = new uri query builder ( ) ; builder . add ( constants . query constants . component , constants . query constants . acl ) ; final url request = base request . create url ( uri , queue options , builder , op context ) ; request . set request method ( constants . http get ) ; return request ; }	Constructs a web request to return the ACL for this queue.
private static list < string > split to list ( string str , string delimiter ) { array list < string > list = new array list < string > ( ) ; string tokenizer st = new string tokenizer ( str , delimiter ) ; while ( st . has more elements ( ) ) { list . add ( st . next token ( ) ) ; } return list ; }	Split a delimiter separated string into an ArrayList.
private static enum set < cors http methods > split to enum set ( string str , string delimiter ) { enum set < cors http methods > set = enum set . none of ( cors http methods . class ) ; string tokenizer st = new string tokenizer ( str , delimiter ) ; while ( st . has more elements ( ) ) { set . add ( cors http methods . value of ( st . next token ( ) ) ) ; } return set ; }	Split a delimiter separated string into a EnumSet of CorsHttpMethods.
public synchronized void update key ( final byte [ ] key ) { if ( key == null || key . length == num ) { throw new illegal argument exception ( sr . invalid key ) ; } this . key = key ; this . hmac sha256 = null ; }	Sets the name of the access key to be used when signing the request.
public synchronized mac get hmac256 ( ) throws invalid key exception { if ( this . hmac sha256 == null ) {	Gets the HmacSha256 associated with the account key.
private static void validate ip ( string ip address ) { try { @ suppress warnings ( str ) inet4 address address = ( inet4 address ) inet4 address . get by name ( ip address ) ; } catch ( exception ex ) { throw new illegal argument exception ( string . format ( sr . invalid ip address , ip address ) , ex ) ; } }	Validate that the IP address is IPv4.
public static byte [ ] decode ( final string data ) { if ( data == null ) { throw new illegal argument exception ( sr . string not valid ) ; } int byte array length = num * data . length ( ) / num ; if ( data . ends with ( str ) ) { byte array length -= num ; } else if ( data . ends with ( str ) ) { byte array length -= num ; } final byte [ ] ret array = new byte [ byte array length ] ; int byte dex = num ; int char dex = num ; for ( ; char dex < data . length ( ) ; char dex += num ) {	Decodes a given Base64 string into its corresponding byte array.
public static string encode ( final byte [ ] data ) { final string builder builder = new string builder ( ) ; final int data remainder = data . length % num ; int j = num ; int n = num ; for ( ; j < data . length ; j += num ) { if ( j < data . length - data remainder ) { n = ( ( data [ j ] & num ) << num ) + ( ( data [ j + num ] & num ) << num ) + ( data [ j + num ] & num ) ; } else { if ( data remainder == num ) { n = ( data [ j ] & num ) << num ; } else if ( data remainder == num ) { n = ( ( data [ j ] & num ) << num ) + ( ( data [ j + num ] & num ) << num ) ; } }	Encodes a byte array as a Base64 string.
public static boolean validate is base64 string ( final string data ) { if ( data == null || data . length ( ) % num != num ) { return bool ; } for ( int m = num ; m < data . length ( ) ; m ++ ) { final byte char byte = ( byte ) data . char at ( m ) ;	Determines whether the given string contains only Base64 characters.
public static void validate container name ( string container name ) { if ( ! ( str . equals ( container name ) || str . equals ( container name ) ) ) { name validator . validate share container queue helper ( container name , sr . container ) ; } }	Checks if a container name is valid.
public static void validate blob name ( string blob name ) { if ( utility . is null or empty or whitespace ( blob name ) ) { throw new illegal argument exception ( string . format ( utility . locale us , sr . resource name empty , sr . blob ) ) ; } if ( blob name . length ( ) < name validator . blob file directory min length || blob name . length ( ) > name validator . blob max length ) { throw new illegal argument exception ( string . format ( utility . locale us , sr . invalid resource name length , sr . blob , name validator . blob file directory min length , name validator . blob max length ) ) ; } int slash count = num ; for ( int i = num ; i < blob name . length ( ) ; i ++ ) { if ( blob name . char at ( i ) == str ) { slash count ++ ; } } if ( slash count >= num ) { throw new illegal argument exception ( sr . too many path segments ) ; } }	Checks if a blob name is valid.
public static void validate file name ( string file name ) { name validator . validate file directory helper ( file name , sr . file ) ; if ( file name . ends with ( str ) ) { throw new illegal argument exception ( string . format ( utility . locale us , sr . invalid resource name , sr . file ) ) ; } for ( string s : name validator . reserved file names ) { if ( s . equals ignore case ( file name ) ) { throw new illegal argument exception ( string . format ( utility . locale us , sr . invalid resource reserved name , sr . file ) ) ; } } }	Checks if a file name is valid.
public static void validate table name ( string table name ) { if ( utility . is null or empty or whitespace ( table name ) ) { throw new illegal argument exception ( string . format ( utility . locale us , sr . resource name empty , sr . table ) ) ; } if ( table name . length ( ) < name validator . container share queue table min length || table name . length ( ) > name validator . container share queue table max length ) { throw new illegal argument exception ( string . format ( utility . locale us , sr . invalid resource name length , sr . table , name validator . container share queue table min length , name validator . container share queue table max length ) ) ; } if ( ! ( name validator . table regex . matcher ( table name ) . matches ( ) || name validator . metrics table regex . matcher ( table name ) . matches ( ) || table name . equals ignore case ( str ) ) ) { throw new illegal argument exception ( string . format ( utility . locale us , sr . invalid resource name , sr . table ) ) ; } }	Checks if a table name is valid.
@ does service request public iterable < cloud file share > list shares ( final string prefix ) { return this . list shares with prefix ( prefix , enum set . none of ( share listing details . class ) , null , null ) ; }	Returns an enumerable collection of shares whose names begin with the specified prefix for this File serviceclient.
@ does service request public result segment < cloud file share > list shares segmented ( ) throws storage exception { return this . list shares segmented ( null , enum set . none of ( share listing details . class ) , null , null , null , null ) ; }	Returns a result segment of an enumerable collection of shares for this File service client.
@ does service request public result segment < cloud file share > list shares segmented ( final string prefix ) throws storage exception { return this . list shares with prefix segmented ( prefix , enum set . none of ( share listing details . class ) , null , null , null , null ) ; }	Returns a result segment of an enumerable collection of shares whose names begin with the specifiedprefix for this File service client.
public static void set reflected entity cache disabled ( boolean disable reflected entity cache ) { if ( table service entity . reflected entity cache != null && disable reflected entity cache ) { table service entity . reflected entity cache . clear ( ) ; } table service entity . disable reflected entity cache = disable reflected entity cache ; }	Sets a boolean representing whether or not the reflected entity cache is disabled.
public static string get date ( final url request ) { final string ret string = request . get header field ( str ) ; return ret string == null ? request . get header field ( constants . header constants . date ) : ret string ; }	Gets the Date.
public static hash map < string , string > get metadata ( final url request ) { return get values by header prefix ( request , constants . header constants . prefix for storage metadata ) ; }	Gets the metadata from the request The response from server.
public static boolean is server request encrypted ( url request ) { return constants . true . equals ( request . get header field ( constants . header constants . server request encrypted ) ) ; }	Gets if the request was encrypted by the server.
public static storage extended error information get extended error information ( final reader reader , final table payload format format ) throws json parse exception , io { json factory json factory = new json factory ( ) ; json parser parser = json factory . create parser ( reader ) ; try { final storage extended error information error info = new storage extended error information ( ) ; if ( ! parser . has current token ( ) ) { parser . next token ( ) ; } json utilities . assert is start object json token ( parser ) ; parser . next token ( ) ; json utilities . assert is field name json token ( parser ) ; json utilities . assert is expected field name ( parser , str ) ;	Gets the Extended Error information.
public static storage extended error information parse error details ( storage request < cloud table client , ? , ? > request ) { try { if ( request == null || request . get connection ( ) . get error stream ( ) == null ) { return null ; } return get extended error information ( new input stream reader ( request . get connection ( ) . get error stream ( ) ) , table payload format . json ) ; } catch ( exception e ) { return null ; } }	Parse the table extended error information from the response body.
private static hash map < string , string [ ] > parse json error exception ( json parser parser ) throws json parse exception , io { hash map < string , string [ ] > additional details = new hash map < string , string [ ] > ( ) ; parser . next token ( ) ; json utilities . assert is start object json token ( parser ) ; parser . next token ( ) ; json utilities . assert is field name json token ( parser ) ; while ( parser . get current token ( ) != json token . end object ) { if ( parser . get current name ( ) . equals ( table constants . error constants . error message ) ) { parser . next token ( ) ; additional details . put ( table constants . error constants . error message , new string [ ] { parser . get value as string ( ) } ) ; } else if ( parser . get current name ( ) . equals ( table constants . error constants . error exception type ) ) { parser . next token ( ) ; additional details . put ( table constants . error constants . error exception type , new string [ ] { parser . get value as string ( ) } ) ; } else if ( parser . get current name ( ) . equals ( table constants . error constants . error exception stack trace ) ) { parser . next token ( ) ; additional details . put ( constants . error exception stack trace , new string [ ] { parser . get value as string ( ) } ) ; } parser . next token ( ) ; } return additional details ; }	Parses the error exception details from the Json-formatted response.
public static < t extends shared access policy > hash map < string , t > get access identifiers ( final input stream stream , final class < t > cls ) throws parser configuration exception , sax , io { sax sax parser = utility . get sax ( ) ; shared access policy handler < t > handler = new shared access policy handler < t > ( cls ) ; sax parser . parse ( stream , handler ) ; return handler . policies ; }	RESERVED FOR INTERNAL USE.
public static copy state get copy state ( final url request ) throws uri , parse exception { string copy status string = request . get header field ( constants . header constants . copy status ) ; if ( ! utility . is null or empty ( copy status string ) ) { final copy state copy state = new copy state ( ) ; copy state . set status ( copy status . parse ( copy status string ) ) ; copy state . set copy id ( request . get header field ( constants . header constants . copy id ) ) ; copy state . set status description ( request . get header field ( constants . header constants . copy status description ) ) ; final string copy progress string = request . get header field ( constants . header constants . copy progress ) ; if ( ! utility . is null or empty ( copy progress string ) ) { string [ ] progress sequence = copy progress string . split ( str ) ; copy state . set bytes copied ( long . parse long ( progress sequence [ num ] ) ) ; copy state . set total bytes ( long . parse long ( progress sequence [ num ] ) ) ; } final string copy source string = request . get header field ( constants . header constants . copy source ) ; if ( ! utility . is null or empty ( copy source string ) ) { copy state . set source ( new uri ( copy source string ) ) ; } final string copy completion time string = request . get header field ( constants . header constants . copy completion time ) ; if ( ! utility . is null or empty ( copy completion time string ) ) { copy state . set completion time ( utility . parse rf gmt ( copy completion time string ) ) ; } return copy state ; } else { return null ; } }	Gets the copyState.
public static file share attributes get file share attributes ( final url request , final boolean use path style uris ) throws storage exception { final file share attributes share attributes = new file share attributes ( ) ; final file share properties share properties = share attributes . get properties ( ) ; share properties . set etag ( base response . get etag ( request ) ) ; share properties . set share quota ( parse share quota ( request ) ) ; share properties . set last modified ( new date ( request . get last modified ( ) ) ) ; share attributes . set metadata ( get metadata ( request ) ) ; return share attributes ; }	Gets the FileShareAttributes from the given request.
public static file directory attributes get file directory attributes ( final url request , final boolean use path style uris ) throws storage exception { final file directory attributes directory attributes = new file directory attributes ( ) ; uri temp uri ; try { temp uri = path utility . strip single uri ( request . get url ( ) . to uri ( ) ) ; } catch ( final uri e ) { final storage exception wrapped unexpected exception = utility . generate new unexpected storage exception ( e ) ; throw wrapped unexpected exception ; } directory attributes . set name ( path utility . get directory name from uri ( temp uri , use path style uris ) ) ; final file directory properties directory properties = directory attributes . get properties ( ) ; directory properties . set etag ( base response . get etag ( request ) ) ; directory properties . set last modified ( new date ( request . get last modified ( ) ) ) ; directory attributes . set metadata ( get metadata ( request ) ) ; directory properties . set server encrypted ( constants . true . equals ( request . get header field ( constants . header constants . server encrypted ) ) ) ; return directory attributes ; }	Gets the FileDirectoryAttributes from the given request.
public static file attributes get file attributes ( final url request , final storage uri resource uri ) throws uri , parse exception { final file attributes file attributes = new file attributes ( ) ; final file properties properties = file attributes . get properties ( ) ; properties . set cache control ( request . get header field ( constants . header constants . cache control ) ) ; properties . set content disposition ( request . get header field ( constants . header constants . content disposition ) ) ; properties . set content encoding ( request . get header field ( constants . header constants . content encoding ) ) ; properties . set content language ( request . get header field ( constants . header constants . content language ) ) ;	Gets the CloudFileAttributes from the given request.
static string get http verb for operation ( final table operation type operation type ) { if ( operation type == table operation type . insert ) { return str ; } else if ( operation type == table operation type . delete ) { return str ; } else if ( operation type == table operation type . merge || operation type == table operation type . insert or merge ) { return str ; } else if ( operation type == table operation type . replace || operation type == table operation type . insert or replace ) { return str ; } else if ( operation type == table operation type . retrieve ) { return str ; } else { throw new illegal argument exception ( sr . unknown table operation ) ; } }	Reserved for internal use.
public void fire event ( final event type event ) { for ( final storage event < event type > listener : this . listeners ) { listener . event occurred ( event ) ; } }	Fires the event to all subscribed event listeners.
private static void fire sending request event ( operation context op context , url request , request result result ) { if ( op context . get sending request event handler ( ) . has listeners ( ) || operation context . get global sending request event handler ( ) . has listeners ( ) ) { sending request event event = new sending request event ( op context , request , result ) ; op context . get sending request event handler ( ) . fire event ( event ) ; operation context . get global sending request event handler ( ) . fire event ( event ) ; } }	Fires events representing that a request will be sent.
private static void fire response received event ( operation context op context , url request , request result result ) { if ( op context . get response received event handler ( ) . has listeners ( ) || operation context . get global response received event handler ( ) . has listeners ( ) ) { response received event event = new response received event ( op context , request , result ) ; op context . get response received event handler ( ) . fire event ( event ) ; operation context . get global response received event handler ( ) . fire event ( event ) ; } }	Fires events representing that a response has been received.
private static void fire error receiving response event ( operation context op context , url request , request result result ) { if ( op context . get error receiving response event handler ( ) . has listeners ( ) || operation context . get global error receiving response event handler ( ) . has listeners ( ) ) { error receiving response event event = new error receiving response event ( op context , request , result ) ; op context . get error receiving response event handler ( ) . fire event ( event ) ; operation context . get global error receiving response event handler ( ) . fire event ( event ) ; } }	Fires events representing that an error occurred when receiving the response.
private static void fire request completed event ( operation context op context , url request , request result result ) { if ( op context . get request completed event handler ( ) . has listeners ( ) || operation context . get global request completed event handler ( ) . has listeners ( ) ) { request completed event event = new request completed event ( op context , request , result ) ; op context . get request completed event handler ( ) . fire event ( event ) ; operation context . get global request completed event handler ( ) . fire event ( event ) ; } }	Fires events representing that a response received from the service is fully processed.
private static void fire retrying event ( operation context op context , url request , request result result , retry context retry context ) { if ( op context . get retrying event handler ( ) . has listeners ( ) || operation context . get global retrying event handler ( ) . has listeners ( ) ) { retrying event event = new retrying event ( op context , request , result , retry context ) ; op context . get retrying event handler ( ) . fire event ( event ) ; operation context . get global retrying event handler ( ) . fire event ( event ) ; } }	Fires events representing that a request will be retried.
public static void assert continuation type ( final result continuation continuation token , final result continuation type continuation type ) { if ( continuation token != null ) { if ( ! ( continuation token . get continuation type ( ) == result continuation type . none || continuation token . get continuation type ( ) == continuation type ) ) { final string error message = string . format ( utility . locale us , sr . unexpected continuation type , continuation token . get continuation type ( ) , continuation type ) ; throw new illegal argument exception ( error message ) ; } } }	Asserts a continuation token is of the specified type.
public static void assert in bounds ( final string param , final long value , final long min , final long max ) { if ( value < min || value > max ) { throw new illegal argument exception ( string . format ( sr . parameter not in range , param , min , max ) ) ; } }	Asserts that the specified integer is in the valid range.
public static void assert greater than or equal ( final string param , final long value , final long min ) { if ( value < min ) { throw new illegal argument exception ( string . format ( sr . parameter should be greater or equal , param , min ) ) ; } }	Asserts that the specified value is greater than or equal to the min value.
public static boolean validate max execution timeout ( long operation expiry time in ms , long additional interval ) { if ( operation expiry time in ms != null ) { long current time = new date ( ) . get time ( ) ; return operation expiry time in ms < current time + additional interval ; } return bool ; }	Returns a value representing whether the maximum execution time would be surpassed.
public static int get remaining timeout ( long operation expiry time in ms , integer timeout interval in ms ) throws storage exception { if ( operation expiry time in ms != null ) { long remaining time = operation expiry time in ms - new date ( ) . get time ( ) ; if ( remaining time > integer . max value ) { return integer . max value ; } else if ( remaining time > num ) { return ( int ) remaining time ; } else { timeout exception timeout exception = new timeout exception ( sr . maximum execution timeout exception ) ; storage exception translated exception = new storage exception ( storage error code strings . operation timed out , sr . maximum execution timeout exception , constants . header constants . http unused 306 , null , timeout exception ) ; throw translated exception ; } } else if ( timeout interval in ms != null ) { return timeout interval in ms + constants . default read timeout ; } else { return constants . default read timeout ; } }	Returns a value representing the remaining time before the operation expires.
public static boolean determine path style from uri ( final uri base uri ) { string path = base uri . get path ( ) ; if ( path != null && path . starts with ( str ) ) { path = path . substring ( num ) ; }	Returns a value that indicates whether a specified URI is a path-style URI.
private static boolean is host dns name ( uri uri ) { string host = uri . get host ( ) ; for ( int i = num ; i < host . length ( ) ; i ++ ) { char host char = host . char at ( i ) ; if ( ! character . is digit ( host char ) && ! ( host char == str ) ) { return bool ; } } return bool ; }	Returns a boolean indicating whether the host of the specified URI is DNS.
public static string format e ( final string etag ) { if ( etag . starts with ( str ) && etag . ends with ( str ) ) { return etag ; } else { return string . format ( str , etag ) ; } }	Reads character data for the Etag element from an XML stream reader.
public static storage exception generate new unexpected storage exception ( final exception cause ) { final storage exception exception ref = new storage exception ( storage error code . none . to string ( ) , str , num ,	Returns an unexpected storage exception.
public static string get standard header value ( final url conn , final string header name ) { final string header value = conn . get request property ( header name ) ;	Returns the standard header value from the specified connection request, or an empty string if no header valuehas been specified for the request.
public static date parse date from string ( final string value , final string pattern , final time zone time zone ) throws parse exception { final date format rfc1123 format = new simple date format ( pattern , utility . locale us ) ; rfc1123 format . set time zone ( time zone ) ; return rfc1123 format . parse ( value ) ; }	Returns a GMT date in the specified format.
public static date parse rf gmt ( final string value ) throws parse exception { final date format format = new simple date format ( rf gmt pattern , utility . locale us ) ; format . set time zone ( gmt zone ) ; return format . parse ( value ) ; }	Returns a GMT date for the specified string in the RFC1123 pattern.
public static void log http error ( storage exception ex , operation context op context ) { if ( logger . should log ( op context , log . debug ) ) { try { string builder bld = new string builder ( ) ; bld . append ( str ) ; bld . append ( str ) ; bld . append ( ex . get http status code ( ) ) ; bld . append ( str ) ; bld . append ( ex . get message ( ) ) ; bld . append ( str ) ; bld . append ( ex . get error code ( ) ) ; storage extended error information extended error = ex . get extended error information ( ) ; if ( extended error != null ) { bld . append ( str ) ; bld . append ( extended error . get error message ( ) ) ; hash map < string , string [ ] > details = extended error . get additional details ( ) ; if ( details != null ) { bld . append ( str ) ; for ( entry < string , string [ ] > detail : details . entry set ( ) ) { bld . append ( detail . get key ( ) ) ; bld . append ( str ) ; for ( string value : detail . get value ( ) ) { bld . append ( value ) ; } bld . append ( str ) ; } bld . set char at ( bld . length ( ) - num , str ) ; } bld . append ( str ) ; } logger . debug ( op context , bld . to string ( ) ) ; } catch ( exception e ) {	Serializes the parsed StorageException.
public static void log http response ( url conn , operation context op context ) throws io { if ( logger . should log ( op context , log . verbose ) ) { try { string builder bld = new string builder ( ) ;	Logs the HttpURLConnection response.
protected static string trim end ( final string value , final char trim char ) { int stop dex = value . length ( ) - num ; while ( stop dex > num && value . char at ( stop dex ) == trim char ) { stop dex -- ; } return stop dex == value . length ( ) - num ? value : value . substring ( stop dex ) ; }	Trims the specified character from the end of a string.
public static string trim start ( final string value ) { int space dex = num ; while ( space dex < value . length ( ) && value . char at ( space dex ) == str ) { space dex ++ ; } return value . substring ( space dex ) ; }	Trims whitespace from the beginning of a string.
public static date parse date ( string date string ) { string pattern = max precision pattern ; switch ( date string . length ( ) ) { case num :	Given a String representing a date in a form of the ISO8601 pattern, generates a Date representing itwith up to millisecond precision.
public static request location mode get listing location mode ( result continuation token ) { if ( ( token != null ) && token . get target location ( ) != null ) { switch ( token . get target location ( ) ) { case primary : return request location mode . primary only ; case secondary : return request location mode . secondary only ; default : throw new illegal argument exception ( string . format ( sr . argument out of range error , str , token . get target location ( ) ) ) ; } } return request location mode . primary or secondary ; }	Determines which location can the listing command target by looking at thecontinuation token.
protected static final queue request options populate and apply defaults ( queue request options options , final cloud queue client client ) { queue request options modified options = new queue request options ( options ) ; request options . populate request options ( modified options , client . get default request options ( ) , bool ) ; queue request options . apply defaults ( modified options ) ; return modified options ; }	Populates the default timeout and retry policy from client if they are not set.
public string read string ( ) throws io { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return temp ; } }	Read a String from the stream.
public string read quoted string ( ) throws io { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return temp ; } }	Read a quoted String from the stream.
public boolean read boolean ( ) throws io { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return boolean . parse boolean ( temp ) ; } }	Read a Boolean from the stream.
public date read date ( date format format ) throws io , parse exception { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return format . parse ( temp ) ; } }	Read a Date from the stream.
public double read double ( ) throws io { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return double . parse double ( temp ) ; } }	Read a Double from the stream.
public uuid read uuid ( ) throws io { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return uuid . from string ( temp ) ; } }	Read a UUID from the stream.
public integer read integer ( ) throws io { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return integer . parse int ( temp ) ; } }	Read an Integer from the stream.
public long read long ( ) throws io { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return long . parse long ( temp ) ; } }	Read a Long from the stream.
public uri read uri ( ) throws uri , io { string temp = this . read field ( bool ) ; if ( utility . is null or empty ( temp ) ) { return null ; } else { return new uri ( html . from html ( temp ) . to string ( ) ) ; } }	Read a URI from the stream.
private void read delimiter ( char delimiter ) throws io { if ( this . is end of file ( ) ) { throw new eof ( sr . log stream end error ) ; } else { int read = this . read ( ) ; if ( read == - num || ( char ) read != delimiter ) { throw new illegal state exception ( sr . log stream delimiter error ) ; } } }	Read a delimiter from the stream.
private boolean try peek delimiter ( char delimiter ) throws io { if ( this . is end of file ( ) ) { throw new eof ( sr . log stream end error ) ; } else { if ( ( char ) this . peek ( ) != delimiter ) { return bool ; } else { return bool ; } } }	Checks to see if the next character is the delimiter expected.
private string read field ( boolean is quoted string ) throws io { if ( ! this . is first field in record ) { this . read delimiter ( log record stream reader . field delimiter ) ; } else { this . is first field in record = bool ; }	Read a field from the stream.
@ override public retry policy create instance ( final operation context op context ) { return new retry exponential retry ( this . resolved min backoff , this . delta backoff interval in ms , this . resolved max backoff , this . maximum attempts ) ; }	Generates a new retry policy for the current request attempt.
@ override @ does service request public boolean has next ( ) { while ( this . current segment == null || ( ! this . current segment iterator . has next ( ) && this . current segment != null && this . current segment . get has more results ( ) ) ) { try { this . current segment = execution engine . execute with retry ( this . client , this . parent object , this . segment generator , this . policy factory , this . op context ) ; } catch ( final storage exception e ) { final no such element exception ex = new no such element exception ( sr . enumeration error ) ; ex . init cause ( e ) ; throw ex ; } this . current segment iterator = this . current segment . get results ( ) . iterator ( ) ; if ( ! this . current segment iterator . has next ( ) && ! this . current segment . get has more results ( ) ) { return bool ; } } return this . current segment iterator . has next ( ) ; }	Indicates if the iterator has another element.
protected void set clazz type ( final class < ? extends table entity > clazz type ) { utility . assert not null ( str , clazz type ) ; utility . check nullary ctor ( clazz type ) ; this . clazz type = clazz type ; }	Reserved for internal use.
protected void set resolver ( final entity resolver < ? > resolver ) { utility . assert not null ( sr . query requires valid classtype or resolver , resolver ) ; this . resolver = resolver ; }	Reserved for internal use.
private static void write mime ( final output stream writer out writer , final string boundary id ) throws io { out writer . write ( string . format ( str , boundary id ) ) ; }	Reserved for internal use.
private static void write mime ( final output stream writer out writer , final string boundary id ) throws io { out writer . write ( string . format ( str , boundary id ) ) ; }	Reserved for internal use.
private static void write mime ( final output stream writer out writer , final string boundary name ) throws io { out writer . write ( string . format ( str , boundary name ) ) ; }	Reserved for internal use.
public void add ( final string name , final string value ) throws storage exception { if ( utility . is null or empty ( name ) ) { throw new illegal argument exception ( sr . query parameter null or empty ) ; } this . insert key value ( name , value ) ; }	Adds a value to the URI with escaping.
public uri add to uri ( final uri uri ) throws uri , storage exception { final string orig raw query = uri . get raw query ( ) ; final string raw fragment = uri . get raw fragment ( ) ; final string uri string = uri . resolve ( uri ) . to ascii ( ) ; final hash map < string , string [ ] > orig query map = path utility . parse query string ( orig raw query ) ;	Add query parameter to an existing Uri.
public static void add optional header ( final url request , final string name , final string value ) { if ( value != null && ! value . equals ( constants . empty string ) ) { request . set request property ( name , value ) ; } }	Adds the optional header.
public static url create url ( final uri uri , final request options options , uri query builder builder , final operation context op context ) throws io , uri , storage exception { if ( builder == null ) { builder = new uri query builder ( ) ; } if ( options . get timeout interval in ms ( ) != null && options . get timeout interval in ms ( ) != num ) { builder . add ( timeout , string . value of ( options . get timeout interval in ms ( ) / num ) ) ; } final url resource url = builder . add to uri ( uri ) . to url ( ) ;	Creates the web request.
public static url delete ( final uri uri , final request options options , uri query builder builder , final operation context op context ) throws io , uri , storage exception { if ( builder == null ) { builder = new uri query builder ( ) ; } final url ret connection = create url ( uri , options , builder , op context ) ; ret connection . set request method ( constants . http delete ) ; return ret connection ; }	Deletes the specified resource.
public static url get service properties ( final uri uri , final request options options , uri query builder builder , final operation context op context ) throws io , uri , storage exception { if ( builder == null ) { builder = new uri query builder ( ) ; } builder . add ( constants . query constants . component , constants . query constants . properties ) ; builder . add ( constants . query constants . resourcetype , service ) ; final url ret connection = create url ( uri , options , builder , op context ) ; ret connection . set request method ( constants . http get ) ; return ret connection ; }	Creates a HttpURLConnection used to retrieve the Analytics service properties from the storage service.
public static string get user agent ( ) { if ( user agent == null ) { string user agent comment = string . format ( utility . locale us , str , android . os . build . version . release , android . os . build . brand , android . os . build . model ) ; user agent = string . format ( str , constants . header constants . user agent prefix , constants . header constants . user agent version , user agent comment ) ; } return user agent ; }	Gets the user agent to send over the wire to identify the client.
public static url set metadata ( final uri uri , final request options options , uri query builder builder , final operation context op context ) throws io , uri , storage exception { if ( builder == null ) { builder = new uri query builder ( ) ; } builder . add ( constants . query constants . component , metadata ) ; final url ret connection = create url ( uri , options , builder , op context ) ; ret connection . set fixed length streaming mode ( num ) ; ret connection . set do output ( bool ) ; ret connection . set request method ( constants . http put ) ; return ret connection ; }	Sets the metadata. Sign with 0 length.
public static url set service properties ( final uri uri , final request options options , uri query builder builder , final operation context op context ) throws io , uri , storage exception { if ( builder == null ) { builder = new uri query builder ( ) ; } builder . add ( constants . query constants . component , constants . query constants . properties ) ; builder . add ( constants . query constants . resourcetype , service ) ; final url ret connection = create url ( uri , options , builder , op context ) ; ret connection . set do output ( bool ) ; ret connection . set request method ( constants . http put ) ; return ret connection ; }	Creates a HttpURLConnection used to set the Analytics service properties on the storage service.
@ override @ does service request public void close ( ) throws io { try {	Closes this output stream and releases any system resources associated with this stream.
@ does service request private void commit ( ) throws storage exception , uri { if ( this . options . get store file content m ( ) ) { this . parent file ref . get properties ( ) . set content m ( base64 . encode ( this . md5 digest . digest ( ) ) ) ; } this . parent file ref . upload properties ( this . access condition , this . options , this . op context ) ; }	Commits the file.
@ does service request private synchronized void dispatch write ( final int write length ) throws io { if ( write length == num ) { return ; } callable < void > worker = null ; if ( this . outstanding requests > this . options . get concurrent request count ( ) * num ) { this . wait for task to complete ( ) ; } final byte array input stream buffer ref = new byte array input stream ( this . out buffer . to byte array ( ) ) ; final cloud file file ref = this . parent file ref ; long temp offset = this . current offset ; long temp length = write length ; final long op write length = temp length ; final long op offset = temp offset ; this . current offset += write length ; worker = new callable < void > ( ) { @ override public void call ( ) { try { file ref . upload range ( buffer ref , op offset , op write length , file output stream . this . access condition , file output stream . this . options , file output stream . this . op context ) ; } catch ( final io e ) { synchronized ( file output stream . this . last error lock ) { file output stream . this . stream faulted = bool ; file output stream . this . last error = e ; } } catch ( final storage exception e ) { synchronized ( file output stream . this . last error lock ) { file output stream . this . stream faulted = bool ; file output stream . this . last error = utility . init io ( e ) ; } } catch ( uri e ) { synchronized ( file output stream . this . last error lock ) { file output stream . this . stream faulted = bool ; file output stream . this . last error = utility . init io ( e ) ; } } return null ; } } ;	Dispatches a write operation for a given length.
@ override @ does service request public synchronized void flush ( ) throws io { this . check stream state ( ) ;	Flushes this output stream and forces any buffered output bytes to be written out.
private void wait for task to complete ( ) throws io { try { final future < void > future = this . completion service . take ( ) ; future . get ( ) ; } catch ( final interrupted exception e ) { throw utility . init io ( e ) ; } catch ( final execution exception e ) { throw utility . init io ( e ) ; } this . outstanding requests -- ; }	Waits for one task to complete.
@ override @ does service request public void write ( final byte [ ] data , final int offset , final int length ) throws io { if ( offset < num || length < num || length > data . length - offset ) { throw new index out of bounds exception ( ) ; } this . write internal ( data , offset , length ) ; }	Writes length bytes from the specified byte array starting at offset to this output stream.
@ does service request public void write ( final input stream source stream , final long write length ) throws io , storage exception { utility . write to output stream ( source stream , this , write length , bool , bool , this . op context , this . options , bool ) ; }	Writes all data from the InputStream to the File.
@ does service request private synchronized void write internal ( final byte [ ] data , int offset , int length ) throws io { while ( length > num ) { this . check stream state ( ) ; final int available buffer bytes = this . internal write threshold - this . current buffered bytes ; final int next write = math . min ( available buffer bytes , length ) ;	Writes the data to the buffer and triggers writes to the service as needed.
private static string get dns ( string service , string base ) { if ( base == null ) { base = default dns ; } return string . format ( dns name format , service , base ) ; }	This generates a domain name for the given service.
private static cloud storage account try configure dev store ( final map < string , string > settings ) throws uri { if ( matches specification ( settings , all required ( use development storage name ) , optional ( development storage proxy uri name ) ) ) { if ( ! boolean . parse boolean ( settings . get ( use development storage name ) ) ) { throw new illegal argument exception ( sr . invalid connection string dev store not true ) ; } uri dev store proxy uri = null ; if ( settings . contains key ( development storage proxy uri name ) ) { dev store proxy uri = new uri ( settings . get ( development storage proxy uri name ) ) ; } return get development storage account ( dev store proxy uri ) ; } else { return null ; } }	Evaluates connection settings and returns a CloudStorageAccount representing Development Storage.
private static cloud storage account try configure service account ( final map < string , string > settings ) throws uri , invalid key exception { connection string filter endpoints optional = optional ( blob endpoint name , blob secondary endpoint name , queue endpoint name , queue secondary endpoint name , table endpoint name , table secondary endpoint name , file endpoint name , file secondary endpoint name ) ; connection string filter primary endpoint required = at least one ( blob endpoint name , queue endpoint name , table endpoint name , file endpoint name ) ; connection string filter secondary endpoints optional = optional ( blob secondary endpoint name , queue secondary endpoint name , table secondary endpoint name , file secondary endpoint name ) ; connection string filter automatic endpoints match spec = matches exactly ( matches all ( matches one ( matches all ( all required ( account key name ) ) ,	Evaluates connection settings and configures a CloudStorageAccount accordingly.
public cloud analytics client create cloud analytics client ( ) { if ( this . get blob storage uri ( ) == null ) { throw new illegal argument exception ( sr . blob endpoint not configured ) ; } if ( this . get table storage uri ( ) == null ) { throw new illegal argument exception ( sr . table endpoint not configured ) ; } if ( this . credentials == null ) { throw new illegal argument exception ( sr . missing credentials ) ; } return new cloud analytics client ( this . get blob storage uri ( ) , this . get table storage uri ( ) , this . get credentials ( ) ) ; }	Creates a new Analytics service client.
public cloud blob client create cloud blob client ( ) { if ( this . get blob storage uri ( ) == null ) { throw new illegal argument exception ( sr . blob endpoint not configured ) ; } if ( this . credentials == null ) { throw new illegal argument exception ( sr . missing credentials ) ; } return new cloud blob client ( this . get blob storage uri ( ) , this . get credentials ( ) ) ; }	Creates a new Blob service client.
public cloud file client create cloud file client ( ) { if ( this . get file storage uri ( ) == null ) { throw new illegal argument exception ( sr . file endpoint not configured ) ; } if ( this . credentials == null ) { throw new illegal argument exception ( sr . missing credentials ) ; } if ( ! storage credentials helper . can credentials generate client ( this . credentials ) ) { throw new illegal argument exception ( sr . credentials cannot sign request ) ; } return new cloud file client ( this . get file storage uri ( ) , this . get credentials ( ) ) ; }	Creates a new File service client.
public cloud queue client create cloud queue client ( ) { if ( this . get queue storage uri ( ) == null ) { throw new illegal argument exception ( sr . queue endpoint not configured ) ; } if ( this . credentials == null ) { throw new illegal argument exception ( sr . missing credentials ) ; } if ( ! storage credentials helper . can credentials generate client ( this . credentials ) ) { throw new illegal argument exception ( sr . credentials cannot sign request ) ; } return new cloud queue client ( this . get queue storage uri ( ) , this . get credentials ( ) ) ; }	Creates a new Queue service client.
public cloud table client create cloud table client ( ) { if ( this . get table storage uri ( ) == null ) { throw new illegal argument exception ( sr . table endpoint not configured ) ; } if ( this . credentials == null ) { throw new illegal argument exception ( sr . missing credentials ) ; } if ( ! storage credentials helper . can credentials generate client ( this . credentials ) ) { throw new illegal argument exception ( sr . credentials cannot sign request ) ; } return new cloud table client ( this . get table storage uri ( ) , this . get credentials ( ) ) ; }	Creates a new Table service client.
public string generate shared access signature ( shared access account policy policy ) throws invalid key exception , storage exception { if ( ! storage credentials helper . can credentials sign request ( this . get credentials ( ) ) ) { throw new illegal argument exception ( sr . cannot create sas without account key ) ; } final string sig = shared access signature helper . generate shared access signature hash for account ( this . credentials . get account name ( ) , policy , this . get credentials ( ) ) ; final uri query builder sas builder = shared access signature helper . generate shared access signature for account ( policy , sig ) ; return sas builder . to string ( ) ; }	Returns a shared access signature for the account.
protected string generate request identity ( boolean is single index entry , final string entry name ) throws storage exception { if ( is single index entry ) { return string . format ( str , entry name . replace ( str , str ) ) ; } if ( this . op type == table operation type . insert ) { return constants . empty string ; } else { string pk = null ; string rk = null ; if ( this . op type == table operation type . retrieve ) { final query table operation q op = ( query table operation ) this ; pk = q op . get partition key ( ) ; rk = q op . get row key ( ) ; } else { pk = this . get entity ( ) . get partition key ( ) ; rk = this . get entity ( ) . get row key ( ) ; } return string . format ( str , table constants . partition key , pk . replace ( str , str ) , table constants . row key , rk . replace ( str , str ) ) ; } }	Reserved for internal use.
protected string generate request identity with table ( final string table name ) throws storage exception { return string . format ( str , table name , generate request identity ( bool , null ) ) ; }	Reserved for internal use.
protected final void initialize ( operation context op context ) { request result curr result = new request result ( ) ; this . set result ( curr result ) ; op context . append request result ( curr result ) ; this . set exception ( null ) ; this . set non exceptioned retryable failure ( bool ) ; this . set is sent ( bool ) ; }	Resets the operation status flags between operations.
protected final storage exception materialize exception ( final operation context op context ) { if ( this . get exception ( ) != null ) { return this . get exception ( ) ; } return storage exception . translate exception ( this , null , op context ) ; }	Returns either the held exception from the operation if it is set, otherwise the translated exception.
public r post process response ( url connection , p parent object , c client , operation context context , r storage object ) throws exception { return storage object ; }	Post-Stream Retrieval function.
public storage extended error information parse error details ( ) { try { if ( this . get connection ( ) == null || this . get connection ( ) . get error stream ( ) == null ) { return null ; } return storage error handler . get extended error information ( this . get connection ( ) . get error stream ( ) ) ; } catch ( final exception e ) { return null ; } }	Returns extended error information for this request.
public void delete ( final table entity entity ) { this . lock to partition key ( entity . get partition key ( ) ) ; this . add ( table operation . delete ( entity ) ) ; }	Adds a table operation to delete the specified entity to the batch operation.
public void insert ( final table entity entity , boolean echo content ) { this . lock to partition key ( entity . get partition key ( ) ) ; this . add ( table operation . insert ( entity , echo content ) ) ; }	Adds a table operation to insert the specified entity to the batch operation.
public void insert or merge ( final table entity entity ) { this . lock to partition key ( entity . get partition key ( ) ) ; this . add ( table operation . insert or merge ( entity ) ) ; }	Adds a table operation to insert or merge the specified entity to the batch operation.
public void insert or replace ( final table entity entity ) { this . lock to partition key ( entity . get partition key ( ) ) ; this . add ( table operation . insert or replace ( entity ) ) ; }	Adds a table operation to insert or replace the specified entity to the batch operation.
public void merge ( final table entity entity ) { this . lock to partition key ( entity . get partition key ( ) ) ; this . add ( table operation . merge ( entity ) ) ; }	Adds a table operation to merge the specified entity to the batch operation.
@ override public table operation remove ( int index ) { table operation op = super . remove ( index ) ; check reset entity locks ( ) ; return op ; }	Removes the table operation at the specified index from the batch operation.
@ override public boolean remove all ( java . util . collection < ? > c ) { boolean ret = super . remove all ( c ) ; check reset entity locks ( ) ; return ret ; }	Removes all elements of the specified collection from the batch operation.
public void replace ( final table entity entity ) { this . lock to partition key ( entity . get partition key ( ) ) ; this . add ( table operation . replace ( entity ) ) ; }	Adds a table operation to replace the specified entity to the batch operation.
private void check single query per batch ( final table operation op , final int size ) {	Reserved for internal use.
private void lock to partition key ( final string partition key ) { if ( this . partition key == null ) { this . partition key = partition key ; } else { if ( partition key . length ( ) != partition key . length ( ) || ! this . partition key . equals ( partition key ) ) { throw new illegal argument exception ( sr . ops in batch must have same partition key ) ; } } }	Reserved for internal use.
@ does service request public void create ( file request options options , operation context op context ) throws storage exception { if ( op context == null ) { op context = new operation context ( ) ; } assert no snapshot ( ) ; if ( this . properties != null && this . properties . get share quota ( ) != null ) { utility . assert in bounds ( str , this . properties . get share quota ( ) , num , file constants . max share quota ) ; } op context . initialize ( ) ; options = file request options . populate and apply defaults ( options , this . file service client ) ; execution engine . execute with retry ( this . file service client , this , create impl ( options ) , options . get retry policy factory ( ) , op context ) ; }	Creates the share using the specified options and operation context.
public string generate shared access signature ( final shared access file policy policy , final string group policy identifier , final ip ip range , final shared access protocols protocols ) throws invalid key exception , storage exception { if ( ! storage credentials helper . can credentials sign request ( this . file service client . get credentials ( ) ) ) { final string error message = sr . cannot create sas without account key ; throw new illegal argument exception ( error message ) ; } final string resource name = this . get shared access canonical name ( ) ; final string signature = shared access signature helper . generate shared access signature hash for blob and file ( policy , null , group policy identifier , resource name , ip range , protocols , this . file service client ) ; final uri query builder builder = shared access signature helper . generate shared access signature for blob and file ( policy , null , group policy identifier , str , ip range , protocols , signature ) ; return builder . to string ( ) ; }	Returns a shared access signature for the share.
@ does service request public void upload permissions ( final file share permissions permissions ) throws storage exception { this . upload permissions ( permissions , null , null , null ) ; }	Uploads the share's permissions.
public final uri get qualified uri ( ) throws uri , storage exception { if ( this . is snapshot ( ) ) { return path utility . add to query ( this . get uri ( ) , string . format ( str , this . snapshot id ) ) ; } return this . file service client . get credentials ( ) . transform uri ( this . get uri ( ) ) ; }	Returns the snapshot or shared access signature qualified URI for this share.
public void basic insert entity ( ) throws storage exception {	Illustrates how to form and execute a single insert operation.
public void basic batch ( ) throws storage exception {	Illustrates how to form and execute a batch operation.
public void basic query ( ) throws storage exception {	Illustrates how to form and execute a query operation.
public void basic upsert ( ) throws storage exception {	Illustrates how to form and execute an upsert operation.
public void basic delete entity ( ) throws storage exception {	Illustrates how to form and execute an entity delete operation.
public void basic listing ( ) {	Illustrates how to list the tables.
private table query < table service entity > generate list tables query ( final string prefix ) { table query < table service entity > list query = table query . < table service entity > from ( table service entity . class ) ; list query . set source table name ( table constants . tables service tables name ) ; if ( ! utility . is null or empty ( prefix ) ) {	Reserved for internal use.
public static list response < cloud queue > get queues ( final input stream stream , final cloud queue client service client ) throws sax , io , parser configuration exception { sax sax parser = utility . get sax ( ) ; queue list handler handler = new queue list handler ( service client ) ; sax parser . parse ( stream , handler ) ; return handler . response ; }	Parses the input stream containing the response body of the list queues request result and populates the classdata.
protected static storage exception translate from http status ( final int status code , final string status description , final exception inner ) { string error code ; switch ( status code ) { case url . http forbidden : error code = storage error code . access denied . to string ( ) ; break ; case url . http gone : case url . http not found : error code = storage error code . resource not found . to string ( ) ; break ; case num : case url . http bad request :	Translates the specified HTTP status code into a storage exception.
@ does service request public iterable < cloud queue > list queues ( ) { return this . list queues ( null , queue listing details . none , null , null ) ; }	Gets an iterable collection of queues for this queue service client.
@ does service request public iterable < cloud queue > list queues ( final string prefix ) { return this . list queues ( prefix , queue listing details . none , null , null ) ; }	Returns an iterable collection of queues whose names begin with thespecified prefix in this Queue service client.
@ does service request public result segment < cloud queue > list queues segmented ( ) throws storage exception { return this . list queues segmented ( null , queue listing details . none , null , null , null , null ) ; }	Gets a result segment of an iterable collection of queues for this Queueservice client.
public void add configured xml ( @ nonnull final xml a xml catalog ) { m a xml catalog . add configured xml ( a xml catalog ) ; log ( str + a xml catalog , project . msg debug ) ; }	Add the catalog to our internal catalog.
@ nullable public string get unique id ( @ nullable final string s id ) { if ( s id == null ) return null ; if ( m a used i . add ( s id ) ) {	Create a unique ID based on the passed one.
@ nonnull public schematron resource pure set phase ( @ nullable final string s phase ) { if ( m a bound schema != null ) throw new illegal state exception ( str ) ; m s phase = s phase ; return this ; }	Set the Schematron phase to be evaluated. Changing the phase will result ina newly bound schema!.
@ nonnull public schematron resource pure set error handler ( @ nullable final ips a error handler ) { if ( m a bound schema != null ) throw new illegal state exception ( str ) ; m a error handler = a error handler ; return this ; }	Set the error handler to be used during binding.
@ nonnull public schematron resource pure set variable resolver ( @ nullable final x a variable resolver ) { if ( m a bound schema != null ) throw new illegal state exception ( str ) ; m a variable resolver = a variable resolver ; return this ; }	Set the variable resolver to be used in the XPath statements.
@ nonnull public schematron resource pure set function resolver ( @ nullable final x a function resolver ) { if ( m a bound schema != null ) throw new illegal state exception ( str ) ; m a function resolver = a function resolver ; return this ; }	Set the function resolver to be used in the XPath statements.
@ nonnull public schematron resource pure set entity resolver ( @ nullable final entity resolver a entity resolver ) { if ( m a bound schema != null ) throw new illegal state exception ( str ) ; internal set entity resolver ( a entity resolver ) ; return this ; }	Set the XML entity resolver to be used when reading the Schematron or theXML to be validated.
@ nonnull public ips get or create bound schema ( ) { if ( m a bound schema == null ) try { m a bound schema = create bound schema ( ) ; } catch ( final runtime exception ex ) { if ( m a error handler != null ) m a error handler . error ( get resource ( ) , null , str , ex ) ; throw ex ; } return m a bound schema ; }	Get the cached bound schema or create a new one.
public void validate completely ( @ nonnull final ips a error handler ) { value enforcer . not null ( a error handler , str ) ; try { get or create bound schema ( ) . get original schema ( ) . validate completely ( a error handler ) ; } catch ( final runtime exception ex ) {	Use the provided error handler to validate all elements in the schematron.It tries to catch as many errors as possible.
@ nonnull public schematron output type apply schematron validation to svrl ( @ nonnull final node a xml , @ nullable final string s base uri ) throws schematron exception { value enforcer . not null ( a xml , str ) ; final schematron output type a sot = get or create bound schema ( ) . validate complete ( a xml , s base uri ) ;	The main method to convert a node to an SVRL document.
private void resolve rule content ( @ nonnull final i < ips > a rule content , @ nonnull final preprocessor lookup a lookup , @ nonnull final id a id , @ nullable final i < string , string > a param value map , @ nonnull final ps a target rule ) throws schematron preprocess exception { for ( final ips a element : a rule content ) { if ( a element instanceof ps ) { final ps a assert report = ( ps ) a element ; a target rule . add assert report ( get preprocessed assert ( a assert report , a id , a param value map ) ) ; } else { final ps a extends = ( ps ) a element ; final string s rule id = a extends . get rule ( ) ; final ps a base rule = a lookup . get abstract rule of id ( s rule id ) ; if ( a base rule == null ) throw new schematron preprocess exception ( str + s rule id + str + a lookup . get all abstract rule i ( ) ) ;	Resolve all &lt;extends&gt; elements.
@ nullable public ps get as minimal schema ( @ nonnull final ps a schema ) throws schematron preprocess exception { value enforcer . not null ( a schema , str ) ;	Convert the passed schema to a minimal schema.
@ nullable public ps get as preprocessed schema ( @ nonnull final ps a schema ) throws schematron preprocess exception { value enforcer . not null ( a schema , str ) ;	Convert the passed schema to a pre-processed schema.
@ nullable public ps get forced preprocessed schema ( @ nonnull final ps a schema ) throws schematron preprocess exception { value enforcer . not null ( a schema , str ) ; final preprocessor lookup a lookup = new preprocessor lookup ( a schema ) ; final id a id = new id ( ) ; final ps ret = new ps ( a schema . get resource ( ) ) ; ret . set id ( a id . get unique id ( a schema . get id ( ) ) ) ; ret . set rich ( a schema . get rich clone ( ) ) ; ret . set schema version ( a schema . get schema version ( ) ) ; ret . set default phase ( a schema . get default phase ( ) ) ; ret . set query binding ( a schema . get query binding ( ) ) ; if ( m b keep titles && a schema . has title ( ) ) ret . set title ( a schema . get title ( ) . get clone ( ) ) ; if ( a schema . has any include ( ) ) throw new schematron preprocess exception ( str ) ; for ( final psns a ns : a schema . get all n ( ) ) ret . add ns ( a ns . get clone ( ) ) ;	Convert the passed schema to a pre-processed schema independent if it isalready minimal or not.
@ nonnull @ override on demand public ps read schema ( @ nonnull final i a resource , @ nullable final ips a error handler , @ nullable final entity resolver a entity resolver ) throws schematron exception { return new ps ( a resource , a error handler , a entity resolver ) . read schema ( ) ; }	Read the specified schema from the passed resource.
@ nonnull @ override on demand public ips get query binding ( @ nonnull final ps a schema ) throws schematron exception { return ps . get query binding of name or throw ( a schema . get query binding ( ) ) ; }	Determine the query binding for the read schema.
@ nonnull @ override on demand public ps create preprocessed schema ( @ nonnull final ps a schema , @ nonnull final ips a query binding ) throws schematron exception { final ps a preprocessor = create preprocessor ( a query binding ) ; final ps a preprocessed schema = a preprocessor . get as preprocessed schema ( a schema ) ; if ( a preprocessed schema == null ) throw new schematron preprocess exception ( str + a schema + str + a query binding ) ; if ( schematron debug . is show preprocessed schematron ( ) ) logger . info ( str + micro writer . get node as string ( a preprocessed schema . get as micro element ( ) ) ) ; return a preprocessed schema ; }	Pre-process the read schema, using the determined query binding.
@ nonnull public e write to file ( @ nonnull final ips a ps , @ nonnull final file a file ) { value enforcer . not null ( a ps , str ) ; final i e xml = a ps . get as micro element ( ) ; return micro writer . write to file ( get as document ( e xml ) , a file , m a writer settings . get xml ( ) ) ; }	Write the passed Schematron element to the passed file.
@ nonnull public e write to stream ( @ nonnull final ips a ps , @ nonnull @ will close final output stream a os ) { value enforcer . not null ( a ps , str ) ; final i e xml = a ps . get as micro element ( ) ; return micro writer . write to stream ( get as document ( e xml ) , a os , m a writer settings . get xml ( ) ) ; }	Write the passed Schematron element to the passed output stream.
@ nonnull public e write to writer ( @ nonnull final ips a ps , @ nonnull @ will close final writer a writer ) { value enforcer . not null ( a ps , str ) ; final i e xml = a ps . get as micro element ( ) ; return micro writer . write to writer ( get as document ( e xml ) , a writer , m a writer settings . get xml ( ) ) ; }	Write the passed Schematron element to the passed writer.
@ nullable public static schematron output type apply schematron ( @ nonnull final i a schematron , @ nonnull final i a xml ) { value enforcer . not null ( a schematron , str ) ; value enforcer . not null ( a xml , str ) ; try {	Apply the passed schematron on the passed XML resource using a custom errorhandler.
@ nullable public static schematron output type apply schematron ( @ nonnull final i a schematron , @ nonnull final node a node ) { value enforcer . not null ( a schematron , str ) ; value enforcer . not null ( a node , str ) ; return apply schematron ( a schematron , new dom ( a node ) ) ; }	Apply the passed schematron on the passed XML node.
@ nonnull public e remove ( @ nullable final string s var name ) { if ( string helper . has text ( s var name ) ) if ( m a map . remove ( psx . param variable prefix + s var name ) == null ) return e . changed ; return e . unchanged ; }	Remove the variable with the specified name.
@ nonnull public e remove all ( @ nullable final iterable < string > a vars ) { e e change = e . unchanged ; if ( a vars != null ) for ( final string s name : a vars ) e change = e change . or ( remove ( s name ) ) ; return e change ; } @ nonnull @ returns mutable copy public i < string , string > get all ( ) { return m a map . get clone ( ) ; } public boolean contains ( @ nullable final string s name ) { if ( string helper . has no text ( s name ) ) return bool ; return m a map . contains key ( s name ) ; }	Remove all variables with the specified names.
@ nonnull @ returns mutable copy public static i < svrl > get all failed assertions ( @ nullable final schematron output type a schematron output ) { final i < svrl > ret = new commons array list < > ( ) ; if ( a schematron output != null ) for ( final object a obj : a schematron output . get active pattern and fired rule and failed assert ( ) ) if ( a obj instanceof failed assert ) ret . add ( new svrl ( ( failed assert ) a obj ) ) ; return ret ; }	Get a list of all failed assertions in a given schematron output.
@ nonnull @ returns mutable copy public static i < svrl > get all failed assertions more or equal severe than ( @ nullable final schematron output type a schematron output , @ nonnull final i a error level ) { final i < svrl > ret = new commons array list < > ( ) ; if ( a schematron output != null ) for ( final object a obj : a schematron output . get active pattern and fired rule and failed assert ( ) ) if ( a obj instanceof failed assert ) { final svrl a fa = new svrl ( ( failed assert ) a obj ) ; if ( a fa . get flag ( ) . is ge ( a error level ) ) ret . add ( a fa ) ; } return ret ; }	Get a list of all failed assertions in a given schematron output, with anerror level equally or more severe than the passed error level.
@ nonnull @ returns mutable copy public static i < svrl > get all successful reports ( @ nullable final schematron output type a schematron output ) { final i < svrl > ret = new commons array list < > ( ) ; if ( a schematron output != null ) for ( final object a obj : a schematron output . get active pattern and fired rule and failed assert ( ) ) if ( a obj instanceof successful report ) ret . add ( new svrl ( ( successful report ) a obj ) ) ; return ret ; }	Get a list of all successful reports in a given schematron output.
@ nonnull @ returns mutable copy public static i < svrl > get all successful reports more or equal severe than ( @ nullable final schematron output type a schematron output , @ nonnull final i a error level ) { final i < svrl > ret = new commons array list < > ( ) ; if ( a schematron output != null ) for ( final object a obj : a schematron output . get active pattern and fired rule and failed assert ( ) ) if ( a obj instanceof successful report ) { final svrl a sr = new svrl ( ( successful report ) a obj ) ; if ( a sr . get flag ( ) . is ge ( a error level ) ) ret . add ( a sr ) ; } return ret ; }	Get a list of all successful reports in a given schematron output, with anerror level equally or more severe than the passed error level.
@ nonnull @ returns mutable copy public static i < svrl > get all failed assertions and successful reports ( @ nullable final schematron output type a schematron output ) { final i < svrl > ret = new commons array list < > ( ) ; if ( a schematron output != null ) for ( final object a obj : a schematron output . get active pattern and fired rule and failed assert ( ) ) if ( a obj instanceof failed assert ) ret . add ( new svrl ( ( failed assert ) a obj ) ) ; else if ( a obj instanceof successful report ) ret . add ( new svrl ( ( successful report ) a obj ) ) ; return ret ; }	Get a list of all failed assertions and successful reports in a givenschematron output.
public static void set error level determinator ( @ nonnull final isvrl a eld ) { value enforcer . not null ( a eld , str ) ; s a rw . read locked ( ( ) -> s a eld = a eld ) ; }	Set the global error level determinator.
@ nullable public static ips get query binding of name ( @ nullable final string s name ) { if ( s name == null ) return default query binding ; return s a rw . read locked ( ( ) -> s a map . get ( s name ) ) ; }	Get the query binding with the specified name.
@ nonnull public static ips get query binding of name or throw ( @ nullable final string s name ) throws schematron bind exception { final ips a qb = get query binding of name ( s name ) ; if ( a qb == null ) throw new schematron bind exception ( str + s name + str ) ; return a qb ; }	Get the query binding with the specified name.
@ nonnull public x load x ( @ nonnull @ will close final input stream a x is ) throws x , io { value enforcer . not null ( a x is , str ) ; try { final x a function resolver = new x ( ) ;	Load XQuery functions from an input stream.
private string format ( final string format , final object arg ) { final formatting tuple tuple = message formatter . format ( format , arg ) ; return tuple . get message ( ) ; }	Format with one object.
private string format ( final string format , final object first , final object second ) { final formatting tuple tuple = message formatter . format ( format , first , second ) ; return tuple . get message ( ) ; }	Format with two objects.
public static boolean is valid schematron ( @ nullable final i a node ) { if ( a node == null ) return bool ; return is valid schematron ( transform source factory . create ( micro writer . get node as string ( a node ) ) ) ; }	Check if the passed micro node is a valid schematron instance.
public static boolean is valid schematron ( @ nullable final node a node ) { if ( a node == null ) return bool ; return is valid schematron ( transform source factory . create ( a node ) ) ; }	Check if the passed DOM node is a valid schematron instance.
public static boolean is valid schematron ( @ nullable final i a res ) { if ( a res == null ) return bool ; return is valid schematron ( transform source factory . create ( a res ) ) ; }	Check if the passed resource is a valid schematron instance.
public static boolean is valid schematron ( @ nullable final source a source ) { if ( a source == null ) return bool ; try {	Check if the passed source is a valid schematron instance.
@ nullable public static xslt sch create schematron xslt ( @ nonnull final i a schematron resource , @ nonnull final sch a transformer customizer ) { if ( logger . is debug enabled ( ) ) logger . debug ( str + a schematron resource . to string ( ) ) ; final xslt sch a xslt = new xslt sch ( a schematron resource , a transformer customizer ) ; if ( ! a xslt . is valid schematron ( ) ) {	Create a new Schematron validator for the passed resource.
@ nullable public static xslt sch get schematron xslt ( @ nonnull final i a schematron resource , @ nonnull final sch a transformer customizer ) { value enforcer . not null ( a schematron resource , str ) ; value enforcer . not null ( a transformer customizer , str ) ; if ( ! a schematron resource . exists ( ) ) { logger . warn ( str + a schematron resource + str ) ; return null ; } if ( ! a transformer customizer . can cache result ( ) ) {	Get the Schematron validator for the passed resource.
@ nonnull private string get error text ( @ nonnull final list < psx > a bound content elements , @ nonnull final node a source node ) throws schematron validation exception { final string builder a sb = new string builder ( ) ; for ( final psx a bound element : a bound content elements ) { final object a content = a bound element . get element ( ) ; if ( a content instanceof string ) a sb . append ( ( string ) a content ) ; else if ( a content instanceof ps ) { final ps a name = ( ps ) a content ; if ( a name . has path ( ) ) {	Get the error text from an assert or report element.
@ nullable public static string get beautified location ( @ nonnull final string s namespace uri , @ nonnull final string s local name ) { for ( final isvrl spi a beautifier : s a list ) { final string s beautified = a beautifier . get replacement text ( s namespace uri , s local name ) ; if ( s beautified != null ) return s beautified ; } if ( logger . is debug enabled ( ) ) logger . debug ( str + s namespace uri + str + s local name ) ; return null ; }	Get the beautified location for the given namespace and local name.
private void warn ( @ nonnull final ips a source element , @ nonnull final string s message ) { value enforcer . not null ( a source element , str ) ; value enforcer . not null ( s message , str ) ; m a error handler . warn ( m a resource , a source element , s message ) ; }	Emit a warning with the registered error handler.
@ nonnull public ps read active from xml ( @ nonnull final i e active ) { final ps ret = new ps ( ) ; e active . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr pattern ) ) ret . set pattern ( s attr value ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e active . for all children ( a active child -> { switch ( a active child . get type ( ) ) { case text : ret . add text ( ( ( i ) a active child ) . get node value ( ) ) ; break ; case element : final i e element = ( i ) a active child ; if ( c . namespace schematron . equals ( e element . get namespace uri ( ) ) ) { final string s local name = e element . get local name ( ) ; if ( s local name . equals ( c xml . element dir ) ) ret . add dir ( read dir from xml ( e element ) ) ; else if ( s local name . equals ( c xml . element emph ) ) ret . add emph ( read emph from xml ( e element ) ) ; else if ( s local name . equals ( c xml . element span ) ) ret . add span ( read span from xml ( e element ) ) ; else warn ( ret , str + s local name + str ) ; } else ret . add foreign element ( e element . get clone ( ) ) ; break ; case comment :	Read an &lt;active&gt; element.
@ nonnull public ps read diagnostics from xml ( @ nonnull final i e diagnostics ) { final ps ret = new ps ( ) ; e diagnostics . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e diagnostics . for all child elements ( e diagnostics child -> { if ( c . namespace schematron . equals ( e diagnostics child . get namespace uri ( ) ) ) { if ( e diagnostics child . get local name ( ) . equals ( c xml . element include ) ) ret . add include ( read include from xml ( e diagnostics child ) ) ; else if ( e diagnostics child . get local name ( ) . equals ( c xml . element diagnostic ) ) ret . add diagnostic ( read diagnostic from xml ( e diagnostics child ) ) ; else warn ( ret , str + e diagnostics child . get local name ( ) + str ) ; } else ret . add foreign element ( e diagnostics child . get clone ( ) ) ; } ) ; return ret ; }	Read a &lt;diagnostics&gt; element.
@ nonnull public ps read dir from xml ( @ nonnull final i e dir ) { final ps ret = new ps ( ) ; e dir . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr value ) ) ret . set value ( e . get from id ( s attr value ) ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e dir . for all children ( a dir child -> { switch ( a dir child . get type ( ) ) { case text : ret . add text ( ( ( i ) a dir child ) . get node value ( ) ) ; break ; case element : final i e element = ( i ) a dir child ; if ( c . namespace schematron . equals ( e element . get namespace uri ( ) ) ) { warn ( ret , str + e element . get local name ( ) + str ) ; } else ret . add foreign element ( e element . get clone ( ) ) ; break ; case comment :	Read a &lt;dir&gt; element.
@ nonnull public ps read emph from xml ( @ nonnull final i e emph ) { final ps ret = new ps ( ) ; e emph . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; warn ( ret , str + s attr name + str + s attr value + str ) ; } ) ; e emph . for all children ( a emph child -> { switch ( a emph child . get type ( ) ) { case text : ret . add text ( ( ( i ) a emph child ) . get node value ( ) ) ; break ; case element : final i e element = ( i ) a emph child ; if ( c . namespace schematron . equals ( e element . get namespace uri ( ) ) ) { warn ( ret , str + e element . get local name ( ) + str ) ; } else warn ( ret , str + e element . get namespace uri ( ) + str ) ; break ; case comment :	Read an &lt;emph&gt; element.
@ nonnull public ps read extends from xml ( @ nonnull final i e extends ) { final ps ret = new ps ( ) ; e extends . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr rule ) ) ret . set rule ( s attr value ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e extends . for all child elements ( e child -> { if ( c . namespace schematron . equals ( e child . get namespace uri ( ) ) ) { warn ( ret , str + e child . get local name ( ) + str ) ; } else warn ( ret , str + e child . get namespace uri ( ) + str ) ; } ) ; return ret ; }	Read an &lt;extends&gt; element.
@ nonnull public ps read include from xml ( @ nonnull final i e include ) { final ps ret = new ps ( ) ; e include . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr href ) ) ret . set href ( s attr value ) ; else warn ( ret , str + s attr name + str + s attr value + str ) ; } ) ; e include . for all child elements ( e value of child -> { if ( c . namespace schematron . equals ( e value of child . get namespace uri ( ) ) ) { warn ( ret , str + e value of child . get local name ( ) + str ) ; } else warn ( ret , str + e value of child . get namespace uri ( ) + str ) ; } ) ; return ret ; }	Read an &lt;include&gt; element.
@ nonnull public ps read let from xml ( @ nonnull final i e let ) { final ps ret = new ps ( ) ; e let . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr name ) ) ret . set name ( s attr value ) ; else if ( s attr name . equals ( c xml . attr value ) ) ret . set value ( s attr value ) ; else warn ( ret , str + s attr name + str + s attr value + str ) ; } ) ; e let . for all child elements ( e let child -> { if ( c . namespace schematron . equals ( e let child . get namespace uri ( ) ) ) { warn ( ret , str + e let child . get local name ( ) + str ) ; } else warn ( ret , str + e let child . get namespace uri ( ) + str ) ; } ) ; return ret ; }	Read a &lt;let&gt; element.
@ nonnull public ps read name from xml ( @ nonnull final i e name ) { final ps ret = new ps ( ) ; e name . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr path ) ) ret . set path ( s attr value ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e name . for all child elements ( e name child -> { if ( c . namespace schematron . equals ( e name child . get namespace uri ( ) ) ) { warn ( ret , str + e name child . get local name ( ) + str ) ; } else warn ( ret , str + e name child . get namespace uri ( ) + str ) ; } ) ; return ret ; }	Read a &lt;name&gt; element.
@ nonnull public psns read ns xml ( @ nonnull final i e ns ) { final psns ret = new psns ( ) ; e ns . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr uri ) ) ret . set uri ( s attr value ) ; else if ( s attr name . equals ( c xml . attr prefix ) ) ret . set prefix ( s attr value ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e ns . for all child elements ( e let child -> { if ( c . namespace schematron . equals ( e let child . get namespace uri ( ) ) ) { warn ( ret , str + e let child . get local name ( ) + str ) ; } else warn ( ret , str + e let child . get namespace uri ( ) + str ) ; } ) ; return ret ; }	Read a &lt;ns&gt; element.
@ nonnull public psp read p xml ( @ nonnull final i e p ) { final psp ret = new psp ( ) ; e p . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr id ) ) ret . set id ( s attr value ) ; else if ( s attr name . equals ( c xml . attr class ) ) ret . set clazz ( s attr value ) ; else if ( s attr name . equals ( c xml . attr icon ) ) ret . set icon ( s attr value ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e p . for all children ( a child -> { switch ( a child . get type ( ) ) { case text : ret . add text ( ( ( i ) a child ) . get node value ( ) ) ; break ; case element : final i e element = ( i ) a child ; if ( c . namespace schematron . equals ( e element . get namespace uri ( ) ) ) { final string s local name = e element . get local name ( ) ; if ( s local name . equals ( c xml . element dir ) ) ret . add dir ( read dir from xml ( e element ) ) ; else if ( s local name . equals ( c xml . element emph ) ) ret . add emph ( read emph from xml ( e element ) ) ; else if ( s local name . equals ( c xml . element span ) ) ret . add span ( read span from xml ( e element ) ) ; else warn ( ret , str + s local name + str ) ; } else ret . add foreign element ( e element . get clone ( ) ) ; break ; case comment :	Read a &lt;p&gt; element.
@ nonnull public ps read param from xml ( @ nonnull final i e param ) { final ps ret = new ps ( ) ; e param . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr name ) ) ret . set name ( s attr value ) ; else if ( s attr name . equals ( c xml . attr value ) ) ret . set value ( s attr value ) ; else warn ( ret , str + s attr name + str + s attr value + str ) ; } ) ; e param . for all child elements ( e param child -> { if ( c . namespace schematron . equals ( e param child . get namespace uri ( ) ) ) { warn ( ret , str + e param child . get local name ( ) + str ) ; } else warn ( ret , str + e param child . get namespace uri ( ) + str ) ; } ) ; return ret ; }	Read a &lt;param&gt; element.
@ nonnull public ps read phase from xml ( @ nonnull final i e phase ) { final ps ret = new ps ( ) ; final ps a rich group = new ps ( ) ; e phase . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr id ) ) ret . set id ( s attr value ) ; else if ( ps . is rich attribute ( s attr name ) ) handle rich group ( s attr name , s attr value , a rich group ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; ret . set rich ( a rich group ) ; e phase . for all child elements ( e phase child -> { if ( c . namespace schematron . equals ( e phase child . get namespace uri ( ) ) ) { if ( e phase child . get local name ( ) . equals ( c xml . element include ) ) ret . add include ( read include from xml ( e phase child ) ) ; else if ( e phase child . get local name ( ) . equals ( c xml . element p ) ) ret . add p ( read p xml ( e phase child ) ) ; else if ( e phase child . get local name ( ) . equals ( c xml . element let ) ) ret . add let ( read let from xml ( e phase child ) ) ; else if ( e phase child . get local name ( ) . equals ( c xml . element active ) ) ret . add active ( read active from xml ( e phase child ) ) ; else warn ( ret , str + e phase child . get local name ( ) + str ) ; } else ret . add foreign element ( e phase child . get clone ( ) ) ; } ) ; return ret ; }	Read a &lt;phase&gt; element.
@ nonnull public ps read span from xml ( @ nonnull final i e span ) { final ps ret = new ps ( ) ; e span . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr class ) ) ret . set clazz ( s attr value ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e span . for all children ( a span child -> { switch ( a span child . get type ( ) ) { case text : ret . add text ( ( ( i ) a span child ) . get node value ( ) ) ; break ; case element : final i e element = ( i ) a span child ; if ( c . namespace schematron . equals ( e element . get namespace uri ( ) ) ) { warn ( ret , str + e element . get local name ( ) + str ) ; } else ret . add foreign element ( e element . get clone ( ) ) ; break ; case comment :	Read a &lt;span&gt; element.
@ nonnull public ps read title from xml ( @ nonnull final i e title ) { final ps ret = new ps ( ) ; e title . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; warn ( ret , str + s attr name + str + s attr value + str ) ; } ) ; e title . for all children ( a title child -> { switch ( a title child . get type ( ) ) { case text : ret . add text ( ( ( i ) a title child ) . get node value ( ) ) ; break ; case element : final i e element = ( i ) a title child ; if ( c . namespace schematron . equals ( e element . get namespace uri ( ) ) ) { final string s local name = e element . get local name ( ) ; if ( s local name . equals ( c xml . element dir ) ) ret . add dir ( read dir from xml ( e element ) ) ; else warn ( ret , str + s local name + str ) ; } else warn ( ret , str + e element . get namespace uri ( ) + str ) ; break ; case comment :	Read a &lt;title&gt; element.
@ nonnull public ps read value of from xml ( @ nonnull final i e value of ) { final ps ret = new ps ( ) ; e value of . for all attributes ( ( s ns , s attr name , s val ) -> { final string s attr value = get attribute value ( s val ) ; if ( s attr name . equals ( c xml . attr select ) ) ret . set select ( s attr value ) ; else ret . add foreign attribute ( s attr name , s attr value ) ; } ) ; e value of . for all child elements ( e value of child -> { if ( c . namespace schematron . equals ( e value of child . get namespace uri ( ) ) ) { warn ( ret , str + e value of child . get local name ( ) + str ) ; } else warn ( ret , str + e value of child . get namespace uri ( ) + str ) ; } ) ; return ret ; }	Read a &lt;value-of&gt; element.
@ nonnull @ returns mutable copy public static map based namespace context create namespace mapping ( @ nonnull final ps a schema ) { final map based namespace context ret = new map based namespace context ( ) ; ret . add default namespace uri ( c . namespace schematron ) ; for ( final psns a item : a schema . get all n ( ) ) ret . add mapping ( a item . get prefix ( ) , a item . get uri ( ) ) ; return ret ; }	Helper method to extract the namespace mapping from the providedSchematron.
private < t > completion stage < t > regex ( final http . request header request header , final deadbolt handler deadbolt handler , final optional < string > content , final string [ ] values , final int value index , final constraint mode mode , final boolean invert , final function < http . request header , completion stage < t > > pass , final tri function < http . request header , deadbolt handler , optional < string > , completion stage < t > > fail , final constraint point constraint point ) { return completable future . completed future ( pattern cache . apply ( values [ value index ] ) ) . then combine ( get subject ( request header , deadbolt handler ) , ( pattern value , subject ) -> f . tuple ( subject . 1 . is present ( ) ? analyzer . check regex pattern ( subject . 1 , optional . of nullable ( pattern value ) ) : invert , subject . 2 ) )	Checks access to the resource based on the regex.
private http . request header mark as authorised ( final http . request header request ) { this . authorised = bool ; return request . add attr ( action authorised , bool ) ; }	Marks the current action as authorised.
protected static boolean is authorised ( final http . request header request ) { return request . attrs ( ) . get optional ( action authorised ) . or else ( bool ) ; }	Checks if an action is authorised.
protected http . request header defer ( final http . request header request , final abstract deadbolt action < t > action ) { if ( action != null ) { logger . info ( str , this . get class ( ) . get name ( ) ) ; return request . add attr ( action deferred , action ) ; } return request ; }	Defer execution until a later point.
@ suppress warnings ( str ) public f . tuple < abstract deadbolt action < ? > , http . request header > get deferred action ( final http . request header request ) { return request . attrs ( ) . get optional ( action deferred ) . map ( action -> { action . delegate = this ; return f . < abstract deadbolt action < ? > , http . request header > tuple ( action , request . remove attr ( action deferred ) . add attr ( ignore deferred flag , bool ) ) ; } ) . or else get ( ( ) -> f . tuple ( null , request ) ) ; }	Get the deferred action from the request.
protected completion stage < result > authorize and execute ( final http . request header request ) { if ( constraint annotation mode != constraint annotation mode . and ) {	Add a flag to the request to indicate the action has passed the constraintand call the delegate.
private static boolean deadbolt action left in action chain ( final action < ? > action ) { if ( action != null ) { if ( action . delegate instanceof abstract deadbolt action ) { return bool ;	Recursive method to determine if there is another deadbolt action further down the action chain.
public list < string > get role names ( final optional < ? extends subject > subject option ) { final list < string > role names = new array list < > ( ) ; subject option . if present ( subject -> { final list < ? extends role > roles = subject . get roles ( ) ; if ( roles != null ) { role names . add all ( roles . stream ( ) . filter ( objects :: non null ) . map ( role :: get name ) . collect ( collectors . to list ( ) ) ) ; } } ) ; return role names ; }	Gets the role name of each role held.
public boolean has role ( final optional < ? extends subject > subject option , final string role name ) { return get role names ( subject option ) . contains ( role name ) ; }	Check if the subject has the given role.
public filter function subject present ( final optional < string > content ) { return ( http . request header request header , deadbolt handler handler , function < http . request header , completion stage < result > > next ) -> before auth check cache . apply ( handler , request header , content ) . then compose ( maybe pre auth -> maybe pre auth . 1 . map ( pre auth result -> ( completion stage < result > ) completable future . completed future ( pre auth result ) ) . or else get ( ( ) -> constraint logic . subject present ( maybe pre auth . 2 , handler , content , ( rh , hdlr , cntent ) -> next . apply ( rh ) , ( rh , hdlr , cntent ) -> hdlr . on auth failure ( rh , cntent ) , constraint point . filter ) ) ) ; }	A constraint that requires a subject to be present.
public static string [ ] roles ( final role ... roles ) { final list < string > names = new array list < > ( roles . length ) ; for ( role role : roles ) { names . add ( role . get name ( ) ) ; } return names . to array ( new string [ names . size ( ) ] ) ; }	Converts the roles into a String array.
public static string [ ] permissions ( final permission ... permissions ) { final list < string > values = new array list < > ( permissions . length ) ; for ( permission permission : permissions ) { values . add ( permission . get value ( ) ) ; } return values . to array ( new string [ values . size ( ) ] ) ; }	Converts the permissions into a String array.
public static list < string [ ] > all of group ( final string ... args ) { return collections . singleton list ( args == null ? new string [ num ] : args ) ; }	Converts the arguments into a String array wrapped in a list.
public boolean view restrict ( final list < string [ ] > roles , final deadbolt handler handler , final optional < string > content , final long timeout in millis , final http . request header request header ) throws throwable { boolean allowed ; try { allowed = constraint logic . restrict ( request header , handler ( handler ) , content , ( ) -> roles , rh -> completable future . completed future ( boolean . true ) , ( rh , dh , cnt ) -> completable future . completed future ( boolean . false ) , constraint point . template ) . to completable future ( ) . get ( timeout in millis , time unit . milliseconds ) ; } catch ( timeout exception e ) { allowed = timeout handler . apply ( timeout in millis , e ) ; } return allowed ; }	Used for restrict tags in the template.
static coder result overflow ( char buffer input , int i , char buffer output , int j ) { input . position ( i - input . array offset ( ) ) ; output . position ( j - output . array offset ( ) ) ; return coder result . overflow ; }	Internal helper method to properly position buffers after encoding upuntil an overflow.
static coder result underflow ( char buffer input , int i , char buffer output , int j ) { input . position ( i - input . array offset ( ) ) ; output . position ( j - output . array offset ( ) ) ; return coder result . underflow ; }	Internal helper method to properly position buffers after encoding upuntil an underflow.
ascii set ( int min , int max ) {	Sets a range of characters to 1s in the masks.
static string encode ( encoder encoder , string str ) { if ( str == null ) {	Core encoding loop shared by public methods.
static void encode ( encoder encoder , writer out , string str ) throws io { if ( str == null ) {	Core encoding loop shared by public methods.
private static < t extends encoder > t map ( string name , t encoder ) { encoder old = encoders map . put ( name , encoder ) ; assert old == null ; return encoder ; }	Internal method to setup and map encoder singletons.
public static encoder for name ( string context name ) throws null pointer exception , unsupported context exception { if ( context name == null ) { throw new null pointer exception ( ) ; } encoder encoder = encoders map . get ( context name ) ; if ( encoder == null ) { throw new unsupported context exception ( context name ) ; } return encoder ; }	Returns a new instance of an Encoder for the specified context.
static int append ( char [ ] src , char [ ] out , int j ) { system . arraycopy ( src , num , out , j , src . length ) ; return j + src . length ; }	Appends a source array verbatim to the output array.
public string encode ( string str ) { if ( str == null ) { str = str ; } int n = str . length ( ) ; int j = first . first encoded offset ( str , num , n ) ; if ( j == n ) {	Encodes an input string to an output string.
private void flush buffer to writer ( ) throws io { out . write ( buffer . array ( ) , num , buffer . position ( ) ) ; buffer . clear ( ) ; }	Flushes the contents of the buffer to the writer and resets the buffer to make room for more input.
private void flush left over ( char buffer input ) throws io { if ( ! has left over ) { return ; } for ( ; ; ) { if ( input != null && input . has remaining ( ) ) { left over buffer . put ( input . get ( ) ) ; } left over buffer . flip ( ) ; coder result cr = encoder . encode ( left over buffer , buffer , input == null ) ; if ( cr . is underflow ( ) ) { if ( left over buffer . has remaining ( ) ) { left over buffer . compact ( ) ; } else { break ; } } if ( cr . is overflow ( ) ) { flush buffer to writer ( ) ; } } has left over = bool ; left over buffer . clear ( ) ; }	Flushes the left-over buffer.
public flowable < reactive sensor event > observe sensor ( int sensor type , final int sampling period in us , final handler handler , final backpressure strategy strategy ) { if ( ! has sensor ( sensor type ) ) { string format = str ; string message = string . format ( locale . get default ( ) , format , sensor type ) ; return flowable . error ( new sensor not found exception ( message ) ) ; } final sensor sensor = sensor manager . get default sensor ( sensor type ) ; final sensor event listener wrapper wrapper = new sensor event listener wrapper ( ) ; final sensor event listener listener = wrapper . create ( ) ; return flowable . create ( new flowable on subscribe < reactive sensor event > ( ) { @ override public void subscribe ( final flowable emitter < reactive sensor event > emitter ) throws exception { wrapper . set emitter ( emitter ) ; if ( handler == null ) { sensor manager . register listener ( listener , sensor , sampling period in us ) ; } else { sensor manager . register listener ( listener , sensor , sampling period in us , handler ) ; } } } , strategy ) . do on cancel ( new action ( ) { @ override public void run ( ) throws exception { sensor manager . unregister listener ( listener ) ; } } ) ; }	Returns RxJava Observable, which allows to monitor hardware sensorsas a stream of ReactiveSensorEvent object with defined sampling period.
private string get text ( json node node , string property name ) { json node child node = node . get ( property name ) ; if ( child node == null ) { return null ; } return child node . as text ( ) ; }	Get the text from child node with the given name.
public result execute ( query query ) throws sonar break exception , io { url query url = build url ( sonar url , query ) ; log . debug ( str + query url . to string ( ) ) ; if ( ! is url ( sonar url , sonar connection retries ) ) { throw new sonar break exception ( string . format ( str , sonar connection retries ) ) ; } return fetch sonar status with retries ( query url , query . get version ( ) ) ; }	Execute the given query on the specified sonar server.
protected static url build url ( url sonar url , query query ) throws url , illegal argument exception { if ( query . get sonar key ( ) == null || query . get sonar key ( ) . length ( ) == num ) { throw new illegal argument exception ( str ) ; } string sonar path with resource = string . format ( sonar format path , query . get sonar key ( ) ) ; return new url ( sonar url , sonar path with resource ) ; }	Creates a url for the specified quality gate query.
private result fetch sonar status with retries ( url query url , string version ) throws io , sonar break exception { date time one minute ago = date time . now ( ) . minus seconds ( sonar look back seconds ) ; date time wait until = date time . now ( ) . plus seconds ( wait for processing seconds ) ; do {	Get the status from sonar for the currently executing build.
private result fetch sonar status ( url query url ) throws io , sonar break exception { input stream in = null ; try { url connection = query url . open connection ( ) ; connection . set request property ( str , str ) ; in = connection . get input stream ( ) ; string response = io . to string ( in ) ; return parse response ( response ) ; } finally { io . close quietly ( in ) ; } }	Get the status of a build project from sonar. This returns the current status that sonar has and does notdo any checking to ensure it matches the current project.
protected static result parse response ( string response ) throws sonar break exception { object mapper mapper = new object mapper ( ) ; final date format df = new simple date format ( str ) ; mapper . set date format ( df ) ; list < result > results ; try { results = mapper . read value ( response , new type reference < list < result > > ( ) { } ) ; } catch ( io e ) { throw new sonar break exception ( str + response , e ) ; } if ( results == null || results . size ( ) != num ) { throw new sonar break exception ( str + response ) ; } return results . get ( num ) ; }	Parses the string response from sonar into POJOs.
private string compute identifier ( final dto transfer ) { string identifier = null ; switch ( transfer . get store key ( ) . get package type ( ) ) { case maven pkg key : artifact path info path info = artifact path info . parse ( transfer . get path ( ) ) ; if ( path info != null ) { artifact ref aref = new simple artifact ref ( path info . get project id ( ) , path info . get type ( ) , path info . get classifier ( ) ) ; identifier = aref . to string ( ) ; } break ; case npm pkg key : npm package path info npm path info = npm package path info . parse ( transfer . get path ( ) ) ; if ( npm path info != null ) { npm package ref package ref = new npm package ref ( npm path info . get name ( ) , npm path info . get version ( ) ) ; identifier = package ref . to string ( ) ; } break ; case generic pkg key :	Computes identifier string for an artifact.
private string compute generic identifier ( string origin url , string local url , string sha256 ) { string identifier = origin url ; if ( identifier == null ) {	Compute the identifier string for a generic download, that does not match package type specific files structure.It prefers to use the origin URL if it is not empty.
private artifact validate artifact ( artifact artifact ) throws repository manager exception { set < constraint violation < artifact > > violations = validator . validate ( artifact ) ; if ( ! violations . is empty ( ) ) { throw new repository manager exception ( str + artifact . to string ( ) + str , violations ) ; } return artifact ; }	Check artifact for any validation errors.
public boolean has config dependency on ( build task build task ) { if ( build task == null || this . equals ( build task ) ) { return bool ; } build configuration build configuration = build configuration audited . get build configuration ( ) ; if ( build configuration == null || build configuration . get all dependencies ( ) == null ) { return bool ; } return build configuration . depends on ( build task . get build configuration audited ( ) . get build configuration ( ) ) ; }	Check if this build task has a build configuration dependency on the given build task.The search include transitive dependencies.
public boolean has direct config dependency on ( build task build task ) { if ( build task == null || this . equals ( build task ) ) { return bool ; } build configuration build configuration = build configuration audited . get build configuration ( ) ; if ( build configuration == null || build configuration . get dependencies ( ) == null ) { return bool ; } return build configuration . get dependencies ( ) . contains ( build task . get build configuration audited ( ) . get build configuration ( ) ) ; }	Check if this build task has a direct build configuration dependency on the given build task.
public < t extends abstract module config > t parse jsonpnc ( string config content , config provider < t > provider ) throws configuration parse exception { try { object mapper mapper = new object mapper ( ) ; provider . register provider ( mapper ) ; pnc pnc group = get module group ( mapper , config content , pnc . class ) ; for ( abstract module config config : pnc group . get configs ( ) ) { if ( config . get class ( ) . is assignable from ( provider . get type ( ) ) ) { return ( t ) config ; } } throw new configuration parse exception ( str + provider . get type ( ) . get simple name ( ) + str ) ; } catch ( io | runtime exception e ) { log . error ( e . get message ( ) ) ; throw new configuration parse exception ( str , e ) ; } }	Loads JSON configuration to the module configuration object.
@ override public void monitor ( consumer < completed repository deletion > on complete , consumer < exception > on error ) { try { store key from key = new store key ( pakage type , from type , from id ) ; if ( indy . stores ( ) . exists ( from key ) ) { indy . stores ( ) . delete ( from key , str ) ; } on complete . accept ( new indy completed deletion ( bool ) ) ; } catch ( indy client exception e ) { on error . accept ( e ) ; } }	Trigger the repository deletion configured for this instance, and send the result to the appropriate consumer.
public void task status updated to final state ( ) {	Notify the set that the state of one of it's tasks has changed.
public build task get build task ( build configuration audited build configuration audited ) { return build tasks . stream ( ) . filter ( ( bt ) -> bt . get build configuration audited ( ) . equals ( build configuration audited ) ) . find first ( ) . or else ( null ) ; }	Get the build task which contains the given audited build configuration.
@ override public void monitor ( consumer < completed repository promotion > on complete , consumer < exception > on error ) { try { store key from key = new store key ( pakage type , from type , from id ) ; if ( ! indy . stores ( ) . exists ( from key ) ) { throw new repository manager exception ( str , from type . singular endpoint name ( ) , from id ) ; } store key to key = new store key ( pakage type , store type . group , to id ) ; group record set group = indy . stores ( ) . load ( to key , group . class ) ; if ( record set group == null ) { throw new repository manager exception ( str , to id ) ; } record set group . add constituent ( from key ) ; boolean result = indy . stores ( ) . update ( record set group , str + from type . singular endpoint name ( ) + str + from id + str + to id ) ; on complete . accept ( new indy completed promotion ( result ) ) ; } catch ( indy client exception | repository manager exception e ) { on error . accept ( e ) ; } }	Trigger the repository promotion configured for this instance, and send the result to the appropriate consumer.
public static < t > void merge ( graph < t > target , graph < t > to merge ) { for ( vertex < t > vertex : to merge . get verticies ( ) ) { target . add vertex ( vertex ) ; }	Adds all elements from toMerge to target.
public static string read file as string ( file file name ) throws io { try ( scanner sc = new scanner ( file name , charset . default charset ( ) . name ( ) ) ) { sc . use delimiter ( str ) ; return sc . next ( ) ; } }	Reads whole content of file to String.
public static string read stream as string ( input stream stream ) throws io { try ( scanner sc = new scanner ( stream , charset . default charset ( ) . name ( ) ) ) { sc . use delimiter ( str ) ; return sc . next ( ) ; } }	Reads whole content of input stream to String.
public void start release ( product milestone milestone , string access token ) { product milestone release release = trigger release ( milestone , access token ) ; product milestone release repository . save ( release ) ; }	Starts milestone release process.
public void cleanup ( ) {	Regularly cleans finished BPM tasks asynchronouslyImmediate cleanup is not usable because of NCL-2300.
@ deprecated public integer get task id by build id ( int build id ) { list < integer > result = tasks . values ( ) . stream ( ) . filter ( t -> t instanceof bpm build task ) . filter ( t -> ( ( bpm build task ) t ) . get build task ( ) . get id ( ) == build id ) . map ( bpm task :: get task id ) . collect ( collectors . to list ( ) ) ; if ( result . size ( ) > num ) throw new illegal state exception ( str + result ) ; return result . size ( ) == num ? result . get ( num ) : null ; }	This method solves backwards compatibility problem.It will be removed soon.
public static < t > collector < collection < t > , list < t > , list < t > > to flat list ( ) { return collector . of ( array list :: new , list :: add all , ( left , right ) -> { left . add all ( right ) ; return left ; } ) ; }	Flattening collector.Look at StreamCollectorsTest for example usage.
@ schedule public void cleanup expired temporary builds ( ) throws validation exception { log . info ( str + temporary build lifespan + str ) ; date expiration threshold = time utils . get date x ( temporary build lifespan ) ; string auth token = service client . get auth token ( ) ; delete expired build config set records ( expiration threshold , auth token ) ; delete expired build records ( expiration threshold , auth token ) ; log . info ( str ) ; }	Cleanup old temporary builds every midnight.
private void setup build repos ( build execution execution , string package type , indy indy , map < string , string > generic parameters ) throws indy client exception { string build content id = execution . get build content id ( ) ; int id = execution . get id ( ) ;	Create the hosted repository and group necessary to support a single build.
private void on rc ( bpm notification rest notification , build configuration rest build configuration rest ) { log . debug ( str + notification ) ; bpm string map notification rest repository creation task result = ( bpm string map notification rest ) notification ; int repository configuration id = - num ; int build configuration saved id = - num ; try { repository configuration id = integer . value of ( repository creation task result . get data ( ) . get ( str ) ) ; } catch ( number format exception ex ) { string error message = str + repository creation task result + str + repository creation task result . get data ( ) . get ( str ) + str ; log . error ( error message , ex ) ; send error message ( repository configuration id , build configuration saved id , error message ) ; return ; } repository configuration repository configuration = repository configuration repository . query by id ( repository configuration id ) ; if ( repository configuration == null ) { string error message = str ; log . error ( error message ) ; send error message ( repository configuration id , build configuration saved id , error message ) ; return ; } if ( build configuration rest != null ) {	Given the successful BC creation, add the BC into the BC sets.
private void add websocket forwarding listeners ( repository creation task task ) { consumer < ? extends bpm notification rest > do notify = ( e ) -> ws notifier . send message ( e ) ; task . add listener ( bpm event type . rc repo creation success , do notify ) ; task . add listener ( bpm event type . rc repo creation error , do notify ) ; task . add listener ( bpm event type . rc repo clone success , do notify ) ; task . add listener ( bpm event type . rc repo clone error , do notify ) ;	This method will add listeners to all important RCC event typesand forward the event to WS clients.
public static artifact mock imported artifact ( int id ) { return get artifact builder ( id ) . import date ( date . from ( instant . now ( ) ) ) . origin url ( str + id + str ) . build ( ) ; }	Create an artifact with an import date and origin url.
public static void set ssl required ( boolean ssl required ) { if ( http util . ssl required != ssl required ) { http util . ssl required = ssl required ; http util . http client = null ; } }	Sets flag telling if SSL hostname validation should be done which also clears the cached httpClient.
public result delete temporary build ( integer build record id , string auth token ) throws validation exception { build record build record = build record repository . find by id fetch all properties ( build record id ) ; if ( ! build record . is temporary build ( ) ) { throw new validation exception ( str ) ; } log . info ( str + build record + str + build record . get built artifacts ( ) + str + build record . get dependencies ( ) ) ; result result = remote builds cleaner . delete remote builds ( build record , auth token ) ; if ( ! result . is success ( ) ) { log . error ( str , build record . get id ( ) ) ; return new result ( build record id . to string ( ) , result . status . failed , str ) ; } set < artifact > artifacts to be deleted = new hash set < > ( ) ; remove relation build record artifact ( build record , artifacts to be deleted ) ; delete artifacts ( artifacts to be deleted ) ; delete dependencies ( build record ) ; build record repository . delete ( build record . get id ( ) ) ; log . info ( str , build record ) ; return new result ( build record id . to string ( ) , result . status . success ) ; }	Deletes a temporary build and artifacts created during the build or orphan dependencies used.
public result delete temporary build config set record ( integer build config set record id , string auth token ) throws validation exception { build config set record build config set record = build config set record repository . query by id ( build config set record id ) ; if ( ! build config set record . is temporary build ( ) ) { throw new validation exception ( str ) ; } log . info ( str + build config set record ) ; for ( build record br : build config set record . get build records ( ) ) { result result = delete temporary build ( br . get id ( ) , auth token ) ; if ( ! result . is success ( ) ) { return result ; } } build config set record repository . delete ( build config set record . get id ( ) ) ; log . info ( str , build config set record ) ; return new result ( build config set record id . to string ( ) , result . status . success ) ; }	Deletes a BuildConfigSetRecord and BuildRecords produced in the build.
@ override public build set task build ( build configuration audited build configuration audited , user user , build options build options ) throws build conflict exception { return build0 ( user , build options , build configuration audited ) ; }	Run a single build.
private void check for empty build set task ( build set task build set task ) { if ( build set task . get build tasks ( ) == null || build set task . get build tasks ( ) . is empty ( ) ) { update build set task status ( build set task , build set status . rejected , str ) ; } }	Check if the given build set task is empty and update the status message appropriately.
public environment driver get driver ( system image type system image type ) throws executor exception { for ( environment driver driver : available drivers ) { if ( driver . can run image type ( system image type ) ) return driver ; } throw new executor exception ( str + system image type + str ) ; }	Gets environment driver, which can manage requested environment.
public static predicate < build configuration > is not archived ( ) { return ( root , query , cb ) -> cb . is true ( root . get ( build configuration . active ) ) ; }	Return a predicate which excludes all archived build configurations.
private void load build configurations ( build configuration audited build config audited ) { project project = build config audited . get project ( ) ; project . get build configurations ( ) . for each ( build configuration :: get id ) ; }	Fetch build configurations of project to be able access it outside transaction.
private build record . builder init build record builder ( build task build task ) { build options build options = build task . get build options ( ) ; build record . builder builder = build record . builder . new builder ( ) . id ( build task . get id ( ) ) . build configuration audited ( build task . get build configuration audited ( ) ) . user ( build task . get user ( ) ) . submit time ( build task . get submit time ( ) ) . start time ( build task . get start time ( ) ) . product milestone ( build task . get product milestone ( ) ) . temporary build ( build options . is temporary build ( ) ) ; if ( build task . get end time ( ) == null ) { build task . set end time ( date . from ( instant . now ( ) ) ) ; } builder . end time ( build task . get end time ( ) ) ; if ( build task . get build config set record id ( ) != null ) { build config set record build config set record = datastore . get build config set record by id ( build task . get build config set record id ( ) ) ; builder . build config set record ( build config set record ) ; } list < integer > dependencies = build task . get dependencies ( ) . stream ( ) . map ( t -> t . get id ( ) ) . collect ( collectors . to list ( ) ) ; builder . dependency build record ids ( dependencies . to array ( new integer [ dependencies . size ( ) ] ) ) ; list < integer > dependants = build task . get dependants ( ) . stream ( ) . map ( t -> t . get id ( ) ) . collect ( collectors . to list ( ) ) ; builder . dependent build record ids ( dependants . to array ( new integer [ dependants . size ( ) ] ) ) ; return builder ; }	Initialize a new BuildRecord.Builder based on the data contained in the BuildTask.Note, this must be done inside a transaction because it fetches the BuildRecordSet entities fromthe database.
public static predicate < product version > with build configuration id ( integer build configuration id ) { return ( root , query , cb ) -> { set join < product version , build configuration > build configuration join = root . join ( product version . build configurations ) ; return cb . equal ( build configuration join . get ( build configuration . id ) , build configuration id ) ; } ; }	This predicate returns all the ProductVersions linked to a specified BuildConfiguration.
boolean is jenkins server secured with csrf ( string url ) throws build driver exception { try { jenkins build driver module config config = configuration . get module config ( new pnc config provider < jenkins build driver module config > ( jenkins build driver module config . class ) ) ; string username = config . get username ( ) ; string password = config . get password ( ) ; if ( url == null || username == null || password == null ) { throw new build driver exception ( str + jenkins build driver . driver id + str ) ; } try { jenkins http client jenkins http client = new jenkins http client ( new uri ( url ) , username , password ) ; try { jenkins http client . get ( str ) ; return bool ; } catch ( io e ) { return bool ; } } catch ( uri e ) { throw new build driver exception ( str + jenkins build driver . driver id + str + url , e ) ; } } catch ( configuration parse exception e ) { throw new build driver exception ( str + jenkins build driver . driver id + str , e ) ; } }	This checks if jenkins does not use option Prevent Cross Site Request Forgery exploitsmnovotny: TODO: see NCL-669 this method should be placed in producing JenkinsServer, but as CSRF is not propagatedout from JenkinsServer instance, we need to figure out the setting by special API call through JenkinsHttpClient.
private set < artifact > save artifacts ( collection < artifact > artifacts , map < string , target repository > repositories cache , map < artifact . identifier sha256 , artifact > artifact cache ) { logger . debug ( str , artifacts . size ( ) ) ; set < artifact > saved artifacts = new hash set < > ( ) ; set < artifact . identifier sha256 > artifact constraints = new hash set < > ( ) ; for ( artifact artifact : artifacts ) { artifact constraints . add ( new artifact . identifier sha256 ( artifact . get identifier ( ) , artifact . get sha256 ( ) ) ) ; } set < artifact > artifacts in db = null ; if ( artifact constraints . size ( ) > num ) { artifacts in db = artifact repository . with identifier and sha256s ( artifact constraints ) ; } if ( artifacts in db != null ) { for ( artifact artifact : artifacts in db ) { logger . trace ( str , artifact ) ; artifact cache . put ( artifact . get identifier sha256 ( ) , artifact ) ; } } for ( artifact artifact : artifacts ) { target repository target repository = artifact . get target repository ( ) ; link target repository ( repositories cache , artifact , target repository ) ; artifact artifact from db ; if ( repository type . generic proxy . equals ( target repository . get repository type ( ) ) ) { artifact from db = save http artifact ( artifact ) ; } else { artifact from db = get or save repository artifact ( artifact , artifact cache ) ; } saved artifacts . add ( artifact from db ) ; } logger . debug ( str , artifacts ) ; return saved artifacts ; }	Checks the given list against the existing database and creates a new list containingartifacts which have been saved to or loaded from the database.
@ override @ transaction attribute ( transaction attribute type . requires new ) public build config set record save build config set record ( build config set record build config set record ) { return build config set record repository . save ( build config set record ) ; }	Save a build config set record to the db.
@ override public set < build configuration > get build configurations ( build configuration set build configuration set ) { return new hash set < > ( build configuration repository . query with predicates ( with build configuration set id ( build configuration set . get id ( ) ) ) ) ; }	Rebuild is required if Build Configuration has been modified or a dependency has been rebuilt since last successful build.
private boolean has a ( build record latest successful build record , boolean temporary build ) { collection < build record > last built from = get records used for ( latest successful build record ) ; return last built from . stream ( ) . any match ( br -> has newer version ( br , temporary build ) ) ; }	Check is some of the dependencies from the previous build were rebuild.Checking is done based on captured dependencies which are stored in the Build Record.
private boolean has a ( build record latest successful build record , set < build configuration > dependencies , boolean temporary build ) { for ( build configuration dependency build configuration : dependencies ) { build record dependency latest successful build record = build record repository . get latest successful build record ( dependency build configuration . get id ( ) , temporary build ) ; if ( dependency latest successful build record == null ) { return bool ; } boolean newer = dependency latest successful build record . get end time ( ) . after ( latest successful build record . get end time ( ) ) ; if ( newer ) { return bool ; } } return bool ; }	Check is some of the dependencies defined on BuildConfiguration has newer version.
public < t extends bpm notification rest > void add listener ( bpm event type event type , consumer < t > listener ) { list < consumer < ? > > consumers = listeners . compute if absent ( event type , ( k ) -> new array list < > ( ) ) ; consumers . add ( listener ) ; }	Listen to notifications from BPM process for this task.
map < string , object > get extended process parameters ( ) throws core exception { serializable process parameters = get process parameters ( ) ; require non null ( process parameters ) ; map < string , object > actual parameters = new hash map < > ( ) ; try { actual parameters . put ( str , mapper . write value as string ( process parameters ) ) ; } catch ( json processing exception e ) { throw new core exception ( str + process parameters + str , e ) ; }	Extend process parameters from the task with additional useful information,such as pncBaseUrl and taskId, needed for notifications.Before use, taskId MUST be assigned.
private boolean collect dependent configurations ( build configuration build configuration , build configuration audited build configuration audited , set < build configuration audited > to build , set < build configuration > visited , boolean check implicit dependencies , boolean force rebuild , boolean temporary build ) { if ( visited . contains ( build configuration ) ) { return to build . contains ( build configuration audited ) ; } visited . add ( build configuration ) ; boolean requires rebuild = force rebuild || datastore adapter . requires rebuild ( build configuration audited , check implicit dependencies , temporary build ) ; for ( build configuration dependency : build configuration . get dependencies ( ) ) { boolean dependency requires rebuild = collect dependent configurations ( dependency , datastore adapter . get latest build configuration audited initialize bc ( dependency . get id ( ) ) , to build , visited , check implicit dependencies , force rebuild , temporary build ) ; requires rebuild = requires rebuild || dependency requires rebuild ; } log . debug ( str , build configuration . get id ( ) , requires rebuild ) ; if ( requires rebuild ) { to build . add ( build configuration audited ) ; } return requires rebuild ; }	Collects all BuildConfigurationAudited entities, that needs to be built.
public build set task create build set task ( build configuration set build configuration set , user user , build options build options , supplier < integer > build task id provider , set < build task > submitted build tasks ) throws core exception { return create build set task ( build configuration set , collections . empty map ( ) , user , build options , build task id provider , submitted build tasks ) ; }	Create a BuildSetTask of latest revisions of BuildConfigurations contained in the BuildConfigurationSet.
public build set task create build set task ( build configuration set build configuration set , map < integer , build configuration audited > build configuration auditeds map , user user , build options build options , supplier < integer > build task id provider , set < build task > submitted build tasks ) throws core exception { build set task build set task = init build set task ( build configuration set , user , build options ) ; set < build configuration audited > build configuration auditeds = new hash set < > ( ) ; for ( build configuration build configuration : datastore adapter . get build configurations ( build configuration set ) ) { build configuration audited build configuration audited = build configuration auditeds map . get ( build configuration . get id ( ) ) ; if ( build configuration audited == null ) { build configuration audited = datastore adapter . get latest build configuration audited initialize bc ( build configuration . get id ( ) ) ; } build configuration auditeds . add ( build configuration audited ) ; }	Create a BuildSetTask of BuildConfigurations contained in the BuildConfigurationSet.A specific revision of the BuildConfigurations contained in the set is used,if it's available in the buildConfigurationAuditedsMap parameter.If it's not available, latest revision of the BuildConfiguration is used.
private void fill build task set ( build set task build set task , user user , supplier < integer > build task id provider , product milestone product milestone , set < build configuration audited > to build , set < build task > already submitted build tasks , build options build options ) { for ( build configuration audited build config audited : to build ) { optional < build task > task optional = already submitted build tasks . stream ( ) . filter ( bt -> bt . get build configuration audited ( ) . equals ( build config audited ) ) . find any ( ) ; build task build task ; if ( task optional . is present ( ) ) { build task = task optional . get ( ) ; log . debug ( str , build config audited , build task ) ; } else { int build id = build task id provider . get ( ) ; string build content id = content identity manager . get build content id ( build id ) ; mdc . add build context ( build content id , build options . is temporary build ( ) , temporary build expire date ) ; build task = build task . build ( build config audited , build set task . get build options ( ) , user , build id , build set task , build set task . get start time ( ) , product milestone , build content id ) ; log . debug ( str , build task , build config audited ) ; } build set task . add build task ( build task ) ; }	Creates build tasks and sets up the appropriate dependency relations.
public collection info < artifact rest > get built artifacts for build record ( int page index , int page size , string sorting rsql , string query , int build record id ) { return query for collection ( page index , page size , sorting rsql , query , with build record id ( build record id ) ) ; }	Lookups built artifacts for the specified BuildRecord.
public static string add ending slash ( string string ) { if ( string == null ) { return null ; } if ( ! string . ends with ( str ) ) { string += str ; } return string ; }	Adds ending slash if it is not present.
public static integer [ ] deserialize int ( string string ) { if ( string == null ) { return new integer [ num ] ; } return arrays . stream ( string . split ( str ) ) . filter ( s -> ! s . equals ( str ) ) . map ( integer :: parse int ) . to array ( integer [ ] :: new ) ; }	Parse comma separated string to Integer array.
public static string serialize int ( integer [ ] integers ) { if ( integers == null ) { return str ; } return arrays . stream ( integers ) . map ( i -> integer . to string ( i ) ) . collect ( collectors . joining ( str ) ) ; }	Serialize Integer array to comma separated string.
public synchronized boolean add ready task ( build task task ) { if ( ! task . ready to build ( ) ) { throw new illegal argument exception ( str + task ) ; } unfinished tasks . add ( task ) ; log . debug ( str , task ) ; ready tasks . add ( task ) ; return bool ; }	Add a new, ready to build task to queue.
public synchronized void add waiting task ( build task task , runnable task ready callback ) { unfinished tasks . add ( task ) ; log . debug ( str , task ) ; waiting tasks with callbacks . put ( task , task ready callback ) ; }	Add a task that is waiting for dependencies.
public synchronized void execute new ready tasks ( ) { list < build task > new ready tasks = extract ready tasks ( ) ; log . debug ( str , new ready tasks ) ; ready tasks . add all ( new ready tasks ) ; }	Trigger searching for ready tasks in the waiting queue.This method should be invoked if one task has finished and there's a possibility that other tasks became ready to be built.
public synchronized optional < build task > get task ( build configuration audited build config audited ) { optional < build task > ready = ready tasks . stream ( ) . filter ( bt -> bt . get build configuration audited ( ) . equals ( build config audited ) ) . find any ( ) ; optional < build task > waiting = waiting tasks with callbacks . key set ( ) . stream ( ) . filter ( bt -> bt . get build configuration audited ( ) . equals ( build config audited ) ) . find any ( ) ; optional < build task > in progress = tasks in progress . stream ( ) . filter ( bt -> bt . get build configuration audited ( ) . equals ( build config audited ) ) . find any ( ) ; return ready . is present ( ) ? ready : waiting . is present ( ) ? waiting : in progress ; }	Get build task for given build configuration from the queue.
static boolean is trusted ( string artifact origin url , target repository target repository ) { if ( target repository . temporary repo ) { return bool ; } if ( artifact origin url == null || artifact origin url . is empty ( ) ) { return bool ; } for ( string trusted repo url : trusted repository urls ) { if ( artifact origin url . starts with ( trusted repo url ) ) { return bool ; } } return bool ; }	Check if a given artifact originates from a trusted source.
public build record add build record ( build record build record ) { get build records ( ) . add ( build record ) ; build record . set user ( this ) ; return build record ; }	Adds the project build record.
public build record remove build record ( build record build record ) { get build records ( ) . remove ( build record ) ; build record . set user ( null ) ; return build record ; }	Removes the project build record.
public boolean delete temporary build ( integer build record id , string auth token , consumer < result > on complete ) throws validation exception { build record build record = build record repository . find by id fetch all properties ( build record id ) ; if ( build record == null ) { return bool ; } if ( ! build record . is temporary build ( ) ) { throw new validation exception ( str ) ; } executor service . submit ( ( ) -> { try { result result = temporary builds cleaner . delete temporary build ( build record id , auth token ) ; on complete . accept ( result ) ; } catch ( validation exception e ) { logger . error ( str + build record id + str , e ) ; on complete . accept ( new result ( build record id . to string ( ) , result . status . failed , str ) ) ; } } ) ; return bool ; }	Deletes a single temporary build.
public set < build configuration > get all dependencies ( ) { set < build configuration > all dependencies = new hash set < build configuration > ( ) ; all dependencies . add all ( get dependencies ( ) ) ; all dependencies . add all ( get indirect dependencies ( ) ) ; return all dependencies ; }	Get the full set of both the direct and indirect dependencies.
private boolean add dependant ( build configuration dependant ) { boolean result = dependants . add ( dependant ) ; if ( ! dependant . get dependencies ( ) . contains ( this ) ) { dependant . add dependency ( this ) ; } return result ; }	This method is private because a dependant should never be added externally. Instead the dependency relation should beset up using the addDependency method.
private boolean remove dependant ( build configuration dependant ) { boolean result = dependants . remove ( dependant ) ; if ( dependant . get dependencies ( ) . contains ( this ) ) { dependant . remove dependency ( this ) ; } return result ; }	This method is private because a dependant should never be removed externally. Instead the dependency relation should beset up using the removeDependency method.
public static string retrieve clone name ( string bc name , date now ) { string bc name to append = str ; int index = bc name . index of ( str ) ; if ( index == - num ) {	Change the BC clone name into date_original-BC-name where date will be for every clone updated and for original BC nameswill be added.Example: clone1 of pslegr-BC on Wednesday October,21st, 2015: 20151021095415_pslegr-BCclone2 of 20151021095415_pslegr-BC on Thursday October,22nd, 2015: 20151022nnnnnn_pslegr-BCclone3 of pslegr-BC on Friday October,23rd, 2015: 20151023nnnnnn_pslegr-BC.
@ suppress warnings ( str ) public < t extends abstract module config > t get module config ( config provider < t > provider ) throws configuration parse exception { class < t > module class = provider . get type ( ) ; if ( config cache . contains key ( module class ) ) return ( t ) config cache . get ( module class ) ; synchronized ( this ) { if ( config cache . contains key ( module class ) ) { return ( t ) config cache . get ( module class ) ; } t config = configuration json parser . parse jsonpnc ( config string , provider ) ; config cache . put ( module class , config ) ; return config ; } }	Reads configuration for module.
private static embedded tomcat instantiate ( class < ? > klass ) { embedded tomcat configuration configuration = extract configuration ( klass ) ; return configuration == null ? new embedded tomcat ( ) : new embedded tomcat ( configuration ) ; }	Instantiate embedded tomcat to be used in tests.
private void unregister embedded server ( extension context context , boolean static mode ) { boolean registered as static = find in store ( context , server runner static mode ) ; if ( registered as static == static mode ) { try { embedded server runner server adapter = find embedded server adapter in store ( context ) ; server adapter . after all ( ) ; } finally { remove embedded server adapter from store ( context ) ; } } }	Stop and remove from the store the started embedded server.
@ suppress warnings ( str ) private static < t > void put in store ( extension context context , string name , t value ) { get store ( context ) . put ( name , value ) ; }	Put value in the internal store.
@ suppress warnings ( str ) private static < t > t find in store ( extension context context , string name ) { return ( t ) get store ( context ) . get ( name ) ; }	Find value in the internal store.
public static string concatenate path ( string path , string endpoint ) { string first segment = ensure absolute path ( path ) ; if ( endpoint == null || endpoint . is empty ( ) ) { return first segment ; } string builder sb = new string builder ( first segment ) ; if ( path . char at ( path . length ( ) - num ) != path separator ) { sb . append ( path separator ) ; } if ( endpoint . char at ( num ) == path separator ) { sb . append ( endpoint . substring ( num ) ) ; } else { sb . append ( endpoint ) ; } return sb . to string ( ) ; }	Concatenate two path value.
@ deprecated protected context create context ( ) throws exception { context context = null ; final string webapp = configuration . get webapp ( ) ; final string path = configuration . get path ( ) ; final string classpath = configuration . get classpath ( ) ; final boolean force meta inf = configuration . is force meta inf ( ) ; final class loader parent class loader = configuration . get parent classpath ( ) ; final string descriptor = configuration . get override descriptor ( ) ; file webapp directory = new file ( webapp ) ; if ( webapp directory . exists ( ) ) { string webapp absolute path = webapp directory . get absolute path ( ) ; tomcat . get host ( ) . set app base ( webapp absolute path ) ; context = tomcat . add webapp ( path , webapp absolute path ) ;	Create tomcat context.May be override by subclasses.
public static cookie read ( string raw value ) { not blank ( raw value , str ) ; final string [ ] parts = raw value . split ( field separator ) ;	Create a cookie from header value.
public static http header header ( string name , string value ) { return new http header ( name , singleton list ( value ) ) ; }	Create a header with a single value.
public static http header header ( string name , collection < string > values ) { return new http header ( name , values ) ; }	Create a header with multiple values.
private web app context created web app context ( ) throws exception { final string path = configuration . get path ( ) ; final string webapp = configuration . get webapp ( ) ; final string classpath = configuration . get classpath ( ) ; final class loader parent class loader = configuration . get parent class loader ( ) ; final string override descriptor = configuration . get override descriptor ( ) ; final resource base resource = configuration . get base resource ( ) ; final string container jar pattern = configuration . get container jar pattern ( ) ; final string web inf jar pattern = configuration . get web inf jar pattern ( ) ; web app context ctx = new web app context ( ) ; if ( container jar pattern != null ) { ctx . set attribute ( web inf configuration . container jar pattern , container jar pattern ) ; } else if ( java utils . is post jdk9 ( ) ) {	Build web app context used to launch server.May be override by subclasses.
private void exec hooks ( boolean pre ) { for ( hook hook : configuration . get hooks ( ) ) { if ( pre ) { hook . pre ( this ) ; } else { hook . post ( this ) ; } } }	Exec hooks phase.
private void process ( object target , boolean before ) { list < field > fields = find all fields ( target . get class ( ) ) ; for ( field field : fields ) { for ( annotation handler handler : handlers ) { process field ( target , handler , field , before ) ; } } }	Process handlers.
private void process field ( object target , annotation handler handler , field field , boolean before ) { for ( annotation annotation : field . get annotations ( ) ) { if ( handler . support ( annotation ) ) { if ( before ) { handler . before ( target , field ) ; } else { handler . after ( target , field ) ; } } } }	Process field for given handler.
@ deprecated public static apache http client new apache http client ( embedded server < ? > server , closeable http client client ) { return new apache http client ( http client configuration . default configuration ( ) , server , client ) ; }	Create new http client using internal with custom internal client.
public static apache http client default apache http client ( embedded server < ? > server ) { http client configuration configuration = http client configuration . default configuration ( ) ; return new apache http client ( configuration , server ) ; }	Create new http client using default internal client.
private void handle body ( http request base http request ) { if ( has body ( ) ) { http entity enclosing request base rq = ( http entity enclosing request base ) http request ; if ( ! form params . is empty ( ) ) { handle form parameters ( rq ) ; } else if ( body != null ) { handle request body ( rq ) ; } } }	Add request body.
private uri create request uri ( ) throws uri { uri uri = get endpoint ( ) . to uri ( ) ; uri builder = new uri ( uri ) . set charset ( standard charsets . utf 8 ) ; for ( http parameter parameter : query params . values ( ) ) { builder . add parameter ( parameter . get name ( ) , parameter . get value ( ) ) ; } return builder . build ( ) ; }	Create request URI.Each additional query parameters will be appended to final URI.
private void handle headers ( http request base http request ) { for ( http header header : headers . values ( ) ) { http request . add header ( header . get name ( ) , header . serialize values ( ) ) ; } }	Add headers to http request.
private void handle form parameters ( http entity enclosing request base http request ) { list < name value pair > pairs = map ( form params . values ( ) , param mapper ) ; http entity entity = new url encoded form entity ( pairs , charset . default charset ( ) ) ; http request . set entity ( entity ) ; }	Add parameters as form url encoded content.Each parameter is set as a key value entry to requestbody.
private void handle request body ( http entity enclosing request base http request ) { http entity entity = new string entity ( body , charset . default charset ( ) ) ; http request . set entity ( entity ) ; }	Set request body value to http request.
private void handle cookies ( http request base http request ) { if ( ! cookies . is empty ( ) ) { http request . add header ( cookie , cookies . serialize ( cookies ) ) ; } }	Add cookies to http request.
public static async http client default async http client ( embedded server < ? > server ) { http client configuration configuration = http client configuration . default configuration ( ) ; return new async http client ( configuration , server ) ; }	Create new http client using default internal http client.
private static int parse java version ( ) { string [ ] parts = java specification version . split ( str ) ; int nb parts = parts . length ; int major index = nb parts > num ? num : num ; return integer . parse int ( parts [ major index ] ) ; }	Parse java version.
public static < t , u > list < u > map ( collection < t > inputs , mapper < t , u > mapper ) { if ( inputs == null ) { return null ; } list < u > outputs = new array list < > ( inputs . size ( ) ) ; for ( t input : inputs ) { outputs . add ( mapper . apply ( input ) ) ; } return outputs ; }	Map input values to output values.
public static < t > list < t > concat ( list < t > inputs , t new value ) { list < t > outputs = new array list < > ( inputs . size ( ) + num ) ; outputs . add all ( inputs ) ; outputs . add ( new value ) ; return outputs ; }	Concat new value to existing inputs and returns new outputs.Note that input is not modified.
static < t > list < t > filter ( list < t > list , predicate < t > predicate ) { list < t > results = new array list < > ( ) ; for ( t current : list ) { if ( predicate . apply ( current ) ) { results . add ( current ) ; } } return results ; }	Filter input by using given predicate and returnfiltered outputs.
public static default http response of ( long duration , int status , string body , collection < http header > headers ) { return new default http response ( duration , status , body , headers ) ; }	Create a default HTTP Response from given values.
private static embedded jetty instantiate ( class < ? > klass ) { final embedded jetty configuration configuration = extract configuration ( klass ) ; return configuration == null ? new embedded jetty ( ) : new embedded jetty ( configuration ) ; }	Instantiate embedded jetty to be used in tests.
public static ok http client default ok http client ( embedded server < ? > server ) { http client configuration configuration = http client configuration . default configuration ( ) ; return new ok http client ( configuration , server ) ; }	Create new http client using internalhttp client from ok-http library.
@ deprecated public static ok http client new ok http client ( embedded server < ? > server , okhttp3 . ok http client client ) { return new ok http client ( http client configuration . default configuration ( ) , server , client ) ; }	Create new http client using custom internalhttp client from ok-http library.
public static list < field > find all fields ( class < ? > type ) { list < field > fields = new linked list < > ( ) ; if ( type != null ) { add all ( fields , type . get declared fields ( ) ) ; if ( type . get superclass ( ) != null ) { fields . add all ( find all fields ( type . get superclass ( ) ) ) ; } } return fields ; }	Get all fields on given object and look for fields ofsuper classes.
private static list < field > find static fields ( class < ? > type ) { return filter ( as list ( type . get declared fields ( ) ) , static field predicate ) ; }	Get all static fields on given class object.
private static list < method > find static methods ( class < ? > type ) { return filter ( as list ( type . get declared methods ( ) ) , static method predicate ) ; }	Get all static methods on given class object.
public static list < field > find static fields annotated with ( class < ? > type , class < ? extends annotation > klass ) { list < field > fields = find static fields ( type ) ; return filter ( fields , new field annotated with predicate ( klass ) ) ; }	Get all static fields on given class objectannotated with given annotation.
public static list < method > find static methods annotated with ( class < ? > type , class < ? extends annotation > klass ) { list < method > methods = find static methods ( type ) ; return filter ( methods , new method annotated with predicate ( klass ) ) ; }	Get all static methods on given class objectannotated with given annotation.
public static void setter ( object instance , field field , object value ) { boolean force access = bool ; try { if ( ! field . is accessible ( ) ) { force access = bool ; field . set accessible ( bool ) ; } field . set ( instance , value ) ; } catch ( illegal access exception ex ) { throw new reflection exception ( ex ) ; } finally { if ( force access ) { field . set accessible ( bool ) ; } } }	Set value of given field on given instance.
@ suppress warnings ( str ) public static < t > t getter ( object target , field field ) { boolean force access = bool ; try { if ( ! field . is accessible ( ) ) { field . set accessible ( bool ) ; force access = bool ; } return ( t ) field . get ( target ) ; } catch ( illegal access exception ex ) { throw new reflection exception ( ex ) ; } finally { if ( force access ) { field . set accessible ( bool ) ; } } }	Get value of field on target object.If target is null, it means that field is static and do notneed any target instance.
@ suppress warnings ( str ) public static < t > t invoke ( method method ) { boolean force access = bool ; try { if ( ! method . is accessible ( ) ) { method . set accessible ( bool ) ; force access = bool ; } return ( t ) method . invoke ( null ) ; } catch ( invocation target exception | illegal access exception ex ) { throw new reflection exception ( ex ) ; } finally { if ( force access ) { method . set accessible ( bool ) ; } } }	Invoke the static method without any arguments.
public static string format ( date date , string pattern ) { return df ( pattern ) . format ( date ) ; }	Format date according to given pattern.
static string format time ( long time , string pattern ) { date date = new date ( ) ; date . set time ( time ) ; return format ( date , pattern ) ; }	Format timestamp according to given pattern.
private void handle headers ( request . builder builder ) { for ( http header h : headers . values ( ) ) { builder . add header ( h . get name ( ) , h . serialize values ( ) ) ; } }	Add all HTTP headers to the final request.
static boolean is blank ( string value ) { if ( value == null ) { return bool ; } for ( char character : value . to char array ( ) ) { if ( ! character . is whitespace ( character ) ) { return bool ; } } return bool ; }	Check that given string is blank.
public static string remove prefix ( string value , string prefix ) { if ( value == null || prefix == null || prefix . length ( ) > value . length ( ) ) { return value ; } return value . starts with ( prefix ) ? value . substring ( prefix . length ( ) ) : value ; }	Remove string prefix if and only if string value starts withthe prefix, otherwise original string is returned.
public static string join ( string separator , collection < string > values ) { string builder builder = new string builder ( ) ; boolean first = bool ; for ( string value : values ) { if ( ! first ) { builder . append ( separator ) ; } builder . append ( value ) ; first = bool ; } return builder . to string ( ) ; }	Join all strings to a single one using given separator.
private void handle query parameters ( request builder builder ) { for ( http parameter p : query params . values ( ) ) { builder . add query param ( p . get encoded name ( ) , p . get encoded value ( ) ) ; } }	Add query parameter to the final HTTP request.
private void handle body ( request builder builder ) { if ( ! has body ( ) ) { return ; } if ( body != null ) { handle request body ( builder ) ; } else { handle form parameters ( builder ) ; } }	Add body entity to the final HTTP request.
private void handle form parameters ( request builder builder ) { for ( http parameter p : form params . values ( ) ) { builder . add form param ( p . get name ( ) , p . get value ( ) ) ; } }	Serialize form parameters to the request body.
private void handle cookies ( request builder builder ) { if ( ! cookies . is empty ( ) ) { builder . add header ( http headers . cookie , cookies . serialize ( cookies ) ) ; } }	Add cookies to the final HTTP request.
private void handle headers ( request builder builder ) { for ( http header header : headers . values ( ) ) { builder . add header ( header . get name ( ) , header . serialize values ( ) ) ; } }	Add request headers.
public to string builder append ( string name , map < ? , ? > map ) { string builder sb = new string builder ( start obj ) ; for ( map . entry < ? , ? > entry : map . entry set ( ) ) { sb . append ( entry . get key ( ) ) . append ( field value separator ) . append ( format value ( entry . get value ( ) ) ) ; } sb . append ( end obj ) ; return append formatted value ( name , sb . to string ( ) ) ; }	Append new map value.
public < t > to string builder append ( string name , iterable < t > values ) { string builder pending = new string builder ( ) . append ( open array ) ; boolean first item = bool ; for ( t value : values ) { if ( ! first item ) { pending . append ( separator ) ; } pending . append ( format value ( value ) ) ; first item = bool ; } return append formatted value ( name , pending . append ( close array ) . to string ( ) ) ; }	Append new boolean value.
private to string builder append formatted value ( string name , object value ) { if ( ! first ) { sb . append ( separator ) ; } sb . append ( name ) . append ( field value separator ) . append ( value ) ; first = bool ; return this ; }	Append formatted value to the final output.
protected sip get dialog from distributed cache ( string dialog id ) { if ( get stack logger ( ) . is logging enabled ( stack logger . trace debug ) ) { get stack logger ( ) . log debug ( str + this + str + dialog id + str ) ; }	Retrieve the dialog from the distributed cache.
protected void put dialog into distributed cache ( sip dialog ) { string dialog id = dialog . get dialog id ( ) ; if ( get stack logger ( ) . is logging enabled ( stack logger . trace debug ) ) { get stack logger ( ) . log debug ( str + this + str + dialog id + str ) ; }	Store the dialog into the distributed cache.
protected void remove dialog from distributed cache ( string dialog id ) { if ( get stack logger ( ) . is logging enabled ( stack logger . trace debug ) ) { get stack logger ( ) . log debug ( str + this + str + dialog id + str ) ; }	Remove the dialog from the distributed cache.
public void init after load ( clustered sip stack sip stack impl ) { string transport = get last response top most via ( ) . get transport ( ) ; iterator < sip provider impl > providers = sip stack impl . get sip providers ( ) ; boolean provider not found = bool ; while ( providers . has next ( ) ) { sip provider impl provider impl = providers . next ( ) ; if ( provider impl . get listening point ( transport ) != null ) { set sip provider ( provider impl ) ; provider not found = bool ; } } if ( provider not found ) { throw new runtime exception ( str + transport + str ) ; } set stack ( ( sip ) sip stack impl ) ; set assigned ( ) ; first transaction port = get sip provider ( ) . get listening point ( get last response top most via ( ) . get transport ( ) ) . get port ( ) ; ack processed = bool ;	Updates the local dialog transient attributes that were not serialized during the replication.
@ override public boolean add transaction ( sip transaction ) { if ( transaction instanceof server transaction ) { is latest tx server = bool ; } else { is latest tx server = bool ; } return super . add transaction ( transaction ) ; }	From and To Uris switch places in certain conditions.
public void print entry ( final entry entry ) throws io { if ( entry != null ) { final byte string buffer buffer = new byte string buffer ( ) ; entry . to ldif ( buffer , num ) ; if ( ! first ) { ldif output stream . write ( eol ) ; } else { first = bool ; } ldif output stream . write ( buffer . to byte array ( ) ) ; } }	Write the LDAP entry to the underlying output stream in LDIF format.
public final void load ( final ldap connection , final input stream input stream , final boolean ignore errors , final format logger logger ) { final format reader reader = open reader ( input stream , logger ) ; if ( reader != null ) { try { boolean keep reading = bool ; do { try { final ldif record = reader . next record ( ) ; if ( record == null ) { keep reading = bool ; } else { record . process change ( connection ) ; } } catch ( final ldif e ) { if ( ! ignore errors || ! e . may continue reading ( ) ) { logger . log error ( str , e ) ; keep reading = bool ; } } catch ( final ldap e ) { if ( ! ignore errors ) { logger . log error ( str , e ) ; keep reading = bool ; } } } while ( keep reading ) ; } catch ( final io e ) { logger . log error ( str , e ) ; } finally { try { reader . close ( ) ; } catch ( final io e ) { logger . log error ( str , e ) ; } } } }	Reads directory entries from the input stream and loads them in the LDAP directory server.
public final void dump ( final ldap connection , final string base , final string filter , final output stream output stream , final format logger logger ) { final format writer ldap writer = create writer ( output stream , logger ) ; if ( ldap writer == null ) { logger . log error ( str ) ; } else { try { try { final search request request = new search request ( base , search scope . sub , filter . create ( filter ) ) ; final search result result = connection . search ( request ) ; if ( result . get result code ( ) == result code . success ) { final list < search result entry > entries = result . get search entries ( ) ; if ( entries != null ) { for ( final search result entry entry : entries ) { ldap writer . print entry ( entry ) ; } } else { logger . log info ( str ) ; } } else { logger . log error ( str ) ; } } catch ( final ldap e ) { logger . log error ( str , e ) ; } finally { ldap writer . close ( ) ; } } catch ( final io e ) { logger . log error ( str , e ) ; } } }	Dump the results of a search against the LDAP directory server to an output stream.
public final void execute ( ) throws mojo execution exception { final file output file = new file ( output directory , filename ) ; if ( output directory . exists ( ) || output directory . mkdirs ( ) ) { try { final output stream output stream = new file output stream ( output file ) ; try { final ldap connection = connect ( ) ; try { final format handler handler = get format handler ( ) ; if ( handler != null ) { handler . dump ( connection , search base , search filter , output stream , this ) ; } } finally { connection . close ( ) ; } } finally { try { output stream . close ( ) ; } catch ( final io e ) { } } } catch ( final file not found exception e ) { } } }	Execute the plugin goal by dumping the matching directory entries to a file in the specified format.
@ override public void configure component ( final object component , final plexus configuration configuration , final expression evaluator expression evaluator , final class realm container realm , final configuration listener listener ) throws component configuration exception { final string server type = get server type ( configuration ) ; if ( ! server type . starts with ( str ) ) { add server dependencies to class realm ( server type , expression evaluator , container realm ) ; } converter lookup . register converter ( new class realm converter ( container realm ) ) ; final object with fields converter converter = new object with fields converter ( ) ; converter . process configuration ( converter lookup , component , container realm , configuration , expression evaluator , listener ) ; }	Configure the Mojo by adding the dependencies for the LDAP server type to the class loader.
private void add server dependencies to class realm ( final string server type , final expression evaluator expression evaluator , final class realm container realm ) throws component configuration exception { final collection < artifact > classpath elements = get server dependencies ( server type , expression evaluator ) ; if ( classpath elements != null ) { for ( final url url : build ur ( classpath elements ) ) { container realm . add url ( url ) ; } } }	Resolve the dependencies for an LDAP server type and add them to the class loader.
private list < url > build ur ( final collection < artifact > classpath elements ) throws component configuration exception { final list < url > urls = new array list < url > ( classpath elements . size ( ) ) ; for ( final artifact classpath element : classpath elements ) { try { final url url = classpath element . get file ( ) . to uri ( ) . to url ( ) ; urls . add ( url ) ; } catch ( final url e ) { throw new component configuration exception ( str + classpath element , e ) ; } } return urls ; }	Retrive the URLs used to locate the JAR files for a list of artifacts.
private collection < artifact > get server dependencies ( final string server type , final expression evaluator expression evaluator ) throws component configuration exception { try { final maven project project = ( maven project ) expression evaluator . evaluate ( str ) ; final string local repo = ( string ) expression evaluator . evaluate ( str ) ; final artifact repository local repository = repository system . create local repository ( new file ( local repo ) ) ; final repository request repository request = new default repository request ( ) ; repository request . set remote repositories ( project . get remote artifact repositories ( ) ) ; repository request . set local repository ( local repository ) ; final artifact resolution request request = new artifact resolution request ( repository request ) ; request . set artifact ( get server artifact ( server type ) ) ; request . set resolve transitively ( bool ) ; final artifact resolution result result = repository system . resolve ( request ) ; if ( result . is success ( ) ) { return result . get artifacts ( ) ; } boolean first = bool ; final string builder builder = new string builder ( str ) ; for ( final artifact artifact : result . get missing artifacts ( ) ) { if ( ! first ) { builder . append ( str ) ; } else { first = bool ; } builder . append ( artifact . get group id ( ) ) ; builder . append ( str ) ; builder . append ( artifact . get artifact id ( ) ) ; builder . append ( str ) ; builder . append ( artifact . get version ( ) ) ; } builder . append ( str ) ; throw new component configuration exception ( builder . to string ( ) ) ; } catch ( final expression evaluation exception e ) { throw new component configuration exception ( str , e ) ; } catch ( final invalid repository exception e ) { throw new component configuration exception ( str , e ) ; } }	Resolve the LDAP server type artifact and its dependencies.
private artifact get server artifact ( final string server type ) throws component configuration exception { if ( server type . starts with ( str ) ) { int index = server type . index of ( str , num ) ; if ( index > num ) { string [ ] gav = server type . substring ( index + num ) . split ( str ) ; if ( gav . length == num ) { return repository system . create artifact ( gav [ num ] , gav [ num ] , gav [ num ] , str , str ) ; } } throw new component configuration exception ( str + server type ) ; } else { return repository system . create artifact ( default group id , message format . format ( default artifact id format , server type ) , get class ( ) . get package ( ) . get implementation version ( ) , str , str ) ; } }	Get the artifact descriptor for the JAR file that implements support for the LDAP server type.
private string get server type ( final plexus configuration configuration ) { final pattern pattern = pattern . compile ( str ) ; for ( final plexus configuration cfg : configuration . get children ( ) ) { if ( cfg . get name ( ) . equals ( server type attribute ) ) { if ( pattern . matcher ( cfg . get value ( ) ) . matches ( ) ) { return default server type value ; } else { return cfg . get value ( ) ; } } } return default server type value ; }	Determine the configured LDAP server type.
@ override protected format writer create writer ( final output stream output stream , final format logger logger ) { try { return new dsml ( output stream ) ; } catch ( final io e ) { logger . log error ( str , e ) ; } return null ; }	Create the LDAP writer that will dump LDAP entries to a DSML file.
@ override protected format reader open reader ( final input stream input stream , final format logger logger ) { try { return new dsml ( input stream ) ; } catch ( final document exception e ) { logger . log error ( str , e ) ; } catch ( final jaxen exception e ) { logger . log error ( str , e ) ; } catch ( final io e ) { logger . log error ( str , e ) ; } return null ; }	Create the LDAP reader that will load LDAP entries from a DSML file.
@ override public void configure ( final string name , final object value , final logger logger ) { if ( root . equals ( name ) ) { if ( value instanceof string ) { root = ( string ) value ; logger . log info ( str + root ) ; } } else if ( object classes . equals ( name ) ) { if ( value instanceof string [ ] ) { object classes = ( string [ ] ) value ; logger . log info ( str + object classes ) ; } } else if ( auth dn . equals ( name ) ) { if ( value instanceof string ) { auth dn = ( string ) value ; logger . log info ( str + auth dn ) ; } } else if ( passwd . equals ( name ) ) { if ( value instanceof string ) { passwd = ( string ) value ; logger . log info ( str + passwd ) ; } } else if ( work dir . equals ( name ) ) { if ( value instanceof file ) { working directory = ( file ) value ; logger . log info ( str + working directory ) ; } } else if ( ldif file . equals ( name ) ) { if ( value instanceof file ) { ldif file = ( file ) value ; logger . log info ( str + ldif file ) ; } } else if ( ldap port . equals ( name ) ) { if ( value instanceof integer ) { server port = ( integer ) value ; logger . log info ( str + server port ) ; } } }	Used to configure the root DN of the LDAP directory, the working directory used by the directory service tostore the directory data, the LDIF file used to seed the directory or the TCP port number on which the serverwill listening for LDAP traffic.
@ override public void start ( final logger logger ) { try { logger . log info ( str ) ; final in memory listener config listener config = in memory listener config . create ldap ( str , get server port ( ) ) ; final in memory directory server config config = new in memory directory server config ( new dn ( get root ( ) ) ) ; config . set listener configs ( listener config ) ; if ( get auth dn ( ) != null ) { config . add additional bind credentials ( get auth dn ( ) , get passwd ( ) ) ; } server = new in memory directory server ( config ) ; string [ ] object classes = get object classes ( ) ; if ( object classes == null ) { object classes = default root object classes ; } server . add ( new entry ( get root ( ) , new attribute ( str , object classes ) ) ) ; if ( get ldif file ( ) != null ) { final input stream in = new file input stream ( get ldif file ( ) ) ; try { final ldif reader = new ldif ( in ) ; server . import from ldif ( bool , reader ) ; } finally { in . close ( ) ; } } server . start listening ( ) ; logger . log info ( str ) ; } catch ( final ldap e ) { e . print stack trace ( ) ; logger . log error ( str , e ) ; } catch ( final io e ) { e . print stack trace ( ) ; logger . log error ( str , e ) ; } }	Configure and start the embedded UnboundID server creating the root DN and loading the LDIF seed data.
@ override public void stop ( final logger logger ) { logger . log info ( str ) ; server . shut down ( bool ) ; logger . log info ( str ) ; }	Shutdown the the embedded UnboundID server.
public void execute ( ) throws mojo execution exception { if ( ! is skip ( ) ) { final ldap connection = connect ( ) ; try { for ( final source source : sources ) { try { get log ( ) . info ( str + source ) ; final format handler handler = get format handler ( source ) ; if ( handler == null ) { get log ( ) . warn ( str + source ) ; } else { final input stream input stream = source . open ( ) ; if ( input stream == null ) { if ( ! this . continue on error ) { throw new mojo execution exception ( str + source ) ; } else { get log ( ) . warn ( str + source ) ; } } else { try { handler . load ( connection , source . open ( ) , continue on error , this ) ; } finally { input stream . close ( ) ; } } } } catch ( final io e ) { if ( ! this . continue on error ) { throw new mojo execution exception ( str + source , e ) ; } else { this . get log ( ) . warn ( str + source , e ) ; } } } } finally { connection . close ( ) ; } } }	Execute the plugin goal iterating over the list of source files and loading the LDAP directory entries fromeach file using the appropriate handler.
@ override public void start ( final logger logger ) { try { logger . log info ( str ) ; service = new default directory service ( ) ; final list < interceptor > list = new array list < interceptor > ( ) ; list . add ( new normalization interceptor ( ) ) ; list . add ( new authentication interceptor ( ) ) ; list . add ( new referral interceptor ( ) ) ;	Configure and start the embedded ApacheDS server creating the root DN and loading the LDIF seed data.
@ override public void stop ( final logger logger ) { try { logger . log info ( str ) ; server . stop ( ) ; service . shutdown ( ) ; logger . log info ( str ) ; } catch ( final exception e ) { logger . log error ( str , e ) ; } }	Shutdown the the embedded ApacheDS server.
private void create root ( final partition partition ) throws exception { try { service . get admin session ( ) . lookup ( partition . get suffix dn ( ) ) ; } catch ( final ldap name not found exception e ) { final dn dn = new dn ( get root ( ) ) ; final string dc = get root ( ) . substring ( num , get root ( ) . index of ( str ) ) ; final server entry entry = service . new entry ( dn ) ; entry . add ( str , str , str , str ) ; entry . add ( str , dc ) ; service . get admin session ( ) . add ( entry ) ; } }	Create the root DN.
@ override public void start ( final logger logger ) { try { logger . log info ( str ) ; final memory backend backend ; if ( get ldif file ( ) == null ) { backend = new memory backend ( ) ; } else { final input stream input stream = new file input stream ( get ldif file ( ) ) ; final ldif reader = new ldif ( input stream ) ; backend = new memory backend ( reader ) ; } final server connection factory < ldap , integer > connection handler = connections . new server connection factory ( backend ) ; final ldap options = new ldap ( ) . set backlog ( num ) ; listener = new ldap ( str , get server port ( ) , connection handler , options ) ; logger . log info ( str ) ; } catch ( final io e ) { logger . log error ( str , e ) ; } }	Start the OpenDJ in-memory directory server.
@ override public void stop ( final logger logger ) { logger . log info ( str ) ; if ( listener != null ) { listener . close ( ) ; } logger . log info ( str ) ; }	Stop the OpenDJ in-memory directory server.
public void print entry ( final entry entry ) throws io { final byte string buffer buffer = new byte string buffer ( ) ; buffer . append ( str ) ; buffer . append ( entry . get dn ( ) ) ; buffer . append ( str ) ; buffer . append ( eol ) ; final string [ ] values = entry . get attribute values ( str ) ; if ( values != null ) { buffer . append ( str ) ; buffer . append ( eol ) ; for ( final string value : values ) { buffer . append ( str ) ; buffer . append ( value ) ; buffer . append ( str ) ; buffer . append ( eol ) ; } buffer . append ( str ) ; buffer . append ( eol ) ; } for ( final attribute attribute : entry . get attributes ( ) ) { final string name = attribute . get name ( ) ; if ( ! name . equals ( str ) ) { buffer . append ( str ) ; buffer . append ( name ) ; buffer . append ( str ) ; buffer . append ( eol ) ; for ( final string value : attribute . get values ( ) ) { buffer . append ( str ) ; buffer . append ( value ) ; buffer . append ( str ) ; buffer . append ( eol ) ; } buffer . append ( str ) ; buffer . append ( eol ) ; } } buffer . append ( str ) ; buffer . append ( eol ) ; ldif output stream . write ( buffer . to byte array ( ) ) ; }	Writes an individual LDAP directory entry to the DSML file.
@ override public string get server type ( ) { if ( server type . starts with ( str ) ) { return server type . substring ( num ) ; } if ( server type . starts with ( str ) ) { int index = server type . index of ( str , num ) ; if ( index > num ) { return server type . substring ( num , index ) ; } } return server type ; }	Get the server type.
@ override public map < string , object > get server config ( ) { final map < string , object > config = new hash map < string , object > ( ) ; config . put ( ldap . root , root dn ) ; if ( object classes != null ) { config . put ( ldap . object classes , object classes . split ( str ) ) ; } config . put ( ldap . work dir , new file ( output directory , server type ) ) ; if ( ldif file != null ) { config . put ( ldap . ldif file , ldif file ) ; } config . put ( ldap . ldap port , ldap port ) ; config . put ( ldap . auth dn , auth dn ) ; config . put ( ldap . passwd , passwd ) ; return config ; }	Get the embedded LDAP directory server configuration.
protected void send metric ( metric builder metric builder ) throws reporting exception { try { http client client = new http client ( str + this . server + str + this . port ) ; response response = client . push metrics ( metric builder ) ;	Sends a metric to the kairos server.
@ override public void report ( metric metric ) throws reporting exception { kairos metric converter kairos metric converter = new kairos metric converter ( ) ; try { kairos metric converter . add ( metric ) ; } catch ( kairos metric conversion exception e ) { throw new reporting exception ( e ) ; } this . send metric ( kairos metric converter . convert ( ) ) ; }	Report method. Converts the given metric to a metric kairos understands and sends them.
public static geometry type info read geometry type ( byte reader reader ) {	Read the geometry type info.
public static point read point ( byte reader reader , boolean has z , boolean has m ) { double x = reader . read double ( ) ; double y = reader . read double ( ) ; point point = new point ( has z , has m , x , y ) ; if ( has z ) { double z = reader . read double ( ) ; point . set z ( z ) ; } if ( has m ) { double m = reader . read double ( ) ; point . set m ( m ) ; } return point ; }	Read a Point.
public static line string read line string ( byte reader reader , boolean has z , boolean has m ) { line string line string = new line string ( has z , has m ) ; int num points = reader . read int ( ) ; for ( int i = num ; i < num points ; i ++ ) { point point = read point ( reader , has z , has m ) ; line string . add point ( point ) ; } return line string ; }	Read a Line String.
public static polygon read polygon ( byte reader reader , boolean has z , boolean has m ) { polygon polygon = new polygon ( has z , has m ) ; int num rings = reader . read int ( ) ; for ( int i = num ; i < num rings ; i ++ ) { line string ring = read line string ( reader , has z , has m ) ; polygon . add ring ( ring ) ; } return polygon ; }	Read a Polygon.
public static multi point read multi point ( byte reader reader , boolean has z , boolean has m ) { multi point multi point = new multi point ( has z , has m ) ; int num points = reader . read int ( ) ; for ( int i = num ; i < num points ; i ++ ) { point point = read geometry ( reader , point . class ) ; multi point . add point ( point ) ; } return multi point ; }	Read a Multi Point.
public static multi line string read multi line string ( byte reader reader , boolean has z , boolean has m ) { multi line string multi line string = new multi line string ( has z , has m ) ; int num line strings = reader . read int ( ) ; for ( int i = num ; i < num line strings ; i ++ ) { line string line string = read geometry ( reader , line string . class ) ; multi line string . add line string ( line string ) ; } return multi line string ; }	Read a Multi Line String.
public static multi polygon read multi polygon ( byte reader reader , boolean has z , boolean has m ) { multi polygon multi polygon = new multi polygon ( has z , has m ) ; int num polygons = reader . read int ( ) ; for ( int i = num ; i < num polygons ; i ++ ) { polygon polygon = read geometry ( reader , polygon . class ) ; multi polygon . add polygon ( polygon ) ; } return multi polygon ; }	Read a Multi Polygon.
public static geometry collection < geometry > read geometry collection ( byte reader reader , boolean has z , boolean has m ) { geometry collection < geometry > geometry collection = new geometry collection < geometry > ( has z , has m ) ; int num geometries = reader . read int ( ) ; for ( int i = num ; i < num geometries ; i ++ ) { geometry geometry = read geometry ( reader , geometry . class ) ; geometry collection . add geometry ( geometry ) ; } return geometry collection ; }	Read a Geometry Collection.
public static circular string read circular string ( byte reader reader , boolean has z , boolean has m ) { circular string circular string = new circular string ( has z , has m ) ; int num points = reader . read int ( ) ; for ( int i = num ; i < num points ; i ++ ) { point point = read point ( reader , has z , has m ) ; circular string . add point ( point ) ; } return circular string ; }	Read a Circular String.
public static compound curve read compound curve ( byte reader reader , boolean has z , boolean has m ) { compound curve compound curve = new compound curve ( has z , has m ) ; int num line strings = reader . read int ( ) ; for ( int i = num ; i < num line strings ; i ++ ) { line string line string = read geometry ( reader , line string . class ) ; compound curve . add line string ( line string ) ; } return compound curve ; }	Read a Compound Curve.
public static curve polygon < curve > read curve polygon ( byte reader reader , boolean has z , boolean has m ) { curve polygon < curve > curve polygon = new curve polygon < curve > ( has z , has m ) ; int num rings = reader . read int ( ) ; for ( int i = num ; i < num rings ; i ++ ) { curve ring = read geometry ( reader , curve . class ) ; curve polygon . add ring ( ring ) ; } return curve polygon ; }	Read a Curve Polygon.
public static polyhedral surface read polyhedral surface ( byte reader reader , boolean has z , boolean has m ) { polyhedral surface polyhedral surface = new polyhedral surface ( has z , has m ) ; int num polygons = reader . read int ( ) ; for ( int i = num ; i < num polygons ; i ++ ) { polygon polygon = read geometry ( reader , polygon . class ) ; polyhedral surface . add polygon ( polygon ) ; } return polyhedral surface ; }	Read a Polyhedral Surface.
public static tin read tin ( byte reader reader , boolean has z , boolean has m ) { tin tin = new tin ( has z , has m ) ; int num polygons = reader . read int ( ) ; for ( int i = num ; i < num polygons ; i ++ ) { polygon polygon = read geometry ( reader , polygon . class ) ; tin . add polygon ( polygon ) ; } return tin ; }	Read a TIN.
public static triangle read triangle ( byte reader reader , boolean has z , boolean has m ) { triangle triangle = new triangle ( has z , has m ) ; int num rings = reader . read int ( ) ; for ( int i = num ; i < num rings ; i ++ ) { line string ring = read line string ( reader , has z , has m ) ; triangle . add ring ( ring ) ; } return triangle ; }	Read a Triangle.
public static void write geometry ( byte writer writer , geometry geometry ) throws io {	Write a geometry to the byte writer.
public static void write point ( byte writer writer , point point ) throws io { writer . write double ( point . get x ( ) ) ; writer . write double ( point . get y ( ) ) ; if ( point . has z ( ) ) { writer . write double ( point . get z ( ) ) ; } if ( point . has m ( ) ) { writer . write double ( point . get m ( ) ) ; } }	Write a Point.
public static void write line string ( byte writer writer , line string line string ) throws io { writer . write int ( line string . num points ( ) ) ; for ( point point : line string . get points ( ) ) { write point ( writer , point ) ; } }	Write a Line String.
public static void write polygon ( byte writer writer , polygon polygon ) throws io { writer . write int ( polygon . num rings ( ) ) ; for ( line string ring : polygon . get rings ( ) ) { write line string ( writer , ring ) ; } }	Write a Polygon.
public static void write multi point ( byte writer writer , multi point multi point ) throws io { writer . write int ( multi point . num points ( ) ) ; for ( point point : multi point . get points ( ) ) { write geometry ( writer , point ) ; } }	Write a Multi Point.
public static void write multi line string ( byte writer writer , multi line string multi line string ) throws io { writer . write int ( multi line string . num line strings ( ) ) ; for ( line string line string : multi line string . get line strings ( ) ) { write geometry ( writer , line string ) ; } }	Write a Multi Line String.
public static void write multi polygon ( byte writer writer , multi polygon multi polygon ) throws io { writer . write int ( multi polygon . num polygons ( ) ) ; for ( polygon polygon : multi polygon . get polygons ( ) ) { write geometry ( writer , polygon ) ; } }	Write a Multi Polygon.
public static void write geometry collection ( byte writer writer , geometry collection < ? > geometry collection ) throws io { writer . write int ( geometry collection . num geometries ( ) ) ; for ( geometry geometry : geometry collection . get geometries ( ) ) { write geometry ( writer , geometry ) ; } }	Write a Geometry Collection.
public static void write circular string ( byte writer writer , circular string circular string ) throws io { writer . write int ( circular string . num points ( ) ) ; for ( point point : circular string . get points ( ) ) { write point ( writer , point ) ; } }	Write a Circular String.
public static void write compound curve ( byte writer writer , compound curve compound curve ) throws io { writer . write int ( compound curve . num line strings ( ) ) ; for ( line string line string : compound curve . get line strings ( ) ) { write geometry ( writer , line string ) ; } }	Write a Compound Curve.
public static void write curve polygon ( byte writer writer , curve polygon < ? > curve polygon ) throws io { writer . write int ( curve polygon . num rings ( ) ) ; for ( curve ring : curve polygon . get rings ( ) ) { write geometry ( writer , ring ) ; } }	Write a Curve Polygon.
public static void write polyhedral surface ( byte writer writer , polyhedral surface polyhedral surface ) throws io { writer . write int ( polyhedral surface . num polygons ( ) ) ; for ( polygon polygon : polyhedral surface . get polygons ( ) ) { write geometry ( writer , polygon ) ; } }	Write a Polyhedral Surface.
public static void write tin ( byte writer writer , tin tin ) throws io { writer . write int ( tin . num polygons ( ) ) ; for ( polygon polygon : tin . get polygons ( ) ) { write geometry ( writer , polygon ) ; } }	Write a TIN.
public static void write triangle ( byte writer writer , triangle triangle ) throws io { writer . write int ( triangle . num rings ( ) ) ; for ( line string ring : triangle . get rings ( ) ) { write line string ( writer , ring ) ; } }	Write a Triangle.
public static int get code ( geometry geometry ) { int code = get code ( geometry . get geometry type ( ) ) ; if ( geometry . has z ( ) ) { code += num ; } if ( geometry . has m ( ) ) { code += num ; } return code ; }	Get the geometry code from the geometry.
public static int get code ( geometry type geometry type ) { int code ; switch ( geometry type ) { case geometry : code = num ; break ; case point : code = num ; break ; case linestring : code = num ; break ; case polygon : code = num ; break ; case multipoint : code = num ; break ; case multilinestring : code = num ; break ; case multipolygon : code = num ; break ; case geometrycollection : code = num ; break ; case circularstring : code = num ; break ; case compoundcurve : code = num ; break ; case curvepolygon : code = num ; break ; case multicurve : code = num ; break ; case multisurface : code = num ; break ; case curve : code = num ; break ; case surface : code = num ; break ; case polyhedralsurface : code = num ; break ; case tin : code = num ; break ; case triangle : code = num ; break ; default : throw new sf ( str + geometry type ) ; } return code ; }	Get the geometry code from the geometry type.
public static geometry type get geometry type ( int code ) {	Get the Geometry Type from the code.
@ override public boolean exists ( ) {	This implementation checks whether a File can be opened,falling back to whether an InputStream can be opened.This will cover both directories and content resources.
public static long gcd ( list < long > l ) { if ( l . is empty ( ) ) { throw new illegal argument exception ( str ) ; } big integer gcd = big integer . value of ( l . get ( num ) ) ; for ( long num : l . sub list ( num , l . size ( ) ) ) { gcd = gcd . gcd ( big integer . value of ( num ) ) ; } return gcd . long value ( ) ; }	Finds the greatest common divisor of all numbers in the list.
@ nonnull public static string abbreviate ( string str , int max ) { if ( str == null ) { return str ; } else if ( str . length ( ) <= max ) { return str ; } else { return str . substring ( num , max - num ) + str ; } }	Abbreviates a String using ellipses.
public static org . jmxtrans . agent . util . json . json value value ( string string ) { return string == null ? null : new json string ( string ) ; }	Returns a JsonValue instance that represents the given string.
public static org . jmxtrans . agent . util . json . json object object ( ) { return new org . jmxtrans . agent . util . json . json object ( ) ; }	Creates a new empty JsonObject.
public static org . jmxtrans . agent . util . json . json value parse ( string string ) { if ( string == null ) { throw new null pointer exception ( str ) ; } default handler handler = new default handler ( ) ; new json parser ( handler ) . parse ( string ) ; return handler . get value ( ) ; }	Parses the given input string as JSON.
public static string get string ( map < string , string > settings , string name , string default value ) { if ( settings . contains key ( name ) ) { return settings . get ( name ) ; } else { return default value ; } }	Return the value of the given property.If the property is not found, the defaultValue is returned.
@ deprecated public static json object read from ( string string ) { return org . jmxtrans . agent . util . json . json value . read from ( string ) . as object ( ) ; }	Reads a JSON object from the given string.
public org . jmxtrans . agent . util . json . json value get ( string name ) { if ( name == null ) { throw new null pointer exception ( str ) ; } int index = index of ( name ) ; return index != - num ? values . get ( index ) : null ; }	Returns the value of the member with the specified name in this object.
public iterator < member > iterator ( ) { final iterator < string > names iterator = names . iterator ( ) ; final iterator < org . jmxtrans . agent . util . json . json value > values iterator = values . iterator ( ) ; return new iterator < json object . member > ( ) { public boolean has next ( ) { return names iterator . has next ( ) ; } public member next ( ) { string name = names iterator . next ( ) ; org . jmxtrans . agent . util . json . json value value = values iterator . next ( ) ; return new member ( name , value ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }	Returns an iterator over the members of this object in document order.
protected string resolve placeholder ( string property , string default value ) throws illegal state exception {	Search for the given placeholder in system properties then in environment variables.
@ nonnull public static string get version info ( ) { package pkg = jmx trans agent . class . get package ( ) ; if ( pkg == null ) { return str ; } else { return pkg . get implementation title ( ) + str + pkg . get implementation version ( ) ; } }	Human readable name and version.
@ deprecated public static json array read from ( string string ) { return org . jmxtrans . agent . util . json . json value . read from ( string ) . as array ( ) ; }	Reads a JSON array from the given string.
public json array add ( org . jmxtrans . agent . util . json . json value value ) { if ( value == null ) { throw new null pointer exception ( str ) ; } values . add ( value ) ; return this ; }	Appends the specified JSON value to the end of this array.
public json array set ( int index , org . jmxtrans . agent . util . json . json value value ) { if ( value == null ) { throw new null pointer exception ( str ) ; } values . set ( index , value ) ; return this ; }	Replaces the element at the specified position in this array with the specified JSON value.
public org . jmxtrans . agent . util . json . json value get ( int index ) { return values . get ( index ) ; }	Returns the value of the element at the specified position in this array.
public list < org . jmxtrans . agent . util . json . json value > values ( ) { return collections . unmodifiable list ( values ) ; }	Returns a list of the values in this array in document order.
public iterator < org . jmxtrans . agent . util . json . json value > iterator ( ) { final iterator < org . jmxtrans . agent . util . json . json value > iterator = values . iterator ( ) ; return new iterator < org . jmxtrans . agent . util . json . json value > ( ) { public boolean has next ( ) { return iterator . has next ( ) ; } public org . jmxtrans . agent . util . json . json value next ( ) { return iterator . next ( ) ; } public void remove ( ) { throw new unsupported operation exception ( ) ; } } ; }	Returns an iterator over the values of this array in document order.
private void process event ( final object event ) { system . out . println ( str + event . to string ( ) ) ; for ( final event handler handler : get consumers for ( event . get class ( ) ) ) { event executor . execute ( new runnable ( ) { @ override public void run ( ) { try { handler . handle ( event ) ; } catch ( exception e ) { e . print stack trace ( ) ; if ( should re raise on error ) { system . out . println ( str + event . to string ( ) ) ; event queue . publish ( event ) ; } } } } ) ; } }	Runs each appropriate EventHandler in an Executor.
private void publish event ( object event ) { assert ( has event busses ( ) ) ; for ( event bus event bus : event busses . values ( ) ) { event bus . publish ( event ) ; } }	Raise an event on all event busses, passing it to applicable consumers asynchronously.
private void publish event ( string name , object event ) { assert ( has event busses ( ) ) ; event bus event bus = get event bus ( name ) ; if ( event bus == null ) { throw new runtime exception ( str + name ) ; } event bus . publish ( event ) ; }	Raise an event on a named event bus, passing it to applicable consumers asynchronously.
public void remove child ( final string child ) { final string builder html middle sb = get html middle sb ( ) ; final string sb = html middle sb . to string ( ) ; final string replaced = sb . replace ( child , str ) ; final int last index = html middle sb . length ( ) - num ; html middle sb . delete ( num , last index ) ; html middle sb . append ( replaced ) ; }	removes the the child content.
private void add in wff id map ( final abstract html tag ) { final deque < set < abstract html > > children stack = new array deque < > ( ) ;	adds to wffid map.
protected boolean add to attribute value map ( final string key , final string value ) { final collection < abstract html5 shared object > shared objects = get shared objects ( ) ; boolean listener invoked = bool ; final collection < write lock > write locks = lock and get write locks ( ) ; try { final map < string , string > attribute value map = get attribute value map ( ) ; final string previous value = attribute value map . put ( key , value ) ; if ( ! objects . equals ( previous value , value ) ) { set modified ( bool ) ; invoke value change listeners ( shared objects ) ; listener invoked = bool ; } } finally { for ( final lock lock : write locks ) { lock . unlock ( ) ; } } push queues ( shared objects , listener invoked ) ; return listener invoked ; }	adds the given key value.
private void invoke value change listeners ( final collection < abstract html5 shared object > shared objects ) { for ( final abstract html5 shared object shared object : shared objects ) { final attribute value change listener value change listener = shared object . get value change listener ( access object ) ; if ( value change listener != null ) {	this method should be called after changing of attribute value not beforechanging value.
protected boolean add all to attribute value map ( final map < string , string > map ) { if ( map != null && map . size ( ) > num ) { final collection < abstract html5 shared object > shared objects = get shared objects ( ) ; boolean listener invoked = bool ; final collection < write lock > write locks = lock and get write locks ( ) ; try { get attribute value map ( ) . put all ( map ) ; set modified ( bool ) ; invoke value change listeners ( shared objects ) ; listener invoked = bool ; } finally { for ( final lock lock : write locks ) { lock . unlock ( ) ; } } push queues ( shared objects , listener invoked ) ; return listener invoked ; } return bool ; }	adds all to the attribute value map.
protected boolean remove from attribute value map by keys ( final string ... keys ) { final collection < abstract html5 shared object > shared objects = get shared objects ( ) ; boolean listener invoked = bool ; final collection < write lock > write locks = lock and get write locks ( ) ; boolean result = bool ; try { final map < string , string > value map = get attribute value map ( ) ; if ( nullable attr value map value ) { for ( final string key : keys ) { result = value map . contains key ( key ) ; if ( result ) { break ; } } } for ( final string key : keys ) { final string previous = value map . remove ( key ) ; if ( previous != null ) { result = bool ; } } if ( result ) { set modified ( bool ) ; invoke value change listeners ( shared objects ) ; listener invoked = bool ; } } finally { for ( final lock lock : write locks ) { lock . unlock ( ) ; } } push queues ( shared objects , listener invoked ) ; return result ; }	removes the key value for the input key.
private void push queues ( final collection < abstract html5 shared object > shared objects , final boolean listener invoked ) { if ( listener invoked ) { for ( final abstract html5 shared object shared object : shared objects ) { final push queue push queue = shared object . get push queue ( access object ) ; if ( push queue != null ) { push queue . push ( ) ; } } } }	pushes PushQueue from all shared object of parent tags.
protected boolean remove from attribute value map ( final string key , final string value ) { final collection < abstract html5 shared object > shared objects = get shared objects ( ) ; final collection < write lock > write locks = lock and get write locks ( ) ; boolean listener invoked = bool ; try { final boolean removed = get attribute value map ( ) . remove ( key , value ) ; if ( removed ) { set modified ( bool ) ; invoke value change listeners ( shared objects ) ; listener invoked = bool ; } } finally { for ( final lock lock : write locks ) { lock . unlock ( ) ; } } push queues ( shared objects , listener invoked ) ; return listener invoked ; }	removes only if the key and value matches in the map for any particularentry.
protected boolean add to attribute value set ( final string value ) { final collection < abstract html5 shared object > shared objects = get shared objects ( ) ; boolean listener invoked = bool ; final collection < write lock > write locks = lock and get write locks ( ) ; try { final boolean added = get attribute value set ( ) . add ( value ) ; if ( added ) { set modified ( bool ) ; invoke value change listeners ( shared objects ) ; listener invoked = bool ; } } finally { for ( final lock lock : write locks ) { lock . unlock ( ) ; } } push queues ( shared objects , listener invoked ) ; return listener invoked ; }	adds to the attribute value set.
protected void add all to attribute value set ( final collection < string > values ) { if ( values != null ) { final collection < abstract html5 shared object > shared objects = get shared objects ( ) ; boolean listener invoked = bool ; final collection < write lock > write locks = lock and get write locks ( ) ; try { final boolean added = get attribute value set ( ) . add all ( values ) ; if ( added ) { set modified ( bool ) ; invoke value change listeners ( shared objects ) ; listener invoked = bool ; } } finally { for ( final lock lock : write locks ) { lock . unlock ( ) ; } } push queues ( shared objects , listener invoked ) ; } }	adds all to the attribute value set.
protected void remove all from attribute value set ( final collection < string > values ) { final collection < abstract html5 shared object > shared objects = get shared objects ( ) ; boolean listener invoked = bool ; final collection < write lock > write locks = lock and get write locks ( ) ; try { final boolean removed all = get attribute value set ( ) . remove all ( values ) ; if ( removed all ) { set modified ( bool ) ; invoke value change listeners ( shared objects ) ; listener invoked = bool ; } } finally { for ( final lock lock : write locks ) { lock . unlock ( ) ; } } push queues ( shared objects , listener invoked ) ; }	removes the value from the the attribute set.
protected void remove all from attribute value set ( ) { final collection < abstract html5 shared object > shared objects = get shared objects ( ) ; boolean listener invoked = bool ; final collection < write lock > write locks = lock and get write locks ( ) ; try { get attribute value set ( ) . clear ( ) ; set modified ( bool ) ; invoke value change listeners ( shared objects ) ; listener invoked = bool ; } finally { for ( final lock lock : write locks ) { lock . unlock ( ) ; } } push queues ( shared objects , listener invoked ) ; }	clears all values from the value set.
public void add value change listener ( final attribute value change listener value change listener ) { if ( value change listeners == null ) { synchronized ( this ) { if ( value change listeners == null ) { value change listeners = new linked hash set < > ( ) ; } } } value change listeners . add ( value change listener ) ; }	adds value change lister which will be invoked when the value changed.
public boolean contains valid reg ex ( ) { try { java . util . regex . pattern . compile ( super . get attribute value ( ) ) ; return bool ; } catch ( final pattern syntax exception e ) {	checks the value in this attribute contains a valid regex.
public void set r ( final int r ) { if ( r < num || r > num ) { throw new invalid value exception ( str ) ; } this . r = r ; rgba = str + r + str + g + str + b + str + a + str ; if ( get state change informer ( ) != null ) { get state change informer ( ) . state changed ( this ) ; } }	to set the red value which is in between 0 to 255.
public void set g ( final int g ) { if ( g < num || g > num ) { throw new invalid value exception ( str ) ; } this . g = g ; rgba = str + r + str + g + str + b + str + a + str ; if ( get state change informer ( ) != null ) { get state change informer ( ) . state changed ( this ) ; } }	to set the green value which is in between 0 to 255.
public void set b ( final int b ) { if ( b < num || b > num ) { throw new invalid value exception ( str ) ; } this . b = b ; rgba = str + r + str + g + str + b + str + a + str ; if ( get state change informer ( ) != null ) { get state change informer ( ) . state changed ( this ) ; } }	to set the blue value which is in between 0 to 255.
public void set a ( final float a ) { if ( a < num || a > num ) { throw new invalid value exception ( str ) ; } this . a = a ; rgba = str + r + str + g + str + b + str + a + str ; if ( get state change informer ( ) != null ) { get state change informer ( ) . state changed ( this ) ; } }	to set alpha. The default value is 0.
public static void load all tag classes ( ) { final map < string , class < ? > > unloaded classes = new hash map < > ( ) ; for ( final entry < string , class < ? > > entry : tag class by tag name tmp . entry set ( ) ) { try { class . for name ( entry . get value ( ) . get name ( ) ) ; } catch ( final class not found exception e ) { unloaded classes . put ( entry . get key ( ) , entry . get value ( ) ) ; if ( logger . is loggable ( level . warning ) ) { logger . warning ( str + entry . get value ( ) . get name ( ) ) ; } } } tag class by tag name tmp . clear ( ) ; if ( unloaded classes . size ( ) > num ) { tag class by tag name tmp . put all ( unloaded classes ) ; } else { tag class by tag name tmp = null ; } }	Loads all tag classes.
public static string get first substring ( final string input string , final string starting with , final string ending with ) { if ( ! input string . contains ( starting with ) || ! input string . contains ( ending with ) ) { return null ; } final int start index = input string . index of ( starting with ) ; if ( ! ( ( start index + num ) < input string . length ( ) ) ) { return null ; } final int end index = input string . index of ( ending with , start index + num ) + num ; if ( start index > end index || start index < num || end index < num ) { return null ; } return input string . substring ( start index , end index ) ; }	gets the first substring which starts and ends with the given values.
public static string [ ] clone array ( final string [ ] input array ) { final string [ ] array = new string [ input array . length ] ; system . arraycopy ( input array , num , array , num , input array . length ) ; return array ; }	To make the clone copy of the given String array.
public static boolean contains whitespace ( final string string ) { for ( int i = num ; i < string . length ( ) ; i ++ ) { if ( character . is whitespace ( string . char at ( i ) ) ) { return bool ; } } return bool ; }	Checks if the given string contains whitespace.
public static string strip ( final string s ) { int first ; int last ; for ( first = num ; first < s . length ( ) ; first ++ ) { if ( ! character . is whitespace ( s . char at ( first ) ) ) { break ; } } for ( last = s . length ( ) ; last > first ; last -- ) { if ( ! character . is whitespace ( s . char at ( last - num ) ) ) { break ; } } return s . substring ( first , last ) ; }	Removes the trailing and leading whitespaces.
public void remove all children ( ) { boolean listener invoked = bool ; final lock lock = shared object . get lock ( access object ) . write lock ( ) ; try { lock . lock ( ) ; final abstract html [ ] removed abstract htmls = children . to array ( new abstract html [ children . size ( ) ] ) ; children . clear ( ) ; init new shared object in all nested tags and set super parent null ( removed abstract htmls ) ; final child tag remove listener listener = shared object . get child tag remove listener ( access object ) ; if ( listener != null ) { listener . all children removed ( new child tag remove listener . event ( this , removed abstract htmls ) ) ; listener invoked = bool ; } } finally { lock . unlock ( ) ; } if ( listener invoked ) { final push queue push queue = shared object . get push queue ( access object ) ; if ( push queue != null ) { push queue . push ( ) ; } } }	Removes all children from this tag.
protected void add inner htmls ( final boolean update client , final abstract html ... inner htmls ) { boolean listener invoked = bool ; final lock lock = shared object . get lock ( access object ) . write lock ( ) ; try { lock . lock ( ) ; final abstract html [ ] removed abstract htmls = children . to array ( new abstract html [ children . size ( ) ] ) ; children . clear ( ) ; init new shared object in all nested tags and set super parent null ( removed abstract htmls ) ; final inner html add listener listener = shared object . get inner html add listener ( access object ) ; if ( listener != null && update client ) { final inner html add listener . event [ ] events = new inner html add listener . event [ inner htmls . length ] ; int index = num ; for ( final abstract html inner html : inner htmls ) { abstract html previous parent tag = null ; if ( inner html . parent != null && inner html . parent . shared object == shared object ) { previous parent tag = inner html . parent ; } add child ( inner html , bool ) ; events [ index ] = new inner html add listener . event ( this , inner html , previous parent tag ) ; index ++ ; } listener . inner htmls added ( this , events ) ; listener invoked = bool ; } else { for ( final abstract html inner html : inner htmls ) { add child ( inner html , bool ) ; } } } finally { lock . unlock ( ) ; } if ( listener invoked ) { final push queue push queue = shared object . get push queue ( access object ) ; if ( push queue != null ) { push queue . push ( ) ; } } }	Removes all children and adds the given tags as children.
public boolean remove children ( final collection < abstract html > children ) { final lock lock = shared object . get lock ( access object ) . write lock ( ) ; boolean result = bool ; try { lock . lock ( ) ; result = this . children . remove all ( children ) ; } finally { lock . unlock ( ) ; } final push queue push queue = shared object . get push queue ( access object ) ; if ( push queue != null ) { push queue . push ( ) ; } return result ; }	Removes the given tags from its children tags.
public boolean remove child ( final abstract html child ) { boolean listener invoked = bool ; final lock lock = shared object . get lock ( access object ) . write lock ( ) ; boolean removed = bool ; try { lock . lock ( ) ; removed = children . remove ( child ) ; if ( removed ) {	Removes the given tag from its children only if the given tag is a childof this tag.
public void append children ( final collection < abstract html > children ) { boolean listener invoked = bool ; final lock lock = shared object . get lock ( access object ) . write lock ( ) ; try { lock . lock ( ) ; final collection < child moved event > moved or appended = new array deque < > ( children . size ( ) ) ; for ( final abstract html child : children ) { final abstract html previous parent = child . parent ; add child ( child , bool ) ; final child moved event event = new child moved event ( previous parent , this , child ) ; moved or appended . add ( event ) ; } final child tag append listener listener = shared object . get child tag append listener ( access object ) ; if ( listener != null ) { listener . childrend appended or moved ( moved or appended ) ; listener invoked = bool ; } } finally { lock . unlock ( ) ; } if ( listener invoked ) { final push queue push queue = shared object . get push queue ( access object ) ; if ( push queue != null ) { push queue . push ( ) ; } } }	adds the given children to the last position of the current children ofthis object.
private void init attributes ( final abstract attribute ... attributes ) { if ( attributes == null || attributes . length == num ) { return ; }	initializes attributes in this.attributes and also in attributesMap.
public abstract attribute get attribute by name ( final string attribute name ) { final lock lock = shared object . get lock ( access object ) . read lock ( ) ; abstract attribute result = null ; try { lock . lock ( ) ; if ( attributes map != null ) { result = attributes map . get ( attribute name ) ; } } finally { lock . unlock ( ) ; } return result ; }	gets the attribute by attribute name.
private void mark owner tag ( final abstract attribute [ ] attributes ) { if ( attributes == null ) { return ; } for ( final abstract attribute abstract attribute : attributes ) { abstract attribute . set owner tag ( this ) ; } }	marks the owner tag in the attributes.
private void init in constructor ( ) { html start sb = new string builder ( tag name == null ? num : tag name . length ( ) + num + ( ( attributes == null ? num : attributes . length ) * num ) ) ; html end sb = new string builder ( tag name == null ? num : tag name . length ( ) + num ) ; }	to initialize objects in the constructor.
public abstract html [ ] get children as array ( ) { final lock lock = shared object . get lock ( access object ) . read lock ( ) ; try { lock . lock ( ) ; return children . to array ( new abstract html [ children . size ( ) ] ) ; } finally { lock . unlock ( ) ; } }	Gets the children of this tag as an array.
public abstract html get first child ( ) {	Gets the first child of this tag.
public int get children size ( ) { final lock lock = shared object . get lock ( access object ) . read lock ( ) ; try { lock . lock ( ) ; return children . size ( ) ; } finally { lock . unlock ( ) ; } }	Gets the number of children in this tag.
public boolean contains child ( final abstract html child tag ) { final lock lock = shared object . get lock ( access object ) . read lock ( ) ; try { lock . lock ( ) ; return children . contains ( child tag ) ; } finally { lock . unlock ( ) ; } }	Checks whether a tag is contained in its direct children.
public final string get opening tag ( ) { if ( is rebuild ( ) || is modified ( ) ) { final lock lock = shared object . get lock ( access object ) . write lock ( ) ; try { lock . lock ( ) ; build opening tag ( bool ) ; } finally { lock . unlock ( ) ; } } return opening tag ; }	For internal purpose. Not recommended for external purpose.
public boolean insert before ( final abstract html ... abstract htmls ) { if ( parent == null ) { throw new no parent exception ( str ) ; } final lock lock = shared object . get lock ( access object ) . write lock ( ) ; boolean result = bool ; try { lock . lock ( ) ; final abstract html [ ] removed parent children = parent . children . to array ( new abstract html [ parent . children . size ( ) ] ) ; result = insert before ( removed parent children , abstract htmls ) ; } finally { lock . unlock ( ) ; } final push queue push queue = shared object . get push queue ( access object ) ; if ( push queue != null ) { push queue . push ( ) ; } return result ; }	Inserts the given tags before this tag.
@ override protected void set attribute value ( final boolean update client , final string value ) { if ( value != null ) { final collection < string > all values = extract values ( value ) ; super . replace all in attribute value set ( update client , all values ) ; } }	sets the value for this attribute.
protected void replace all in attribute value set ( final boolean update client , final string ... attr values ) { if ( attr values != null ) { final collection < string > all values = new array deque < > ( ) ; for ( final string attr value : attr values ) { if ( attr value != null ) { all values . add all ( extract values ( attr value ) ) ; } } super . replace all in attribute value set ( update client , all values ) ; } }	Removes all values from the attributeValueSet and adds the givenattribute values.
public final void add web socket push listener ( final string session id , final web socket push listener ws listener ) { session id ws listeners . put ( session id , ws listener ) ; ws listeners . push ( ws listener ) ; this . ws listener = ws listener ; if ( push queue on new web socket listener ) { push wff bm ( ) ; } }	adds the WebSocket listener for the given WebSocket session.
public final void remove web socket push listener ( final string session id ) { final web socket push listener removed = session id ws listeners . remove ( session id ) ; ws listeners . remove ( removed ) ; ws listener = ws listeners . peek ( ) ; }	removes the WebSocket listener added for this WebSocket session.
public final void remove from context ( final boolean enable , final on ... ons ) { for ( final on on : ons ) { if ( on . tab close . equals ( on ) ) { remove from browser context on tab close = enable ; } else if ( on . init remove previous . equals ( on ) ) { remove prev from browser context on tab init = enable ; } } }	By default On.TAB_CLOSE and On.INIT_REMOVE_PREVIOUS are enabled.
public final tag repository get tag repository ( ) { if ( tag repository == null && root tag != null ) { synchronized ( this ) { if ( tag repository == null ) { tag repository = new tag repository ( access object , this , tag by wff id , root tag ) ; } } } return tag repository ; }	Gets the TagRepository to do different tag operations.
protected final void set nonce for wff script ( final string value ) { if ( autoremove wff script ) { throw new invalid usage exception ( str ) ; } if ( value != null ) { if ( nonce for wff script tag == null ) { nonce for wff script tag = new nonce ( value ) ; if ( wff script tag id != null ) { final abstract html [ ] owner tags = wff script tag id . get owner tags ( ) ; if ( owner tags . length > num ) { final abstract html wff script = owner tags [ num ] ; wff script . add attributes ( nonce for wff script tag ) ; } } } else { nonce for wff script tag . set value ( value ) ; } } else { if ( wff script tag id != null && nonce for wff script tag != null ) { final abstract html [ ] owner tags = wff script tag id . get owner tags ( ) ; if ( owner tags . length > num ) { final abstract html wff script = owner tags [ num ] ; wff script . remove attributes ( nonce for wff script tag ) ; } } nonce for wff script tag = null ; } }	Sets nonce attribute value for wff script.
public border set border style ( final border style border style ) { if ( border style == border style . initial || border style == border style . inherit ) { throw new invalid value exception ( str + border style . get css value ( ) ) ; } final string builder css value builder = new string builder ( ) ; if ( border width value != null ) { css value builder . append ( border width value ) . append ( str ) ; } if ( border style != null ) { css value builder . append ( border style . get css value ( ) ) . append ( str ) ; } if ( border color css values != null ) { css value builder . append ( border color css values . get value ( ) ) . append ( str ) ; } final string trimmed css value = string builder util . get trimmed string ( css value builder ) . to string ( ) ; css value = trimmed css value . is empty ( ) ? inherit : trimmed css value ; this . border style = border style ; if ( get state change informer ( ) != null ) { get state change informer ( ) . state changed ( this ) ; } return this ; }	to set the border style.
public void set value ( final uuid uuid ) { if ( uuid != null ) { super . set attribute value ( uuid . to string ( ) ) ; this . uuid = uuid ; } }	value for the id attribute.
public static byte buffer merge ( final byte buffer ... data array ) { int total capacity = num ; for ( final byte buffer data : data array ) { total capacity += data . capacity ( ) ; } final byte buffer whole data = byte buffer . allocate ( total capacity ) ; for ( final byte buffer data : data array ) { whole data . put ( data ) ; } whole data . flip ( ) ; return whole data ; }	Merges and returns ByteBuffer from the given dataArray.
public void remove all css properties ( ) { final long stamp = lock . write lock ( ) ; try { css properties . clear ( ) ; abstract css property class objects . clear ( ) ; super . remove all from attribute value map ( ) ; } finally { lock . unlock write ( stamp ) ; } }	Removes all css properties.
public boolean contains ( final css property css property ) { final long stamp = lock . read lock ( ) ; try { return css properties . contains ( css property ) ; } finally { lock . unlock read ( stamp ) ; } }	Checks if the given cssProperty object exists in this style object.
map < string , css property > get css properties as map ( final boolean rebuild ) { if ( rebuild || ! loaded once ) { synchronized ( css properties ) { if ( rebuild || ! loaded once ) { css properties . clear ( ) ; load ( css properties ) ; loaded once = bool ; set modified ( bool ) ; } } } return css properties as map ; }	rebuild true to rebuild, the load method will be invoked again.
public collection < abstract html > find tags by attribute ( final abstract attribute attribute ) throws null value exception { if ( attribute == null ) { throw new null value exception ( str ) ; } final collection < abstract html > tags = new hash set < > ( ) ; for ( final abstract html owner tag : attribute . get owner tags ( ) ) { if ( browser page . contains ( owner tag ) ) { tags . add ( owner tag ) ; } } return tags ; }	Finds tags by attribute instance.
public abstract html find one tag by attribute ( final abstract attribute attribute ) { if ( attribute == null ) { throw new null value exception ( str ) ; } for ( final abstract html owner tag : attribute . get owner tags ( ) ) { if ( browser page . contains ( owner tag ) ) { return owner tag ; } } return null ; }	Finds one tag by attribute instance.
public collection < abstract attribute > find all attributes ( final boolean parallel ) { final collection < lock > locks = get read locks ( root tags ) ; for ( final lock lock : locks ) { lock . lock ( ) ; } try { return build all attributes stream ( parallel ) . collect ( collectors . to set ( ) ) ; } finally { for ( final lock lock : locks ) { lock . unlock ( ) ; } } }	Finds all attributes from all tags.
public stream < abstract attribute > build all attributes stream ( final boolean parallel ) { final stream < abstract attribute > attributes stream = build all tags stream ( parallel ) . filter ( tag -> tag . get attributes ( ) != null ) . map ( tag -> { return tag . get attributes ( ) ; } ) . flat map ( attributes -> attributes . stream ( ) ) ; return attributes stream ; }	Finds all attributes as stream from all tags.
public static collection < abstract attribute > find all attributes ( final boolean parallel , final abstract html ... from tags ) throws null value exception { if ( from tags == null ) { throw new null value exception ( str ) ; } final collection < lock > locks = get read locks ( from tags ) ; for ( final lock lock : locks ) { lock . lock ( ) ; } try { return get all nested children including parent ( parallel , from tags ) . filter ( tag -> tag . get attributes ( ) != null ) . map ( tag -> { return tag . get attributes ( ) ; } ) . flat map ( attributes -> attributes . stream ( ) ) . collect ( collectors . to set ( ) ) ; } finally { for ( final lock lock : locks ) { lock . unlock ( ) ; } } }	Finds all attributes from the given tags.
public boolean exists ( final abstract html tag ) throws null value exception , invalid tag exception { if ( tag == null ) { throw new null value exception ( str ) ; } if ( no tag . class . is assignable from ( tag . get class ( ) ) ) { throw new invalid tag exception ( str ) ; } return browser page . contains ( tag ) ; }	Checks the existence of a tag instance.
public boolean exists ( final abstract attribute attribute ) throws null value exception { if ( attribute == null ) { throw new null value exception ( str ) ; } for ( final abstract html owner tag : attribute . get owner tags ( ) ) { if ( browser page . contains ( owner tag ) ) { return bool ; } } return bool ; }	Checks the existence of an attribute instance.
public static stream < abstract attribute > build all attributes stream ( final boolean parallel , final abstract html ... from tags ) { final stream < abstract attribute > attributes stream = get all nested children including parent ( parallel , from tags ) . filter ( tag -> tag . get attributes ( ) != null ) . map ( tag -> { return tag . get attributes ( ) ; } ) . flat map ( attributes -> attributes . stream ( ) ) ; return attributes stream ; }	Builds all attributes stream from the given tags.
public string get child text ( ) { final list < abstract html > children = get children ( ) ; if ( children . size ( ) > num ) { final string builder builder = new string builder ( ) ; for ( final abstract html child : children ) { builder . append ( child . to html string ( ) ) ; } return builder . to string ( ) ; } return str ; }	gets the child text set for this tag.
private void write by chunk ( final byte [ ] bytes ) throws io { final int chunk size = this . chunk size ; if ( bytes . length == num ) { return ; } if ( chunk size < bytes . length && chunk size > num ) { int remaining = bytes . length ; int offset = num ; while ( remaining > num ) { if ( chunk size < remaining ) { os . write ( bytes , offset , chunk size ) ; remaining -= chunk size ; offset += chunk size ; } else { os . write ( bytes , offset , remaining ) ; remaining = num ; } } } else { os . write ( bytes ) ; } }	writes maximum bytes at chuckSize.
public embedded tomcat set context path ( string context path ) { if ( context path == null || ! context path . equals ( str ) && ! context path . starts with ( str ) ) { throw new illegal argument exception ( str ) ; } this . context path = context path ; return this ; }	Sets the contextPath for the webapplication.
public embedded tomcat set context file ( string context file ) { try { this . context file url = new file ( context file ) . to uri ( ) . to url ( ) ; } catch ( url e ) { throw new runtime exception ( e ) ; } return this ; }	Sets the location of the context file that configures this web application.
@ deprecated public embedded tomcat add context environment and resource from file ( string context file ) { try { set context file ( new file ( context file ) . to uri ( ) . to url ( ) ) ; } catch ( url e ) { throw new runtime exception ( e ) ; } return this ; }	Read ContextEnvironment and ContextResource definition from a text file.
public static < t > filter < t > filter ( final path . filter filter , final content . type < t > content type ) { return new filter < t > ( ) { @ override public boolean matches ( path . id id , content . type < t > ct ) { return ct == content type && filter . matches ( id ) ; } @ override public boolean matches subpath ( path . id id ) { return filter . matches subpath ( id ) ; } @ override public string to string ( ) { return filter . to string ( ) ; } } ; }	Construct a content filter from a path filter and a content type.
public static < t > filter < t > or ( final filter < t > f1 , final filter < t > f2 ) { return new filter < t > ( ) { @ override public boolean matches ( path . id id , content . type < t > ct ) { return f1 . matches ( id , ct ) || f2 . matches ( id , ct ) ; } @ override public boolean matches subpath ( path . id id ) { return f1 . matches subpath ( id ) || f2 . matches subpath ( id ) ; } @ override public string to string ( ) { return f1 . to string ( ) + str + f2 . to string ( ) ; } } ; }	Combine two filters together produce one filter whose items must bematched by at least one of the original filters.
private void check not eof ( ) { skip white space ( ) ; if ( index >= tokens . size ( ) ) { if ( index > num ) { syntax error ( str , tokens . get ( index - num ) ) ; } else {	Check that the End-Of-File has not been reached.
private boolean is line space ( token token ) { return token . kind == token . kind . indent || token . kind == token . kind . line comment ; }	Define what is considered to be linespace.
protected string parse string ( string v ) { v = v . substring ( num , v . length ( ) - num ) ; string buffer result = new string buffer ( ) ;	Parse a string constant whilst interpreting all escape characters.
public list < token > scan ( ) throws error { array list < token > tokens = new array list < > ( ) ; int pos = num ; while ( pos < input . length ( ) ) { int start = pos ; for ( int i = num ; i != rules . length ; ++ i ) { rule rule = rules [ i ] ; int left = input . length ( ) - pos ; if ( left >= rule . lookahead ( ) ) { token t = rule . match ( input , pos ) ; if ( t != null ) { tokens . add ( t ) ; pos = pos + t . text . length ( ) ; break ;	Scan the given input stream and produce a list of tokens, or an error.
protected command . template parse ( command . descriptor root , string [ ] args , int index ) { array list < command . option > options = new array list < > ( ) ; array list < string > arguments = new array list < > ( ) ;	Parse a given set of command-line arguments starting from a given indexposition to produce an appropriate command template.
private static object parse data ( string str ) { if ( str . equals ( str ) ) { return bool ; } else if ( str . equals ( str ) ) { return bool ; } else if ( character . is digit ( str . char at ( num ) ) ) {	Parse a given string representing a data value into an instance of Data.
protected void print usage ( ) { list < command . descriptor > descriptors = project . get parent ( ) . get command descriptors ( ) ;	Print usage information to the console.
private static int determine command name width ( list < command . descriptor > descriptors ) { int max = num ; for ( command . descriptor d : descriptors ) { max = math . max ( max , d . get name ( ) . length ( ) ) ; } return max ; }	Determine the maximum width of any configured command name.
private zip file create zip file ( list < path . entry < ? > > files ) throws io {	Given a list of files construct a corresponding ZipFile containing them.
private byte [ ] read file contents ( path . entry < ? > file ) throws io { input stream in = file . input stream ( ) ; byte array output stream buffer = new byte array output stream ( ) ; int n read ;	Read the contents of a given file into a byte array.
private content . filter create filter ( string filter ) { string [ ] split = filter . split ( str ) ;	Create a content filter from the string representation.
@ override public void write ( int i ) throws io { if ( count == num ) { output . write ( i & num ) ; } else { write un ( i & num , num ) ; } }	Write an unsigned integer value using 8bits using a big-endian encoding.
public void write u32 ( int w ) throws io { write u8 ( ( w > > num ) & num ) ; write u8 ( ( w > > num ) & num ) ; write u8 ( ( w > > num ) & num ) ; write u8 ( w & num ) ; }	Write an unsigned integer value using 32bits using a big-endian encoding.
public void write un ( int bits , int n ) throws io { int mask = num ; for ( int i = num ; i < n ; ++ i ) { boolean bit = ( bits & mask ) != num ; write bit ( bit ) ; mask = mask << num ; } }	Write an unsigned integer value using n bits using a big-endian encoding.
public static void print syntactic markers ( print stream output , collection < path . entry < ? > > sources , path . entry < ? > target ) throws io {	Print out syntactic markers for all entries in the build graph.
private static void print syntactic markers ( print stream output , collection < path . entry < ? > > sources , syntactic item . marker marker ) {	Print out an individual syntactic markers.
private static list < syntactic item . marker > extract syntactic markers ( path . entry < ? > ... binaries ) throws io { list < syntactic item . marker > annotated = new array list < > ( ) ;	Traverse the various binaries which have been generated looking for errormessages.
@ override public < t extends syntactic item > t get parent ( class < t > kind ) { return parent . get parent ( this , kind ) ; }	Get the first syntactic item of a given kind which refers to this item.
@ override public < t extends syntactic item > list < t > get parents ( class < t > kind ) { return parent . get parents ( this , kind ) ; }	Get all syntactic items of a given kind which refer to this item.
@ override public < t extends syntactic item > t get ancestor ( class < t > kind ) { return parent . get ancestor ( this , kind ) ; }	Get the first syntactic item of a given kind which refers to this item eitherindirectly or directly.
public static int [ ] append ( int lhs , int [ ] rhs ) { int [ ] rs = new int [ rhs . length + num ] ; rs [ num ] = lhs ; system . arraycopy ( rhs , num , rs , num , rhs . length ) ; return rs ; }	Append an integer item to the front of an array of integer type together,producing a fresh array whose length equals that the second plus one.
public static int [ ] append ( int first , int second , int [ ] rhs ) { int [ ] rs = new int [ rhs . length + num ] ; rs [ num ] = first ; rs [ num ] = second ; system . arraycopy ( rhs , num , rs , num , rhs . length ) ; return rs ; }	Append two integer items to the front of an array of integer typetogether, producing a fresh array whose length equals that of the thirdplus two.
public static int [ ] append ( int [ ] lhs , int [ ] rhs ) { int [ ] rs = java . util . arrays . copy of ( lhs , lhs . length + rhs . length ) ; system . arraycopy ( rhs , num , rs , lhs . length , rhs . length ) ; return rs ; }	Append two arrays of integer type together, producing a fresh array whoselength equals that of the first and second added together.
public static < t > t [ ] append ( class < t > type , t lhs , t ... rhs ) { t [ ] rs = ( t [ ] ) array . new instance ( type , rhs . length + num ) ; system . arraycopy ( rhs , num , rs , num , rhs . length ) ; rs [ num ] = lhs ; return rs ; }	Append an element onto an array of unknown type together, producing afresh array whose length equals that of the second plus one.
public static < t > void add all ( t [ ] lhs , collection < t > rhs ) { for ( int i = num ; i != lhs . length ; ++ i ) { rhs . add ( lhs [ i ] ) ; } }	Add all elements from an array into a given collection of the same type.
public static string [ ] to string array ( collection < string > items ) { string [ ] result = new string [ items . size ( ) ] ; int i = num ; for ( string s : items ) { result [ i ++ ] = s ; } return result ; }	Convert a collection of strings into a string array.
public static int [ ] to int array ( collection < integer > items ) { int [ ] result = new int [ items . size ( ) ] ; int i = num ; for ( integer v : items ) { result [ i ++ ] = v ; } return result ; }	Convert a collection of Integers into an int array.
public static < t extends s , s extends comparable < s > > t [ ] sort and remove duplicates ( t [ ] children ) { int r = is sorted and unique ( children ) ; switch ( r ) { case num :	Sort and remove duplicate items from a given array.
public static < t extends comparable < t > > int is sorted and unique ( t [ ] children ) { int r = num ; for ( int i = num ; i < children . length ; ++ i ) { int c = children [ i - num ] . compare to ( children [ i ] ) ; if ( c == num ) {	Check whether or not the children of this array are sorted according totheir underlying order.
public static < s , t extends comparable < s > > int compare to ( t [ ] lhs , t [ ] rhs ) { if ( lhs . length != rhs . length ) { return lhs . length - rhs . length ; } else { for ( int i = num ; i != lhs . length ; ++ i ) { int r = lhs [ i ] . compare to ( ( s ) rhs [ i ] ) ; if ( r != num ) { return r ; } } return num ; } }	A default operator for comparing arrays.
public configuration . schema get build schema ( ) { configuration . schema [ ] schemas = new configuration . schema [ build platforms . size ( ) + num ] ; schemas [ num ] = local config schema ; for ( int i = num ; i != build platforms . size ( ) ; ++ i ) { wybs . lang . build . platform platform = build platforms . get ( i ) ; schemas [ i + num ] = platform . get configuration schema ( ) ; } return configuration . to combined schema ( schemas ) ; }	Get the appropriate configuration schema for a project.
private void create template extension point ( ) { context . create ( command . descriptor . class , new module . extension point < command . descriptor > ( ) { @ override public void register ( command . descriptor command ) { command descriptors . add ( command ) ; } } ) ; }	Create the Build.Template extension point.
private void activate default plugins ( configuration global ) {	Activate the default set of plugins which the tool uses.
private static string determine system root ( ) throws io { string whileyhome = system . getenv ( str ) ; if ( whileyhome == null ) { system . err . println ( str ) ; system . exit ( - num ) ; } return whileyhome ; }	Determine the system root.
private static string determine local root ( ) throws io {	Determine where the root of this project is.
private static configuration read config file ( string name , string dir , configuration . schema ... schemas ) throws io { directory root root = new directory root ( dir , boot registry ) ; path . entry < config file > config = root . get ( trie . from string ( name ) , config file . content type ) ; if ( config == null ) { return configuration . empty ; } try {	Attempt to read a configuration file from a given root.
public < t extends module > t get instance ( class < t > module ) { return ( t ) instances . get ( module ) ; }	Get instance of given module within this context, or null if noinstance available.
public void start ( ) {	Scan and activate all modules on the search path.
private void activate modules ( url loader ) { for ( int i = num ; i != modules . size ( ) ; ++ i ) { descriptor module = modules . get ( i ) ; try { class c = loader . load class ( module . get activator ( ) ) ; module . activator self = ( module . activator ) c . new instance ( ) ; module instance = self . start ( context ) ; instances . put ( c , instance ) ; logger . log timed message ( str + module . get id ( ) + str + module . get version ( ) + str , num , num ) ; } catch ( exception e ) { e . print stack trace ( ) ; } } }	Activate all modules in the order of occurrence in the given list.
public void output source error ( print stream output , boolean brief ) { attribute . span span ; if ( entry == null || element == null ) { output . println ( str + get message ( ) ) ; return ; } else if ( element instanceof attribute . span ) { span = ( attribute . span ) element ; } else { syntactic heap parent = element . get heap ( ) ; span = parent . get parent ( element , attribute . span . class ) ; }	Output the syntax error to a given output stream in either full or briefform.
private boolean ready ( build . task task ) {	Check whether a given task is ready to be built.
public static map < string , object > parse options ( list < string > args , opt arg ... options ) { hash map < string , object > result = new hash map < > ( ) ; hash map < string , opt arg > optmap = new hash map < > ( ) ; for ( opt arg opt : options ) { if ( opt . default value != null ) { result . put ( opt . option , opt . default value ) ; } optmap . put ( opt . option , opt ) ; optmap . put ( opt . short form , opt ) ; } iterator < string > iter = args . iterator ( ) ; while ( iter . has next ( ) ) { string arg = iter . next ( ) ; if ( arg . starts with ( str ) ) { arg = arg . substring ( num , arg . length ( ) ) ; opt arg opt = optmap . get ( arg ) ; if ( opt != null ) {	Parse options from the list of arguments, removing those which arerecognised.
private static map < string , object > split config ( string str ) { hash map < string , object > options = new hash map < > ( ) ; string [ ] splits = str . split ( str ) ; for ( string s : splits ) { string [ ] p = s . split ( str ) ; options . put ( p [ num ] , parse value ( p [ num ] ) ) ; } return options ; }	This splits strings of the form "x=y,v=w" into distinct components andputs them into a map.
@ override public < t extends syntactic item > t get parent ( syntactic item child , class < t > kind ) {	Get first parent of a syntactic item matching the given kind.
@ override public < t extends syntactic item > t get ancestor ( syntactic item child , class < t > kind ) {	Get first ancestor of a syntactic item matching the given kind.
private static syntactic item substitute ( syntactic item item , syntactic item from , syntactic item to , map < syntactic item , syntactic item > mapping ) { syntactic item s item = mapping . get ( item ) ; if ( s item != null ) {	Helper method for above.
private content . type < ? > get content type ( string file ) { list < content . type < ? > > cts = project . get parent ( ) . get content types ( ) ; for ( int i = num ; i != cts . size ( ) ; ++ i ) { content . type < ? > ct = cts . get ( i ) ; string suffix = str + ct . get suffix ( ) ; if ( file . ends with ( suffix ) ) { return ct ; } }	Determine the content type for this file.
public path . entry < ? > get entry ( string file , content . type < ? > ct ) throws io {	Get the entry associated with this file.
private void inspect ( path . entry < ? > entry , content . type < ? > ct , boolean garbage ) throws io { object o = entry . read ( ) ; if ( o instanceof syntactic heap ) { new syntactic heap printer ( new print writer ( out ) , garbage ) . print ( ( syntactic heap ) o ) ; } else { inspect binary file ( read all bytes ( entry . input stream ( ) ) ) ; } }	Inspect a given path entry.
private void inspect binary file ( byte [ ] bytes ) { for ( int i = num ; i < bytes . length ; i += width ) { out . print ( string . format ( str , i ) ) ;	Inspect a given binary file.
protected pair < integer , syntactic item [ ] > read items ( ) throws io {	Read all the items in this heap, returning the identified root item and anarray of all items contained therein.
public static trie from string ( path . id id ) { if ( id instanceof trie ) { return ( ( trie ) id ) ; } trie r = root ; for ( int i = num ; i != id . size ( ) ; ++ i ) { r = r . append ( id . get ( i ) ) ; } return r ; }	Construct a Trie from a Path ID.
public static command . descriptor descriptor ( list < command . descriptor > descriptors ) { return new command . descriptor ( ) { @ override public schema get configuration schema ( ) {	The descriptor for this command.
public path . root get repository root ( ) throws io { path . root root = environment . get global root ( ) . create relative root ( repository path ) ;	Get the root of the package repository.
private void resolve package dependencies ( ) throws io {	Add any declared dependencies to the set of project roots.
public list < token > scan ( ) { array list < token > tokens = new array list < > ( ) ; pos = num ; while ( pos < input . length ( ) ) { char c = input . char at ( pos ) ; if ( character . is digit ( c ) ) { tokens . add ( scan numeric constant ( ) ) ; } else if ( c == str ) { tokens . add ( scan string constant ( ) ) ; } else if ( c == str ) { tokens . add ( scan character constant ( ) ) ; } else if ( is operator start ( c ) ) { tokens . add ( scan operator ( ) ) ; } else if ( character . is letter ( c ) || c == str ) { tokens . add ( scan identifier ( ) ) ; } else if ( character . is whitespace ( c ) ) { scan white space ( tokens ) ; } else { syntax error ( str , pos ) ; } } return tokens ; }	Scan all characters from the input stream and generate a correspondinglist of tokens, whilst discarding all whitespace and comments.
private void syntax error ( string msg , int index ) {	Raise a syntax error with a given message at given index.
public void log stack trace ( ) { if ( enabled ) { throwable t = new throwable ( ) ; t . fill in stack trace ( ) ; stack trace element [ ] ste arr = t . get stack trace ( ) ; for ( int ii = num ; ii < ste arr . length ; ii ++ ) { stack trace element ste = ste arr [ ii ] ; system . out . printf ( str , get indent string ( ) , ste ) ; } } }	Print a stack trace to System.out.
private string get indent string ( ) { assert enabled ; if ( indent string == null ) { for ( int i = indent strings . size ( ) ; i <= indent level ; i ++ ) { indent strings . add ( indent strings . get ( i - num ) + indent str one level ) ; } indent string = indent strings . get ( indent level ) ; } return indent string ; }	Return the current indentation string.
boolean execute ( instruction context ic , frame in frame , array list < instruction context > execution predecessors , inst constraint visitor icv , execution visitor ev ) { stack types . set ( ic . get instruction ( ) . get position ( ) , in frame ) ; return ic . execute ( in frame , execution predecessors , icv , ev ) ; }	Like InstructionContext.execute, but also sets stack_types.
protected string [ ] add string ( string [ ] arr , string new string ) { string [ ] new arr = new string [ arr . length + num ] ; for ( int ii = num ; ii < arr . length ; ii ++ ) { new arr [ ii ] = arr [ ii ] ; } new arr [ arr . length ] = new string ; return new arr ; }	Returns a String array with new_string added to the end of arr.
@ pure protected final string get attribute name ( attribute a ) { int con index = a . get name index ( ) ; constant c = pool . get constant ( con index ) ; string att name = ( ( constant utf8 ) c ) . get bytes ( ) ; return att name ; }	Return the attribute name for the specified attribute.
@ pure protected final @ nullable attribute get stack map table attribute ( method gen mgen ) { for ( attribute a : mgen . get code attributes ( ) ) { if ( is stack map table ( a ) ) { return a ; } } return null ; }	Find the StackMapTable attribute for a method.
@ pure protected final @ nullable attribute get local variable type table attribute ( method gen mgen ) { for ( attribute a : mgen . get code attributes ( ) ) { if ( is local variable type table ( a ) ) { return a ; } } return null ; }	Find the LocalVariableTypeTable attribute for a method.
protected final stack map entry find stack map equal ( int offset ) { running offset = - num ;	Find the StackMap entry whose offset matches the input argument.
protected final int find stack map index before ( int offset ) { number active locals = initial locals count ; running offset = - num ;	Find the index of the StackMap entry whose offset is the last one before the input argument.Return -1 if there isn't one.
protected final @ index or low ( str ) int find stack map index after ( int offset ) { running offset = - num ;	Find the index of the StackMap entry whose offset is the first one after the input argument.Return -1 if there isn't one.
protected final void build unitialized new map ( instruction list il ) { uninitialized new map . clear ( ) ; il . set positions ( ) ; for ( stack map entry smte : stack map table ) { int frame type = smte . get frame type ( ) ; if ( ( frame type >= const . same locals 1 stack item frame && frame type <= const . same locals 1 stack item frame extended ) || ( frame type >= const . append frame && frame type <= const . append frame max ) || ( frame type == const . full frame ) ) { if ( smte . get number of locals ( ) > num ) { for ( stack map type smt : smte . get types of locals ( ) ) { if ( smt . get type ( ) == const . item ) { int i = smt . get index ( ) ; uninitialized new map . put ( il . find handle ( i ) , i ) ; } } } if ( smte . get number of stack items ( ) > num ) { for ( stack map type smt : smte . get types of stack items ( ) ) { if ( smt . get type ( ) == const . item ) { int i = smt . get index ( ) ; uninitialized new map . put ( il . find handle ( i ) , i ) ; } } } } } }	We need to locate and remember any NEW instructions that create uninitialized objects.
private final void update new object stack map entries ( int old offset , int new offset ) { for ( stack map entry smte : stack map table ) { int frame type = smte . get frame type ( ) ; if ( ( frame type >= const . same locals 1 stack item frame && frame type <= const . same locals 1 stack item frame extended ) || ( frame type >= const . append frame && frame type <= const . append frame max ) || ( frame type == const . full frame ) ) { if ( smte . get number of locals ( ) > num ) { for ( stack map type smt : smte . get types of locals ( ) ) { if ( smt . get type ( ) == const . item ) { if ( old offset == smt . get index ( ) ) { smt . set index ( new offset ) ; } } } } if ( smte . get number of stack items ( ) > num ) { for ( stack map type smt : smte . get types of stack items ( ) ) { if ( smt . get type ( ) == const . item ) { if ( old offset == smt . get index ( ) ) { smt . set index ( new offset ) ; } } } } } } }	One of uninitialized NEW instructions has moved.
protected final void update uninitialized new offsets ( instruction list il ) { il . set positions ( ) ; for ( map . entry < instruction handle , integer > e : uninitialized new map . entry set ( ) ) { instruction handle ih = e . get key ( ) ; int old offset = e . get value ( ) . int value ( ) ; int new offset = ih . get position ( ) ; if ( old offset != new offset ) { update new object stack map entries ( old offset , new offset ) ; e . set value ( new offset ) ; } } }	Check to see if any of the uninitialized NEW instructions have moved.
@ ensures non null ( { str } ) protected final void set current stack map table ( method gen mgen , int java class version ) { smta = ( stack map ) get stack map table attribute ( mgen ) ; if ( smta != null ) {	Get existing StackMapTable from the MethodGen argument.
protected final void print stack map table ( string prefix ) { debug instrument . log ( str , prefix , stack map table . length ) ; running offset = - num ;	Print the contents of the StackMapTable to the debug_instrument.log.
protected final void create new stack map attribute ( method gen mgen ) throws io { if ( ! need stack map ) { return ; } if ( stack map table == empty stack map table ) { return ; } print stack map table ( str ) ;	Create a new StackMap code attribute from stack_map_table.
@ suppress warnings ( str )	Convert a Type name to a Class name.
protected final stack map type generate from ( type t ) { switch ( t . get type ( ) ) { case const . t boolean : case const . t char : case const . t byte : case const . t short : case const . t int : return new stack map type ( const . item , - num , pool . get constant pool ( ) ) ; case const . t float : return new stack map type ( const . item , - num , pool . get constant pool ( ) ) ; case const . t double : return new stack map type ( const . item , - num , pool . get constant pool ( ) ) ; case const . t long : return new stack map type ( const . item , - num , pool . get constant pool ( ) ) ; case const . t array : case const . t object : return new stack map type ( const . item , pool . add class ( type to class get name ( t ) ) , pool . get constant pool ( ) ) ;	Convert a Type to a StackMapType.
protected final type generate from ( stack map type smt ) { switch ( smt . get type ( ) ) { case const . item : case const . item :	Convert a StackMapType to a Type.
protected final local variable gen create method scope local ( method gen mgen , string local name , type local type ) {	Create a new local with a scope of the full method.
protected final stack types bcel calc stack types ( method gen mg ) { stack ver stackver = new stack ver ( ) ; verification result vr ; try { vr = stackver . do stack ver ( mg ) ; } catch ( throwable t ) { system . out . printf ( str , mg . get class name ( ) , mg . get name ( ) ) ; system . out . printf ( str , t ) ; system . out . printf ( str ) ; return null ; } if ( vr != verification result . vr ok ) { system . out . printf ( str , mg . get class name ( ) , mg . get name ( ) , vr ) ; system . out . printf ( str ) ; return null ; } assert vr == verification result . vr ok : str + vr ; return stackver . get stack types ( ) ; }	Calculates the types on the stack for each instruction using the BCEL stack verificationroutines.
static string access flags to string ( method m ) { int flags = m . get access flags ( ) ; string builder buf = new string builder ( ) ;	Return a string representation of the access flags of method m.
public static string instruction list to string ( instruction list il , constant pool gen pool ) { string builder out = new string builder ( ) ; for ( iterator < instruction handle > i = il . iterator ( ) ; i . has next ( ) ; ) { instruction handle handle = i . next ( ) ; out . append ( handle . get instruction ( ) . to string ( pool . get constant pool ( ) ) + str ) ; } return out . to string ( ) ; }	Return a printed description of the given instructions.
public static string attribute name to string ( attribute a ) { constant pool pool = a . get constant pool ( ) ; int con index = a . get name index ( ) ; constant c = pool . get constant ( con index ) ; string att name = ( ( constant utf8 ) c ) . get bytes ( ) ; return att name ; }	Return the attribute name for the specified attribute, looked up in the original class fileConstantPool.
public static void check mgen ( method gen mgen ) { if ( skip checks ) { return ; } try { mgen . to string ( ) ;	Checks the specified method for consistency. Does nothing if {.
public static void check mgens ( final class gen gen ) { if ( skip checks ) { return ; } method [ ] methods = gen . get methods ( ) ; for ( int i = num ; i < methods . length ; i ++ ) { method method = methods [ i ] ;	Checks all of the methods in gen for consistency.
public static void dump stack trace ( ) { stack trace element [ ] ste = thread . current thread ( ) . get stack trace ( ) ;	Print the current java call stack.
static void dump methods ( class gen gen ) { system . out . printf ( str , gen . get class name ( ) ) ; for ( method m : gen . get methods ( ) ) { system . out . printf ( str , m ) ; } }	Print the methods in the class, to standard output.
public static void add to start ( method gen mg , instruction list new list ) {	Adds instructions to the start of a method.
public static string get constant string ( constant pool pool , int index ) { constant c = pool . get constant ( index ) ; assert c != null : str + index + str ; if ( c instanceof constant utf8 ) { return ( ( constant utf8 ) c ) . get bytes ( ) ; } else if ( c instanceof constant class ) { constant class cc = ( constant class ) c ; return cc . get bytes ( pool ) + str + cc . get name index ( ) + str ; } else { throw new error ( str + c + str + c . get class ( ) ) ; } }	Returns the constant string at the specified offset.
public static void reset locals to formals ( method gen mg ) {	Sets the locals to be the formal parameters.
public static class < ? > type to class ( type type ) { string classname = type to classgetname ( type ) ; try { return reflection plume . class for name ( classname ) ; } catch ( exception e ) { throw new runtime exception ( str + classname , e ) ; } }	Returns the class that corresponds to type.
public static type [ ] postpend to array ( type [ ] types , type new type ) { if ( types . length == integer . max value ) { throw new error ( str + types + str ) ; } type [ ] new types = new type [ types . length + num ] ; system . arraycopy ( types , num , new types , num , types . length ) ; new types [ types . length ] = new type ; return new types ; }	Returns a copy of the given type array, with newType added to the end.
public void set ( @ index for ( { str , str } ) int offset , frame f ) { operand stack os = f . get stack ( ) ;	Sets the stack for the instruction at the specified offset to a copy of the information in thegiven frame.
protected final void insert at method start ( method gen mg , instruction list new il ) {	Inserts an instruction list at the beginning of a method.
private void print il ( instruction handle start , string label ) { if ( debug instrument . enabled ( ) ) { print stack map table ( label ) ; instruction handle tih = start ; while ( tih != null ) { debug instrument . log ( str , tih ) ; if ( tih . has targeters ( ) ) { for ( instruction targeter it : tih . get targeters ( ) ) { debug instrument . log ( str , it ) ; } } tih = tih . get next ( ) ; } } }	Print a BCEL instruction list to the debug_instrument log.
protected final instruction list build il ( instruction ... instructions ) { instruction list il = new instruction list ( ) ; for ( instruction inst : instructions ) { append inst ( il , inst ) ; } return il ; }	Convenience function to build an instruction list.
protected final stack map type [ ] calculate live stack types ( operand stack stack ) { int ss = stack . size ( ) ; stack map type [ ] stack map types = new stack map type [ ss ] ; for ( int ii = num ; ii < ss ; ii ++ ) { stack map types [ ii ] = generate from ( stack . peek ( ss - ii - num ) ) ; } return stack map types ; }	Compute the StackMapTypes of the items on the execution stack as described by the OperandStackargument.
private static final int find ( boolean skip blocks , string s , char to find , int from ) { int open = num ; boolean escaping = bool ; for ( int i = from ; i < s . length ( ) ; i ++ ) { if ( escaping ) { escaping = bool ; continue ; } char c = s . char at ( i ) ; if ( c == str ) { escaping = bool ; continue ; } if ( ( open == num ) && ( c == to find ) ) { return i ; } else if ( skip blocks && ( c == str ) ) { open ++ ; } else if ( skip blocks && ( c == str ) ) { open -- ; } } return - num ; }	Beware, with the current algorithm, this function cannot find '\'.
@ override public int read ( final byte [ ] output , final int offset , final int length ) throws t { int read = num ; int index = offset ; int space = length - offset ; while ( space > num ) { byte a byte = read asynchrously ( ) ; output [ index ] = a byte ; space -- ; index ++ ; read ++ ; } return read ; }	Reads from the shared input queue, blocking if there is not enough inputin the buffer.
@ override public void flush ( ) throws t { channel buffer flush = channel buffers . dynamic buffer ( ) ; flush . write bytes ( output ) ; channel . write ( flush ) . await uninterruptibly ( ) ; }	We need data to be written and flushed at once.
public web socket client new client ( final uri url , final web socket callback callback ) { client bootstrap bootstrap = new client bootstrap ( socket channel factory ) ; string protocol = url . get scheme ( ) ; if ( ! protocol . equals ( str ) && ! protocol . equals ( str ) ) { throw new illegal argument exception ( str + protocol ) ; } final web socket client handler client handler = new web socket client handler ( bootstrap , url , callback ) ; bootstrap . set pipeline factory ( new channel pipeline factory ( ) { public channel pipeline get pipeline ( ) throws exception { channel pipeline pipeline = channels . pipeline ( ) ; pipeline . add last ( str , new http response decoder ( ) ) ; pipeline . add last ( str , new http request encoder ( ) ) ; pipeline . add last ( str , client handler ) ; return pipeline ; } } ) ; return client handler ; }	Create a new WebSocket client.
private boolean can use this ad ( native ad ad native ) { if ( ad native != null ) { native ad . image logo image = null ; char sequence header = null , body = null ; if ( ad native instanceof native content ad ) { native content ad ad = ( native content ad ) ad native ; logo image = ad . get logo ( ) ; header = ad . get headline ( ) ; body = ad . get body ( ) ; } else if ( ad native instanceof native app install ad ) { native app install ad ad = ( native app install ad ) ad native ; logo image = ad . get icon ( ) ; header = ad . get headline ( ) ; body = ad . get body ( ) ; } if ( ! text utils . is empty ( header ) && ! text utils . is empty ( body ) ) { return bool ; } } return bool ; }	Determines if the native ad can be used.
public synchronized ad view get ad for index ( int ad pos ) { if ( ad pos >= num && m prefetched ads . size ( ) > ad pos ) return m prefetched ads . get ( ad pos ) ; return null ; }	Gets banner ad at a particular index in the fetched ads list.
private synchronized void on failed to load ( ad view ad view , int error code ) { log . i ( tag , str + error code ) ; m fetch fail count ++ ; m no of fetched ads = math . max ( m no of fetched ads - num , num ) ;	A handler for failed banner ads.
protected synchronized ad request get ad request ( ) { ad request . builder ad bldr = new ad request . builder ( ) ; for ( string id : get test device ids ( ) ) { ad bldr . add test device ( id ) ; } return ad bldr . build ( ) ; }	Setup and get an ads request.
public int get ads count to publish ( int fetched ads count , int source items count ) { if ( fetched ads count <= num || get no of data between ads ( ) <= num ) return num ; int expected = num ; if ( source items count > num && source items count >= get offset value ( ) + num ) expected = ( source items count - get offset value ( ) ) / get no of data between ads ( ) + num ; expected = math . max ( num , expected ) ; expected = math . min ( fetched ads count , expected ) ; return math . min ( expected , get limit of ads ( ) ) ; }	Gets the count of ads that could be published.
public int get original content position ( int position , int fetched ads count , int source items count ) { int no of ads = get ads count to publish ( fetched ads count , source items count ) ;	Translates an adapter position to an actual position within the underlying dataset.
public int get ad index ( int position ) { int index = - num ; if ( position >= get offset value ( ) ) index = ( position - get offset value ( ) ) / ( get no of data between ads ( ) + num ) ;	Gets the ad index for this adapter position within the list of currently fetched ads.
public boolean is ad available ( int position , int fetched ads count ) { if ( fetched ads count == num ) return bool ; int ad index = get ad index ( position ) ; int first ad pos = get offset value ( ) ; return position >= first ad pos && ad index >= num && ad index < get limit of ads ( ) && ad index < fetched ads count ; }	Checks if an ad is available for this position.
public boolean has to fetch ad ( int position , int fetching ads count ) { int ad index = get ad index ( position ) ; int first ad pos = get offset value ( ) ; return position >= first ad pos && ad index >= num && ad index < get limit of ads ( ) && ad index >= fetching ads count ; }	Checks if we have to request the next ad block for this position.
public static type mirror has generics type argument of ( element element , string type to check , elements elements , types types ) { if ( element . as type ( ) . get kind ( ) != type kind . declared || ! ( element . as type ( ) instanceof declared type ) ) { processor message . error ( element , str , element . get simple name ( ) , element . as type ( ) . to string ( ) ) ; } declared type declared type = ( declared type ) element . as type ( ) ; list < ? extends type mirror > type arguments = declared type . get type arguments ( ) ; if ( type arguments . is empty ( ) ) { processor message . error ( element , str , element . get simple name ( ) , element . as type ( ) . to string ( ) ) ; } if ( type arguments . size ( ) > num ) { processor message . error ( element , str , element . get simple name ( ) , element . as type ( ) . to string ( ) ) ; }	Checks if the variabel element has generics arguments that matches the expected type.
public java writer emit package ( string package name ) throws io { if ( this . package prefix != null ) { throw new illegal state exception ( ) ; } if ( package name . is empty ( ) ) { this . package prefix = str ; } else { out . write ( str ) ; out . write ( package name ) ; out . write ( str ) ; this . package prefix = package name + str ; } return this ; }	Emit a package declaration and empty line.
public string compress type ( string type ) { string builder sb = new string builder ( ) ; if ( this . package prefix == null ) { throw new illegal state exception ( ) ; } matcher m = type pattern . matcher ( type ) ; int pos = num ; while ( bool ) { boolean found = m . find ( pos ) ;	Try to compress a fully-qualified class name to only the class name.
public java writer begin initializer ( boolean is static ) throws io { indent ( ) ; if ( is static ) { out . write ( str ) ; out . write ( str ) ; } else { out . write ( str ) ; } scopes . push ( scope . initializer ) ; return this ; }	Emits an initializer declaration.
public java writer end type ( ) throws io { pop scope ( scope . type declaration , scope . interface declaration ) ; types . pop ( ) ; indent ( ) ; out . write ( str ) ; return this ; }	Completes the current type declaration.
public java writer emit single line comment ( string comment , object ... args ) throws io { indent ( ) ; out . write ( str ) ; out . write ( string . format ( comment , args ) ) ; out . write ( str ) ; return this ; }	Emits a single line comment.
private java writer emit annotation value ( object value ) throws io { if ( value instanceof object [ ] ) { out . write ( str ) ; boolean first value = bool ; scopes . push ( scope . annotation array value ) ; for ( object o : ( ( object [ ] ) value ) ) { if ( first value ) { first value = bool ; out . write ( str ) ; } else { out . write ( str ) ; } indent ( ) ; out . write ( o . to string ( ) ) ; } pop scope ( scope . annotation array value ) ; out . write ( str ) ; indent ( ) ; out . write ( str ) ; } else { out . write ( value . to string ( ) ) ; } return this ; }	Writes a single annotation value.
public java writer end method ( ) throws io { scope popped = scopes . pop ( ) ;	Completes the current method declaration.
public static string type ( class < ? > raw , string ... parameters ) { if ( parameters . length == num ) { return raw . get canonical name ( ) ; } if ( raw . get type parameters ( ) . length != parameters . length ) { throw new illegal argument exception ( ) ; } string builder result = new string builder ( ) ; result . append ( raw . get canonical name ( ) ) ; result . append ( str ) ; result . append ( parameters [ num ] ) ; for ( int i = num ; i < parameters . length ; i ++ ) { result . append ( str ) ; result . append ( parameters [ i ] ) ; } result . append ( str ) ; return result . to string ( ) ; }	Build a string representation of a type and optionally its generic type arguments.
private void emit modifiers ( set < modifier > modifiers ) throws io { if ( modifiers . is empty ( ) ) { return ; }	Emits the modifiers to the writer.
private psi class get psi class from context ( an action event e ) { psi file psi file = e . get data ( lang data keys . psi file ) ; editor editor = e . get data ( platform data keys . editor ) ; if ( psi file == null || editor == null ) { return null ; } int offset = editor . get caret model ( ) . get offset ( ) ; psi element element = psi file . find element at ( offset ) ; return psi tree util . get parent of type ( element , psi class . class ) ; }	Get the class where currently the curser is.
private void find and remove method ( string method name , string ... arguments ) {	Finds and removes a given method.
public void generate ( ) { psi element factory element factory = java psi facade . get element factory ( psi class . get project ( ) ) ; java code style manager style manager = java code style manager . get instance ( psi class . get project ( ) ) ;	Generate and insert the Parcel and ParcelablePlease code.
private void make class implement parcelable ( psi element factory element factory , java code style manager style manager ) { final psi class type [ ] implements list types = psi class . get implements list types ( ) ; final string implements type = str ; for ( psi class type implements list type : implements list types ) { psi class resolved = implements list type . resolve ( ) ;	Make the class implementing Parcelable.
private boolean is class ( element element ) { if ( element . get kind ( ) == element kind . class ) { if ( element . get modifiers ( ) . contains ( modifier . abstract ) ) { processor message . error ( element , str + str + str , element . get simple name ( ) , parcelable please . class . get simple name ( ) , parcelable please . class . get simple name ( ) ) ; return bool ; } if ( element . get modifiers ( ) . contains ( modifier . private ) ) { processor message . error ( element , str + str , element . get simple name ( ) , parcelable please . class . get simple name ( ) ) ; return bool ; }	Checks if the element is a class.
public static boolean is type of ( type mirror type , class < ? > clazz ) { return type . to string ( ) . equals ( clazz . get canonical name ( ) ) ; }	Checks if a TypeMirror equals a class.
public static class < ? > is type of ( type mirror type , list < class < ? > > class list ) { for ( class < ? > c : class list ) { if ( is type of ( type , c ) ) { return c ; } } return null ; }	Returns the class this element is part of.
public static string get package name ( elements element utils , type element type ) throws io { package element pkg = element utils . get package of ( type ) ; if ( ! pkg . is unnamed ( ) ) { return pkg . get qualified name ( ) . to string ( ) ; } else { return str ;	Get the Package name.
public static string get binary name ( elements element utils , type element type ) throws io { string package name = get package name ( element utils , type ) ; string qualified name = type . get qualified name ( ) . to string ( ) ; if ( package name . length ( ) > num ) { return package name + str + qualified name . substring ( package name . length ( ) + num ) . replace ( str , str ) ; } else { return qualified name . replace ( str , str ) ; } }	Get the qualified name of a class. Also respects innner classes.
private void generate write to parcel ( java writer jw , string origin class , list < parcelable field > fields ) throws io { jw . begin method ( str , str , enum set . of ( modifier . public , modifier . static ) , origin class , param source , str , param parcel , str , param flags ) ; for ( parcelable field field : fields ) { field code gen gen = field . get code generator ( ) ; if ( gen == null ) {	Generate the writeToParcel method.
private boolean is public class ( declared type type ) { element element = type . as element ( ) ; return element . get modifiers ( ) . contains ( javax . lang . model . element . modifier . public ) ; }	Checks if a class is public.
private boolean has public empty constructor ( declared type type ) { element element = type . as element ( ) ; list < ? extends element > containing = element . get enclosed elements ( ) ; for ( element e : containing ) { if ( e . get kind ( ) == element kind . constructor ) { executable element c = ( executable element ) e ; if ( ( c . get parameters ( ) == null || c . get parameters ( ) . is empty ( ) ) && c . get modifiers ( ) . contains ( javax . lang . model . element . modifier . public ) ) { return bool ; } } } return bool ; }	Checks if an public empty constructor is available.
public static double determinant3x3 ( final double r0c0 , final double r0c1 , final double r0c2 , final double r1c0 , final double r1c1 , final double r1c2 , final double r2c0 , final double r2c1 , final double r2c2 ) { double sum = num ; sum += r0c0 * ( ( r1c1 * r2c2 ) - ( r1c2 * r2c1 ) ) ; sum -= r0c1 * ( ( r1c0 * r2c2 ) - ( r1c2 * r2c0 ) ) ; sum += r0c2 * ( ( r1c0 * r2c1 ) - ( r1c1 * r2c0 ) ) ; return sum ; }	Calculate the determinant of the given 3x3 matrix values.
public static generator < d > create orthogonal ( ) { return ( ) -> { final secure random rng = new secure random ( ) ; final double r0c0 = num ; final double r0c1 = num ; final double r0c2 = num ; final double r0c3 = rng . next double ( ) ; final double r1c0 = num ; final double r1c1 = num ; final double r1c2 = num ; final double r1c3 = rng . next double ( ) ; final double r2c0 = num ; final double r2c1 = num ; final double r2c2 = num ; final double r2c3 = rng . next double ( ) ; final double r3c0 = num ; final double r3c1 = num ; final double r3c2 = num ; final double r3c3 = num ; return d . of ( r0c0 , r0c1 , r0c2 , r0c3 , r1c0 , r1c1 , r1c2 , r1c3 , r2c0 , r2c1 , r2c2 , r2c3 , r3c0 , r3c1 , r3c2 , r3c3 ) ; } ; }	Create a generator initialized with a default component generator that onlyproduces orthogonal matrices.
@ suppress warnings ( str ) public static list < byte [ ] > get binary multi bulk reply ( byte [ ] input ) { return ( list < byte [ ] > ) redis protocol . read ( new redis input stream ( new byte array input stream ( input ) ) ) ; }	Gets the binary multi bulk reply.
private set < tuple > get binary tupled set ( ) { list < byte [ ] > members with scores = client . get binary multi bulk reply ( ) ; set < tuple > set = new linked hash set < tuple > ( ) ; if ( members with scores == null ) { return set ; } iterator < byte [ ] > iterator = members with scores . iterator ( ) ; if ( iterator == null ) { return set ; } while ( iterator . has next ( ) ) { set . add ( new tuple ( iterator . next ( ) , double . value of ( safe encoder . encode ( iterator . next ( ) ) ) ) ) ; } return set ; }	Gets the binary tupled set.
@ suppress warnings ( str ) byte [ ] raw key ( object key ) { assert . not null ( key , str ) ; return key serializer ( ) . serialize ( key ) ; }	Raw key.
@ suppress warnings ( str ) < hk > byte [ ] raw hash key ( hk hash key ) { assert . not null ( hash key , str ) ; return hash key serializer ( ) . serialize ( hash key ) ; }	Raw hash key.
@ suppress warnings ( str ) set < typed tuple < v > > deserialize tuple values ( set < tuple > raw values ) { set < typed tuple < v > > set = new linked hash set < typed tuple < v > > ( raw values . size ( ) ) ; for ( tuple raw value : raw values ) { set . add ( new default typed tuple ( value serializer ( ) . deserialize ( raw value . get value ( ) ) , raw value . get score ( ) ) ) ; } return set ; }	Deserialize tuple values.
@ suppress warnings ( str ) < t > set < t > deserialize hash keys ( set < byte [ ] > raw keys ) { return serialization utils . deserialize ( raw keys , hash key serializer ( ) ) ; }	Deserialize hash keys.
@ suppress warnings ( str ) < t > list < t > deserialize hash values ( list < byte [ ] > raw values ) { return serialization utils . deserialize ( raw values , hash value serializer ( ) ) ; }	Deserialize hash values.
@ suppress warnings ( str ) < hk , hv > map < hk , hv > deserialize hash map ( map < byte [ ] , byte [ ] > entries ) {	Deserialize hash map.
< hk , hv > map < hk , list < hv > > deserialize hash list ( map < byte [ ] , list < byte [ ] > > entries ) {	Deserialize hash list.
< hk , hv > map < hk , set < hv > > deserialize hash set ( map < byte [ ] , set < byte [ ] > > entries ) {	Deserialize hash set.
public static list < gateway address > as list from domain ( final string domain address ) { if ( domain address == null ) { throw new illegal argument exception ( str ) ; } gateway address domain = new gateway address ( num , domain address ) ; inet address [ ] addresses ; try { addresses = inet address . get all by name ( domain . get host ( ) ) ; } catch ( exception e ) { throw new illegal argument exception ( str + domain + str + e . get message ( ) ) ; } list < gateway address > list = new array list < gateway address > ( ) ; int id = num ; for ( inet address address : addresses ) { list . add ( new gateway address ( id ++ , address . get host address ( ) , domain . get port ( ) ) ) ; } return list ; }	As list from domain.
public static string parse host ( final string address ) { int ep = address . index of ( str ) ; if ( ep == - num || ep == num ) { throw new illegal argument exception ( str + address + str ) ; } return address . substring ( num , ep ) . trim ( ) ; }	Parses the host.
public static int parse port ( final string address ) { int sp = address . index of ( str ) ; if ( sp == - num && sp + num >= address . length ( ) ) { throw new illegal argument exception ( str + address + str ) ; } try { return integer . parse int ( address . substring ( sp + num , address . length ( ) ) . trim ( ) ) ; } catch ( number format exception nfe ) { throw new illegal argument exception ( str + address + str ) ; } }	Parses the port.
public void set ( final string key , final string value ) { set ( safe encoder . encode ( key ) , safe encoder . encode ( value ) ) ; }	Sets the.
public void sync ( ) { if ( this . client == null ) { return ; } list < object > unformatted = null ; try { unformatted = this . client . get all ( ) ; } catch ( exception e ) { this . broken resource = bool ; throw new gateway exception ( str + this . server + str + this . redis . connect info ( ) , e ) ; } if ( unformatted == null ) { return ; } for ( object o : unformatted ) { try { generate response ( o ) ; } catch ( exception ignored ) { } } }	Synchronize pipeline by reading all responses.
private set < tuple > get tupled set ( ) { list < string > members with scores = client . get multi bulk reply ( ) ; set < tuple > set = new linked hash set < tuple > ( ) ; iterator < string > iterator = members with scores . iterator ( ) ; while ( iterator . has next ( ) ) { set . add ( new tuple ( iterator . next ( ) , double . value of ( iterator . next ( ) ) ) ) ; } return set ; }	Gets the tupled set.
public synchronized void stop ( ) { state = state . stop ; dispatch event ( leader election event type . stop start ) ; logger . info ( str ) ; if ( leader offer != null ) { try { zoo keeper . delete ( leader offer . get node path ( ) , - num ) ; logger . info ( str , leader offer . get node path ( ) ) ; } catch ( interrupted exception e ) { become failed ( e ) ; } catch ( keeper exception e ) { become failed ( e ) ; } } dispatch event ( leader election event type . stop complete ) ; }	Stops all election services, revokes any outstanding leader offers, anddisconnects from ZooKeeper.
string to execute info ( final int try count , final long started time , final gateway server server , final redis cluster redis ) { final string builder sb = new string builder ( ) ; final long executed time = system . current time millis ( ) - started time ; sb . append ( str ) . append ( executed time ) . append ( str ) ; sb . append ( str ) . append ( try count ) . append ( str ) ; sb . append ( str ) . append ( server ) ; if ( redis != null ) { sb . append ( str ) . append ( str ) . append ( redis . connect info ( ) ) ; } return sb . to string ( ) ; }	time, retry, gateway server information.
public void setquorum ( partition group server master , int q , string quorum members ) throws mgmt setquorum exception , mgmt smr command exception { master . set quorum ( q , quorum members ) ; }	Since it is a singleton instance and represents a part of workflow logic running in multiple threads.
public static void check permission ( string path , lock type type ) throws mgmt zoo keeper exception { if ( znode permission . get ( ) != null ) { znode permission . get ( ) . check permission ( path , type ) ; } }	Clear ZNodePermission of current-thread to null.If znodePermission.get() returns null, this method skip permission-check.
private byte [ ] [ ] join parameters ( byte [ ] first , byte [ ] [ ] rest ) { byte [ ] [ ] result = new byte [ rest . length + num ] [ ] ; result [ num ] = first ; for ( int i = num ; i < rest . length ; i ++ ) { result [ i + num ] = rest [ i ] ; } return result ; }	Join parameters.
public void expire at ( final byte [ ] key , final long milliseconds timestamp ) { send command ( command . expireat , key , redis protocol . to byte array ( milliseconds timestamp ) ) ; }	Expire at.
public void decr by ( final byte [ ] key , final long integer ) { send command ( command . decrby , key , redis protocol . to byte array ( integer ) ) ; }	Decr by.
public void incr by ( final byte [ ] key , final long integer ) { send command ( command . incrby , key , redis protocol . to byte array ( integer ) ) ; }	Incr by.
public void zadd binary ( final byte [ ] key , map < double , byte [ ] > score members ) { array list < byte [ ] > args = new array list < byte [ ] > ( score members . size ( ) * num + num ) ; args . add ( key ) ; for ( map . entry < double , byte [ ] > entry : score members . entry set ( ) ) { args . add ( redis protocol . to byte array ( entry . get key ( ) ) ) ; args . add ( entry . get value ( ) ) ; } byte [ ] [ ] args array = new byte [ args . size ( ) ] [ ] ; args . to array ( args array ) ; send command ( command . zadd , args array ) ; }	Zadd binary.
public void zrange by score ( final byte [ ] key , final byte [ ] min , final byte [ ] max ) { send command ( command . zrangebyscore , key , min , max ) ; }	Zrange by score.
public void zrange by score with scores ( final byte [ ] key , final byte [ ] min , final byte [ ] max , final int offset , final int count ) { send command ( command . zrangebyscore , key , min , max , keyword . limit . raw , redis protocol . to byte array ( offset ) , redis protocol . to byte array ( count ) , keyword . withscores . raw ) ; }	Zrange by score with scores.
public void slaveof no one ( ) { send command ( command . slaveof , keyword . no . raw , keyword . one . raw ) ; }	Slaveof no one.
public void config set ( final byte [ ] parameter , final byte [ ] value ) { send command ( command . config , keyword . set . raw , parameter , value ) ; }	Config set.
public void getbit ( byte [ ] key , long offset ) { send command ( command . getbit , key , redis protocol . to byte array ( offset ) ) ; }	Gets the bit.
public void getrange ( byte [ ] key , long start offset , long end offset ) { send command ( command . getrange , key , redis protocol . to byte array ( start offset ) , redis protocol . to byte array ( end offset ) ) ; }	Gets the range.
public void shutdown ( ) throws io { try { selector . close ( ) ; } catch ( io e ) { logger . error ( str , e ) ; throw e ; } }	Shutdown a selector.
public elapsed time process ( ) { try { long start = system . current time millis ( ) ; io process ( ) ; long io done = system . current time millis ( ) ; loop process ( ) ; long end = system . current time millis ( ) ; return new elapsed time ( start , io done , end ) ; } catch ( exception e ) { logger . error ( str , e ) ; } return null ; }	Main loop of nio.
public void loop process ( ) { for ( session session : sessions . values ( ) ) { long time millis = system . current time millis ( ) ; try { session . callback on loop ( time millis ) ; } catch ( exception e ) { logger . error ( str , session , e ) ; } } }	to be called on each loop to process idle routines.
public void register ( session session , int ops ) throws closed channel exception { if ( sessions . contains key ( session . get id ( ) ) ) { throw new illegal state exception ( str ) ; } selection key sel key ; try { sel key = session . get channel ( ) . register ( selector , ops , session ) ; } catch ( closed channel exception e ) { logger . error ( str , session , e ) ; throw e ; } session . set selection key ( sel key ) ; }	register session to Selector in order to detect IO events.
public void add default header ( final string name , final string value ) { validate . not empty ( name , str ) ; validate . not null ( value , str ) ; this . check configurable ( ) ; this . default headers . put ( name , value ) ; }	Adds a default header to be added to every stub http response.
public void received times ( final matcher < integer > nr requests predicate ) { validate . not null ( nr requests predicate , str ) ; this . request manager . evaluate verification ( predicates , nr requests predicate ) ; }	Checks whether the number of requests described in this verifying object received so far matches the given predicate.
public string get value ( final string key ) { validate . not empty ( key , str ) ; final list < string > all values = this . get values ( key ) ; return all values != null ? all values . get ( num ) : null ; }	Returns the first value for the given key.
public list < string > get values ( final string key ) { validate . not empty ( key , str ) ; @ suppress warnings ( str ) final list < string > result = ( list < string > ) values . get ( key . to lower case ( ) ) ; return result == null || result . is empty ( ) ? null : new array list < string > ( result ) ; }	Returns all values for the given key.
static void add encoding ( final request . builder builder , final http exchange http exchange ) { final string content type = http exchange . get request headers ( ) . get first ( str ) ; if ( content type != null ) { final matcher matcher = charset pattern . matcher ( content type ) ; if ( matcher . matches ( ) ) { try { builder . encoding ( charset . for name ( matcher . group ( num ) ) ) ; } catch ( unsupported charset exception e ) {	package protected for testing purposes.
public stubbing create stubbing ( final charset default encoding , final int default status , final multi map default headers ) { return new stubbing ( default encoding , default status , default headers ) ; }	Creates new stubbing instance.
public static string encode ( json claims , string secret ) { string encoded header = get common header ( ) ; string encoded claims = encode json ( claims ) ; string secure bits = new string builder ( encoded header ) . append ( token sep ) . append ( encoded claims ) . to string ( ) ; string sig = sign ( secret , secure bits ) ; return new string builder ( secure bits ) . append ( token sep ) . append ( sig ) . to string ( ) ; }	Encode and sign a set of claims.
private date copy date ( date date ) { return ( date != null ) ? new date ( date . get time ( ) ) : null ; }	Copies the date, since Date objects are mutable.
public string create token ( map < string , object > data , token options options ) { if ( ( data == null || data . size ( ) == num ) && ( options == null || ( ! options . is admin ( ) && ! options . is debug ( ) ) ) ) { throw new illegal argument exception ( str ) ; } json claims = new json ( ) ; try { claims . put ( str , token version ) ; claims . put ( str , new date ( ) . get time ( ) / num ) ; boolean is admin token = ( options != null && options . is admin ( ) ) ; validate token ( str , data , is admin token ) ; if ( data != null && data . size ( ) > num ) { claims . put ( str , new json ( data ) ) ; }	Create a token for the given object and options.
dialog get error dialog ( int error code , int request code ) { final dialog dialog = google api availability . get instance ( ) . get error dialog ( activity , error code , request code ) ; dialog . set on dismiss listener ( new dialog interface . on dismiss listener ( ) { @ override public void on dismiss ( dialog interface dialog interface ) { resolving error = bool ; } } ) ; return dialog ; }	Helper to create a new dialog from an error code.
void connect and request google account ( int sign in request code , int error resolution request code ) { if ( client . is connected ( ) ) { request google account ( sign in request code ) ; } else if ( ! client . is connecting ( ) ) { this . sign in request code = sign in request code ; this . error resolution request code = error resolution request code ; client . connect ( ) ; } }	Checks if the Google API Client is connected and tries to request the user Account.
public void logout and clear state ( ) { if ( client != null && client . is connected ( ) ) { logout ( ) ; client . disconnect ( ) ; } activity = null ; client = null ; }	Clears this helper state.
@ override public boolean invalidate if necessary ( baragon request request ) { if ( request . get load balancer service ( ) . get edge cache domains ( ) . is empty ( ) ) { return bool ; } try { boolean all succeeded = bool ; for ( string edge cache dns : request . get load balancer service ( ) . get edge cache domains ( ) ) { list < cloudflare zone > matching zones = get cloudflare zone ( edge cache dns ) ; if ( matching zones . is empty ( ) ) { log . warn ( str ) ; return bool ; } for ( cloudflare zone matching zone : matching zones ) { string zone id = matching zone . get id ( ) ; optional < cloudflare dns record > matching dns record = get cloudflare dns record ( edge cache dns , zone id ) ; if ( ! matching dns record . is present ( ) ) { log . warn ( str ) ; return bool ; } if ( ! matching dns record . get ( ) . is proxied ( ) ) { log . warn ( str , edge cache dns ) ; return bool ; } string cache tag = string . format ( edge cache configuration . get integration settings ( ) . get ( str ) , request . get load balancer service ( ) . get service id ( ) ) ; log . debug ( str , matching dns record . get ( ) . get name ( ) , cache tag ) ; all succeeded = cf . purge edge cache ( zone id , collections . singleton list ( cache tag ) ) && all succeeded ; } } return all succeeded ; } catch ( cloudflare client exception e ) { log . error ( str , request , e ) ; return bool ; } }	Invalidation will eventually occur when the TTL expires, so it's not a showstopper if this fails.
public collection < string > get load balancer groups ( ) { final string request uri = string . format ( load balancer format , get base url ( ) ) ; return get collection ( request uri , str , string collection ) ; }	BaragonService load balancer group actions.
public collection < string > get occupied base paths ( string load balancer group name ) { final string request uri = string . format ( load balancer all base paths format , get base url ( ) , load balancer group name ) ; return get collection ( request uri , str , string collection ) ; }	BaragonService base path actions.
public collection < queued request id > get queued requests ( ) { final string uri = string . format ( request format , get base url ( ) ) ; return get collection ( uri , str , queued request collection ) ; }	BaragonService queued request actions.
private void guarantee registered ( traffic source traffic source , target group target group , collection < target description > targets , collection < baragon agent metadata > baragon agents , collection < load balancer > load balancers ) { if ( configuration . is present ( ) && configuration . get ( ) . is check for correct vpc ( ) ) { guarantee same vpc ( target group , baragon agents , load balancers ) ; } guarantee az enabled ( baragon agents , load balancers ) ; guarantee has all targets ( traffic source , target group , targets , baragon agents ) ;	Ensure that the given baragon agent is attached to the given target group.
private void deregister removable targets ( traffic source traffic source , baragon group baragon group , target group target group , collection < baragon agent metadata > agents , collection < target description > targets ) { collection < target description > removable targets = list removable targets ( traffic source , baragon group , targets , agents ) ; for ( target description removable target : removable targets ) { try { if ( configuration . is present ( ) && ! configuration . get ( ) . is remove last healthy enabled ( ) && is last healthy instance ( removable target , target group ) ) { log . info ( str , removable target , target group ) ; } else { elb client . deregister targets ( new deregister targets request ( ) . with target group arn ( target group . get target group arn ( ) ) . with targets ( removable target ) ) ; log . info ( str , removable target , target group ) ; } } catch ( amazon client exception acexn ) { log . error ( str , removable target , target group , acexn ) ; exception notifier . notify ( acexn , immutable map . of ( str , target group . get target group name ( ) ) ) ; } } }	De-register any targets representing agents that are not known to the BaragonService,or which otherwise need to be removed.
private void guarantee same vpc ( target group target group , collection < baragon agent metadata > agents , collection < load balancer > load balancers ) { string vpc id = target group . get vpc id ( ) ; for ( baragon agent metadata agent : agents ) { if ( agent . get ec2 ( ) . get vpc id ( ) . is present ( ) ) { if ( ! agent . get ec2 ( ) . get vpc id ( ) . get ( ) . equals ( vpc id ) ) { log . error ( str , agent , target group ) ; throw new illegal state exception ( string . format ( str , agent , target group ) ) ; } } else { log . error ( str , agent ) ; throw new illegal state exception ( string . format ( str , agent ) ) ; } } for ( load balancer load balancer : load balancers ) { if ( ! vpc id . equals ( load balancer . get vpc id ( ) ) ) { log . error ( str , load balancer , target group ) ; throw new illegal state exception ( string . format ( str , load balancer , target group ) ) ; } } }	When this method completes, the target group, the agents, and the loadBalancers areall on the same VPC.The target group, each of the agents, and each of the load balancers should thinkthat they are on the same VPC, otherwise they won't be able to talk to each other.
public void set href ( string href ) { if ( href . contains ( str ) ) { try { href = url . decode ( href , str ) ; } catch ( unsupported encoding exception e ) { throw new runtime exception ( e ) ; } } this . href = new uri template ( href ) ; }	backwards compatibility, would be canged in next version.
static member key new instance ( object context object , string name ) { if ( context object instanceof class < ? > ) { class < ? > clazz = ( class < ? > ) context object ; if ( clazz . is enum ( ) && ( str . equals ( name ) || reflections . is constant name ( clazz , name ) ) ) {	Simple factory method to obtain a new instance for the given contextobject and name.
private void line separator found ( string line separator ) { flush text ( ) ; flush line separator ( line separator ) ; line ++ ; state = state . text ; separator idx = num ; }	Line separator end - flush.
private void flush tag ( ) { state = state . text ; handler . tag ( derive tag ( buffer . to string ( ) ) ) ; delimiter idx = num ; clear buffer ( ) ; }	Real tag end - flush.
private string extract content ( mustache tag type tag type , string buffer ) { switch ( tag type ) { case variable : return buffer . trim ( ) ; case unescape variable : return ( buffer . char at ( num ) == ( ( string ) engine configuration key . start delimiter . get default value ( ) ) . char at ( num ) ? buffer . substring ( num , buffer . length ( ) - num ) . trim ( ) : buffer . substring ( num ) . trim ( ) ) ; case section : case inverted section : case partial : case extend : case extend section : case section end : case nested template : case comment : return buffer . substring ( num ) . trim ( ) ; case delimiter : return buffer . trim ( ) ; default : return null ; } }	Extract the tag content.
private static list < list < segment base > > read segment lines ( container segment base container ) { list < list < segment base > > lines = new array list < > ( ) ;	Read segment lines recursively.
public static pattern new mustache tag pattern ( configuration configuration ) { string builder regex = new string builder ( ) ; regex . append ( pattern . quote ( configuration . get string property value ( engine configuration key . start delimiter ) ) ) ; regex . append ( str ) ; regex . append ( pattern . quote ( configuration . get string property value ( engine configuration key . end delimiter ) ) ) ; return pattern . compile ( regex . to string ( ) ) ; }	Delimiters are quoted to avoid regexp reserved characters conflict.
public static < t > decorator < t > decorate ( t delegate , map < string , function < t , object > > mappings , string delegate key , configuration configuration ) { return iterable decorator . is iterable ( delegate ) ? new iterable decorator < > ( delegate , immutable map . copy of ( mappings ) , delegate key , configuration ) : new decorator < > ( delegate , immutable map . copy of ( mappings ) , delegate key , configuration ) ; }	Returns a decorator instance for the specified delegate and mappings.
@ suppress warnings ( str ) public static < t > t unwrap ( t instance ) { return instance instanceof decorator ? unwrap ( ( ( decorator < t > ) instance ) . delegate ) : instance ; }	This method is recursive.
public synchronized mustache engine build ( ) { mustache engine engine = new default mustache engine ( this ) ; for ( engine built callback callback : engine ready callbacks ) { callback . engine built ( engine ) ; } build info build info = build info . load ( ) ; logger . info ( str , build info . get version ( ) , build info . get timestamp date ( ) ) ; logger . debug ( str , engine . get configuration ( ) . get info ( ) ) ; is built = bool ; return engine ; }	Builds the engine instance.
public mustache engine builder add template locator ( template locator locator ) { check argument not null ( locator ) ; check not built ( ) ; this . template locators . add ( locator ) ; return this ; }	Adds a template locator.
public mustache engine builder add resolver ( resolver resolver ) { check argument not null ( resolver ) ; check not built ( ) ; this . resolvers . add ( resolver ) ; return this ; }	Adds a value resolver.
public mustache engine builder register callback ( engine built callback callback ) { check argument not null ( callback ) ; check not built ( ) ; this . engine ready callbacks . add ( callback ) ; return this ; }	Callback is useful to configure a component instantiated before theengine is built.
public mustache engine builder add value converter ( value converter converter ) { check argument not null ( converter ) ; check not built ( ) ; this . value converters . add ( converter ) ; return this ; }	Add a value converter.
public mustache engine builder add context converter ( context converter converter ) { check argument not null ( converter ) ; check not built ( ) ; this . context converters . add ( converter ) ; return this ; }	Add a context converter.
public static string capitalize fully ( string text , character delimiter ) { if ( is empty ( text ) ) { return text ; } text = text . to lower case ( ) ; boolean capitalize next = bool ; string builder builder = new string builder ( ) ; for ( int i = num ; i < text . length ( ) ; i ++ ) { final char ch = text . char at ( i ) ; if ( delimiter . equals ( ch ) ) { capitalize next = bool ; builder . append ( ch ) ; } else if ( capitalize next ) { builder . append ( character . to title case ( ch ) ) ; capitalize next = bool ; } else { builder . append ( ch ) ; } } return builder . to string ( ) ; }	Capitalizes all the delimiter separated words.
protected void append ( options options , char sequence sequence ) { text support text support = this . text support ; if ( text support == null || is unescape variable ( options ) ) { options . append ( sequence ) ; } else { try { text support . append escaped html ( sequence . to string ( ) , options . get appendable ( ) ) ; } catch ( io e ) { throw new mustache exception ( mustache problem . render io error , e ) ; } } }	Escape appended sequence if needed.
private computing cache < string , optional < string > > build source cache ( ) { return build cache ( str , key -> optional . of nullable ( locate and read ( key ) ) , ( key , cause ) -> logger . debug ( str , key , cause ) ) ; }	Properties of the source cache are dependent on that of the templatecache.
private void push ( container segment base container ) { container stack . add first ( container ) ; logger . trace ( str , container . get type ( ) , container . get content ( ) ) ; }	Push the container wrapper on the stack.
private void add segment ( segment base segment ) { container stack . peek first ( ) . add segment ( segment ) ; logger . trace ( str , segment ) ; }	Add the segment to the container on the stack.
private root segment base validate ( ) { container segment base root = container stack . peek first ( ) ; if ( ! ( root instanceof root segment base ) ) { throw new mustache exception ( mustache problem . compile invalid template , str , container stack . peek first ( ) . to string ( ) , line ) ; } return ( root segment base ) root ; }	Validate the compiled template.
static iterator < string > split helper name ( string name , segment segment ) { boolean string literal = bool ; boolean array literal = bool ; boolean space = bool ; list < string > parts = new array list < > ( ) ; string builder buffer = new string builder ( ) ; for ( int i = num ; i < name . length ( ) ; i ++ ) { if ( name . char at ( i ) == str ) { if ( ! space ) { if ( ! string literal && ! array literal ) { if ( buffer . length ( ) > num ) { parts . add ( buffer . to string ( ) ) ; buffer = new string builder ( ) ; } space = bool ; } else { buffer . append ( name . char at ( i ) ) ; } } } else { if ( ! array literal && strings . is string literal separator ( name . char at ( i ) ) ) { string literal = ! string literal ; } else if ( ! string literal && strings . is list literal start ( name . char at ( i ) ) ) { array literal = bool ; } else if ( ! string literal && strings . is list literal end ( name . char at ( i ) ) ) { array literal = bool ; } space = bool ; buffer . append ( name . char at ( i ) ) ; } } if ( buffer . length ( ) > num ) { if ( string literal || array literal ) { throw new mustache exception ( mustache problem . compile helper validation failure , str , segment ) ; } parts . add ( buffer . to string ( ) ) ; } return parts . iterator ( ) ; }	Extracts parts from an input string.
public static < t > builder < t > decorate ( class < t > delegate type ) { return decorate ( o -> ( delegate type . is assignable from ( decorator . unwrap ( o ) . get class ( ) ) ) ) ; }	Returns a decorator converter builder for the specified delegate type.
private void flush ( ) { try { parent . append ( future . get ( num , time unit . seconds ) . collect ( this ) ) ; parent . append ( buffer ) ; if ( parent instanceof async appendable ) { ( ( async appendable ) parent ) . flush ( ) ; } } catch ( exception e ) { throw new mustache exception ( mustache problem . render async processing error , e ) ; } }	Append the result to the parent.
static field find field ( class < ? > clazz , string name ) { check argument not null ( clazz ) ; check argument not null ( name ) ; field found = null ; for ( field field : security actions . get fields ( clazz ) ) { if ( field . get name ( ) . equals ( name ) ) { found = field ; } } logger . debug ( str , name , found != null ? str : str , clazz . get name ( ) ) ; return found ; }	Tries to find a public field with the given name on the given class.
public static void register helpers ( configuration extension builder builder , map < string , helper > helpers ) { checker . check arguments not null ( builder , helpers ) ; for ( entry < string , helper > entry : helpers . entry set ( ) ) { register helper ( builder , entry . get key ( ) , entry . get value ( ) ) ; } }	Register helper and do nothing if a helper with the same name is already registered.
public static void register helper ( configuration extension builder builder , string name , helper helper ) { checker . check arguments not null ( builder , name , helper ) ; try { builder . register helper ( name , helper ) ; } catch ( illegal argument exception ignored ) { } }	Register helpers and do nothing if a helper with the same name is already registered.
static list < list < segment > > read segment lines before rendering ( abstract container segment container ) { list < list < segment > > lines = new array list < > ( ) ; list < segment > current line = new array list < > ( ) ; for ( segment segment : container ) { if ( ! segment type . line separator . equals ( segment . get type ( ) ) ) { current line . add ( segment ) ; } else {	Read segment lines before rendering.
public void invalidate fragments ( final string key part ) { if ( fragments == null || key part == null ) { return ; } fragments . invalidate ( fragment key -> fragment key . get key ( ) . contains ( key part ) ) ; }	Invalidate the cache fragments whose key contains the given part of thekey.
public static storage ext get local storage ( ) { if ( local storage == null && storage . is local storage supported ( ) ) { local storage = new storage ext ( storage . get local storage if supported ( ) ) ; } return local storage ; }	Returns a Local Storage.
public static storage ext get session storage ( ) { if ( session storage == null && storage . is session storage supported ( ) ) { session storage = new storage ext ( storage . get session storage if supported ( ) ) ; } return session storage ; }	Returns a Session Storage.
public void clear ( ) { storage . clear ( ) ; cache . clear ( ) ; fire event ( storage change event . change type . clear , null , null , null , null , null ) ; }	Removes all items in the Storage, and its cache if activated.
public < t > boolean contains key ( storage key < t > key ) { return storage . get item ( key . name ( ) ) != null ; }	Test if this storage contains a value for the specified key. {.
public < t > void put ( storage key < t > key , t value ) throws serialization exception , storage quota exceeded exception { if ( value == null ) { throw new null pointer exception ( ) ; } try { string data = storage utils . serialize ( key . get clazz ( ) , value ) ;	Store the specified value with the specified key in this storage.
public < t extends serializable > void remove ( storage key < t > key ) { string data = storage . get item ( key . name ( ) ) ; storage . remove item ( key . name ( ) ) ; t value = cache . remove ( key ) ; fire event ( storage change event . change type . remove , key , null , value , null , data ) ; }	Removes the record for the specified key from this storage if present. {.
@ deprecated public static < t > storage key < t > object key ( string key name ) { return new storage key < > ( key name , object . class ) ; }	Returns non-primitive type value's storage key.
public static < t extends is serializable > storage key < t > is serializable key ( string key name ) { return new storage key < > ( key name , is serializable . class ) ; }	Returns IsSerializable type value's storage key.
public static < t extends serializable > storage key < t > serializable key ( string key name ) { return new storage key < > ( key name , serializable . class ) ; }	Returns Serializable type value's storage key.
private void obtain size ( @ non null final typed array typed array ) { size default size = size . normal ; size = size . from value ( typed array . get int ( r . styleable . size , default size . get value ( ) ) ) ; }	Obtains the floating action button's size from a specific typed array.
private void obtain color ( @ non null final typed array typed array ) { int default color = theme util . get color ( get context ( ) , r . attr . color accent ) ; color = typed array . get color ( r . styleable . android color , default color ) ; }	Obtains the floating action button's color from a specific typed array.
private void obtain activated color ( @ non null final typed array typed array ) { int default activated color = get control activated color ( ) ; activated color = typed array . get color ( r . styleable . activated color , default activated color ) ; }	Obtains the floating action button's activated color from a specific typed array.
private void obtain pressed color ( @ non null final typed array typed array ) { int default pressed color = get control highlight color ( ) ; pressed color = typed array . get color ( r . styleable . pressed color , default pressed color ) ; }	Obtains the floating action button's pressed color from a specific typed array.
private void obtain disabled color ( @ non null final typed array typed array ) { int default disabled color = context compat . get color ( get context ( ) , r . color . floating action button disabled color ) ; disabled color = typed array . get color ( r . styleable . disabled color , default disabled color ) ; }	Obtains the floating action button's disabled color from a specific typed array.
private void obtain icon ( @ non null final typed array typed array ) { drawable icon = typed array . get drawable ( r . styleable . android icon ) ; set icon ( icon ) ; }	Obtains the floating action button's icon from a specific typed array.
private void obtain visibility animation duration ( @ non null final typed array typed array ) { int default animation duration = get resources ( ) . get integer ( r . integer . floating action button visibility animation duration ) ; int duration = typed array . get integer ( r . styleable . visibility animation duration , default animation duration ) ; set visibility animation duration ( duration ) ; }	Obtains the duration of the animation, which may be used to changed the visibility of thefloating action button, from a specific typed array.
private void adapt shadow ( ) { if ( get size ( ) == size . normal ) { set background resource ( r . drawable . floating action button shadow normal ) ; } else if ( get size ( ) == size . small ) { set background resource ( r . drawable . floating action button shadow small ) ; } else { set background resource ( r . drawable . floating action button shadow large ) ; } }	Adapts the shadow of the floating action button, depending on its size.
private void adapt image button size ( ) { int pixel size = get pixel size ( ) ; layout params layout params = ( layout params ) image button . get layout params ( ) ; layout params . width = pixel size ; layout params . height = pixel size ; image button . set layout params ( layout params ) ; image button . request layout ( ) ; }	Adapts the size of the image button, which is used to show the floating image button'sbackground and icon, depending on the floating button's size.
@ suppress lint ( str ) private void adapt image button background ( ) { drawable background = create state list background drawable ( ) ; if ( build . version . sdk int >= build . version codes . lollipop ) { drawable ripple drawable = new ripple drawable ( new color state list ( new int [ ] [ ] { { } } , new int [ ] { get pressed color ( ) } ) , background , null ) ; view util . set background ( image button , ripple drawable ) ; } else { view util . set background ( image button , background ) ; } }	Adapts the background of the image button, which is used to show the floating image button'sbackground and icon, depending on the floating button's colors.
private drawable create state list background drawable ( ) { state list drawable drawable = new state list drawable ( ) ; if ( build . version . sdk int < build . version codes . lollipop ) { drawable . add state ( new int [ ] { android . r . attr . state enabled , android . r . attr . state pressed } , create pressed background drawable ( ) ) ; } drawable . add state ( new int [ ] { android . r . attr . state enabled , android . r . attr . state activated } , create activated background drawable ( ) ) ; drawable . add state ( new int [ ] { android . r . attr . state enabled } , create background drawable ( get color ( ) ) ) ; drawable . add state ( new int [ ] { } , create disabled background drawable ( ) ) ; return drawable ; }	Creates and returns a state list drawable, which can be used as the floating action buttonbackground and adapts the background color depending on the button's current state.
private drawable create activated background drawable ( ) { drawable drawable = create background drawable ( get color ( ) ) ; drawable hover drawable = create background drawable ( get activated color ( ) ) ; return new layer drawable ( new drawable [ ] { drawable , hover drawable } ) ; }	Creates and returns a drawable, which can be used as the floating action button's background,when it is activated.
private drawable create pressed background drawable ( ) { drawable drawable = create background drawable ( get color ( ) ) ; drawable hover drawable = create background drawable ( get pressed color ( ) ) ; return new layer drawable ( new drawable [ ] { drawable , hover drawable } ) ; }	Creates and returns a drawable, which can be used as the floating action button's background,when it is pressed.
private drawable create disabled background drawable ( ) { drawable drawable = create background drawable ( get color ( ) ) ; drawable hover drawable = create background drawable ( get disabled color ( ) ) ; return new layer drawable ( new drawable [ ] { drawable , hover drawable } ) ; }	Creates and returns a drawable, which can be used as the floating action button's background,when it is disabled.
private drawable create background drawable ( @ color int final int color ) { oval shape shape = new oval shape ( ) ; shape drawable drawable = new shape drawable ( shape ) ; drawable . get paint ( ) . set color ( color ) ; return drawable ; }	Creates and returns a drawable with a specific color, which can be used as the floatingaction button's background.
private int get pixel size ( ) { if ( get size ( ) == size . normal ) { return get resources ( ) . get dimension pixel size ( r . dimen . floating action button size normal ) ; } else if ( get size ( ) == size . small ) { return get resources ( ) . get dimension pixel size ( r . dimen . floating action button size small ) ; } else { return get resources ( ) . get dimension pixel size ( r . dimen . floating action button size large ) ; } }	Returns the size of the floating action button in pixels, depending on its current size.
private void animate visibility ( final int visibility , final long duration ) { if ( visibility animator != null ) { visibility animator . cancel ( ) ; } animator listener listener = create visibility animator listener ( visibility ) ; float target scale = visibility == view . visible ? num : num ; long animation duration = math . round ( math . abs ( get scale x ( ) - target scale ) * duration ) ; interpolator interpolator = new accelerate decelerate interpolator ( ) ; visibility animator = animate ( ) . set interpolator ( interpolator ) . scale x ( target scale ) . scale y ( target scale ) . set duration ( animation duration ) . set listener ( listener ) ; }	Animates changing the visibility of the floating action button.
private animator listener create visibility animator listener ( final int visibility ) { return new animator listener ( ) { @ override public void on animation start ( final animator animation ) { if ( visibility == view . visible ) { floating action button . super . set visibility ( visibility ) ; } } @ override public void on animation repeat ( final animator animation ) { } @ override public void on animation end ( final animator animation ) { floating action button . super . set visibility ( visibility ) ; visibility animator = null ; } @ override public void on animation cancel ( final animator animation ) { visibility animator = null ; } } ; }	Creates and returns a listener, which allows to adapt the visibility of the floating actionbutton, depending on the progress of an animation, which is used to change the visibility.
public final void set size ( @ non null final size size ) { condition . instance . ensure not null ( size , str ) ; this . size = size ; adapt shadow ( ) ; adapt image button size ( ) ; request layout ( ) ; }	Sets the floating action button's size.
private void obtain thickness ( @ non null final typed array typed array ) { int default thickness = get context ( ) . get resources ( ) . get dimension pixel size ( r . dimen . circular progress bar thickness normal ) ; thickness = typed array . get dimension pixel size ( r . styleable . android thickness , default thickness ) ; }	Obtains the progress bar's thickness from a specific typed array.
private void initialize paint ( ) { paint = new paint ( ) ; paint . set anti alias ( bool ) ; paint . set style ( paint . style . stroke ) ; paint . set stroke width ( get thickness ( ) ) ; paint . set color ( get color ( ) ) ; }	Initializes the paint, which is used for drawing.
private void initialize angle animator ( ) { angle animator = object animator . of float ( this , create angle property ( ) , max degrees ) ; angle animator . set interpolator ( new linear interpolator ( ) ) ; angle animator . set duration ( angle animation duration ) ; angle animator . set repeat mode ( value animator . restart ) ; angle animator . set repeat count ( value animator . infinite ) ; }	Initializes the angle animator.
private property < circular progress drawable , float > create angle property ( ) { return new property < circular progress drawable , float > ( float . class , str ) { @ override public float get ( final circular progress drawable object ) { return current global angle ; } @ override public void set ( final circular progress drawable object , final float value ) { current global angle = value ; invalidate self ( ) ; } } ; }	Creates and returns a property, which allows to animate the global angle of the progressdrawable.
private void initialize sweep animator ( ) { sweep animator = object animator . of float ( this , create sweep property ( ) , max degrees - min sweep angle * num ) ; sweep animator . set interpolator ( new decelerate interpolator ( ) ) ; sweep animator . set duration ( sweep animation duration ) ; sweep animator . set repeat mode ( value animator . restart ) ; sweep animator . set repeat count ( value animator . infinite ) ; sweep animator . add listener ( create sweep animator listener ( ) ) ; }	Initializes the sweep animator.
private property < circular progress drawable , float > create sweep property ( ) { return new property < circular progress drawable , float > ( float . class , str ) { @ override public float get ( final circular progress drawable object ) { return current sweep angle ; } @ override public void set ( final circular progress drawable object , final float value ) { current sweep angle = value ; invalidate self ( ) ; } } ; }	Creates and returns a property, which allows to animate the sweep angle of the progressdrawable.
private animator listener create sweep animator listener ( ) { return new animator listener ( ) { @ override public void on animation start ( final animator animation ) { } @ override public void on animation end ( final animator animation ) { } @ override public void on animation cancel ( final animator animation ) { } @ override public void on animation repeat ( final animator animation ) { appearing = ! appearing ; if ( appearing ) { current global angle offset = ( current global angle offset + min sweep angle * num ) % max degrees ; } } } ; }	Creates and returns a listener, which allows to restart the progress drawable's animation,when it has been finished.
private void initialize floating action buttons ( ) { small floating action button = find view by id ( r . id . floating action button small ) ; small floating action button . set on click listener ( create floating action button listener ( ) ) ; normal floating action button = find view by id ( r . id . floating action button normal ) ; normal floating action button . set on click listener ( create floating action button listener ( ) ) ; large floating action button = find view by id ( r . id . floating action button large ) ; large floating action button . set on click listener ( create floating action button listener ( ) ) ; }	Initializes the floating action buttons.
private on click listener create floating action button listener ( ) { return new on click listener ( ) { @ override public void on click ( final view v ) { toast toast = toast . make text ( main activity . this , r . string . floating action button toast , toast . length short ) ; toast . show ( ) ; } } ; }	Creates and returns a listener, which allows to show a toast when a floating action buttonhas been clicked.
private void initialize hide floating action buttons button ( ) { button button = find view by id ( r . id . hide floating action buttons ) ; button . set on click listener ( create hide floating action buttons listener ( ) ) ; }	Initializes the button, which allows to show or hide the floating action buttons.
private on click listener create hide floating action buttons listener ( ) { return new on click listener ( ) { @ override public void on click ( final view v ) { int visibility = floating action buttons visible ? view . invisible : view . visible ; small floating action button . set visibility ( visibility , bool ) ; normal floating action button . set visibility ( visibility , bool ) ; large floating action button . set visibility ( visibility , bool ) ; floating action buttons visible = ! floating action buttons visible ; } } ; }	Creates and returns a listener, which allows to show or hide the floating action buttons.
private void initialize chips ( ) { chip closable chip light = find view by id ( r . id . chip closable light ) ; closable chip light . add close listener ( create chip close listener ( ) ) ; chip closable chip dark = find view by id ( r . id . chip closable dark ) ; closable chip dark . add close listener ( create chip close listener ( ) ) ; chip closable icon chip light = find view by id ( r . id . chip icon closable light ) ; closable icon chip light . add close listener ( create chip close listener ( ) ) ; chip closable icon chip dark = find view by id ( r . id . chip icon closable dark ) ; closable icon chip dark . add close listener ( create chip close listener ( ) ) ; }	Initializes all closable chips.
private chip . close listener create chip close listener ( ) { return new chip . close listener ( ) { @ override public void on chip closed ( @ non null final chip chip ) { chip . set visibility ( view . gone ) ; toast . make text ( main activity . this , r . string . chip closed toast , toast . length short ) . show ( ) ; } } ; }	Creates and returns a listener, which allows to show a toast, when a chip has been closed.
private void handle saved instance state ( @ nullable final bundle saved instance state ) { if ( saved instance state != null ) { floating action buttons visible = saved instance state . get boolean ( floating action buttons visible extra ) ; int visibility = floating action buttons visible ? view . visible : view . invisible ; small floating action button . set visibility ( visibility ) ; normal floating action button . set visibility ( visibility ) ; large floating action button . set visibility ( visibility ) ; } }	Adapts the activity's views depending on the saved instance state, which has been passed tothe activity.
private void obtain text ( @ non null final typed array typed array ) { set text ( typed array . get text ( r . styleable . android text ) ) ; }	Obtains the chip's text from a specific typed array.
private void obtain text color ( @ non null final typed array typed array ) { int default color = context compat . get color ( get context ( ) , r . color . chip text color light ) ; set text color ( typed array . get color ( r . styleable . android text color , default color ) ) ; }	Obtains the chip's text color from a specific typed array.
private void obtain color ( @ non null final typed array typed array ) { int default color = context compat . get color ( get context ( ) , r . color . chip color light ) ; set color ( typed array . get color ( r . styleable . android color , default color ) ) ; }	Obtains the chip's color from a specific typed array.
private void obtain icon ( @ non null final typed array typed array ) { set icon ( typed array . get drawable ( r . styleable . android icon ) ) ; }	Obtains the chip's icon from a specific typed array.
private void obtain closable ( @ non null final typed array typed array ) { set closable ( typed array . get boolean ( r . styleable . closable , bool ) ) ; }	Obtains, whether the chip should be closable, or not, from a specific typed array.
private void obtain close icon ( @ non null final typed array typed array ) { drawable icon = typed array . get drawable ( r . styleable . close button icon ) ; if ( icon != null ) { set close button icon ( icon ) ; } }	Obtains the icon of the button, which allows to close the chip, from a specific typed array.
public final void add close listener ( @ non null final close listener listener ) { condition . instance . ensure not null ( listener , str ) ; listeners . add ( listener ) ; }	Adds a new listener, which should be notified, when the chip has been closed.
public final void remove close listener ( @ non null final close listener listener ) { condition . instance . ensure not null ( listener , str ) ; listeners . remove ( listener ) ; }	Removes a specific listener, which should not be notified, when the chip has been closed,anymore.
public final void set color ( @ color int final int color ) { this . color = color ; get background ( ) . set color filter ( color , porter duff . mode . src in ) ; }	Sets the chip's color.
public final void set closable ( final boolean closable ) { this . closable = closable ; if ( closable ) { close button . set visibility ( view . visible ) ; text view . set padding ( text view . get padding left ( ) , text view . get padding top ( ) , num , text view . get padding bottom ( ) ) ; } else { close button . set visibility ( view . gone ) ; text view . set padding ( text view . get padding left ( ) , text view . get padding top ( ) , get resources ( ) . get dimension pixel size ( r . dimen . chip horizontal padding ) , text view . get padding bottom ( ) ) ; } }	Sets, whether the chip is closable, or not.
@ suppress warnings ( str ) public map < string , string > get partials ( ) { final view view = this . get view ( ) ; if ( view != null && view instanceof mustache view ) { mustache view mustache view = ( mustache view ) view ; return mustache view . get aliases ( ) ; } else { final object object = get model map ( ) . get ( mustache settings . partials key ) ; if ( object != null && ! ( object instanceof map ) ) { throw new mustache partials mapping exception ( ) ; } final map < string , string > map ; if ( object == null ) { map = new hash map < string , string > ( ) ; } else { map = ( map < string , string > ) object ; } return map ; } }	Get current partials stored in view.
public static script engine get engine ( collection < input stream > scripts ) { script engine engine = get engine ( ) ; for ( input stream script : scripts ) { evaluate ( engine , script ) ; } return engine ; }	Get new nashorn engine.
public map < string , string > get layout mappings ( ) { string mappings values = environment . get property ( str , mustache settings . layout mappings ) . trim ( ) ; if ( mappings values . is empty ( ) ) { return empty map ( ) ; } map < string , string > mappings = new hash map < string , string > ( ) ; string [ ] values = mappings values . split ( str ) ; if ( values . length > num ) { for ( string value : values ) { string val = value == null ? str : value . trim ( ) ; if ( val . is empty ( ) ) { continue ; } string [ ] mapping = val . split ( str ) ; if ( mapping . length != num ) { throw new illegal argument exception ( str ) ; } mappings . put ( mapping [ num ] . trim ( ) , mapping [ num ] . trim ( ) ) ; } } return unmodifiable map ( mappings ) ; }	Get mappings to use with resolvers.
public static boolean is present ( string klass ) { has text ( klass , str ) ; try { class . for name ( klass ) ; return bool ; } catch ( exception ex ) { return bool ; } }	Check that a given class is available onclasspath.
@ suppress warnings ( str ) public static < t > t get annotation value ( annotation metadata importing class metadata , class annotation class , string name , t default value ) { map < string , object > attributes = importing class metadata . get annotation attributes ( annotation class . get name ( ) ) ; return attributes != null && attributes . contains key ( name ) ? ( t ) attributes . get ( name ) : default value ; }	Get annotation method value.
public static input stream get stream ( string name ) { resource pattern resolver resolver = new path matching resource pattern resolver ( io . class . get class loader ( ) ) ; input stream stream = get input stream with resolver ( resolver , name ) ;	Return an input stream from given name.Name is searched into the classpath.Name can contains ant style pattern.
public static input stream get first available stream ( collection < string > names ) { resource pattern resolver resolver = new path matching resource pattern resolver ( io . class . get class loader ( ) ) ; for ( string name : names ) { try { input stream stream = get input stream with resolver ( resolver , name ) ; if ( stream != null ) { return stream ; } } catch ( io ex ) {	Return an input stream from given names.First result returning a valid stream is returned.Names are searched into the classpath.Names can contains ant style pattern.
public string render ( string template , map < string , object > model ) { try { invocable invocable = ( invocable ) engine ; return ( string ) invocable . invoke function ( str , template , model , partials ) ; } catch ( script exception ex ) { throw new nashorn exception ( ex ) ; } catch ( no such method exception ex ) { throw new nashorn exception ( ex ) ; } }	Render template with given model object.
public void add aliases ( map < string , string > aliases ) { not null ( aliases , str ) ; for ( map . entry < string , string > entry : aliases . entry set ( ) ) { add alias ( entry . get key ( ) , entry . get value ( ) ) ; } }	Add partials mapping.
public void add alias ( string key , string value ) { this . aliases . put ( not null ( key , str ) , not null ( value , str ) ) ; }	Add alias mapping.
@ non null public final synchronized chronos listener get listener ( final int id ) { chronos listener chronos listener = m listeners . get ( id ) ; if ( chronos listener == null ) { chronos listener = new chronos listener ( id ) ; m listeners . put ( id , chronos listener ) ; } return chronos listener ; }	Gets previously created ServiceConnector by its id.
@ non null public static < output > chronos operation result < output > run ( @ non null final chronos operation < output > operation ) { return chronos service . get instance ( ) . run sync ( operation , bool ) ; }	Runs operation synchronously.
@ contract ( pure = bool ) private static boolean is callback ( @ non null final method method , @ non null final class < ? > result class , @ non null final string method name ) { if ( method . get name ( ) . equals ( method name ) ) { if ( method . get return type ( ) == void . type ) { final class < ? > [ ] parameters = method . get parameter types ( ) ; if ( parameters . length == num && parameters [ num ] . is assignable from ( result class ) ) { return bool ; } } } return bool ; }	Checks if a method can be used as a callback to handle operation result.
public final void on resume ( @ non null final object service listener ) { logd ( str ) ; m service listener = service listener ; m state = state . resumed ; if ( ! m stored results . is empty ( ) ) { logd ( str ) ; final list < soft reference < operation delivery < ? > > > old results = new array list < > ( m stored results ) ; m stored results . clear ( ) ; for ( soft reference < operation delivery < ? > > result : old results ) { final operation delivery < ? > delivery = result . get ( ) ; if ( delivery != null ) { deliver result ( delivery ) ; } } logd ( str ) ; } else { logd ( str ) ; } }	This method must be called by a bound GUI element when it passes its own onResume state.
@ suppress warnings ( str ) public final void on event main thread ( @ nullable final chronos operation result < ? > operation result ) { if ( operation result == null ) {	This method is used to listening to results stream and operate with them.
public final int invoke ( @ non null final chronos operation < ? > operation , final boolean broadcast result ) { logd ( str ) ; final int id = chronos service . get instance ( ) . run async ( operation , broadcast result ) ; m untagged requests . add ( id ) ; return id ; }	Launches an operation in background thread.
public final int invoke ( @ non null final chronos operation < ? > operation , @ non null final string tag , final boolean broadcast result ) { logd ( str + tag ) ; final integer saved id = m tagged requests . get ( tag ) ; if ( saved id != null && is running ( saved id ) ) { logd ( str + tag + str ) ; return saved id ; } logd ( str + tag + str ) ; final int id = chronos service . get instance ( ) . run async ( operation , broadcast result ) ; m tagged requests . put ( tag , id ) ; return id ; }	Launches an operation in background thread.
@ contract ( pure = bool ) public final boolean is running ( @ non null final string tag ) { final integer id = m tagged requests . get ( tag ) ;	Checks if an operation with given launch tag is running.
private void on operation finished ( @ non null final operation delivery < ? > operation result ) { logd ( str + operation result ) ; switch ( m state ) { case paused : store result ( operation result ) ; break ; case resumed : deliver result ( operation result ) ; break ; default : throw new illegal state exception ( str + m state ) ; } }	A dispatcher method which decides what to do with an operation result.
private void store result ( @ non null final operation delivery < ? > operation delivery ) { logd ( str + operation delivery ) ; m stored results . add ( new soft reference < operation delivery < ? > > ( operation delivery ) ) ; }	Storing an operation result to use it later.
private void deliver result ( @ non null final operation delivery < ? > operation delivery ) { logd ( str + operation delivery ) ; switch ( operation delivery . get delivery mode ( ) ) { case normal : deliver result ( operation delivery . get result ( ) , chronos . own callback method name , bool ) ; break ; case broadcast : deliver result ( operation delivery . get result ( ) , chronos . broadcast callback method name , bool ) ; break ; default : break ; } }	Delivers an operation result to the bound client.
@ suppress warnings ( str ) private void deliver result ( @ non null final chronos operation result < ? > operation result , @ non null final string method name , final boolean warn if no callback ) { final class listener class = m service listener . get class ( ) ; final method [ ] listener methods = listener class . get methods ( ) ; method callback method = null ; final class result class = operation result . get class ( ) ; for ( method method : listener methods ) { if ( is callback ( method , result class , method name ) ) { callback method = method ; try { callback method . invoke ( m service listener , operation result ) ; } catch ( illegal access exception e ) { log . w ( log tag , log . get stack trace string ( e ) ) ; } catch ( invocation target exception e ) { log . w ( log tag , log . get stack trace string ( e ) ) ; } } } if ( warn if no callback && callback method == null ) { log . w ( log tag , str + operation result . get id ( ) + str + operation result . get class ( ) . get name ( ) + str + m service listener + str ) ; log . w ( log tag , str ) ; log . w ( log tag , str + method name + str + result class . get name ( ) + str ) ; } }	Call bound client methods to pass an operation result.
private synchronized boolean cancel ( final int id , final boolean may interrupt , final boolean remove operation ) { final running operation running operation = m running operations . get ( id ) ; if ( running operation != null ) { if ( remove operation ) { m running operations . remove ( id ) ; } m cancelled operations . add ( id ) ; return running operation . cancel ( may interrupt ) ; } else { return bool ; } }	Cancels running operation.
synchronized final void operation started ( final int id , @ non null final chronos operation < ? > operation , @ non null final future < ? > future ) { m running operations . put ( id , new running operation ( operation , future ) ) ; }	Stores the future as a running operation with a given runs' id.
synchronized final void cancel all ( final boolean may interrupt ) { for ( final integer key : m running operations . key set ( ) ) { cancel ( key , may interrupt , bool ) ; } m running operations . clear ( ) ; }	Cancels all running operations.
@ contract ( pure = bool ) synchronized final boolean is operation cancelled ( final int id ) { return m cancelled operations . contains ( integer . value of ( id ) ) ; }	Checks if operation launch with given id was cancelled.
private static < output > void silent run ( @ non null final chronos operation < output > operation , @ non null final chronos operation result < output > operation result ) { try { final output output = operation . run ( ) ; operation result . set output ( output ) ; } catch ( exception e ) { operation result . set exception ( e ) ; } }	Runs operation, handling all the exceptions that may ne thrown while running.
@ non null @ contract ( pure = bool ) private < output > chronos operation result < output > create empty result ( @ non null final chronos operation < output > operation , final boolean broadcast result ) { final chronos operation result < output > operation result ; final class < ? extends chronos operation result < output > > result class = operation . get result class ( ) ; try { operation result = result class . new instance ( ) ; } catch ( instantiation exception e ) { throw new runtime exception ( str + result class . get name ( ) ) ; } catch ( illegal access exception e ) { throw new runtime exception ( result class . get name ( ) + str ) ; } operation result . set id ( m last operation id . increment and get ( ) ) ; operation result . set operation ( operation ) ; operation result . set broadcast ( broadcast result ) ; return operation result ; }	Creates a template object for storing operations' run result.
final < output > int run async ( @ non null final chronos operation < output > operation , final boolean broadcast result ) { final chronos operation result < output > result = create empty result ( operation , broadcast result ) ; final int id = result . get id ( ) ; synchronized ( chronos service . this ) { running operation storage . get instance ( ) . operation started ( id , operation , m executor service . submit ( new runnable ( ) { @ override public void run ( ) { silent run ( operation , result ) ; m event bus . post ( result ) ; synchronized ( chronos service . this ) { running operation storage . get instance ( ) . operation finished ( id ) ; } } } ) ) ; } return id ; }	Runs operation in background.
@ non null final < output > chronos operation result < output > run sync ( @ non null final chronos operation < output > operation , final boolean broadcast result ) { final chronos operation result < output > result = create empty result ( operation , broadcast result ) ; silent run ( operation , result ) ; m event bus . post ( result ) ; return result ; }	Runs operation in the same thread.
public void on operation finished ( final simple operation . result result ) { if ( result . is successful ( ) ) { m data = result . get output ( ) ; show data ( ) ; } else { m text output . set text ( result . get error message ( ) ) ; } }	cancelling in the place it happened.
protected static void main ( main main , string ... args ) { main . get injector ( ) . get instance ( main . get main class ( ) ) . do main ( args ) ; }	Subclass specific entry point.
protected module [ ] get modules ( ) { module [ ] modules = { new wire module ( new event handler module ( ) , new space module ( new url ( main . class . get class loader ( ) ) ) ) } ; return modules ; }	Get the Guice modules to be used in injecting dependencies.
protected void do main ( string ... args ) { properties = new mergeable properties ( ) ; properties . put all ( system . get properties ( ) ) ; for ( string arg : args ) { properties . merge ( arg ) ; }	Actual main implementation.
private void check line ( ) { string end str = new string ( buf , count - line seperator . length ( ) , line seperator . length ( ) , charset ) ; if ( line seperator . equals ( end str ) ) { flush ( ) ; } }	Checks if the end of the buffer contains a newline and if so, flushes the stream.
public void initialize ( map < string , list < event handler > > event handlers , uri uri ) { this . event handlers = event handlers ; event listener listener = new event listener ( uri ) ; executor service . submit ( listener ) ; logger . fine ( str ) ; }	Initialize the event poller.
protected m get m ( string child name ) { m conn info = connections . get ( child name ) ; if ( conn info == null ) { conn info = new m ( ) ; connections . put ( child name , conn info ) ; } long child pid = main . get first java child pid ( child name ) ; if ( child pid > num && child pid != conn info . child pid && conn info . connector != null ) { try { conn info . connector . close ( ) ; } catch ( io e ) { logger . log ( level . fine , str , e ) ; } conn info . connector = null ; conn info . server = null ; } if ( child pid > num ) { try { if ( conn info . connector == null ) { conn info . connector = deployer control . get jmx ( child pid ) ; } if ( conn info . connector != null && conn info . server == null ) { conn info . server = conn info . connector . get m ( ) ; conn info . child pid = child pid ; } } catch ( io e ) { logger . log ( level . fine , str , e ) ; try { conn info . connector . close ( ) ; } catch ( exception e2 ) { logger . log ( level . fine , str , e2 ) ; } conn info . connector = null ; conn info . server = null ; } } return conn info . server ; }	Return the MBean server connection to the child process.
protected void close m ( string child name ) { m conn info = connections . get ( child name ) ; if ( conn info != null && conn info . connector != null ) { try { conn info . connector . close ( ) ; } catch ( io e ) { logger . log ( level . fine , str , e ) ; } conn info . connector = null ; } }	Close the MBean server connection.
protected void init ( context context ) { layout inflater . from ( context ) . inflate ( r . layout . fake search view , this , bool ) ; wrapped edit text = ( edit text ) find view by id ( r . id . wrapped search ) ; wrapped edit text . add text changed listener ( this ) ; wrapped edit text . set on editor action listener ( this ) ; }	Inflate the layout to this FrameLayout wrapper.
public static void main ( string [ ] args ) throws throwable { try { class < ? > initial class ;	The main program which actually runs JMeter.
private com . github . fge . jsonschema . main . json schema get validator ( ) throws processing exception { if ( validator == null ) { synchronized ( this ) { if ( validator == null ) { validation configuration builder cfg builder = validation configuration . new builder ( ) ; cfg builder . add library ( str , draft v3 library . get ( ) ) ; validator = json schema factory . new builder ( ) . set validation configuration ( cfg builder . freeze ( ) ) . freeze ( ) . get json schema ( get node ( ) ) ; } } } return validator ; }	Lazy intialization of validator instance.
public list < column > get find column list ( ) { list < column > find column list = new array list < column > ( ) ; list < column > temp column list = new array list < column > ( ) ; for ( int i = num ; i <= this . cardinality ; i ++ ) { if ( this . columns . get ( i ) . reference table != null ) { temp column list = this . columns . get ( i ) . reference table . get find column list ( ) ; for ( int j = num ; j < temp column list . size ( ) ; j ++ ) { column column = new column ( ) ; column . name = columns . get ( i ) . name . replace ( str , str ) . replace ( str , str ) + temp column list . get ( j ) . name ; column . data type = temp column list . get ( j ) . data type ; column . nullable = this . columns . get ( i ) . nullable ; find column list . add ( column ) ; } } else { column column = new column ( ) ; column . name = columns . get ( i ) . name ; column . data type = columns . get ( i ) . data type ; column . nullable = this . columns . get ( i ) . nullable ; find column list . add ( column ) ; } } return find column list ; }	get the list of arguments used in find stored procedure.
public list < column > get insert column list ( ) { list < column > result = new array list < > ( ) ; list < column > temp column list = new array list < > ( ) ; for ( column current column : this . columns ) { if ( current column . reference table != null ) { temp column list = current column . reference table . get find column list ( ) ; for ( column temp column : temp column list ) { column column = new column ( ) ; column . name = current column . name . replace ( str , str ) . replace ( str , str ) + temp column . name ; column . data type = temp column . data type ; column . nullable = current column . nullable ; result . add ( column ) ; } } else { column column = new column ( ) ; column . name = current column . name ; column . data type = current column . data type ; column . nullable = current column . nullable ; result . add ( column ) ; } } return result ; }	get the list of arguments used in insert by code stored procedure.
@ xml transient public list < package meta data > get all packages ( ) { list < package meta data > result = new array list < > ( ) ; if ( packages != null ) { for ( package meta data pack : packages ) { result . add all ( get packages ( pack ) ) ; } } return result ; }	recursive method to get all packages including children packages.
private final string get not overridable content ( ) throws io { if ( files . exists ( file path ) ) { list < string > lines = files . read all lines ( file path , file type . get encoding ( ) ) ; boolean is not overridable = bool ; string writer not overridable content writer = new string writer ( ) ; for ( string line : lines ) { if ( line . contains ( file type . get specific code start mark ( ) ) ) { is not overridable = bool ; } else if ( line . contains ( file type . get specific code end mark ( ) ) ) { is not overridable = bool ; } else { if ( is not overridable ) { not overridable content writer . append ( line + skip line ) ; } } } return not overridable content writer . to string ( ) ; } return str ; }	extract non generated content from a file to keep it after next generation.
protected final void write not overridable content ( ) throws io { string content = get not overridable content ( ) ; write line ( file type . get specific code start mark ( ) ) ; write ( content ) ; write line ( file type . get specific code end mark ( ) ) ; }	appends non generated content to be kept at next generation.
public table find table ( string table name ) { if ( table name == null ) { return null ; } if ( table name . is empty ( ) ) { return null ; } for ( package my package : this . packages ) { for ( table table : my package . tables ) { if ( table . original name . equals ( table name ) ) { return table ; } } } throw new table not found exception ( str + table name ) ; }	run through all the tables until it is found.
public bean find bean ( string table original name ) { for ( package my package : this . packages ) { for ( bean bean : my package . beans ) { if ( bean . table . original name . equals ( table original name ) ) { return bean ; } } } throw new bean not found exception ( str + table original name ) ; }	run through all the beans until it is found.
public list < view property > get reference properties ( bean bean ) { list < view property > result = new array list < > ( ) ; for ( int i = num ; i < bean . cardinality ; i ++ ) { property property = bean . properties . get ( i ) ; result . add all ( property . view properties ) ; } return result ; }	get the list of properties that will be used in bean views to showreferences to other beans.
private list < view property > get visible properties ( one to many one to many ) { return get view properties excluding field ( one to many . reference bean , one to many . reference property . name ) ; }	get the list of properties that will be available in a basic view bean.
public void update ( versionable target , versionable source ) { target . set dirty ( source . get dirty ( ) ) ; target . set major version ( source . get major version ( ) ) ; target . set mid version ( source . get mid version ( ) ) ; target . set minor version ( source . get minor version ( ) ) ; target . set modifier id ( source . get modifier id ( ) ) ; target . set reason ( source . get reason ( ) ) ; target . set modification time ( source . get modification time ( ) ) ; target . set history list ( source . get history list ( ) ) ; try { target . update history ( ) ; } catch ( exception ex ) { log . log ( level . severe , ex . get localized message ( ) , ex ) ; } }	Increase minor is done by default when updating a record.
public void add history ( history history ) { if ( get history list ( ) == null ) { set history list ( new array list < > ( ) ) ; } get history list ( ) . add ( history ) ; }	Add history to this entity.
@ override public void customize ( session session ) throws exception { jndi connector ;	Get a dataSource connection and set it on the session withlookupType=STRING_LOOKUP.
public requirement spec node server add spec node ( string name , string description , string scope ) throws exception { requirement spec node server sns = new requirement spec node server ( new requirement spec jpa controller ( get entity manager factory ( ) ) . find requirement spec ( get requirement spec pk ( ) ) , name , description , scope ) ; sns . write2 db ( ) ; get requirement spec node list ( ) . add ( new requirement spec node jpa controller ( get entity manager factory ( ) ) . find requirement spec node ( sns . get requirement spec node pk ( ) ) ) ; write2 db ( ) ; return sns ; }	Add a node to this spec.This is equivalent to a section in a document.Although database might allow a requirement being on different nodes,this constraint is imposed via software.
public static issue type get type ( string typename ) { issue type result = null ; for ( issue type type : new issue type jpa controller ( data base manager . get entity manager factory ( ) ) . find issue type entities ( ) ) { if ( type . get type name ( ) . equals ( typename ) ) { result = type ; break ; } } return result ; }	Get an Issue Type by name.
@ suppress warnings ( str ) public static vm setting get setting ( string s ) { parameters . clear ( ) ; parameters . put ( str , s ) ; result = named query ( str , parameters ) ; if ( result . is empty ( ) ) { return null ; } else { return ( vm setting ) result . get ( num ) ; } }	Get setting from database.
public static data entry get string field ( string name , string expected , boolean match case ) { data entry de = new data entry ( ) ; data entry type det = data entry type server . get type ( str ) ; de . set entry name ( name ) ; de . set data entry property list ( get default properties ( det ) ) ; de . set data entry type ( det ) ; if ( expected != null ) { get property ( de , str ) . set property value ( expected ) ; get property ( de , str ) . set property value ( match case ? str : str ) ; } return de ; }	Create a default string field.
public static data entry get boolean field ( string name ) { data entry de = new data entry ( ) ; de . set entry name ( name ) ; data entry type det = data entry type server . get type ( str ) ; de . set data entry property list ( get default properties ( det ) ) ; de . set data entry type ( det ) ; return de ; }	Create a boolean field.
public static data entry get numeric field ( string name , float min , float max ) { data entry de = new data entry ( ) ; de . set entry name ( name ) ; data entry type det = data entry type server . get type ( str ) ; de . set data entry property list ( get default properties ( det ) ) ; de . set data entry type ( det ) ; for ( data entry property dep : de . get data entry property list ( ) ) { if ( dep . get property name ( ) . equals ( str ) && min != null ) {	Create a numeric field.
private void display workflow ( workflow w ) { graph graph = new graph ( w . get workflow name ( ) , graph . digraph ) ; nodes . clear ( ) ;	Create workflow from database.
private void refresh workflow ( ) { graph graph = new graph ( ( ( workflow ) workflows . get value ( ) ) . get workflow name ( ) , graph . digraph ) ; nodes . values ( ) . for each ( node -> { graph . add node ( node ) ; } ) ; edges . values ( ) . for each ( edge -> { graph . add edge ( edge . get key ( ) , edge . get value ( ) . get dest ( ) ) ; } ) ; diagram . draw graph ( graph ) ; selected = null ; update controls ( ) ; }	Recreate graph with the edited values.
private static void walk component tree ( component c , consumer < component > visitor ) { visitor . accept ( c ) ; if ( c instanceof has components ) { for ( component child : ( ( has components ) c ) ) { walk component tree ( child , visitor ) ; } } }	recursively walk the Component true.
@ override public output stream receive upload ( string filename , string mime ) { file output stream fos ;	Callback method to begin receiving the upload.
@ nullable public result strength get address risk ( ) { if ( address risk == null ) { return null ; } return result strength . to enum ( address risk . to lower case ( ) ) ; }	Gets the risk of this particular address.
@ deprecated protected < d extends file descriptor > d to file descriptor ( descriptor descriptor , class < d > type , string path , scanner context context ) { if ( descriptor == null ) { d result = context . get store ( ) . create ( type ) ; result . set file name ( path ) ; return result ; } return migrate or cast ( descriptor , type , context ) ; }	Takes an optional descriptor and transforms it to file descriptor.
@ nullable public static blockscore error get blockscore error ( @ not null final retrofit error cause ) { object raw error = cause . get body as ( blockscore error . class ) ; if ( raw error instanceof blockscore error ) { return ( blockscore error ) raw error ; } else { return null ; } }	Converts a Retrofit Error into a Blockscore Error.
@ not null public void score ( @ not null final answer set answers ) { question set scored set = rest adapter . score question set ( get id ( ) , answers ) ; expired = scored set . is expired ( ) ; score = scored set . get score ( ) ; }	Scores a question set.
public < d extends m > d digest ( input stream stream , digest operation < d > digest operation ) throws io { digest input stream digest input stream = new digest input stream ( stream , md5 digest ) ; d md5 descriptor = digest operation . execute ( digest input stream ) ; string md5 = datatype converter . print hex binary ( md5 digest . digest ( ) ) ; md5 descriptor . set md5 ( md5 ) ; return md5 descriptor ; }	Calculate the MD5 hash sum for the given input stream using the givenoperation.
public boolean accepts ( string path ) { boolean result ; if ( include file patterns != null ) { result = matches ( path , include file patterns ) ; } else { result = bool ; } if ( exclude file patterns != null ) { result = result && ! matches ( path , exclude file patterns ) ; } return result ; }	Determines if the given path matches the configured include and excludepatterns.NOTE: The include pattern is evaluated before the exclude pattern.
public void add answer ( int question id , int answer id ) { question answer pair answer pair = new question answer pair ( question id , answer id ) ; answers . add ( answer pair ) ; }	Adds an answer to a question to the AnswerSet.
@ not null public string [ ] get matching info ( ) { if ( matching info == null ) { return new string [ num ] ; } return arrays . copy of ( matching info , matching info . length ) ; }	Gets a list of elements in your request that match this watchlist hit.
@ nullable public address get address ( ) { return new address ( address street1 , address street2 , address city , address state , address postal code , address country code ) ; }	Gets the address of the candidate.
public question set create question set ( long time limit ) { map < string , string > query options = new hash map < string , string > ( ) ; query options . put ( str , get id ( ) ) ; query options . put ( str , string . value of ( time limit ) ) ; question set question set = rest adapter . create question set ( query options ) ; question set . set adapter ( rest adapter ) ; return question set ; }	Creates a question set with a set time limit in seconds.
public question set retrieve question set ( @ not null final string question set id ) { question set question set = rest adapter . retrieve question set ( question set id ) ; question set . set adapter ( rest adapter ) ; return question set ; }	Retrieve a question set you have created.
@ not null public date get date of birth ( ) { gregorian calendar calendar = new gregorian calendar ( birth year , birth month , birth day ) ; return calendar . get time ( ) ; }	Gets the date of birth for this individual.
@ not null public address get address ( ) { address address object = new address ( address street1 , address street2 , address city , address subdivision , address postal code , address country code ) ; return address object ; }	Gets the address for this individual.
@ nullable public date get incorporation date ( ) { if ( incorporation day == null || incorporation month == null || incorporation year == null ) { return null ; } gregorian calendar calendar day = new gregorian calendar ( incorporation year , incorporation month , incorporation day ) ; return calendar day . get time ( ) ; }	Gets the date of incorporation.
public list < candidate > get revision history ( ) { list < candidate > candidates = rest adapter . get candidate history ( get id ( ) ) ; for ( candidate candidate : candidates ) { candidate . set adapter ( rest adapter ) ; } return collections . unmodifiable list ( candidates ) ; }	Returns a complete revision history of a candidate's edits.
public paginated result < watchlist hit > search watchlists ( entity type entity type , double similarity threshold ) { map < string , string > query options = new hash map < string , string > ( ) ; query options . put ( str , get id ( ) ) ; if ( entity type != null ) { query options . put ( str , string . value of ( entity type ) ) ; } if ( similarity threshold != null ) { query options . put ( str , string . value of ( similarity threshold ) ) ; } watchlist search results results = rest adapter . search watchlists ( query options ) ;	Performs a watchlist search for this candidate.
@ not null public candidate set date of birth ( @ nullable final date date of birth ) { if ( date of birth == null ) { this . date of birth = null ; return this ; } this . date of birth = new date ( date of birth . get time ( ) ) ; return this ; }	Set the date of birth of your candidate.
public candidate set address ( @ not null final address address ) { this . address street1 = address . get street1 ( ) ; this . address street2 = address . get street2 ( ) ; this . address city = address . get city ( ) ; this . address subdivision = address . get subdivision ( ) ; this . address postal code = address . get postal code ( ) ; this . address country code = address . get country code ( ) ; return this ; }	Sets the primary street address for this person.
@ not null public person retrieve person ( @ not null final string id ) { person person = rest adapter . retrieve person ( id ) ; person . set adapter ( rest adapter ) ; return person ; }	Gets a single person exactly as it was when you created it.This route is useful for auditing purposes as you can provide proof that a verification took placealong with all of its associated data.
@ not null public candidate retrieve candidate ( @ not null final string id ) { candidate candidate = rest adapter . retrieve candidate ( id ) ; candidate . set adapter ( rest adapter ) ; return candidate ; }	Retrieves a candidate.
@ not null private string get encoded authorization ( ) { try { return str + datatype converter . print base64 binary ( api key . get bytes ( str ) ) ; } catch ( unsupported encoding exception e ) { throw new runtime exception ( e ) ; } }	Encodes the API key for Basic authentication.
@ nullable public date get date of birth end ( ) { if ( birth day end == null || birth month end == null || birth year end == null ) { return null ; } gregorian calendar calendar = new gregorian calendar ( birth year end , birth month end , birth day end ) ; return calendar . get time ( ) ; }	Returns the end of the date of birth range.
protected < t > class < t > get type parameter ( class < ? > expected super class , int generic type parameter index ) { class < ? extends abstract scanner plugin > this class = this . get class ( ) ; if ( ! this class . get superclass ( ) . equals ( expected super class ) ) { throw new illegal state exception ( str + this class . get name ( ) ) ; } type generic superclass = this class . get generic superclass ( ) ; type type parameter = ( ( parameterized type ) generic superclass ) . get actual type arguments ( ) [ generic type parameter index ] ; if ( type parameter instanceof parameterized type ) { return ( class < t > ) ( ( parameterized type ) type parameter ) . get raw type ( ) ; } return ( class < t > ) type parameter ; }	Determines the type parameter for a generic super class.
protected string get string property ( string name , string default value ) { object value = properties . get ( name ) ; return value != null ? value . to string ( ) : default value ; }	Get a property as string.
protected boolean get boolean property ( string name , boolean default value ) { object value = properties . get ( name ) ; return value != null ? boolean . value of ( value . to string ( ) ) : default value ; }	Get a property as boolean.
protected string get directory path ( file directory , file entry ) { string relative path ; if ( entry . equals ( directory ) ) { relative path = str ; } else { string file path = entry . get absolute path ( ) ; string directory path = directory . get absolute path ( ) ; relative path = file path . substring ( directory path . length ( ) ) . replace ( file . separator , str ) ; } return relative path ; }	Return the relative path of a file within a directory.
@ not null public blockscore error type get error type ( ) { if ( type == null ) { return blockscore error type . unknown ; } else { return blockscore error type . to enum ( type ) ; } }	Gets the error type.
@ not null public validation error type get validation error code ( ) { if ( code == null ) { return validation error type . unknown ; } else { return validation error type . to enum ( code ) ; } }	Gets the validation error type.
public void flush ( ) { create hierarchy ( ) ; sync ( file container descriptor . get requires ( ) , required files ) ; sync ( file container descriptor . get contains ( ) , contained files ) ; }	Flush the caches to the store.
private void sync ( collection < file descriptor > target , map < string , file descriptor > after ) { map < string , file descriptor > before = get cache ( target ) ; map < string , file descriptor > all = new hash map < > ( ) ; all . put all ( before ) ; all . put all ( after ) ; for ( map . entry < string , file descriptor > entry : all . entry set ( ) ) { string key = entry . get key ( ) ; file descriptor file descriptor = entry . get value ( ) ; boolean has before = before . contains key ( key ) ; boolean has after = after . contains key ( key ) ; if ( has before && ! has after ) { target . remove ( file descriptor ) ; } else if ( ! has before && has after ) { target . add ( file descriptor ) ; } } }	Sync the given target collection with the new state from the cache map.
private map < string , file descriptor > get cache ( iterable < file descriptor > file descriptors ) { map < string , file descriptor > cache = new hash map < > ( ) ; for ( file descriptor file descriptor : file descriptors ) { cache . put ( file descriptor . get file name ( ) , file descriptor ) ; } return cache ; }	Creates cache map from the given collection of file descriptors.
private void create hierarchy ( ) { for ( map . entry < string , file descriptor > entry : contained files . entry set ( ) ) { string relative path = entry . get key ( ) ; file descriptor file descriptor = entry . get value ( ) ; int separator index = relative path . last index of ( str ) ; if ( separator index != - num ) { string parent name = relative path . substring ( num , separator index ) ; file descriptor parent descriptor = contained files . get ( parent name ) ; if ( parent descriptor instanceof file container descriptor ) { ( ( file container descriptor ) parent descriptor ) . get contains ( ) . add ( file descriptor ) ; } } } }	Build the hierarchy of the container entries, i.e.
public static int find unused port ( ) throws io { int port ; try ( server socket socket = new server socket ( ) ) { socket . bind ( new inet socket address ( num ) ) ; port = socket . get local port ( ) ; } return port ; }	Find an unused port.
@ override public string value get parameter value ( final string name ) { final list < string value > values = this . parameters . get ( name ) ; return ( values != null && ! values . is empty ( ) ) ? values . get ( num ) : string value . value of ( ( string ) null ) ; }	Returns single value for parameter with specified name.
@ override public void set parameter values ( final string name , final list < string value > value ) { this . parameters . put ( name , value ) ; try { context . get thread context ( ) . get parameters ( ) . put ( name , parameter util . string values2 array ( value ) ) ; } catch ( final e e ) { e . log . error ( str , name ) ; } }	Sets the values for given parameter.
public void set parameter value ( final string key , final string value ) { final list < string value > list = new array list < string value > ( num ) ; list . add ( string value . value of ( value ) ) ; set parameter values ( key , list ) ; }	Sets value for given key.
public void add parameter value ( final string key , final string value ) { list < string value > list = this . parameters . get ( key ) ; if ( list == null ) { list = new array list < string value > ( num ) ; this . parameters . put ( key , list ) ; } list . add ( string value . value of ( value ) ) ; try { context . get thread context ( ) . get parameters ( ) . put ( key , parameter util . string values2 array ( list ) ) ; } catch ( final e e ) { e . log . error ( str , key ) ; } }	Adds a value for given key.
public abstract command get target cmd ( ) throws cache reload exception { abstract command cmd = command . get ( this . target cmd uuid ) ; if ( cmd == null ) { cmd = menu . get ( this . target cmd uuid ) ; } return cmd ; }	Get the CommandAbstract that is the target of this Page.
protected object get value4 wizard ( final string key ) { object ret = null ; final map < string , string [ ] > para = this . wizard . get parameters ( ( i ) this ) ; if ( para != null && para . contains key ( key ) ) { final string [ ] value = para . get ( key ) ; ret = value [ num ] ; } return ret ; }	Method to get the value for a key in case of wizard.
public string register oid ( final string oid ) { final string ret = random util . random alphanumeric ( num ) ; get ui i ( ) . put ( ret , oid ) ; return ret ; }	Register oid.
@ override public component new node component ( final string wicket id , final i < ui > model ) { return new node < ui > ( wicket id , this , model ) { private static final long serial version uid = num ; @ override protected component create content ( final string wicket id , final i < ui > model ) { return new content component ( wicket id , model ) ; } @ override protected markup container create junction component ( final string id ) { final ui struc brws = ( ui ) get default model object ( ) ; final markup container ret ; if ( struc brws . has children ( ) && struc brws . is force expanded ( ) ) { ret = new web markup container ( id ) ; } else { ret = super . create junction component ( id ) ; } if ( struc brws . get level ( ) > num ) { ret . add ( attribute modifier . append ( str , str + num * ( struc brws . get level ( ) - num ) + str ) ) ; } return ret ; } } ; }	Create a new component for a node.
@ override public component new subtree ( final string wicket id , final i < ui > model ) { return new sub element ( wicket id , this , model ) ; }	Create a new subtree.
public static set < index flavor > complement of ( final set < index flavor > index flavors ) { final set < index flavor > set = all of ( ) ; set . remove all ( index flavors ) ; return set ; }	Returns a set containing all the known index flavours, except those is the given set.
public static set < index flavor > of ( final index flavor first , final index flavor ... rest ) { final set < index flavor > set = new hash set < > ( ) ; set . add ( first ) ; set . add all ( arrays . as list ( rest ) ) ; return set ; }	Returns a set containing the given index flavours.
@ override public v put ( final k key , final v value ) { entries . add ( new entry ( key , value ) ) ; return value ; }	Add an entry for the given key-value pair to the map.
@ override public v remove ( final object key ) { final iterator < map . entry < k , v > > iterator = entries . iterator ( ) ; v last value = null ; while ( iterator . has next ( ) ) { final map . entry < k , v > entry = iterator . next ( ) ; last value = entry . get value ( ) ; if ( key . equals ( entry . get key ( ) ) ) { iterator . remove ( ) ; } } return last value ; }	Remove all entries for the given key.
public string get random4 id ( final long id ) { final string rid = random util . random alphanumeric ( num ) ; this . random2id . put ( rid , id ) ; return rid ; }	Gets the random for ID.
protected list < integer > get user widths ( ) { list < integer > ret = null ; try { if ( context . get thread context ( ) . contains user attribute ( get cache key ( ui . user cache key . columnwidth ) ) ) { set user width ( bool ) ; final string widths = context . get thread context ( ) . get user attribute ( get cache key ( ui . user cache key . columnwidth ) ) ; final string tokenizer tokens = new string tokenizer ( widths , str ) ; ret = new array list < > ( ) ; while ( tokens . has more tokens ( ) ) { final string token = tokens . next token ( ) ; for ( int i = num ; i < token . length ( ) ; i ++ ) { if ( ! character . is digit ( token . char at ( i ) ) ) { final int width = integer . parse int ( token . substring ( num , i ) ) ; ret . add ( width ) ; break ; } } } } } catch ( final number format exception e ) {	This method retieves the UserAttribute for the ColumnWidths and evaluatesthe string.
public void set sort direction ( final sort direction sortdirection ) { this . sort direction = sortdirection ; try { context . get thread context ( ) . set user attribute ( get cache key ( user cache key . sortdirection ) , sortdirection . get value ( ) ) ; } catch ( final e e ) {	Method to set he sort direction.
public void set column order ( final string markups ids ) { final string tokenizer tokens = new string tokenizer ( markups ids , str ) ; final string builder column order = new string builder ( ) ; while ( tokens . has more tokens ( ) ) { final string markup id = tokens . next token ( ) ; for ( final ui header : get headers ( ) ) { if ( markup id . equals ( header . get markup id ( ) ) ) { column order . append ( header . get field name ( ) ) . append ( str ) ; break ; } } } try { context . get thread context ( ) . set user attribute ( get cache key ( ui . user cache key . columnorder ) , column order . to string ( ) ) ; } catch ( final e e ) {	Method to set the order of the columns.
protected list < field > get user sorted columns ( ) { list < field > ret = new array list < > ( ) ; try { final list < field > fields = get table ( ) . get fields ( ) ; if ( context . get thread context ( ) . contains user attribute ( get cache key ( ui . user cache key . columnorder ) ) ) { final string column order = context . get thread context ( ) . get user attribute ( get cache key ( ui . user cache key . columnorder ) ) ; final string tokenizer tokens = new string tokenizer ( column order , str ) ; while ( tokens . has more tokens ( ) ) { final string fieldname = tokens . next token ( ) ; for ( int i = num ; i < fields . size ( ) ; i ++ ) { if ( fieldname . equals ( fields . get ( i ) . get name ( ) ) ) { ret . add ( fields . get ( i ) ) ; fields . remove ( i ) ; } } } if ( ! fields . is empty ( ) ) { for ( final field field : fields ) { ret . add ( field ) ; } } } else { ret = fields ; } } catch ( final e e ) { ui . log . debug ( str ) ; } return ret ; }	This method looks if for this TableModel a UserAttribute for the sortingof the Columns exist.
@ override protected void on component tag ( final component tag tag ) { super . on component tag ( tag ) ; final ui structur browser = ( ui ) get default model object ( ) ; if ( structur browser . get sort direction ( ) . equals ( sort direction . ascending ) ) { tag . put ( str , str ) ; } else { tag . put ( str , str ) ; } }	On the tag the class is set.
@ override public void on component tag body ( final markup stream markup stream , final component tag open tag ) { replace component tag body ( markup stream , open tag , this . header ) ; }	The body of the component is filled with the header.
@ override public void on click ( ) { final ui structur browser = ( ui ) get default model object ( ) ;	On click the model is sorted and a new page with this model as responserendered.
public static config get config ( string name , i factory ) { if ( configs == null ) { init ( ) ; } if ( name == null ) { name = default config name ; } config got = configs . get ( name ) ; if ( got == null ) { log ( bool , str + name + str , null ) ;	Returns a Config instance, instantiating it on first call. If no factoryimplementation is provided, one will be searched using Service Loader If aConfig with given name already exists, it will be simply returned.
private void render e ( ) { collections . sort ( this . e faps header items , ( item0 , item1 ) -> item0 . get sort weight ( ) . compare to ( item1 . get sort weight ( ) ) ) ; final list < string > css = new array list < > ( ) ; final list < string > js = new array list < > ( ) ; for ( final e item : this . e faps header items ) { if ( item instanceof e ) { js . add ( item . get reference ( ) . get name ( ) ) ; } else { css . add ( item . get reference ( ) . get name ( ) ) ; } } try { if ( ! css . is empty ( ) ) { final string key = bundle maker . get bundle key ( css , temp file bundle . class ) ; final temp file bundle bundle = ( temp file bundle ) bundle maker . get bundle ( key ) ; bundle . set content type ( str ) ; super . render ( css header item . for url ( e . get ( ) . get servlet context ( ) . get context path ( ) + str + key ) ) ; } if ( ! js . is empty ( ) ) { final string key = bundle maker . get bundle key ( js , temp file bundle . class ) ; final temp file bundle bundle = ( temp file bundle ) bundle maker . get bundle ( key ) ; bundle . set content type ( str ) ; super . render ( java script header item . for url ( e . get ( ) . get servlet context ( ) . get context path ( ) + str + key ) ) ; } } catch ( final e e ) { e . log . error ( str , e ) ; } }	render the eFaps Resource items.
private void render combined require scripts ( ) { final set < dojo class > dojo classes = this . require header items . stream ( ) . flat map ( o -> o . get dojo classes ( ) . stream ( ) ) . collect ( collectors . to set ( ) ) ; if ( collection utils . is not empty ( dojo classes ) ) { super . render ( new header item ( ) { private static final long serial version uid = num ; @ override public iterable < ? > get render tokens ( ) { return dojo classes ; } @ override public void render ( final response response ) { java script utils . write java script ( response , dojo wrapper . require ( null , dojo classes . to array ( new dojo class [ dojo classes . size ( ) ] ) ) , require header item . class . get name ( ) ) ; } } ) ; } }	Render combined requir scripts.
protected char sequence get create tree node script ( ) { final string builder js = new string builder ( ) ; js . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( inputname ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) ; return js ; }	Gets the creates the tree node script.
protected char sequence get data line ( final classification clazz , final i filter ) throws e { final string builder js = new string builder ( ) ; if ( clazz . has access ( null , access type enums . show . get access type ( ) ) ) { js . append ( str ) . append ( clazz . get uuid ( ) ) . append ( str ) . append ( string escape utils . escape ecma script ( clazz . get label ( ) ) ) . append ( str ) . append ( clazz . is root ( ) ? str : clazz . get parent classification ( ) . get uuid ( ) ) . append ( str ) . append ( filter . contains ( clazz . get uuid ( ) ) ) . append ( str ) ; for ( final classification child clazz : clazz . get child classifications ( ) ) { js . append ( get data line ( child clazz , filter ) ) ; } } return js ; }	Gets the data line.
public void execute ( final instance instance ) throws e { ui clazz = this ; while ( ! clazz . is root ( ) ) { clazz = clazz . get parent ( ) ; } clazz . initialized = bool ; for ( final ui child : clazz . get children ( ) ) { final classification type = ( classification ) type . get ( child . get classification uuid ( ) ) ; if ( clazz . selected uuid . contains ( child . get classification uuid ( ) ) ) { child . set selected ( bool ) ; } child . add children ( child , type . get child classifications ( ) , clazz . selected uuid , instance ) ; clazz . expand ( ) ; } }	Execute the model.
@ suppress warnings ( str ) private void expand ( ) { try { final string key = get cache key ( ) ; if ( context . get thread context ( ) . contains session attribute ( key ) ) { final set < uuid > sess map = ( set < uuid > ) context . get thread context ( ) . get session attribute ( key ) ; set expanded internal ( sess map . contains ( this . classification uuid ) ) ; for ( final ui ui clazz : get descendants ( ) ) { if ( sess map . contains ( ui clazz . classification uuid ) ) { ui clazz . set expanded internal ( bool ) ; } } } } catch ( final e e ) { ui . log . error ( str , this . field id , e ) ; } }	Expand the Tree.
private void add children ( final ui parent , final set < classification > children , final set < uuid > selected uuid , final instance instance ) throws e { for ( final classification child : children ) { boolean access ; if ( ! child . is abstract ( ) ) { final instance inst = abstract instance object . get instance4 create ( child ) ; access = child . has access ( inst , get mode ( ) == target mode . create || get mode ( ) == target mode . edit ? access type enums . create . get access type ( ) : access type enums . show . get access type ( ) ) ; } else { access = bool ; } if ( access ) { final ui child ui = new ui ( child . get uuid ( ) , parent . mode , bool ) ; if ( selected uuid . contains ( child . get uuid ( ) ) ) { child ui . selected = bool ; } child ui . add children ( child ui , child . get child classifications ( ) , selected uuid , instance ) ; parent . children . add ( child ui ) ; child ui . set parent ( parent ) ; } } collections . sort ( parent . children , new comparator < ui > ( ) { @ override public int compare ( final ui class0 , final ui class2 ) { return class0 . get label ( ) . compare to ( class2 . get label ( ) ) ; } } ) ; }	Recursive method used to add the children to this UIClassification.
public map < uuid , string > get class instance keys ( final instance instance ) throws e { final map < uuid , string > ret = new hash map < uuid , string > ( ) ; ui clazz = this ; while ( ! clazz . is root ( ) ) { clazz = clazz . get parent ( ) ; } type reltype = null ; for ( final ui child : clazz . get children ( ) ) { final classification class type = ( classification ) type . get ( child . get classification uuid ( ) ) ; if ( ! class type . get classify relation type ( ) . equals ( reltype ) ) { final query builder query bldr = new query builder ( class type . get classify relation type ( ) ) ; query bldr . add where attr eq value ( class type . get rel link attribute name ( ) , instance . get id ( ) ) ; final multi print query multi = query bldr . get print ( ) ; multi . add attribute ( class type . get rel type attribute name ( ) ) ; multi . execute ( ) ; while ( multi . next ( ) ) { final long typeid = multi . < long > get attribute ( class type . get rel type attribute name ( ) ) ; final classification sub class type = ( classification ) type . get ( typeid ) ; final query builder sub query bldr = new query builder ( sub class type ) ; sub query bldr . add where attr eq value ( sub class type . get link attribute name ( ) , instance . get id ( ) ) ; sub query bldr . add order by attribute asc ( str ) ; final instance query query = sub query bldr . get query ( ) ; query . execute ( ) ; if ( query . next ( ) ) {	Method to get the key to the instances related to this classification.
public string get cache key ( ) { string ret = str ; ui clazz = this ; while ( ! clazz . is root ( ) ) { clazz = clazz . get parent ( ) ; } final field field = field . get ( clazz . get field id ( ) ) ; if ( field != null ) { try { ret = field . get collection ( ) . get uuid ( ) . to string ( ) + str + field . get name ( ) + str + ui . usersessionkey ; } catch ( final cache reload exception e ) { ui . log . error ( str , e ) ; } } return ret ; }	This method generates the Key for a UserAttribute by using the UUID ofthe Command and the given static part, so that for every StruturBrowser aunique key for expand etc, is created.
public view document request builder add highlight expressions ( final string highlight expression , final string ... highlight expressions ) { this . highlight expressions . add ( highlight expression ) ; this . highlight expressions . add all ( arrays . as list ( highlight expressions ) ) ; return this ; }	Adds values to the highlight_expression parameter.
public view document request builder add start tags ( final string start tag , final string ... start tags ) { this . start tags . add ( start tag ) ; this . start tags . add all ( arrays . as list ( start tags ) ) ; return this ; }	Adds values to the start_tag parameter.
public view document request builder add end tags ( final string end tag , final string ... end tags ) { this . end tags . add ( end tag ) ; this . end tags . add all ( arrays . as list ( end tags ) ) ; return this ; }	Adds values to the end_tag parameter.
public component get lazy load component ( final string markup id , final string html ) { return new web markup container ( markup id ) { private static final long serial version uid = num ; @ override public void on component tag body ( final markup stream markup stream , final component tag open tag ) { replace component tag body ( markup stream , open tag , html ) ; } } ; }	Gets the lazy load component.
public component get loading component ( final string markup id ) { final i handler = new resource reference request handler ( abstract default ajax behavior . indicator ) ; return new label ( markup id , str + request cycle . get ( ) . url for ( handler ) + str ) . set escape model strings ( bool ) ; }	Gets the loading component.
public void insert before ( final i element ) { int i = num ; for ( final i ui object : this . elements ) { if ( ui object == this . current ) { this . elements . add ( i , element ) ; break ; } i ++ ; } }	Insert a UIObject before the current one.
public i get previous ( ) { i ret = null ; for ( final i ui object : this . elements ) { if ( ui object == this . current ) { break ; } else { ret = ui object ; } } this . current = ret ; return ret ; }	Method to get the previous object.
public void add parameters ( final i element , final map < string , string [ ] > parameters ) { this . parameters . put ( element , parameters ) ; }	Add parameters.
protected boolean evaluate4 instance ( ) throws e { boolean ret = bool ; if ( ! is search mode ( ) ) { final list < return > returns = this . get command ( ) . execute events ( event type . ui table evaluate , parameter values . instance , get instance ( ) , parameter values . parameters , context . get thread context ( ) . get parameters ( ) , parameter values . class , this ) ; for ( final return retu : returns ) { if ( retu . contains ( return values . instance ) ) { final object object = retu . get ( return values . instance ) ; if ( object != null && object instanceof instance && ( ( instance ) object ) . is valid ( ) ) { set instance key ( ( ( instance ) object ) . get oid ( ) ) ; } else { ui . log . error ( str , this . get command ( ) . get name ( ) ) ; } } else { ret = bool ; } } } return ret ; }	This is a possibility to replace the current Instance for the form withanother one using an table evaluate esjp.
public void add class elements ( final ui uiclass , final map < uuid , string > instance keys ) throws e { this . elements . add all ( get class elements ( uiclass , instance keys ) ) ; }	Method that adds the classification forms as elements to the form bywalking down the tree.
public void update class elements ( final ui uiclass ) throws e {	Method that removes all classifcations and afterwards adds theclassification forms as elements to the form by walking down the tree.
private boolean add cell2 form row ( final form element form element , final print query query , final field field ) throws e { boolean ret = bool ; attribute attr = null ; if ( field . get attribute ( ) != null ) { attr = query . get attribute4 attribute ( field . get attribute ( ) ) ; } else if ( field . get select ( ) != null ) { attr = query . get attribute4 select ( field . get select ( ) ) ; } final instance field instance = evaluate field instance ( query , field ) ; if ( field . is hidden display ( get mode ( ) ) ) { if ( field . get attribute ( ) != null ) { query . get attribute ( field . get attribute ( ) ) ; } else if ( field . get select ( ) != null ) { query . get select ( field . get select ( ) ) ; } else if ( field . get phrase ( ) != null ) { query . get phrase ( field . get name ( ) ) ; } add hidden ( evaluate ui ( query , field , field instance , attr ) ) ; ret = bool ; } else {	Method to add a Cell to the given Row.
private ui evaluate ui ( final print query print , final field field , final instance field instance , final attribute attr ) throws e { object value = null ; if ( field . get attribute ( ) != null ) { value = print . < object > get attribute ( field . get attribute ( ) ) ; } else if ( field . get select ( ) != null ) { value = print . < object > get select ( field . get select ( ) ) ; } else if ( field . get phrase ( ) != null ) { value = print . get phrase ( field . get name ( ) ) ; } else if ( field . get msg phrase ( ) != null ) { value = print . get msg phrase ( new select builder ( get base select4 msg phrase ( field ) ) , field . get msg phrase ( ) ) ; } final ui ui field = new ui ( this , field instance . get key ( ) , ui . get ( field , attr , value ) . set instance ( field instance ) . set call instance ( get instance ( ) ) . set class object ( this ) ) ; return ui field ; }	Method evaluates a Field and adds it to the row.
private list < element > get class elements ( final ui uiclass , final map < uuid , string > uuid2 instance key ) throws e { final list < element > ret = new array list < > ( ) ; if ( uiclass . is selected ( ) && ! uiclass . is root ( ) ) { final ui fieldform ; if ( uuid2 instance key . contains key ( uiclass . get classification uuid ( ) ) ) { fieldform = new ui ( get command uuid ( ) , uuid2 instance key . get ( uiclass . get classification uuid ( ) ) ) ; } else { fieldform = new ui ( get command uuid ( ) , uiclass ) ; if ( is edit mode ( ) ) {	Recursive method to add the children classification forms.
private char sequence get image ( final ui menu item , final string node ) { final string label = menu item . get label ( ) ; string content = str ; if ( string utils . is not empty ( label ) ) { content = string utils . left ( label , num ) . to upper case ( ) ; } final string builder js = new string builder ( ) ; if ( string utils . is not empty ( menu item . get image ( ) ) && menu item . get image ( ) . ends with ( str ) ) { try { final query builder quer bldr = new query builder ( ci . image ) ; quer bldr . add where attr eq value ( ci . image . name , menu item . get image ( ) ) ; final instance query query = quer bldr . get query ( ) ; query . execute ( ) ; if ( query . next ( ) ) { final checkout checkout = new checkout ( query . get current value ( ) ) ; final byte array output stream os = new byte array output stream ( ) ; checkout . execute ( os ) ; final string svg = new string ( os . to byte array ( ) , standard charsets . utf 8 ) ; js . append ( str ) . append ( str ) . append ( string escape utils . escape ecma script ( svg ) ) . append ( str ) . append ( str ) . append ( node ) . append ( str ) ; } } catch ( final e e ) {	Gets the image.
protected ajax event behavior get behavior ( final class < ? extends behavior > class ) { final slide in panel panel = ( slide in panel ) get parent ( ) ; return panel . visit children ( ajax menu item . class , ( item , visit ) -> { final list < ? extends behavior > behaviors = item . get behaviors ( class ) ; if ( collection utils . is not empty ( behaviors ) ) { visit . stop ( ( ajax event behavior ) behaviors . get ( num ) ) ; } else { visit . stop ( ) ; } } ) ; }	Gets the behavior.
@ override public iterator < ? extends ui > get children ( final ui node ) { if ( node . is parent ( ) && ! node . has children ( ) ) { node . add children ( ) ; } return node . get children ( ) . iterator ( ) ; }	Get the children of the given node.
public < u , be extends entity type , bt extends token type > u make request ( final token proxy < be , bt > token proxy , final class < u > return type , final backend caller < ? super be , ? super bt > backend caller ) throws hod error exception { return response parser . parse response ( token proxy , return type , backend caller . make request ( get authentication token ( token proxy ) ) ) ; }	Makes a request to HP Haven OnDemand, converting the response body to the type specified by the Class object.
public < u , be extends entity type , bt extends token type > u make request ( final token proxy < be , bt > token proxy , final type reference < u > type reference , final backend caller < ? super be , ? super bt > backend caller ) throws hod error exception { return response parser . parse response ( token proxy , type reference , backend caller . make request ( get authentication token ( token proxy ) ) ) ; }	Makes a request to HP Haven OnDemand, converting the response body to the type specified by the type reference.
public < be extends entity type , bt extends token type > input stream make request ( final token proxy < be , bt > token proxy , final backend caller < ? super be , ? super bt > backend caller ) throws hod error exception { return response parser . parse response ( token proxy , backend caller . make request ( get authentication token ( token proxy ) ) ) ; }	Makes a request to HP Haven OnDemand, returning the response body as an input stream.
@ override public object from body ( final typed input body , final type type ) throws conversion exception { try { return converter . from body ( body , type ) ; } catch ( final conversion exception e ) { if ( e . get cause ( ) instanceof json parse exception ) { throw new hod unavailable exception ( e . get cause ( ) ) ; } else { throw e ; } } }	Returns the object returned by calling fromBody on the underlying converter.
@ override public void render head ( final component component , final i response ) { super . render head ( component , response ) ; response . render ( e . for java script ( ajax field update behavior . js ) ) ; }	Render to the web response the eFapsContentReference.
@ override protected void on error ( final ajax request target target ) { if ( this . error handling ) { final feedback collector collector = new feedback collector ( get form ( ) . get page ( ) ) ; final list < feedback message > msgs = collector . collect ( ) ; final string builder html = new string builder ( ) . append ( str ) ; for ( final feedback message msg : msgs ) { msg . get reporter ( ) . add ( attribute modifier . append ( str , str ) ) ; target . add ( msg . get reporter ( ) ) ; serializable warn = null ; if ( msg . get message ( ) instanceof validation error feedback ) {	Default means nothing is done on error.
public execution bridge launch ( final i job , final string job name ) throws e {	Launch a job.
public add to text index request builder add reference prefixes ( final string reference prefix , final string ... reference prefixes ) { this . reference prefixes . add ( reference prefix ) ; this . reference prefixes . add all ( arrays . as list ( reference prefixes ) ) ; return this ; }	Adds values to the referencePrefixes parameter.
public add to text index request builder add additional metadata ( final object metadatum , final object ... metadata ) { this . additional metadata . add ( metadatum ) ; this . additional metadata . add all ( arrays . as list ( metadata ) ) ; return this ; }	Sets the value of the metadata parameter.
public query profile request builder add promotion categories ( final string category0 , final string ... categories ) { promotion categories . add ( category0 ) ; promotion categories . add all ( arrays . as list ( categories ) ) ; return this ; }	Adds categories to the promotion_categories parameter.
public query profile request builder add synonym categories ( final string category0 , final string ... categories ) { synonym categories . add ( category0 ) ; synonym categories . add all ( arrays . as list ( categories ) ) ; return this ; }	Adds categories to the synonym_categories parameter.
public query profile request builder add blacklist categories ( final string category0 , final string ... categories ) { blacklist categories . add ( category0 ) ; blacklist categories . add all ( arrays . as list ( categories ) ) ; return this ; }	Adds categories to the blacklist_categories parameter.
public void initiate ( final i target ) { final string url = get call back url ( ) ; if ( url != null ) { target . prepend java script ( get call back script ( url ) ) ; } }	Call this method to initiate the download.
@ override public void on request ( ) { final string file name = get file name ( ) ; final i stream = get resource stream ( ) ; final resource stream request handler handler = new resource stream request handler ( stream , file name ) ; handler . set content disposition ( content disposition . attachment ) ; get component ( ) . get request cycle ( ) . schedule request handler after current ( handler ) ; }	On request, respond with a ResourcStream.
protected i get resource stream ( ) { final file file = e . get ( ) . get file ( ) ; final file resource stream ret = new file resource stream ( file ) ; e . get ( ) . set file ( null ) ; return ret ; }	Hook method providing the actual resource stream.
protected char sequence get call back script ( final string url ) { final string builder js = new string builder ( ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( url ) . append ( str ) . append ( str ) ; return dojo wrapper . require ( js , dojo classes . base window , dojo classes . dom , dojo classes . dom construct ) ; }	Script that searches for an existing iframe to use it for the download of the frame.If it does not exist it will be created.
public void send keep alive ( final application application ) { final long reference = new date ( ) . get time ( ) ; final concurrent map < string , i > session id2key = application . get meta data ( connection registry . sessio key ) ; final concurrent map < string , long > keepalive = application . get meta data ( connection registry . keepalive ) ; if ( keepalive != null ) { for ( final entry < string , long > entry : keepalive . entry set ( ) ) { if ( reference - entry . get value ( ) > configuration . get attribute as integer ( config attribute . websocket kath ) * num ) { final i key = session id2key . get ( entry . get key ( ) ) ; if ( key != null ) { final i registry = web socket settings . holder . get ( application ) . get connection registry ( ) ; final i conn = registry . get connection ( application , entry . get key ( ) , key ) ; if ( conn != null ) { try { conn . send message ( keep alive behavior . msg ) ; connection registry . log . debug ( str , entry . get key ( ) ) ; } catch ( final io e ) { connection registry . log . error ( str , e ) ; } } } } } } }	Send the KeepAlive.
private void init keep alive ( ) { if ( ! this . keep alive ) { this . keep alive = bool ; final keep alive task keep alive task = new keep alive task ( e . get ( ) . get application key ( ) ) ; final timer timer = new timer ( bool ) ;	Init the KeepAlive mechanism.
public static list < ui > get ui ( ) { final list < ui > ret = new array list < > ( ) ; final collection < user session > user sessions = registry manager . get user sessions ( ) ; for ( final user session user session : user sessions ) { ret . add ( new ui ( user session . get user name ( ) , user session . get session id ( ) , user session . get last activity ( ) ) ) ; } return ret ; }	Gets the UI user sessions.
@ override public void on component tag body ( final markup stream markup stream , final component tag open tag ) { set escape model strings ( bool ) ; string value = get default model object as string ( get default model object ( ) ) ;	Must be overwritten so that no replacing of html tags is done.
@ override protected void on render ( ) { final i markup = get markup ( ) ; if ( markup == null ) { throw new markup exception ( str + to string ( ) ) ; } final markup stream markup stream = new markup stream ( markup ) ;	Method is overwritten to prevent the annoing warnings from Component to come up.The warning come up due to the reason that this component moves the tags from parentelement to its child.
public static embedded link get dashboard link ( final string instance key , final string identifier ) { final embedded link ret = new embedded link ( instance key ) ; ret . set tag html ( tag . dashboard . get html ( ) ) ; ret . set identifier ( identifier ) ; return ret ; }	Gets the dashboard link.
< t > t parse response ( final token proxy < ? , ? > token proxy , final class < t > clazz , final response response ) { return unsafe parse response ( token proxy , object mapper . construct type ( clazz ) , response ) ; }	Parse the response into a type represented by the Class object.
< t > t parse response ( final token proxy < ? , ? > token proxy , final type reference < t > type reference , final response response ) { return unsafe parse response ( token proxy , object mapper . get type factory ( ) . construct type ( type reference ) , response ) ; }	Parse the response into a type represented by the TypeReference object.
< t > t unsafe parse response ( final token proxy < ? , ? > token proxy , final java type type , final response response ) { check refresh ( token proxy , response ) ; try { return object mapper . read value ( response . get body ( ) . in ( ) , type ) ; } catch ( final io e ) { throw new runtime exception ( e ) ; } }	Parse the response into a type represented by the JavaType object.
input stream parse response ( final token proxy < ? , ? > token proxy , final response response ) { check refresh ( token proxy , response ) ; try { return response . get body ( ) . in ( ) ; } catch ( final io e ) { throw new runtime exception ( e ) ; } }	Checks the response headers for a refreshed authentication token then returns the response body as an input stream.
@ override protected list < event definition > get events ( final event type event type ) { return field . get ( this . field id ) . get events ( event type ) ; }	Method to get the events that are related to this UITable.
protected void on component tag internal ( final component tag tag ) { tag . put ( str , get config ( ) . get name ( ) ) ; tag . append ( str , str + get config ( ) . get align ( ) , str ) ; }	Add to the tag.
@ override public void run ( ) { try { log . debug ( str , job id ) ; final job status < t > job status ; if ( token proxy != null ) { job status = job service . get job status ( token proxy , job id ) ; } else { job status = job service . get job status ( job id ) ; } final status job status status = job status . get status ( ) ; if ( job status status == status . finished || job status status == status . failed ) { for ( final action < t > action : job status . get actions ( ) ) { final status status = action . get status ( ) ; if ( status == status . finished ) { log . debug ( str ) ; callback . success ( action . get result ( ) ) ; } else if ( status == status . failed ) { log . debug ( str ) ; for ( final hod error error : action . get errors ( ) ) { log . debug ( str , error ) ; callback . error ( error . get error code ( ) ) ; } } } } else if ( timeout != null && timeout . is before ( local date time . now ( ) ) ) { callback . timeout ( ) ; log . debug ( str ) ; } else { log . debug ( str ) ;	Checks the status of the job. If the job has not finished, the runnable will schedule itself to run again after ashort wait.
@ override public void on component tag ( final component component , final component tag tag ) { super . on component tag ( component , tag ) ; if ( this . type == d . behavior type . item ) { string value = str ; if ( tag . get attribute ( str ) != null ) { value += tag . get attribute ( str ) ; } tag . put ( str , this . dnd type ) ; tag . put ( str , value ) ; } }	The tag of the component must be altered, so that the dojo dnd will be rendered.
@ override public void render head ( final component component , final i response ) { super . render head ( component , response ) ; response . render ( require header item . for classes ( dojo classes . d , dojo classes . parser ) ) ; if ( this . type == d . behavior type . source ) { final string builder js = new string builder ( ) . append ( str ) . append ( component . get markup id ( bool ) ) . append ( str ) . append ( str + this . dnd type + str ) . append ( str ) . append ( this . append java script ) . append ( str ) ; response . render ( on dojo ready header item . for script ( dojo wrapper . require ( js , dojo classes . aspect , dojo classes . dom , dojo classes . d ) ) ) ; } }	Add the javascriupt to the head of the webpage.
public void set default ( final uuid select cmd uuid ) { final ui menu item = get provider ( ) . get roots ( ) . next ( ) ; menu item . set header ( bool ) ; boolean has default = bool ; for ( final ui child item : menu item . get children ( ) ) { if ( select cmd uuid == null && child item . is default selected ( ) || select cmd uuid != null && select cmd uuid . equals ( child item . get command uuid ( ) ) ) { has default = bool ; child item . set selected ( bool ) ; } } if ( ! has default ) { menu item . set selected ( bool ) ; } expand ( menu item ) ; expand children ( menu item ) ; }	Set the default selected item.
public static string get label ( final string cmd name , final string keytype ) { final string ret ; if ( db . has property ( cmd name + str + keytype ) ) { ret = db . get property ( cmd name + str + keytype ) ; } else { ret = db . get property ( str + keytype ) ; } return ret ; }	Method that gets the Value for the Buttons from the DBProperties.
@ override protected void on after render ( ) { super . on after render ( ) ; if ( get default model ( ) != null ) { final ui headermodel = ( ui ) get default model object ( ) ; headermodel . set markup id ( this . get markup id ( ) ) ; } }	Set the markupid into the model.
public list < string value > get date as string ( final list < string value > date , final list < string value > hour , final list < string value > minute , final list < string value > ampm ) throws e { final list < string value > ret = new array list < > ( ) ; final list < date time > dates = get date list ( date , hour , minute , ampm ) ; for ( final date time date : dates ) { final date time formatter isofmt = iso . date time ( ) ; ret . add ( string value . value of ( date . to string ( isofmt ) ) ) ; } return ret ; }	Method to get for the parameters returned from the form as a valid string. for a datetime.
@ override protected void on after render ( ) { super . on after render ( ) ; final i container = this . find parent ( i . class ) ; if ( container != null ) { container . add date component ( this ) ; } }	After rendering the datefields are added to the parent.
public void destroy ( ) { log . debug ( str ) ; executor service . shutdown ( ) ; try { if ( ! executor service . await termination ( num , time unit . seconds ) ) { log . debug ( str ) ; executor service . shutdown now ( ) ; } } catch ( final interrupted exception e ) { log . debug ( str ) ; executor service . shutdown now ( ) ; } }	Shuts down the executor service. This method should be called when the job service is no longer needed, if thedefault executor service was used.
@ override @ suppress warnings ( str ) public void on click ( final ajax request target target ) { instance instance = null ; try { if ( this . target . equals ( script target . top ) ) { final page reference reference = ( ( abstract content page ) get page ( ) ) . get called by page reference ( ) ; if ( reference != null ) { final ui menu item = ( ui ) ( ( content container page ) reference . get page ( ) ) . get menu tree ( ) . get selected ( ) . get default model object ( ) ; final recent object link link = new recent object link ( menu item ) ; if ( link != null ) { ( ( e ) get session ( ) ) . add recent ( link ) ; } } } final ui ui field = super . get model object ( ) ; if ( ui field . get instance key ( ) != null ) { menu menu = null ; try { instance = ui field . get instance ( ) ; menu = menu . get type tree menu ( instance . get type ( ) ) ; } catch ( final exception e ) { if ( menu == null ) { throw new e ( load in target ajax link . class , str , instance ) ; } } final content container page page = new content container page ( menu . get uuid ( ) , ui field . get instance key ( ) , ui field . get parent ( ) instanceof ui ) ; final char sequence url = url for ( new render page request handler ( new page provider ( page ) ) ) ;	Method to load something inside the opener window.
@ override protected void on component tag ( final component tag tag ) { if ( this . action url == null ) { this . action url = url for ( get request cycle ( ) . get active request handler ( ) ) . to string ( ) ; } super . on component tag ( tag ) ; if ( get page ( ) . get default model object ( ) != null ) {	On component tag.
private void reset set counter ( ) { if ( get page ( ) . get default model object ( ) instanceof ui ) { for ( final element element : ( ( ui ) get page ( ) . get default model object ( ) ) . get elements ( ) ) { if ( element . get type ( ) . equals ( element type . form ) ) { final iterator < form row > iter = ( ( ui . form element ) element . get element ( ) ) . get row models ( ) ; while ( iter . has next ( ) ) { final form row row = iter . next ( ) ; for ( final iui ui element : row . get values ( ) ) { if ( ui element instanceof ui ) { ( ( ui ) ui element ) . reset index ( ) ; } } } } else if ( element . get type ( ) . equals ( element type . subform ) ) { for ( final element n element : ( ( ui ) element . get element ( ) ) . get elements ( ) ) { if ( n element . get type ( ) . equals ( element type . form ) ) { final iterator < form row > iter = ( ( ui . form element ) n element . get element ( ) ) . get row models ( ) ; while ( iter . has next ( ) ) { final form row row = iter . next ( ) ; for ( final iui ui element : row . get values ( ) ) { if ( ui element instanceof ui ) { ( ( ui ) ui element ) . reset index ( ) ; } } } } } } } } }	Reset the counters for sets.
@ override public void init ( final filter config filter config ) throws servlet exception { super . init ( filter config ) ; try { this . login handler = new login handler ( app access handler . get application key ( ) ) ; } catch ( final e e ) { abstract authentication filter . log . error ( str , e ) ; } }	Called by the web container to indicate to a filter that it is beingplaced into service.
@ override protected void do filter ( final http servlet request request , final http servlet response response , final filter chain chain ) throws io , servlet exception { if ( is logged in ( request ) ) { chain . do filter ( request , response ) ; } else { do authenticate ( request , response , chain ) ; } }	If the current user is already logged in, nothing is filtered.
protected boolean check login ( final string name , final string passwd ) { boolean login ok = bool ; context context = null ; try { context = context . begin ( ) ; boolean ok = bool ; try { if ( this . login handler . check login ( name , passwd ) != null ) { login ok = bool ; } ok = bool ; } finally { if ( ok && context . is tm ( ) ) { context . commit ( ) ; } else { if ( context . is tm ( ) ) { abstract authentication filter . log . error ( str ) ; } else { abstract authentication filter . log . error ( str ) ; } context . rollback ( ) ; } } } catch ( final e e ) { abstract authentication filter . log . error ( str , e ) ; } finally { context . close ( ) ; } return login ok ; }	Checks if the user with given name and password is allowed to login.
@ override public void on request ( final ajax request target target ) { final ui ui object = ( ui ) get default model object ( ) ; final string builder snip = new string builder ( ) ; try { final ui page object = ( ui ) get page ( ) . get default model object ( ) ; final map < string , string > ui i = page object == null ? null : page object . get ui i ( ) ; final list < return > returns = ui object . execute events ( null , ui i ) ; for ( final return one return : returns ) { if ( one return . contains ( return values . sniplett ) ) { snip . append ( one return . get ( return values . sniplett ) ) ; } } } catch ( final e e ) { throw new restart response exception ( new error page ( e ) ) ; } target . append java script ( snip . to string ( ) ) ; }	On submit.
protected char sequence get print menu items ( final set < dojo class > dojo classes ) { final string builder ret = new string builder ( ) ; collections . add all ( dojo classes , dojo classes . menu item ) ; final print behavior print behavior = ( print behavior ) get behavior ( print behavior . class ) ; final string [ ] mimes = new string [ ] { str , str } ; for ( final string mime : mimes ) { if ( ret . length ( ) > num ) { ret . append ( str ) ; } ret . append ( str ) . append ( str ) . append ( mime ) . append ( str ) . append ( str ) . append ( mime . to upper case ( ) ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( str ) . append ( print behavior . get callback function body ( callback parameter . resolved ( str , str + mime + str ) , callback parameter . explicit ( str ) , callback parameter . explicit ( str ) ) ) . append ( str ) . append ( str ) ; } return ret ; }	Gets the prints the menu items.
protected char sequence get menu ( final set < dojo class > dojo classes ) throws e { final string builder ret = new string builder ( ) ; final ui ui grid = ( ui ) get default model object ( ) ; if ( ! ( ui grid instanceof ui ) && ui grid . get command ( ) . get target menu ( ) != null ) { collections . add all ( dojo classes , dojo classes . menu bar , dojo classes . drop down menu , dojo classes . menu item , dojo classes . popup menu bar item , dojo classes . menu bar item ) ; ret . append ( str ) ; for ( final abstract command child : ui grid . get command ( ) . get target menu ( ) . get commands ( ) ) { if ( child . has access ( ui grid . get command ( ) . get target mode ( ) , ui grid . get instance ( ) ) ) { if ( child instanceof abstract menu ) { ret . append ( get sub menu ( ( abstract menu ) child , str ) ) ; } else { ret . append ( str ) . append ( get menu item ( child , bool ) ) . append ( str ) ; } } } } return ret ; }	Gets the menu.
protected char sequence get sub menu ( final abstract menu menu , final string parent ) throws e { final string var = random util . random alphabetic ( num ) ; final string builder js = new string builder ( ) ; js . append ( str ) . append ( var ) . append ( str ) ; final ui ui grid = ( ui ) get default model object ( ) ; for ( final abstract command child : menu . get commands ( ) ) { if ( child . has access ( ui grid . get command ( ) . get target mode ( ) , ui grid . get instance ( ) ) ) { if ( child instanceof abstract menu ) { js . append ( get sub menu ( ( abstract menu ) child , var ) ) ; } else { js . append ( var ) . append ( str ) . append ( get menu item ( child , bool ) ) . append ( str ) ; } } } js . append ( parent ) . append ( str ) . append ( str ) . append ( string escape utils . escape ecma script ( menu . get label property ( ) ) ) . append ( str ) . append ( str ) . append ( var ) . append ( str ) . append ( str ) ; return js ; }	Gets the sub menu.
public static char sequence get data js ( final ui ui grid ) throws e { final string builder ret = new string builder ( ) . append ( str ) ; int i = num ; for ( final grid row row : ui grid . get values ( ) ) { if ( i > num ) { ret . append ( str ) ; } ret . append ( get row js ( row , string . value of ( i ) ) ) ; i ++ ; } ret . append ( str ) ; return ret ; }	Gets the data JS.
public static char sequence get data reload js ( final ui ui grid ) throws e { final string builder js = new string builder ( ) . append ( str ) . append ( str ) . append ( x . get data js ( ui grid ) ) ; final string builder dialog js = new string builder ( ) ; if ( ! ui grid . is columns up to date ( ) ) {	Gets the javascript.
@ override protected void on event ( final ajax request target target ) { final modal window container modal = get component ( ) . get page ( ) . visit children ( modal window container . class , new modal visitor ( ) ) ; modal . show ( target ) ; }	Show the modal window.
public void add value ( final instance row instance , final ui ui field set value ) { this . inst key2row . get ( row instance . get key ( ) ) . add ( ui field set value ) ; }	Adds the value.
public int get index ( final string input name ) { integer ret = num ; if ( this . indexes . contains key ( input name ) ) { ret = this . indexes . get ( input name ) + num ; } this . indexes . put ( input name , ret ) ; return ret ; }	Gets the index.
public void add new row ( ) throws e { final ui row = new ui ( this ) ; this . rows . add ( row ) ; for ( final ui header : get headers ( ) ) { final ui ui value = ui . get ( field . get ( header . get field id ( ) ) , attribute . get ( header . get attr id ( ) ) , null ) ; final ui cell set value = new ui ( get parent ( ) , null , this , ui value ) ; row . add ( cell set value ) ; } }	Add a new Row.
private void add children ( final ui ui class , final boolean force ) { if ( force || ui class . is expanded ( ) ) { get model object ( ) . add ( ui class ) ; for ( final ui child : ui class . get children ( ) ) { add children ( child , force ) ; } } }	Recursive method to add child classifications.
public static char sequence get help ( final long cmd id ) { char sequence ret ; try { final class < ? > clazz = class . for name ( configuration . get attribute ( configuration . config attribute . helpsnipprov ) , bool , e . get instance ( ) ) ; final i provider = ( i ) clazz . new instance ( ) ; ret = provider . get help ( cmd id ) ; } catch ( final class not found exception | instantiation exception | illegal access exception | e e ) { help util . log . error ( str , e ) ; ret = str ; } return ret ; }	Gets the help.
protected ui get new structur browser ( final instance instance , final ui struc brwsr ) throws e { final uuid uuid ; if ( struc brwsr . get table ( ) == null ) { uuid = menu . get type tree menu ( instance . get type ( ) ) . get uuid ( ) ; } else { uuid = struc brwsr . get command uuid ( ) ; } final ui ret = new ui ( uuid , instance == null ? null : instance . get key ( ) , bool , struc brwsr . get sort direction ( ) ) ; ret . set parent brws ( this ) ; ret . set level ( get level ( ) + num ) ; return ret ; }	Internal method to call a constructor, it is used to set that thisStructurBrowserModel is not a root.
protected void initialise ( ) throws e { final abstract command command = get command ( ) ; if ( command != null && command . get target table ( ) != null ) { set table uuid ( command . get target table ( ) . get uuid ( ) ) ; this . browser field name = command . get target structur browser field ( ) ; set show check boxes ( command . is target show check boxes ( ) ) ; } else if ( get instance ( ) != null ) { final string tmplabel = menu . get type tree menu ( get instance ( ) . get type ( ) ) . get label ( ) ; this . value label = db . get property ( tmplabel ) ; }	Method used to initialize this StructurBrowserModel.
@ suppress warnings ( str ) protected void expand ( final boolean expand ) { try {	Expand the tree with the information from the Session.
protected void sort model ( ) { set execution status ( ui . execution status . sort ) ; try { get object4 event ( ) . execute events ( event type . ui table evaluate , parameter values . class , this ) ; if ( get sort direction ( ) == sort direction . descending ) { collections . reverse ( this . children ) ; } } catch ( final e e ) { throw new restart response exception ( new error page ( e ) ) ; } }	Method to sort the data of this model.
public void check hide column4 row ( ) { set execution status ( ui . execution status . checkhidecolum row ) ; try { get object4 event ( ) . execute events ( event type . ui table evaluate , parameter values . instance , get instance ( ) , parameter values . class , this ) ; } catch ( final e e ) { throw new restart response exception ( new error page ( e ) ) ; } }	Method is called from the StructurBrowser in edit mode before renderingthe columns for row to be able to hide the columns for different rows bysetting the cell model to hide.
protected boolean check for allow children ( final instance instance ) { set execution status ( ui . execution status . allowschildren ) ; try { final list < return > ret = get object4 event ( ) . execute events ( event type . ui table evaluate , parameter values . instance , instance , parameter values . class , this ) ; return ret . is empty ( ) ? bool : ret . get ( num ) . get ( return values . true ) != null ; } catch ( final e e ) { throw new restart response exception ( new error page ( e ) ) ; } }	This method is used to check if a node has potential children.
public void execute listener ( final execution status status , final map < string , string > ui i ) { set execution status ( status ) ; try { get object4 event ( ) . execute events ( event type . ui table evaluate , parameter values . instance , get instance ( ) , parameter values . class , this , parameter values . oidma ui , ui i ) ; } catch ( final e e ) { throw new restart response exception ( new error page ( e ) ) ; } }	This method is used to execute a listener with a specific event.
public void requery label ( ) { try { final value parser parser = new value parser ( new string reader ( this . value label ) ) ; final value list val list = parser . expression string ( ) ; final print query print = new print query ( get instance ( ) ) ; val list . make select ( print ) ; if ( print . execute ( ) ) { set label ( val list . make string ( get instance ( ) , print , get mode ( ) ) . to string ( ) ) ; } } catch ( final e e ) { throw new restart response exception ( new error page ( e ) ) ; } catch ( final parse exception e ) { throw new restart response exception ( new error page ( e ) ) ; } }	This method is updating the Label, by querying the eFaps-DataBase.
@ override public final void bind ( final component host component ) { args . not null ( host component , str ) ; if ( this . component != null ) { throw new illegal state exception ( str + str + this . component + str + host component + str ) ; } this . component = host component ; this . component . set output markup id ( bool ) ; }	Bind this handler to the given component.
private data table < element , void > get data table ( final index search index search ) { final list < i < element , void > > columns = new array list < > ( ) ; columns . add ( new abstract column < element , void > ( new model < > ( str ) ) { private static final long serial version uid = num ; @ override public void populate item ( final item < i < element > > cell item , final string component id , final i < element > row model ) { cell item . add ( new link ( component id , row model ) ) ; } } ) ; if ( index search . get search ( ) == null || index search . get search ( ) . get result fields ( ) . is empty ( ) ) { columns . add ( new property column < element , void > ( new model < > ( str ) , str ) ) ; } else { for ( final entry < string , collection < string > > entry : index search . get search ( ) . get result fields ( ) . entry set ( ) ) { columns . add ( new result column ( index search . get search ( ) . get result label ( ) . get ( entry . get key ( ) ) , entry . get value ( ) ) ) ; } } final data table < element , void > ret = new data table < > ( str , columns , index search . get data provider ( ) , index search . get search ( ) == null ? num : index search . get search ( ) . get num hits ( ) ) ; ret . add top toolbar ( new headers toolbar < > ( ret , null ) ) ; return ret ; }	Gets the data table.
public list < return > execute events ( final object others , final map < string , string > ui i ) throws e { if ( this . execution status == null ) { this . execution status = execution status . execute ; } final list < return > ret = execute events ( event type . ui field cmd , others , ui i ) ; if ( this . execution status == execution status . execute ) { this . execution status = null ; } return ret ; }	Execute the underlying events.
public string get rendered content ( final string script , final map < string , string > ui i ) throws e { this . execution status = ui . execution status . render ; final string builder snip = new string builder ( ) ; final list < return > returns = execute events ( script , ui i ) ; for ( final return one return : returns ) { if ( one return . contains ( return values . sniplett ) ) { snip . append ( one return . get ( return values . sniplett ) ) ; } } this . execution status = null ; return snip . to string ( ) ; }	Get the script to render the content for the UserInterface in case thatnot a standard button should be rendered.
private abstract command get command ( final uuid uuid ) throws cache reload exception { abstract command cmd = command . get ( uuid ) ; if ( cmd == null ) { cmd = menu . get ( uuid ) ; if ( cmd == null ) { cmd = search . get ( uuid ) ; } } return cmd ; }	Method to get a Command.
private string get label ( final i ui cmd object , final string keytype ) throws e { final string ret ; if ( db . has property ( cmd object . get command ( ) . get name ( ) + str + keytype ) ) { ret = db . get property ( cmd object . get command ( ) . get name ( ) + str + keytype ) ; } else { ret = db . get property ( str + keytype ) ; } return ret ; }	Method that searches a DBProperty for the Label.
public synchronized void prune finished tasks ( ) { final array list < i > non finished bridges = new array list < > ( ) ; for ( final i bridge : this . execution bridges ) { if ( ! bridge . is finished ( ) ) { non finished bridges . add ( bridge ) ; } } this . execution bridges = non finished bridges ; }	Prune finished tasks.
public iterator < i > get jobs page ( final int start , final int size ) { final int min = math . min ( size , this . execution bridges . size ( ) ) ; return new array list < > ( this . execution bridges . sub list ( start , min ) ) . iterator ( ) ; }	Gets the tasks page.
public i get bridge4 job ( final string job name , final boolean prune ) { i ret = null ; for ( final i bridge : this . execution bridges ) { if ( bridge . get job name ( ) . equals ( job name ) ) { ret = bridge ; if ( prune && ret . is finished ( ) ) { this . execution bridges . remove ( ret ) ; } break ; } } return ret ; }	Gets the bridge for job.
public boolean is loged in ( ) { boolean ret = bool ; if ( this . user name != null ) { ret = bool ; } else if ( ! is session invalidated ( ) ) { ret = lazy login ( ) ; } return ret ; }	Method to check if a user is checked in.
private boolean lazy login ( ) { boolean ret = bool ; final http servlet request http request = ( ( servlet web request ) request cycle . get ( ) . get request ( ) ) . get container request ( ) ; final http session http session = http request . get session ( bool ) ; if ( http session != null && ! ( http session instanceof http session copy ) ) { for ( final i login provider : e . get ( ) . get login providers ( ) ) { this . user name = login provider . login ( http session ) ; if ( this . user name != null ) { break ; } } if ( this . user name != null ) { open context ( ) ; try { set attribute ( e . login attribute name , this . user name ) ; this . session attributes . put ( user attributes set . contextmapkey , new user attributes set ( this . user name ) ) ; } catch ( final e e ) { e . log . error ( str , e ) ; } registry manager . register user session ( this . user name , get id ( ) ) ; ret = bool ; request cycle . get ( ) . set response page ( gather info page . class ) ; } } return ret ; }	Lazy login is used in copmination with a Single Sign On mechanism.
public final void login ( ) { final i paras = request cycle . get ( ) . get request ( ) . get request parameters ( ) ; final string value name = paras . get parameter value ( str ) ; final string value pwd = paras . get parameter value ( str ) ; if ( check login ( name . to string ( ) , pwd . to string ( ) ) ) { this . user name = name . to string ( ) ;	Method to log a user with the Parameters from the Request in.
public final void logout ( ) { if ( this . session attributes . contains key ( user attributes set . contextmapkey ) ) { try { usage registry . store ( ) ; ( ( user attributes set ) this . session attributes . get ( user attributes set . contextmapkey ) ) . store in db ( ) ; access cache . clean4 person ( context . get thread context ( ) . get person id ( ) ) ; } catch ( final e e ) { e . log . error ( str , e ) ; } finally { this . session attributes . clear ( ) ; remove attribute ( e . login attribute name ) ; invalidate ( ) ; } } close context ( ) ; this . user name = null ; }	Logs a user out and stores the UserAttribues in the eFaps database.
public query request builder add indexes ( final resource identifier index0 , final resource identifier ... indexes ) { this . indexes . add ( index0 ) ; this . indexes . add all ( arrays . as list ( indexes ) ) ; return this ; }	Adds indexes to the indexes parameter.
public static i < i ui > get model ( final long cmd id , final instance instance ) { return model . < i ui > of ( ui . get ( cmd id ) . set instance ( instance ) ) ; }	Gets the model.
@ suppress warnings ( str ) protected void add components ( final form container form ) throws e { this . form = form ; add ( new keep alive behavior ( ) ) ;	Method that adds the Components to the Page.
@ override public markup container add ( final component ... childs ) { markup container ret = null ; for ( final component child : childs ) { if ( child instanceof html header container ) { ret = add2 page ( child ) ; } else { ret = body . add ( childs ) ; } } return ret ; }	Adds a child component to this container or to the body.
private boolean convert date field values ( final ajax request target target ) throws e { ajax submit close button . log . trace ( str ) ; boolean ret = bool ; final string builder html = new string builder ( ) ; html . append ( str ) ; final e parameters = ( e ) get request ( ) . get request parameters ( ) ; final set < string > names = parameters . get parameter names ( ) ; for ( final date time panel datepicker : ( ( form container ) get form ( ) ) . get date components ( ) ) { if ( names . contains ( datepicker . get date field name ( ) ) ) { final list < string value > date = parameters . get parameter values ( datepicker . get date field name ( ) ) ; final list < string value > hour = parameters . get parameter values ( datepicker . get hour field name ( ) ) ; final list < string value > minute = parameters . get parameter values ( datepicker . get minute field name ( ) ) ; final list < string value > ampm = parameters . get parameter values ( datepicker . get am pm field name ( ) ) ; ret = datepicker . validate ( date , hour , minute , ampm , html ) ; if ( ret ) { parameters . set parameter values ( datepicker . get field name ( ) , datepicker . get date as string ( date , hour , minute , ampm ) ) ; } else { break ; } } } if ( ! ret ) { html . append ( str ) ; show dialog ( target , html . to string ( ) , bool , bool ) ; } return ret ; }	Method used to convert the date value from the ui in date values foreFaps.
private boolean convert field values ( final ajax request target target ) throws e { ajax submit close button . log . trace ( str ) ; final e parameters = ( e ) get request ( ) . get request parameters ( ) ; final form container frm container = ( form container ) get form ( ) ; for ( final i converter : frm container . get value converters ( ) ) { converter . convert value ( parameters ) ; } return bool ; }	Method used to convert the values from the ui in values foreFaps.
@ override public void on error ( final ajax request target target ) { final feedback collector collector = new feedback collector ( get form ( ) . get page ( ) ) ; final list < feedback message > msgs = collector . collect ( ) ; final error message resource msg resource = new error message resource ( ) ; final string builder html = new string builder ( ) . append ( str ) ; for ( final feedback message msg : msgs ) { if ( ! ( msg . get reporter ( ) instanceof form ) ) { if ( msg . get reporter ( ) instanceof auto complete combo box ) { final string builder js = new string builder ( ) . append ( str ) . append ( msg . get reporter ( ) . get markup id ( ) ) . append ( str ) ; target . prepend java script ( dojo wrapper . require ( js , dojo classes . dom , dojo classes . dom class ) ) ; } else { msg . get reporter ( ) . add ( attribute modifier . append ( str , str ) ) ; target . add ( msg . get reporter ( ) ) ; } } serializable warn = null ; if ( msg . get message ( ) instanceof validation error feedback ) {	Method is not used, but needed from the api.
private boolean validate field values ( final ajax request target target ) throws e { ajax submit close button . log . trace ( str ) ; boolean ret = bool ; final i ui uiobject = ( i ui ) get page ( ) . get default model object ( ) ; final string builder html = new string builder ( ) ; html . append ( str ) ; if ( uiobject instanceof ui ) { final ui uiform = ( ui ) uiobject ; ret = eval form element ( target , html , uiform ) ; } if ( ! ret ) { html . append ( str ) ; show dialog ( target , html . to string ( ) , bool , bool ) ; } return ret ; }	Method to validate the values for fields.
private boolean eval form element ( final ajax request target target , final string builder html , final ui uiform ) throws e { ajax submit close button . log . trace ( str ) ; boolean ret = bool ; for ( final element element : uiform . get elements ( ) ) { if ( element . get type ( ) . equals ( element type . form ) ) { final form element form element = ( form element ) element . get element ( ) ; for ( final iterator < form row > ui row iter = form element . get row models ( ) ; ui row iter . has next ( ) ; ) { for ( final iui object : ui row iter . next ( ) . get values ( ) ) { } } } else if ( element . get type ( ) . equals ( element type . subform ) ) { final ui ui field form = ( ui ) element . get element ( ) ; final boolean tmp = eval form element ( target , html , ui field form ) ; ret = ret ? tmp : ret ; } else if ( element . get type ( ) . equals ( element type . table ) ) { final ui ui field table = ( ui ) element . get element ( ) ; final list < ui > headers = ui field table . get headers ( ) ; for ( final ui ui row : ui field table . get values ( ) ) { ui row . get userinterface id ( ) ; final iterator < ui > header iter = headers . iterator ( ) ; for ( final i filterable : ui row . get cells ( ) ) { header iter . next ( ) ; } } } } return ret ; }	Recursive method to validate the elements of the form.
private boolean check for required ( final ajax request target target ) { ajax submit close button . log . trace ( str ) ; boolean ret = bool ; if ( ! ( get form ( ) . get parent ( ) . get default model ( ) instanceof table model ) ) { final i parameters = get request ( ) . get request parameters ( ) ; final list < form panel > panels = get form panels ( ) ; for ( final form panel panel : panels ) { for ( final entry < string , label > entry : panel . get required components ( ) . entry set ( ) ) { final string value value = parameters . get parameter value ( entry . get key ( ) ) ; if ( value . is null ( ) || value . is empty ( ) ) { final label label = entry . get value ( ) ; label . add ( attribute modifier . replace ( str , str ) ) ; target . add ( label ) ; ret = bool ; } } } if ( ! ret ) { show dialog ( target , str , bool , bool ) ; } } return ret ; }	Method checking if the mandatory field of the Form are filled with a value,and if not opens a WarnDialog and marks the fields in the Form via Ajax.
private list < form panel > get form panels ( ) { ajax submit close button . log . trace ( str ) ; final list < form panel > ret = new array list < > ( ) ; final iterator < ? > iterator = get form ( ) . iterator ( ) ; while ( iterator . has next ( ) ) { final object object = iterator . next ( ) ; if ( object instanceof web markup container ) { final iterator < ? > iterator2 = ( ( web markup container ) object ) . iterator ( ) ; while ( iterator2 . has next ( ) ) { final object object2 = iterator2 . next ( ) ; if ( object2 instanceof form panel ) { ret . add ( ( form panel ) object2 ) ; } } } } return ret ; }	Method to get the FormPanel of this Page.
private void show dialog ( final ajax request target target , final string key , final boolean is sniplett , final boolean go on button ) { final modal window container modal = ( ( abstract content page ) get page ( ) ) . get modal ( ) ; modal . set initial width ( num ) ; modal . set initial height ( num ) ; modal . set page creator ( new modal window . page creator ( ) { private static final long serial version uid = num ; @ override public page create page ( ) { return new dialog page ( ( ( abstract content page ) get page ( ) ) . get page reference ( ) , key , is sniplett , go on button ) ; } } ) ; if ( go on button ) { modal . set window closed callback ( new window closed callback ( ) { private static final long serial version uid = num ; @ override public void on close ( final ajax request target target ) { if ( ajax submit close button . this . validated ) { target . append java script ( get execute script ( ) ) ; } } } ) ; } modal . show ( target ) ; }	Shows a modal DialogPage.
@ override public void init ( final filter config filter config ) throws servlet exception { super . init ( filter config ) ; final string root = str + filter config . get servlet context ( ) . get servlet context name ( ) + str ; this . not logged in forward = str + filter config . get init parameter ( transaction filter . init param url login page ) ; if ( this . not logged in forward == null || this . not logged in forward . length ( ) == num ) { throw new servlet exception ( str + str + transaction filter . init param url login page + str ) ; } this . exlude uris . add ( ( root + this . not logged in forward ) . replace all ( str , str ) ) ; this . exlude uris . add ( ( root + str ) . replace all ( str , str ) ) ; final service loader < i > service loader logins = service loader . load ( i . class ) ; for ( final i login provider : service loader logins ) { log . info ( str , login provider ) ; this . login providers . add ( login provider ) ; } }	Called by the web container to indicate to a filter that it is beingplaced into service.
public static set < resource type > complement of ( final set < resource type > resource types ) { final set < resource type > set = all of ( ) ; set . remove all ( resource types ) ; return set ; }	Returns a set containing all the known resource types, except those is the given set.
public static set < resource type > of ( final resource type first , final resource type ... rest ) { final set < resource type > set = new hash set < > ( ) ; set . add ( first ) ; set . add all ( arrays . as list ( rest ) ) ; return set ; }	Returns a set containing the given resource types.
private boolean is check out ( final ui ui field ) { return string utils . contains ignore case ( ui field . get field configuration ( ) . get field ( ) . get reference ( ) , h . checkout . to string ( ) ) ; }	Checks if is a check out.
private boolean has access2 menu ( final ui ui field ) throws e { final menu menu = menu . get type tree menu ( ui field . get instance ( ) . get type ( ) ) ; return menu != null && menu . has access ( ui field . get parent ( ) . get mode ( ) , ui field . get instance ( ) ) && ( ! ( ( ui ) ui field . get parent ( ) ) . get access map ( ) . contains key ( ui field . get instance ( ) ) || ( ( ui ) ui field . get parent ( ) ) . get access map ( ) . contains key ( ui field . get instance ( ) ) && ( ( ui ) ui field . get parent ( ) ) . get access map ( ) . get ( ui field . get instance ( ) ) ) ; }	Checks for access to menu.
public string get type image ( ) throws e { string ret = null ; if ( get instance ( ) != null ) { final image image tmp = image . get type icon ( get instance ( ) . get type ( ) ) ; if ( image tmp != null ) { ret = image tmp . get name ( ) ; } } return ret ; }	This method returns the URL to the Image of this MenuItem.
public boolean requery label ( ) { boolean ret = bool ; try { string label tmp = db . get property ( get command ( ) . get label ( ) ) ; if ( get instance ( ) != null ) { final value parser parser = new value parser ( new string reader ( label tmp ) ) ; final value list list = parser . expression string ( ) ; if ( list . get expressions ( ) . size ( ) > num ) { final print query print = new print query ( get instance ( ) ) ; list . make select ( print ) ; if ( print . execute ( ) ) { label tmp = list . make string ( get instance ( ) , print , get mode ( ) ) ; } } } ret = ! label tmp . equals ( this . label ) ; this . label = label tmp ; } catch ( final e e ) { throw new restart response exception ( new error page ( e ) ) ; } catch ( final parse exception e ) { throw new restart response exception ( new error page ( e ) ) ; } return ret ; }	Requery the Label.
public static void remove pages4 session ( final string session id ) { final advanced cache < string , stored page > cache = infinispan cache . get ( ) . < string , stored page > get ign re cache ( infinispan page store . pagecache ) ; final query factory query factory = search . get query factory ( cache ) ; final query query = query factory . from ( stored page . class ) . having ( str ) . eq ( session id ) . build ( ) ; query . < stored page > list ( ) . for each ( stored page -> cache . remove ( stored page . get session id ( ) + str + stored page . get page ( ) . get page id ( ) ) ) ; }	Removes the session.
@ override protected void on component tag ( final component tag tag ) { tag . set name ( str ) ; super . on component tag ( tag ) ; on component tag internal ( tag ) ; }	The tag must be overwritten.
@ override public void on click ( ) { instance instance = null ; final ui ui field = super . get model object ( ) ; if ( ui field . get instance key ( ) != null ) { menu menu = null ; try { instance = ui field . get instance ( ) ; menu = menu . get type tree menu ( instance . get type ( ) ) ; } catch ( final e e ) { throw new restart response exception ( new error page ( e ) ) ; } if ( menu == null ) { final exception ex = new exception ( str + instance . get type ( ) . get name ( ) ) ; throw new restart response exception ( new error page ( ex ) ) ; } page page ; try { page = new content container page ( menu . get uuid ( ) , ui field . get instance key ( ) , get page ( ) instanceof structur browser page ) ; } catch ( final e e ) { page = new error page ( e ) ; } this . set response page ( page ) ; } }	Method is executed on click.
private e get e ( final request request ) { final i session store = web application . get ( ) . get session store ( ) ; final e session = ( e ) session store . lookup ( request ) ; return session ; }	Method to get the EFapsSession.
@ override public void on begin request ( final request cycle cycle ) { final e session = get e ( cycle . get request ( ) ) ; if ( session != null ) { session . open context ( ) ; registry manager . register activity ( session ) ; } e . log . debug ( str ) ; }	Called when the request cycle object is beginning its response.
@ override public void on end request ( final request cycle cycle ) { final e session = get e ( cycle . get request ( ) ) ; if ( session != null ) { session . close context ( ) ; } e . log . debug ( str ) ; }	Called when the request cycle object has finished its response.
public static void register user session ( final string user name , final string session id ) { if ( e . get max inactive interval ( ) > num ) { registry manager . get cache ( ) . put ( session id , new user session ( ) . set user name ( user name ) . set session id ( session id ) , - num , time unit . minutes , e . get max inactive interval ( ) + num , time unit . seconds ) ; } else { registry manager . get cache ( ) . put ( session id , new user session ( ) . set user name ( user name ) . set session id ( session id ) ) ; } registry manager . register login4 history ( user name , session id ) ; }	Register user session.
public static void register activity ( final e session ) { if ( session . is loged in ( ) && registry manager . get cache ( ) . contains key ( session . get id ( ) ) ) { final user session user session = registry manager . get cache ( ) . get ( session . get id ( ) ) ; if ( user session . is invalidated ( ) ) { session . invalidate ( ) ; } else { user session . register activity ( ) ; } } }	Register activity.
public static void add msg connection ( final string session id , final i key ) { if ( registry manager . get cache ( ) . contains key ( session id ) ) { registry manager . get cache ( ) . get ( session id ) . set connection key ( key ) ; } registry manager . log . debug ( str , session id ) ; }	Adds the msg connection.
public static void invalidate session ( final string session id ) { if ( registry manager . get cache ( ) . contains key ( session id ) ) { registry manager . get cache ( ) . get ( session id ) . mark invalid ( ) ; } }	Invalidate session.
public static void remove user session ( final string session id ) { if ( registry manager . get cache ( ) . contains key ( session id ) ) { registry manager . register logout4 history ( registry manager . get cache ( ) . get ( session id ) . get user name ( ) , session id ) ; registry manager . get cache ( ) . remove ( session id ) ; } }	Removes the user session.
public static set < string > get users ( ) { final set < string > ret = new hash set < > ( ) ; for ( final user session user session : registry manager . get cache ( ) . values ( ) ) { ret . add ( user session . get user name ( ) ) ; } return ret ; }	Gets the users.
public static list < i > get connections4 user ( final string login ) { final list < i > ret = new array list < > ( ) ; final search manager search manager = search . get search manager ( registry manager . get cache ( ) ) ; final query builder qbldr = search manager . build query builder for class ( user session . class ) . get ( ) ; final cache query < ? > query = search manager . get query ( qbldr . keyword ( ) . on field ( str ) . matching ( login ) . create query ( ) ) ; try ( result iterator < ? > iter = query . iterator ( ) ) { while ( iter . has next ( ) ) { final user session user session = ( user session ) iter . next ( ) ; if ( user session . get connection key ( ) != null ) { final i registry = web socket settings . holder . get ( e . get ( ) ) . get connection registry ( ) ; final i conn = registry . get connection ( e . get ( ) , user session . get session id ( ) , user session . get connection key ( ) ) ; if ( conn != null ) { ret . add ( conn ) ; } } } } return ret ; }	Gets the connections 4 user.
public static i get connection4 session ( final string session id ) { i ret = null ; if ( registry manager . get cache ( ) . contains key ( session id ) ) { final user session user session = registry manager . get cache ( ) . get ( session id ) ; if ( user session . get connection key ( ) != null ) { final i registry = web socket settings . holder . get ( e . get ( ) ) . get connection registry ( ) ; ret = registry . get connection ( e . get ( ) , user session . get session id ( ) , user session . get connection key ( ) ) ; } } return ret ; }	Gets the connection 4 session.
private static cache < string , user session > get cache ( ) {	Gets the cache.
protected void initialize ( final uuid command uuid , final string opener id ) throws cache reload exception { this . opener id = opener id ; if ( command uuid != null ) { final abstract command command = get command ( command uuid ) ; this . cmd uuid = command . get uuid ( ) ; set mode ( command . get target mode ( ) ) ; this . target = command . get target ( ) ; this . submit = command . is submit ( ) ; if ( command . get target search ( ) != null && ! ( this instanceof ui ) ) { this . calling cmd uuid = this . cmd uuid ; this . cmd uuid = command . get target search ( ) . get default command ( ) . get uuid ( ) ; set mode ( target mode . search ) ; if ( command . has events ( event type . ui command execute ) ) { this . submit = bool ; } } } }	Method initializes the model.
public abstract command get calling command ( ) throws cache reload exception { abstract command cmd = null ; if ( get calling command uuid ( ) != null ) { cmd = command . get ( get calling command uuid ( ) ) ; if ( cmd == null ) { cmd = menu . get ( get calling command uuid ( ) ) ; } } return cmd ; }	Get the CommandAbstract which was originally called from the Frontend andlet to the construction of this model.
public list < return > execute events ( final event type event type , final object ... object tuples ) throws e { list < return > ret = new array list < > ( ) ; final abstract command command ; if ( this . calling cmd uuid == null ) { command = this . get command ( ) ; } else { command = get calling command ( ) ; } if ( command . has events ( event type ) ) { final parameter param = new parameter ( ) ; if ( object tuples != null ) {	Execute the events.
private void add behaviors ( ) { if ( this . ui field . get field configuration ( ) . get field ( ) . has events ( event type . ui field update ) ) { final list < event definition > events = this . ui field . get field configuration ( ) . get field ( ) . get events ( event type . ui field update ) ; string event name = str ; for ( final event definition event : events ) { event name = event . get property ( str ) == null ? str : event . get property ( str ) ; } add ( new ajax field update behavior ( event name , model . of ( this . ui field ) , bool ) { private static final long serial version uid = num ; @ override protected void on submit ( final ajax request target target ) {	Adds the behaviors.
public int get width weight ( ) { int ret = num ; if ( ! is fixed width ( ) && has property ( ui . width ) ) { ret = integer . value of ( get property ( ui . width ) ) ; } return ret ; }	Gets the width weight.
public string eval label ( final ui ui value , final instance field inst ) throws cache reload exception { final string key ; if ( get field ( ) . get label ( ) == null ) { if ( ui value != null && ui value . get attribute ( ) != null ) { if ( field inst != null && field inst . is valid ( ) && field inst . get type ( ) . get attribute ( ui value . get attribute ( ) . get name ( ) ) != null ) { key = field inst . get type ( ) . get attribute ( ui value . get attribute ( ) . get name ( ) ) . get label key ( ) ; } else if ( ui value . get instance ( ) != null && ui value . get instance ( ) . get type ( ) . get attribute ( ui value . get attribute ( ) . get name ( ) ) != null ) { key = ui value . get instance ( ) . get type ( ) . get attribute ( ui value . get attribute ( ) . get name ( ) ) . get label key ( ) ; } else { key = ui value . get attribute ( ) . get label key ( ) ; } } else { key = field configuration . class . get name ( ) + str ; } } else { key = get field ( ) . get label ( ) ; } this . label = db . get property ( key ) ; return this . label ; }	Evaluate the label.
public boolean is table field ( ) { boolean ret = bool ; try { ret = get field ( ) . get collection ( ) instanceof table ; } catch ( final cache reload exception e ) { log . error ( str , e ) ; } return ret ; }	Checks if is table.
public static field configuration get sim field config ( final string field name ) { final field field = new field ( num , str , field name ) ; final field configuration ret = new field configuration ( num ) { private static final long serial version uid = num ; @ override public field get field ( ) { return field ; } } ; return ret ; }	Gets the field config.
public boolean is visible ( ) { initialize ( ) ; boolean ret = bool ; try { ret = this . snipplet . is visible ( ) ; } catch ( final e e ) { esjp invoker . log . error ( str , e ) ; } return ret ; }	Checks if is visible.
@ override protected void respond ( final ajax request target target ) { final string value horizontal = get component ( ) . get request ( ) . get request parameters ( ) . get parameter value ( ajax store position behavior . parameter horizontalposition ) ; final string value vertical tmp = get component ( ) . get request ( ) . get request parameters ( ) . get parameter value ( ajax store position behavior . parameter verticalposition ) ; if ( ! horizontal . is null ( ) ) { configuration . set attribute ( config attribute . splitterposhorizontal , horizontal . to string ( ) ) ; } if ( ! vertical tmp . is null ( ) ) { configuration . set attribute ( config attribute . splitterposvertical , vertical tmp . to string ( ) ) ; } }	On request the values are stored.
protected void initialize ( final i < t > model , final e reference , final string label ) { final button link < t > link ; if ( model == null ) { link = new button link < > ( str ) ; } else { link = new button link < > ( str , model ) ; } add ( link ) ; link . add ( new button image ( str , reference ) ) ; link . add ( new label ( str , label == null ? str : label ) ) ; }	Init the component.
@ suppress warnings ( str ) @ override public iterator < map < string , string > > get choices ( final string input ) { final list < map < string , string > > ret list = new array list < map < string , string > > ( ) ; try { final ui page object = ( ui ) get page ( ) . get default model object ( ) ; final map < string , string > ui i = page object == null ? null : page object . get ui i ( ) ; final list < return > returns = this . auto complete . get auto completion ( input , ui i ) ; for ( final return a return : returns ) { final object ob = a return . get ( return values . values ) ; if ( ob instanceof list ) { ret list . add all ( ( collection < ? extends map < string , string > > ) ob ) ; } } } catch ( final e e ) { auto complete combo box . log . error ( str , e ) ; } return ret list . iterator ( ) ; }	Method to get the values from the esjp.
public static date time formatter get date time formatter ( ) throws e { final string format str = configuration . get attribute ( configuration . config attribute . format datetime ) ; final date time formatter ret ; if ( format str . matches ( str ) ) { ret = date time format . for style ( format str ) ; } else { ret = date time format . for pattern ( format str ) ; } return ret . with locale ( context . get thread context ( ) . get locale ( ) ) ; }	Gets the date time formatter.
@ override protected void do get ( final http servlet request req , final http servlet response resp ) throws servlet exception { string file name = req . get request uri ( ) ; file name = file name . substring ( file name . last index of ( str ) + num ) ; try { final person pers = context . get thread context ( ) . get person ( ) ; if ( pers != null ) { final file file = get file ( pers . get id ( ) , file name ) ; if ( file != null && file . exists ( ) ) { resp . set content type ( get servlet context ( ) . get mime type ( file . get name ( ) ) ) ; resp . set content length ( ( int ) file . length ( ) ) ; resp . set date header ( str , system . current time millis ( ) ) ; resp . set date header ( str , system . current time millis ( ) ) ; resp . add header ( str , str + file . get name ( ) + str ) ; resp . set header ( str , str ) ; final file input stream input = new file input stream ( file ) ; io . copy ( input , resp . get output stream ( ) ) ; } } } catch ( final e e ) { file servlet . log . error ( str , e ) ; throw new servlet exception ( e ) ; } catch ( final io e ) { file servlet . log . error ( str , e ) ; throw new servlet exception ( e ) ; } }	Search for the requested file in the folder corresponding to the user of the context.
private string get menu ( ) throws e { help servlet . log . debug ( str ) ; final string builder ret = new string builder ( ) ; ret . append ( str ) ; final query builder query bldr = new query builder ( type . get ( str ) ) ;	get the CharSequence for the menu.
private void initialise ( ) throws e { final abstract command command = get command ( ) ; if ( command == null ) { set show check boxes ( bool ) ; } else {	Method that initializes the TableModel.
@ suppress warnings ( str ) protected list < instance > get instance list ( ) throws e {	Method to get the list of instance.
public void add filter list ( final ui uitable header , final set < ? > list ) { final table filter filter = new table filter ( uitable header , list ) ; this . filters . put ( uitable header . get field name ( ) , filter ) ; final ui orig = get header4 id ( uitable header . get field id ( ) ) ; if ( orig != null ) { orig . set filter applied ( bool ) ; } store filters ( ) ; }	Add a filterlist to the filters of this UiTable.
public void add filter classifcation ( final ui uitable header , final ui ui classification ) throws e { final table filter filter = new table filter ( uitable header , ui classification ) ; this . filters . put ( uitable header . get field name ( ) , filter ) ; final ui orig = get header4 id ( uitable header . get field id ( ) ) ; if ( orig != null ) { orig . set filter applied ( bool ) ; } store filters ( ) ; }	Add a classification based filters of this UiTable.
public table filter get filter ( final ui uitable header ) throws e { table filter ret = this . filters . get ( uitable header . get field name ( ) ) ; if ( ret != null && ret . get ui table header ( ) == null ) { ret = new table filter ( uitable header ) ; this . filters . put ( uitable header . get field name ( ) , ret ) ; } return ret ; }	Method to get a Filter from the list of filters belonging to thisUITable.
public list < string > get filter pick list ( final ui uitable header ) throws e { final list < string > ret = new array list < > ( ) ; for ( final ui rowmodel : this . values ) { for ( final i cell : rowmodel . get cells ( ) ) { if ( cell . belongs to ( uitable header . get field id ( ) ) ) { final string value = cell . get pick list value ( ) ; if ( ! ret . contains ( value ) ) { ret . add ( value ) ; } break ; } } } collections . sort ( ret ) ; return ret ; }	Get the List of values for a PICKERLIST.
private list < status > get status4 type ( final type type ) throws cache reload exception { final list < status > ret = new array list < > ( ) ; final status group grp = status . get ( type . get uuid ( ) ) ; if ( grp != null ) { ret . add all ( grp . values ( ) ) ; } else { for ( final type type : type . get child types ( ) ) { ret . add all ( get status4 type ( type ) ) ; } } return ret ; }	Recursive method to get all status for a Type representing a StatusGrp.
private void store filters ( ) { final map < string , table filter > sess filter = new hash map < > ( ) ; for ( final entry < string , table filter > entry : this . filters . entry set ( ) ) { sess filter . put ( entry . get key ( ) , entry . get value ( ) ) ; } try { context . get thread context ( ) . set session attribute ( get cache key ( ui . user cache key . filter ) , sess filter ) ; } catch ( final e e ) { ui . log . error ( str , get command uuid ( ) , e ) ; } }	Store the Filter in the Session.
public void remove filter ( final ui ui table header ) { this . filters . remove ( ui table header . get field name ( ) ) ; final ui orig = get header4 id ( ui table header . get field id ( ) ) ; if ( orig != null ) { orig . set filter applied ( bool ) ; } store filters ( ) ; }	Method to remove a filter from the filters.
@ suppress warnings ( str ) protected list < instance > get instances ( ) throws e { final list < return > returns = get event object ( ) . execute events ( event type . ui table evaluate , parameter values . instance , get call instance ( ) , parameter values . call instance , get call instance ( ) , parameter values . parameters , context . get thread context ( ) . get parameters ( ) , parameter values . class , this , parameter values . others , this . filter list ) ; list < instance > ret = null ; if ( returns . size ( ) < num ) { throw new e ( ui . class , str ) ; } else { final object result = returns . get ( num ) . get ( return values . values ) ; if ( result instanceof list ) { ret = ( list < instance > ) result ; } } return ret ; }	Gets the instances.
protected i get filter4 field ( final field field ) { final i ret ; switch ( field . get filter ( ) . get type ( ) ) { case status : case picklist : ret = new list filter ( field . get id ( ) ) ; break ; case freetext : case form : ret = new map filter ( field . get id ( ) ) ; break ; case classification : ret = new classification filter ( field . get id ( ) ) ; break ; case none : default : ret = new i ( ) { private static final long serial version uid = num ; @ override public long get field id ( ) { return field . get id ( ) ; } } ; break ; } return ret ; }	Gets the filter for field.
@ override public abstract command get command ( ) throws cache reload exception { abstract command cmd = command . get ( get cmd uuid ( ) ) ; if ( cmd == null ) { cmd = menu . get ( get cmd uuid ( ) ) ; } return cmd ; }	Gets the command.
public string get title ( ) { string title = str ; try { final string key = get command ( ) . get target title ( ) == null ? get command ( ) . get name ( ) + str : get command ( ) . get target title ( ) ; title = db . get property ( key ) ; if ( title != null && get call instance ( ) != null ) { final print query print = new print query ( get call instance ( ) ) ; final value parser parser = new value parser ( new string reader ( title ) ) ; final value list list = parser . expression string ( ) ; list . make select ( print ) ; if ( print . execute ( ) ) { title = list . make string ( get call instance ( ) , print , target mode . view ) ; }	This method retrieves the Value for the Title from the eFaps Database.
public boolean is date filter ( final i filter ) throws e { final boolean ret ; final field field = field . get ( filter . get field id ( ) ) ;	Checks if is date filter.
public grid row get row4 id ( final string row id ) throws e { final string [ ] row ids = row id . split ( str ) ; grid row row = null ; for ( final string id : row ids ) { if ( row == null ) { row = get values ( ) . get ( integer . parse int ( id ) ) ; } else { row = row . get children ( ) . get ( integer . parse int ( id ) ) ; } } return row ; }	Gets the row for id.
public static file print ( final ui ui grid ) { file ret = null ; final string clazz name = configuration . get attribute ( config attribute . gridprintesjp ) ; try { ui . log . debug ( str , ui grid ) ; final class < ? > clazz = class . for name ( clazz name , bool , e . get instance ( ) ) ; final event execution event = ( event execution ) clazz . new instance ( ) ; final parameter param = new parameter ( ) ; param . put ( parameter values . parameters , context . get thread context ( ) . get parameters ( ) ) ; param . put ( parameter values . class , ui grid ) ; final return retu = event . execute ( param ) ; if ( retu != null ) { ret = ( file ) retu . get ( return values . values ) ; } } catch ( final class not found exception | instantiation exception | illegal access exception e ) { ui . log . error ( str , e ) ; } catch ( final e e ) { ui . log . error ( str , e ) ; } return ret ; }	Prints the.
protected string get query ( ) { final string builder ret = new string builder ( ) ; try { final string clazzname ; if ( e . get ( ) . contains attribute value ( str ) ) { clazzname = e . get ( ) . get attribute value ( str ) ; } else { clazzname = str ; } final class < ? > clazz = class . for name ( clazzname , bool , e . get instance ( ) ) ; final object obj = clazz . new instance ( ) ; final method method = clazz . get method ( str , string . class , list . class , list . class ) ; final object new query = method . invoke ( obj , get current query ( ) , get included ( ) , get excluded ( ) ) ; ret . append ( new query ) ; } catch ( final e | class not found exception | instantiation exception | illegal access exception | no such method exception | security exception | illegal argument exception | invocation target exception e ) { index search . log . error ( str , e ) ; ret . append ( get current query ( ) ) ; } return ret . to string ( ) ; }	Gets the query.
private list < dim value > get excluded ( ) { final list < dim value > ret = new array list < > ( ) ; for ( final dim tree node node : get dimension provider ( ) . get root list ( ) ) { ret . add all ( node . get excluded ( ) ) ; } return ret ; }	Gets the excluded.
private boolean dim filter applied ( final list < dim tree node > nodes ) { final list < dim tree node > nodes = nodes == null ? get dimension provider ( ) . get root list ( ) : nodes ; boolean ret = bool ; for ( final dim tree node node : nodes ) { if ( node . get status ( ) != null ) { ret = bool ; break ; } ret = dim filter applied ( node . get children ( ) ) ; if ( ret ) { break ; } } return ret ; }	Check if a dimension filter applied.
private void fill dimension provider ( final boolean update dim ) { final dimension provider provider = get dimension provider ( ) ; final iterator < ? extends dim tree node > current iter = provider . get roots ( ) ; final list < dimension > dims = get dimensions ( ) ; if ( update dim && dims . is empty ( ) ) { provider . get root list ( ) . clear ( ) ; } else { collections . sort ( dims , new comparator < dimension > ( ) { @ override public int compare ( final dimension arg0 , final dimension arg1 ) { final string dim0 = db . get property ( dimension panel . class . get name ( ) + str + arg0 . get key ( ) ) ; final string dim1 = db . get property ( dimension panel . class . get name ( ) + str + arg1 . get key ( ) ) ; return dim0 . compare to ( dim1 ) ; } } ) ; final iterator < dimension > new dims iter = dims . iterator ( ) ; while ( current iter . has next ( ) ) { final dim tree node current = current iter . next ( ) ; if ( new dims iter . has next ( ) ) { final dimension new dim = new dims iter . next ( ) ; if ( ! new dim . get key ( ) . equals ( ( ( dimension ) current . get value ( ) ) . get key ( ) ) ) { current iter . remove ( ) ; } else if ( update dim ) { current . update ( new dim . get values ( ) ) ; } } }	Fill dimension provider.
private map < string , object > build hierarchy parameters ( final list < string > parents , final list < string > children ) { final multi map < string , object > parameters = new multi map < > ( ) ; if ( parents != null ) { for ( final string parent : parents ) { parameters . put ( str , parent ) ; } } if ( children != null ) { for ( final string child : children ) { parameters . put ( str , child ) ; } } return parameters ; }	Build the hierarchy parameters map for a create group request.
public static boolean root element matches ( file resource file resource , string path , string expected root element ) throws io { try ( input stream stream = file resource . create stream ( ) ) { xml reader = factory . create xml ( stream ) ; while ( reader . has next ( ) ) { int event = reader . next ( ) ; switch ( event ) { case xml . start element : string root element = reader . get local name ( ) ; return expected root element . equals ( root element ) ; } } } catch ( xml e ) { logger . warn ( str , path ) ; } return bool ; }	Matches a file resource for being an XML file with a specific rootelement.
public boolean touch ( ) { if ( expire after access > num ) { long now = system . current time millis ( ) ; if ( last access timestamp ms + last access threshold ms < now ) { last access timestamp ms = now ; return bool ; } } return bool ; }	"Touch" the cache entry.
protected void refresh ttl ( string key , cache entry ce ) { final string key = calc cache key ( key ) ; final long ttl = ce . get expire after access ( ) ; try ( sharded jedis jedis = get jedis ( ) ) { if ( ttl > num ) { if ( key mode == key mode . hash ) { jedis . expire ( get name ( ) , ( int ) ttl ) ; } else { jedis . expire ( safe encoder . encode ( key ) , ( int ) ttl ) ; } } } catch ( exception e ) { throw e instanceof cache exception ? ( cache exception ) e : new cache exception ( e ) ; } }	Refresh TTL of a cache entry.
public static object try clone ( object to be cloned ) { if ( to be cloned == null ) { return null ; } object cloned obj = null ; if ( to be cloned instanceof cloneable ) { try { method method = object . class . get declared method ( str ) ; method . set accessible ( bool ) ; cloned obj = method . invoke ( to be cloned ) ; } catch ( exception e ) { if ( e instanceof clone not supported exception ) { cloned obj = to be cloned ; } else { throw e instanceof runtime exception ? ( runtime exception ) e : new runtime exception ( e ) ; } } } else { cloned obj = to be cloned ; } return cloned obj ; }	Try cloning an object.
public abstract cache init ( ) { long old capacity = this . capacity ; try { string entry = get cache property ( cache prop capacity ) ; if ( entry != null ) { this . capacity = long . parse long ( entry ) ; } } catch ( exception e ) { this . capacity = old capacity ; logger . warn ( e . get message ( ) , e ) ; } if ( capacity < - num ) { set capacity ( - num ) ; } long old expire after access = this . expire after access ; try { string entry = get cache property ( cache prop expire after access ) ; if ( entry != null ) { this . expire after access = long . parse long ( entry ) ; } } catch ( exception e ) { this . expire after access = old expire after access ; logger . warn ( e . get message ( ) , e ) ; } if ( expire after access < - num ) { set expire after access ( - num ) ; } long old expire after write = this . expire after write ; try { string entry = get cache property ( cache prop expire after write ) ; if ( entry != null ) { this . expire after write = long . parse long ( entry ) ; } } catch ( exception e ) { this . expire after write = old expire after write ; logger . warn ( e . get message ( ) , e ) ; } if ( expire after write < - num ) { set expire after write ( - num ) ; } return this ; }	Initializes the cache before use.
public abstract cache set cache properties ( properties cache props ) { this . cache props = cache props != null ? new properties ( cache props ) : new properties ( ) ; return this ; }	Cache's custom properties.
protected string get cache property ( string key ) { return cache props != null ? cache props . get property ( key ) : null ; }	Get cache's custom property.
protected string calc cache key ( string key ) { switch ( key mode ) { case hash : case monopolistic : return key ; case namespace : return get name ( ) + str + key ; default : throw new illegal state exception ( str + key mode ) ; } }	Calculates cache key based on the key mode. HASH & MONOPOLISTIC mode: return the key as-is NAMESPACE mode: return {.
protected properties get cache properties ( string name ) { return cache properties != null ? cache properties . get ( name ) : null ; }	Gets a cache's properties.
@ override public void set ( string key , object entry , long expire after write , long expire after access ) { try { if ( local cache != null ) { local cache . set ( key , entry , expire after write , expire after access ) ; } if ( remote cache != null ) { remote cache . set ( key , entry , expire after write , expire after access ) ; } } catch ( exception e ) { throw e instanceof cache exception ? ( cache exception ) e : new cache exception ( e ) ; } }	Puts an entry to both local and remote caches, with specified expiries.
@ override public void delete ( string key ) { try { if ( local cache != null ) { local cache . delete ( key ) ; } if ( remote cache != null ) { remote cache . delete ( key ) ; } } catch ( exception e ) { throw e instanceof cache exception ? ( cache exception ) e : new cache exception ( e ) ; } }	Delete an entry from both local and remote caches.
public void delete local ( string key ) { if ( local cache != null ) { try { local cache . delete ( key ) ; } catch ( exception e ) { throw e instanceof cache exception ? ( cache exception ) e : new cache exception ( e ) ; } } }	Delete an entry from the local cache.
@ override public void delete all ( ) { try { if ( local cache != null ) { local cache . delete all ( ) ; } if ( remote cache != null ) { remote cache . delete all ( ) ; } } catch ( exception e ) { throw e instanceof cache exception ? ( cache exception ) e : new cache exception ( e ) ; } }	Deletes all entries in both local and remote caches.
public void delete all local ( ) { if ( local cache != null ) { try { local cache . delete all ( ) ; } catch ( exception e ) { throw e instanceof cache exception ? ( cache exception ) e : new cache exception ( e ) ; } } }	Deletes all entries in the local cache.
private void sort tab indexes ( ) { int tab index = num ; for ( form checker element elem : form . get elements ( ) ) { elem . set tab index ( tab index ) ; tab index = elem . get last tab index ( ) ; tab index ++ ; } }	resort tab-indexes.
@ deprecated final public string generate generic form ( string form action , boolean first run , form checker form form , request req , form checker config config ) { return this . generate generic form ( form action , first run , form , req , config . properties ) ; }	Renders the html for the complete form with all elements within.
string generate html for element ( boolean first run , message source message source , form checker element elem , boolean html5 validation ) { input element structure input struct = new input element structure ( ) ;	builds the html for one element.
public string get complete rendered input ( input element structure input struct , form checker element elem , boolean first run ) { string builder elem html = new string builder ( ) ; wrapper element wrapper = get wrapper for elem ( elem , first run ) ; elem html . append ( element wrapper . start ) ; elem html . append ( input struct . get errors ( ) ) ; wrapper label wrapper = get wrapper for label ( elem ) ; elem html . append ( label wrapper . start ) . append ( input struct . get label ( ) ) . append ( label wrapper . end ) ; wrapper input wrapper = get wrapper for input ( elem ) ; elem html . append ( input wrapper . start ) ; elem html . append ( input struct . get input ( ) ) ; elem html . append ( input struct . get help ( ) ) ; elem html . append ( input wrapper . end ) ; elem html . append ( element wrapper . end ) ; return elem html . to string ( ) ; }	override this, if you want to have a different order of the elements.
public string get element ( string name ) { return form builder . generate html for element ( fc . first run , fc . config . get properties ( ) , form . get element ( name ) , this . form . is html5 validation ( ) ) ; }	input-element via a macro!.
public static application context register app context ( string embedded web context , application context app context ) { return app context map . put ( embedded web context , app context ) ; }	Registers the specified embedded web context.
@ deprecated public static select input build ( string name , linked hash map < string , string > possible names ) { select input si = select input . build ( name ) ; si . set possible values ( possible names ) ; return si ; }	a map is not a good structure for that, because keys may be used more than once.
protected string build all attributes ( tag attributes tag attributes , message source message source , boolean html5 validation ) { string builder all attribs = new string builder ( ) ; all attribs . append ( attribute utils . build attributes ( tag attributes ) ) ; all attribs . append ( get element id ( ) ) ; all attribs . append ( get tab index tag ( ) ) ; if ( html5 validation ) { all attribs . append ( build required attribute ( ) ) ; all attribs . append ( build fc required message ( message source ) ) ; } all attribs . append ( build size attribute ( ) ) ;	builds attribs, elementId, TabIndex.
public string build max len ( ) { list < criterion > criteria = this . get criteria ( ) ; if ( criteria != null ) { for ( criterion criterion : criteria ) { if ( criterion instanceof max length ) { return attribute utils . build single attribute ( str , integer . to string ( ( ( max length ) criterion ) . get max length ( ) ) ) ; } } } return str ; }	builds the maxlen attribute.
private list < content type > get accepted content types ( ) { annotation consumes annotation = referenced method . get annotation ( consumes . class ) ; if ( null == consumes annotation ) consumes annotation = referenced class . get annotation ( consumes . class ) ; final list < content type > accepted content types = lists . new array list ( ) ; if ( null != consumes annotation ) { for ( final string cts : ( ( consumes ) consumes annotation ) . value ( ) ) { try { accepted content types . add ( content type . value of ( cts ) ) ; } catch ( illegal argument exception e ) { } } } return accepted content types ; }	Ensure most optimal match works.
public boolean is same session ( ) { string session id = session id provider . get ( ) ; if ( callback start session id == null ) { return session id == null ; } return callback start session id . equals ( session id ) ; }	Checks if currently we are during same session that we were duringcallback creation.
public static < d > cursor converter < list < d > > list converter ( final cursor converter < d > converter ) { return new list converter < > ( converter ) ; }	Wrap a provided converter.Returns a converter that creates of list of elements obtained with a provider converter.
void init started loaders ( ) { loader manager lm = operator context . loader manager ; sparse array < loader cookies > listeners map = this . listeners map ; int count = listeners map . size ( ) ; for ( int i = num ; i < count ; i ++ ) { int loader id = listeners map . key at ( i ) ; loader < ? > loader = lm . get loader ( loader id ) ; if ( loader != null && loader . is started ( ) ) { loader cookies cookies = listeners map . value at ( i ) ; boolean not init = ( cookies . options & loader cookies . already init ) == num ; if ( not init ) { utils . init loader ( operator context , loader id , stub provider , ( cookies . options & loader cookies . destroy on finish ) == loader cookies . destroy on finish , this ) ; } } } }	Initialize already started loaders.
public remote profile get profile of ( spf p ) { if ( p == null ) { throw new null pointer exception ( ) ; } return new remote profile ( p , m interface ) ; }	Provides a reference to a remote profile.
public void set change listener ( on change listener listener ) { change listener = listener ; if ( change listener != null ) {	Set the change listener.
public static document builder factory get document builder factory ( final string schema ) { system . set property ( document builder factory key , document builder factory value ) ; final document builder factory factory = document builder factory . new instance ( ) ; factory . set namespace aware ( bool ) ; factory . set validating ( bool ) ; factory . set attribute ( schema language key , http www org 2001 xml schema ) ; factory . set attribute ( schema source key , schema ) ; return factory ; }	Gets the document builder factory.
public static dom get dom ( final file xml , final error handler error handler ) throws sax , parser configuration exception , io { return new dom ( parse ( xml , error handler ) ) ; }	Gets the dOM source.
public static schema get schema ( final file xsd , final error handler error handler ) throws sax {	Gets the schema.
public static document parse ( final file xml , final error handler error handler ) throws sax , parser configuration exception , io { final document builder factory factory = get document builder factory ( xml . get name ( ) ) ; final document builder builder = factory . new document builder ( ) ; builder . set error handler ( error handler ) ; return builder . parse ( xml ) ; }	Parses the.
public static void validate schema ( final file xsd , final file xml , final error handler error handler ) throws sax , parser configuration exception , io { final schema schema xsd = get schema ( xsd , error handler ) ;	Validate xml through xsd.
public static boolean validate schema ( final string schema url , final string xml document url ) throws sax , parser configuration exception , io { system . set property ( document builder factory key , document builder factory value ) ; final document builder factory factory = document builder factory . new instance ( ) ; factory . set namespace aware ( bool ) ; factory . set validating ( bool ) ; factory . set attribute ( schema language key , http www org 2001 xml schema ) ; factory . set attribute ( schema source key , schema url ) ; final document builder builder = factory . new document builder ( ) ; final validator handler handler = new validator handler ( ) ; builder . set error handler ( handler ) ; builder . parse ( xml document url ) ; if ( handler . is valid ( ) ) { return bool ; } return bool ; }	Validate given xml schema.
public boolean add child ( final simple tag child ) { if ( get children ( ) == null ) { set children ( list factory . new array list ( ) ) ; } return get children ( ) . add ( child ) ; }	Adds the given child.
public string remove attribute ( final string name ) { if ( get attributes ( ) != null ) { get attributes ( ) . remove ( name ) ; } return null ; }	Removes the attribute with the given name.
public string builder to velocity template ( ) { final string builder buffer = new string builder ( ) ; buffer . append ( str ) ; buffer . append ( str ) . append ( get name ( ) ) . append ( str ) ; if ( get attributes ( ) != null && ! get attributes ( ) . is empty ( ) ) { buffer . append ( str + str ) . append ( get name ( ) ) . append ( str + str ) ; buffer . append ( str ) . append ( get name ( ) ) . append ( str ) ; buffer . append ( str ) ; } buffer . append ( str ) . append ( get name ( ) ) . append ( str ) . append ( get name ( ) ) . append ( str ) ; if ( get children ( ) != null && ! get children ( ) . is empty ( ) ) { buffer . append ( str ) . append ( get children ( ) . get ( num ) . get name ( ) ) . append ( str ) . append ( get name ( ) ) . append ( str ) ; for ( final simple tag child : get children ( ) ) { buffer . append ( child . to velocity template ( ) . to string ( ) ) ; } buffer . append ( str ) ; } buffer . append ( str ) . append ( get name ( ) ) . append ( str ) ; buffer . append ( str + str ) ; return buffer ; }	Creates from this Tag object an velocity template as String object.
public string to xml string ( ) { final string builder buffer = new string builder ( ) ; buffer . append ( str ) ; buffer . append ( get name ( ) ) ; optional < string > attr = tag extensions . attributes to string ( get attributes ( ) ) ; if ( attr . is present ( ) ) { buffer . append ( attr . get ( ) ) ; } if ( is end tag ( ) ) { buffer . append ( str ) ; buffer . append ( get content ( ) ) ; if ( get children ( ) != null && ! get children ( ) . is empty ( ) ) { for ( final simple tag child : get children ( ) ) { buffer . append ( child . to xml string ( ) ) ; } } buffer . append ( str ) ; buffer . append ( get name ( ) ) ; buffer . append ( str ) ; } else { buffer . append ( str ) ; } return buffer . to string ( ) ; }	Creates from this Tag object an xml string.
public void add service if not present ( wi fi p2p service service ) { wfd log . d ( tag , str + service list . size ( ) ) ; if ( service == null ) { wfd log . e ( tag , str ) ; return ; } boolean add = bool ; for ( wi fi p2p service element : service list ) { if ( element != null && element . get device ( ) . equals ( service . get device ( ) ) && element . get instance name ( ) . equals ( service . get instance name ( ) ) ) { add = bool ;	Method to add a service inside the list in a secure way.The service is added only if isn't already inside the list.
public wi fi p2p service get service by device ( wifi p2p device device ) { if ( device == null ) { return null ; } wfd log . d ( tag , str + device . device name + str + device . device address ) ; wfd log . d ( tag , str + service list . size ( ) ) ; for ( wi fi p2p service element : service list ) { wfd log . d ( tag , str + element . get device ( ) . device name + str + element . get device ( ) . device address ) ; wfd log . d ( tag , str + device . device name + str + device . device address ) ; if ( element . get device ( ) . device address . equals ( device . device address ) ) { wfd log . d ( tag , str + device . device address + str + element . get device ( ) . device address ) ; return element ; } } wfd log . d ( tag , str + service list . size ( ) ) ; return null ; }	Method to get a service from the list, using only the device.This method use only the deviceAddress, not the device name, because sometimes Android doesn'tget the name, but only the mac address.
@ override public int on start command ( intent intent , int flags , int start id ) { if ( intent == null ) { return start sticky ; } string action = intent . get action ( ) ; if ( action start foreground . equals ( action ) ) { if ( ! spf . get ( ) . is connected ( ) ) { spf . get ( ) . connect ( ) ; } spf . get ( ) . notify proximity status ( bool ) ;	Triggered by the front end to keep spf service active in foreground.
list < spf > get all triggers ( string app identifier ) { string where = contract . column app identifier + str ; string [ ] where args = { app identifier } ; cursor c = get readable database ( ) . query ( contract . table name , null , where , where args , null , null , null ) ; list < spf > triggers = new array list < spf > ( ) ; while ( c . move to next ( ) ) { triggers . add ( trigger from cursor ( c ) ) ; } c . close ( ) ; return triggers ; }	Return all the triggers of the specified application.
boolean delete all trigger of ( string app package name ) { string where = contract . column app identifier + str ; string [ ] where args = { app package name } ; int c = get readable database ( ) . delete ( contract . table name , where , where args ) ; return c > num ; }	Delete all the triggers registered with the given application identifier.
boolean delete trigger ( long id , string app package name ) { string where = contract . column app identifier + str + contract . id + str ; string [ ] where args = { app package name , long . to string ( id ) } ; int count = get readable database ( ) . delete ( contract . table name , where , where args ) ; return count > num ; }	Delete the trigger with the given id.
spf get trigger ( long trigger id , string app package name ) { string where = contract . id + str + contract . column app identifier + str ; string [ ] where args = { long . to string ( trigger id ) , app package name } ; cursor c = get readable database ( ) . query ( contract . table name , null , where , where args , null , null , null ) ; if ( ! c . move to first ( ) ) { return null ; } spf t = trigger from cursor ( c ) ; c . close ( ) ; return t ; }	Return the trigger with the specified id.
public static < t > t to object with x ( final string xml string , final map < string , class < ? > > aliases ) { return to object with x ( null , xml string , aliases ) ; }	Creates from the given xml string an Object.
@ suppress warnings ( str ) public static < t > t to object with x ( x xstream , final string xml string , final map < string , class < ? > > aliases ) { if ( xstream == null ) { xstream = new x ( ) ; } if ( aliases != null ) { for ( final map . entry < string , class < ? > > alias : aliases . entry set ( ) ) { xstream . alias ( alias . get key ( ) , alias . get value ( ) ) ; } } return ( t ) xstream . from xml ( xml string ) ; }	Creates from the given xml string an java object.
public static string to json ( final string xml string , final map < string , class < ? > > aliases ) { final object object = xml to object extensions . to object with x ( xml string ) ; final x xstream = new x ( new jettison mapped xml driver ( ) ) ; if ( aliases != null ) { for ( final map . entry < string , class < ? > > alias : aliases . entry set ( ) ) { xstream . alias ( alias . get key ( ) , alias . get value ( ) ) ; } } final string json = xstream . to xml ( object ) ; return json ; }	Creates from the given xml string a json string.
public object invoke method ( string method name , object [ ] args , type ret type ) throws service invocation exception { check current thread ( method name ) ; utils . not null ( method name ) ; utils . not null ( args ) ;	Invokes a remote service providing the name of the method to invoke nameand the list of parameters.
private void check current thread ( string method name ) { if ( looper . my looper ( ) == looper . get main looper ( ) ) { log . w ( tag , string . format ( wrong thread msg , m service descriptor . get service name ( ) , method name ) ) ; } }	Checks if the current thread is the main thread, if so it logs a wrning.
public static void log call ( string tag , string method name , object ... args ) { if ( spf . debug ) { log . d ( tag , str + method name + str + ( args != null ? text utils . join ( str , args ) : str ) + str ) ; } }	Helper to log a call to a method.
private static < t > t load object ( final input stream is ) throws io { final string xml string = read file extensions . input stream2 string ( is ) ; final t object = xml to object extensions . to object with x ( xml string ) ; return object ; }	Load from the given input stream that should represent an xml file and transform it to thegeneric type object.
public static string new tag ( final string tagname , final string value , final map < string , string > attributes ) { final string builder xml tag = new string builder ( ) ; xml tag . append ( str ) . append ( tagname ) ; if ( attributes != null && ! attributes . is empty ( ) ) { xml tag . append ( str ) ; int count = num ; for ( final map . entry < string , string > attributte : attributes . entry set ( ) ) { xml tag . append ( attributte . get key ( ) ) ; xml tag . append ( str ) ; xml tag . append ( str ) . append ( attributte . get value ( ) ) . append ( str ) ; if ( count != attributes . size ( ) ) { xml tag . append ( str ) ; } count ++ ; } } xml tag . append ( str ) ; xml tag . append ( value ) ; xml tag . append ( str ) . append ( tagname ) . append ( str ) ; return xml tag . to string ( ) ; }	Creates a tag from the given string values.
public boolean matches ( string query json ) { query container query container ; try { query container = query container . from json ( query json ) ; } catch ( json e ) { return bool ; } spf query = query container . get query ( ) ; string caller app = query container . get caller app id ( ) ; string user uid = query container . get user uid ( ) ; return analyze with ( query , caller app , user uid ) ; }	Verifies if the local profile matches the given query.
public invocation response dispatch invocation ( invocation request request ) { string app name = request . get app name ( ) ; string service name = request . get service name ( ) ; string component name = m service table . get component for service ( app name , service name ) ; if ( component name == null ) { return invocation response . error ( str + app name + str + service name ) ; } app service proxy proxy = m communication agent . get proxy ( component name ) ; if ( proxy == null ) { return invocation response . error ( str ) ; } try { return proxy . execute service ( request ) ; } catch ( throwable t ) { log . e ( str , str , t ) ; return invocation response . error ( str + t . get message ( ) ) ; } }	Dispatches an invocation request to the right application.
public < t > void unregister service ( class < ? super t > service interface ) { utils . not null ( service interface , str ) ; service validator . validate interface ( service interface , service validator . type published ) ; service interface svc interface = service interface . get annotation ( service interface . class ) ; spf svc desc = service interface . convert . to service descriptor ( svc interface ) ; string token = get access token ( ) ; try { spf error = new spf ( ) ; get service ( ) . unregister service ( token , svc desc , error ) ; if ( ! error . is ok ( ) ) { handle error ( error ) ; } } catch ( remote exception e ) { catch remote exception ( e ) ; } }	Allows to unregister a previously registered service.
private string generate query id ( query info query info ) { string query id = spf . get ( ) . get unique identifier ( ) + ( ++ id ) ; query info . set query id ( query id ) ; return query id ; }	Generate a query id for the specified query.
void on instance lost ( string unique identifier ) { log ( tag , str + unique identifier ) ; list < string > queries ids = results . get ( unique identifier ) ; if ( queries ids == null ) { return ; } for ( string query id : queries ids ) { string [ ] args = new string [ num ] ; args [ num ] = query id ; args [ num ] = unique identifier ; message msg = handler . obtain message ( search messages . result lost , args ) ; log ( tag , str + query id ) ; handler . send message ( msg ) ; } }	Call this method when the middleware notify that a spf instance is lost.It will notify the event to all the active searches that have the lostinstance in their results.
void stop search ( string query id ) { query info info = queries . get ( query id ) ; if ( info != null ) { stop search ( info ) ; } }	Call this method to stop the search and release the associated resources.The application will not be notified about the event;.
void stop all searches ( string app identifier ) { list < query info > qinfos ; synchronized ( queries ) { qinfos = new array list < query info > ( queries . values ( ) ) ; } for ( query info query info : qinfos ) { if ( query info . get app name ( ) . equals ( app identifier ) ) { stop search ( query info ) ; } } }	Unregister all the active queries associated with the givenappIdentifier.
public static void connect ( final context context , final connection listener listener ) { component . load ( context , descriptor , as base ( listener ) ) ; }	Creates a connection to SPF asynchronously.
private < e > view create standard display view ( profile field < e > field , e current value , view group view container ) { view result = m inflater . inflate ( r . layout . profileview field listelement , view container , bool ) ; string friendly field name = m helper . get friendly name of field ( field ) ; ( ( text view ) result . find view by id ( r . id . profile field key ) ) . set text ( friendly field name ) ; string field value = m helper . convert to friendly string ( field , current value ) ; ( ( text view ) result . find view by id ( r . id . profile field value ) ) . set text ( field value ) ; set up circle view ( result , field , null ) ; return result ; }	Standard display view for all profile fields except tags.
private < e > view create spinner ( multiple choiche profile field < e > field , e current value , field value listener < e > listener , view group container ) { view result = m inflater . inflate ( r . layout . profileedit field multiplechoiche , container , bool ) ; string friendly name = m helper . get friendly name of field ( field ) ; ( ( text view ) result . find view by id ( r . id . profileedit field identifier ) ) . set text ( friendly name ) ; spinner spinner = ( spinner ) result . find view by id ( r . id . profileedit field multiple value ) ; array adapter < e > adapter = new array adapter < e > ( m context , android . r . layout . simple list item 1 , field . get choiches ( ) ) ; spinner . set adapter ( adapter ) ; int index = index of ( field . get choiches ( ) , current value ) ; if ( index >= num ) { spinner . set selection ( index , bool ) ; } spinner . set on item selected listener ( new on item selected adapter < e > ( field , listener , adapter ) ) ; set up circle view ( result , field , listener ) ; return result ; }	Edit view for multiple choiche fields.
@ suppress warnings ( str ) private < e > view create tag view ( tag profile field field , string [ ] current value , field value listener < e > listener , view group container , boolean editable ) { view result = m inflater . inflate ( editable ? r . layout . profileedit field tag : r . layout . profileview tag field , container , bool ) ; string friendly name = m helper . get friendly name of field ( field ) ; ( ( text view ) result . find view by id ( r . id . profileedit field identifier ) ) . set text ( friendly name ) ; tags picker picker = ( tags picker ) result . find view by id ( r . id . profileedit tags picker ) ; picker . set editable ( editable ) ; if ( current value != null ) { picker . set initial tags ( arrays . as list ( current value ) ) ; } if ( editable ) { picker . set change listener ( new on change listener adapter ( field , ( field value listener < string [ ] > ) listener ) ) ; } set up circle view ( result , ( profile field < e > ) field , listener ) ; return result ; }	Edit and display view for tags.
private < e > view create standard edit view ( profile field < e > field , e current value , field value listener < e > listener , view group container ) { view result = m inflater . inflate ( r . layout . profileedit field standard , container , bool ) ; string friendly name = m helper . get friendly name of field ( field ) ; ( ( text view ) result . find view by id ( r . id . profileedit field identifier ) ) . set text ( friendly name ) ; edit text edit text = ( edit text ) result . find view by id ( r . id . profileedit field value ) ; edit text . add text changed listener ( new on editor action adapter < > ( listener , field ) ) ; if ( current value != null ) { edit text . set text ( m helper . convert to friendly string ( field , current value ) ) ; } set up circle view ( result , field , listener ) ; return result ; }	Edit view for all other fields.
public final void send notification ( string unique identifier , spf action ) { if ( unique identifier == null || action == null ) { throw new null pointer exception ( ) ; } string action json = action . to json ( ) ; send notification ( unique identifier , action json ) ; }	Sends a notification to the remote SPF instance.
public string to xml ( ) { final string lq simple name = this . get class ( ) . get simple name ( ) . to lower case ( ) ; final map < string , class < ? > > aliases = new hash map < > ( ) ; aliases . put ( lq simple name , this . get class ( ) ) ; return object to xml extensions . to xml with x ( this , aliases ) ; }	To xml.
private void set content view with minimal elements ( ) {	Method to set the contentview with Title, Text and Image.
public string get friendly name of field ( profile field < ? > field ) { string name = get string from resource ( profile field prefix + field . get identifier ( ) ) ; if ( name == null ) { return field . get identifier ( ) ; } return name ; }	Provides the localized friendly name of a field.
private void kill scheduler ( ) { if ( scheduler != null ) { wfd log . d ( tag , str ) ; scheduler . shutdown ( ) ; scheduler = null ; } }	Kill the scheduler to stop the Eternal Connect in any case.
public static synchronized void initialize ( context context , int go intent , boolean is autonomous , proximity middleware . factory factory ) { if ( context == null || factory == null ) { throw new null pointer exception ( str ) ; } spf . initialize ( context , go intent , is autonomous , factory ) ; s instance = new spf ( ) ; }	Initializes SPFContext. After this method has been called, you can getreferences to SPFContext and SPF.
public void broadcast event ( final int code , final bundle payload ) { if ( spf . debug ) { log . d ( tag , str + code + str + payload ) ; } for ( final on event listener listener : m event listeners ) {	Broadcasts an event to all registered listeners.
public static profile fragment create view self profile fragment ( ) { bundle b = new bundle ( ) ; b . put int ( extra view mode , mode . self . ordinal ( ) ) ; profile fragment fragment = new profile fragment ( ) ; fragment . set arguments ( b ) ; return fragment ; }	Creates a new instance of ProfileFragment to show the local profile.
public void begin crop ( uri source ) { uri destination = uri . from file ( new file ( this . get activity ( ) . get cache dir ( ) , str ) ) ; crop . of ( source , destination ) . as square ( ) . start ( this . get activity ( ) ) ; }	Method to start the activity to crop an image.
public void handle crop ( int result code , intent result ) { if ( result code == activity . result ok ) { uri uri = crop . get output ( result ) ; result view . set image uri ( uri ) ; input stream input stream = null ; try { input stream = new file input stream ( uri . get path ( ) ) ; bitmap my bitmap = bitmap factory . decode stream ( input stream ) ; my bitmap = bitmap . create scaled bitmap ( my bitmap , num , num , bool ) ; m container . set field value ( profile field . photo , my bitmap ) ; show picture ( my bitmap ) ; } catch ( file not found exception e ) { log . e ( tag , str , e ) ; } finally { if ( input stream != null ) { try { input stream . close ( ) ; } catch ( io e ) { log . e ( tag , str , e ) ; } } } } else if ( result code == crop . result error ) { toast . make text ( this . get activity ( ) , crop . get error ( result ) . get message ( ) , toast . length short ) . show ( ) ; } }	Method to set an show a cropped imaged.
public static < t > string to json ( final t object , final boolean new mapper ) throws json processing exception { final object mapper mapper = object mapper factory . get object mapper ( new mapper ) ; final string json = mapper . write value as string ( object ) ; return json ; }	To json.
public void add tag ( string tag ) { tag bubble tb = new tag bubble ( get context ( ) ) ; tb . set text ( tag ) ; tb . set editable ( editable ) ; tb . set on remove tag listener ( bubble click listener ) ; tags . add ( tag . to string ( ) ) ; add view ( tb ) ; }	Adds and shows a new tag.
public void set tags ( list < string > tags ) { this . tags . clear ( ) ; remove all views ( ) ; for ( string tag : tags ) { add tag ( tag ) ; } }	Set the list of tags to be displayed.
public long save trigger ( spf trigger , string app package name ) { trigger = m trigger table . save trigger ( trigger , app package name ) ; if ( trigger != null ) { if ( m handler != null ) m handler . post add trigger ( trigger ) ; return trigger . get id ( ) ; } else { return - num ; } }	Saves the trigger on the database.
public boolean delete trigger ( long id , string app package name ) { boolean success = m trigger table . delete trigger ( id , app package name ) ; if ( success ) { if ( m handler != null ) m handler . post remove trigger ( id ) ; } return success ; }	Deletes the trigger specified by its id.
public void start ( ) { this . m handler thread = new handler thread ( str ) ; this . m handler thread . start ( ) ; this . m handler = new spf ( m handler thread . get looper ( ) ) ; m handler . post setup ( this ) ; is running = bool ; }	Initialize and start all the threads and resources used bySPFNotification service.
private void start registration ( ) {	Registers a local service.
public string add attribute ( final string name , final string value ) { if ( get attributes ( ) == null ) { this . attributes = map factory . new linked hash map ( ) ; } return get attributes ( ) . put ( name , value ) ; }	Adds the attribute with the given name and value.
public invocation response invoke method ( invocation request request ) { string method name = request . get method name ( ) ; if ( ! m method index . contains key ( method name ) ) { string msg = string . format ( error msg . method not found , method name , m service descriptor . get service name ( ) ) ; return invocation response . error ( msg ) ; } method m = m method index . get ( method name ) ; object [ ] params ; try { params = deserialize parameters ( request . get payload ( ) , m . get generic parameter types ( ) ) ; } catch ( service invocation exception e ) { return invocation response . error ( str + e . get message ( ) ) ; } try { object result = m . invoke ( m implementation , params ) ; string json = gson helper . gson . to json ( result ) ; return invocation response . result ( json ) ; } catch ( illegal access exception e ) { return invocation response . error ( e ) ; } catch ( illegal argument exception e ) { return invocation response . error ( error msg . illegal argument ) ; } catch ( invocation target exception e ) { return invocation response . error ( e . get cause ( ) ) ; } }	Invokes a method of the service.
public void set selection ( string [ ] selection ) { for ( string sel : selection ) { for ( int j = num ; j < m items . length ; ++ j ) { if ( m items [ j ] . equals ( sel ) ) { m selection [ j ] = bool ; } } } refresh display value ( ) ; }	Sets the selected options based on an array of string.
public void set selection ( int [ ] selected indicies ) { for ( int index : selected indicies ) { if ( index >= num && index < m selection . length ) { m selection [ index ] = bool ; } else { throw new illegal argument exception ( str + index + str ) ; } } refresh display value ( ) ; }	Sets the selected options based on an array of positions.
public list < string > get selected strings ( ) { list < string > selection = new linked list < string > ( ) ; for ( int i = num ; i < m items . length ; ++ i ) { if ( m selection [ i ] ) { selection . add ( m items [ i ] ) ; } } return selection ; }	Returns a list of strings, one for each selected item.
public list < integer > get selected indicies ( ) { list < integer > selection = new linked list < integer > ( ) ; for ( int i = num ; i < m items . length ; ++ i ) { if ( m selection [ i ] ) { selection . add ( i ) ; } } return selection ; }	Returns a list of positions, one for each selected item.
public void on refresh ( ) { m view container . remove all views ( ) ; for ( profile field < ? > field : m fields to show ) { view child = m parent . create view for ( field , m view container ) ; m view container . add view ( child ) ; } }	Refreshes the values of displayed fields.
public void shutdown ( ) { synchronized ( this ) { if ( m shutdown ) { return ; } for ( app service proxy p : m proxies . values ( ) ) { if ( p . is connected ( ) ) { m context . unbind service ( p ) ; m proxies . remove ( p ) ; } } m shutdown = bool ; } }	Unbinds all proxies available in caches and prevents the creation of newones.
private void insert new line ( ) throws sax { try { writer . write ( system . get property ( str ) ) ; } catch ( final io e ) { throw new sax ( str , e ) ; } }	Insert a new line to the writer.
private void write to buffer ( ) throws sax { if ( string builder == null ) { return ; } final string string = string builder . to string ( ) . trim ( ) ; write ( string ) ; string builder = null ; }	Write to buffer.
public static < t > string to json quietly ( final t object ) { try { return object to json extensions . to json ( object ) ; } catch ( final json processing exception e ) { log . log ( level . severe , str + object . to string ( ) + str , e ) ; } return null ; }	Creates from the given Object a json string.
protected static < c extends component < c , i > , i extends i > void load ( final context context , final descriptor < c , i > descriptor , final connection callback < c > callback ) { utils . not null ( context , str ) ; utils . not null ( descriptor , str ) ; if ( access token manager . get ( context ) . has token ( ) ) { bind to service ( context , descriptor , callback ) ; } else { access token manager . get ( context ) . require access token ( context , new access token manager . registration callback ( ) { @ override public void on registration successful ( ) { log . d ( str , str + descriptor ) ; bind to service ( context , descriptor , callback ) ; } @ override public void on registration error ( spf error msg ) { callback . on error ( error msg ) ; } } ) ; } }	Loads a local component asynchronously.
private static < c extends component < c , i > , i extends i > void bind to service ( final context context , final descriptor < c , i > descriptor , final connection callback < c > callback ) { intent intent = new intent ( ) ; intent . set component ( spf . get spf ( ) ) ; intent . set action ( descriptor . get action name ( ) ) ; service connection connection = new service connection ( ) { @ override public void on service connected ( component name name , i binder ) { i service = descriptor . cast interface ( binder ) ; c instance = descriptor . create instance ( context , service , this , callback ) ; callback . on service ready ( instance ) ; } @ override public void on service disconnected ( component name name ) { callback . on disconnect ( ) ; } } ; if ( ! context . bind service ( intent , connection , context . bind auto create ) ) { callback . on error ( new spf ( spf . spf not installed error code ) ) ; } }	Performs the binding to the remote service.
public void disconnect ( ) { try { m context . unbind service ( m connection ) ; } catch ( exception e ) { log . w ( get class ( ) . get simple name ( ) , str , e ) ; } }	Disconnects the component from the remote service.
protected void handle error ( spf err ) { if ( err . code equals ( spf . token not valid error code ) ) { access token manager . get ( m context ) . invalidate token ( ) ; } m callback . on error ( err ) ; }	Performs common error handling operations.
public void refresh triggers ( list < spf > triggers2 ) { triggers . clear ( ) ; for ( spf trg : triggers2 ) { triggers . put ( trg . get id ( ) , trg ) ; } }	Update the current set of triggers with the given list.
boolean add persona ( spf persona ) { sq db = get writable database ( ) ; string table = contract . table personas ; string null column hack = null ; content values values = new content values ( ) ; values . put ( contract . column persona , persona . get identifier ( ) ) ; if ( db . insert ( table , null column hack , values ) > num ) {	Creates a new SPFPersona.
boolean remove persona ( spf persona ) { sq db = get writable database ( ) ; if ( persona . get identifier ( ) . equals ( str ) ) { return bool ; } string table = contract . table personas ; string selection = contract . column persona + str ; string [ ] selection args = { persona . get identifier ( ) } ; if ( db . delete ( table , selection , selection args ) > num ) { delete fields of ( persona , db ) ; delete visibility of ( persona , db ) ; } return bool ; }	Delete a SPFPersona. All the information related to the specified personawill be erased.
public boolean register service ( spf descriptor ) { string app id = descriptor . get app identifier ( ) ; string service name = descriptor . get service name ( ) ; for ( string verb : descriptor . get consumed verbs ( ) ) { if ( ! register service internal ( verb , service name , app id ) ) { return bool ; } log . v ( tag , str + descriptor . get service name ( ) ) ; } return bool ; }	Registers the capabilities of a service to consume activities.
app auth get app authorization by app id ( string app id ) { string where = contract . column app identifier + str ; string args [ ] = { app id } ; cursor c = m registry table . get readable database ( ) . query ( contract . table name , null , where , args , null , null , null ) ; app auth auth = null ; if ( c . move to first ( ) ) { auth = app auth from cursor ( c ) ; } c . close ( ) ; return auth ; }	Retrieves an appauth given the identifier of an application.
public string register application ( app descriptor descriptor , spf persona ) { string token = m token generator . generate access token ( ) ; content values cv = new content values ( ) ; cv . put ( contract . column app name , descriptor . get app name ( ) ) ; cv . put ( contract . column access token , token ) ; cv . put ( contract . column app identifier , descriptor . get app identifier ( ) ) ; cv . put ( contract . column permission code , descriptor . get permission code ( ) ) ; cv . put ( contract . column persona , persona . get identifier ( ) ) ; sq db = m registry table . get writable database ( ) ; if ( db . insert ( contract . table name , null , cv ) == - num ) { return null ;	Low level method to register applications.
public boolean unregister application ( string app identifier ) { string where = contract . column app identifier + str ; string [ ] where args = { app identifier } ; if ( m registry table . get writable database ( ) . delete ( contract . table name , where , where args ) == num ) { return bool ; } if ( spf . get ( ) . get service registry ( ) . unregister all services of app ( app identifier ) ) { intent i = new intent ( deregistration intent ) ; i . put extra ( deregistered app , app identifier ) ; m context . send broadcast ( i ) ; return bool ; } return bool ; }	To be called from application uninstall monitor.
public spf get persona of ( string app identifier ) { sq db = m registry table . get readable database ( ) ; string table = contract . table name ; string [ ] columns = { contract . column persona } ; string selection = contract . column app identifier + str ; string [ ] selection args = { app identifier } ; string group by = null ; string having = null ; string order by = null ; cursor c = db . query ( table , columns , selection , selection args , group by , having , order by ) ; if ( c . move to next ( ) ) { string persona = c . get string ( c . get column index ( contract . column persona ) ) ; return new spf ( persona ) ; } c . close ( ) ; return spf . default ; }	Returns the SPFPersona associated to the specified application.
void on message received ( final wfd message msg ) { thread pool . execute ( new runnable ( ) { @ override public void run ( ) { if ( msg . get receiver id ( ) . equals ( my identifier ) ) { handle ( msg ) ; } else { route ( msg ) ; } } } ) ; }	called from the GOInternalClient.
public void add client if not present ( device gui element device ) { boolean add = bool ; for ( device gui element element : clients ) { if ( element != null && element . get name ( ) . equals ( device . get name ( ) ) && element . get address ( ) . equals ( device . get address ( ) ) ) { add = bool ;	Method to add a client inside the list in a secure way.The client is added only if isn't already inside the list.
public void connect ( ) { if ( ! m middleware . is connected ( ) ) { m middleware . connect ( ) ; } if ( ! m notification manager . is running ( ) ) { m notification manager . start ( ) ; } if ( m advertise manager . is advertising enabled ( ) ) { m middleware . register advertisement ( m advertise manager . generate adv profile ( ) . to json ( ) , num ) ; } }	Life-cycle methods.
public < e > e get field value ( profile field < e > field ) { if ( field == null ) { throw new null pointer exception ( ) ; } string val = m fields . get string ( field . get identifier ( ) ) ; return val == null ? null : profile field converter . for field ( field ) . from storage string ( val ) ; }	Gets the value of a field from the container.
public boolean is modified ( ) { for ( string key : m status . key set ( ) ) { field status status = get status ( key ) ; if ( status == field status . deleted || status == field status . modified ) { return bool ; } } return bool ; }	Returns whether at least one field in the container has been modified.
public void stop search ( int tag ) { string query id = m tag to id . get ( tag ) ; m tag to id . delete ( tag ) ; if ( query id != null && m callbacks . remove ( query id ) != null ) { m search interface . stop search ( query id ) ; } }	Stops a previously registered search request performed by theapplication.
public void stop all searches ( ) { m tag to id . clear ( ) ; string [ ] query ids = m callbacks . key set ( ) . to array ( new string [ ] { } ) ; m callbacks . clear ( ) ; for ( string query id : query ids ) { m search interface . stop search ( query id ) ; } }	Stops all searches registered by the application.
public spf lookup ( string identifier ) { boolean is reachable = m search interface . lookup ( identifier ) ; if ( is reachable ) { return new spf ( identifier ) ; } else { return null ; } }	Allows to retrieve a reference to a remote person given its identifier.This reference is valid until the given person is reachable from theproximity middleware.
public profile field container get profile field bulk ( person auth auth , spf persona , string [ ] fields ) { return m profile table . get profile field bulk ( persona , fields , auth ) ; }	Method for proximity interface to provide access to local profile toremote spf instances.
public base info get base info ( spf persona ) { profile field container pfc = get profile field bulk ( persona , profile field . identifier , profile field . display name ) ; return new base info ( pfc . get field value ( profile field . identifier ) , pfc . get field value ( profile field . display name ) ) ; }	Returns the display_name of the user.
public static node list get node list ( final string xml , final string xpath expression ) throws x , parser configuration exception , sax , io { final document builder factory dom factory = document builder factory . new instance ( ) ; dom factory . set namespace aware ( bool ) ; final document builder builder = dom factory . new document builder ( ) ; final document doc = builder . parse ( xml ) ; final x xpath = x . new instance ( ) . new x ( ) ; final x expr = xpath . compile ( xpath expression ) ; final object result = expr . evaluate ( doc , x . nodeset ) ; final node list nodes = ( node list ) result ; return nodes ; }	Gets the node list from the given xml file and the given xpath expression.
public static < e > e on main thread ( class < e > callback interface , final e callback ) { utils . not null ( callback interface , str ) ; utils . not null ( callback , str ) ; final handler handler = new handler ( looper . get main looper ( ) ) ; final string tag = callback . get class ( ) . get simple name ( ) ; object proxy = proxy . new proxy instance ( callback interface . get class loader ( ) , new class < ? > [ ] { callback interface } , new invocation handler ( ) { @ override public object invoke ( object proxy , final method method , final object [ ] args ) throws throwable { handler . post ( new runnable ( ) { @ override public void run ( ) { try { method . invoke ( callback , args ) ; } catch ( illegal access exception e ) { log . e ( tag , str + method . get name ( ) + str , e ) ; } catch ( illegal argument exception e ) { log . e ( tag , str + method . get name ( ) + str , e ) ; } catch ( invocation target exception e ) { log . e ( tag , str + method . get name ( ) + str , e ) ; } } } ) ; return null ; } } ) ; return callback interface . cast ( proxy ) ; }	Wraps a callback into a proxy that executes its methods on the mainthread.
public person auth get person auth from ( string received tkn ) { if ( received tkn . equals ( str ) ) { return person auth . get public auth ( ) ; } string selection = relationship entry . column tkn + str + relationship entry . column request status + str ; string [ ] selection args = { received tkn , integer . to string ( request accepted ) } ; string [ ] columns = { relationship entry . column user uuid } ; sq db = get readable database ( ) ; cursor cursor = db . query ( relationship entry . table person auth , columns , selection , selection args , null , null , null ) ; person auth auth ; if ( cursor . move to next ( ) ) { string unique identifier = cursor . get string ( cursor . get column index ( relationship entry . column user uuid ) ) ; auth = generate permission for ( unique identifier , db ) ; } else { auth = person auth . get public auth ( ) ; } cursor . close ( ) ; return auth ; }	Call this method every time you receive a remote request.
public string create entry for sent request ( string target uid , string password ) throws general security exception {	Creates a pending request associated to the target id.
public boolean create entry for received request ( contact request fr ) { string user uuid = fr . get user identifier ( ) ; string receive token = fr . get access token ( ) ; int request status = request pending ; if ( insert new entry ( user uuid , receive token , request status ) ) { return bool ; } return bool ; }	Creates a pending request with the information contained in the message.
public int entry exists for ( string user uid ) { string selection = relationship entry . column user uuid + str ; string [ ] selection args = { user uid } ; string [ ] columns = { relationship entry . column request status } ; sq db = get readable database ( ) ; cursor cursor = db . query ( relationship entry . table person auth , columns , selection , selection args , null , null , null ) ; if ( cursor . move to next ( ) ) { return cursor . get int ( cursor . get column index ( relationship entry . column request status ) ) ; } cursor . close ( ) ; return request not exist ; }	check if an entry for the specified user id exists.
public boolean confirm request ( string target uid , string password ) throws general security exception , wrong passphrase exception { sq db = get writable database ( ) ; string table = relationship entry . table person auth ; string [ ] columns = { relationship entry . column tkn , relationship entry . column request status , relationship entry . column password } ; string selection = relationship entry . column user uuid + str ; string [ ] selection args = { target uid } ; string group by = null ; string having = null ; string order by = null ; string limit = null ; cursor c = db . query ( table , columns , selection , selection args , group by , having , order by , limit ) ; if ( c . move to next ( ) ) { string token = c . get string ( c . get column index ( relationship entry . column tkn ) ) ; string decrypted tkn = token cipher . decrypt token ( token , password ) ; if ( decrypted tkn != null ) { return commit confirmation ( target uid , password , decrypted tkn ) ; } else { return bool ; } } return bool ; }	Confirm a friendship request. the status of the entry associated with thespecified person, will be REQUEST_ACCEPTED.
@ override public void add closing tag ( string tag name ) { indent . dec ( ) ; xml . add xml ( indent . to string ( ) ) ; xml . add closing tag ( tag name ) ; xml . add xml ( str ) ; }	Adds a closing tag.
@ override public void add empty tag ( string tag name ) { xml . add xml ( indent . to string ( ) ) ; xml . add empty tag ( tag name ) ; xml . add xml ( str ) ; }	Adds an empty tag.
@ override public void add opening tag ( string tag name , map attributes ) { xml . add xml ( indent . to string ( ) ) ; xml . add opening tag ( tag name , attributes ) ; xml . add xml ( str ) ; indent . inc ( ) ; }	Adds an opening tag which contains the attributes specified.
public static boolean delete file ( file file ) throws io { if ( ! file . exists ( ) ) return bool ; file [ ] files = file . list files ( ) ; if ( files != null ) { for ( int i = num ; i < files . length ; i ++ ) { file child file = files [ i ] ; if ( child file . equals ( file ) ) continue ; if ( child file . is directory ( ) ) delete file ( child file ) ; else child file . delete ( ) ; } } return file . delete ( ) ; }	Deletes the file provided.
public static file create temp directory ( string namespace , string name ) throws io { file dir = file . create temp file ( namespace , str ) ; if ( dir . exists ( ) ) delete file ( dir ) ; create new directory ( dir ) ; file temp dir = new file ( dir , name ) ; create new directory ( temp dir ) ; return temp dir . get canonical file ( ) ; }	Creates a temporary directory.
@ suppress warnings ( str ) public static object get proxied object ( object proxy ) { if ( proxy . is proxy class ( proxy . get class ( ) ) ) { invocation handler invocation handler = proxy . get invocation handler ( proxy ) ; if ( invocation handler instanceof object proxy ) { object proxy object proxy = ( object proxy ) invocation handler ;	Given a proxy returns the object proxied.
public static class for name ( class clazz , class loader class loader ) throws class not found exception , linkage error { if ( clazz == null ) return null ; if ( class loader == null ) { class loader = get default class loader ( ) ; } if ( clazz . get class loader ( ) == null || clazz . get class loader ( ) . equals ( class loader ) ) return clazz ; else return for name ( clazz . get name ( ) , class loader ) ; }	Convenient call to return a class in a different class loader..
@ suppress warnings ( str ) public static string compute signature ( method m ) { string builder sb = new string builder ( ) ; sb . append ( m . get name ( ) ) . append ( str ) ; class [ ] parameter types = m . get parameter types ( ) ; for ( int i = num ; i < parameter types . length ; i ++ ) { if ( i > num ) sb . append ( str ) ; class parameter type = parameter types [ i ] ; sb . append ( parameter type . get name ( ) ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	Computes the signature of a method.
private static one way message digest codec create well known instance ( string algorithm , string password , one way codec codec ) { try { return new one way message digest codec ( algorithm , password , codec ) ; } catch ( no such algorithm exception e ) { throw new runtime exception ( e ) ; } catch ( clone not supported exception e ) { throw new runtime exception ( e ) ; } }	This creates a well known instance.
public void reset ( ) { scheme = null ; user info = null ; host = null ; port = - num ; path = null ; query = new query builder ( ) ; fragment = null ; escape fragment = bool ; }	Call this method when you want to reset the internal string to startfrom scratch again.
public static url create from path ( string path ) { url res = new url ( ) ; res . set path ( path ) ; return res ; }	Factory method from a path.
public static url add query parameter ( url url , string name , string value ) { url ub = create from url ( url ) ; ub . add query parameter ( name , value ) ; return ub ; }	Convenient call which adds a query parameter to the give url.
@ override public string get parameter ( string name ) { string [ ] params = get parameter values ( name ) ; if ( params == null ) return null ; return params [ num ] ; }	Get the first parameter given its name.
private void add query parameter ( string name , string value ) { if ( query . length ( ) > num ) query . append ( str ) ; query . append ( encode ( name ) ) ; query . append ( str ) ; query . append ( encode ( value ) ) ; }	Add query parameter to query string.
public void add parameters ( map < string , string [ ] > parameters ) { for ( map . entry < string , string [ ] > entry : parameters . entry set ( ) ) { add parameters ( entry . get key ( ) , entry . get value ( ) ) ; } }	Adds the map of parameters.
public void add indexed parameter ( string name , int value , int index ) { add parameter ( get indexed param name ( name , index ) , value ) ; }	Adds a parameter that comes from an array at the provided index.
public void add query ( uri uri ) { try { add query ( uri . get raw query ( ) , bool ) ; } catch ( uri e ) {	Adds the query extracted from the URI.
private void validate query ( string query ) throws uri { if ( query . length ( ) == num ) return ; iterator < string > iter = ss . split to iterator ( query ) ; while ( iter . has next ( ) ) { string s = iter . next ( ) ; if ( s . length ( ) > num ) { int idx = s . index of ( str ) ; if ( idx == - num ) throw new uri ( query , str + s ) ; if ( s . last index of ( str ) != idx ) throw new uri ( query , str + s ) ; } } }	Internal method in charge of validating the query provided.
public void add query ( query query ) { if ( query == null ) return ; try { if ( ! query . get encoding ( ) . equals ( get encoding ( ) ) ) throw new runtime exception ( str ) ; add query ( query . get query ( ) , bool ) ; } catch ( uri e ) {	Simply adds the query provided.
private void rebuild query ( ) { map < string , string [ ] > map = get map ( ) ;	Rebuild query instance with values in the map.
public string [ ] replace parameter ( string name , string value ) { map < string , string [ ] > map = get map ( ) ; string [ ] v = map . put ( name , new string [ ] { value } ) ; rebuild query ( ) ; return v ; }	Replace existing or add new parameter with givenvalue.
@ override public object invoke ( object o , method method , object [ ] objects ) throws throwable {	Method from the interface. Checks for shutdown then dispatches the call.
public static object create shutdown proxy ( object o , class [ ] interfaces , shutdown shutdown ) { if ( interfaces == null ) interfaces = reflect utils . extract all interfaces ( o ) ; return proxy . new proxy instance ( o . get class ( ) . get class loader ( ) , interfaces , new shutdown proxy ( o , shutdown ) ) ; }	Creates the proxy to check for shutdown.
public static boolean convert to boolean ( object o ) { if ( o == null ) return bool ; if ( o instanceof boolean ) { return ( boolean ) o ; } return convert to boolean ( o . to string ( ) ) ; }	Converts the object into a boolean value.
public static string get stack trace ( throwable th ) { string writer sw = new string writer ( ) ; print writer pw = new print writer ( sw ) ; th . print stack trace ( pw ) ; return sw . to string ( ) ; }	Returns the stack trace of the throwable as a string.
public static string remove trailing slash ( string path ) { if ( path . ends with ( str ) ) return path . substring ( num , path . length ( ) - num ) ; else return path ; }	Removes a trailing slash if exists.
@ override public void wait for shutdown ( object timeout ) throws interrupted exception , illegal state exception , timeout exception { if ( ! shutdown ) throw new illegal state exception ( str ) ; pending calls count . wait for counter ( timeout ) ; }	Waits for shutdown to be completed.
@ override public void add empty tag ( string tag name , map attributes ) { xml . append ( str ) . append ( tag name ) ; add attributes ( attributes ) ; xml . append ( str ) ; }	Adds an empty tag which contains the attributes specified.
private void add attribute ( string attr name , string attr value ) { if ( attr name == null ) return ; xml . append ( str ) ; xml . append ( attr name ) . append ( str ) ; xml . append ( xml . xml encode ( attr value ) ) . append ( str ) ; }	Adds the attribute.
private void add attributes ( map attributes ) { if ( attributes == null ) return ; iterator iter = attributes . key set ( ) . iterator ( ) ; while ( iter . has next ( ) ) { string attr name = ( string ) iter . next ( ) ; object attr value = attributes . get ( attr name ) ; if ( attr value != null ) add attribute ( attr name , attr value . to string ( ) ) ; } }	Adds the attributes. All the properties will be used as attributes.
public static resource info extract info ( url url ) throws io { url url connection = url . open connection ( ) ; url connection . set do input ( bool ) ; url connection . set do output ( bool ) ; url connection . set use caches ( bool ) ; url connection . connect ( ) ; input stream is = url connection . get input stream ( ) ; try { return new static info ( url connection . get content length ( ) , url connection . get last modified ( ) ) ; } finally { is . close ( ) ; } }	Extracts the info from the url.
@ override public internal resource chroot ( internal resource resource ) { string path = resource . get path ( ) ;	Returns a new resource with the root resource set to this resource.
@ override public internal resource [ ] list ( internal resource resource , final resource filter filter ) throws io { final list < resource > resources = new array list < resource > ( ) ; string path = path utils . add trailing slash ( resource . get path ( ) ) ; if ( do list ( path , new resource filter ( ) { @ override public boolean accept ( resource resource ) { boolean res = filter . accept ( resource ) ; if ( res ) resources . add ( resource ) ; return res ; } } ) ) { return resources . to array ( new internal resource [ resources . size ( ) ] ) ; } else return null ; }	If this resource denotes a directory, then it will return all resources that are contained inthe directory.
@ override public resource chroot ( string relative path ) { return resource provider . chroot ( ( internal resource ) create relative ( relative path ) ) ; }	Returns a new resource with the root resource set to the relative path provided.
public static resource create ( file file ) { try { string path = file . get canonical path ( ) ; if ( file . is directory ( ) ) path = path utils . add trailing slash ( path ) ; return create ( new file ( str ) , path ) ; } catch ( io e ) { throw new illegal argument exception ( str + file , e ) ; } }	Creates a file resource from a file.
public void start ( ) throws io { process = process builder . start ( ) ; out = new input reader ( new buffered input stream ( process . get input stream ( ) ) ) ; err = new input reader ( new buffered input stream ( process . get error stream ( ) ) ) ; out . start ( ) ; err . start ( ) ; }	After creating the command, you have to start it...
public static external command create ( list < string > commands ) { external command ec = new external command ( new process builder ( commands ) ) ; return ec ; }	Creates an external process from the command. It is not started and you have to callstart on it!.
public static external command start ( string ... commands ) throws io { external command ec = new external command ( new process builder ( commands ) ) ; ec . start ( ) ; return ec ; }	Creates an external process from the command.
public static external command execute ( file working directory , string command , string ... args ) throws io , interrupted exception { try { return execute with timeout ( working directory , command , num , args ) ; } catch ( timeout exception e ) {	Executes the external command in the given working directory and waits for it to befinished.
public long tick ( ) { long tick = clock . current time millis ( ) ; long diff = tick - tick ; tick = tick ; return diff ; }	Returns the number of milliseconds ellapsed since the last call tothis function.
public string get elapsed time ( ) { string builder sb = new string builder ( str ) ; sb . append ( this . tick ( ) ) ; sb . append ( str ) ; return sb . to string ( ) ; }	Returns a string that represents the time elapsed.
@ override public void add tag ( string tag name , int value , string attr name , string attr value ) { add tag ( tag name , string . value of ( value ) , attr name , attr value ) ; }	Adds a tag which contains an attribute.
@ override public void add tag ( string tag name , int value , map attributes ) { add tag ( tag name , string . value of ( value ) , attributes ) ; }	Adds a tag which contains the attributes specified.
public static string indent block ( string block , indent indent ) { string builder sb = new string builder ( ) ; buffered reader br = new buffered reader ( new string reader ( block ) ) ; string line ; try { while ( ( line = br . read line ( ) ) != null ) sb . append ( indent ) . append ( line ) . append ( str ) ; } catch ( io ex ) {	Indents a block of text.
public static long to end time ( clock clock , object timeout ) { timespan t = to timespan ( timeout ) ; if ( t == null ) return num ; if ( clock == null ) clock = system clock . instance ; if ( t . get duration in milliseconds ( ) == num ) return num ; return t . future time millis ( clock ) ; }	Computes the end time = now + timeout.
public ram add ( ram entry ) { touch ( ) ; directory content . put ( entry . name ( ) , entry ) ; return entry ; }	Copy the entry in this directory with the provided name.
public ram mkdir ( string name ) throws io { ram entry = get entry ( name ) ; if ( entry instanceof ram ) { ram ram directory = ( ram ) entry ; return ram directory ; } else { if ( entry == null ) { ram directory = new ram ( clock , name ) ; return ( ram ) add ( directory ) ; } else { throw new io ( str + name ) ; } } }	Creates an empty directory and add it to this directory with this name.
public static string encode string ( one way codec codec , string s ) { try { return codec . encode ( s . get bytes ( str ) ) ; } catch ( unsupported encoding exception ex ) {	Encodes the string using the codec provided.
public static string decode string ( codec codec , string s ) throws codec . cannot decode exception { try { return new string ( codec . decode ( s ) , str ) ; } catch ( unsupported encoding exception ex ) {	Decodes the string using the codec provided. Returns a string.
public static leaf resource create ( resource resource ) { try {	Decorates the resource to implement a caching strategy.
public static < t > t [ ] reverse ( t [ ] array ) { if ( array == null ) return array ; int s = num ; int e = array . length - num ; while ( s < e ) {	Reverses the array in place.
public static < t extends enum < t > > enum set < t > to enum set ( class < t > clazz , t ... ts ) { if ( ts == null ) return null ; enum set < t > res = enum set . none of ( clazz ) ; for ( t t : ts ) { res . add ( t ) ; } return res ; }	Turns an array of enumeration values into an enum set.
public static properties load properties ( file file ) throws io { if ( file == null ) return null ; file reader reader = new file reader ( file ) ; try { return load properties ( reader ) ; } finally { reader . close ( ) ; } }	Convenient call to load a properties file from the provided file.
public static properties load properties ( reader reader ) throws io { if ( reader == null ) return null ; properties properties = new properties ( ) ; properties . load ( reader ) ; return properties ; }	Convenient call to load a properties file from the provided reader.
public string get as string ( enum set < time unit > time units ) { string builder sb = new string builder ( ) ; enum map < time unit , timespan > canonical timespans = get as timespans ( time units ) ; for ( time unit time unit : time unit order ) { if ( canonical timespans . contains key ( time unit ) ) { long duration = canonical timespans . get ( time unit ) . get duration ( ) ; if ( duration > num ) { sb . append ( duration ) . append ( time unit . get display char ( ) ) ; } } } if ( sb . length ( ) == num ) { sb . append ( num ) ; if ( time units . contains ( get time unit ( ) ) ) sb . append ( get time unit ( ) . get display char ( ) ) ; } return sb . to string ( ) ; }	Returns a string representing this timespan expressed with the units provided.
@ override public int compare to ( timespan timespan ) { if ( timespan . get time unit ( ) == get time unit ( ) ) return lang utils . compare ( get duration ( ) , timespan . get duration ( ) ) ; else return lang utils . compare ( get duration in milliseconds ( ) , timespan . get duration in milliseconds ( ) ) ; }	Compares 2 timespan. Based on duration in milliseconds.
public memory size truncate ( size unit size unit ) { if ( get size unit ( ) == size unit ) return this ; long size in bytes = get size in bytes ( ) ; if ( size in bytes >= size unit . get bytes count ( ) ) { return new memory size ( size in bytes / size unit . get bytes count ( ) , size unit ) ; } else { return zero sizes . get ( size unit ) ; } }	Return a new instance of MemorySize that is truncated to the given unit.
public memory size add ( memory size other ) { if ( other == null ) throw new null pointer exception ( ) ; if ( get size unit ( ) == other . get size unit ( ) ) return new memory size ( get size ( ) + other . get size ( ) , get size unit ( ) ) ; return new memory size ( get size in bytes ( ) + other . get size in bytes ( ) , size unit . byte ) ; }	Return a new instance of MemorySize that adds up the size of this objectwith that of the 'other'.
@ override public int compare to ( memory size memory size ) {	Compare with another instance of MemorySize based on size in bytes.
public static memory size create ( memory size ... memory sizes ) { if ( memory sizes == null ) return null ; if ( memory sizes . length == num ) return zero bytes ; memory size res = memory sizes [ num ] ; for ( int i = num ; i < memory sizes . length ; i ++ ) { memory size memory size = memory sizes [ i ] ; if ( memory size != null ) res = res . add ( memory size ) ; } return res ; }	Create a new instance of MemorySize by adding up the givenarray of memorySizes.
public static < v > future < v > execute ( callable < v > callable ) { future task < v > future task = new future task < v > ( callable ) ; new thread ( future task ) . start ( ) ; return future task ; }	Executes the callable in a separate thread and return the future to get the result.
public void add marker ( t marker ) { final marker options marker options = new marker options ( ) ; marker . set marker manager ( this ) ; marker . prepare marker ( marker options ) ; marker cache . put ( marker , google map . add marker ( marker options ) ) ; marker . on add ( ) ; }	Add a marker to the map.
public void remove marker ( t marker ) { final marker real marker = marker cache . get ( marker ) ; if ( real marker != null ) { real marker . remove ( ) ; } marker cache . remove ( marker ) ; }	Remove a marker from the map.
public static bitmap descriptor from view ( view view ) {	Returns a bitmap icon showing a screenshot of the view passed in.
private final static func1 < watch event < ? > , boolean > only related to ( final file file ) { return new func1 < watch event < ? > , boolean > ( ) { @ override public boolean call ( watch event < ? > event ) { final boolean ok ; if ( file . is directory ( ) ) ok = bool ; else if ( standard watch event kinds . overflow . equals ( event . kind ( ) ) ) ok = bool ; else { object context = event . context ( ) ; if ( context != null && context instanceof path ) { path p = ( path ) context ; path base path = get base path ( file ) ; file p file = new file ( base path . to file ( ) , p . to string ( ) ) ; ok = p file . get absolute path ( ) . equals ( file . get absolute path ( ) ) ; } else ok = bool ; } return ok ; } } ; }	Returns true if and only if the path corresponding to a WatchEventrepresents the given file.
private static boolean emit events ( watch service watch service , subscriber < ? super watch event < ? > > subscriber , long poll duration ms , long poll interval ms ) {	returns true if and only there may be more events.
private state list drawable get selector drawable ( ) { state list drawable d = null ; try { d = new state list drawable ( ) ; shape drawable selected drawable = new shape drawable ( new oval shape ( ) ) ; selected drawable . get paint ( ) . set color ( m item selected color ) ; selected drawable . set intrinsic height ( m item radius * num ) ; selected drawable . set intrinsic width ( m item radius * num ) ; shape drawable unselected drawable = new shape drawable ( new oval shape ( ) ) ; unselected drawable . get paint ( ) . set color ( m item unselected color ) ; unselected drawable . set intrinsic height ( m item radius * num ) ; unselected drawable . set intrinsic width ( m item radius * num ) ; d . add state ( new int [ ] { android . r . attr . state checked } , selected drawable ) ; d . add state ( new int [ ] { } , unselected drawable ) ; } catch ( exception e ) { log . e ( tag , get message for ( e ) ) ; } return d ; }	Create a StateListDrawable for the pager indicator.
public void init with view pager ( view pager view pager ) throws illegal state exception { if ( view pager == null ) return ; if ( view pager . get adapter ( ) == null ) throw new illegal state exception ( str ) ; try { m view pager = view pager ; m view pager . add on page change listener ( m on page change listener ) ; add views ( ) ; } catch ( exception e ) { log . e ( tag , get message for ( e ) ) ; } }	Initialize ViewPagerIndicator with a properly set up ViewPager.
private void add views ( ) { try { if ( m view pager == null || m view pager . get adapter ( ) == null || m view pager . get adapter ( ) . get count ( ) == num ) return ; remove all views ( ) ; app compat radio button first item = new app compat radio button ( get context ( ) ) ; first item . set text ( str ) ; first item . set button drawable ( m button drawable . get constant state ( ) . new drawable ( ) ) ; view pager indicator . layout params params = new layout params ( layout params . wrap content , layout params . wrap content ) ; first item . set layout params ( params ) ; first item . set clickable ( bool ) ; add view ( first item ) ; for ( int i = num ; i < m view pager . get adapter ( ) . get count ( ) ; i ++ ) { app compat radio button item = new app compat radio button ( get context ( ) ) ; item . set text ( str ) ; item . set button drawable ( m button drawable . get constant state ( ) . new drawable ( ) ) ; params = new layout params ( layout params . wrap content , layout params . wrap content ) ; params . set margins ( m item divider width , num , num , num ) ; item . set layout params ( params ) ; item . set clickable ( bool ) ; add view ( item ) ; } check ( first item . get id ( ) ) ; } catch ( exception e ) { log . e ( tag , get message for ( e ) ) ; } }	Add page indicators based on the attached ViewPager.
private string get message for ( exception e ) { if ( e == null ) return tag + str ; return e != null && e . get message ( ) != null ? e . get message ( ) : e . get class ( ) . get name ( ) + str ; }	Always get a message for an exception.
private static int int value ( char x ) { if ( x >= str && x <= str ) return x - str ; if ( x >= str && x <= str ) return x - str + num ; if ( x >= str && x <= str ) return x - str + num ; throw new runtime exception ( str + x ) ; }	This method maps a hex character to its 4-bit representation in an int.
private static byte map to byte ( char a , char b ) { int ai = int value ( a ) ; int bi = int value ( b ) ; return ( byte ) ( ( ai << num ) | bi ) ; }	Map two hex characters to 4-bit numbers and combine them to produce 8-bit number in byte.
public date get timestamp ( ) { if ( get version ( ) != version ) return null ; long time ; time = ( ( long ) content [ num ] & num ) << num ; time |= ( ( long ) content [ num ] & num ) << num ; time |= ( ( long ) content [ num ] & num ) << num ; time |= ( ( long ) content [ num ] & num ) << num ; time |= ( ( long ) content [ num ] & num ) << num ; time |= ( ( long ) content [ num ] & num ) ; return new date ( time ) ; }	Extract timestamp from raw UUID bytes and return as int.
public byte [ ] get mac fragment ( ) { if ( get version ( ) != str ) return null ; byte [ ] x = new byte [ num ] ; x [ num ] = num ; x [ num ] = num ; x [ num ] = ( byte ) ( content [ num ] & num ) ; x [ num ] = content [ num ] ; x [ num ] = content [ num ] ; x [ num ] = content [ num ] ; return x ; }	Extract MAC address fragment from raw UUID bytes, setting missing values to 0, thus the first 2 and a half byteswill be 0, followed by 3 and a half bytes of the active MAC address when the UUID was generated.
public void set property ( string key , string value ) { if ( properties == null ) { properties = create properties ( ) ; } if ( value != null ) { value = value . trim ( ) ; properties . put ( key , value ) ; } else { properties . remove ( key ) ; } }	Sets a custom property.
@ deprecated public void set facebook user credentials ( string user id , string token ) { set property ( socialize config . facebook user id , user id ) ; set property ( socialize config . facebook user token , token ) ; }	Sets the FB credentials for the current user if available.
public void set socialize credentials ( string consumer key , string consumer secret ) { set property ( socialize config . socialize consumer key , consumer key ) ; set property ( socialize config . socialize consumer secret , consumer secret ) ; }	Sets the Socialize credentials for your App.
public void merge ( properties other , set < string > to be removed ) { if ( properties == null ) { properties = create properties ( ) ; } if ( other != null && other . size ( ) > num ) { set < entry < object , object > > entry set = other . entry set ( ) ; for ( entry < object , object > entry : entry set ) { properties . put ( entry . get key ( ) , entry . get value ( ) ) ; } } if ( to be removed != null && to be removed . size ( ) > num ) { for ( string key : to be removed ) { properties . remove ( key ) ; } to be removed . clear ( ) ; } }	Merge properties into the config.
protected void do share ( final activity context , final entity entity , final share type share type , final share add listener share add listener ) { final socialize session session = get socialize ( ) . get session ( ) ; share system . add share ( context , session , entity , str , share type , null , new share add listener ( ) { @ override public void on error ( socialize exception error ) { if ( share add listener != null ) { share add listener . on error ( error ) ; } } @ override public void on create ( share share ) { if ( share != null && share system != null ) { handle non network share ( context , session , share type , share , str , null , share add listener ) ; } } } ) ; }	Creates the socialize share object.
protected void handle non network share ( activity activity , final socialize session session , final share type share type , final share share , string share text , location location , final share add listener share add listener ) { social network listener sn listener = new social network listener ( ) { @ override public void on network error ( activity context , social network network , exception error ) { if ( share add listener != null ) { share add listener . on error ( socialize exception . wrap ( error ) ) ; } } @ override public void on cancel ( ) { if ( share add listener != null ) { share add listener . on cancel ( ) ; } } @ override public boolean on before post ( activity parent , social network social network , post data post data ) { return share add listener instanceof social network listener && ( ( simple share listener ) share add listener ) . on before post ( parent , social network , post data ) ; } @ override public void on after post ( activity parent , social network social network , json response object ) { if ( share add listener != null ) { share add listener . on create ( share ) ; } } } ; share system . share ( activity , session , share , share text , location , share type , sn listener ) ; }	Handles a non-network share like email or SMS.
public static void add comment ( activity context , entity entity , string text , comment add listener listener ) { proxy . add comment ( context , entity , text , listener ) ; }	Adds a comment to the given entity.
public static void delete comment ( activity context , long id , comment delete listener listener ) { proxy . delete comment ( context , id , listener ) ; }	Deletes a comment. Only the person that created the comment can delete it.
public static void get comment ( activity context , comment get listener listener , long id ) { proxy . get comment ( context , id , listener ) ; }	Retrieves a single comment based on ID.
public static void get comments ( activity context , comment list listener listener , long ... ids ) { proxy . get comments ( context , listener , ids ) ; }	Retrieves comments based on a set of IDs.
public static void get comments by user ( activity context , user user , int start , int end , comment list listener listener ) { proxy . get comments by user ( context , user , start , end , listener ) ; }	Retrieves all comments made by the given user.
public static void get comments by entity ( activity context , string entity key , int start , int end , comment list listener listener ) { proxy . get comments by entity ( context , entity key , start , end , listener ) ; }	Retrieves all comments associated with the given entity.
public static void get comments by application ( activity context , int start , int end , comment list listener listener ) { proxy . get comments by application ( context , start , end , listener ) ; }	Retrieves all comments across all entities.
public static void show comment view ( activity context , entity entity , on comment view action listener listener ) { proxy . show comment view ( context , entity , listener ) ; }	Shows the comments for an entity.
public json parse object ( string json ) throws json { json = json . trim ( ) ; if ( json . starts with ( str ) ) { json array = new json ( json ) ; json obj = new json ( ) ; obj . put ( str , array ) ; return obj ; } else { return new json ( json ) ; } }	Detects whether the inbound string is a JSONArray and if so wraps the array in an object with a single field called "data".
public static json parse json ( string response ) throws json , facebook error {	Parse a server response into a JSON Object.
public static void show alert ( context context , string title , string text ) { builder alert builder = new builder ( context ) ; alert builder . set title ( title ) ; alert builder . set message ( text ) ; alert builder . create ( ) . show ( ) ; }	Display a simple alert dialog with the given text and title.
public static void logd ( string tag , string msg ) { if ( enable log ) { log . d ( tag , msg ) ; } }	A proxy for Log.d api that kills log messages in release build.
private type get runtime type if more specific ( type type , object value ) { if ( value != null && ( type == object . class || type instanceof type variable < ? > || type instanceof class < ? > ) ) { type = value . get class ( ) ; } return type ; }	Finds a compatible runtime type if it is more specific.
public void set entity safe ( entity entity ) { if ( string utils . is empty ( entity . get name ( ) ) ) { set entity key ( entity . get key ( ) ) ; } else { set entity ( entity ) ; } }	Reverts to only set the entity key if the name is not defined.This ensures an existing entity name is not wiped out when the action is saved.
public string build profile image url ( string id ) { string builder builder = new string builder ( ) ; builder . append ( str ) ; builder . append ( id ) ; builder . append ( str ) ; return builder . to string ( ) ; }	Constructs the URL to access the FB graph API and retrieve a profile image for theuser with the given facebook id.
public void on image change ( bitmap bitmap ) { if ( bitmap != null ) { bitmap scaled = bitmap utils . get scaled bitmap ( bitmap , num , num ) ; content . on profile picture change ( scaled ) ; } }	Called when the profile picture has been changed by the user.
public string generate ( ) throws o { try { string normalized url = normalize request url ( ) ; string normalized params = normalize request parameters ( ) ; return request . get method ( ) + str + o . percent encode ( normalized url ) + str + o . percent encode ( normalized params ) ; } catch ( exception e ) { throw new o ( e ) ; } }	Builds the signature base string from the data this instance wasconfigured with.
public string normalize request parameters ( ) throws io { if ( request parameters == null ) { return str ; } string builder sb = new string builder ( ) ; iterator < string > iter = request parameters . key set ( ) . iterator ( ) ; for ( int i = num ; iter . has next ( ) ; i ++ ) { string param = iter . next ( ) ; if ( o . oauth signature . equals ( param ) || str . equals ( param ) ) { continue ; } if ( i > num ) { sb . append ( str ) ; } sb . append ( request parameters . get as query string ( param ) ) ; } return sb . to string ( ) ; }	Normalizes the set of request parameters this instance was configuredwith, as per OAuth spec section 9.1.1.
public void authorize ( activity activity , final dialog listener listener ) { authorize ( activity , new string [ ] { } , default auth activity code , listener ) ; }	Default authorize method. Grants only basic permissions.See authorize() below for .
private boolean validate activity intent ( context context , intent intent ) { resolve info resolve info = context . get package manager ( ) . resolve activity ( intent , num ) ; if ( resolve info == null ) { return bool ; } return validate app signature for package ( context , resolve info . activity info . package name ) ; }	Helper to validate an activity intent by resolving and checking theprovider's package signature.
public string logout ( context context ) throws url , io { util . clear cookies ( context ) ; bundle b = new bundle ( ) ; b . put string ( str , str ) ; string response = request ( b ) ; set access token ( null ) ; set access expires ( num ) ; return response ; }	Invalidate the current user session by removing the access token inmemory, clearing the browser cookie, and calling auth.expireSessionthrough the API.Note that this method blocks waiting for a network response, so do notcall it in a UI thread.
public void dialog ( context context , string action , bundle parameters , final dialog listener listener ) { string endpoint = dialog base url + action ; parameters . put string ( str , str ) ; parameters . put string ( str , redirect uri ) ; if ( action . equals ( login ) ) { parameters . put string ( str , str ) ; parameters . put string ( str , m app id ) ; } else { parameters . put string ( str , m app id ) ; } if ( is session valid ( ) ) { parameters . put string ( token , get access token ( ) ) ; } string url = endpoint + str + util . encode url ( parameters ) ; if ( context . check calling or self permission ( manifest . permission . internet ) != package manager . permission granted ) { util . show alert ( context , str , str ) ; } else { new fb dialog ( context , url , listener ) . show ( ) ; } }	Generate a UI dialog for the request action in the given Android contextwith the provided parameters.Note that this method is asynchronous and the callback will be invoked inthe original calling thread (not in a background thread).
@ deprecated public static void link ( activity context , socialize auth listener listener ) { proxy . link ( context , listener ) ; }	Links the current user to a facebook account.
@ deprecated public static void link ( activity context , socialize auth listener listener , string ... permissions ) { proxy . link ( context , listener , permissions ) ; }	Links the current user to a facebook account with custom FB permissions.
@ deprecated public static void link ( activity context , string token , boolean verify permissions , socialize auth listener listener ) { proxy . link ( context , token , verify permissions , listener ) ; }	Links an existing Facebook access token with the current user.
public static void post entity ( final activity context , final entity entity , final string text , final social network share listener listener ) { if ( proxy . is linked for write ( context ) ) { proxy . post entity ( context , entity , text , listener ) ; } else { proxy . link for write ( context , new socialize auth listener ( ) { @ override public void on error ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . facebook , error ) ; } } @ override public void on cancel ( ) { if ( listener != null ) { listener . on cancel ( ) ; } } @ override public void on auth success ( socialize session session ) { proxy . post entity ( context , entity , text , listener ) ; } @ override public void on auth fail ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . facebook , error ) ; } } } ) ; } }	Posts an entity to the user's Facebook wall.
@ deprecated public static void extend access token ( activity context , socialize auth listener listener ) { proxy . extend access token ( context , listener ) ; }	Extends the user's Facebook access token if needed.
public static void get current permissions ( activity context , string token , on permission result callback ) { proxy . get current permissions ( context , token , callback ) ; }	Retrieves the current permissions for token provided.
public static string [ ] get hash keys ( activity context ) throws no such algorithm exception { package info package info = null ; string [ ] keys = null ; try { package info = context . get package manager ( ) . get package info ( context . get package name ( ) , package manager . get signatures ) ; if ( package info != null && package info . signatures != null && package info . signatures . length > num ) { keys = new string [ package info . signatures . length ] ; for ( int i = num ; i < package info . signatures . length ; i ++ ) { signature signature = package info . signatures [ i ] ; message digest md = message digest . get instance ( str ) ; md . update ( signature . to byte array ( ) ) ; string hash = new string ( base64 . encode ( md . digest ( ) , num ) ) ; keys [ i ] = hash ; } } } catch ( package manager . name not found exception e ) { e . print stack trace ( ) ; } return keys ; }	Returns the hash key used to authenticate this application with Facebook.
public static void save entity ( activity context , entity e , entity add listener listener ) { proxy . save entity ( context , e , listener ) ; }	Saves or Creates an entity.
public static void get entity ( activity context , string key , entity get listener listener ) { proxy . get entity ( context , key , listener ) ; }	Retrieves an entity based on its key.
public static void get entity ( activity context , long id , entity get listener listener ) { proxy . get entity ( context , id , listener ) ; }	Retrieves an entity based on its id.
public static void get entities ( activity context , int start , int end , entity list listener listener ) { proxy . get entities ( context , start , end , sort order . creation date , listener ) ; }	Retrieves all entities sorted by creation date.
public static void get entities ( activity context , entity list listener listener , string ... keys ) { proxy . get entities ( context , sort order . creation date , listener , keys ) ; }	Retrieves the entities designated by the given keys.
@ override public boolean on create context menu ( ui activity , context menu menu , view v , context menu . context menu info menu info ) { return bool ; }	Called BEFORE the default activity onCreateContextMenu event.
public static void subscribe ( activity context , entity e , subscription type type , subscription result listener listener ) { subscription utils . subscribe ( context , e , type , listener ) ; }	Subscribes the current user to notifications for new comments on this entity.
public static void is subscribed ( activity context , entity e , subscription type type , subscription check listener listener ) { subscription utils . is subscribed ( context , e , type , listener ) ; }	Determines if the current user is subscribed to notifications on new comments for the given entity.
public boolean check registrations ( context context , socialize session session ) { boolean checked = bool ; if ( ! checking ) { checking = bool ; try { if ( app utils . is notifications available ( context ) ) { if ( config . get boolean property ( socialize config . socialize check notifications , bool ) ) { if ( logger != null && logger . is debug enabled ( ) ) { logger . debug ( str ) ; } boolean c2 dm = notification registration system . is registered c2 dm ( context ) ; boolean soc registered = notification registration system . is registered socialize ( context , session . get user ( ) ) ; if ( ! c2 dm || ! soc registered ) {	Called at application startup.
public json token peek ( ) throws io { if ( token != null ) { return token ; } switch ( stack [ stack size - num ] ) { case empty document : if ( lenient ) { consume non execute prefix ( ) ; } stack [ stack size - num ] = json scope . nonempty document ; json token first token = next value ( ) ; if ( ! lenient && token != json token . begin array && token != json token . begin object ) { throw new io ( str + token + str + get line number ( ) + str + get column number ( ) ) ; } return first token ; case empty array : return next in array ( bool ) ; case nonempty array : return next in array ( bool ) ; case empty object : return next in object ( bool ) ; case dangling name : return object value ( ) ; case nonempty object : return next in object ( bool ) ; case nonempty document : int c = next non whitespace ( bool ) ; if ( c == - num ) { return json token . end document ; } pos -- ; if ( ! lenient ) { throw syntax error ( str ) ; } return next value ( ) ; case closed : throw new illegal state exception ( str ) ; default : throw new assertion error ( ) ; } }	Returns the type of the next token without consuming it.
public void next null ( ) throws io { peek ( ) ; if ( token != json token . null ) { throw new illegal state exception ( str + token + str + get line number ( ) + str + get column number ( ) ) ; } advance ( ) ; }	Consumes the next token from the JSON stream and asserts that it is aliteral null.
private char read escape character ( ) throws io { if ( pos == limit && ! fill buffer ( num ) ) { throw syntax error ( str ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case str : if ( pos + num > limit && ! fill buffer ( num ) ) { throw syntax error ( str ) ; }	Unescapes the character identified by the character or characters thatimmediately follow a backslash.
public static void show share dialog ( activity context , entity entity ) { proxy . show share dialog ( context , entity , default , null , null ) ; }	Displays the default share dialog.
public static void show share dialog ( activity context , entity entity , social network dialog listener listener ) { proxy . show share dialog ( context , entity , default , listener , listener ) ; }	Displays the default share dialog and allows for the handling of share dialog events.
public static void share via email ( activity context , entity entity , share add listener listener ) { proxy . share via email ( context , entity , listener ) ; }	Shares the given entity via email.
public static void share via google plus ( activity context , entity entity , share add listener listener ) { proxy . share via google plus ( context , entity , listener ) ; }	Shares the given entity via Google+.
public static void share via other ( activity context , entity entity , share add listener listener ) { proxy . share via other ( context , entity , listener ) ; }	Shares the given entity via a user selected medium.
public static void share via sms ( activity context , entity entity , share add listener listener ) { proxy . share via sms ( context , entity , listener ) ; }	Shares the given entity via SMS.
public static void share via social networks ( activity context , entity entity , share options share options , social network share listener listener , social network ... networks ) { proxy . share via social networks ( context , entity , share options , listener , networks ) ; }	Shares the given entity via a Social Network such as Twitter or Facebook.
public static void get share ( activity context , share get listener listener , long id ) { proxy . get share ( context , listener , id ) ; }	Retrieves a single share event based on ID.
public static void get shares ( activity context , share list listener listener , long ... ids ) { proxy . get shares ( context , listener , ids ) ; }	Retrieves multiple share events based on ID.
public static void get shares by user ( activity context , user user , int start , int end , share list listener listener ) { proxy . get shares by user ( context , user , start , end , listener ) ; }	Retrieves all share events performed by the given user.
public static void get shares by entity ( activity context , string entity key , int start , int end , share list listener listener ) { proxy . get shares by entity ( context , entity key , start , end , listener ) ; }	Retrieves all share events performed on the given entity.
public static void get shares by application ( activity context , int start , int end , share list listener listener ) { proxy . get shares by application ( context , start , end , listener ) ; }	Retrieves all share events across all entities.
public static void like ( activity context , entity entity , like add listener listener ) { proxy . like ( context , entity , listener ) ; }	Records a like against the given entity for the current user.
public static void like ( activity context , entity entity , like options like options , like add listener listener , social network ... networks ) { proxy . like ( context , entity , like options , listener , networks ) ; }	Records a like against the given entity for the current user.
public static void unlike ( activity context , string entity key , like delete listener listener ) { proxy . unlike ( context , entity key , listener ) ; }	Removes a like previously created for the current user.
public static void get like ( activity context , string entity key , like get listener listener ) { proxy . get like ( context , entity key , listener ) ; }	Retrieves a like for an entity and the current user.
public static void get like ( activity context , long id , like get listener listener ) { proxy . get like ( context , id , listener ) ; }	Retrieves a like based on its ID.
public static void is liked ( activity context , string entity key , is liked listener listener ) { proxy . get like ( context , entity key , listener ) ; }	Determines if the given entity has been liked by the current user.
public static void get likes by user ( activity context , user user , int start , int end , like list listener listener ) { proxy . get likes by user ( context , user , start , end , listener ) ; }	Lists all likes for the given user.
public static void get likes by entity ( activity context , string entity key , int start , int end , like list listener listener ) { proxy . get likes by entity ( context , entity key , start , end , listener ) ; }	Lists all likes for the given entity.
protected void collect header parameters ( http request request , http parameters out ) { http parameters header params = o . oauth header to params map ( request . get header ( o . http authorization header ) ) ; out . put all ( header params , bool ) ; }	Collects OAuth Authorization header parameters as per OAuth Core 1.0 specsection 9.1.1.
protected void collect body parameters ( http request request , http parameters out ) throws io {	Collects x-www-form-urlencoded body parameters as per OAuth Core 1.0 specsection 9.1.1.
protected void collect query parameters ( http request request , http parameters out ) { string url = request . get request url ( ) ; int q = url . index of ( str ) ; if ( q >= num ) {	Collects HTTP GET query string parameters as per OAuth Core 1.0 specsection 9.1.1.
private json writer new json writer ( writer writer ) throws io { if ( generate non executable json ) { writer . write ( json non executable prefix ) ; } json writer json writer = new json writer ( writer ) ; if ( pretty printing ) { json writer . set indent ( str ) ; } json writer . set serialize nulls ( serialize nulls ) ; return json writer ; }	Returns a new JSON writer configured for this GSON and with the non-executeprefix if that is configured.
@ suppress warnings ( str )	Constructors for common interface types like Map and List and theirsubytpes.
public static string replace new lines ( string src , int from , int to ) { if ( src != null && from > num && to < from ) { string str from = str ; string str to = str ; for ( int i = num ; i < from ; i ++ ) { str from += str ; } for ( int i = num ; i < to ; i ++ ) { str to += str ; } while ( src . contains ( str from ) ) { src = src . replace all ( str from , str to ) ; } } return src ; }	Replaces successive new line characters.
public string get simple location ( address address ) { string builder builder = new string builder ( ) ; string locality = address . get locality ( ) ; string country name = address . get country name ( ) ; if ( ! string utils . is empty ( locality ) ) { builder . append ( locality ) ; } else if ( ! string utils . is empty ( country name ) ) { builder . append ( country name ) ; } return builder . to string ( ) ; }	Returns a simple one-line address based on city and country.
protected void get user ( final session session , final auth provider listener listener ) { request . execute me request async ( session , new request . graph user callback ( ) {	so we can mock.
public static void get actions by application ( activity context , int start , int end , action list listener listener ) { proxy . get actions by application ( context , start , end , listener ) ; }	Gets the application-wide actions.
public static void get actions by user ( activity context , long user id , int start , int end , action list listener listener ) { proxy . get actions by user ( context , user id , start , end , listener ) ; }	Gets the actions of a single user.
public static void get actions by entity ( activity context , string entity key , int start , int end , action list listener listener ) { proxy . get actions by entity ( context , entity key , start , end , listener ) ; }	Gets the actions for a given entity.
public static void get actions by user and entity ( activity context , long user id , string entity key , int start , int end , action list listener listener ) { proxy . get actions by user and entity ( context , user id , entity key , start , end , listener ) ; }	Gets the actions of a single user on a single entity.
private json writer close ( json scope empty , json scope nonempty , string close bracket ) throws io { json scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new illegal state exception ( str + stack ) ; } if ( deferred name != null ) { throw new illegal state exception ( str + deferred name ) ; } stack . remove ( stack . size ( ) - num ) ; if ( context == nonempty ) { newline ( ) ; } out . write ( close bracket ) ; return this ; }	Closes the current scope by appending any necessary whitespace and thegiven bracket.
public json writer name ( string name ) throws io { if ( name == null ) { throw new null pointer exception ( str ) ; } if ( deferred name != null ) { throw new illegal state exception ( ) ; } deferred name = name ; return this ; }	Encodes the property name.
public json element parse ( reader json ) throws io , json syntax exception { try { json reader json reader = new json reader ( json ) ; json element element = parse ( json reader ) ; if ( ! element . is json null ( ) && json reader . peek ( ) != json token . end document ) { throw new json syntax exception ( str ) ; } return element ; } catch ( malformed json exception e ) { throw new json syntax exception ( e ) ; } catch ( io e ) { throw new io ( e ) ; } catch ( number format exception e ) { throw new json syntax exception ( e ) ; } }	Parses the specified JSON string into a parse tree.
public json element parse ( json reader json ) throws io , json syntax exception { boolean lenient = json . is lenient ( ) ; json . set lenient ( bool ) ; try { return streams . parse ( json ) ; } catch ( stack overflow error e ) { throw new json parse exception ( str + json + str , e ) ; } catch ( out of memory error e ) { throw new json parse exception ( str + json + str , e ) ; } catch ( json parse exception e ) { if ( e . get cause ( ) instanceof eof ) { return json null . instance ; } throw e ; } finally { json . set lenient ( lenient ) ; } }	Returns the next value from the JSON stream as a parse tree.
public static void link ( activity context , string token , string secret , socialize auth listener listener ) { proxy . link ( context , token , secret , listener ) ; }	Links the current user to their Twitter account using an existing Twitter oAuth token and secret.
public static void set credentials ( context context , string consumer key , string consumer secret ) { proxy . set credentials ( context , consumer key , consumer secret ) ; }	Sets the Twitter App credentials for the application.
public static void tweet entity ( final activity context , final entity entity , final string text , final social network share listener listener ) { if ( proxy . is linked ( context ) ) { proxy . tweet entity ( context , entity , text , listener ) ; } else { proxy . link ( context , new socialize auth listener ( ) { @ override public void on error ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . twitter , error ) ; } } @ override public void on cancel ( ) { if ( listener != null ) { listener . on cancel ( ) ; } } @ override public void on auth success ( socialize session session ) { proxy . tweet entity ( context , entity , text , listener ) ; } @ override public void on auth fail ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . twitter , error ) ; } } } ) ; } }	"Tweets" an entity. A "share" event will be recorded in Socialize and the entity URL generated by Socialize will be posted to the user's Twitter feed.If the user is not currently linked to a Twitter account they will be prompted to authenticate.
public static void get ( final activity context , final string resource , final map < string , object > params , final social network post listener listener ) { if ( proxy . is linked ( context ) ) { proxy . get ( context , resource , params , listener ) ; } else { proxy . link ( context , new socialize auth listener ( ) { @ override public void on error ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . twitter , error ) ; } } @ override public void on cancel ( ) { if ( listener != null ) { listener . on cancel ( ) ; } } @ override public void on auth success ( socialize session session ) { proxy . get ( context , resource , params , listener ) ; } @ override public void on auth fail ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . twitter , error ) ; } } } ) ; } }	Performs a simple HTTP GET to the Twitter resource endpoint specified.
public static void tweet ( final activity context , final tweet tweet , final social network listener listener ) { if ( proxy . is linked ( context ) ) { proxy . tweet ( context , tweet , listener ) ; } else { proxy . link ( context , new socialize auth listener ( ) { @ override public void on error ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . twitter , error ) ; } } @ override public void on cancel ( ) { if ( listener != null ) { listener . on cancel ( ) ; } } @ override public void on auth success ( socialize session session ) { proxy . tweet ( context , tweet , listener ) ; } @ override public void on auth fail ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . twitter , error ) ; } } } ) ; } }	Performs a simple "tweet".
public static void tweet photo ( final activity context , final photo tweet photo , final social network post listener listener ) { if ( proxy . is linked ( context ) ) { proxy . tweet photo ( context , photo , listener ) ; } else { proxy . link ( context , new socialize auth listener ( ) { @ override public void on error ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . twitter , error ) ; } } @ override public void on cancel ( ) { if ( listener != null ) { listener . on cancel ( ) ; } } @ override public void on auth success ( socialize session session ) { proxy . tweet photo ( context , photo , listener ) ; } @ override public void on auth fail ( socialize exception error ) { if ( listener != null ) { listener . on network error ( context , social network . twitter , error ) ; } } } ) ; } }	Publishes a photo to a user's Twitter feed.
public bitmap get scaled bitmap ( bitmap bitmap , int scale to width , int scale to height , boolean recycle original , int density ) { bitmap . set density ( density ) ; bitmap original = bitmap ; if ( scale to width > num || scale to height > num ) { int width = bitmap . get width ( ) ; int height = bitmap . get height ( ) ;	Returns a scaled bitmap, cropped if necessary.
@ suppress warnings ( str ) public void put as post async ( socialize session session , string endpoint , t object , socialize action listener listener ) { async putter poster = new async putter ( session , listener ) ; socialize put request < t > request = new socialize put request < t > ( ) ; request . set request type ( request type . put as post ) ; request . set endpoint ( endpoint ) ; request . set object ( object ) ; poster . execute ( request ) ; }	Does a POST, but expects a single object in return.
public void set text size ( int text size ) { if ( text view != null ) { text view . set text size ( android . util . typed value . complex unit dip , text size ) ; } this . text size = text size ; }	Set the text size in DIP.
public void on image change ( bitmap bitmap , string local path ) { if ( profile layout view != null ) { profile layout view . on image change ( bitmap ) ; }	Called when the user's profile image is changed.
public static void save user async ( context context , user user , user save listener listener ) { proxy . save user async ( context , user , listener ) ; }	Saves the given user.
public static void get user ( context context , long id , user get listener listener ) { proxy . get user ( context , id , listener ) ; }	Retrieves a User based on the given ID.
public static void save user settings ( context context , user settings user settings , user save listener listener ) { proxy . save user settings ( context , user settings , listener ) ; }	Saves the profile for the given user.
@ deprecated public boolean set auto post preferences ( social network ... networks ) { boolean tw = is auto post to twitter ( ) ; boolean fb = is auto post to facebook ( ) ; set auto post to facebook ( bool ) ; set auto post to twitter ( bool ) ; if ( networks != null ) { for ( social network network : networks ) { if ( network . equals ( social network . facebook ) ) { set auto post to facebook ( bool ) ; } else if ( network . equals ( social network . twitter ) ) { set auto post to twitter ( bool ) ; } } } return tw != is auto post to twitter ( ) || fb != is auto post to facebook ( ) ; }	Sets the auto post preferences for the user.
@ deprecated public void authenticate ( activity context ) { authenticate ( context , facebook facade . default permissions , bool , bool ) ; }	Authenticates with default permissions and Single Sign On.
public void authenticate for read ( activity context , boolean sso , string [ ] permissions ) { authenticate ( context , permissions , sso , bool ) ; }	Authenticates with Single Sign On.
@ suppress warnings ( str ) public static final < e extends object > e get static field ( string field name , class < ? > clazz ) throws exception { try { field field = clazz . get field ( field name ) ; if ( field != null ) { return ( e ) field . get ( null ) ; } } catch ( exception e ) { throw e ; } return null ; }	Gets the value of the given static field from the given class.
public static final string get static field name ( object value , class < ? > clazz ) throws exception { field [ ] fields = clazz . get fields ( ) ; for ( field field : fields ) { object f val = field . get ( null ) ; if ( f val != null && f val . equals ( value ) ) { return field . get name ( ) ; } } return null ; }	Returns the name of the static field that corresponds to the given value.
public static boolean on message ( context context , intent intent ) { assert initialized ( context ) ; bundle message data = intent . get extras ( ) ; if ( message data != null ) { string source = message data . get string ( dm . source key ) ; if ( source != null && source . trim ( ) . equals ignore case ( dm . source socialize ) ) { handler . on message ( context , intent ) ; return bool ; } } return bool ; }	Handles a GCM message.
public static boolean handle broadcast intent ( context context , intent intent ) { return socialize . get socialize ( ) . handle broadcast intent ( context , intent ) ; }	Handles a broadcast intent received by a Broadcast Receiver on Android.Call this method if you already have a broadcast receiver defined but want to also utilize Socialize SmartAlerts.
public byte [ ] encode ( byte [ ] source , int off , int len , byte [ ] alphabet , int max line length ) { int len div3 = ( len + num ) / num ;	Encodes a byte array into Base64 notation.
public byte [ ] decode ( byte [ ] source , int off , int len , byte [ ] decodabet ) throws base64 decoder exception { int len34 = len * num / num ; byte [ ] out buff = new byte [ num + len34 ] ;	Decodes Base64 content using the supplied decodabet and returnsthe decoded byte array.
public static void view ( activity context , entity e , view add listener listener ) { proxy . view ( context , e , listener ) ; }	Records a view against the given entity for the current user.
public void on profile update ( ) { comment adapter . notify data set changed ( ) ; if ( comment entry slider != null ) { comment entry slider . update content ( ) ; } if ( notify box != null ) { try { user settings user = user utils . get user settings ( get context ( ) ) ; if ( user . is notifications enabled ( ) ) { notify box . set visibility ( view . visible ) ; } else { notify box . set visibility ( view . gone ) ; } } catch ( socialize exception e ) { if ( logger != null ) { logger . error ( str , e ) ; } else { e . print stack trace ( ) ; } notify box . set visibility ( view . gone ) ; } } }	Called when the current logged in user updates their profile.
public static http parameters decode form ( string form ) { http parameters params = new http parameters ( ) ; if ( is empty ( form ) ) { return params ; } for ( string nvp : form . split ( str ) ) { int equals = nvp . index of ( str ) ; string name ; string value ; if ( equals < num ) { name = percent decode ( nvp ) ; value = null ; } else { name = percent decode ( nvp . substring ( num , equals ) ) ; value = percent decode ( nvp . substring ( equals + num ) ) ; } params . put ( name , value ) ; } return params ; }	Parse a form-urlencoded document.
public static < t extends map . entry < string , string > > map < string , string > to map ( collection < t > from ) { hash map < string , string > map = new hash map < string , string > ( ) ; if ( from != null ) { for ( map . entry < string , string > entry : from ) { string key = entry . get key ( ) ; if ( ! map . contains key ( key ) ) { map . put ( key , entry . get value ( ) ) ; } } } return map ; }	Construct a Map containing a copy of the given parameters.
public static string to header element ( string name , string value ) { return o . percent encode ( name ) + str + o . percent encode ( value ) + str ; }	Helper method to concatenate a parameter and its value to a pair that canbe used in an HTTP header.
public boolean put ( k str key , e object , long ttl ) { return put ( str key , object , ttl , bool ) ; }	Adds an object to cache with the given time-to-live.
public boolean put ( k str key , e object , boolean eternal ) { return put ( str key , object , default ttl , eternal ) ; }	Adds an object to cache that optionally lives forever.
protected synchronized boolean put ( k k , e object , long ttl , boolean eternal ) {	Adds an object to cache with the given Time To Live in milliseconds.
public synchronized e get raw ( k str key ) { ttl < k , e > obj = get ttl ( str key ) ; if ( obj != null && ! is expired ( obj ) ) { return obj . get object ( ) ; } return null ; }	Ignores proxy and always returns raw object.
public synchronized e get ( k key ) { ttl < k , e > obj = get ttl ( key ) ; if ( obj != null && ! is expired ( obj ) ) { if ( extend on get ) { extend ttl ( key ) ; } if ( event listener != null ) { event listener . on get ( obj . get object ( ) ) ; } obj . get object ( ) . on get ( ) ; return obj . get object ( ) ; } else if ( obj != null ) {	Gets an object from cache.
public boolean exists ( k k ) { key < k > key = keys . get ( k ) ; if ( key != null ) { return objects . get ( key ) != null ; } return bool ; }	Returns true if the object with the given key resides in the cache.
public synchronized void extend ttl ( k str key ) { ttl < k , e > object = get ttl ( str key ) ; if ( object != null ) { object . set life expectancy ( system . current time millis ( ) + object . get ttl ( ) ) ; } }	Extends the ttl of the object with the given key with the current system time.
public void load image by data ( final string name , final string encoded data , int width , int height , final image load listener listener ) { image load request request = make request ( ) ; request . set url ( name ) ; request . set encoded image data ( encoded data ) ; request . set type ( image load type . encoded ) ; load image ( request , listener ) ; }	Loads an image based on Base64 encoded bytes.
public void load image by url ( final string url , int width , int height , final image load listener listener ) { image load request request = make request ( ) ; request . set url ( url ) ; request . set type ( image load type . url ) ; request . set scale width ( width ) ; request . set scale height ( height ) ; load image ( request , listener ) ; }	Asynchronously loads the image at the given url and calls the listener when it is loaded.
public static map < string , string > parse tags ( final string tag string ) throws illegal argument exception {	Convert a tag string into a tag map.
public static string format tags ( final map < string , string > tag map ) { string builder string builder = new string builder ( ) ; string delimeter = str ; for ( map . entry < string , string > tag : tag map . entry set ( ) ) { string builder . append ( delimeter ) . append ( sanitize ( tag . get key ( ) ) ) . append ( str ) . append ( sanitize ( tag . get value ( ) ) ) ; delimeter = str ; } return string builder . to string ( ) ; }	Convert a tag map into a space-delimited string.
public static string fix encoded tags in name after prefix ( final string name ) { if ( name == null ) return name ; int tag start = name . index of ( str ) ; if ( tag start == - num ) return name ;	Call this function whenever a potentially tag-encoded name is prefixed.
public static builder named ( string name ) { if ( ! has encoded tag in name ( name ) ) { return new builder ( name ) ; }	Creates a Builder for a metric name.
public string to telnet put string ( ) { string tag string = format tags ( tags ) ; return string . format ( str , metric , timestamp , value , tag string ) ; }	Returns a put string version of this metric compatible with the telnet-style reporter.Format: put (metric-name) (timestamp) (value) (tags) Example: put sys.cpu.nice 1346846400 18 host=web01 dc=lga.
@ override public string to human string ( ) { if ( unicode ) { return domain ; } final idna . info idna info = new idna . info ( ) ; final string builder idna output = new string builder ( ) ; idna . get ut ( idna . default ) . name to unicode ( domain , idna output , idna info ) ; return idna output . to string ( ) ; }	Converts the domain to a Unicode representation suitable for human interpretation.
public static string percent decode ( final string input ) { if ( input . is empty ( ) ) { return input ; } try { final byte array output stream bytes = new byte array output stream ( ) ; int idx = num ; while ( idx < input . length ( ) ) { boolean is eof = idx >= input . length ( ) ; int c = ( is eof ) ? num : input . code point at ( idx ) ; while ( ! is eof && c != str ) { if ( c <= num ) {	Percent-decodes a string.Percent-encoded bytes are assumed to represent UTF-8 characters.
public string query parameter ( final string name ) { if ( name == null ) { throw new null pointer exception ( str ) ; } if ( query == null || query . is empty ( ) ) { return null ; } int start = num ; do { final int next ampersand = query . index of ( str , start ) ; final int end = ( next ampersand == - num ) ? query . length ( ) : next ampersand ; int next equals = query . index of ( str , start ) ; if ( next equals == - num || next equals > end ) { next equals = end ; } final int this name length = next equals - start ; final int this value length = end - next equals ; if ( this name length == name . length ( ) && query . region matches ( start , name , num , name . length ( ) ) ) { if ( this value length == num ) { return str ; } return query . substring ( next equals + num , end ) ; } if ( next ampersand == - num ) { break ; } start = next ampersand + num ; } while ( bool ) ; return null ; }	Gets the first query parameter value for a given name.
public list < string > query parameters ( final string name ) { if ( name == null ) { throw new null pointer exception ( str ) ; } if ( query == null || query . is empty ( ) ) { return null ; } int start = num ; final list < string > result = new array list < string > ( ) ; do { final int next ampersand = query . index of ( str , start ) ; final int end = ( next ampersand == - num ) ? query . length ( ) : next ampersand ; int next equals = query . index of ( str , start ) ; if ( next equals == - num || next equals > end ) { next equals = end ; } final int this name length = next equals - start ; final int this value length = end - next equals ; if ( this name length == name . length ( ) && query . region matches ( start , name , num , name . length ( ) ) ) { if ( this value length == num ) { result . add ( str ) ; } else { result . add ( query . substring ( next equals + num , end ) ) ; } } if ( next ampersand == - num ) { break ; } start = next ampersand + num ; } while ( bool ) ; return result ; }	Gets all query parameter values for a given name.
public string relativize ( final url url ) { if ( this . is opaque ( ) || url . is opaque ( ) ) { return url . to string ( ) ; } if ( ! this . scheme ( ) . equals ( url . scheme ( ) ) ) { return url . to string ( ) ; } if ( this . authority ( ) == null ^ url . authority ( ) == null ) { return url . to string ( ) ; } if ( this . authority ( ) != null && ! this . authority ( ) . equals ( url . authority ( ) ) ) { return url . to string ( ) ; } string prefix path = ( this . path ( ) . ends with ( str ) ) ? this . path : this . path ( ) + str ; if ( ! url . path ( ) . starts with ( prefix path ) && ! this . path ( ) . equals ( url . path ( ) ) ) { return url . to string ( ) ; } string builder output = new string builder ( ) ; if ( ! this . path ( ) . equals ( url . path ( ) ) ) { output . append ( url . path ( ) . replace first ( prefix path , str ) ) ; } if ( url . query ( ) != null ) { output . append ( str ) . append ( url . query ( ) ) ; } if ( url . fragment ( ) != null ) { output . append ( str ) . append ( url . fragment ( ) ) ; } return output . to string ( ) ; }	Returns a relative URL reference for the given URL.Behaves as .
public static url build hierarchical ( final string scheme , final string host ) throws galimatias parse exception { if ( ! url . is relative scheme ( scheme ) ) { throw new galimatias parse exception ( str + scheme ) ; } return new url ( scheme + str + host ) . parse ( ) ; }	Gets a URL object from a relative scheme and a host.
public static url build opaque ( final string scheme ) throws galimatias parse exception { if ( url . is relative scheme ( scheme ) ) { throw new galimatias parse exception ( str + scheme ) ; } return new url ( scheme + str ) . parse ( ) ; }	Gets a URL object from a non-relative scheme.
public string to human string ( ) { final string builder output = new string builder ( ) ; output . append ( scheme ) . append ( str ) ; if ( is hierarchical ) { output . append ( str ) ; final string user info = user info ( ) ; if ( ! user info . is empty ( ) ) { output . append ( url . percent decode ( user info ) ) . append ( str ) ; } if ( host != null ) { if ( host instanceof i ) { output . append ( host . to host string ( ) ) ; } else { output . append ( host . to human string ( ) ) ; } } if ( port != - num ) { output . append ( str ) . append ( port ) ; } if ( path != null ) { output . append ( url . percent decode ( path ) ) ; } } else { output . append ( url . percent decode ( scheme data ) ) ; } if ( query != null ) { output . append ( str ) . append ( url . percent decode ( query ) ) ; } if ( fragment != null ) { output . append ( str ) . append ( url . percent decode ( fragment ) ) ; } return output . to string ( ) ; }	Serializes the URL to a human-readable representation.
private < t , u > u query stream with ordinal params ( string sql , prepared statement setter pss , row mapper < t > mapper , function < ? super stream < t > , u > handle stream ) { sql exc translator = jdbc template . get exception translator ( ) ; result set extractor < u > extractor = new stream result set extractor ( sql , mapper , handle stream , exc translator ) ; return jdbc template . query ( sql , pss , extractor ) ; }	Executes a quey for stream with ordinal parameters.
private < t , u > u query stream with named params ( string sql , sql parameter source sps , row mapper < t > mapper , function < ? super stream < t > , u > handle stream ) { sql exc translator = jdbc template . get exception translator ( ) ; result set extractor < u > extractor = new stream result set extractor ( sql , mapper , handle stream , exc translator ) ; return named jdbc template . query ( sql , sps , extractor ) ; }	Executes a query for stream with named parameters.
public static field [ ] get ( class < ? > clazz ) { field [ ] fields = cached fields . get ( clazz ) ; if ( fields == null ) { fields = clazz . get fields ( ) ; cached fields . put if absent ( clazz , fields ) ; } return fields ; }	Get fields of the given class.
private optional < t > fetch row ( ) { if ( this . row != null ) {	Fetches a row if not fetched yet.
protected static local date time get as local date time ( result set rs , int index ) throws sql { timestamp timestamp = rs . get timestamp ( index ) ; if ( timestamp != null ) { return timestamp . to local date time ( ) ; } return null ; }	Get the column value as LocalDateTime.
protected static local date get as local date ( result set rs , int index ) throws sql { date date = rs . get date ( index ) ; if ( date != null ) { return date . to local date ( ) ; } return null ; }	Get the column value as LocalDate.
protected static local time get as local time ( result set rs , int index ) throws sql { time time = rs . get time ( index ) ; if ( time != null ) { return time . to local time ( ) ; } return null ; }	Get the column value as LocalTime.
protected static zoned date time get as zoned date time ( result set rs , int index , zone id zone id ) throws sql { timestamp timestamp = rs . get timestamp ( index ) ; if ( timestamp != null ) { return timestamp . to local date time ( ) . at zone ( zone id ) ; } return null ; }	Get the column value as ZonedDateTime.
protected static offset date time get as offset date time ( result set rs , int index , zone id zone id ) throws sql { timestamp timestamp = rs . get timestamp ( index ) ; if ( timestamp != null ) { return timestamp . to local date time ( ) . at zone ( zone id ) . to offset date time ( ) ; } return null ; }	Get the column value as OffsetDateTime.
protected static offset time get as offset time ( result set rs , int index , zone id zone id ) throws sql { time time = rs . get time ( index ) ; if ( time != null ) { return time . to local time ( ) . at offset ( zone id . get rules ( ) . get offset ( instant . now ( ) ) ) ; } return null ; }	Get the column value as OffsetTime.
protected object get column value ( result set rs , int index , class < ? > required type ) throws sql { return jsr310 jdbc utils . get result set value ( rs , index , required type , zone id ) ; }	Get the column value.
public cdn path builder crop ( int width , int height ) { dimensions guard ( width , height ) ; sb . append ( str ) . append ( width ) . append ( str ) . append ( height ) ; return this ; }	Adds top-left-aligned crop.
public cdn path builder crop center ( int width , int height ) { dimensions guard ( width , height ) ; sb . append ( str ) . append ( width ) . append ( str ) . append ( height ) . append ( str ) ; return this ; }	Adds center-aligned crop.
public cdn path builder crop color ( int width , int height , color color ) { dimensions guard ( width , height ) ; sb . append ( str ) . append ( width ) . append ( str ) . append ( height ) . append ( str ) . append ( color to hex ( color ) ) ; return this ; }	Adds top-left-aligned crop with a filled background.
public cdn path builder resize width ( int width ) { dimension guard ( width ) ; sb . append ( str ) . append ( width ) . append ( str ) ; return this ; }	Resizes width, keeping the aspect ratio.
public cdn path builder resize ( int width , int height ) { dimensions guard ( width , height ) ; sb . append ( str ) . append ( width ) . append ( str ) . append ( height ) ; return this ; }	Resizes width and height.
public cdn path builder scale crop ( int width , int height ) { dimensions guard ( width , height ) ; sb . append ( str ) . append ( width ) . append ( str ) . append ( height ) ; return this ; }	Scales the image until one of the dimensions fits,then crops the bottom or right side.
public cdn path builder scale crop center ( int width , int height ) { dimensions guard ( width , height ) ; sb . append ( str ) . append ( width ) . append ( str ) . append ( height ) . append ( str ) ; return this ; }	Scales the image until one of the dimensions fits,centers it, then crops the rest.
public cdn path builder blur ( int strength ) { if ( strength < num || strength > num ) { strength = num ; } sb . append ( str ) . append ( strength ) ; return this ; }	Performs Gaussian blur on result image.
public cdn path builder sharp ( int strength ) { if ( strength < num || strength > num ) { strength = num ; } sb . append ( str ) . append ( strength ) ; return this ; }	Performs sharpening on result image.
public cdn path builder preview ( int width , int height ) { dimensions guard ( width , height ) ; sb . append ( str ) . append ( width ) . append ( str ) . append ( height ) ; return this ; }	Reduces an image proportionally in order to fit it into given dimensions.
public project get project ( ) { uri url = urls . api project ( ) ; request helper request helper = get request helper ( ) ; project data project data = request helper . execute query ( new http get ( url ) , bool , project data . class ) ; return new project ( this , project data ) ; }	Requests project info from the API.
public file get file ( string file id ) { uri url = urls . api file ( file id ) ; request helper request helper = get request helper ( ) ; file data file data = request helper . execute query ( new http get ( url ) , bool , file data . class ) ; return new file ( this , file data ) ; }	Requests file data.
public void delete file ( string file id ) { uri url = urls . api file ( file id ) ; request helper request helper = get request helper ( ) ; request helper . execute command ( new http delete ( url ) , bool ) ; }	Marks a file as deleted.
public void save file ( string file id ) { uri url = urls . api file storage ( file id ) ; request helper request helper = get request helper ( ) ; request helper . execute command ( new http post ( url ) , bool ) ; }	Marks a file as saved.This has to be done for all files you want to keep.Unsaved files are eventually purged.
public http response execute command ( http uri request request , boolean api headers ) { if ( api headers ) { set api headers ( request ) ; } try { closeable http response response = client . get http client ( ) . execute ( request ) ; try { check response status ( response ) ; return response ; } finally { response . close ( ) ; } } catch ( io e ) { throw new uploadcare network exception ( e ) ; } }	Executes the request et the Uploadcare API and return the HTTP Response object.The existence of this method(and it's return type) enables the end user to extend thefunctionality of theUploadcare API client by creating a subclass of {.
private void check response status ( http response response ) throws io { int status code = response . get status line ( ) . get status code ( ) ; if ( status code >= num && status code < num ) { return ; } else if ( status code == num || status code == num ) { throw new uploadcare authentication exception ( stream to string ( response . get entity ( ) . get content ( ) ) ) ; } else if ( status code == num || status code == num ) { throw new uploadcare invalid request exception ( stream to string ( response . get entity ( ) . get content ( ) ) ) ; } else { throw new uploadcare api exception ( str + stream to string ( response . get entity ( ) . get content ( ) ) ) ; } }	Verifies that the response status codes are within acceptable boundaries and throwscorresponding exceptionsotherwise.
public static uri upload from url ( string source url , string pub key , string store ) { uri builder = new uri ( uri . create ( upload base ) ) ; builder . set path ( str ) . set parameter ( str , source url ) . set parameter ( str , pub key ) . set parameter ( str , store ) ; return trusted build ( builder ) ; }	Creates a URL for URL upload.
@ override public void inject ( object target ) { check state ( m object graph != null , str ) ; m object graph . inject ( target ) ; }	Injects a target object using this ActionBarActivity's object graph.
public static builder new builder ( context context , int theme res id ) { if ( build . version . sdk int >= num ) { return new a ( context , theme res id ) ; } return new api20 builder ( context , theme res id ) ; }	Create new Builder.
@ nullable public class < ? > find class ( final string class name ) { objects . require non null ( class name ) ; try { return ( class < ? > ) find class . invoke ( loader , class name ) ; } catch ( illegal access exception | invocation target exception e ) { throw new parser transform exception ( str + class name + str , e ) ; } }	Returns the class with the given name if it has already been loaded bythe given class loader If the class has not been loaded yet, this method returns {.
public trie builder add word ( @ nonnull final string word ) { objects . require non null ( word ) ; final int length = word . length ( ) ; if ( length == num ) throw new illegal argument exception ( str + str ) ; nr words ++ ; max length = math . max ( max length , length ) ; node builder . add word ( word ) ; return this ; }	Add one word to the trie.
public boolean append ( final char c ) { if ( get ( ) == null ) return set ( new string builder ( ) . append ( c ) ) ; get ( ) . append ( c ) ; return bool ; }	Appends the given char.If this instance is currently uninitialized the given char is used for initialization.
public final t get and set ( final t value ) { final t ret = this . value ; this . value = value ; return ret ; }	Replaces this references value with the given one.
public static boolean is assignable to ( final string class internal name , final class < ? > type ) { objects . require non null ( class internal name , str ) ; objects . require non null ( type , str ) ; final class < ? > c = cache . load class ( class internal name ) ;	Determines whether the class with the given descriptor is assignable tothe given type.
private void copy parse info ( final file system zipfs ) throws io { final path path = zipfs . get path ( info path ) ; try ( final buffered writer writer = files . new buffered writer ( path , utf 8 ) ; ) { sb . set length ( num ) ; sb . append ( start time ) . append ( str ) . append ( prematch indices . size ( ) ) . append ( str ) . append ( next matcher id ) . append ( str ) . append ( nr lines ) . append ( str ) . append ( nr chars ) . append ( str ) . append ( nr code points ) . append ( str ) . append ( next node id ) . append ( str ) ; writer . append ( sb ) ; writer . flush ( ) ; } }	MUST be called after copyInputText!.
public static void hash ( @ nonnull final instruction group group , @ nonnull final string class name ) { final instruction group hasher group hasher = new instruction group hasher ( group , class name ) ; final string name = group hasher . hash and get name ( ) ; group . set name ( name ) ; }	Generate a hash of the group, use it to name it.
@ cached @ dont label public rule ignore case ( final char c ) { return character . is lower case ( c ) == character . is upper case ( c ) ? ch ( c ) : new char ignore case matcher ( c ) ; }	Match a given character in a case-insensitive manner.
@ cached @ dont label public rule unicode char ( final int code point ) { if ( ! character . is valid code point ( code point ) ) throw new invalid grammar exception ( str + code point ) ; return new code point matcher ( code point ) ; }	Match one Unicode character.
@ cached @ dont label public rule unicode range ( final int low , final int high ) { if ( ! character . is valid code point ( low ) ) throw new invalid grammar exception ( str + low ) ; if ( ! character . is valid code point ( high ) ) throw new invalid grammar exception ( str + high ) ; if ( low > high ) throw new invalid grammar exception ( str + low + str + high ) ; return low == high ? new code point matcher ( low ) : new code point range matcher ( low , high ) ; }	Match a Unicode character range Note that this method will delegate to "regular" character matchers ifpart of, or all of, the specified range is into the basic multilingualplane. .
@ dont label public rule any of ( final string characters ) { objects . require non null ( characters ) ;	Match any of the characters in the given string This method delegates to {.
@ cached @ dont label public rule any of ( final characters characters ) { objects . require non null ( characters ) ; if ( ! characters . is subtractive ( ) && characters . get chars ( ) . length == num ) return ch ( characters . get chars ( ) [ num ] ) ; if ( characters . equals ( characters . none ) ) return nothing ; return new any of matcher ( characters ) ; }	Match any given character among a set of characters Both {.
@ dont label public rule string ( final string string ) { objects . require non null ( string ) ; return string ( string . to char array ( ) ) ; }	Match a string literal.
@ cached @ dont label public rule string ( final char ... characters ) { if ( characters . length == num ) return ch ( characters [ num ] ) ;	Match a given set of characters as a string literal.
@ dont label public rule ignore case ( final string string ) { objects . require non null ( string ) ; return ignore case ( string . to char array ( ) ) ; }	Match a string literal in a case insensitive manner.
@ cached @ dont label public rule optional ( final object rule ) { objects . require non null ( rule ) ; return new optional matcher ( to rule ( rule ) ) ; }	Try and match a rule zero or one time This rule therefore always succeeds. .
@ dont label public rule optional ( final object rule , final object rule2 , final object ... more rules ) { objects . require non null ( more rules ) ; return optional ( sequence ( rule , rule2 , more rules ) ) ; }	Try and match a given set of rules once This rule will therefore never fail. .
@ dont label public final repeat matcher builder < v > repeat ( final object rule , final object rule2 , final object ... more rules ) { objects . require non null ( more rules ) ; return repeat ( sequence ( rule , rule2 , more rules ) ) ; }	Kickstart a repeat rule Like {.
@ dont label public rule zero or more ( final object rule , final object rule2 , final object ... more rules ) { return repeat ( rule , rule2 , more rules ) . min ( num ) ; }	Try and match a set of rules zero or more times This is an alias for {.
@ dont extend protected rule from string literal ( final string string ) { objects . require non null ( string ) ; return from char array ( string . to char array ( ) ) ; }	Convert a string literal to a parser rule.
@ dont extend public rule [ ] to rules ( final object ... objects ) { return arrays . stream ( objects ) . map ( this :: to rule ) . to array ( rule [ ] :: new ) ; }	Convert the given object array to an array of rules.
@ dont extend public rule to rule ( final object obj ) { objects . require non null ( obj ) ; if ( obj instanceof rule ) return ( rule ) obj ; if ( obj instanceof character ) return from char literal ( ( character ) obj ) ; if ( obj instanceof string ) return from string literal ( ( string ) obj ) ; if ( obj instanceof char [ ] ) return from char array ( ( char [ ] ) obj ) ; if ( obj instanceof action ) { final action < ? > action = ( action < ? > ) obj ; return new action matcher ( action ) ; } final string errmsg = obj instanceof boolean ? str : str + obj + str ; throw new invalid grammar exception ( errmsg ) ; }	Converts the given object to a rule.
public boolean push ( final int down , final v value ) { check ( ) ; context . get value stack ( ) . push ( down , value ) ; return bool ; }	Inserts the given value a given number of elements below the current topof the value stack.
public < e extends v > e pop as ( @ nonnull final class < e > c ) { return c . cast ( pop ( ) ) ; }	Removes the value at the top of the value stack and casts it beforereturning it.
public < e extends v > e pop as ( final class < e > c , final int down ) { return c . cast ( pop ( down ) ) ; }	Removes the value the given number of elements below the top of the valuestack and casts it before returning it.
public < e extends v > e peek as ( final class < e > c ) { return c . cast ( peek ( ) ) ; }	Returns and casts the value at the top of the value stack withoutremoving it.
public boolean poke ( final int down , final v value ) { check ( ) ; context . get value stack ( ) . poke ( down , value ) ; return bool ; }	Replaces the element the given number of elements below the current topof the value stack.
@ override public < t > boolean match ( final matcher context < t > context ) { final matcher matcher = context . get matcher ( ) ; final pre match event < t > pre match event = new pre match event < > ( context ) ; bus . post ( pre match event ) ; if ( throwable != null ) throw new grappa exception ( str , throwable ) ;	Internal method. DO NOT USE!.
public boolean overlaps with ( final index range other ) { objects . require non null ( other , str ) ; return end > other . start && other . end > start ; }	Determines whether this range overlaps with the given other one.
public boolean touches ( final index range other ) { objects . require non null ( other , str ) ; return other . end == start || end == other . start ; }	Determines whether this range immediated follows or precedes the given other one.
public index range merged with ( final index range other ) { objects . require non null ( other , str ) ; return new index range ( math . min ( start , other . start ) , math . max ( end , other . end ) ) ; }	Created a new IndexRange that spans all characters between the smallest and the highest index of the two ranges.
public static < p extends base parser < v > , v > byte [ ] get byte code ( final class < p > parser class ) { try { return parser transformer . get byte code ( parser class ) ; } catch ( exception e ) { throw new runtime exception ( str , e ) ; } }	Generate the byte code of a transformed parser class When you create a parser using {.
private void do add word ( final char buffer buffer ) { if ( ! buffer . has remaining ( ) ) { full word = bool ; return ; } final char c = buffer . get ( ) ; trie node builder builder = subnodes . get ( c ) ; if ( builder == null ) { builder = new trie node builder ( ) ; subnodes . put ( c , builder ) ; } builder . do add word ( buffer ) ; }	Add a word Here also, a {.
public static matcher unwrap ( final matcher matcher ) { if ( matcher instanceof proxy matcher ) { final proxy matcher proxy matcher = ( proxy matcher ) matcher ; if ( proxy matcher . dirty ) proxy matcher . apply ( ) ; return proxy matcher . target == null ? proxy matcher : proxy matcher . target ; } return matcher ; }	Retrieves the innermost Matcher that is not a ProxyMatcher.
public final boolean register ( @ nonnull final object listener ) { bus . register ( objects . require non null ( listener ) ) ; return bool ; }	Register a listener to the event bus.
public final boolean post ( @ nonnull final object object ) { objects . require non null ( object ) ; bus . post ( object ) ; return bool ; }	Post an arbitrary, non null, object on the bus.
@ override public < v > matcher context < v > get sub context ( final matcher context < v > context ) { return context . get sub context ( this ) ; }	default implementation is to simply delegate to the context.
public rule min ( final int nr cycles ) { preconditions . check argument ( nr cycles >= num , str + nr cycles + str ) ; return range ( range . at least ( nr cycles ) ) ; }	Return a rule with a minimum number of cycles to run.
public rule max ( final int nr cycles ) { preconditions . check argument ( nr cycles >= num , str + nr cycles + str ) ; return range ( range . at most ( nr cycles ) ) ; }	Return a rule with a maximum number of cycles to run.
public rule times ( final int nr cycles ) { preconditions . check argument ( nr cycles >= num , str + nr cycles + str ) ; return range ( range . singleton ( nr cycles ) ) ; }	Return a rule with an exact number of cycles to run.
public rule times ( final int min cycles , final int max cycles ) { preconditions . check argument ( min cycles >= num , str + min cycles + str ) ; preconditions . check argument ( max cycles >= min cycles , str + min cycles + str + max cycles + str ) ; return range ( range . closed ( min cycles , max cycles ) ) ; }	Return a rule with both lower and upper bounds on the number of cycles Note that the range of cycles to run is closed on both ends (that is,the minimum and maximum number of cycles) are inclusive . .
public static characters all but ( final char ... chars ) { final int length = chars . length ; if ( length == num ) return all ; final char [ ] array = arrays . copy of ( chars , length ) ; arrays . sort ( array ) ; return new characters ( bool , array ) ; }	Creates a new Characters instance containing all characters minus the given ones.
private list < bw > get bw ( ) { list < bw > result = new array list < bw > ( ) ; for ( jaxb < ? extends service type > jaxb element : application . get services ( ) . get base service ( ) ) { if ( jaxb element . get name ( ) . get local part ( ) . equals ( str ) ) { result . add ( ( bw ) jaxb element . get value ( ) ) ; } } return result ; }	This method retrieves the list of objects of type "BWServiceType".
public void add monitoring events to all services ( events events ) { list < jaxb < ? extends event type > > events = events . get event ( ) ; if ( events != null && ! events . is empty ( ) ) { for ( bw service : this . get bw ( ) ) { monitor monitor = service . get monitor ( ) ; if ( monitor != null ) { monitor . set events ( events ) ; } } } }	Add &lt;events> in &lt;monitor> element of all &lt;bw> elements.
public list < global variables . global variable > get global variable ( ) { if ( global variable == null ) { global variable = new array list < global variables . global variable > ( ) ; } return this . global variable ; }	Gets the value of the globalVariable property.
private void check bw ( ) throws mojo execution exception { if ( project directory == null ) { project not found ( ) ; } else if ( ! project directory . exists ( ) || ! project directory . is directory ( ) ) { project not found ( ) ; } }	This will check that the BW project specified in the POM project exists.TODO : add additional checks about BW project integrity.
protected list < dependency > read dependencies from file ( string resolved file name , string dependency type ) throws io { list < dependency > dependencies = new array list < dependency > ( ) ; file resolved file = new file ( resolved file name ) ; if ( ! resolved file . exists ( ) ) { return dependencies ; } file input stream fstream = new file input stream ( resolved file ) ; data input stream ds = new data input stream ( fstream ) ; buffered reader br = new buffered reader ( new input stream reader ( ds ) ) ; pattern p = pattern . compile ( str + dependency type + str ) ;	This will read the dependencies from the 'resolved' file found in thebuild directory.
protected void launch tibco ( file binary , list < file > tras , array list < string > arguments , file working dir , string error msg ) throws io , mojo execution exception { launch tibco ( binary , tras , arguments , working dir , error msg , bool , bool ) ; }	Same as launchTIBCOBinary with 'fork=false' and 'synchronous=true'.
protected boolean clean directory ( file directory ) { if ( directory . is directory ( ) && directory . list files ( ) . length != num ) { for ( file file : directory . list files ( ) ) { if ( file . is file ( ) ) { file . delete ( ) ; } } } return directory . delete ( ) ; }	Delete all file of a directory and then delete this directory.
public java . util . list < string > get final ( ) { if ( final == null ) { final = new array list < string > ( ) ; } return this . final ; }	Gets the value of the final property.
public list < rulebases . rulebase > get rulebase ( ) { if ( rulebase == null ) { rulebase = new array list < rulebases . rulebase > ( ) ; } return this . rulebase ; }	Gets the value of the rulebase property.
private void add alias ( array list < hash map < string , object > > list , string alias name ) { for ( hash map < string , object > h : list ) { string name = ( string ) h . get ( str ) ; if ( name != null && name . equals ( alias name ) ) { return ;	This method add an alias in the object used internally by TIBCOBusinessWorks.
public void process file ( file f ) throws mojo execution exception { try { repository model repository model = new repository model ( f ) ; array list < hash map < string , object > > aliases = read xml ( repository model , f ) ;	This method adds the JAR aliases to a ".aliaslib" file.
public static void add dependency ( file pom , dependency dependency , log logger ) throws io , xml pull parser exception { model model = get model from pom ( pom , logger ) ; model . add dependency ( dependency ) ; write model to pom ( model , pom , logger ) ; }	Add the Maven dependency to a POM file.
public static void remove dependency ( file pom , dependency dependency , log logger ) throws io , xml pull parser exception { model model = get model from pom ( pom , logger ) ; for ( iterator < dependency > it = model . get dependencies ( ) . iterator ( ) ; it . has next ( ) ; ) { if ( dependencies equal ( it . next ( ) , dependency ) ) { it . remove ( ) ; } } write model to pom ( model , pom , logger ) ; }	Remove the Maven dependency from a POM file.
private static boolean dependency exists ( dependency dependency , list < dependency > dependencies ) { for ( dependency d : dependencies ) { if ( dependencies equal ( dependency , d ) ) { return bool ; } } return bool ; }	Check whether a dependency exists in a list of dependencies.
public static boolean dependency exists ( file pom , dependency dependency , log logger ) throws io , xml pull parser exception { model model = get model from pom ( pom , logger ) ; return dependency exists ( dependency , model . get dependencies ( ) ) ; }	Check whether a dependency exists in a POM.
public static void add project as module ( file pom , string relative path , string profile id , log logger ) throws io , xml pull parser exception { if ( relative path == null ) return ; model model = get model from pom ( pom , logger ) ; relative path = relative path . replace ( str , str ) ; if ( profile id != null && ! profile id . is empty ( ) ) { profile p = get profile ( model , profile id ) ; if ( p != null ) { p . add module ( relative path ) ; } } else { model . add module ( relative path ) ; } write model to pom ( model , pom , logger ) ; }	Add a project as a module.
public static boolean module exists ( file pom , string relative path , string profile id , log logger ) throws io , xml pull parser exception { if ( relative path == null ) return bool ; model model = get model from pom ( pom , logger ) ; relative path = relative path . replace ( str , str ) ; if ( profile id != null && ! profile id . is empty ( ) ) { profile p = get profile ( model , profile id ) ; if ( p != null ) { return p . get modules ( ) . index of ( relative path ) >= num ; } } else { return model . get modules ( ) . index of ( relative path ) >= num ; } return bool ; }	Check whether a module exists in a POM.
protected file get artifact file ( file basedir , string final name , string classifier ) { if ( classifier == null ) { classifier = str ; } else if ( classifier . trim ( ) . length ( ) > num && ! classifier . starts with ( str ) ) { classifier = str + classifier ; } return new file ( basedir , final name + classifier + get artifact file extension ( ) ) ; }	Retrieves the full path of the artifact that will be created.
public void execute ( ) throws mojo execution exception { if ( this . resources . size ( ) == num ) { throw new mojo execution exception ( str ) ; }	MOJO execution method.
protected string extract file content ( final string filename ) throws io { final string builder sb = new string builder ( ) ; string temp = str ; final buffered reader buffered reader = new buffered reader ( new file reader ( filename ) ) ; try { while ( temp != null ) { temp = buffered reader . read line ( ) ; if ( temp != null ) { sb . append ( temp ) ; } } return sb . to string ( ) ; } finally { buffered reader . close ( ) ; } }	Reads the complete content of the javaxpath file.
private void update repo instances ( ) { repo instances repo instances = application . get repo instances ( ) ; rv repo instance rv repo instance = repo instances . get rv repo instance ( ) ; rv repo instance . set discovery timout ( big integer . value of ( repo rv discovery timeout ) ) ; rv repo instance . set timeout ( big integer . value of ( repo rv timeout ) ) ; rv repo instance . set daemon ( repo rv daemon ) ; rv repo instance . set service ( repo rv service ) ; rv repo instance . set network ( repo rv network ) ; rv repo instance . set regional subject ( repo rv regional subject ) ; rv repo instance . set operation retry ( big integer . value of ( repo rv operation retry ) ) ; rv repo instance . set extra property file ( repo rv extra property file ) ; rv repo instance . set server ( repo rv server ) ; rv repo instance . set user ( repo rv user ) ; rv repo instance . set password ( repo rv password ) ; http repo instance http repo instance = repo instances . get http repo instance ( ) ; http repo instance . set timeout ( big integer . value of ( repo http timeout ) ) ; http repo instance . set url ( repo http url ) ; http repo instance . set server ( repo http server ) ; http repo instance . set user ( repo http user ) ; http repo instance . set password ( repo http password ) ; http repo instance . set extra property file ( repo http extra property file ) ; local repo instance local repo instance = repo instances . get local repo instance ( ) ; encoding type encoding ; try { encoding = encoding type . value of ( repo local encoding ) ; } catch ( illegal argument exception e ) { encoding = encoding type . utf 8 ; } local repo instance . set encoding ( encoding ) ; repo instances . set rv repo instance ( rv repo instance ) ; repo instances . set http repo instance ( http repo instance ) ; repo instances . set local repo instance ( local repo instance ) ; repo type repo type ; try { repo type = repo type . value of ( repo select instance . to upper case ( ) ) ; } catch ( illegal argument exception e ) { repo type = repo type . local ; } repo instances . set selected ( repo type ) ; }	This will update the &lt;repoInstances> element.
public list < java . lang . object > get any ( ) { if ( any == null ) { any = new array list < java . lang . object > ( ) ; } return this . any ; }	Gets the value of the any property.
private static < t > t new instance ( class < t > clazz , object ... params ) throws sql { try { if ( params == null || params . length == num ) { return clazz . new instance ( ) ; } else { for ( constructor < ? > ctor : clazz . get constructors ( ) ) { if ( ctor . get parameter types ( ) . length != params . length ) { continue ; } int param index = num ; for ( class < ? > param type : ctor . get parameter types ( ) ) { if ( ! param type . is instance ( params [ param index ] ) ) { break ; } param index ++ ; } if ( param index != params . length ) { continue ; } @ suppress warnings ( str ) constructor < t > the ctor = ( constructor < t > ) ctor ; return the ctor . new instance ( params ) ; } throw new sql ( str + clazz ) ; } } catch ( reflective operation exception reflective operation exception ) { throw new sql ( reflective operation exception ) ; } }	Instantiate a new object of type T.
public < t > class < t > create class ( ) { return ( class < t > ) proxy . get proxy class ( get class loader ( ) , get interfaces ( ) ) ; }	Create proxy class.
public < t > constructor < t > create constructor ( ) { try { return this . < t > create class ( ) . get constructor ( invocation handler . class ) ; } catch ( no such method exception no such method exception ) { throw new proxy exception ( no such method exception ) ; } }	Create proxy constructorCreate proxy class.
public timer . context start statement execute timer ( query query ) { ensure sql id ( query ) ; string name = metric naming strategy . get statement execute timer ( query . get sql ( ) , query . get sql id ( ) ) ; return start timer ( name ) ; }	Start Timer when statement is executed.
public timer . context start callable statement life timer ( query query ) { ensure sql id ( query ) ; string name = metric naming strategy . get callable statement life timer ( query . get sql ( ) , query . get sql id ( ) ) ; return start timer ( name ) ; }	Start Timer when callable statement is created.
public timer . context start result set life timer ( query query ) { ensure sql id ( query ) ; string name = metric naming strategy . get result set life timer ( query . get sql ( ) , query . get sql id ( ) ) ; return start timer ( name ) ; }	Start Timer when result set is created.
public void mark result set row meter ( query query ) { ensure sql id ( query ) ; string name = metric naming strategy . get result set row meter ( query . get sql ( ) , query . get sql id ( ) ) ; mark meter ( name ) ; }	Increment when result set row is read.
private < t > t new proxy ( jdbc proxy handler < t > proxy handler ) { return proxy factory . new proxy ( proxy handler , proxy handler . get proxy class ( ) ) ; }	Create a proxy for given JDBC proxy handler.
public connection wrap connection ( connection wrapped connection ) { timer . context life timer context = metric helper . start connection life timer ( ) ; return new proxy ( new connection proxy handler ( wrapped connection , this , life timer context ) ) ; }	Wrap a connection to monitor it.
public statement wrap statement ( statement statement ) { timer . context life timer context = get metric helper ( ) . start statement life timer ( ) ; return new proxy ( new statement proxy handler ( statement , this , life timer context ) ) ; }	Wrap a simple statement to monitor it.
public prepared statement wrap prepared statement ( prepared statement prepared statement , string sql ) { query query = new query ( sql ) ; timer . context life timer context = get metric helper ( ) . start prepared statement life timer ( query ) ; return new proxy ( new prepared statement proxy handler ( prepared statement , this , query , life timer context ) ) ; }	Wrap a prepared statement to monitor it.
public callable statement wrap callable statement ( callable statement callable statement , string sql ) { query query = new query ( sql ) ; timer . context life timer context = get metric helper ( ) . start callable statement life timer ( query ) ; return new proxy ( new callable statement proxy handler ( callable statement , this , query , life timer context ) ) ; }	Wrap a callable statement to monitor it.
private class < ? extends result set > get result set type ( result set result set ) { class < ? extends result set > result set type ; if ( result set instanceof row set ) { if ( result set instanceof cached row set ) { if ( result set instanceof web row set ) { if ( result set instanceof filtered row set ) { result set type = filtered row set . class ; } else if ( result set instanceof join row set ) { result set type = join row set . class ; } else { result set type = web row set . class ; } } else { result set type = cached row set . class ; } } else if ( result set instanceof jdbc row set ) { result set type = jdbc row set . class ; } else { result set type = row set . class ; } } else { result set type = result set . class ; } return result set type ; }	Determine the interface implemented by this result set.
protected string [ ] build args ( ) { string result [ ] = new string [ num ] ; list < string > args = new array list < string > ( ) ; if ( lang != null && lang . length ( ) > num ) { args . add ( flagify ( cowsay cli . opt . lang . to string ( ) ) ) ; args . add ( lang ) ; } if ( html ) { args . add ( flagify ( cowsay cli . opt . html . to string ( ) ) ) ; } if ( alt != null && alt . length ( ) > num ) { args . add ( flagify ( cowsay cli . opt . alt . to string ( ) ) ) ; args . add ( alt ) ; } if ( wrap != null ) { args . add ( flagify ( cowsay cli . opt . wrap at . to string ( ) ) ) ; args . add ( wrap ) ; } build face args ( args ) ; args . add ( message ) ; return args . to array ( result ) ; }	Build an args array that can be passed to cowsay.
private void build face args ( final list < string > args ) { if ( mode != null && cow face . is known mode ( mode ) ) { args . add ( flagify ( mode ) ) ; } else { if ( eyes != null ) { args . add ( flagify ( cowsay cli . opt . eyes . to string ( ) ) ) ; args . add ( eyes ) ; } if ( tongue != null ) { args . add ( flagify ( cowsay cli . opt . tongue . to string ( ) ) ) ; args . add ( tongue ) ; } if ( cowfile != null ) { args . add ( flagify ( cowsay cli . opt . cowfile . to string ( ) ) ) ; args . add ( cowfile ) ; } } }	Face specific flags, either a face mode or face customizations.
public string execute ( ) throws illegal state exception { validate ( ) ; string [ ] args = build args ( ) ; string result ; if ( think ) { result = cowsay . think ( args ) ; } else { result = cowsay . say ( args ) ; } return result ; }	Run cowsay with the provided properties.
@ override public void execute ( ) throws build exception { try { string moo = executor . execute ( ) ; if ( this . property != null && this . property . length ( ) > num ) { get project ( ) . set property ( this . property , moo ) ; } else { system . out . println ( moo ) ; } } catch ( illegal state exception ex ) { throw new build exception ( ex . get message ( ) , ex ) ; } }	Run cowsay with the provided attributes.
public static void set language ( final string language ) { current locale = new locale ( language ) ; messages = resource bundle . get bundle ( str , current locale ) ; }	Set the language.
protected static string get message ( final string key ) { if ( messages == null ) { set language ( default lang ) ; } return messages . get string ( key ) ; }	Get a message in the correct language.
private static string say or think ( final string [ ] args , final boolean think ) { try { boolean is thought = think ; string wordwrap = null ; command line command line = cowsay cli . parse cmd args ( args ) ; if ( command line != null ) { if ( command line . has option ( cowsay cli . opt . help . to string ( ) ) ) { cowsay cli . show cmd line help ( ) ; } else if ( command line . has option ( cowsay cli . opt . list cows . to string ( ) ) ) { string [ ] files = cowloader . list all cowfiles ( ) ; if ( files != null ) { return string utils . join ( files , system . get property ( str ) ) ; } } else { string cowfile spec = null ; cow face cow face = null ; if ( command line . has option ( cowsay cli . opt . wrap at . to string ( ) ) ) { wordwrap = command line . get option value ( cowsay cli . opt . wrap at . to string ( ) ) ; } else if ( command line . has option ( cowsay cli . opt . nowrap . to string ( ) ) ) { wordwrap = str ; } cow face = get cow face by mode ( command line ) ; if ( cow face == null ) {	Do some cowsaying or cowthinking.
private static string format html ( final command line command line , final string plain cow , final string moosage , final boolean is thought ) { string cow = plain cow ; if ( command line . has option ( cowsay cli . opt . html . to string ( ) ) ) { cow = string escape utils . escape html4 ( cow ) ; cow = str + cow + str ; string alt ; if ( command line . has option ( cowsay cli . opt . alt . to string ( ) ) ) { alt = command line . get option value ( cowsay cli . opt . alt . to string ( ) ) ; } else { alt = is thought ? i18n . get message ( str ) : i18n . get message ( str ) ; } string escaped = string escape utils . escape html4 ( moosage ) ; cow += string . format ( alt , escaped ) ; cow += str ; } return cow ; }	May apply HTML markup to the cow, if requested in the command line.
private static cow face get cow face by mode ( final command line command line ) { cow face cow face = null ; set < string > modes = cow face . cow modes . key set ( ) ; for ( string mode : modes ) { if ( command line . has option ( mode ) ) { cow face = cow face . get by mode ( mode ) ; break ; } } return cow face ; }	If a pre-defined cow mode has been set on the command line then use that face.
private static cow face get cow face ( final command line command line ) { cow face cow face ; cow face = new cow face ( ) ; if ( command line . has option ( cowsay cli . opt . eyes . to string ( ) ) ) { cow face . set eyes ( command line . get option value ( cowsay cli . opt . eyes . to string ( ) ) ) ; } if ( command line . has option ( cowsay cli . opt . tongue . to string ( ) ) ) { cow face . set tongue ( command line . get option value ( cowsay cli . opt . tongue . to string ( ) ) ) ; } return cow face ; }	Get a regular cow face optionally formatted with custom eyes and tongue from the command line.
private static string extract cow template ( final string cow ) throws cow parse exception { matcher matcher = cowstart re . matcher ( cow ) ; if ( matcher . find ( num ) ) { string result = matcher . replace first ( str ) ; return result ; } else { throw new cow parse exception ( str + cow ) ; } }	Extracts the ascii art part of the cowfile, removing any before or after PERL comments, variable assignments, weird EOC markers etc.
public static string load ( final string cowfile spec ) { string effective cowfile spec = ( cowfile spec != null ) ? cowfile spec . trim ( ) : default cow ; if ( effective cowfile spec . length ( ) > num ) { if ( ! effective cowfile spec . ends with ( cowfile ext ) ) { effective cowfile spec += cowfile ext ; } input stream cow input stream ; if ( effective cowfile spec . index of ( file . separator char ) >= num ) { cow input stream = get cow from path ( effective cowfile spec ) ; } else { cow input stream = get cow from cow path ( effective cowfile spec ) ; } if ( cow input stream == null ) {	Call this with the provided cowfileSpec - that is the value passed to `-f` on the commandline.
private static string cow input stream to string ( final input stream cow input stream ) { buffered reader reader = new buffered reader ( new input stream reader ( cow input stream ) ) ; string builder sb = new string builder ( ) ; string line ; try { string new line = system . get property ( str ) ; while ( ( line = reader . read line ( ) ) != null ) { sb . append ( line ) ; sb . append ( new line ) ; } reader . close ( ) ; } catch ( io ex ) { logger . get logger ( cowloader . class . get name ( ) ) . log ( level . severe , null , ex ) ; } finally { if ( cow input stream != null ) { try { cow input stream . close ( ) ; } catch ( io ex ) { logger . get logger ( cowloader . class . get name ( ) ) . log ( level . severe , null , ex ) ; } } } return sb . to string ( ) ; }	Reads a cowfile from an InputStream and returns a string.
private static input stream get cow from path ( final string path ) { string cwd = system . get property ( str ) ;	In the case that the cowfileSpec is a filesystem path call this method to attempt to load the cowfile.It will attempt to load the cowfile relative to CWD and if that fails it will try as an absolute path.
private static input stream get cow from cow path ( final string cow name ) { string cow path = system . getenv ( str ) ; if ( cow path != null ) { string [ ] paths = cow path . split ( file . path separator ) ; if ( paths != null ) { for ( string path : paths ) { file cowfile = get cowfile ( path , cow name ) ; if ( cowfile != null ) { return cowfile to cow input stream ( cowfile ) ; } } } } return get cow from resources ( cow name ) ; }	This will attempt to load a cowfile, by name, from the COWPATH environment variable or bundled cowfiles.Note that bundled cowfiles are considered part of the COWPATH since this is how to original `cowsay` worked.COWPATH takes precedence and bundled cowfiles are only considered after searching the COWPATH.
private static boolean is cowfile ( final file cowfile ) { if ( cowfile != null && cowfile . exists ( ) ) { return cowfile . get name ( ) . ends with ( cowfile ext ) ; } return bool ; }	Determine if this File appears to be a genuine cowfile.This is not a deep check, more rigor will be applied later.
private static input stream cowfile to cow input stream ( final file cowfile ) { input stream cow input stream = null ; try { cow input stream = new file input stream ( cowfile ) ; } catch ( file not found exception ex ) { logger . get logger ( cowloader . class . get name ( ) ) . log ( level . severe , null , ex ) ; } return cow input stream ; }	Reads a File to an InputStream.Not sure why I thought this should be a separate method, I guess it made sense at the time.
private static file get cowfile ( final string folder , final string cow name ) { file [ ] cowfiles = get cow files ( folder ) ; for ( file cowfile : cowfiles ) { if ( cowfile . get name ( ) . equals ( cow name ) ) { return cowfile ; } } return null ; }	Get a cowfile, by name, from the given directory.
private static file [ ] get cow files ( final string folder ) { file dir = new file ( folder ) ; file [ ] files ; files = dir . list files ( new filename filter ( ) { @ override public boolean accept ( final file dir , final string name ) { return name . ends with ( str ) ; } } ) ; return files ; }	Gets all cowfiles found in the given directory.
protected static cow face get by mode ( final string mode ) { if ( mode != null ) { return cow modes . get ( mode ) ; } return null ; }	Get cow args by mode.
public final void set eyes ( final string eyes ) { if ( eyes != null && eyes . length ( ) > num ) { if ( eyes . length ( ) > num ) { this . eyes = eyes . substring ( num , num ) ; } else { this . eyes = eyes ; } } }	Set custom cow eyes.
public final void set tongue ( final string tongue ) { if ( tongue != null && tongue . length ( ) > num ) { if ( tongue . length ( ) > num ) { this . tongue = tongue . substring ( num , num ) ; } else { this . tongue = tongue ; } } }	Set custom cow tongue.
public static final boolean is known mode ( final string mode ) { set < string > modes = cow modes . key set ( ) ; return modes . contains ( mode ) ; }	Determine if the given mode flag is known and mapped to a particular cow face.
public static command line parse cmd args ( final string [ ] argv ) { final command line parser cmd line parser = new default parser ( ) ; try { command line parsed = cmd line parser . parse ( options , argv , bool ) ; if ( parsed . has option ( opt . lang . text ) ) { string language = parsed . get option value ( opt . lang . text ) ; if ( language != null ) { i18n . set language ( language ) ; } } return parsed ; } catch ( missing argument exception ex ) { option option = ex . get option ( ) ; string flag = option . get opt ( ) ; if ( flag == null ) { flag = option . get long opt ( ) ; } logger . get logger ( cowsay cli . class . get name ( ) ) . log ( level . info , i18n . get message ( str ) , flag ) ; } catch ( parse exception ex ) { logger . get logger ( cowsay cli . class . get name ( ) ) . log ( level . finest , null , ex ) ; } return null ; }	Parses an array of arguments.
public static void show cmd line help ( ) { help formatter formatter = new help formatter ( ) ; update option descriptions ( ) ; formatter . print help ( i18n . get message ( str ) , options ) ; }	Displays help message to user.
private static string format bubble ( final bubble wrap bubble , final string message , final int longest line ) { string new line = system . get property ( str ) ; string [ ] lines = message . split ( new line ) ; string builder sb = new string builder ( ) ; sb . append ( bubble . build top ( longest line ) ) ; if ( lines . length > num ) { sb . append ( bubble . format multi open ( lines [ num ] , longest line ) ) ; for ( int i = num ; i < ( lines . length - num ) ; i ++ ) { sb . append ( bubble . format multi mid ( lines [ i ] , longest line ) ) ; } sb . append ( bubble . format multi end ( lines [ ( lines . length - num ) ] , longest line ) ) ; } else { sb . append ( bubble . format single ( lines [ num ] ) ) ; } sb . append ( bubble . build bottom ( longest line ) ) ; return sb . to string ( ) ; }	Draws a complete bubble around a line-wrapped message.
private string wrap message ( final string message ) {	Applies word wrapping to the message to handle long lines.
private string format message ( final string message ) { string result ; if ( message != null ) { result = wrap message ( message ) ; int longest line = get longest line len ( result ) ; if ( ! is thought ) { result = bubble . format speech ( result , longest line ) ; } else { result = bubble . format thought ( result , longest line ) ; } return result ; } return str ; }	Builds the bubble around the message.
public void set wordwrap ( final string wordwrap ) { try { int ww = integer . parse int ( wordwrap ) ; if ( ww >= num ) { this . wordwrap = ww ; } } catch ( throwable ignore ) {	Set the length of the wordwrap, default is "40", zero disables line-wrap.
private static int get longest line len ( final string message ) { string new line = system . get property ( str ) ; string [ ] lines = message . split ( new line ) ; int max len = num ; for ( string line : lines ) { max len = math . max ( max len , line . length ( ) ) ; } return max len ; }	For a given multiline message determines the character count of the longest line.
public boolean log ( string message ) { if ( message == null ) return bool ; boolean ok ; try { ok = loggly . log ( token , tags , message ) . is executed ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; ok = bool ; } return ok ; }	Posts a log message to Loggly.
public void log ( string message , final callback callback ) { if ( message == null ) return ; loggly . log ( token , tags , message , new retrofit2 . callback < loggly response > ( ) { @ override public void on response ( call < loggly response > call , response < loggly response > response ) { callback . success ( ) ; } @ override public void on failure ( call < loggly response > call , throwable throwable ) { callback . failure ( throwable . get message ( ) ) ; } } ) ; }	Posts a log message asynchronously to Loggly.
public void log bulk ( collection < string > messages , final callback callback ) { if ( messages == null ) return ; string parcel = join strings ( messages ) ; if ( parcel . is empty ( ) ) return ; loggly . log bulk ( token , tags , parcel , new retrofit2 . callback < loggly response > ( ) { @ override public void on response ( call < loggly response > call , response < loggly response > response ) { callback . success ( ) ; } @ override public void on failure ( call < loggly response > call , throwable throwable ) { callback . failure ( throwable . get message ( ) ) ; } } ) ; }	Posts several log messages in bulk to Loggly asynchronously.
private string join strings ( collection < string > messages ) { string builder b = new string builder ( ) ; for ( string s : messages ) { if ( s == null || s . is empty ( ) ) { continue ; }	Combines a collection of messages to be sent to Loggly.In order to preserve event boundaries, the new lines ineach message are replaced with '\r', which get strippedby Loggly.
public sorted map < string , schema > get schemas ( ) throws sql { synchronized ( get schemas lock ) { if ( get schemas cache == null ) { sorted map < string , schema > new schemas = new tree map < > ( database meta data . get collator ( ) ) ; try ( result set results = meta data . get meta data ( ) . get schemas ( ) ) { result set meta data results meta = results . get meta data ( ) ; while ( results . next ( ) ) { int col count = results meta . get column count ( ) ;	Gets all schemas for this catalog keyed by unique name.
public schema get schema ( string name ) throws no row exception , sql { schema schema = get schemas ( ) . get ( name ) ; if ( schema == null ) throw new no row exception ( str + name ) ; return schema ; }	Gets the schema of the provided name.
@ override public void context initialized ( servlet context event sce ) { try { servlet context sc ; synchronized ( servlet context lock ) { servlet context = sce . get servlet context ( ) ; sc = servlet context ; }	Set to null when context shutdown.
private void resync ( ) throws io { path gtl ; synchronized ( git toplevel lock ) { gtl = git toplevel ; } watch service w ; synchronized ( watcher lock ) { w = watcher ; } if ( gtl != null && w != null ) { synchronized ( registered ) { set < path > extra keys = new hash set < > ( registered . key set ( ) ) ; resync ( w , gtl , extra keys ) ; for ( path extra key : extra keys ) { if ( debug ) log ( str + extra key ) ; registered . remove ( extra key ) . cancel ( ) ; } } } }	Resyncs the entire directory recursively, registering and canceling anydiscrepancies found.
public sorted map < string , table > get tables ( ) throws sql { synchronized ( get tables lock ) { if ( get tables cache == null ) { sorted map < string , table > new tables = new tree map < > ( database meta data . get collator ( ) ) ; try ( result set results = catalog . get meta data ( ) . get meta data ( ) . get tables ( catalog . get name ( ) , name , null , null ) ) { while ( results . next ( ) ) { table new table = new table ( this , results . get string ( str ) , results . get string ( str ) ) ; if ( new tables . put ( new table . get name ( ) , new table ) != null ) throw new assertion error ( str + new table ) ; } } get tables cache = ao collections . optimal unmodifiable sorted map ( new tables ) ; } return get tables cache ; } }	Gets all tables for this schema keyed by unique name.
public table get table ( string name ) throws no row exception , sql { table table = get tables ( ) . get ( name ) ; if ( table == null ) throw new no row exception ( ) ; return table ; }	Gets the table of the provided name.
private void write to impl ( writer out , long write start , long write end ) throws io { try (	Implementation of writeTo.
public sorted map < string , catalog > get catalogs ( ) throws sql { synchronized ( get catalogs lock ) { if ( get catalogs cache == null ) { sorted map < string , catalog > new catalogs = new tree map < > ( english collator ) ; try ( result set results = meta data . get catalogs ( ) ) { while ( results . next ( ) ) { catalog new catalog = new catalog ( this , results . get string ( num ) ) ; if ( new catalogs . put ( new catalog . get name ( ) , new catalog ) != null ) throw new assertion error ( str + new catalog ) ; } } get catalogs cache = ao collections . optimal unmodifiable sorted map ( new catalogs ) ; } return get catalogs cache ; } }	Gets all catalogs for this database keyed by unique name.
public catalog get catalog ( string name ) throws no row exception , sql { catalog catalog = get catalogs ( ) . get ( name ) ; if ( catalog == null ) throw new no row exception ( ) ; return catalog ; }	Gets the catalog of the provided name.
private char [ ] get buffer ( int additional ) throws io { long new len = ( long ) length + additional ; if ( new len > max length ) throw new io ( str + max length + str + new len + str ) ; char [ ] buf = this . buffer ; int buf len = buf . length ; if ( new len > buf len ) {	Grows as-needed to fit the provided new capacity.
private void log ( encoder encoder ) throws io { if ( encoder == null ) log . write ( str ) ; else { string class name = encoder . get class ( ) . get name ( ) ;	Provides detailed logging for a media encoder.
private void log ( writer writer ) throws io { if ( writer == null ) { log . write ( str ) ; } else if ( writer instanceof logging writer ) { logging writer logging writer = ( logging writer ) writer ; log . write ( str ) ; log . write ( long . to string ( logging writer . get id ( ) ) ) ; log . write ( str ) ; } else if ( writer instanceof encoder writer ) { encoder writer encoder writer = ( encoder writer ) writer ; log . write ( str ) ; log ( encoder writer . get encoder ( ) ) ; log . write ( str ) ; log ( encoder writer . get out ( ) ) ; log . write ( str ) ; } else { string classname = writer . get class ( ) . get name ( ) ; if ( classname . equals ( str ) ) log . write ( str ) ; else if ( classname . equals ( str ) ) log . write ( str ) ; else log . write ( classname ) ; } }	Provides detailed logging for a writer.
public static < f > lexical position < f > zero with file ( final f file ) { return lexical position . of ( num , num , optional . of ( file ) ) ; }	Construct a lexical position at line 0, column 0, with the given file.
private void append ( int segment index , int off , int len , string builder buffer ) { switch ( segment types [ segment index ] ) { case segmented writer . type string : buffer . append ( ( string ) segment values [ segment index ] , off , off + len ) ; break ; case segmented writer . type char newline : assert off == num ; assert len == num ; buffer . append ( str ) ; break ; case segmented writer . type char quote : assert off == num ; assert len == num ; buffer . append ( str ) ; break ; case segmented writer . type char apos : assert off == num ; assert len == num ; buffer . append ( str ) ; break ; case segmented writer . type char other : assert off == num ; assert len == num ; buffer . append ( ( ( character ) segment values [ segment index ] ) . char value ( ) ) ; break ; default : throw new assertion error ( ) ; } }	Appends the given range of a segment.
private void write segment ( int segment index , int off , int len , encoder encoder , writer out ) throws io { switch ( segment types [ segment index ] ) { case segmented writer . type string : encoder . write ( ( string ) segment values [ segment index ] , off , len , out ) ; break ; case segmented writer . type char newline : assert off == num ; assert len == num ; encoder . write ( str , out ) ; break ; case segmented writer . type char quote : assert off == num ; assert len == num ; encoder . write ( str , out ) ; break ; case segmented writer . type char apos : assert off == num ; assert len == num ; encoder . write ( str , out ) ; break ; case segmented writer . type char other : assert off == num ; assert len == num ; encoder . write ( ( character ) segment values [ segment index ] , out ) ; break ; default : throw new assertion error ( ) ; } }	Writes the given range of a segment to the given writer using the given encoder.
private static char char at ( byte type , object value , int char index ) { switch ( type ) { case segmented writer . type string : return ( ( string ) value ) . char at ( char index ) ; case segmented writer . type char newline : assert char index == num ; return str ; case segmented writer . type char quote : assert char index == num ; return str ; case segmented writer . type char apos : assert char index == num ; return str ; case segmented writer . type char other : assert char index == num ; return ( character ) value ; default : throw new assertion error ( ) ; } }	Gets the character at the given index in a segment.This is the absolute index, the offset is not added-in.
private map < string , class < ? > > get sql data types ( ) throws sql { if ( sql data types == null ) {	Loads the custom types when first needed and caches the results.
public sorted map < string , column > get column map ( ) throws sql { synchronized ( get column map lock ) { if ( get column map cache == null ) { sorted map < string , column > new column map = new tree map < > ( database meta data . get collator ( ) ) ; try ( result set results = schema . get catalog ( ) . get meta data ( ) . get meta data ( ) . get columns ( schema . get catalog ( ) . get name ( ) , schema . get name ( ) , name , null ) ) { while ( results . next ( ) ) { column new column = new column ( this , results . get string ( str ) , results . get int ( str ) , results . get string ( str ) , get integer ( results , str ) , get integer ( results , str ) , results . get int ( str ) , results . get string ( str ) , get integer ( results , str ) , results . get int ( str ) , results . get string ( str ) , results . get string ( str ) ) ; if ( new column map . put ( new column . get name ( ) , new column ) != null ) throw new assertion error ( str + new column ) ; } } get column map cache = ao collections . optimal unmodifiable sorted map ( new column map ) ; } return get column map cache ; } }	Gets all columns for this schema keyed by unique name.
public column get column ( string name ) throws no row exception , sql { column column = get column map ( ) . get ( name ) ; if ( column == null ) throw new no row exception ( ) ; return column ; }	Gets the column of the provided name.
public list < column > get columns ( ) throws sql { synchronized ( get columns lock ) { if ( get columns cache == null ) { sorted map < string , column > column map = get column map ( ) ; list < column > new columns = new array list < > ( column map . size ( ) ) ; for ( int i = num ; i < column map . size ( ) ; i ++ ) new columns . add ( null ) ; for ( column column : column map . values ( ) ) { int ordinal position = column . get ordinal position ( ) ; if ( new columns . set ( ordinal position - num , column ) != null ) throw new sql ( str + ordinal position ) ; } for ( int i = num ; i < new columns . size ( ) ; i ++ ) { if ( new columns . get ( i ) == null ) throw new sql ( str + ( i + num ) ) ; } get columns cache = ao collections . optimal unmodifiable list ( new columns ) ; } return get columns cache ; } }	Gets all columns for this schema in their ordinal position order.Column with ordinal position one is at index zero.
public column get column ( int ordinal position ) throws no row exception , sql { try { return get columns ( ) . get ( ordinal position - num ) ; } catch ( index out of bounds exception exc ) { throw new no row exception ( exc ) ; } }	Gets the column of the provided ordinal position, where positions start at one.
public set < ? extends table > get imported tables ( ) throws sql { synchronized ( get imported tables lock ) { if ( get imported tables cache == null ) { set < table > new imported tables = new linked hash set < > ( ) ; catalog catalog = schema . get catalog ( ) ; database meta data meta data = catalog . get meta data ( ) ; try ( result set results = schema . get catalog ( ) . get meta data ( ) . get meta data ( ) . get imported keys ( schema . get catalog ( ) . get name ( ) , schema . get name ( ) , name ) ) { while ( results . next ( ) ) { string pk cat = results . get string ( str ) ; catalog pk catalog = pk cat == null ? catalog : meta data . get catalog ( pk cat ) ; new imported tables . add ( pk catalog . get schema ( results . get string ( str ) ) . get table ( results . get string ( str ) ) ) ; } } get imported tables cache = ao collections . optimal unmodifiable set ( new imported tables ) ; } return get imported tables cache ; } }	Gets the set of tables that this table depends on.This is based on getImportedKeys.
public set < ? extends table > get exported tables ( ) throws sql { synchronized ( get exported tables lock ) { if ( get exported tables cache == null ) { set < table > new exported tables = new linked hash set < > ( ) ; catalog catalog = schema . get catalog ( ) ; database meta data meta data = catalog . get meta data ( ) ; try ( result set results = schema . get catalog ( ) . get meta data ( ) . get meta data ( ) . get exported keys ( schema . get catalog ( ) . get name ( ) , schema . get name ( ) , name ) ) { while ( results . next ( ) ) { string fk cat = results . get string ( str ) ; catalog fk catalog = fk cat == null ? catalog : meta data . get catalog ( fk cat ) ; new exported tables . add ( fk catalog . get schema ( results . get string ( str ) ) . get table ( results . get string ( str ) ) ) ; } } get exported tables cache = ao collections . optimal unmodifiable set ( new exported tables ) ; } return get exported tables cache ; } }	Gets the set of tables that depend on this table.This is based on getExportedKeys.
private void add segment ( byte type , object value , int off , int len ) { assert ! is closed ; assert len > num : str ; final int arraylen = segment values . length ; if ( segment count == arraylen ) {	Adds a new segment.
private void log ( char ch ) throws io { if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch < str ) { log . write ( str ) ; string hex = integer . to hex string ( ch ) ; for ( int l = hex . length ( ) ; l < num ; l ++ ) log . write ( str ) ; log . write ( hex ) ; log . write ( str ) ; } else { log . write ( str ) ; log . write ( ch ) ; log . write ( str ) ; } }	Writes a character, unicode escaping as needed.
private void log ( string value ) throws io { if ( value == null ) { log . write ( str ) ; } else { log . write ( str ) ; for ( int i = num , len = value . length ( ) ; i < len ; i ++ ) { char ch = value . char at ( i ) ; if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch == str ) log . write ( str ) ; else if ( ch < str ) { log . write ( str ) ; string hex = integer . to hex string ( ch ) ; for ( int l = hex . length ( ) ; l < num ; l ++ ) log . write ( str ) ; log . write ( hex ) ; } else { log . write ( ch ) ; } } log . write ( str ) ; } }	Writes a String, unicode escaping as needed.
public void move camera to last location ( google map map , float zoom ) { m provider . get last location ( ) . subscribe ( location -> map . move camera ( camera update factory . new lat lng zoom ( new lat lng ( location . get latitude ( ) , location . get longitude ( ) ) , zoom ) ) ) ; }	Move and zoom to the most recently reported location.
public void animate camera to include position ( google map map , lat lng position , long delay ) { if ( ! map . get projection ( ) . get visible region ( ) . lat lng bounds . contains ( position ) ) { if ( delay > num ) { new handler ( looper . get main looper ( ) ) . post delayed ( ( ) -> do animate camera to include position ( map , position ) , delay ) ; } else { do animate camera to include position ( map , position ) ; } } }	If the position is not visible on the map, animate the camera to include it, after the delay.
public static animator circle to rect ( view circle , view rect ) { return circle rect ( circle , rect , bool ) ; }	Get an Animator that reveals the rectangular View from the circular View.
public static animator circle from rect ( view circle , view rect ) { return circle rect ( circle , rect , bool ) ; }	Get an Animator that "unreveals" the rectangular View to the circular View.
public static transition arc motion ( context context ) { if ( s arc == null ) { s arc = transition inflater . from ( context ) . inflate transition ( r . transition . sprockets arc motion ) ; } return s arc ; }	Get a cached arc motion transition.
public static style span bold ( int i ) { if ( s bolds == null ) { s bolds = new array list < > ( ) ; s bolds . add ( bold ( ) ) ; } if ( i < s bolds . size ( ) ) { return s bolds . get ( i ) ; } else { style span bold = new style span ( typeface . bold ) ; s bolds . add ( bold ) ; return bold ; } }	Get a cached bold span.
public static view property animator scale in ( view view ) { return scale ( view , num , enter screen ( ) , r . integer . anim duration enter ) ; }	Scale in the View to full size.
public static view property animator scale out ( view view ) { return scale ( view , num , exit screen ( ) , r . integer . anim duration exit ) ; }	Scale out the View to zero size.
public static view property animator scale show next ( view switcher view , runnable end action ) { return scale ( view , view :: show next , end action ) ; }	Scale out the ViewSwitcher, show the next View, scale it back in, and run the action.
public static int get count ( context context , uri uri ) { string [ ] proj = { str } ; return cursors . first int ( context . get content resolver ( ) . query ( uri , proj , null , null , null ) ) ; }	Get the number of rows at the URI.
public static string concat address lines ( address address , string delimiter ) { string builder s = new string builder ( num ) ; for ( int i = num , max = address . get max address line index ( ) ; i <= max ; i ++ ) { if ( i > num ) { s . append ( delimiter ) ; } s . append ( address . get address line ( i ) ) ; } return s . to string ( ) ; }	Get a single line address which uses the delimiter between the original lines.
public static google api client connect ( google api client client , connected listener connected , on connection failed listener failed ) { client . register connection callbacks ( new connection listener ( connected ) ) ; client . register connection failed listener ( failed ) ; client . connect ( ) ; return client ; }	Register the listeners and then connect the client.
@ suppress lint ( str ) private static fragment transaction transit ( fragment manager fm , int transit ) { return fm != null ? fm . begin transaction ( ) . set transition ( transit ) : null ; }	Begin a transaction that uses the transition.
@ override public int get foreground color ( ) { return color . argb ( m alpha , color . red ( m color ) , color . green ( m color ) , color . blue ( m color ) ) ; }	Get the result of applying the alpha to the color.
public static void set on click listeners ( on click listener listener , view ... views ) { for ( view view : views ) { view . set on click listener ( listener ) ; } }	Set the listener on all of the Views.
public static string get level name ( int level ) { switch ( level ) { case verbose : return str ; case debug : return str ; case info : return str ; case warn : return str ; case error : return str ; case assert : return str ; default : return str ; } }	Get the name of the level.
public static activity options make scale up animation ( view source ) { return activity options . make scale up animation ( source , num , num , source . get width ( ) , source . get height ( ) ) ; }	Scale the new Activity from the View to its full size.
public static void show ( view view ) { view . post delayed ( ( ) -> managers . input method ( view . get context ( ) ) . show soft input ( view , num ) , num ) ;	Show the current input method for the focused View which can receive input.
public static void hide ( view view ) { managers . input method ( view . get context ( ) ) . hide soft input from window ( view . get window token ( ) , num ) ; }	Hide the input method for the View's window.
public static boolean has position ( cursor cursor , int position ) { return ! cursor . is closed ( ) && position >= num && position < cursor . get count ( ) ; }	True if the cursor has a row at the position.
public static int count ( cursor cursor , boolean close ) { int count = cursor . get count ( ) ; close ( cursor , close ) ; return count ; }	Get the number of rows in the cursor.
public static int first int ( cursor cursor , boolean close ) { int i = cursor . move to first ( ) ? cursor . get int ( num ) : integer . min value ; close ( cursor , close ) ; return i ; }	Get the int value in the first row and column.
public static long first long ( cursor cursor , boolean close ) { long l = cursor . move to first ( ) ? cursor . get long ( num ) : long . min value ; close ( cursor , close ) ; return l ; }	Get the long value in the first row and column.
@ nullable public static string first string ( cursor cursor , boolean close ) { string s = cursor . move to first ( ) ? cursor . get string ( num ) : null ; close ( cursor , close ) ; return s ; }	Get the String value in the first row and column.
public static int [ ] all ints ( cursor cursor , boolean close ) { int [ ] i = empty int array ; if ( cursor . move to first ( ) ) { i = new int [ cursor . get count ( ) ] ; do { i [ cursor . get position ( ) ] = cursor . get int ( num ) ; } while ( cursor . move to next ( ) ) ; } close ( cursor , close ) ; return i ; }	Get all int values in the first column.
public static long [ ] all longs ( cursor cursor , boolean close ) { long [ ] l = empty long array ; if ( cursor . move to first ( ) ) { l = new long [ cursor . get count ( ) ] ; do { l [ cursor . get position ( ) ] = cursor . get long ( num ) ; } while ( cursor . move to next ( ) ) ; } close ( cursor , close ) ; return l ; }	Get all long values in the first column.
public static string [ ] all strings ( cursor cursor , boolean close ) { string [ ] s = empty string array ; if ( cursor . move to first ( ) ) { s = new string [ cursor . get count ( ) ] ; do { s [ cursor . get position ( ) ] = cursor . get string ( num ) ; } while ( cursor . move to next ( ) ) ; } close ( cursor , close ) ; return s ; }	Get all String values in the first column.
@ binding adapter ( value = { str , str , str , str } , require all = bool ) public static void load ( image view view , drawable placeholder , uri load , boolean resize , string transform ) { request creator req = picasso . with ( view . get context ( ) ) . load ( load ) . placeholder ( placeholder ) ; if ( resize ) { req . fit ( ) . center crop ( ) ;	Set a placeholder before loading an image, optionally resizing and transforming it.
public static int get orientation ( recycler view view ) { layout manager layout = view . get layout manager ( ) ; if ( layout instanceof linear layout manager ) { return ( ( linear layout manager ) layout ) . get orientation ( ) ; } else if ( layout instanceof staggered grid layout manager ) { return ( ( staggered grid layout manager ) layout ) . get orientation ( ) ; } return - num ; }	Get the orientation of the RecyclerView's LayoutManager.
public static int get span count ( recycler view view ) { layout manager layout = view . get layout manager ( ) ; if ( layout != null ) { if ( layout instanceof grid layout manager ) { return ( ( grid layout manager ) layout ) . get span count ( ) ; } else if ( layout instanceof staggered grid layout manager ) { return ( ( staggered grid layout manager ) layout ) . get span count ( ) ; } return num ;	Get the number of spans laid out by the RecyclerView's LayoutManager.
public static relative layout . layout params add rule ( view view , int verb , int anchor ) { relative layout . layout params params = get params ( view ) ; params . add rule ( verb , anchor ) ; view . request layout ( ) ; return params ; }	Add the rule to the View's RelativeLayout params and request a layout of the View.
public boolean was read ( ) { int pos = get position ( ) ; if ( pos < num || pos >= m read . length ) { return bool ; } boolean read = m read [ pos ] ; if ( ! read ) { m read [ pos ] = bool ; } return read ; }	True if this method has been previously called for the current row.
public static looper mine or main ( ) { looper looper = looper . my looper ( ) ; return looper != null ? looper : looper . get main looper ( ) ; }	Get this thread's Looper, if it's a Looper thread.
@ suppress warnings ( str ) public static < e > list < e > values ( sparse array < e > array ) { return ( list < e > ) values ( array , null , null , null , null ) ; }	Get the values of the SparseArray.
@ suppress warnings ( str ) public static < e > list < e > values ( long sparse array < e > array ) { return ( list < e > ) values ( null , null , null , null , array ) ; }	Get the values of the LongSparseArray.
private void check adapter ( ) { pager adapter adapter = m pager . get adapter ( ) ; if ( m adapter != adapter ) { if ( m adapter != null ) { m adapter . unregister data set observer ( m observer ) ; } m adapter = adapter ; if ( m adapter != null ) { m adapter . register data set observer ( m observer ) ; } reset ( ) ; } }	Check if the pager has a new adapter and switch to it if it does.
private void check drawable ( ) { drawable drawable = m view . get drawable ( ) ; if ( m drawable != drawable ) { m view width = m view . get width ( ) ; m view height = m view . get height ( ) ; if ( m view width > num && m view height > num ) { m drawable = drawable ;	Check if the ImageView has a new Drawable and calculate the new scaling if it does.
private void update matrix ( int position , float offset ) { if ( m drawable != null && m scale > num ) { if ( m page count == - num && m adapter != null ) {	Scale the image and translate it according to the pager position and offset.
private int upd del ( int op , uri uri , content values vals , string sel , string [ ] args ) { sql sql = elements ( op , uri , new string [ ] { str } , sel , args , null ) ; long [ ] ids = cursors . all longs ( sql . m result ) ; sq db = m helper . get writable database ( ) ; int rows = op == update ? db . update ( sql . table ( ) , vals , sql . sel ( ) , sql . args ( ) ) : db . delete ( sql . table ( ) , ! text utils . is empty ( sql . sel ( ) ) ? sql . sel ( ) : str , sql . args ( ) ) ; if ( rows > num ) { for ( long id : ids ) { notify change ( content uris . with appended id ( sql . notify uri ( ) , id ) , uri ) ; } } return rows ; }	Update or delete records and get the number of rows affected.
private sql elements ( int op , uri uri , string [ ] proj , string sel , string [ ] args , string order ) { mutable sql sql = translate ( uri ) ; if ( sql == null ) { sql = sql . create ( ) ; } if ( sql . table ( ) == null ) { sql . table ( uri . get path segments ( ) . get ( num ) ) ; } if ( sql . notify uri ( ) == null && op != select ) { sql . notify uri ( uri . build upon ( ) . path ( sql . table ( ) ) . clear query ( ) . fragment ( null ) . build ( ) ) ; } if ( op != insert ) {	Get the updated SQL elements for the URI and, when not inserting, a cursor with the queryresults.
public static int get byte count ( int width , int height , config config ) { int bytes = num ; switch ( config ) { case alpha 8 : bytes = num ; break ; case rgb 565 : bytes = num ; break ; case argb 4444 : bytes = num ; break ; case argb 8888 : bytes = num ; break ; } return width * height * bytes ; }	Get the number of bytes that would be used to store a bitmap with the size, in pixels, andstorage config.
@ nullable public static bitmap mutable ( bitmap source ) { if ( source . is mutable ( ) ) { return source ; } config config = source . get config ( ) ; bitmap bm = source . copy ( config != null ? config : argb 8888 , bool ) ; if ( bm != null ) { source . recycle ( ) ; } return bm ; }	If the bitmap is immutable, get a mutable copy of it.
public static boolean has activity ( context context , intent intent ) { return context . get package manager ( ) . resolve activity ( intent , match default only ) != null ; }	True if the Intent can be resolved to an Activity.
public static intent mailto ( list < string > to , list < string > cc , list < string > bcc , string subject , string body ) { return new intent ( action sendto , uris . mailto ( to , cc , bcc , subject , body ) ) ; }	Get an Activity Intent that launches an email app with the headers.
public void set default content view ( ) { set content view ( r . layout . sprockets panes , r . id . panes , r . id . pane1 , r . id . pane2 ) ; }	Use the default layout for the panes.
@ nullable @ suppress warnings ( str ) public < t extends fragment > t find fragment by pane ( @ int range ( from = num , to = num ) int pane ) { string tag = elements . get ( s panes , pane - num ) ; return tag != null ? ( t ) get fragment manager ( ) . find fragment by tag ( tag ) : null ; }	Get the fragment that is displayed in the pane.
public static bundle of ( string key1 , int value1 , string key2 , int value2 ) { bundle b = new bundle ( num ) ; b . put int ( key1 , value1 ) ; b . put int ( key2 , value2 ) ; return b ; }	Get a Bundle of the keys and values.
public static intent new intent ( context context , string action , uri data , content values values ) { return new intent ( context , action , data , values , null , null ) ; }	Get an Intent to insert or update rows of the content.
public static intent new update intent ( context context , uri data , content values values , string selection , string [ ] selection args ) { return new intent ( context , action edit , data , values , selection , selection args ) ; }	Get an Intent to update the selected rows of the content.
public static intent new delete intent ( context context , uri data ) { return new intent ( context , action delete , data , null , null , null ) ; }	Get an Intent to delete rows of the content.
public static intent new delete intent ( context context , uri data , string selection , string [ ] selection args ) { return new intent ( context , action delete , data , null , selection , selection args ) ; }	Get an Intent to delete the selected rows of the content.
public static int get action bar size ( context context ) { typed array a = context . obtain styled attributes ( s action bar size ) ; int size = a . get dimension pixel size ( num , num ) ; a . recycle ( ) ; return size ; }	Get the ActionBar height in the Context's theme.
@ nullable public static drawable get action bar background ( context context ) { int [ ] attrs = { android . r . attr . action bar style } ; typed array a = context . obtain styled attributes ( attrs ) ; int id = a . get resource id ( num , num ) ; a . recycle ( ) ; if ( id > num ) { attrs [ num ] = android . r . attr . background ; a = context . obtain styled attributes ( id , attrs ) ; drawable background = a . get drawable ( num ) ; a . recycle ( ) ; return background ; } return null ; }	Get the ActionBar background in the Context's theme.
public static boolean is connected ( context context ) { network info info = managers . connectivity ( context ) . get active network info ( ) ; return info != null && info . is connected ( ) ; }	True if a data network is connected.
public void diff cleanup efficiency ( linked list < diff > diffs ) { if ( diffs . is empty ( ) ) { return ; } boolean changes = bool ; stack < diff > equalities = new stack < diff > ( ) ;	Reduce the number of edits by eliminating operationally trivial equalities.
public linked list < patch > patch make ( string text1 , linked list < diff > diffs ) { if ( text1 == null || diffs == null ) { throw new illegal argument exception ( str ) ; } linked list < patch > patches = new linked list < patch > ( ) ; if ( diffs . is empty ( ) ) { return patches ;	Compute a list of patches to turn text1 into text2.text2 is not provided, diffs are the delta between text1 and text2.
@ override public < r > option < r > flat map ( throwable function1 < t , option < r > > function ) { try { return function . apply ( value ) ; } catch ( throwable ex ) { throw new broken function exception ( str , ex ) ; } }	Returns an Option consisting of the result of applying the given function to the current value.
string convert soap message as string ( soap soap message ) { if ( soap message == null ) { return str ; } try { byte array output stream os = new byte array output stream ( ) ; soap message . write to ( os ) ; return new string ( os . to byte array ( ) , determine message encoding ( soap message ) ) ; } catch ( exception e ) { logger . error ( str + soap message . to string ( ) ) ; return str ; } }	Converts a SOAPMessage instance to string representation.
protected static synchronized file object wrapper get or create profile properties ( final filer filer , string file name ) throws io { file object wrapper file object = tracee profile properties . get ( file name ) ; if ( file object == null ) { file object = new file object wrapper ( filer . create resource ( standard location . source output , str , file name , null ) ) ; tracee profile properties . put ( file name , file object ) ; } return file object ; }	Central method to get cached FileObjectWrapper. Creates new FileObjectWrapper if it can't be found.
protected boolean is valid method ( element element ) {	Checks if passed element is a method declared as public, not abstract and not static.
protected boolean is getter method ( executable element executable element ) {	Checks if passed element has a non void return type and takes no parameters.
public boolean get property value ( final string property key ) { if ( property key == null ) { return null ; }	Checks whether the property for the passed key is enabled or not.
protected boolean check if class has noargs constructor ( type element type element ) {	Checks if class has noargs constructor or default noargs constructor.
public static < t extends annotation > t get annotation from type ( final object instance , class < t > annotation ) { if ( instance == null || annotation == null ) { return null ; } return instance . get class ( ) . get annotation ( annotation ) ; }	Gets an annotation of passed instance.
public static boolean check method has non void return type ( final method method ) { if ( method == null ) { return bool ; } try { return ! ( void . type == method . get return type ( ) ) ; } catch ( exception e ) { return bool ; } }	Checks whether the passsed method has a non void return value.
public boolean apply ( final string builder string builder , final output style output style , final output element output element ) { boolean result = bool ; if ( output element != null ) { if ( output element type . collection . equals ( output element . get output element type ( ) ) ) { result = handle collection type ( string builder , output style , output element ) ; } else if ( output element type . complex . equals ( output element . get output element type ( ) ) ) { if ( tracee context log annotation utilities . get annotation from type ( output element . get encapsulated instance ( ) ) != null ) { result = handle tracee contextprovider ( string builder , output style , output element ) ; } else { result = handle complex type ( string builder , output style , output element ) ; } } } return result ; }	Write the type string to the Stringbuilder.
public static set < class > find wrapper classes ( ) { final list < type to wrapper > local type to wrapper list = get type to wrapper ( ) ; set < class > result list = new hash set < class > ( ) ; if ( local type to wrapper list != null ) { for ( type to wrapper type to wrapper : local type to wrapper list ) { result list . add ( type to wrapper . get wrapper type ( ) ) ; } } return result list ; }	Gets a list with all wrapper classes.
public static set < implicit context data > get implicit context data providers ( ) { final set < implicit context data > result = new hash set < implicit context data > ( ) ; for ( class clazz : context provider service loader . get service locator ( ) . get implicit context provider ( ) ) { try { if ( implicit context data . class . is assignable from ( clazz ) ) { implicit context data instance = ( implicit context data ) ( clazz . new instance ( ) ) ; result . add ( instance ) ; } } catch ( throwable e ) {	Generic function to get a implicit data provider classes from resource files.
public static list < type to wrapper > get available wrappers ( ) { final list < type to wrapper > result = new array list < type to wrapper > ( ) ; for ( class clazz : context provider service loader . get service locator ( ) . get context provider ( ) ) { try { if ( wrapped context data . class . is assignable from ( clazz ) ) {	Method to get all available wrappers.
private void init connectors ( ) {	Initializes all available connectors.
final void send error report to connectors ( connector output provider connector output provider ) { for ( connector connector : this . connector map . values ( ) ) { connector . send error report ( connector output provider ) ; } }	Send error report to all initialized connector instances.
final set < string > get connector configuration names ( ) { set < string > connector names = new hash set < string > ( ) ; enumeration < object > key enumeration = get system properties ( ) . keys ( ) ; while ( key enumeration . has more elements ( ) ) { string key = key enumeration . next element ( ) . to string ( ) ;	Extracts all names for connector configurations from System properties.
final map < string , string > get properties for connector configuration name ( final string connector name ) { final map < string , string > property map = new hash map < string , string > ( ) ; final string pattern string = string . format ( connector property grabber pattern , connector name ) ; final pattern property grab pattern = pattern . compile ( pattern string ) ; final set < map . entry < object , object > > entries = get system properties ( ) . entry set ( ) ; for ( map . entry < object , object > entry : entries ) { final string key = entry . get key ( ) . to string ( ) ; final object value = entry . get value ( ) ;	Collects all properties for a given connector configuration name and writes them to a Map.
final connector create connector ( final string connector configuration name ) { map < string , string > property map = this . get properties for connector configuration name ( connector configuration name ) ; string type = property map . get ( tracee context logger constants . system property context logger connector type ) ;	Tries to create a Connector for a given connector configuration name.
private boolean is connector configured ( class connector class ) { for ( connector connector : this . connector map . values ( ) ) { if ( connector class . is instance ( connector ) ) { return bool ; } } return bool ; }	Checks whether the LogConnector is defined or not.
boolean has getter prefix in method name ( method method ) { string method name = method . get name ( ) ; if ( method name != null ) { for ( string prefix : getter prefixes ) { if ( method name . starts with ( prefix ) ) { return bool ; } } } return bool ; }	Getter method names must have a specific prefix.
boolean is public non static method ( final method method ) { int modifiers = method . get modifiers ( ) ; return ! modifier . is static ( modifiers ) && modifier . is public ( modifiers ) ; }	Getter methods must be public and not be static.
boolean has compatible return types ( class type , method method ) { field corresponding field = get corresponding field ( type , method ) ; return corresponding field != null && method . get return type ( ) . is assignable from ( corresponding field . get type ( ) ) ; }	Getter method and field must have compatible fields.
field get corresponding field ( class type , method method ) { try { return type . get declared field ( getter utilities . get field name ( method ) ) ; } catch ( no such field exception e ) { return null ; } }	Helper method for getting a corresponsing field for a method.
public static boolean is getter method ( final string method name ) { if ( method name != null ) { for ( string prefix : getter prefixes ) { if ( method name . starts with ( prefix ) ) { return bool ; } } } return bool ; }	Checks whether the method name starts with a getter prefix.
static string capitalize first char of string ( final string input ) { if ( input == null || input . length ( ) == num ) { return str ; } else if ( input . length ( ) == num ) { return input . to upper case ( ) ; } else { return input . substring ( num , num ) . to upper case ( ) + input . substring ( num ) ; } }	Capitalizes first char of an input string.
static string decapitalize first char of string ( final string input ) { if ( input == null || input . length ( ) == num ) { return str ; } else if ( input . length ( ) == num ) { return input . to lower case ( ) ; } else { return input . substring ( num , num ) . to lower case ( ) + input . substring ( num ) ; } }	Decapitalizes first char of an input string.
static string strip getter prefix ( final string input ) { if ( input != null ) { for ( string prefix : getter prefixes ) { if ( input . starts with ( prefix ) ) { return input . substring ( prefix . length ( ) ) ; } } } return input ; }	Strips getter prefix from input string.
void send error report to connectors ( proceeding join point proceeding join point , string annotated id , throwable e ) {	Sends the error reports to all connectors.
public object apply ( context logger configuration context logger configuration , object instance to wrap ) {	Wraps the passed instance inside a matching tracee context logging provider instance.Will return the passed instance, if no matching tracee context logging provider exists.
protected object create instance ( final class type ) { if ( type != null ) { try { return type . new instance ( ) ; } catch ( exception e ) {	Creates a new instance of the passed type via reflection.
public static profile get current profile ( ) {	Gets the current profile.Uses the following algorithm to determine the profile.1.
public static properties open properties ( final string property file name ) throws io { if ( property file name == null ) { return null ; } input stream input stream = null ; try { input stream = profile . class . get resource as stream ( property file name ) ; if ( input stream != null ) {	Loads properties from resources.
private void fill manual context override map ( final string [ ] contexts , final boolean value ) { if ( contexts != null ) { for ( string context : contexts ) { if ( ! context . is empty ( ) ) { this . manual context overrides . put ( context , value ) ; } } } }	Adds passed contexts value pairs to manualContextOverrides.
private tracee context string representation builder impl create context string representation log builder ( ) { tracee context string representation builder impl tracee context string representation builder impl = new tracee context string representation builder impl ( ) ; tracee context string representation builder impl . set manual context overrides ( this . get manual context overrides ( ) ) ; tracee context string representation builder impl . set profile ( this . get profile ( ) ) ; tracee context string representation builder impl . set enforce order ( this . get enforce order ( ) ) ; tracee context string representation builder impl . set output writer configuration ( this . get output writer configuration ( ) ) ; return tracee context string representation builder impl ; }	Creates a TraceeGsonContextStringRepresentationBuilder instance which can be used for creating the createStringRepresentation message.
public static boolean check if method throws contains passed exception ( final proceeding join point proceeding join point , throwable thrown exception ) { if ( proceeding join point == null || thrown exception == null ) { return bool ; } class [ ] throws classes from method signature = get defined throws from method signature ( proceeding join point ) ; return check class is defined in throws exception ( throws classes from method signature , thrown exception ) ; }	Checks whether the passed Throwable is contained in methods throws part.
public static boolean check class is defined in throws exception ( class [ ] classes , throwable thrown exception ) {	Checks whether the passed Throwable is defined included in passed classes array or is subtype of one of the included classes.
public static class [ ] get defined throws from method signature ( final proceeding join point proceeding join point ) { if ( proceeding join point == null ) { return new class [ num ] ; }	Gets all Exceptions declared at the throws part of the method signature.
public static boolean check process watchdog ( final watchdog watchdog annotation , final proceeding join point proceeding join point , final throwable throwable ) {	Checks whether the exception should be processed or not.
public final @ not null s has size ( int expected ) { is not null ( ) ; int size = actual group size ( ) ; if ( size == expected ) { return myself ( ) ; } fail if custom message is set ( ) ; throw failure ( format ( str , expected , size , actual ) ) ; }	Verifies that the number of values in the actual group is equal to the given one.
protected final void assert does not have duplicates ( ) { is not null ( ) ; collection < ? > duplicates = duplicates from ( actual as list ( ) ) ; if ( duplicates . is empty ( ) ) { return ; } fail if custom message is set ( ) ; throw failure ( format ( str , actual , duplicates ) ) ; }	Verifies that the actual group of objects does not have duplicates.
public view get drop down view ( int index , view convert view , view group parent ) { return drop down view factory . get view ( convert view , item list . get ( index ) ) ; }	Declared by SpinnerAdapter, this method allows your spinner to showdifferent views in your drop down vs the 'closed' spinned box.
protected final int reserve term name ( string name ) { check status ( status . initializing ) ; check initialization precondition ( term utils . is valid term name ( name ) , str , name ) ; check initialization precondition ( ! this . name ordinal . contains key ( name ) , str , name ) ; this . name ordinal . put ( name , ++ this . ordinal ) ; return this . ordinal ; }	Allow the reservation of term names during the initialization of thevocabulary.
protected final < s extends immutable term > void register term ( s term ) { check status ( status . initializing ) ; check initialization precondition ( this . name ordinal . contains key ( term . name ( ) ) , str , term . name ( ) ) ; check initialization precondition ( term . ordinal ( ) >= num && term . ordinal ( ) <= this . ordinal , str , term . ordinal ( ) , term . name ( ) ) ; this . terms . put ( term . ordinal ( ) , this . term class . cast ( term ) ) ; }	Upon reservation, the method enables registering the properly builtimmutable term instance.
protected final void initialize ( ) { check status ( status . initializing ) ; if ( this . terms . size ( ) != this . name ordinal . size ( ) ) { throw new illegal state exception ( string . format ( str , this . namespace , get class ( ) . get name ( ) ) ) ; } this . status = status . initialized ; }	Complete the initialization of the vocabulary.
public data set get representation ( ) { return dsl . data set ( ) . individual ( new reference ( ) . to local individual ( ) . named ( str ) ) . has link ( knows ) . referring to ( new reference ( ) . to managed individual ( str ) . named ( str ) ) . individual ( new reference ( ) . to local individual ( ) . named ( str ) ) . has property ( created on ) . with value ( new date ( ) ) . has link ( knows ) . referring to ( new reference ( ) . to managed individual ( str ) . named ( str ) ) . individual ( new reference ( ) . to managed individual ( str ) . named ( str ) ) . has property ( creation date ) . with value ( new date ( ) ) . has property ( age ) . with value ( num ) . has link ( has father ) . to individual ( new reference ( ) . to local individual ( ) . named ( str ) ) . has link ( has wife ) . referring to ( new reference ( ) . to local individual ( ) . named ( str ) ) . build ( ) ; }	Get custom representation with bad data.
public name < string > name ( string name , string ... names ) { return create name ( assemble ( name , names ) ) ; }	Concatenates elements to form a dotted name, discarding null valuesand empty strings.
public name < string > name ( class < ? > clazz , string ... names ) { return name ( clazz . get canonical name ( ) , names ) ; }	Concatenates a canonical class name and elements to form a dotted name, discarding any null values or empty stringsany null values or empty strings.
public static media type wildcard ( string type ) { require non null ( type , type cannot be null ) ; return new immutable media type ( media types . preferred syntax ( ) , type , wildcard type , null , null ) ; }	Create a wildcard media type for a given primary type.
public static media type wildcard ( string type , string suffix ) { require non null ( type , type cannot be null ) ; require non null ( suffix , str ) ; return new immutable media type ( media types . preferred syntax ( ) , type , wildcard type , suffix , null ) ; }	Create a wildcard structured-syntax media type for a given primary type.
public static media type of ( string type , string subtype ) { require non null ( type , type cannot be null ) ; require non null ( subtype , str ) ; return from string ( type + str + subtype ) ; }	Create a media type.
public static string to header ( final media type media type ) { require non null ( media type , reference media type cannot be null ) ; final string builder builder = new string builder ( ) . append ( media type . type ( ) . to lower case ( locale . english ) ) . append ( str ) . append ( media type . sub type ( ) . to lower case ( locale . english ) ) ; final string suffix = media type . suffix ( ) ; if ( suffix != null ) { builder . append ( str ) . append ( suffix . to lower case ( locale . english ) ) ; } final charset charset = media type . charset ( ) ; if ( charset != null ) { builder . append ( str ) . append ( charset . name ( ) . to lower case ( locale . english ) ) ; } for ( entry < string , string > entry : media type . parameters ( ) . entry set ( ) ) { final string key = entry . get key ( ) ; if ( is standard parameter ( key ) ) { continue ; } builder . append ( str ) . append ( key . to lower case ( locale . english ) ) . append ( str ) . append ( entry . get value ( ) ) ; } return builder . to string ( ) ; }	Format the media type in a HTTP-header compliant manner using preferredformat.
@ override public void run ( ) { application context ctx = application context . get instance ( ) ; logger . debug ( str , new date ( ) ) ; try ( write session session = ctx . create session ( ) ) { resource snapshot snapshot = session . find ( resource snapshot . class , this . name , dynamic resource handler . class ) ; data set data set = this . handler . get ( snapshot ) ; individual < ? , ? > individual = data set . individual of id ( managed individual id . create id ( snapshot . name ( ) , snapshot . template id ( ) ) ) ; snapshot resolver snapshot resolver = snapshot resolver . builder ( ) . with read session ( session ) . with canonical base ( canonical base ) . build ( ) ; uri snapshot endpoint = snapshot resolver . to uri ( snapshot ) ; individual . add value ( snapshot endpoint , literals . new literal ( snapshot endpoint ) ) ; individual . add value ( snapshot resolution , literals . new literal ( roundtrip ( snapshot resolver , snapshot endpoint , snapshot ) ) ) ; this . handler . update ( this . name , data set ) ; session . modify ( snapshot ) ; session . save changes ( ) ; } catch ( exception e ) { logger . error ( str , e ) ; } finally { logger . debug ( str ) ; } }	Update the resource representation adding the path where the resource ispublished and whether or not if given that URI it can be resolved to thesame resource.
@ override public int compare to ( term other ) { immutable term self = this ; if ( self . get declaring vocabulary ( ) != other . get declaring vocabulary ( ) ) { throw new class cast exception ( ) ; } return self . ordinal - other . ordinal ( ) ; }	Compares this term with the specified object for order.
public list < name < string > > pending attachment names ( string attachment id ) { list < name < string > > result = new array list < name < string > > ( ) ; name source source = this . attachment name sources . get ( attachment id ) ; if ( source != null ) { result . add all ( source . pending names ) ; } return result ; }	Return the pending names for the specified attachment.
public void add attachment name ( string attachment id , name < string > next name ) { name source ( attachment id ) . add name ( next name ) ; }	Add a name to the list of available names for a given attachment.
public name < string > next attachment name ( string attachment id ) { name source result = this . attachment name sources . get ( attachment id ) ; if ( result == null ) { result = new name source ( str + attachment id + str ) ; } return result . next name ( ) ; }	Return the next available name for a given attachment.
public static name provider create ( name < string > resource ) { objects . require non null ( resource , str ) ; return new name provider ( resource ) ; }	Create a new name provider.
private static void parse suffix ( final media range mr , final string media type ) { final string sub type = mr . sub type ; final int plus idx = sub type . last index of ( str ) ; if ( plus idx == num ) { throw new invalid media type exception ( media type , str + sub type . substring ( num ) + str ) ; } else if ( plus idx == sub type . length ( ) - num ) { throw new invalid media type exception ( media type , str + sub type . substring ( num , sub type . length ( ) - num ) + str ) ; } else if ( plus idx > num ) { mr . sub type = sub type . substring ( num , plus idx ) ; mr . suffix = sub type . substring ( plus idx + num ) ; }	As per RFC 6838, Section 4.2 structuring syntaxes specifier syntaxes aredefined after the last '+' symbol.
private static void check quoted string ( final string quoted string ) { boolean quoted pair = bool ; for ( int i = num ; i < quoted string . length ( ) ; i ++ ) { final char ch = quoted string . char at ( i ) ; if ( quoted pair ) { check argument ( quoted pair . get ( ch ) , str , ch , quoted string , i ) ; quoted pair = bool ; } else if ( ch == slash ) { quoted pair = bool ; } else { check argument ( qdtext . get ( ch ) , str , ch , quoted string , i ) ; } } check argument ( ! quoted pair , str , quoted string , quoted string . length ( ) ) ; }	Checks the given quoted string for illegal characters, as defined in RFC7230, section 3.2.6.
@ override public integer next ( ) { if ( ! has next ( ) ) { throw new no such element exception ( str ) ; } this . index = this . next ; final integer code point = character . code point at ( this . s , this . next ) ; this . next += character . char count ( code point ) ; return code point ; }	Returns the next code point in the iteration.
@ override public void run ( ) { application context ctx = application context . get instance ( ) ; date date = new date ( ) ; logger . debug ( str , date ) ; try ( write session session = ctx . create session ( ) ) { resource snapshot snapshot = session . find ( resource snapshot . class , this . name , dynamic resource handler . class ) ; data set data set = this . handler . get ( snapshot ) ; individual < ? , ? > individual = data set . individual of id ( managed individual id . create id ( this . name , dynamic resource handler . id ) ) ; individual . add value ( refreshed on , literals . of ( date ) . date time ( ) ) ; this . handler . update ( this . name , data set ) ; session . modify ( snapshot ) ; session . save changes ( ) ; } catch ( exception e ) { logger . error ( str , e ) ; } finally { logger . debug ( str ) ; } }	Update the resource representation adding a temporal timestamp of whenthe resource was last updated.
private static void close quietly ( final input stream is , final string message ) { if ( is != null ) { try { is . close ( ) ; } catch ( final exception e ) { if ( logger . is warn enabled ( ) ) { logger . warn ( message , e ) ; } } } }	Close an input stream logging possible failures.
static boolean is name start char ( final int code point ) { return ( code point == str ) || ( code point >= str && code point <= str ) || ( code point == str ) || ( code point >= str && code point <= str ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) ; }	Determines if a character is a Name start character.
static boolean is name char ( final int code point ) { return is name start char ( code point ) || ( code point == str ) || ( code point == str ) || ( code point >= str && code point <= str ) || ( code point == num ) || ( code point >= num && code point <= num ) || ( code point >= num && code point <= num ) ; }	Determines if a character is a Name character.
static void check token ( final string token , final string message , object ... args ) { check not null ( message , str ) ; try { validate length ( token ) ; validate characters ( token ) ; } catch ( illegal argument exception e ) { throw new invalid token exception ( string . format ( message , args ) , token , e ) ; } }	Checks the given type name for illegal characters, as defined in RFC7230, section 3.2.6.
public data transformator media type ( media type media type ) { check not null ( media type , media type cannot be null ) ; data transformator result = new data transformator ( this ) ; result . set media type ( media type ) ; return result ; }	Create transformator with the specified media type.
static void register adapter class ( class < ? > clazz ) { objects . require non null ( clazz , str ) ; type adapter . adapter classes . add if absent ( clazz ) ; }	Register a new adapter class.
static < s , t > type adapter < s , t > create adapter ( class < ? extends s > source type , class < ? extends t > target type ) { return do create adapter ( target type , adapter method validator . new instance ( target type , source type ) ) ; }	Get an adapter capable of transforming instances of a source type intoinstances of a target type.
static < s , t > t adapt ( s object , class < ? extends t > result class ) { return type adapter . < s , t > do create adapter ( result class , adapter method validator . new instance ( result class , object ) ) . adapt ( object ) ; }	Transform a given object into an instance of the specified type.
public immutable namespaces with prefix ( string prefix , string namespace uri ) { objects . require non null ( prefix , str ) ; objects . require non null ( namespace uri , str ) ; immutable namespaces result = new immutable namespaces ( this . map ) ; result . map . put ( prefix , namespace uri ) ; return result ; }	Create a copy of the namespaces which includes a mapping between a givenprefix and namespace URI.
public immutable namespaces without prefix ( string ... prefixes ) { immutable namespaces result = new immutable namespaces ( this . map ) ; for ( string prefix : prefixes ) { result . map . remove ( prefix ) ; } return result ; }	Create a copy of the namespaces without the prefixes.
public static string escape xml ( final char sequence s ) { final string builder sb = new string builder ( s . length ( ) * num ) ; final code point iterator iterator = new code point iterator ( s ) ; while ( iterator . has next ( ) ) { final int code point = iterator . next ( ) ; if ( code point == str ) { sb . append ( lt ) ; } else if ( code point == str ) { sb . append ( gt ) ; } else if ( code point == str ) { sb . append ( quot ) ; } else if ( code point == str ) { sb . append ( amp ) ; } else if ( code point == str ) { sb . append ( apos ) ; } else { sb . append code point ( code point ) ; } } return sb . to string ( ) ; }	Escapes a character sequence so that it is valid XML.
@ override public data set query ( resource snapshot resource , query query , read session session ) throws invalid query exception { return query support . get description ( resource . name ( ) , query ) ; }	Instead of retrieving the contents of the resource, return a descriptionof the query received.
public final void add name provider ( name < string > container name , name provider provider ) { this . name providers . put ( container name , provider ) ; }	Add a name provider for a container resource.
public final name provider name provider ( name < ? > container name ) { name provider result = this . name providers . get ( container name ) ; if ( result == null ) { throw new application runtime exception ( str + container name + str ) ; } return result ; }	Return the name provider registered for a given container resource.
public < t > t unwrap ( final class < ? extends t > clazz ) throws application engine exception { check not null ( clazz , str ) ; if ( ! clazz . is instance ( this ) ) { throw new application engine exception ( str + clazz . get canonical name ( ) ) ; } return clazz . cast ( this ) ; }	Return an object of the specified type to allow access to theprovider-specific API.
public boolean is out of scope ( ) {	Checks if the path is out of the scope.
public path with directory ( final string directory ) { final path result = new path ( this ) ; result . set directory ( directory ) ; return result ; }	Create a new path with a given directory.
public path with file ( final string file ) { final path result = new path ( this ) ; result . set file ( file ) ; return result ; }	Create a new path with a given file.
private path assemble relative segments ( final path path , final path base , final deque < string > segments ) { if ( segments . is empty ( ) && path . is directory ( ) && base . is file ( ) ) { segments . add ( current ) ; } return path . create ( assemble segments ( segments , path . get file ( ) ) ) ; }	If there are no segments in the resolved path, and we are trying toresolve a directory coming from a path, we have to make explicit that wewant the directory.
static < t > class < t > get type parameter ( class < ? > clazz , class < ? super t > bound ) { type t = check not null ( clazz ) ; while ( t instanceof class < ? > ) { t = ( ( class < ? > ) t ) . get generic superclass ( ) ; } if ( t instanceof parameterized type ) { class < t > result = process parameterized type ( bound , ( parameterized type ) t ) ; if ( result != null ) { return result ; } } throw new illegal state exception ( str + clazz . get name ( ) ) ; }	Finds the type parameter for the given class which is assignable to thebound class.
public static < t > primitive object factory < t > create ( final class < ? extends t > value class ) { check not null ( value class , str ) ; check argument ( value class . is primitive ( ) , str + value class . get name ( ) + str ) ; return new primitive object factory < t > ( value class ) ; }	Create a primitive object factory for the specified primitive class.
public static list < variant > create variants ( media type ... media types ) { return variant . variant list builder . new instance ( ) . media types ( media types ) . encodings ( ) . languages ( ) . add ( ) . build ( ) ; }	Get a list of acceptable variants.
@ suppress warnings ( str ) public individual < t , s > resolve ( data set data set ) { return ( individual < t , s > ) data set . individual of id ( ref ( ) ) ; }	Find the individual of the data set with the same identifier.
@ factory public static < t extends view group > matcher < t > equal children count as ( int value ) { return new view group comparison < t > ( value , equal , equal ) ; }	Is value = expected?.
@ factory public static < t extends view group > matcher < t > more children than ( int value ) { return new view group comparison < t > ( value , greater than , greater than ) ; }	Is value > expected?.
@ factory public static < t extends view group > matcher < t > more children or equal ( int value ) { return new view group comparison < t > ( value , equal , greater than ) ; }	Is value >= expected?.
@ factory public static < t extends view group > matcher < t > less children than ( int value ) { return new view group comparison < t > ( value , less than , less than ) ; }	Is value < expected?.
@ factory public static < t extends view group > matcher < t > less children or equal ( int value ) { return new view group comparison < t > ( value , less than , equal ) ; }	Is value <= expected?.
public measures get measures by year state ( string year , string state id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , year , str , state id ) , measures . class ) ; }	This method returns a list of state ballot measures in a given year.
public measure get measure ( string measure id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , measure id ) , measure . class ) ; }	This method returns a single Ballot Measure detail.
public candidate rating get candidate rating ( string candidate id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , candidate id ) , candidate rating . class ) ; }	This method dumps a candidate's rating by an SIG.
public rating get rating ( string rating id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , rating id ) , rating . class ) ; }	This method dumps all candidate ratings from a scorecard by an SIG.
public elections get election by year state ( string year ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , year ) , elections . class ) ; }	This method grabs district basic election data according to year and stateid.
public election by zip get election by zip ( string zip5 ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , zip5 ) , election by zip . class ) ; }	This method grabs district basic election data according to zip code.
public stage candidates get stage candidates ( string election id , string stage id , string party ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , election id , str , stage id , str , party ) , stage candidates . class ) ; }	This method grabs district basic election data according to electionId and stageId.Per state lists of a Presidential election are available by specifying the stateId.
public address address get office by office state ( string office id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , office id ) , address address . class ) ; }	This method grabs office address and basic candidate information according to the officeId and state.
public offices get offices by type ( string office type id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , office type id ) , offices . class ) ; }	This method dumps offices we keep track of according to type.
public offices get offices by level ( string level id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , level id ) , offices . class ) ; }	This method dumps offices we keep track of according to level.
public offices get offices by type level ( string office type id , string office level id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , office type id , str , office level id ) , offices . class ) ; }	This method dumps offices we keep track of according to type and level.
public offices get offices by branch level ( string branch id , string level id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , branch id , str , level id ) , offices . class ) ; }	This method dumps offices we keep track of according to branch and level.
public counties get counties ( string state id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , state id ) , counties . class ) ; }	Fetches counties in a state.
public cities get cities ( string state id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , state id ) , cities . class ) ; }	Fetches cities in a state.
public local candidate list get officials ( string local id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , local id ) , local candidate list . class ) ; }	Fetches officials for a locality.
public < t > t query ( string method , arg map arg map , class < t > response type ) throws vote smart exception , vote smart error exception { buffered reader reader = null ; url conn = null ; string char set = str ; try { if ( is caching ( method , arg map ) ) { file file = get cache file ( method , arg map ) ; long file length = file . length ( ) ; logger . fine ( str + file length + str + file . get name ( ) ) ; if ( file length == num ) { vote smart . cache file from api ( method , arg map , file ) ; } reader = new buffered reader ( new input stream reader ( new file input stream ( file ) , char set ) ) ; } else { conn = vote smart . get connection from api ( method , arg map ) ; char set = get charset ( conn ) ; reader = new buffered reader ( new input stream reader ( conn . get input stream ( ) , char set ) ) ; } jaxb < t > e = unmarshaller . unmarshal ( new stream source ( reader ) , response type ) ; if ( e . get name ( ) . get local part ( ) . equals ( str ) ) {	Queries the API server for the information requested.
public candidate list get statewide ( string state id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , state id ) , candidate list . class ) ; }	This method grabs a list of officials according to state representation.
public candidate list get by office type state ( string office type id , string state id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , office type id , str , state id ) , candidate list . class ) ; }	This method grabs a list of officials according to office type and state representation.
public candidate list get by zip ( string zip5 ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , zip5 ) , candidate list . class ) ; }	This method grabs a list of officials according to the zip code they represent.
public addl bio get addl bio ( string candidate id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , candidate id ) , addl bio . class ) ; }	This method grabs the extended bio for each candidate that has one.
public bio get bio ( string candidate id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , candidate id ) , bio . class ) ; }	This method grabs the extended bio for each candidate that has one.It uses the updated version 'getDetailedBio' of the call.
public candidate list get by lastname ( string last name , string election year ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , last name , str , election year ) , candidate list . class ) ; }	This method grabs a list of candidates according to a lastname match.
public candidate list get by election ( string election id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , election id ) , candidate list . class ) ; }	This method grabs a list of candidates according to a fuzzy lastname match.
public candidate list get by district ( string district id , string election year ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , district id , str , election year ) , candidate list . class ) ; }	This method grabs a list of candidates according to the district they represent.
public committees get committees by type state ( string type id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , type id ) , committees . class ) ; }	Returns the list of committees that fit the criteria.
public committee get committee ( string committee id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , committee id ) , committee . class ) ; }	Returns detailed committee data.
public committee members get committee members ( string committee id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , committee id ) , committee members . class ) ; }	Returns members of the committee.
public leadership get positions ( string state id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , state id ) , leadership . class ) ; }	Gets leadership positions by state and office.
public leaders get officials ( string leadership id ) throws vote smart exception , vote smart error exception { return api . query ( str , new arg map ( str , leadership id ) , leaders . class ) ; }	Gets officials that hold the leadership role in certain states.
public static void sleep ( int ms ) { long deadline = system . current time millis ( ) + ms ; while ( system . current time millis ( ) < deadline ) { try { thread . sleep ( math . max ( num , ( deadline - system . current time millis ( ) ) / num ) ) ; } catch ( interrupted exception ignore ) { } } }	Sleeps for the provided amount of milliseconds, ignoring threadinterrupts.
public void start ( ) { if ( timer != null ) throw new illegal state exception ( str ) ; if ( interval < busy waiting threshold ) timer = new my busy timer ( ) ; else if ( interval < millisecond threshold ) timer = new my waiting timer ( ) ; else timer = new my millisecond timer ( ) ; thread thread = new thread ( timer , str ) ; thread . set daemon ( bool ) ; thread . start ( ) ; }	Starts generating tick events, starting from 0.
public void wait for ( ) throws throwable { while ( ! finished ) { try { synchronized ( this ) { this . wait ( num ) ; } } catch ( interrupted exception e ) { thread . current thread ( ) . interrupt ( ) ; } } if ( t != null ) throw t ; }	Waits until the gobbler finished.
public void close ( ) { cancel = bool ; try { thread . interrupt ( ) ; wait for ( ) ; } catch ( throwable ignore ) { } try { is . close ( ) ; } catch ( exception ignore ) { } try { os . close ( ) ; } catch ( exception ignore ) { } }	Interrupts the gobbler and closes its streams.
public static < k , v , m extends map < k , v > > m merge ( stream < ? extends map < k , v > > stream , binary operator < v > merge function , supplier < m > map supplier ) { assert . not null ( stream , str ) ; assert . not null ( merge function , str ) ; assert . not null ( map supplier , str ) ; return stream . collect ( map supplier , ( a , b ) -> b . for each ( ( k , v ) -> a . merge ( k , v , merge function ) ) , map :: put all ) ; }	Merging single level aggregation maps.
public static < k , v > list < map < k , v > > split ( map < k , v > map , int limit ) { assert . not null ( map , str ) ; assert . is true ( limit > num , str ) ; if ( map . size ( ) <= limit ) { return collections . singleton list ( map ) ;	Splits map to list of maps.
public static < k , v > map < k , v > sort ( map < k , v > map , comparator < map . entry < k , v > > comparator ) { assert . not null ( map , str ) ; assert . not null ( comparator , str ) ; list < map . entry < k , v > > list = new linked list < > ( map . entry set ( ) ) ; collections . sort ( list , comparator ) ; map < k , v > result = new linked hash map < > ( ) ; for ( map . entry < k , v > entry : list ) { result . put ( entry . get key ( ) , entry . get value ( ) ) ; } return result ; }	Sorts map with comparator.
public static < t > t first value ( map < string , t > map ) { if ( map == null || map . size ( ) == num ) { return null ; } string first key = map . key set ( ) . iterator ( ) . next ( ) ; return map . get ( first key ) ; }	Returns first value in map as given by the iterator or null if empty.
public static < t > void is null ( t test , string message ) { is true ( test == null , message ) ; }	Tests if object is null.
public static < t > void not null ( t test , string message ) { is false ( test == null , message ) ; }	Tests if object is != null.
public static void not null or empty trimmed ( string value , string message ) { is false ( string utils . is null or empty trimmed ( value ) , message ) ; }	Tests if String is null or empty when trimmed.
public static < t > void is null or empty ( set < t > set , string message ) { is true ( set == null || set . size ( ) == num , message ) ; }	Tests if set is null or empty.
public static < t > void is null or empty ( t [ ] array , string message ) { is true ( array == null || array . length == num , message ) ; }	Tests if array is null or empty.
@ deprecated public static string get resource as string ( string resource file , class clazz ) { assert . not null or empty trimmed ( resource file , str ) ; scanner scanner = null ; try { input stream resource = clazz . get resource as stream ( resource file ) ; scanner = new scanner ( resource , utf 8 ) ; return scanner . use delimiter ( str ) . next ( ) ; } catch ( exception e ) { return null ; } finally { if ( scanner != null ) { scanner . close ( ) ; } } }	Loads class resource to String.
public static set < string > get resource words ( string resource file , class clazz ) { assert . not null or empty trimmed ( resource file , str ) ; scanner scanner = null ; try { input stream resource = clazz . get resource as stream ( resource file ) ; scanner = new scanner ( resource , utf 8 ) ; set < string > list = new linked hash set < > ( ) ; while ( scanner . has next ( ) ) { string next = scanner . next ( ) ; if ( next != null && next . trim ( ) . length ( ) > num ) { list . add ( next ) ; } } return list ; } catch ( exception e ) { return null ; } finally { if ( scanner != null ) { scanner . close ( ) ; } } }	Loads resource as a set of Strings, where each word is added to the set.
@ deprecated public static long get last modified time ( string resource file , class clazz ) { assert . not null or empty trimmed ( resource file , str ) ; try { url url = clazz . get resource ( resource file ) ; return url . open connection ( ) . get last modified ( ) ;	Get resource last modified date.
public static string get string ( final input stream is , string encoding ) { if ( is == null ) { return null ; } if ( string utils . is null or empty trimmed ( encoding ) ) { encoding = utf 8 ; } final char [ ] buffer = new char [ buffer size ] ; final string builder out = new string builder ( ) ; try { try ( reader in = new input stream reader ( is , encoding ) ) { for ( ; ; ) { int rsz = in . read ( buffer , num , buffer . length ) ; if ( rsz < num ) { break ; } out . append ( buffer , num , rsz ) ; } } } catch ( io ioe ) { throw new runtime exception ( ioe ) ; } return out . to string ( ) ; }	Load input stream into string.
public static byte [ ] get bytes ( input stream is ) { if ( is == null ) { return null ; } byte array output stream buffer = new byte array output stream ( ) ; int n read ; byte [ ] data = new byte [ buffer size ] ; try { while ( ( n read = is . read ( data , num , data . length ) ) != - num ) { buffer . write ( data , num , n read ) ; } buffer . flush ( ) ; } catch ( io ignored ) { } return buffer . to byte array ( ) ; }	Load input stream into byte array.
public static string read file to string ( file file ) throws io { assert . is true ( file . exists ( ) , str + file + str ) ; assert . is false ( file . is directory ( ) , str + file + str ) ; assert . is true ( file . can read ( ) , str + file + str ) ; file input stream stream = new file input stream ( file ) ; return get string ( stream ) ; }	Reads file into String.
@ deprecated public static string get resource absolute path ( string resource , class clazz ) { assert . not null or empty trimmed ( resource , str ) ; url file = clazz . get resource ( resource ) ; assert . not null ( file , str + resource + str ) ; return file . get file ( ) ; }	Gets absolute file path of resource.
public static string generate string ( int length ) { if ( length <= num || length > num ) { throw new illegal argument exception ( str + length ) ; } secure random random = new secure random ( ) ; string builder sb = new string builder ( length ) ; for ( int i = num ; i < length ; i ++ ) { sb . append ( elements . char at ( random . next int ( elements . length ( ) ) ) ) ; } return sb . to string ( ) ; }	Generates random string from ELEMENTS set of chars and numbers.
public static long generate long ( int length ) { if ( length <= num || length > num ) { throw new illegal argument exception ( str + length ) ; } secure random random = new secure random ( ) ; string builder sb = new string builder ( length ) ;	Generates non negative long key of maximum length 18.
@ safe varargs public static < t > t [ ] join ( final t [ ] array1 , final t ... array2 ) { if ( is empty ( array1 ) && is empty ( array2 ) ) { return null ; } if ( is empty ( array1 ) ) { return array2 ; } if ( is empty ( array2 ) ) { return array1 ; } final class < ? > type1 = array1 . get class ( ) . get component type ( ) ; @ suppress warnings ( str )	joins two arrays and preserves array orderarray1 items are followed by array2 items as given.
public static < t > list < set < t > > split ( set < t > set , int max size ) { assert . not null ( set , str ) ; assert . is true ( max size > num , str ) ; if ( set . size ( ) < max size ) { return collections . singleton list ( set ) ; } list < set < t > > list = new array list < > ( ) ; iterator < t > iterator = set . iterator ( ) ; while ( iterator . has next ( ) ) { set < t > new set = new hash set < > ( ) ; for ( int j = num ; j < max size && iterator . has next ( ) ; j ++ ) { t item = iterator . next ( ) ; new set . add ( item ) ; } list . add ( new set ) ; } return list ; }	Splits set in 1..N chunks of maxSize or less.
public static instant get month start ( instant time ) { assert . not null ( time , str ) ; local date time date time = local date time . of instant ( time , zone offset . utc ) ; date time = date time . with day of month ( num ) . with hour ( num ) . with minute ( num ) . with second ( num ) . with ( chrono field . milli of second , num ) ; return date time . to instant ( zone offset . utc ) ; }	Gets first millisecond of first day in month.
public static instant get month end ( instant time ) { assert . not null ( time , str ) ; local date time date time = local date time . of instant ( time , zone offset . utc ) ; date time = date time . with day of month ( num ) . with hour ( num ) . with minute ( num ) . with second ( num ) . with ( chrono field . milli of second , num ) ; date time = date time . plus ( num , chrono unit . months ) . minus ( num , chrono unit . days ) ; return date time . to instant ( zone offset . utc ) ; }	Returns last millisecond of last day in month ..
public static string trim to null ( string text ) { text = trim ( text ) ; if ( text == null || text . is empty ( ) ) { return null ; } return text ; }	Trims down text to null if empty.
public static string capitalize ( string input ) { if ( input == null ) { return null ; } if ( input . length ( ) > num ) { for ( int i = num ; i < input . length ( ) ; i ++ ) { if ( character . is alphabetic ( input . char at ( i ) ) ) { return input . substring ( num , i ) + character . to string ( input . char at ( i ) ) . to upper case ( ) + input . substring ( i + num ) ; } } } return input . to upper case ( ) ; }	Capitalizes first character in given string.
public static string join ( object [ ] args , string separator ) { return join ( args , separator , null ) ; }	Joins array of objects into string, where items are separatedwith a defined separator.
public static string join ( set < ? > items , string separator ) { return join ( items , separator , null ) ; }	Joins set of items to a single string, where items are separatedwith a defined separator.
public static list < string > get words ( string text ) { list < string > output = new array list < > ( ) ; if ( is null or empty trimmed ( text ) ) { return output ; } pattern p = pattern . compile ( str ) ; matcher m = p . matcher ( text ) ; while ( m . find ( ) ) { output . add ( m . group ( ) ) ; } return output ; }	Extracts words from text removing non alpha characters.
public static string trim text down ( string text , int size ) { if ( text == null || text . length ( ) <= size ) { return text ; } int pos = text . last index of ( str , size ) ; if ( pos < num ) { return text . substring ( num , size ) ; } return text . substring ( num , pos ) ; }	Reduces text to max given size preserving words.
public static string trim text down ( string text , int size minus append , string append ) { assert . not null ( append , str ) ; if ( text == null || text . length ( ) <= size minus append ) { return text ; } size minus append = size minus append - append . length ( ) ; int pos = text . last index of ( str , size minus append ) ; if ( pos < num ) { return text . substring ( num , size minus append ) + append ; } return text . substring ( num , pos ) + append ; }	Reduces text size to a given size.
public static list < string > as list of chars ( string text ) { list < string > list = new array list < > ( ) ; if ( string utils . is null or empty trimmed ( text ) ) { return list ; } for ( int i = num ; i < text . length ( ) ; i ++ ) { list . add ( character . to string ( text . char at ( i ) ) ) ; } return list ; }	Converts text to list of characters.
public static int relevance ( string value , string search ) { if ( string utils . is null or empty trimmed ( value ) || string utils . is null or empty trimmed ( search ) ) { return - num ; } if ( search . length ( ) > value . length ( ) ) { return - num ; } int relevance = - num ;	Calculates matching relevance between given string and search expression.
public static string un quote ( string text ) { if ( is null or empty trimmed ( text ) ) { return text ; } if ( ( text . starts with ( str ) && text . ends with ( str ) ) || ( text . starts with ( str ) && text . ends with ( str ) ) ) { return text . substring ( num , text . length ( ) - num ) ; } return text ; }	Removes double or single quotes if any are present.
public static long get timezone time ( long time , int timezone ) { calendar calendar = get calendar ( time ) ; int hour = calendar . get ( calendar . hour of day ) ; hour = ( hour + timezone ) % num ; if ( hour < num ) { hour = num + hour ; calendar . add ( calendar . day of month , - num ) ; } calendar . set ( calendar . hour of day , hour ) ; return calendar . get time in millis ( ) ; }	Returns time for given time zone.
public list < integer > has tag ( final integer tag id ) { final list < integer > ret value = new array list < integer > ( ) ; for ( final filter tag tag : get filter tags ( ) ) { if ( tag . get tag ( ) . get tag id ( ) . equals ( tag id ) ) ret value . add ( tag . get tag state ( ) ) ; } return ret value ; }	Loops through the FilterTags held by this Filter, and returns the state of the tag if it exists, and -1 if it does not.
private boolean is violation ( string severity ) { if ( str . equals ( severity ) ) { return str . equals ( violation severity ) || str . equals ( violation severity ) || str . equals ( violation severity ) ; } else if ( str . equals ( severity ) ) { return str . equals ( violation severity ) || str . equals ( violation severity ) ; } else if ( str . equals ( severity ) ) { return str . equals ( violation severity ) ; } else { return bool ; } }	Checks if the given severity is considered a violation.
public void icon severity ( string level ) { sink . figure ( ) ; sink . figure graphics ( str + level + str ) ; sink . figure ( ) ; }	Render a simple icon of given level.
public void icon severity ( string level , int text type ) { sink . figure ( ) ; sink . figure graphics ( str + level + str ) ; sink . figure ( ) ; if ( text type > num ) { sink . non breaking space ( ) ; sink . text ( bundle . get string ( str + level + suffix ( text type ) ) ) ; } }	Render an icon of given level with associated text.
@ transient public string get tags list ( final boolean br line break ) {	Generates a HTML formatted and categorized list of the tags that are associated with this topic.
@ transient public void set next and clean ( cs next ) { set next internal ( next ) ; if ( next != null ) { next . set previous internal ( this ) ; } }	Sets the Next Node and cleans up any old references.
@ transient public void set previous and clean ( cs previous ) { set previous internal ( previous ) ; if ( previous != null ) { previous . set next internal ( this ) ; } }	Sets the Previous Node and cleans up any old references.
public node find ( string host , int port ) { return socket to node map . get ( utils . to key ( host , port ) ) ; }	Finds the node by host and port.
public set < node > find ( string host ) { set < node > result set = new hash set < node > ( ) ; if ( host != null ) { for ( node node : socket to node map . values ( ) ) { if ( host . equals ( node . get host ( ) ) ) { result set . add ( node ) ; } } } return result set ; }	Finds the set of nodes by host.
public set < node > get all not dead ( ) { set < node > all not dead nodes set = new hash set < node > ( ) ; for ( node node : socket to node map . values ( ) ) { if ( ! node status . dead . equals ( node . get status ( ) ) ) { all not dead nodes set . add ( node ) ; } } return all not dead nodes set ; }	Gets all the nodes not in status DEAD.
public void add ( node node ) { socket to node map . put ( utils . to key ( node ) , node ) ; send event ( node , node event type . added ) ; }	Adds one more node to the container.
public void remove ( node node ) { socket to node map . remove ( utils . to key ( node ) ) ; send event ( node , node event type . removed ) ; }	Removes the specified node.
public void mark as alive ( node node ) { if ( ! node status . alive . equals ( node . get status ( ) ) ) { socket to node map . get ( utils . to key ( node ) ) . mark as alive ( ) ; send event ( node , node event type . marked as alive ) ; } }	Marks the node as ALIVE in case of its status is not ALIVE.
public void mark as dead ( node node ) { if ( ! node status . dead . equals ( node . get status ( ) ) ) { socket to node map . get ( utils . to key ( node ) ) . mark as dead ( ) ; send event ( node , node event type . marked as dead ) ; } }	Marks the node as DEAD in case of its status is not DEAD.
private void send event ( node node , node event type type ) { node event event = new node event ( node , type ) ; for ( node event handler handler : handlers ) { handler . handle ( event ) ; } }	Sends the event to all the handlers.
private string get checkstyle version ( ) { package checkstyle api package = configuration . class . get package ( ) ; return ( checkstyle api package == null ) ? null : checkstyle api package . get implementation version ( ) ; }	Get the effective Checkstyle version at runtime.
private void configure resource locator ( final resource manager resource manager , final checkstyle executor request request , final list < artifact > additional artifacts ) { final maven project project = request . get project ( ) ; resource manager . set output directory ( new file ( project . get build ( ) . get directory ( ) ) ) ;	Configures search paths in the resource locator.This method should only be called once per execution.
private map < string , object > create object property values ( map < string , object > default property values , list < object > attributes ) { map < string , object > property values = new hash map < string , object > ( default property values ) ; if ( attributes != null ) { iterator < object > iterator = attributes . iterator ( ) ; map < string , object > property override map = new hash map < string , object > ( ) ; while ( iterator . has next ( ) ) { string name = ( string ) iterator . next ( ) ;	Merge passed attributes with the supplied property values.
private int current sequence ( string name ) { map < string , integer > sequences for class = sequences . get ( get class ( ) ) ; if ( sequences for class == null ) { sequences for class = new hash map < string , integer > ( ) ; sequences . put ( get class ( ) , sequences for class ) ; } integer seq = sequences for class . get ( name ) ; seq = seq == null ? num : seq + num ; sequences for class . put ( name , seq ) ; return seq ; }	Retrieve the current sequence value for the given property.
@ override public int compare to ( final id that ) {	Compares the supplied NodeID to this one.
public list < node event > get and clear eventslist ( ) { array list < node event > result = new array list < node event > ( eventslist ) ; eventslist . clear ( ) ; return result ; }	Gets the copy of the buffer and clears the buffer.
public sorted set < package doc > find packages from classes in java doc run ( ) { final sorted set < package doc > to return = new tree set < > ( comparators . package name comparator ) ; final class doc [ ] current execution classes = classes ( ) ; if ( current execution classes != null ) { arrays . stream ( current execution classes ) . map ( program element doc :: containing package ) . for each ( to return :: add ) ; }	Finds all PackageDoc objects from the classes in this JavaDoc execution.
public static boolean set property ( object target , string name , object value ) { try { for ( property descriptor pd : introspector . get bean info ( target . get class ( ) ) . get property descriptors ( ) ) { if ( pd . get write method ( ) != null && pd . get name ( ) . equals ( name ) ) { pd . get write method ( ) . invoke ( target , value ) ; return bool ; } } } catch ( exception e ) { throw new runtime exception ( e ) ; } return bool ; }	Set the property identified by name to the provided value.
public static boolean set field ( object target , string name , object value ) { try { field field = target . get class ( ) . get declared field ( name ) ; field . set accessible ( bool ) ; field . set ( target , value ) ; return bool ; } catch ( no such field exception e ) { return bool ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Set the field identified by name to the given value.
public static list < method > get annotated methods ( class target class , class < ? extends annotation > annotation type ) { list < method > annotated methods = new array list < method > ( ) ; for ( method method : target class . get declared methods ( ) ) { if ( method . is annotation present ( annotation type ) ) { annotated methods . add ( method ) ; } } return annotated methods ; }	Get all methods on the given class that are annotated with the given annotation type.
public static void invoke method ( object target , method method , object ... arguments ) { method . set accessible ( bool ) ;	Invoke the given method on the given target using the given arguments.Allows to call private and protected methods.
public static void main ( string [ ] args ) throws exception { if ( args . length > num ) { load classes ( args [ num ] ) ; } start cache server ( ) ; console utils . wait for enter ( java process launcher . process startup completed ) ; stop cache server ( ) ; }	Server entry point.
private string get config attribute ( configuration config , chained item < configuration > parent configuration , string attribute name , string default value ) { string ret ; try { ret = config . get attribute ( attribute name ) ; } catch ( checkstyle exception e ) {	Get the value of the specified attribute from the Checkstyle configuration.If parentConfigurations is non-null and non-empty, the parentconfigurations are searched if the attribute cannot be found in thecurrent configuration.
private void do rules summary ( checkstyle results results ) { if ( checkstyle config == null ) { return ; } sink . section1 ( ) ; sink . section title1 ( ) ; sink . text ( bundle . get string ( str ) ) ; sink . section title1 ( ) ; sink . table ( ) ; sink . table row ( ) ; sink . table header cell ( ) ; sink . text ( bundle . get string ( str ) ) ; sink . table header cell ( ) ; sink . table header cell ( ) ; sink . text ( bundle . get string ( str ) ) ; sink . table header cell ( ) ; sink . table header cell ( ) ; sink . text ( bundle . get string ( str ) ) ; sink . table header cell ( ) ; sink . table header cell ( ) ; sink . text ( bundle . get string ( str ) ) ; sink . table header cell ( ) ; sink . table row ( ) ;	Create the rules summary section of the report.
public boolean match rule ( audit event event , string rule name , string expected message , string expected severity ) { if ( ! rule name . equals ( rule util . get name ( event ) ) ) { return bool ; }	Check if a violation matches a rule.
private string create received at key ( string from cluster name , string to cluster name ) { return key prefix + from cluster name + str + to cluster name + key postfix duration ; }	Creates the receivedAt key.
private void wait for started ( ) { debug ( str ) ; while ( bool ) { boolean others started = bool ; for ( object key : clusters properties . key set ( ) ) { string cluster name = ( string ) key ; long started at = region . get ( create started at key ( cluster name ) ) ; debug ( str + started at + str + processing started at ) ; if ( ( started at == null ) || ( started at . long value ( ) < processing started at ) ) { others started = bool ; break ; } } if ( others started ) { break ; } try { time unit . milliseconds . sleep ( check period ) ; } catch ( interrupted exception e ) { } } debug ( str ) ; }	Wait until the other clients started.
private void wait for sent ( ) { debug ( str ) ; while ( bool ) { boolean others sent = bool ; map < string , long > cluster name to received at map = new hash map < string , long > ( ) ; for ( object key : clusters properties . key set ( ) ) { string cluster name = ( string ) key ; if ( local cluster name . equals ( cluster name ) ) { continue ; } long sent at = region . get ( create sent at key ( cluster name ) ) ; long received at = system . current time millis ( ) ; if ( ( sent at != null ) && ( sent at . long value ( ) > processing started at ) ) { cluster name to received at map . put ( cluster name , received at ) ; } } for ( object key : clusters properties . key set ( ) ) { string cluster name = ( string ) key ; if ( local cluster name . equals ( cluster name ) ) { continue ; } long received at = cluster name to received at map . get ( cluster name ) ; if ( received at == null ) { if ( others sent ) { others sent = bool ; } } else { region . put ( create received at key ( cluster name , local cluster name ) , received at ) ; } } if ( others sent ) { break ; } try { time unit . milliseconds . sleep ( check period ) ; } catch ( interrupted exception e ) { } } debug ( str ) ; }	Wait until received all the entries from other clients.
private void wait for connected ( ) { debug ( str ) ; while ( bool ) { boolean connected = bool ; for ( object from key : clusters properties . key set ( ) ) { string from cluster name = ( string ) from key ; for ( object to key : clusters properties . key set ( ) ) { string to cluster name = ( string ) to key ; if ( from cluster name . equals ( to cluster name ) ) { continue ; } long received at = region . get ( create received at key ( from cluster name , to cluster name ) ) ; if ( received at == null ) { connected = bool ; break ; } } } if ( connected ) { break ; } try { time unit . milliseconds . sleep ( check period ) ; } catch ( interrupted exception e ) { } } debug ( str ) ; }	Wait until all the clients received all the receivedAt entries.
public boolean wait for ( long timeout ) { debug ( str + timeout ) ; processing task connection check task = new processing task ( ) ; utils . execute ( connection check task , timeout ) ; boolean connected = connection check task . is connected ( ) ; debug ( str + connected ) ; return connected ; }	Waits for processing finished.
public void close ( ) { try { debug ( str ) ; client cache . close ( ) ; debug ( str + client cache . is closed ( ) ) ; } catch ( throwable t ) { debug ( str + t . get message ( ) , t ) ; } }	Finalizes work with the guest node.
public void print state ( boolean connected ) { if ( ! quiet ) { string builder sb = new string builder ( ) ; if ( connected ) { sb . append ( local cluster name ) . append ( str ) ; iterator < object > it = clusters properties . key set ( ) . iterator ( ) ; while ( it . has next ( ) ) { string cluster name = ( string ) it . next ( ) ; if ( local cluster name . equals ( cluster name ) ) { continue ; } long sent at = region . get ( create sent at key ( cluster name ) ) ; long received at = region . get ( create received at key ( cluster name , local cluster name ) ) ; long duration = received at - sent at ; sb . append ( str ) . append ( cluster name ) . append ( str ) . append ( duration ) . append ( str ) ; } } else { sb . append ( str ) . append ( local cluster name ) ; } system . out . println ( sb . to string ( ) ) ; } }	Prints the current state of connections.
public static void main ( string [ ] args ) { try { if ( args . length != num ) { utils . exit with failure ( ) ; } string cluster = args [ num ] ; properties clusters properties = properties helper . string to properties ( args [ num ] ) ; long timeout = long . parse long ( args [ num ] ) ; string region name = args [ num ] ; boolean debug enabled = ( str . equals ( args [ num ] ) ? bool : bool ) ; boolean quiet = ( str . equals ( args [ num ] ) ? bool : bool ) ; long processing started at = long . parse long ( args [ num ] ) ; guest node guest node = new guest node ( cluster , clusters properties , region name , debug enabled , quiet , processing started at ) ; boolean connected = guest node . wait for ( timeout ) ; guest node . print state ( connected ) ; guest node . close ( ) ; if ( connected ) { utils . exit with success ( ) ; } utils . exit with failure ( ) ; } catch ( throwable t ) { utils . exit with failure ( ) ; } }	Configures and starts the guest node.
public list < x > get ordered properties ( ) { final list < x > result = introspector . get properties ( clazz ) ; collections . sort ( result , new x . natural order ( ) ) ; return result ; }	Returns properties in "natural" order, i.e.
public short get version model hash code ( int version ) { list < x > class fields = get ordered properties ( ) ; string builder builder = new string builder ( ) ; for ( x field : class fields ) { if ( version == - num || version >= field . get property version ( ) ) { builder . append ( field . get type ( ) ) . append ( field . get name ( ) ) ; } } int hash code = builder . to string ( ) . hash code ( ) ; return ( short ) ( ( hash code & num ) ^ ( ( hash code & num ) > > num ) ) ; }	Returns a hash code of class model for specified bean version based on fields that this model contains.
public int get total number of pages ( ) throws query exception { prepare result data ( bool ) ; if ( is empty ( ) ) { return num ; } int total = total number of entries / this . page size ; if ( total number of entries % this . page size > num ) { total += num ; } return total ; }	Returns a total number of query pages.
@ suppress warnings ( str ) private list < v > get values ( list < object > entries keys for page ) { if ( entries keys for page . is empty ( ) ) { return collections . empty list ( ) ; } map < object , v > entries map = query region . get all ( entries keys for page ) ; list < v > entries = new array list < v > ( entries keys for page . size ( ) ) ; for ( object key : entries keys for page ) { entries . add ( entries map . get ( key ) ) ; } return entries ; }	Returns values for given keys.
@ suppress warnings ( { str } ) private void prepare result data ( boolean force ) throws query exception { if ( this . info loaded && ! force ) { return ; } page key page key = new key ( page number for general info ) ; list < object > query info = null ; if ( ! force ) { query info = paginated query info region . get ( page key ) ; } if ( query info == null ) { query query = query service . new query ( this . query string ) ; select results < object > results = null ; try { results = ( select results < object > ) query . execute ( page key . get query parameters ( ) ) ; } catch ( function domain exception e ) { handle exception ( e ) ; } catch ( type mismatch exception e ) { handle exception ( e ) ; } catch ( name resolution exception e ) { handle exception ( e ) ; } catch ( query invocation target exception e ) { handle exception ( e ) ; } if ( results . size ( ) > query limit ) { this . limit exceeded = bool ; this . total number of entries = query limit ; string msg = str + query limit + str ; logger . warn ( msg ) ; } else { limit exceeded = bool ; this . total number of entries = results . size ( ) ; } query info = arrays . as list ( new object [ ] { results . size ( ) , limit exceeded } ) ; store page ( page number for general info , query info ) ; list < object > keys = extract keys ( results ) ; store results ( keys ) ; } else { this . total number of entries = ( integer ) query info . get ( num ) ; this . limit exceeded = ( boolean ) query info . get ( num ) ; } this . info loaded = bool ; }	Stores paginated query info if it has not been stored yet.
private void store results ( list < object > result keys ) { if ( result keys . size ( ) > query limit ) { result keys = result keys . sub list ( num , query limit ) ; } int key number = num ; int page number = num ; list < object > page = new array list < object > ( ) ; for ( object key : result keys ) { if ( key number % get page size ( ) == num && key number != num ) { store page ( ++ page number , page ) ; page . clear ( ) ; } page . add ( key ) ; key number ++ ; } if ( page . size ( ) > num || page number == num ) { store page ( ++ page number , page ) ; } }	Stores paginated query pages and general info.
public t create ( object ... attributes ) {	Create an object with the given attributes.First builds the object, than persists it.
@ override public int compare ( final tag to category o1 , final tag to category o2 ) { if ( o1 == null && o2 == null ) return num ; if ( o1 == null ) return less than ; if ( o2 == null ) return greater than ; if ( o1 . get sorting ( ) == null && o2 . get sorting ( ) == null ) return compare second level ( o1 , o2 ) ; if ( o1 . get sorting ( ) == null ) return greater than ; if ( o2 . get sorting ( ) == null ) return less than ; if ( o1 . get sorting ( ) . equals ( o2 . get sorting ( ) ) ) return compare second level ( o1 , o2 ) ; return o1 . get sorting ( ) . compare to ( o2 . get sorting ( ) ) * greater than ; }	Sorting order is preferentially used to sort TagToCategory's, or the name of the Tag thatthe TagToCategory's point to are used if both TagToCategory's sorting orders are null.
private void migrate broken locales ( final prepared statement prepared stmt , final map < string , integer > locale map ) throws sql { final integer en us id = locale map . get ( str ) ; if ( en us id != null && en us id > num ) { migrate broken locale ( prepared stmt , locale map , str , en us id ) ; migrate broken locale ( prepared stmt , locale map , str , en us id ) ; migrate broken locale ( prepared stmt , locale map , str , en us id ) ; migrate broken locale ( prepared stmt , locale map , str , en us id ) ; } }	Migrates locales from a very early version of PressGang that was using the wrong locale value.
public static boolean recalculate min hash ( final topic topic , final list < xor > min hash xo ) { boolean ret value = bool ; final set < min hash > existing min hashes = topic . get min hashes ( ) ; final map < integer , integer > min hashes = get min hashes ( topic . get topic xml ( ) , min hash xo ) ; for ( final integer func id : min hashes . key set ( ) ) { boolean found = bool ; for ( final min hash min hash : existing min hashes ) { if ( min hash . get min hash func id ( ) . equals ( func id ) ) { if ( ! min hash . get min hash ( ) . equals ( min hashes . get ( func id ) ) ) { min hash . set min hash ( min hashes . get ( func id ) ) ; ret value = bool ; } found = bool ; break ; } } if ( ! found ) { ret value = bool ; final min hash min hash = new min hash ( ) ; min hash . set min hash func id ( func id ) ; min hash . set min hash ( min hashes . get ( func id ) ) ; topic . add min hash ( min hash ) ; } } return ret value ; }	Recalculate the min hash signature for a topic.
public static map < integer , integer > get min hashes ( final string xml , final list < xor > min hash xo ) { final map < integer , integer > ret value = new hash map < integer , integer > ( ) ;	Generate the min hashes.
protected static string clean xml ( final string xml ) {	Cleans the provided XML by removing element names and other useless data.
public static void validate and fix relationships ( final topic topic ) { final array list < topic to topic > remove list = new array list < topic to topic > ( ) ; for ( final topic to topic topic to topic : topic . get parent topic to topics ( ) ) if ( topic to topic . get related topic ( ) . get topic id ( ) . equals ( topic . get topic id ( ) ) ) remove list . add ( topic to topic ) ; for ( final topic to topic topic to topic : remove list ) topic . get parent topic to topics ( ) . remove ( topic to topic ) ; final array list < topic to topic > remove child list = new array list < topic to topic > ( ) ; for ( final topic to topic topic to topic : topic . get child topic to topics ( ) ) if ( topic to topic . get main topic ( ) . get topic id ( ) . equals ( topic . get topic id ( ) ) ) remove child list . add ( topic to topic ) ; for ( final topic to topic topic to topic : remove child list ) topic . get child topic to topics ( ) . remove ( topic to topic ) ; }	Validate and Fix a topics relationships to ensure that the topics related topics are still matched by the Related Topicsthemselves.
public static void update content hash ( final topic topic ) { if ( topic . get topic xml ( ) != null ) { topic . set topic content hash ( hash utilities . generate sh ( topic . get topic xml ( ) ) . to char array ( ) ) ; } }	Set the content hash on the topic.
public static void validate and fix tags ( final topic topic ) {	Validate and Fix a topics tags so that mutually exclusive tags are enforced and also remove any tags that may have beenduplicated.
public static sorted map < package doc , sorted set < class doc > > sort classes per package ( final class doc ... class docs ) { final sorted map < package doc , sorted set < class doc > > to return = new tree map < > ( comparators . package name comparator ) ; if ( class docs != null ) { arrays . stream ( class docs ) . for each ( current -> {	Sorts all given ClassDocs into a SortedMap keyed by their respective PackageDocs.
@ override @ suppress warnings ( str ) public final void execute ( final enforcer rule helper helper ) throws enforcer rule exception { final maven project project ; try { project = ( maven project ) helper . evaluate ( str ) ; } catch ( final expression evaluation exception e ) {	This is the interface into the rule.
protected static list < string > splice ( final string to splice ) { final list < string > to return = new array list < string > ( ) ; final string tokenizer tok = new string tokenizer ( to splice , str , bool ) ; while ( tok . has more tokens ( ) ) { to return . add ( tok . next token ( ) ) ; } return to return ; }	Helper method which splices the provided string into a List, separating on commas.
protected static list < pattern > splice2 pattern ( final string to splice ) throws pattern syntax exception { final list < pattern > to return = new array list < pattern > ( ) ; for ( final string current : splice ( to splice ) ) { to return . add ( pattern . compile ( current ) ) ; } return to return ; }	Helper method which splices the provided String into a List of Pattern instances.
protected static boolean contains prefix ( final list < string > source , final string to check ) { if ( source != null ) { for ( final string current : source ) { if ( to check . starts with ( current ) ) { return bool ; } } }	Checks if any element within source startsWith the provided toCheck string.
private static class < ? extends object factory > get factory class ( class < ? > factory class ) { if ( factory packages . size ( ) == num ) throw new illegal argument exception ( str ) ; if ( factory classes == null ) { factory classes = new hash map < class < ? > , class < ? extends object factory > > ( ) ; set < class < ? extends object factory > > classes = reflection utils . get subclasses of ( object factory . class , factory packages ) ; for ( class < ? extends object factory > clazz : classes ) { if ( ! modifier . is abstract ( clazz . get modifiers ( ) ) ) { try { constructor constructor = clazz . get constructor ( ) ; object factory factory = ( object factory ) constructor . new instance ( ) ; factory classes . put ( factory . get factory class ( ) , factory . get class ( ) ) ; } catch ( exception e ) { throw new runtime exception ( e ) ;	Get the class of the Factory for the given factoryClass.
public void send ( string subject , string content ) throws messaging exception { mime message message = compose ( subject , content , properties helper . get string property ( str ) ) ; transport ( message ) ; }	Sends email with subject and content to receivers specified in property file after key "mail.to".
public void send ( string subject , string content , string to ) throws messaging exception { mime message message = compose ( subject , content , to ) ; transport ( message ) ; }	Sends email with subject and content to receivers specified by argument "to".
private int execute zero function ( pool pool ) throws function exception , interrupted exception { int result = - num ; result collector < ? , ? > collector = function service . on server ( pool ) . execute ( new zero function ( ) ) ; list < ? > function result = ( list < ? > ) collector . get result ( ) ; if ( ( function result != null ) && ( function result . size ( ) == num ) && ( function result . get ( num ) instanceof integer ) ) { result = ( integer ) function result . get ( num ) ; } return result ; }	Executes the "zero" function using pool for the concrete server.
@ override @ suppress warnings ( { str , str } ) public void execute ( function context function context ) { result sender < serializable > result sender = function context . get result sender ( ) ; region function context region function context = ( region function context ) function context ; if ( function context . get arguments ( ) == null ) { handle exception ( new function exception ( str ) , result sender , null ) ; return ; } if ( ! ( function context . get arguments ( ) instanceof bucket oriented query function argument ) ) { handle exception ( new function exception ( str + bucket oriented query function argument . class . get name ( ) + str ) , result sender , null ) ; return ; } bucket oriented query function argument argument = ( bucket oriented query function argument ) function context . get arguments ( ) ; local data set local data = ( local data set ) partition region helper . get local data for context ( region function context ) ; query service query service = local data . get cache ( ) . get query service ( ) ; string query str = argument . get query string ( ) ; try { query query = query service . new query ( query str ) ; select results < ? > result = ( select results < ? > ) local data . execute query ( ( default query ) query , argument . get query parameters ( ) , local data . get bucket set ( ) ) ; result sender . last result ( ( serializable ) format results ( result ) ) ; } catch ( exception e ) { handle exception ( e , result sender , query str ) ; } }	Executes query using arguments query string and query parameters.
@ suppress warnings ( { str } ) private void handle exception ( throwable e , result sender < serializable > result sender , string query string ) { logger . error ( str + ( query string != null ? str + query string : str ) , e ) ; result sender . send exception ( new function exception ( e . get message ( ) ) ) ; }	Handles exceptions during query execution.
private list < object > format results ( select results < ? > select results ) { list < object > results = new array list < object > ( select results . size ( ) + num ) ; results . add all ( select results . as list ( ) ) ; results . add ( select results . get collection type ( ) . get element type ( ) ) ; return results ; }	Formats results of query execution.
@ override public final void add error message ( final string message ) { if ( message == null || str . equals ( message ) ) { return ; }	Adds the provided error message to this ErrorMessageContainer.
@ override public string get message ( ) { final string builder builder = new string builder ( ) ; for ( final string current : error messages ) { builder . append ( current ) . append ( str ) ; }	Returns the detail message string of this throwable.
public static boolean is socket alive ( string host , int port ) { boolean socket alive = bool ; socket socket = null ; try { socket = new socket ( host , port ) ; socket alive = socket . is connected ( ) ; } catch ( throwable t ) {	Checks if the socket of specified host and port is alive.
public static void execute ( thread thread , long timeout ) { thread . start ( ) ; try { thread . join ( timeout ) ; } catch ( interrupted exception e ) {	Executes the thread with specified timeout.
private boolean has resources ( list < resource > resources ) { for ( resource resource : resources ) { if ( new file ( resource . get directory ( ) ) . exists ( ) ) { return bool ; } } return bool ; }	Check if any of the resources exist.
private void merge deprecated info ( ) throws maven report exception { if ( str . equals ( config location ) && ! str . equals ( format ) ) { config location = format to config location . get ( format ) ; throw new maven report exception ( str + config location + str ) ; } if ( string utils . is empty ( properties location ) ) { if ( properties file != null ) { properties location = properties file . get path ( ) ; throw new maven report exception ( str + str + properties location + str ) ; } else if ( properties url != null ) { properties location = properties url . to external form ( ) ; throw new maven report exception ( str + str + properties location + str ) ; } } if ( str . equals ( header location ) ) { file default header file = new file ( project . get basedir ( ) , str ) ; if ( ! default header file . equals ( header file ) ) { header location = header file . get path ( ) ; } } if ( string utils . is empty ( suppressions location ) ) { suppressions location = suppressions file ; if ( string utils . is not empty ( suppressions file ) ) { throw new maven report exception ( str + str + suppressions location + str ) ; } } if ( string utils . is empty ( package names location ) ) { package names location = package names file ; if ( string utils . is not empty ( package names file ) ) { throw new maven report exception ( str + str + suppressions location + str ) ; } } }	Merge in the deprecated parameters to the new ones, unless the newparameters have values.
public static string add query limit ( string query string , int query limit ) { int limit index = query string . last index of ( str ) ; if ( limit index == - num ) { limit index = query string . last index of ( str ) ; } if ( limit index == - num ) { return query string + str + ( query limit + num ) ; } int limit number = integer . parse int ( query string . substring ( limit index + num ) . trim ( ) ) ; return ( limit number > query limit ) ? query string . substring ( num , limit index ) + str + ( query limit + num ) : query string ; }	Limits query results.
public static string [ ] get first locator from locators string ( string locators string ) { if ( locators string == null || locators string . length ( ) == num ) { return new string [ num ] ; } string [ ] first locator = new string [ num ] ; first locator [ num ] = locators string . substring ( num , locators string . index of ( str ) ) . trim ( ) ; locators string = locators string . substring ( locators string . index of ( str ) + num ) ; first locator [ num ] = locators string . substring ( num , locators string . index of ( str ) ) ; return first locator ; }	Returns first locator host and port from locators string.
public static int get region size ( region < ? , ? > region ) { function function = new region size function ( ) ; function service . register function ( function ) ; result collector < ? , ? > rc = function service . on region ( region ) . with collector ( new region size result collector ( ) ) . execute ( function ) ; return ( integer ) rc . get result ( ) ; }	Returns approximate number of entries in the region.
public static boolean is gem fire client ( ) { gem fire cache impl impl = ( gem fire cache impl ) cache factory . get any instance ( ) ; return impl != null && impl . is client ( ) ; }	Checks if the current GemFire is a client instance.
public static < k > void remove all ( region < k , ? > region , set < k > keys ) { if ( keys == null ) { throw new null pointer exception ( ) ; } if ( keys . is empty ( ) ) {	Removes several entries from region in a single hop.
public static < t > t retry with exponential backoff ( retryable < t > runnable , int max retries ) throws interrupted exception , operation retry failed exception { int retry = num ; while ( retry < max retries ) { retry ++ ; try { return runnable . execute ( ) ; } catch ( operation require retry exception e ) {	Retries passed operation with random exponential back off delay.
protected void generate buffered image ( transcoder input in , int w , int h ) throws transcoder exception { buffered image transcoder t = new buffered image transcoder ( ) ; if ( w != num && h != num ) { t . set dimensions ( w , h ) ; } t . transcode ( in , null ) ; buffered image = t . get buffered image ( ) ; width = buffered image . get width ( ) ; height = buffered image . get height ( ) ; }	Generate the BufferedImage.
@ override public void paint icon ( component c , graphics g , int x , int y ) { if ( background colour == null ) g . draw image ( buffered image , x , y , null ) ; else g . draw image ( buffered image , x , y , background colour , null ) ; }	Draw the icon at the specified location.
private static buffered reader get reader ( ) { if ( buffered reader == null ) { buffered reader = new buffered reader ( new input stream reader ( system . in ) ) ; } return buffered reader ; }	Method getReader returns the reader of this ConsoleUtils object.
public static void wait for enter ( string message ) { system . out . println ( message ) ; try { get reader ( ) . read line ( ) ; } catch ( io e ) { e . print stack trace ( ) ;	Waits for enter with specified message.
public void execute ( string [ ] args , boolean debug enabled , boolean quiet ) { try { this . debug enabled = debug enabled ; debug ( str + arrays . as list ( args ) ) ; parse command line arguments ( args ) ; system . out . println ( str ) ; debug ( str + clusters properties + str + timeout + str + region name ) ; processor task task = new processor task ( clusters properties , timeout , region name , debug enabled , quiet ) ; debug ( str ) ; utils . execute ( task , timeout + delta timeout ) ; int exit code = task . get exit code ( ) ; debug ( str + exit code ) ; if ( exit code == num ) { utils . exit with success ( ) ; } utils . exit with failure ( ) ; } catch ( throwable t ) { debug ( str + t . get message ( ) , t ) ; utils . exit with failure ( str , t ) ; } }	Runs the tool. All the tools run in this way.
protected void parse command line arguments ( string [ ] command line arguments ) { options options = construct gnu options ( ) ; if ( command line arguments . length < num ) { print help ( options ) ; } command line parser parser = new gnu parser ( ) ; try { command line line = parser . parse ( options , command line arguments ) ; if ( line . has option ( help option ) ) { print help ( options ) ; } if ( line . has option ( region option ) ) { region name = line . get option value ( region option ) ; } if ( line . has option ( timeout option ) ) { string timeout string = line . get option value ( timeout option ) ; timeout = long . parse long ( timeout string ) ; } if ( line . has option ( cluster option ) ) { clusters properties = line . get option properties ( cluster option ) ; if ( clusters properties . key set ( ) . size ( ) < num ) { utils . exit with failure ( str ) ; } } else { utils . exit with failure ( str ) ; } } catch ( throwable t ) { utils . exit with failure ( str , t ) ; } }	Parses command-line arguments and sets the local variables.
protected void print help ( final options options ) { help formatter formatter = new help formatter ( ) ; formatter . print help ( str , options ) ; utils . exit with failure ( ) ; }	Prints help if requested, or in case of any misconfiguration.
protected options construct gnu options ( ) { final options gnu options = new options ( ) ; gnu options . add option ( str , timeout option , bool , str + default timeout ) . add option ( str , region option , bool , str + default region name + str ) . add option ( str , help option , bool , str ) ; @ suppress warnings ( str ) option locators option = option builder . has args ( ) . with description ( str + str + str ) . with value separator ( ) . with arg name ( str ) . with long opt ( cluster option ) . create ( str ) ; gnu options . add option ( locators option ) ; return gnu options ; }	Constructs the set of GNU options.
private static void aggregate single cluster member data ( list < result collector > task results ) { for ( result collector single cluster : task results ) { list members result = ( list ) single cluster . get result ( ) ; for ( object result from node : members result ) { system . out . print ( ( ( hash map ) result from node ) . get ( str ) + str ) ; } system . out . println ( ) ; } }	only for partitioned region!.
public expression builder not null ( final object property , final string name ) { if ( property == null ) { message container . add error message ( str + name + str ) ; } return this ; }	Adds a description for a null property.
private static void parse command line arguments ( string [ ] command line arguments ) { options options = construct gnu options ( ) ; command line parser parser = new gnu parser ( ) ; try { command line line = parser . parse ( options , command line arguments ) ; if ( line . has option ( help option ) ) { print help ( options ) ; } if ( line . has option ( debug option ) ) { debug enabled = bool ; } if ( ! debug enabled && line . has option ( quiet option ) ) { quiet = bool ; } } catch ( throwable t ) { print help ( options ) ; } }	Parses command line arguments.
private static void print help ( final options options ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; command [ ] commands = command . values ( ) ; for ( int i = num ; i < commands . length ; i ++ ) { sb . append ( commands [ i ] . get name ( ) ) ; if ( i < ( commands . length - num ) ) { sb . append ( str ) ; } } sb . append ( str ) ; help formatter formatter = new help formatter ( ) ; formatter . print help ( sb . to string ( ) , options ) ; utils . exit with failure ( ) ; }	Prints help if requested.
private static options construct gnu options ( ) { final options gnu options = new options ( ) ; gnu options . add option ( str , debug option , bool , str ) . add option ( str , quiet option , bool , str + debug option + str ) . add option ( str , help option , bool , str ) ; return gnu options ; }	Constructs the set of GNU options.
private static int find command index ( string [ ] args ) { int command index = - num ; for ( int i = num ; i < args . length ; i ++ ) { for ( command command : command . values ( ) ) { if ( command . get name ( ) . equals ( args [ i ] . trim ( ) ) ) { command index = i ; break ; } } } return command index ; }	Looks for the index of command in the specified array.
private static string [ ] extract launcher args ( string [ ] args , int command index ) { string [ ] launcher args = new string [ command index ] ; system . arraycopy ( args , num , launcher args , num , command index ) ; return launcher args ; }	Extracts the launcher arguments from the all arguments array.
private static string [ ] extract command args ( string [ ] args , int command index ) { string [ ] command args = new string [ args . length - command index - num ] ; system . arraycopy ( args , command index + num , command args , num , args . length - command index - num ) ; return command args ; }	Extracts the command-specific arguments from the all arguments array.
public static void main ( string [ ] args ) { try { int command index = find command index ( args ) ; if ( command index < num ) { print help ( ) ; } string [ ] launcher args = extract launcher args ( args , command index ) ; string [ ] command args = extract command args ( args , command index ) ; parse command line arguments ( launcher args ) ; debug ( str + arrays . as list ( args ) ) ; debug ( str + arrays . as list ( launcher args ) ) ; debug ( str + arrays . as list ( command args ) ) ; string command name = args [ command index ] ; executable tool = command . get util ( command name ) ; if ( tool != null ) { tool . execute ( command args , debug enabled , quiet ) ; } else { debug ( str + command name + str ) ; print help ( ) ; } } catch ( throwable t ) { debug ( str + t . get message ( ) , t ) ; utils . exit with failure ( str , t ) ; } }	The entry point of the application.
private static void debug ( string message , throwable t ) { if ( debug enabled ) { system . err . println ( str + message ) ; if ( t != null ) { t . print stack trace ( system . err ) ; } } }	Prints debug information if debug is enabled.
private void start ( ) { try { timer . schedule ( new is alive timer task ( ) , num , period ) ; } catch ( throwable t ) { utils . exit with failure ( str , t ) ; } }	Starts the checking task.
public set < region < ? , ? > > create regions ( map < string , string > region names ) { set < region < ? , ? > > regions = new hash set < region < ? , ? > > ( ) ; proxy region factory = cache . create client region factory ( client region shortcut . proxy ) ; for ( string region path : region names . key set ( ) ) { region region = create region ( region path , region names . get ( region path ) ) ; regions . add ( region ) ; } return regions ; }	Creates regions structure similar to server region structure.
public long process ( region < ? , ? > region , expiration policy policy ) { long destroyed entries number = num ; try { if ( region == null ) { throw new illegal state exception ( str ) ; } if ( policy == null ) { throw new illegal argument exception ( str ) ; } logger . info ( str + region + str + policy + str + packet size + str + packet delay ) ; destroyed entries count collector collector = ( destroyed entries count collector ) function service . on region ( region ) . with args ( new expiration function arguments ( packet size , packet delay ) ) . with collector ( new destroyed entries count collector ( ) ) . execute ( new expiration function ( policy ) ) ; object result = collector . get result ( ) ; if ( result instanceof long ) { destroyed entries number = ( long ) result ; } logger . info ( str + region + str + policy + str + packet size + str + packet delay + str + destroyed entries number + str ) ; } catch ( runtime exception re ) { logger . error ( str , re ) ; throw re ; } return destroyed entries number ; }	Applies the specified policy on the specified region and returns numberof destroyed entries.
public final void set indentation token ( final string indentation token ) {	Assigns the indentationToken of this RenderConfiguration.
@ override public string get package ( final file source file ) { string a line = get package ( source file , package statement ) ; if ( a line != null ) return a line ;	Retrieves the package definition from the supplied sourceFile.
public static boolean start ( final root doc root ) {	Generate documentation here.This method is required for all doclets.
private set < integer > extract ports set ( system member member ) throws admin exception { set < integer > ports set = new hash set < integer > ( ) ; system member cache cache = member . get cache ( ) ; if ( cache != null ) { system member cache server [ ] cache servers = cache . get cache servers ( ) ; if ( cache servers != null ) { for ( system member cache server cache server : cache servers ) { ports set . add ( cache server . get port ( ) ) ; } } } return ports set ; }	Extracts port from the SystemMember object.
private pool find or create pool ( string host , int port ) { string pool name = utils . to key ( host , port ) ; pool pool = pool manager . find ( pool name ) ; if ( pool == null ) { pool factory . reset ( ) ; pool factory . add server ( host , port ) ; pool = pool factory . create ( pool name ) ; } return pool ; }	Looks for the existing pool with name poolFactory.
public static string get name ( string event src name ) { if ( event src name == null ) { return null ; } if ( event src name . ends with ( str ) ) { event src name = event src name . substring ( num , event src name . length ( ) - num ) ; } return event src name . substring ( event src name . last index of ( str ) + num ) ; }	Get the rule name from an audit event source name.
public static string get category ( string event src name ) { if ( event src name == null ) { return null ; } int end = event src name . last index of ( str ) ; event src name = event src name . substring ( num , end ) ; if ( checkstyle package . equals ( event src name ) ) { return str ; } else if ( ! event src name . starts with ( checkstyle package ) ) { return str ; } return event src name . substring ( event src name . last index of ( str ) + num ) ; }	Get the rule category from an audit event source name.
public static void enter frame ( string class name ) { int counter = local . get ( ) . increment and get ( ) ; class names . get ( ) . add ( class name ) ; if ( counter == max stack depth ) { throw new runtime exception ( stack overflow msg + get class names ( ) ) ; } }	Increment the counter.
public static void exit frame ( string class name ) { int counter = local . get ( ) . decrement and get ( ) ; if ( counter < num ) { string error message = str + get class names ( ) ; clear counter ( ) ; throw new runtime exception ( error message ) ; } string frame to exit = class names . get ( ) . remove ( class names . get ( ) . size ( ) - num ) ; if ( ! class name . equals ( frame to exit ) ) { throw new runtime exception ( str + class name + str + frame to exit + str + get class names ( ) ) ; } }	Decrement the counter and remove class name from the list.
private static string get class names ( ) { string builder result = new string builder ( str ) ; for ( string class name : class names . get ( ) ) { result . append ( class name ) . append ( str ) ; } return result . to string ( ) ; }	Creates string with all classes that have been entered by method frame counter.
public final void set package extractors ( final string package extractor implementations ) throws illegal argument exception {	Splices the supplied packageExtractorImplementations argument, which is assumed to be a comma-separatedstring holding fully qualified class names of the PackageExtractor implementations which should be usedby this CorrectPackagingRule.
private void add packages ( final file file or directory , final sorted map < string , sorted set < string > > package2 file names map ) { for ( package extractor current : package extractors ) { final file filter source file definition filter = current . get source file filter ( ) ; if ( file or directory . is file ( ) && source file definition filter . accept ( file or directory ) ) {	Adds all source file found by recursive search under sourceRoot to thetoPopulate List, using a width-first approach.
@ pre persist @ pre update private void update image data ( ) throws custom constraint violation exception { thumbnail = create image ( bool ) ; image file . validate ( ) ; if ( image data != null ) { image content hash = hash utilities . generate sh ( image data ) . to char array ( ) ; } }	Create the thumbnails, and make sure the parent imagefile is valid.
public void set ui original file name ( final string ui original file name ) { this . ui original file name = ui original file name ; if ( this . ui original file name != null && ! this . ui original file name . is empty ( ) ) original file name = this . ui original file name ; }	The UI will attempt to assign an empty value if the file upload box does not have a file selected.
private static int extract limit ( string query string ) { int limit index = query string . last index of ( str ) ; if ( limit index == - num ) { limit index = query string . last index of ( str ) ; } if ( limit index == - num ) { return limit index ; } string limit value = query string . substring ( limit index + num ) ; return integer . parse int ( limit value . trim ( ) ) ; }	Extracts limit value from query string.
@ suppress warnings ( { str } ) private static select results < object > format select results ( list < list < object > > query results , int limit ) { list < object > list = new array list < object > ( ) ; object type base element type = null ; for ( list < object > query result : query results ) { object type element type = ( object type ) query result . remove ( query result . size ( ) - num ) ; if ( base element type == null ) { base element type = element type ; } else if ( ! base element type . equals ( element type ) ) { throw new illegal state exception ( str ) ; } list . add all ( query result ) ; if ( limit != - num && list . size ( ) >= limit ) { break ; } } return limit == - num ? new results collection wrapper ( base element type , list ) : new results collection wrapper ( base element type , list , limit ) ; }	Collects and formats query results into SelectResults.
private static void check allowed in real time0 ( object obj , int depth ) throws invalid class exception { if ( depth >= method frame counter . max stack depth ) {	With stack counter.
public process run with confirmation ( string id , class < ? > klass , string [ ] java arguments , string [ ] process arguments ) throws io , interrupted exception { process process = start process ( id , klass , java arguments , process arguments , bool ) ; wait confirmation ( klass . get simple name ( ) , process ) ; new stream redirector ( process . get input stream ( ) , klass . get simple name ( ) + process stdout stream prefix , redirect process input stream to parent process std out ) . start ( ) ; return process ; }	Runs process based on a specified class in a separate VM using array ofarguments.
public process run with startup delay ( class < ? > klass , string [ ] java arguments , string [ ] process arguments ) throws io , interrupted exception , timeout exception { return run with startup delay ( klass , java arguments , process arguments , default process startup shutdown time ) ; }	Runs process with arguments based on a specified class in a separate VM.Waits DEFAULT_PROCESS_STARTUP_TIME before returns the created process toa caller.
public process run with startup delay ( class < ? > klass , string [ ] java arguments , string [ ] process arguments , long process startup time ) throws io , interrupted exception , timeout exception { process process = run with confirmation ( str , klass , java arguments , process arguments ) ; if ( process startup time > num ) { thread . sleep ( process startup time ) ; } return process ; }	Runs process with arguments based on a specified class in a separate VM.Waits processStartupTime before returns the created process to a caller.
public void stop by sending new line into process ( process process ) throws io , interrupted exception { if ( process != null ) { buffered writer writer = new buffered writer ( new output stream writer ( process . get output stream ( ) ) ) ; writer . new line ( ) ; writer . flush ( ) ; process . wait for ( ) ; } }	Stops process by sending new line to it's output stream.The process can be stopped by calling destroy() method.
private process start process ( string id , class < ? > klass , string [ ] java arguments , string [ ] process arguments , boolean with confirmation ) throws io , interrupted exception { list < string > arguments = create command line for process ( klass , java arguments , process arguments ) ; process process = new process builder ( arguments ) . start ( ) ; redirect process streams ( id , klass , process , ! with confirmation ) ; return process ; }	Starts process based on specified class using command line arguments.This process inherits a classpath from parent VM that starts it.
private void redirect process streams ( string id , class < ? > klass , process process , boolean redirect process std out ) { string error stream type = ( print type ? klass . get simple name ( ) + id + process error stream prefix : str ) ; new stream redirector ( process . get error stream ( ) , error stream type , redirect process error stream to parent process std out , system . err ) . start ( ) ; if ( redirect process std out ) { string output stream type = ( print type ? klass . get simple name ( ) + id + process stdout stream prefix : str ) ; new stream redirector ( process . get input stream ( ) , output stream type , redirect process input stream to parent process std out , system . out ) . start ( ) ; } }	Redirects process standard output and error streams into parent processstandard output.
private void wait confirmation ( string class name , process process ) throws io , interrupted exception { system . out . println ( str + class name + str ) ; buffered reader buffered reader = new buffered reader ( new input stream reader ( process . get input stream ( ) ) ) ; string line ; while ( ( line = buffered reader . read line ( ) ) != null ) { if ( line . equals ( process startup completed ) ) { system . out . println ( str + class name + str ) ; return ; } else if ( redirect process input stream to parent process std out ) { system . out . println ( class name + process stdout stream prefix + line ) ; } } throw new interrupted exception ( str + class name + str + str ) ; }	Waits startup complete confirmation from process.
public void generate ( string output filename , string template , context context ) throws velocity exception , mojo execution exception , io { writer writer = null ; try { file f = new file ( output filename ) ; if ( ! f . get parent file ( ) . exists ( ) ) { f . get parent file ( ) . mkdirs ( ) ; } writer = new file writer ( f ) ; get velocity ( ) . get engine ( ) . merge template ( template directory + str + template , context , writer ) ; } catch ( resource not found exception e ) { throw new resource not found exception ( str + template directory + str + template , e ) ; } catch ( velocity exception | io e ) { throw e ;	Using a specified Velocity Template and provided context, create the outputFilename.
public int process ( ) throws io , interrupted exception { debug ( str ) ; properties gemfire properties = properties helper . filter properties ( system . get properties ( ) , str ) ; string [ ] vm options = properties helper . properties to vm ( gemfire properties ) ; debug ( str + arrays . as list ( vm options ) ) ; list < process > processes list = new array list < process > ( ) ; for ( object key object : clusters properties . key set ( ) ) { string cluster = ( string ) key object ; string clusters properties string = properties helper . properties to string ( clusters properties ) ; debug ( str + cluster + str + clusters properties string + str + timeout + str + region name ) ; process process = java process launcher . run without confirmation ( str , guest node . class , vm options , new string [ ] { cluster , clusters properties string , string . value of ( timeout ) , region name , string . value of ( debug enabled ) , string . value of ( quiet ) , string . value of ( processing started at ) } ) ; debug ( str ) ; processes list . add ( process ) ; } debug ( str ) ; int main exit code = num ; int process number = num ; for ( process process : processes list ) { debug ( str + process number ) ; int exit code = process . wait for ( ) ; if ( exit code != num ) { main exit code = num ; } debug ( str + process number + str + exit code ) ; process number ++ ; } debug ( str + main exit code ) ; return main exit code ; }	Creates, configures and runs the guest nodes and collects informationform them.
public static boolean is a ( class clazz , parameterized type p type ) { return clazz . is assignable from ( ( class ) p type . get raw type ( ) ) ; }	Is the genericType of a certain class?.
public static boolean is compatible ( method method , method intf method ) { if ( method == intf method ) return bool ; if ( ! method . get name ( ) . equals ( intf method . get name ( ) ) ) return bool ; if ( method . get parameter types ( ) . length != intf method . get parameter types ( ) . length ) return bool ; for ( int i = num ; i < method . get parameter types ( ) . length ; i ++ ) { class root param = method . get parameter types ( ) [ i ] ; class intf param = intf method . get parameter types ( ) [ i ] ; if ( ! intf param . is assignable from ( root param ) ) return bool ; } return bool ; }	See if the two methods are compatible, that is they have the samerelative signature.
public static method get implementing method ( class clazz , method intf method ) { class < ? > declaring class = intf method . get declaring class ( ) ; if ( declaring class . equals ( clazz ) ) return intf method ; class [ ] param types = intf method . get parameter types ( ) ; if ( declaring class . get type parameters ( ) . length > num && param types . length > num ) { type [ ] intf types = find parameterized types ( clazz , declaring class ) ; map < string , type > type var map = new hash map < string , type > ( ) ; type variable < ? extends class < ? > > [ ] vars = declaring class . get type parameters ( ) ; for ( int i = num ; i < vars . length ; i ++ ) { if ( intf types != null && i < intf types . length ) { type var map . put ( vars [ i ] . get name ( ) , intf types [ i ] ) ; } else {	Given a method and a root class, find the actual method declared in theroot that implements the method.
public static class < ? > get type argument ( type generic type ) { if ( ! ( generic type instanceof parameterized type ) ) return null ; parameterized type parameterized type = ( parameterized type ) generic type ; class < ? > type arg = ( class < ? > ) parameterized type . get actual type arguments ( ) [ num ] ; return type arg ; }	Returns the type argument from a parameterized type.
public static type resolve type variable ( class < ? > root , type variable < ? > type variable ) { if ( type variable . get generic declaration ( ) instanceof class < ? > ) { class < ? > class declaring type variable = ( class < ? > ) type variable . get generic declaration ( ) ; type [ ] types = find parameterized types ( root , class declaring type variable ) ; if ( types == null ) return null ; for ( int i = num ; i < types . length ; i ++ ) { type variable < ? > tv = class declaring type variable . get type parameters ( ) [ i ] ; if ( tv . equals ( type variable ) ) { return types [ i ] ; } } } return null ; }	Finds an actual value of a type variable.
public static type [ ] get actual type arguments of an interface ( class < ? > class to search , class < ? > interface to find ) { type [ ] types = find parameterized types ( class to search , interface to find ) ; if ( types == null ) throw new runtime exception ( str + interface to find ) ; return types ; }	Given a class and an interfaces, go through the class hierarchy to findthe interface and return its type arguments.
private void populate ( ) throws exception { list < t > initializer = new array list < t > ( this . get min idle ( ) ) ; for ( int idx = num ; idx < this . get min idle ( ) && ( this . get max idle ( ) == disabled || idx < this . get max idle ( ) ) && ( this . get max active ( ) == disabled || idx < this . get max active ( ) ) ; idx ++ ) { initializer . add ( this . borrow object ( ) ) ; } for ( int idx = num ; idx < this . get min idle ( ) && ( this . get max idle ( ) == disabled || idx < this . get max idle ( ) ) && ( this . get max active ( ) == disabled || idx < this . get max active ( ) ) ; idx ++ ) { this . return object ( initializer . get ( idx ) ) ; } }	Populate the pool up to minIdle instances.
private void add return option description ( method method , return . return builder return builder ) { doc return return anno = get non exception doc return ( method ) ; string return option desc = ( return anno == null ) ? null : return anno . description ( ) ; return builder . description ( string utils . is empty ( return option desc ) ? null : return anno . description ( ) ) ; }	Used for non exception return option.
private void return object ( object pool < classifier > pool , classifier object ) { try { pool . return object ( object ) ; } catch ( exception e ) { logger . error ( str , e ) ; } }	Returns the given object to the pool.
private destination get destination ( final string destination name ) { if ( ! destinations . contains key ( destination name ) ) { destination destination = destination supplier . apply ( destination name ) ; destinations . put ( destination name , destination ) ; } return destinations . get ( destination name ) ; }	Get the destination.
private message consumer get consumer ( final string destination name ) { if ( ! consumers . contains key ( destination name ) ) { session session = get session ( ) ; destination destination = get destination ( destination name ) ; try { message consumer consumer = session . create consumer ( destination ) ; consumers . put ( destination name , consumer ) ; } catch ( jms e ) { throw new jms exception ( str + destination name , e ) ; } } return consumers . get ( destination name ) ; }	Get the `MessageConsumer`.
private message producer get producer ( final string destination name ) { if ( ! producers . contains key ( destination name ) ) { session session = get session ( ) ; destination destination = get destination ( destination name ) ; message producer producer ; try { producer = session . create producer ( destination ) ; } catch ( jms e ) { throw new jms exception ( str + destination name , e ) ; } producers . put ( destination name , producer ) ; } return producers . get ( destination name ) ; }	Get the `MessageProducer` or create one from the JMS session.
private session get session ( ) { if ( ! session option . is present ( ) ) { try { session option = optional . of ( get connection ( ) . create session ( transacted , acknowledge mode ) ) ; } catch ( jms e ) { throw new jms exception ( str , e ) ; } } return session option . get ( ) ; }	Get the current session or create one from the JMS connection.
private connection get connection ( ) { if ( ! connection option . is present ( ) ) { final connection connection = connection supplier . get ( ) ; if ( connection instanceof mq ) { ( ( mq ) connection ) . add transport listener ( new transport listener ( ) { @ override public void on command ( object command ) { } @ override public void on exception ( io error ) { } @ override public void transport interupted ( ) { connected . set ( bool ) ; } @ override public void transport resumed ( ) { connected . set ( bool ) ; } } ) ; } connected . set ( bool ) ; if ( start connection ) { try { connection . start ( ) ; } catch ( jms e ) { throw new jms exception ( str , e ) ; } } connection option = optional . of ( connection ) ; } return connection option . get ( ) ; }	Get the current connection or create one using the connectionSupplier.
public void send text message with destination ( final string destination name , final string message content ) { if ( ! this . is connected ( ) ) { throw new jms not connected exception ( str + destination name ) ; } final session session = get session ( ) ; final message producer producer = get producer ( destination name ) ; try { text message message = session . create text message ( message content ) ; producer . send ( message ) ; } catch ( jms e ) { throw new jms exception ( str + destination name , e ) ; } }	Send a text message given a queue or topic name and a text message.
public void listen text messages with destination ( final string destination name , final consumer < string > message listener ) { final message consumer consumer = get consumer ( destination name ) ; try { consumer . set message listener ( message -> { try { message listener . accept ( ( ( text message ) message ) . get text ( ) ) ; if ( acknowledge mode == session . client acknowledge ) { message . acknowledge ( ) ; } } catch ( jms e ) { throw new jms exception ( str + destination name , e ) ; } catch ( exception ex ) { throw new illegal state exception ( str + destination name , ex ) ; } } ) ; } catch ( jms e ) { throw new jms exception ( str + destination name , e ) ; } }	Listen to a message from JMS from a given destination by name.
public string receive text message from destination with timeout ( final string destination name , final int timeout ) { if ( ! this . is connected ( ) ) { throw new jms not connected exception ( str ) ; } message consumer consumer = get consumer ( destination name ) ; text message message ; try { if ( timeout == num ) { message = ( text message ) consumer . receive no wait ( ) ; } else { message = ( text message ) consumer . receive ( timeout ) ; } if ( message != null ) { if ( acknowledge mode == session . client acknowledge ) { message . acknowledge ( ) ; } return message . get text ( ) ; } else { return null ; } } catch ( jms e ) { throw new jms exception ( str + destination name , e ) ; } }	Receive a message from destination with timeout.
private void handle load from user data service ( final user loaded user , final callback < list < recommendation > > recommendations callback ) { callbacks . add ( ( ) -> { list < recommendation > recommendations = run rules engine against user ( loaded user ) ; recommendations callback . accept ( recommendations ) ; } ) ;	Handle defered recommendations based on user loads.
@ not null public map < object , object > get pool configuration ( ) { return configuration converter . get map ( configuration . subset ( generic object pool config . class . get name ( ) ) ) ; }	Returns the pool configuration of the scorer.
public void set id ( uuid id ) { this . dirty = bool ; this . id = id ; this . model config . set property ( id , id . to string ( ) ) ; }	Sets the ID of the model.
public void set model ( file model ) { this . dirty = bool ; this . model = model ; this . model config . set property ( model file , model . get absolute path ( ) ) ; }	Sets the model file of the serialized classifier.
public void add or update ( weka model config weka model config ) throws fos { check not null ( weka model config , str ) ; weka thread safe scorer new weka thread safe scorer = new weka thread safe scorer pool ( weka model config , weka manager config ) ; weka thread safe scorer old weka thread safe scorer = quick switch ( weka model config . get id ( ) , new weka thread safe scorer ) ; weka utils . close silently ( old weka thread safe scorer ) ; }	Adds the given model to the managed models.
public void remove model ( uuid model id ) { weka thread safe scorer new weka thread safe scorer = null ; weka thread safe scorer old weka thread safe scorer = quick switch ( model id , new weka thread safe scorer ) ; weka utils . close silently ( old weka thread safe scorer ) ; }	Removes the given model from the managed models.
@ bean public service queue clustered event manager service queue ( final @ qualifier ( str ) event bus cluster event bus cluster ) { if ( event bus cluster == null ) { return null ; } return event bus cluster . event service queue ( ) ; }	The actual service queue for the clustered event bus.All events are sent to this queue first.
@ bean public event manager clustered event manager impl ( final event connector hub event connector hub ) { return event manager builder . event manager builder ( ) . set event connector ( event connector hub ) . set name ( str ) . build ( ) ; }	Wraps factory method call so we can provide another implementation of interface if needed.
public static string encode non codes ( string string ) { matcher matcher = non codes . matcher ( string ) ; string buffer buf = new string buffer ( ) ;	Encode '%' if it is not an encoding sequence.
public static multivalued map < string , string > decode ( multivalued map < string , string > map ) { multivalued map impl < string , string > decoded = new multivalued map impl < string , string > ( ) ; for ( map . entry < string , list < string > > entry : map . entry set ( ) ) { list < string > values = entry . get value ( ) ; for ( string value : values ) { try { decoded . add ( url . decode ( entry . get key ( ) , utf 8 ) , url . decode ( value , utf 8 ) ) ; } catch ( unsupported encoding exception e ) { throw new runtime exception ( e ) ; } } } return decoded ; }	decode an encoded map.
public service group create service group ( set < resource class > resource classes , service group . service group builder service group builder ) { for ( resource class resource class : resource classes ) { logger . info ( str , resource class . get clazz ( ) . get canonical name ( ) ) ; service service = create resource ( resource class ) ; service group builder . service ( service ) ; logger . info ( str , resource class . get clazz ( ) . get canonical name ( ) ) ; } return service group builder . build ( ) ; }	Main method, creates API model from metadata.
@ override public synchronized void close ( ) throws fos { accept thread running = bool ; if ( scorer handler != null ) { scorer handler . close ( ) ; } io . close quietly ( server socket ) ; save configuration ( ) ; }	Will save the configuration to file.
@ override public void forward event ( final event transfer object < object > event ) { event connector . forward event ( new event transfer object < object > ( ) { @ override public string channel ( ) { return event . channel ( ) ; } @ override public long id ( ) { return event . id ( ) ; } @ override public object body ( ) { return event . body ( ) ; } @ override public boolean is singleton ( ) { return bool ; } @ override public multi map < string , string > params ( ) { return event . params ( ) ; } @ override public multi map < string , string > headers ( ) { return event . headers ( ) ; } @ override public boolean was replicated ( ) { return bool ; } @ suppress warnings ( str ) @ override public boolean equals ( object obj ) {	This message receives an event from a remote call.
public static annotation [ ] get resources annotations ( method method ) { map < class < ? > , annotation > annotations = new hash map < class < ? > , annotation > ( ) ; for ( annotation annotation : method . get declaring class ( ) . get annotations ( ) ) { annotations . put ( annotation . get class ( ) , annotation ) ; } for ( annotation annotation : method . get annotations ( ) ) { annotations . put ( annotation . get class ( ) , annotation ) ; } return annotations . values ( ) . to array ( new annotation [ annotations . size ( ) ] ) ; }	Returns an array of annotations the specified method of a resource class.
public static < t extends annotation > t find annotation ( class < ? > type , annotation [ ] annotations , class < t > annotation ) { t config = find annotation . find annotation ( annotations , annotation ) ; if ( config == null ) { config = type . get annotation ( annotation ) ; } return config ; }	Look for an annotation in a list of annotations. If not there, see if itis on the type provided.
public static resource constructor constructor ( class < ? > annotated resource class ) { constructor constructor = pick constructor . pick per request constructor ( annotated resource class ) ; if ( constructor == null ) { throw new runtime exception ( str + annotated resource class . get name ( ) ) ; } resource constructor builder builder = root resource ( annotated resource class ) . constructor ( constructor ) ; if ( constructor . get parameter types ( ) != null ) { for ( int i = num ; i < constructor . get parameter types ( ) . length ; i ++ ) builder . param ( i ) . from annotations ( ) ; } return builder . build constructor ( ) . build class ( ) . get constructor ( ) ; }	Picks a constructor from an annotated resource class based on spec rules.
public static resource class root resource from annotations ( class < ? > clazz ) { resource class resource class = from annotations ( bool , clazz ) ; return resource class ; }	Build metadata from annotations on classes and methods.
public static void setup bagging classifiers ( iterated single classifier enhancer bagging ) throws exception { bagging . m = classifier . make copies ( bagging . m , bagging . m ) ; }	Sets the classifiers in a bagging.
@ not null public t get ( ) throws io , class not found exception { byte array input stream byte array input stream = null ; object input stream object input stream = null ; try { byte array input stream = new byte array input stream ( this . serialized object ) ; object input stream = new object input stream ( byte array input stream ) ; return ( t ) object input stream . read object ( ) ; } finally { io . close quietly ( byte array input stream ) ; io . close quietly ( object input stream ) ; } }	Gets a fresh clone of the object.
@ not null public byte [ ] get serialized ( ) { byte [ ] result = new byte [ serialized object . length ] ; system . arraycopy ( serialized object , num , result , num , serialized object . length ) ; return result ; }	Returns a copy of the serialized object.
public void write ( file file ) throws io { check not null ( file , str ) ; file utils . write byte array to file ( file , serialized object ) ; }	Writes the serialized object to file.
public static string leaf score from distribution ( double [ ] class distribution , instances instances ) { double sum = num , max count = num ; int max index = num ; if ( class distribution != null ) { sum = utils . sum ( class distribution ) ; max index = utils . max index ( class distribution ) ; max count = class distribution [ max index ] ; } return instances . class attribute ( ) . value ( max index ) ; }	Retrieves a String representing the score of the given class distribution.
public string get provider url ( ) { if ( provider url == null ) { provider url = get provider url ( ) . replace ( str , get host ( ) ) . replace ( str , integer . to string ( get port ( ) ) ) ; } return provider url ; }	If null, will build based on host, port and provider url pattern.
public context get context ( ) { if ( context == null ) { try { context = new initial context ( create properties ( ) ) ; } catch ( naming exception e ) { throw new illegal state exception ( str , e ) ; } } return context ; }	Gets the initial JNDI context, if not set uses the jndi settings and `initialContextFactory` to createa JNDI initial context.
public supplier < connection > get connection supplier ( ) { final boolean start connection = is start connection ( ) ; if ( connection supplier == null ) { if ( get user name ( ) == null ) { connection supplier = ( ) -> { try { final connection connection = get connection factory ( ) . create connection ( ) ; if ( start connection ) { connection . start ( ) ; } return connection ; } catch ( jms e ) { throw new jms not connected exception ( str , e ) ; } } ; } else { final string user name = get user name ( ) ; final string password = get password ( ) ; connection supplier = ( ) -> { try { final connection connection = get connection factory ( ) . create connection ( user name , password ) ; if ( start connection ) { connection . start ( ) ; } return connection ; } catch ( jms e ) { throw new jms not connected exception ( str + user name , e ) ; } } ; } } return connection supplier ; }	If the user name is set, use the user name and password to create the JMS connection.
public jms service build ( ) { return new jms service ( get connection supplier ( ) , get destination supplier ( ) , is transacted ( ) , get acknowledge mode ( ) , is start connection ( ) , get default destination ( ) , get default timeout ( ) ) ; }	Build JMS Service.
public type get type ( simple type jackson type ) { try { string signature = jackson signature . create signature ( jackson type ) ; custom type type = new custom type ( jackson type . get raw class ( ) . get name ( ) , signature , jackson type . get raw class ( ) ) ; if ( cache . contains key ( signature ) ) { return cache . get ( signature ) ; } cache . put ( signature , type ) ; object writer object writer = object mapper . writer for ( jackson type ) ; field prefetch field = object writer . get class ( ) . get declared field ( str ) ; prefetch field . set accessible ( bool ) ; object writer . prefetch prefetch = ( object writer . prefetch ) prefetch field . get ( object writer ) ; do introspection ( prefetch . value serializer , type ) ; return type ; } catch ( no such field exception e ) { e . print stack trace ( ) ; } catch ( illegal access exception e ) { e . print stack trace ( ) ; } return null ; }	From Jackson type creates a JRAPIDoc type, type is stored in cache.
public type get type ( java type type ) { if ( type instanceof simple type ) { return get type ( ( simple type ) type ) ; } else if ( type instanceof collection type ) { return get type ( ( collection like type ) type ) ; } else if ( type instanceof array type ) { return get type ( ( array type ) type ) ; } else if ( type instanceof map like type ) { return get type ( ( map like type ) type ) ; } throw new runtime exception ( str + type ) ; }	Do redirection from general Jackson type to the concrete one.
private void do introspection ( json serializer serializer , type type ) { if ( serializer == null ) { return ; } if ( enum serializer . class . is assignable from ( serializer . get class ( ) ) ) { introspect serializer ( ( enum serializer ) serializer , ( custom type ) type ) ; } else if ( bean serializer base . class . is assignable from ( serializer . get class ( ) ) ) { introspect serializer ( ( bean serializer base ) serializer , ( custom type ) type ) ; } else if ( std scalar serializer . class . is assignable from ( serializer . get class ( ) ) ) { introspect serializer ( ( std scalar serializer ) serializer , ( custom type ) type ) ; } else if ( as array serializer base . class . is assignable from ( serializer . get class ( ) ) ) { introspect serializer ( ( as array serializer base ) serializer , ( collection type jrapidoc ) type ) ; } else if ( map serializer . class . is assignable from ( serializer . get class ( ) ) ) { introspect serializer ( ( map serializer ) serializer , ( map type jrapidoc ) type ) ; } }	Do redirection from general Jackson serializer to the concrete one.
private void introspect serializer ( bean serializer base bean serializer , custom type type ) { try { field props field = bean serializer . get class ( ) . get superclass ( ) . get declared field ( str ) ; props field . set accessible ( bool ) ; bean property writer [ ] props = ( bean property writer [ ] ) props field . get ( bean serializer ) ; for ( bean property writer prop : props ) { java type prop type = prop . get type ( ) ; get type ( prop type ) ; string signature = jackson signature . create signature ( prop type ) ; type . add bean property ( new bean property ( prop . get name ( ) , signature , prop . get property type ( ) , prop . get metadata ( ) . get description ( ) , prop . get metadata ( ) . is required ( ) ) ) ; } } catch ( no such field exception e ) { e . print stack trace ( ) ; } catch ( illegal access exception e ) { e . print stack trace ( ) ; } }	Introspect serializer for java beans.
private void introspect serializer ( enum serializer enum serializer , custom type type ) { for ( serializable string value : enum serializer . get enum values ( ) . values ( ) ) { type . add enumeration ( value . get value ( ) ) ; } }	Introspect serializer for enumerations.
private void introspect serializer ( map serializer map serializer , map type jrapidoc type ) { try { field key type field = map serializer . get class ( ) . get declared field ( str ) ; key type field . set accessible ( bool ) ; java type key type = ( java type ) key type field . get ( map serializer ) ; java type value type = map serializer . get content type ( ) ; get type ( key type ) ; get type ( value type ) ; } catch ( no such field exception e ) { e . print stack trace ( ) ; } catch ( illegal access exception e ) { e . print stack trace ( ) ; } }	Introspect serializer for map.
private void frame1 ( ) {	Get customer, customer account, and broker information.
private void frame3 ( ) {	Estimate overall effects of the trade.
private void frame4 ( ) { long current time = system . current time millis ( ) ;	Record the trade request by making all related updates.
public void next ( ) { for ( int k = a . length - num ; k > num ; k -- ) { int w = ( int ) math . floor ( math . random ( ) * ( k + num ) ) ; int temp = a [ w ] ; a [ w ] = a [ k ] ; a [ k ] = temp ; } }	It produces the next random permutation.
public int next ( ) {	Not repeat, randomly choose a number from 1 to the initinalized size.
public static void main ( string [ ] args ) { microbenchmark param gen executor = new microbenchmark param gen ( ) ; system . out . println ( str ) ; system . out . println ( str + rw tx rate ) ; system . out . println ( str + long read tx rate ) ; system . out . println ( str + total read count ) ; system . out . println ( str + local hot count ) ; system . out . println ( str + write ratio in rw tx ) ; system . out . println ( str + hot conflict rate ) ; system . out . println ( str + data size ) ; system . out . println ( str + hot data size ) ; system . out . println ( str + cold data size ) ; system . out . println ( ) ; for ( int i = num ; i < num ; i ++ ) { object [ ] params = executor . generate parameter ( ) ; system . out . println ( arrays . to string ( params ) ) ; } }	a main application for debugging.
public string make last name ( int number ) { if ( number < num && number > tpcc constants . num distinct clast - num ) throw new illegal argument exception ( ) ; int indicies [ ] = { number / num , ( number / num ) % num , number % num } ; string buffer sb = new string buffer ( ) ; for ( int i = num ; i < indicies . length ; ++ i ) { sb . append ( tokens [ indicies [ i ] ] ) ; } return sb . to string ( ) ; }	Return a last name as defined by TPC-C 4.3.2.3.
public int random choose from distribution ( double ... probs ) { int result = - num ; int [ ] range = new int [ probs . length ] ; double accuracy = num ; int total = num ; for ( int i = num ; i < probs . length ; i ++ ) { range [ i ] = ( int ) ( probs [ i ] * accuracy ) ; total += range [ i ] ; } int rand num = ( int ) ( rng . next double ( ) * total ) ; for ( int i = num ; i < range . length ; i ++ ) { rand num -= range [ i ] ; if ( rand num <= num ) { result = i ; break ; } } return result ; }	Return the result of a random choose from a given distribution.
public static file get relative path ( file in , file repository path ) throws java git exception { string path = in . get path ( ) ; string absolute path = in . get absolute path ( ) ;	Returns a file, with path relative to git working tree.
public git add response add ( ) throws io , java git exception { git add git add = new git add ( ) ;	Adds the object to the git index.
public git commit response commit ( string comment ) throws io , java git exception {	Commits the file system object.
public git mv response mv ( file dest ) throws io , java git exception {	Moves or renames the object.
public git rm response rm ( ) throws io , java git exception { git rm git rm = new git rm ( ) ;	Removes the file system object from the working tree and the index.
public static void check file validity ( file file ) throws io { if ( ! file . exists ( ) ) { throw new io ( exception message map . get message ( str ) + str + file . get name ( ) + str ) ; } }	Checks that the specified file exists.
public static boolean check unordered lists equal ( list < ? > l1 , list < ? > l2 ) { if ( null == l1 && null != l2 ) { return bool ; } if ( null != l1 && null == l2 ) { return bool ; } if ( l1 . size ( ) != l2 . size ( ) ) { return bool ; } for ( object o : l1 ) { if ( ! l2 . contains ( o ) ) { return bool ; } } for ( object o : l2 ) { if ( ! l1 . contains ( o ) ) { return bool ; } } return bool ; }	Checks if two unordered lists are equal.
public static void check int in range ( int index , int start , int end ) { if ( index < start ) { throw new index out of bounds exception ( exception message map . get message ( str ) + str + index + str + start + str + end + str ) ; } if ( index >= end ) { throw new index out of bounds exception ( exception message map . get message ( str ) + str + index + str + start + str + end + str ) ; } }	A general range check utility for checking whether a given &lt;integer&gt; value is between agiven start and end indexes.
public i get client instance ( client type client type ) { i client instance = client impls . get ( client type ) ; if ( null == client instance ) { if ( client type . cli == client type ) { client instance = new cli client ( ) ; } if ( null != client instance ) { client impls . put ( client type , client instance ) ; } } return client instance ; }	Gets an instance of the specified client type.
public void set preferred client type ( client type preferred client type ) { if ( null == preferred client type ) { this . preferred client type = client type . cli ; } else { this . preferred client type = preferred client type ; } }	Sets the preferred client type.
public git add response add ( file repository path , git add options options , list < file > paths ) throws java git exception , io { check utilities . check file validity ( repository path ) ; git add parser parser = new git add parser ( ) ; list < string > command = build command ( repository path , options , paths ) ; git add response impl response = ( git add response impl ) process utilities . run command ( repository path , command , parser ) ; if ( options != null ) { add dry run ( options , response ) ; } return ( git add response ) response ; }	Implementations of &lt;git-add&gt; with options and list of files provided.
public git add response add ( file repository path , list < file > files ) throws java git exception , io { git add options options = null ; return add ( repository path , options , files ) ; }	Adds a list of files with no GitAddOptions.
public git add response add ( file repository path , file file ) throws java git exception , io { list < file > file paths = new array list < file > ( ) ; file paths . add ( file ) ; git add options options = null ; return add ( repository path , options , file paths ) ; }	Adds one file to the index with no GitAddOptions.
public git add response add ( file repository path , git add options options , file file ) throws java git exception , io { list < file > paths = new array list < file > ( ) ; paths . add ( file ) ; return add ( repository path , options , paths ) ; }	Implementations of &lt;git-add&gt; with options and one file to be added to index.
public git add response add dry run ( file repository path , list < file > paths ) throws java git exception , io { git add options options = new git add options ( ) ; options . set dry run ( bool ) ; return add ( repository path , options , paths ) ; }	Implementation of &lt;git-add&gt; dry run.
public git add response add verbose ( file repository path , list < file > paths ) throws java git exception , io { git add options options = new git add options ( ) ; options . set verbose ( bool ) ; return add ( repository path , options , paths ) ; }	Implementations of &lt;git-add&gt; in verbose mode.
public git add response add with force ( file repository path , list < file > paths ) throws java git exception , io { git add options options = new git add options ( ) ; options . set force ( bool ) ; return add ( repository path , options , paths ) ; }	Implementations of &lt;git-add&gt; with force option set.
private void add dry run ( git add options options , git add response impl response ) { if ( options . dry run ( ) ) { response . set dry run ( bool ) ; } }	if the dry run option was selected then set the flag in response.
private int compare to release minor ( git version that ) { if ( this . contains release minor ( ) && that . contains release minor ( ) ) return compare to int ( this . get release minor ( ) , that . get release minor ( ) ) ; else if ( ! this . contains release minor ( ) && ! that . contains release minor ( ) ) return same ; else if ( this . contains release minor ( ) && ! that . contains release minor ( ) ) return later ; else return previous ; }	Compares minor releases values given that git version contains no tagfor none of GitVersion objects.
private static list < i > create list ( method method ) { list < i > parameters = new array list < i > ( ) ; class < ? > param types [ ] = method . get parameter types ( ) ; annotation [ ] [ ] method annotations = method . get parameter annotations ( ) ; for ( int i = num ; i < method annotations . length ; i ++ ) {	Creates the list of BinderVariables given a method obtained throughreflection.
public int [ ] get function definition array ( int function offset , int max params , int return type ) { int [ ] definition = new int [ max params + extra func def values ] ; int param count = get parameter count ( bool ) ; int full param count = get parameter count ( bool ) ; definition [ num ] = function offset ; if ( param count > max params ) { throw new illegal state exception ( str + str + max params + str + param count ) ; } definition [ num ] = param count ; int j = num ; for ( int i = num ; i < full param count ; i ++ ) {	Return the m_functionDefinition compatible array.
public object [ ] get value array ( workspace ws , data binder binder , execution context ctx ) { object [ ] param array = new object [ this . parameters . size ( ) ] ; for ( int i = num ; i < this . parameters . size ( ) ; i ++ ) {	Returns an array of values given a filter execution context.
public static synchronized boolean exists instance ( file path ) { string canonical path = str ; try { canonical path = path . get canonical path ( ) ; } catch ( io e ) {	Checks if there is a DotGit instance for a given path.
public ref create branch ( string name ) throws io , java git exception { ref new branch = ref . create branch ref ( name ) ; git branch git branch = new git branch ( ) ; git branch . create branch ( path , new branch ) ; return new branch ; }	Creates a new branch.
public void delete branch ( ref branch , boolean force delete ) throws io , java git exception { git branch git branch = new git branch ( ) ; git branch . delete branch ( path , force delete , bool , branch ) ; branch = null ; }	Deletes a branch.
public ref rename branch ( ref branch from , string name to , boolean force rename ) throws io , java git exception { ref new branch = ref . create branch ref ( name to ) ; git branch git branch = new git branch ( ) ; git branch . rename branch ( path , force rename , branch from , new branch ) ; return new branch ; }	Renames a branch.
public iterator < ref > get branches ( ) throws io , java git exception { git branch git branch = new git branch ( ) ; git branch options options = new git branch options ( ) ; git branch response response = git branch . branch ( path , options ) ; return response . get branch list iterator ( ) ; }	Gets a list of the branches in the repository.
@ suppress warnings ( str ) public static < t > t convert ( object from , class < t > to ) {	Convert the given object value to the given class.
public static boolean integer to boolean ( integer value ) { return value . int value ( ) == num ? boolean . false : boolean . true ; }	Converts Integer to Boolean.
public static integer boolean to integer ( boolean value ) { return value . boolean value ( ) ? integer . value of ( num ) : integer . value of ( num ) ; }	Converts Boolean to Integer.
public static string long to string ( date value ) { if ( value == null ) { return null ; } simple date format sdf = new simple date format ( ) ; return sdf . format ( value ) ; }	Converts Date to String.
public static string get message ( string code ) { string str = message map . get ( code ) ; if ( null == str ) { return str + code + str ; } return str ; }	Gets the error message for the specified code.
public file get file needing update ( int index ) { check utilities . check int index in list range ( files needing update , index ) ; return files needing update . get ( index ) ; }	Gets the file at the specified index from the list of files needing update.
public void add to deleted files to commit ( file file ) { deleted files to commit . add ( file ) ; file to status . put ( file , status . deleted to commit ) ; }	Adds a file to list of files that are deleted and will be committed next time&lt;git-commit&gt; is run.
public void add to deleted files not updated ( file file ) { deleted files not updated . add ( file ) ; file to status . put ( file , status . deleted ) ; }	Adds a file to the list of files that are deleted locally but not yet deleted from index using&lt;git-rm&gt; command.
public void add to modified files to commit ( file file ) { modified files to commit . add ( file ) ; file to status . put ( file , status . modified to commit ) ; }	Adds a file to list of files that are modified and will be committed next time&lt;git-commit&gt; is run.
public void add to modified files not updated ( file file ) { modified files not updated . add ( file ) ; file to status . put ( file , status . modified ) ; }	Adds a file to the list of files that are modified files but not yet updated.
public void add to new files to commit ( file file ) { new files to commit . add ( file ) ; file to status . put ( file , status . new to commit ) ; }	Adds a file to the list of new files that are ready to be committed next time &lt;git-commit&gt;command is run.
public void add to renamed files to commit ( file file ) { renamed files to commit . add ( file ) ; file to status . put ( file , status . renamed to commit ) ; }	Adds a file to the list of renamed files that are ready to be committed next time &lt;git-commit&gt;command is run.
public void add to untracked files ( file file ) { untracked files . add ( file ) ; file to status . put ( file , status . untracked ) ; }	Adds a file to list of files that have been added locally but not yet added to the index.
public string get string value ( data binder binder ) {	Get the string value from binder.
public void set opt verbose ( boolean opt verbose ) { check can set no arg option ( str ) ; if ( ( bool == opt verbose ) && ( opt abbrev || opt no abbrev ) ) { throw new illegal argument exception ( exception message map . get message ( str ) + str ) ; } this . opt verbose = opt verbose ; }	Checks whether the verbose option should be set and sets it.
public void set opt d ( boolean opt d ) { check can set delete option ( str ) ; if ( opt d && opt d ) { throw new illegal argument exception ( exception message map . get message ( str ) + str ) ; } this . opt d = opt d ; }	Checks whether the -d option should be set and sets it.
public void set opt d ( boolean opt d ) { check can set delete option ( str ) ; if ( opt d && opt d ) { throw new illegal argument exception ( exception message map . get message ( str ) + str ) ; } this . opt d = opt d ; }	Checks whether the -D option should be set and sets it.
public void set opt m ( boolean opt m ) { check can set rename option ( str ) ; if ( opt m && opt m ) { throw new illegal argument exception ( exception message map . get message ( str ) + str ) ; } this . opt m = opt m ; }	Checks whether the -m option should be set and sets it.
public void set opt m ( boolean opt m ) { check can set rename option ( str ) ; if ( opt m && opt m ) { throw new illegal argument exception ( exception message map . get message ( str ) + str ) ; } this . opt m = opt m ; }	Checks whether the -M option should be set and sets it.
public integer get function return type ( method m ) { class < ? > type = m . get return type ( ) ; if ( type == void . class || type == void . class ) { return return void ; } if ( type == boolean . class || type == boolean . class ) { return return boolean ; } if ( type == integer . class || type == int . class || type == long . class || type == long . class ) { return return integer ; } if ( type == float . class || type == float . class || type == double . class || type == double . class ) { return return float ; } return return string ; }	Get idoc function return type.
public boolean evaluate function ( script info info , object [ ] args , execution context context ) throws service exception { int config [ ] = ( int [ ] ) info . m entry ; string function called = info . m key ; int function index = config [ num ] ; int nargs = args . length - num ; int allowed params = config [ num ] ; if ( allowed params >= num && allowed params != nargs ) { string msg = locale utils . encode message ( str , null , function called , str + allowed params ) ; throw new illegal argument exception ( msg ) ; } user data user data = ( user data ) context . get cached object ( str ) ; if ( user data == null ) { string msg = locale utils . encode message ( str , null , function called ) ; throw new service exception ( msg ) ; } if ( function index > m function table . length ) { system utils . trace ( str , str + function index ) ; return bool ; } try { args [ nargs ] = run function method ( function index , args , context ) ; } catch ( exception e ) { string msg = e . get message ( ) ; if ( e instanceof invocation target exception ) { msg = ( ( invocation target exception ) e ) . get target exception ( ) . get message ( ) ; } msg = str + function called + str + msg ; system utils . err ( e , msg ) ; system utils . trace ( str , msg ) ; throw new service exception ( e ) ; }	This is where the custom IdocScript function is evaluated.
public object [ ] get injected value array ( method method , object [ ] args , execution context ctx ) throws illegal argument exception , service exception { parameter marshaller marshaller = new parameter marshaller ( method ) ; if ( ( ctx instanceof service ) == bool ) { throw new service exception ( str ) ; } return marshaller . get value array ( args , ( service ) ctx ) ; }	Enumerates the correct parameters for the delegated method.
public object run function method ( int function index , object [ ] args , execution context ctx ) throws security exception , no such method exception , illegal argument exception , service exception , illegal access exception , invocation target exception { method method = function methods [ function index ] ; object params [ ] = get injected value array ( method , args , ctx ) ; object result ; try { result = method . invoke ( m class . new instance ( ) , params ) ; } catch ( instantiation exception e ) {	Executes the annotated method.
private object convert return value ( object result ) { if ( boolean . class . is instance ( result ) || result instanceof boolean ) { return script extension utils . compute return object ( num , ( ( boolean ) result ) . boolean value ( ) , num , num , null ) ; } else if ( long . class . is instance ( result ) ) { return ( long ) result ; } else if ( int . class . is instance ( result ) || result instanceof integer ) { return new long ( ( integer ) result ) ; } else if ( double . class . is instance ( result ) ) { return ( double ) result ; }	Convert the method return value into a PageMerger internal type of String,Long or Double.
public boolean evaluate value ( script info info , boolean [ ] return bool , string [ ] return string , execution context context , boolean is conditional ) throws service exception { int config [ ] = ( int [ ] ) info . m entry ; string key = info . m key ; if ( ( context instanceof service ) == bool ) {	This is where the custom IdocScript variable is evaluated.
public git branch response branch ( file repository path ) throws io , java git exception { check utilities . check null argument ( repository path , str ) ; i client = client manager . get instance ( ) . get preferred client ( ) ; i git branch = client . get git branch instance ( ) ; return git branch . branch ( repository path ) ; }	Does a basic git-branch without any options.
public git commit response commit ( string comment ) throws io , java git exception { git commit git commit = new git commit ( ) ; return git commit . commit ( path , comment ) ; }	Commits the objects specified in the index to the repository.
public ref get current branch ( ) throws io , java git exception { git branch git branch = new git branch ( ) ; git branch options options = new git branch options ( ) ; git branch response response = git branch . branch ( path , options ) ; return response . get current branch ( ) ; }	Gets the currently checked-out branch of the working directory.
public void checkout ( ref ref ) throws io , java git exception { git checkout git checkout = new git checkout ( ) ; git checkout . checkout ( path , null , ref ) ;	Switches to a new branch.
public git status response get status ( ) throws io , java git exception { git status git status = new git status ( ) ; return git status . status ( path ) ; }	Gets the status of all files in the working directory.
public file get file from new files to commit ( int index ) { check utilities . check int index in list range ( new files to commit , index ) ; return new files to commit . get ( index ) ; }	Get the name of the file from newFilesToCommit list at a given index.
public file get file from deleted files to commit ( int index ) { check utilities . check int index in list range ( deleted files to commit , index ) ; return deleted files to commit . get ( index ) ; }	Get the name of the deleted file that will be committed next time git-commit is executedcurrently located at the given index in the list.
public file get file from modified files to commit ( int index ) { check utilities . check int index in list range ( modified files to commit , index ) ; return modified files to commit . get ( index ) ; }	Get the name of the file that is modified and added to the repository by &lt;git-add&gt;command and will be committed to repository next time &lt;git-commit&gt; is executed.
public file get file from deleted files not updated ( int index ) { check utilities . check int index in list range ( deleted files not updated , index ) ; return deleted files not updated . get ( index ) ; }	Returns the name of the deleted file that is removed locally but not yet removed fromrepository.
public file get file from modified files not updated ( int index ) { check utilities . check int index in list range ( modified files not updated , index ) ; return modified files not updated . get ( index ) ; }	Returns the name of the file that is existing in the repository and has been locally modified.This file is one of the files that has been locally modified and is located at given index inthe list.
public file get file from untracked files ( int index ) { check utilities . check int index in list range ( untracked files , index ) ; return untracked files . get ( index ) ; }	Returns the name of the file at the specified index that has been created locally but has notyet been added to the repository by &lt;git-add&gt;.
public file get file from renamed files ( int index ) { check utilities . check int index in list range ( renamed files to commit , index ) ; return renamed files to commit . get ( index ) ; }	Returns the file at the specified index in the list of renamed files.
public string get error ( int index ) { if ( index < errors . size ( ) ) { error details error details = errors . get ( index ) ; return error details . line number + str + error details . error ; } return null ; }	Returns the error message otherwise returns null;.
public string get error ( ) { string builder str builder = new string builder ( ) ; for ( int i = num ; i < errors . size ( ) ; i ++ ) { str builder . append ( get error ( i ) + str ) ; } return str builder . to string ( ) ; }	Gets all the errors generated by &lt;git-status&gt; command and returns them in String format.
public boolean add added file ( file path to file , string mode ) { if ( null == path to file ) { return bool ; } return added files . add ( new added or deleted file ( path to file , mode ) ) ; }	Add the information about a newly added file in the repository for a given commit.
public boolean add copied file ( file source file path , file destination file path , int percentage ) { if ( null == source file path || null == destination file path ) { return bool ; } return copied files . add ( new copied or moved file ( source file path , destination file path , percentage ) ) ; }	Add the information about a newly copied file in the repository for a given commit.
public boolean add deleted file ( file path to file , string mode ) { if ( null == path to file ) { return bool ; } return deleted files . add ( new added or deleted file ( path to file , mode ) ) ; }	Add the information about a file deleted from the repository for a given commit.
public boolean set files changed ( string files changed str ) { try { this . files changed = integer . parse int ( files changed str ) ; return bool ; } catch ( number format exception e ) { return bool ; } }	Sets the number of files changed during a commit.
public boolean set lines deleted ( string lines deleted str ) { try { this . lines deleted = integer . parse int ( lines deleted str ) ; return bool ; } catch ( number format exception e ) { return bool ; } }	Sets the number of lines deleted in a commit.
public boolean set lines inserted ( string lines inserted str ) { try { this . lines inserted = integer . parse int ( lines inserted str ) ; return bool ; } catch ( number format exception e ) { return bool ; } }	Sets the number of lines inserted in a commit.
public static int index of left ( string str , int from , char c ) { int pos = - num ; int f = from ; while ( f >= num && pos == - num ) if ( str . char at ( f -- ) == c ) pos = f + num ; return pos ; }	Returns the position for char 'c' in string 'str' starting from position 'pos'and searching towards the string beginning.
private data result set get result set ( string name , service service ) { result set rs = service . get binder ( ) . get result set ( name ) ; data result set drs = new data result set ( ) ; if ( rs != null ) { drs . copy ( rs ) ; return drs ; } return null ; }	Find a result set in the service binder.
public list < commit > log ( file repository path , git log options options ) throws java git exception , io { check utilities . check file validity ( repository path ) ; git log parser parser = new git log parser ( ) ; list < string > command = build command ( repository path , options ) ; git log response response = ( git log response ) process utilities . run command ( repository path , command , parser ) ; if ( response . contains error ( ) ) { int line = response . get error ( num ) . get line number ( ) ; string error = response . get error ( num ) . error ( ) ; throw new java git exception ( num , str + line + str + error ) ; } return response . get log ( ) ; }	Implementations of &lt;git log&gt; with options and one file to be added to index.
public void add commit ( ) { if ( this . sha != null ) { commit commit = new commit ( this . sha , this . merge details , this . author , this . date string , this . message , this . files ) ; if ( commit list == null ) { commit list = new array list < commit > ( ) ; } this . commit list . add ( commit ) ;	This add a newly created commit object to the list of commits for a log.
public void add file ( string filename , int lines added , int lines deleted ) { commit file commit file = new commit file ( filename , lines added , lines deleted ) ; if ( files == null ) { files = new array list < commit file > ( ) ; } this . files . add ( commit file ) ; }	This adds a file to the list of files affected by a particular commit.
public git checkout response checkout ( file repository path , git checkout options options , ref ref ) throws java git exception , io { check utilities . check file validity ( repository path ) ; check ref against ref type ( ref , ref type . head ) ; list < string > command = build command ( options , ref ) ; git checkout parser parser = new git checkout parser ( ) ; git checkout response response = ( git checkout response ) process utilities . run command ( repository path , command , parser ) ; return response ; }	Git checkout with options and base branch information provided to &lt;git-checkout&gt; command.
public git checkout response checkout ( file repository path ) throws java git exception , io { git checkout options options = null ; return checkout ( repository path , options , null ) ; }	Git checkout without any options and branch information provided.
public git checkout response checkout ( file repository path , ref branch ) throws java git exception , io { return checkout ( repository path , null , branch ) ; }	Checks out a branch from the git repository with a given branch name.
public git checkout response checkout ( file repository path , list < file > paths ) throws java git exception , io { check utilities . check file validity ( repository path ) ; check utilities . check null list argument ( paths , str ) ; git checkout parser parser = new git checkout parser ( ) ; list < string > command = build command ( null , null , paths ) ; git checkout response response = ( git checkout response ) process utilities . run command ( repository path , command , parser ) ; return response ; }	Checks out a list of files from repository, no checkout options provided.
public git checkout response checkout ( file repository path , git checkout options options , ref ref , list < file > paths ) throws java git exception , io { check utilities . check file validity ( repository path ) ; if ( ref != null && ref . get ref type ( ) == ref type . head ) { throw new illegal argument exception ( str ) ; } git checkout parser parser = new git checkout parser ( ) ; list < string > command = build command ( options , ref , paths ) ; return ( git checkout response ) process utilities . run command ( repository path , command , parser ) ; }	Checks out a list of file from repository, with &lt;tree-ish&gt; options provided.
public git checkout response checkout ( file repository path , git checkout options options , ref branch , file path ) throws java git exception , io { check utilities . check file validity ( repository path ) ; git checkout parser parser = new git checkout parser ( ) ; list < file > paths = new array list < file > ( ) ; paths . add ( path ) ; list < string > command = build command ( options , branch , paths ) ; git checkout response response = ( git checkout response ) process utilities . run command ( repository path , command , parser ) ; return response ; }	Checks out a file from repository from a particular branch.
private void check ref against ref type ( ref ref , ref type ref type ) { if ( ref != null && ref . get ref type ( ) == ref type ) { throw new illegal argument exception ( str ) ; } }	This is just a test method for verifying that a given ref is not of refType provided as one of the parameters.
public list < git file system object > get children ( ) throws io , java git exception { list < git file system object > children = new array list < git file system object > ( ) ;	Gets the children of this directory.
public file get removed file ( int index ) { check utilities . check int index in list range ( removed files , index ) ; return removed files . get ( index ) ; }	Gets the file at the specified index from the removed file list.
public git checkout response checkout ( file repository path , list < file > paths ) throws io , java git exception { check utilities . check file validity ( repository path ) ; check utilities . check null list argument ( paths , str ) ; i client = client manager . get instance ( ) . get preferred client ( ) ; i git checkout = client . get git checkout instance ( ) ; return git checkout . checkout ( repository path , paths ) ; }	For checking a file or list of files from a branch.
public git checkout response checkout ( file repository path , ref ref , list < file > paths ) throws java git exception , io { check utilities . check file validity ( repository path ) ; if ( ref != null && ( ref . get ref type ( ) != ref type . branch && ref . get ref type ( ) != ref type . sh ) ) { throw new java git exception ( num , exception message map . get message ( str ) + str + ref . get ref type ( ) ) ; } check utilities . check null list argument ( paths , str ) ; i client = client manager . get instance ( ) . get preferred client ( ) ; i git checkout = client . get git checkout instance ( ) ; return git checkout . checkout ( repository path , ref , paths ) ; }	Checks out files from the repository when a tree-ish object is given as the reference.
public void set comment ( int line number , string comment string ) { response string comment = new response string ( line number , comment string ) ; comments . add ( comment ) ; }	Sets the non-error message generated in the output of the &lt;git-add&gt; command.
public void set delete options ( git branch options options , boolean force delete , boolean remote ) { if ( force delete ) { options . set opt d ( bool ) ; } else { options . set opt d ( bool ) ; } if ( remote ) { options . set opt r ( bool ) ; } }	Sets the options for delete.
@ override public void inject ( class < ? > klass ) throws data exception { method [ ] class methods = klass . get methods ( ) ; for ( method method : class methods ) { service method annotation = ( service method ) method . get annotation ( service method . class ) ; if ( annotation != null ) { inject service method ( method , annotation ) ; } } }	Inject a service into the service manager registry.
private static void inject service method ( method method , service method annotation ) throws data exception { service data service data = new service data ( ) ; string template = annotation . template ( ) ; int access level = annotation . access level ( ) ; string service type = ( ! annotation . type ( ) . equals ( str ) ) ? annotation . type ( ) : null ; string error message = annotation . error message ( ) ; string subjects = annotation . subjects ( ) ; string service name = annotation . name ( ) ; try { service data . init ( service name , service proxy . class . get name ( ) , access level , template , service type , error message , subjects ) ; } catch ( exception e ) { throw new data exception ( str + service name + str + e . get message ( ) ) ; }	Injects a single UCMService annotation into the ServiceManager registry.
public void set opt b ( ref new branch ) { check utilities . validate argument ref type ( new branch , ref type . branch , str ) ; opt b = new branch ; }	Sets the name of the new branch that need to be created from the base branch.
public int do filter ( workspace ws , data binder binder , execution context ctx ) throws data exception , service exception { string config file name = ( string ) ctx . get cached object ( str ) ; try { class loader cl = get class ( ) . get class loader ( ) ; enumeration < url > prop files = cl . get resources ( config file name ) ;	Begins injection of filters, including the Service and IdocScript injectorsrequired to load other ucm entities.
private enumeration < url > get resources11g ( class loader class loader , string config file name ) { list < url > new props = new array list < url > ( ) ; if ( class loader . get class ( ) . get simple name ( ) . equals ignore case ( str ) ) { try { field field = class loader . get class ( ) . get field ( str ) ; @ suppress warnings ( str ) map < string , idc zip file > zip files = ( map < string , idc zip file > ) field . get ( class loader ) ; for ( entry < string , idc zip file > entry : zip files . entry set ( ) ) { if ( entry . get value ( ) . m entries . get ( config file name ) != null ) { string jar file = entry . get key ( ) ;	Replacement for getResources which works on 11g. The UCM 11G {.
private void setup ( reset type reset type , ref commit name ) { check utilities . check null argument ( reset type , str ) ; check utilities . check null argument ( commit name , str ) ; this . reset type = reset type ; this . commit name = commit name ; }	Central instance construction setup method.
public static string add method ( method m ) { if ( methods == null ) { methods = new hash map < string , method > ( ) ; } string hash code = string . value of ( m . hash code ( ) ) ; if ( ! methods . contains key ( hash code ) ) { methods . put ( hash code , m ) ; } return string . value of ( m . hash code ( ) ) ; }	Adds a method to the registry and returns the UUID.
public int do filter ( workspace ws , data binder binder , execution context ctx ) throws data exception , service exception { object return val = null ; try { string method id = ( string ) ctx . get cached object ( str ) ; method m = method registry . get method ( method id ) ; parameter marshaller marshaller = new parameter marshaller ( m ) ; object [ ] params = marshaller . get value array ( ws , binder , ctx ) ; object context = m . get declaring class ( ) . new instance ( ) ; return val = m . invoke ( context , params ) ; } catch ( illegal argument exception e ) { throw new data exception ( e . get message ( ) , e ) ; } catch ( exception e ) { throw new service exception ( e . get message ( ) , e ) ; } if ( return val != null && return val instanceof integer ) { return ( ( integer ) return val ) . int value ( ) ; } return continue ; }	Main entry point which will delegate to the filter method with dependencyinjection.
public void reduce database connection ( ) { synchronized ( lock ) { int number of open connections = open connections . decrement and get ( ) ; if ( number of open connections == num && db connection != null ) { db connection . close ( ) ; db connection = null ; } } }	Reduce the connection opened.
public void consume database ( db consumer db consumer ) { sq db = get database connection ( ) ; try { db consumer . consume ( db ) ; } finally { reduce database connection ( ) ; } }	Execute an action on the database.
public cursor query ( string table , string [ ] columns , string selection , string [ ] selection args , string group by , string having , string order by ) { sq db = get database connection ( ) ; return new db closing cursor ( db . query ( table , columns , selection , selection args , group by , having , order by ) , this ) ; }	Executes a query on the database.
public cursor raw query ( string sql ) { sq db = get database connection ( ) ; return new db closing cursor ( db . raw query ( sql , null ) , this ) ; }	Executes a raw query on the database.
private list < string > build command line ( git rm options options , file path , list < file > paths ) { list < string > cmdline = new array list < string > ( ) ; cmdline . add ( java git configuration . get git command ( ) ) ; cmdline . add ( str ) ; if ( null != options ) { if ( options . is opt cached ( ) ) { cmdline . add ( str ) ; } if ( options . is opt f ( ) ) { cmdline . add ( str ) ; } if ( options . is opt n ( ) ) { cmdline . add ( str ) ; } if ( options . is opt q ( ) ) { cmdline . add ( str ) ; } if ( options . is opt r ( ) ) { cmdline . add ( str ) ; } } if ( null != path ) { cmdline . add ( path . get path ( ) ) ; } else { for ( file f : paths ) { cmdline . add ( f . get path ( ) ) ; } } return cmdline ; }	Builds the command line.
public file get added file ( int index ) { check utilities . check int index in list range ( added files , index ) ; return added files . get ( index ) ; }	Returns the file at a given location in the addedFiles list.
public file get deleted file ( int index ) { check utilities . check int index in list range ( deleted files , index ) ; return deleted files . get ( index ) ; }	Returns the file at a given location in the deletedFiles list.
public file get modified file ( int index ) { check utilities . check int index in list range ( modified files , index ) ; return modified files . get ( index ) ; }	Returns the file at a given location in the modifiedFiles list.
public status get status ( ) throws io , java git exception { git status git status = new git status ( ) ;	Show object's status in the working directory.
protected static head element get head ( ) { if ( head == null ) { final element element = document . get ( ) . get elements by tag name ( str ) . get item ( num ) ; assert element != null : str ; final head element head = head element . as ( element ) ; abstract injector . head = head ; } return abstract injector . head ; }	Gets the document header.
public array list < file > get files ( ) {	Return array if all files added to dropzone.
public int get files count ( ) { final js array < js > files = get files native ( get element ( ) ) ; return files != null ? files . length ( ) : num ; }	Return number of added files.
public boolean matches ( string string ) { string src = string ; final boolean result ; if ( compiled pattern . length == num ) {	Match the given string.
@ override protected void update list after hit ( cache entry < k , v > entry ) { if ( entry != null && ! entry . equals ( first ) ) { if ( entry . equals ( last ) ) { set last ( entry . get previous ( ) ) ; } else { final cache entry < k , v > previous = entry . get previous ( ) ; final cache entry < k , v > next = entry . get next ( ) ; previous . set next ( next ) ; next . set previous ( previous ) ; } first . set previous ( entry ) ; entry . set next ( first ) ; set first ( entry ) ; } }	Move the entry to the beginning of the LinkedList.
protected void remove last ( ) { final cache entry < k , v > entry ; synchronized ( lock ) { if ( last != null ) { entry = entries . remove ( last . get key ( ) ) ; set last ( last . get previous ( ) ) ; } else { entry = null ; } if ( size ( ) == num ) { first = null ; last = null ; } } if ( entry != null ) { handle remove ( entry ) ; } }	Remove the last element from the cache.
@ suppress warnings ( str ) public void clean up lifetime expired ( ) { final long current time = current time millis ( ) ;	Remove entries that are out of their maxLifetime.
@ override protected void update list after hit ( cache entry < k , v > entry ) { if ( entry != null && ! entry . equals ( first ) ) { if ( entry . get hits ( ) > entry . get previous ( ) . get hits ( ) ) {	Resort the linked list.
public static boolean starts with ( char [ ] src , char [ ] find , int start at ) { int start pos = start at ; boolean result = bool ;	Test whether 'find' can be found at position 'startPos' in the string 'src'.
@ override public token get access token ( token request token , verifier verifier ) { o request = new o ( this . api . get access token verb ( ) , this . api . get access token endpoint ( ) , this . proxy host , this . proxy port ) ; string userpass = this . config . get api key ( ) + str + this . config . get api secret ( ) ; string basic auth = str + javax . xml . bind . datatype converter . print base64 binary ( userpass . get bytes ( ) ) ; request . add header ( str , basic auth ) ; request . add body parameter ( str , str ) ; request . add body parameter ( str , verifier . get value ( ) ) ; request . add body parameter ( str , config . get callback ( ) ) ; response response = request . send ( ) ; string body = response . get body ( ) ; json node json = json helper . get first node ( body ) ; if ( json != null ) { return new token ( ( string ) json helper . get ( json , str ) , str , body ) ; } else { return null ; } }	Makes the call to request an access token for an authorized user.
@ override public void sign request ( token access token , o request ) { request . add header ( str , str + access token . get token ( ) ) ; }	Adds an authorization header containing the bearer token to a request.It is intended for use in API calls after getting the access token, suchas requesting the user's profile.
@ override public string get authorization url ( o config ) { preconditions . check valid url ( config . get callback ( ) , str ) ; return string . format ( authorize url , config . get api key ( ) , o . encode ( config . get callback ( ) ) , scopes ) ; }	Returns the URL for authorizing the user.
public boolean perform finish ( ) { final string container name = get project name ( ) ; final i location = project page . use defaults ( ) ? null : project page . get location path ( ) ; i op = new i ( ) { public void run ( i monitor ) throws invocation target exception { try { do finish ( container name , location , monitor ) ; } catch ( core exception e ) { throw new invocation target exception ( e ) ; } finally { monitor . done ( ) ; } } } ; try { get container ( ) . run ( bool , bool , op ) ; } catch ( interrupted exception e ) { return bool ; } catch ( invocation target exception e ) { throwable real exception = e . get target exception ( ) ; message dialog . open error ( get shell ( ) , str , real exception . get message ( ) ) ; return bool ; } return bool ; }	This method is called when 'Finish' button is pressed in the wizard.
private void do finish ( string container name , i location , i monitor ) throws core exception {	The worker method. It will find the container, create the file if missingor just replace its contents, and open the editor on the newly createdfile.
public void create control ( composite parent ) { composite composite = new composite ( parent , swt . null ) ; composite . set layout ( new grid layout ( num , bool ) ) ; create artifact group ( composite ) ; create properties group ( composite ) ; set archetype ( ) ; validate ( ) ; set control ( composite ) ; }	Creates page controls.
protected string get default java package ( ) { return project wizard parameters page . get default java package ( group id combo . get text ( ) . trim ( ) , artifact id combo . get text ( ) . trim ( ) ) ; }	Returns the default package name.
public void set visible ( boolean visible ) { super . set visible ( visible ) ; boolean should validate = bool ; if ( visible ) { if ( group id combo . get text ( ) . length ( ) == num && group id combo . get item count ( ) > num ) { group id combo . set text ( group id combo . get item ( num ) ) ; package combo . set text ( get default java package ( ) ) ; package customized = bool ; } if ( should validate ) { validate ( ) ; } } }	Loads the group value when the page is displayed.
public string create query debug string ( ) {	Creates a human-readable representation of the query that will be createdfrom this builder.
private list < object > get query parameters as list ( ) {	Creates an ordered list of all parameter values registered atthe root criteria.
public void create part control ( composite parent ) { viewer = new palette viewer ( ) ; viewer . create control ( parent ) ; palette root root = new palette root ( ) ; string [ ] category = get categories ( ) ; for ( int i = num ; i < category . length ; i ++ ) { palette drawer group = new palette drawer ( category [ i ] ) ; i [ ] items = get palette items ( category [ i ] ) ; for ( int j = num ; j < items . length ; j ++ ) { html entry = new html ( items [ j ] . get label ( ) , null , items [ j ] . get image descriptor ( ) ) ; tools . put ( entry , items [ j ] ) ; group . add ( entry ) ; } root . add ( group ) ; } viewer . set palette root ( root ) ; viewer . get control ( ) . add mouse listener ( new mouse adapter ( ) { @ override public void mouse double click ( mouse event e ) {	create controls and apply configurations.
private void add palette item ( string category , i item ) { if ( items . get ( category ) == null ) { list < i > list = new array list < i > ( ) ; items . put ( category , list ) ; } list < i > list = items . get ( category ) ; list . add ( item ) ; }	Adds PaletteItem to the specified category.
private i [ ] get palette items ( string category ) { list < i > list = items . get ( category ) ; if ( list == null ) { return new i [ num ] ; } return list . to array ( new i [ list . size ( ) ] ) ; }	Returns PaletteItems which are contained by the specified category.
private void configure table resizing ( final composite parent , final table table , final table column column1 , final table column column2 ) { parent . add control listener ( new control adapter ( ) { public void control resized ( control event e ) { rectangle area = parent . get client area ( ) ; point preferred size = table . compute size ( swt . default , swt . default ) ; int width = area . width - num * table . get border width ( ) ; if ( preferred size . y > area . height ) {	Correctly resizes the table so no phantom columns appear.
private template get selected template ( ) { template template = null ; i selection = ( i ) f table viewer . get selection ( ) ; if ( selection . size ( ) == num ) { template = ( template ) selection . get first element ( ) ; } return template ; }	Get the currently selected template.
string get template string ( ) { string template string = null ; template template = get selected template ( ) ; if ( template != null ) { template context type context type = ui . get default ( ) . get template context registry ( ) . get context type ( card context type . context type ) ; i document = new document ( ) ; template context context = new document template context ( context type , document , num , num ) ; try { template buffer buffer = context . evaluate ( template ) ; template string = buffer . get string ( ) ; } catch ( exception e ) { ui . log error ( str , e ) ; } } return template string ; }	Returns template string to insert.
private void load last saved preferences ( ) { f last selected template name = str ;	Load the last template name used in New HTML File wizard.
void save last saved preferences ( ) { string template name = str ;	Save template name used for next call to New HTML File wizard.
private void set selected template ( string template name ) { object template = null ; if ( template name != null && template name . length ( ) > num ) {	Select a template in the table viewer given the template name.
void update viewer input ( ) { template template = get selected template ( ) ; if ( template != null ) { f pattern viewer . get document ( ) . set ( template . get pattern ( ) ) ; string image id = str + template . get name ( ) . replace ( str , str ) . to lower case ( ) ; image descriptor desc = image registry . get descriptor ( image id ) ; if ( desc != null ) { f image . set image ( desc . create image ( ) ) ; } else { f image . set image ( null ) ; } } else { f pattern viewer . get document ( ) . set ( str ) ;	Updates the pattern viewer.
public static criterion in ( string relative path , collection < ? > values ) { return new in expression ( relative path , values . to array ( ) ) ; }	Adds an "in" restriction to a persistent field.
public static criterion member of ( string relative path , object value ) { return new member of expression ( relative path , value , bool ) ; }	Creates a "member of" restriction.
public static criterion not member of ( string relative path , object value ) { return new member of expression ( relative path , value , bool ) ; }	Creates a "not member of" restriction.
public void create field editors ( ) { add field ( new string field editor ( preference constants . client id , str , get field editor parent ( ) ) ) ; add field ( new string field editor ( preference constants . client secret , str , get field editor parent ( ) ) ) ; }	Creates the field editors.
public static string get last path component ( string path ) {	Returns the last component of a dot-separated path.
protected void initial populate container name field ( ) { super . initial populate container name field ( ) ; i full path = get container full path ( ) ; i project = get project from path ( full path ) ; i root = project utils . get root container for path ( project , full path ) ; if ( root != null ) { return ; } root = project utils . get default root container ( project ) ; if ( root != null ) { set container full path ( root ) ; return ; } }	This method is overridden to set the selected folder to web contentsfolder if the current selection is outside the web contents folder.
protected boolean validate page ( ) { set message ( null ) ; set error message ( null ) ; if ( ! super . validate page ( ) ) { return bool ; } string file name = get file name ( ) ; i full path = get container full path ( ) ; if ( ( full path != null ) && ( full path . is empty ( ) == bool ) && ( file name != null ) ) {	This method is overridden to set additional validation specific to htmlfiles.
private boolean extension valid for content type ( string file name ) { boolean valid = bool ; i type = get content type ( ) ;	Verifies if fileName is valid name for content type.
string add default extension ( string filename ) { string buffer new file name = new string buffer ( filename ) ; string ext = str ; new file name . append ( str ) ;	Adds default extension to the filename.
private i get project from path ( i path ) { i workspace = resources plugin . get workspace ( ) ; i project = null ; if ( path != null ) { if ( workspace . validate path ( path . to string ( ) , i . project ) . is ok ( ) ) { project = workspace . get root ( ) . get project ( path . to string ( ) ) ; } else { project = workspace . get root ( ) . get file ( path ) . get project ( ) ; } } return project ; }	Returns the project that contains the specified path.
public string get user id ( http servlet request request ) { http session session = request . get session ( ) ; return ( string ) session . get attribute ( str ) ; }	Get the current user's ID from the session.
void create page0 ( ) { try { text editor = new structured text editor ( ) ; int index = add page ( text editor , get editor input ( ) ) ; set page text ( index , str ) ; set part name ( text editor . get title ( ) ) ; } catch ( part init exception e ) { error dialog . open error ( get site ( ) . get shell ( ) , str , null , e . get status ( ) ) ; } }	Creates Structured Twext Editot of the multi-page editor, which contains an HTML editor.
public void do save as ( ) { i editor = get editor ( num ) ; editor . do save as ( ) ; set page text ( num , editor . get title ( ) ) ; set input ( editor . get editor input ( ) ) ; }	Saves the multi-page editor's document as another file.
public void resource changed ( final i event ) { if ( event . get type ( ) == i . pre close ) { display . get default ( ) . async exec ( new runnable ( ) { public void run ( ) { i [ ] pages = get site ( ) . get workbench window ( ) . get pages ( ) ; for ( int i = num ; i < pages . length ; i ++ ) { if ( ( ( file editor input ) text editor . get editor input ( ) ) . get file ( ) . get project ( ) . equals ( event . get resource ( ) ) ) { i editor part = pages [ i ] . find editor ( text editor . get editor input ( ) ) ; pages [ i ] . close editor ( editor part , bool ) ; } } } } ) ; } }	Closes all project files on project close.
void show page ( ) { string editor text = get document provider ( ) . get document ( text editor . get editor input ( ) ) . get ( ) ; delete preview files ( ) ; file file = to preview file ( editor text ) ; if ( file != null ) { preview files list . add ( file ) ; string s = str + file . get absolute path ( ) ;	Sorts the words in page 0, and shows them in page 2.
public static string create query log message ( string query , list < object > parameter values ) {	Method to create a human readable log message regarding a generated query.
private static string object to string ( object obj ) {	Helper method to create a string representation of an object.
public timeline item insert timeline item ( timeline item item ) throws io { return get mirror ( ) . timeline ( ) . insert ( item ) . execute ( ) ; }	Inserts a simple timeline item.
public void insert timeline item ( timeline item item , string attachment content type , byte [ ] attachment data ) throws io { mirror . timeline timeline = get mirror ( ) . timeline ( ) ; timeline . insert ( item , new byte array content ( attachment content type , attachment data ) ) . execute ( ) ; }	Inserts an item with an attachment provided as a byte array.
public void insert timeline item ( timeline item item , string attachment content type , input stream attachment input stream ) throws io { insert timeline item ( item , attachment content type , byte streams . to byte array ( attachment input stream ) ) ; }	Inserts an item with an attachment provided as an input stream.
private void validate ( final cache response response , final string keyword ) { if ( ! response . get message ( ) . to lower case ( locale . us ) . starts with ( keyword ) ) { throw new illegal argument exception ( response . get message ( ) ) ; } }	Validates that the keyword expected was returned.
public string to query string ( criteria criteria , criteria query builder query builder ) { string absolute path = query builder . get absolute path ( criteria , relative path ) ; return ascending ? absolute path : absolute path + str ; }	Renders the order to a ORDER BY substring of JPQL query.
public template store get template store ( ) { if ( f template store == null ) { f template store = new contribution template store ( get template context registry ( ) , get preference store ( ) , str ) ; try { f template store . load ( ) ; } catch ( io e ) { log error ( str , e ) ; } } return f template store ; }	Returns the template store for the html editor templates.
public context type registry get template context registry ( ) { if ( f context type registry == null ) { contribution context type registry registry = new contribution context type registry ( ) ; registry . add context type ( card context type . context type ) ; f context type registry = registry ; } return f context type registry ; }	Returns the template context type registry for the html plugin.
protected i get action ( i editor , string action id ) { return ( editor == null ? null : editor . get action ( action id ) ) ; }	Returns the action registed with the given text editor.
private dbi create dbi ( ) throws exception { if ( driver != null ) { class . for name ( driver ) . new instance ( ) ; } return new dbi ( url , user , password ) ; }	Creates the datasource config based on the provided parameters.
protected void append limit and off set ( final string builder sql , final page page ) { sql . append ( str ) . append ( page . get page size ( ) ) . append ( str ) . append ( page . get offset ( ) ) ; }	Appends LIMIT and OFFSET for POSTGRESQL SQL queries SELECT select_listFROM table_expression[ ORDER BY ..
public static < n > named property < n > named property ( final n name , final property value < n > value ) { return new named property . impl < > ( name , value ) ; }	Create a value property from a literal value.
public static < n > named property < n > named property ( final n name , final string value ) { return named property ( name , datatree . < n > literal ( value ) ) ; }	Create a value property from a string value.
public static < n > named property < n > named property ( final n name , final nested document < n > value ) { return new named property . impl < > ( name , value ) ; }	Create a value property from a nested document value.
public static < n > literal . string literal < n > literal ( final string value ) { return new literal . string literal < > ( value ) ; }	Create a string literal.
public static < n > literal . uri literal < n > literal ( final uri value ) { return new literal . uri literal < > ( value ) ; }	Create a URI literal.
public static < n > literal . typed literal < n > literal ( final string value , final q type ) { return new literal . typed literal < > ( value , type ) ; }	Create a typed literal.
public static q q ( string namespace uri , string local part , string prefix ) { return new q ( namespace uri , local part , prefix ) ; }	Create a QName from a namespace URI, local part and prefix.
public void init ( final filter config filter config ) throws servlet exception {	This method is invoked by the web container to initialise thefilter at startup.
public void created ( final uuid created by entity id ) { if ( this . entity id != null ) { throw new illegal state exception ( str + entity id ) ; } this . entity id = uuid . random uuid ( ) ; this . entity version = num ; this . created by entity id = created by entity id ; this . updated by entity id = created by entity id ; this . entity created on = system . current time millis ( ) ; this . entity updated on = this . entity created on ; }	Call this method when the entity is updated to increment its version and update its lastupdatedByEntityId.
protected void init ( json parser parser ) throws io { logger factory . get logger ( get class ( ) ) . warn ( str , parser . get current name ( ) ) ; }	Sub-classes should override this to parse sub-class specific fields.This is invoked by init(InputStream), when an unknown field is encountered.
public void updated ( final uuid lastupdated by entity id ) { if ( this . entity id == null ) { throw new illegal state exception ( str ) ; } assert . not null ( lastupdated by entity id , str ) ; entity version ++ ; updated by entity id = lastupdated by entity id ; entity updated on = system . current time millis ( ) ; }	Call this method when the entity is updated before it is persisted to increment its version and update its lastupdatedByEntityId.
public void close ( int port ) { for ( iterator i = listeners . key set ( ) . iterator ( ) ; i . has next ( ) ; ) { object k = i . next ( ) ; object s = listeners . get ( k ) ; if ( s instanceof socket handler ) { socket handler sh = ( socket handler ) s ; if ( port == - num || sh . is port ( port ) ) { sh . interrupt ( ) ; sh . close ( ) ; transactions . remove ( s ) ; listeners . remove ( k ) ; } } } }	Closes a port. All connections on this port will be closed.
public static final void main ( string [ ] args ) { if ( args . length != num ) { system . err . println ( str ) ; system . exit ( num ) ; } int port = integer . value of ( args [ num ] ) . int value ( ) ; system . out . println ( version . version ) ; try { new server ( port ) ; } catch ( exception e ) { system . err . println ( str ) ; e . print stack trace ( system . err ) ; } }	Gozirra is probably not the best choice for a stand-alone server.
public void validate opts ( object instance ) { final set < constraint violation < object > > set = validator . validate ( instance ) ; final string builder sb = new string builder ( ) ; for ( constraint violation < object > violation : set ) { final path path = violation . get property path ( ) ; final string msg = violation . get message ( ) ; sb . append ( path . to string ( ) ) . append ( str ) . append ( msg ) . append ( str ) ; } if ( sb . length ( ) > num ) {	This method will only be called if we know that JSR 303 1.0 Bean Validation APIand compliant implementation are available on classpath.
public void validate args ( list < object > args , object instance , method m , command cmd ) { final set < constraint violation < object > > set = validator . validate parameters ( instance , m , args . to array ( ) ) ; final string builder sb = new string builder ( ) ; for ( constraint violation < object > violation : set ) { final path path = violation . get property path ( ) ; final string msg = violation . get message ( ) ; string var = path . to string ( ) ; try { int pos = integer . parse int ( str + var . char at ( var . length ( ) - num ) ) ; argument arg = cmd . get arguments ( ) . get ( pos ) ; sb . append ( arg . get name ( ) ) . append ( str ) . append ( msg ) . append ( str ) ; } catch ( exception e ) { sb . append ( var ) . append ( str ) . append ( msg ) . append ( str ) ; } } if ( sb . length ( ) > num ) {	This method will only be called if we know that JSR 303 1.1 Bean Validation APIand compliant implementation are available on classpath.Method validation was first introduced in version 1.1.
public void subscribe ( string name , listener listener , map headers ) { synchronized ( listeners ) { if ( listener != null ) { list list = ( list ) listeners . get ( name ) ; if ( list == null ) { list = new array list ( ) ; listeners . put ( name , list ) ; } if ( ! list . contains ( listener ) ) list . add ( listener ) ; } } if ( headers == null ) headers = new hash map ( ) ; headers . put ( str , name ) ; transmit ( command . subscribe , headers ) ; }	Subscribe to a channel.
public void unsubscribe ( string name , listener l ) { synchronized ( listeners ) { list list = ( list ) listeners . get ( name ) ; if ( list != null ) { list . remove ( l ) ; if ( list . size ( ) == num ) { unsubscribe ( name ) ; } } } }	Unsubscribe a single listener from a channel.
public void unsubscribe ( string name , map header ) { if ( header == null ) header = new hash map ( ) ; synchronized ( listeners ) { listeners . remove ( name ) ; } header . put ( str , name ) ; transmit ( command . unsubscribe , header ) ; }	Unsubscribe from a channel.
public void unsubscribe w ( string name , map header ) throws interrupted exception { string receipt = add receipt ( header ) ; unsubscribe ( name , ( hash map ) null ) ; wait on receipt ( receipt ) ; }	Unsubscribe from a channel.
public void send ( string dest , string mesg , map header ) { if ( header == null ) header = new hash map ( ) ; header . put ( str , dest ) ; transmit ( command . send , header , mesg ) ; }	Send a message to a channel.
public message get next ( string name ) { synchronized ( queue ) { for ( int idx = num ; idx < queue . size ( ) ; idx ++ ) { message m = ( message ) queue . get ( idx ) ; if ( m . headers ( ) . get ( str ) . equals ( name ) ) { queue . remove ( idx ) ; return m ; } } } return null ; }	Get the next unconsumed message for a particular channel.
public boolean has receipt ( string receipt id ) { synchronized ( receipts ) { for ( iterator i = receipts . iterator ( ) ; i . has next ( ) ; ) { string o = ( string ) i . next ( ) ; if ( o . equals ( receipt id ) ) return bool ; } } return bool ; }	Checks to see if a receipt has come in.
public void clear receipt ( string receipt id ) { synchronized ( receipts ) { for ( iterator i = receipts . iterator ( ) ; i . has next ( ) ; ) { string o = ( string ) i . next ( ) ; if ( o . equals ( receipt id ) ) i . remove ( ) ; } } }	Deletes all receipts with a given ID.
@ subscribe public void log dead event ( final dead event dead event ) { final object event = dead event . get event ( ) ; log . warn ( str , bean name , event . get class ( ) . get name ( ) , event ) ; }	Logs dead event as warnings.
public < t > t convert ( final object source , final class < t > targetclass ) { if ( source == null ) { return null ; } final class < ? > sourceclass = source . get class ( ) ; final source target pair key key = new source target pair key ( sourceclass , targetclass ) ; converter converter = cache . get ( key ) ; if ( converter != null ) { return ( t ) converter . convert ( source , targetclass ) ; } final linked list < source target pair match > matches = new linked list < source target pair match > ( ) ; for ( source target pair pair : converters . values ( ) ) { source target pair match match = pair . match ( sourceclass , targetclass ) ; if ( match . matches source ( ) && match . matches target ( ) ) { matches . add ( match ) ; } } if ( matches . size ( ) == num ) { throw new conversion exception ( str + targetclass . get name ( ) + str + sourceclass . get name ( ) + str + converters . key set ( ) + str ) ; } collections . sort ( matches , source target pair match . best target match ( ) ) ; converter = matches . get ( num ) . pair . converter ; cache . put ( key , converter ) ; return ( t ) converter . convert ( source , targetclass ) ; }	Convert a value to a specific class.The algorithm for finding a suitable converter is as follows:Find converters that is able to convert both source and target; a exact orsuperclass match.
protected priority get priority ( final int lines ) { if ( lines >= high threshold ) { return priority . high ; } else if ( lines >= normal threshold ) { return priority . normal ; } else { return priority . low ; } }	Returns the priority of the warning.
public void execute ( gn p ) { if ( instance == null ) { instance = utils . new instance ( class name ) ; } final class < ? > clazz = instance . get class ( ) ; final method [ ] methods = clazz . get declared methods ( ) ; for ( method m : methods ) { m . set accessible ( bool ) ; if ( ! m . get name ( ) . equals ( p . get command ( ) ) ) { continue ; } final list < object > args = adjust args ( p . get args ( ) , m ) ; inject opts ( p , clazz ) ; try { validate args ( args , instance , m , this ) ; m . invoke ( instance , args . to array ( ) ) ; return ; } catch ( invocation target exception e ) { final throwable ex = e . get target exception ( ) ; if ( ex instanceof runtime exception ) { throw ( runtime exception ) e . get cause ( ) ; } else { throw new runtime exception ( e . get target exception ( ) ) ; } } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { throw new runtime exception ( e ) ; } } system . out . println ( p . get command ( ) + str ) ; }	Execute this command according to the user input argumentsparsed by the parser.
private void inject opts ( gn p , class < ? > clazz ) { for ( field f : clazz . get declared fields ( ) ) { f . set accessible ( bool ) ; final cli option anno = f . get annotation ( cli option . class ) ; if ( anno == null ) { continue ; } string value = p . get short opt ( anno . short name ( ) ) ; if ( value == null ) { value = p . get long opt ( f . get name ( ) ) ; if ( value == null ) { continue ; } } try { f . set ( instance , c . convert ( value , f . get type ( ) ) ) ; } catch ( conversion exception e ) { throw cli exception . wrong opt type ( f . get name ( ) , f . get type ( ) . get name ( ) , value ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } } validate opts ( instance ) ; }	Convert options to appropriate type and inject them intothe command instance.
private list < object > adjust args ( list < string > args , method m ) { final list < object > result = new array list < object > ( ) ; final class < ? > [ ] types = m . get parameter types ( ) ; if ( m . is var args ( ) ) { types [ types . length - num ] = types [ types . length - num ] . get component type ( ) ; if ( ! string . class . is assignable from ( types [ types . length - num ] ) ) { throw new cli exception ( str ) ; } types [ types . length - num ] = string . class ; } list < object > varargs = new array list < > ( ) ; for ( int i = num ; i < args . size ( ) ; i ++ ) { try { if ( m . is var args ( ) && i >= types . length - num ) { varargs . add ( c . convert ( args . get ( i ) , types [ types . length - num ] ) ) ; } else { result . add ( c . convert ( args . get ( i ) , types [ i ] ) ) ; } } catch ( conversion exception e ) { throw cli exception . wrong arg type ( get arguments ( ) . get ( i ) . get name ( ) , types [ i ] . get name ( ) , args . get ( i ) ) ; } } if ( m . is var args ( ) ) { result . add ( varargs . to array ( new string [ num ] ) ) ; } return result ; }	Add or remove parameters to fit the method declaration and also convert themto appropriate data type.
private list < migration result > migrate personality ( final metadata manager metadata manager , final string personality name , final integer target version , final migratory option [ ] options ) { final integer current version = metadata manager . get current version ( personality name ) ; if ( current version == null && ! migratory config . is create personalities ( ) ) { throw new migratory exception ( reason . new personalities denied ) ; }	Performs the migration of a personality.
public void handle actual request ( final http servlet request request , final http servlet response response ) throws cors , cors , http { if ( cors . detect ( request ) != cors . actual ) throw new cors ( str ) ;	Handles a simple or actual CORS request. CORS specification: Simple Cross-Origin Request, Actual Request, and Redirects .
public void handle preflight request ( final http servlet request request , final http servlet response response ) throws cors , cors , http , http { if ( cors . detect ( request ) != cors . preflight ) throw new cors ( str ) ;	Handles a preflight CORS request. CORS specification: Preflight Request .
protected string check ( ) { string error ; if ( ! m . exists ( ) ) return str + m ; if ( ! m . is directory ( ) ) return str + m ; if ( system . get property ( str ) . to lower case ( ) . contains ( str ) ) m = new file ( m . get absolute path ( ) + file . separator + str + file . separator + str ) ; else m = new file ( m . get absolute path ( ) + file . separator + str + file . separator + str ) ; if ( ! m . exists ( ) ) return str + m ; if ( ! m . exists ( ) ) return str + m ; if ( m . is directory ( ) ) return str + m ;	Performs some checks.
protected list < string > filter ( list < string > lines , string regexp , boolean invert ) { list < string > result ; pattern pattern ; result = new array list < > ( ) ; pattern = pattern . compile ( regexp ) ; for ( string line : lines ) { if ( invert ) { if ( ! pattern . matcher ( line ) . matches ( ) ) result . add ( line ) ; } else { if ( pattern . matcher ( line ) . matches ( ) ) result . add ( line ) ; } } return result ; }	Filters the list of strings with a regular expression.
protected string packages reg exp ( ) { string builder result ; int i ; string pkg ; result = new string builder ( ) ; result . append ( str ) ; for ( i = num ; i < m . size ( ) ; i ++ ) { if ( i > num ) result . append ( str ) ; pkg = m . get ( i ) ; if ( ! pkg . ends with ( str ) ) pkg = pkg + str ; pkg = pkg . replace ( str , str ) ; result . append ( pkg ) ; } result . append ( str ) ; return result . to string ( ) ; }	Builds the regular expression for the packages to keep.
public void output ( ) { if ( ( m == null || m . is directory ( ) ) ) { for ( string dep : m ) system . out . println ( dep ) ; } else { try { files . write ( m . to path ( ) , m , standard open option . create , standard open option . truncate existing ) ; } catch ( exception e ) { system . err . println ( str + m ) ; e . print stack trace ( ) ; } } }	Outputs the dependencies on stdout.
@ override public int compare to ( instance provider instance provider ) { if ( this . get priority ( ) . equals ( instance provider . get priority ( ) ) ) { return this . get name ( ) . compare to ( instance provider . get name ( ) ) ; } else { return this . get priority ( ) . compare to ( instance provider . get priority ( ) ) ; } }	Default implementation of compareTo for the InstanceManager.
public static io get io ( ) { if ( io utils == null ) { try { class clazz = class . for name ( io utils ) ; io utils = ( io ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return io utils ; }	Retrieve IOUtils implementation.
public static image utils get image utils ( ) { if ( image utils == null ) { try { class clazz = class . for name ( image utils ) ; image utils = ( image utils ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return image utils ; }	Retrieve ImageUtils implementation.
public static price utils get price utils ( ) { if ( price utils == null ) { try { class clazz = class . for name ( price utils ) ; price utils = ( price utils ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return price utils ; }	Retrieve PriceUtils implementation.
public static resource utils get resource utils ( ) { if ( resource utils == null ) { try { class clazz = class . for name ( resource utils ) ; resource utils = ( resource utils ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return resource utils ; }	Retrieve ResourceUtils implementation.
public static zip utils get zip utils ( ) { if ( zip utils == null ) { try { class clazz = class . for name ( zip utils ) ; zip utils = ( zip utils ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return zip utils ; }	Retrieve ZipUtils implementation.
public static digest utils get digest utils ( ) { if ( digest utils == null ) { try { class clazz = class . for name ( digest utils ) ; digest utils = ( digest utils ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return digest utils ; }	Retrieve DigestUtils implementation.
public static string utils get string utils ( ) { if ( string utils == null ) { try { class clazz = class . for name ( string utils ) ; string utils = ( string utils ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return string utils ; }	Retrieve StringUtils implementation.
public static resource service get resource service ( ) { if ( resource service == null ) { try { class clazz = class . for name ( resource service ) ; resource service = ( resource service ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return resource service ; }	Retrieve ResourceService implementation.
public static pricing service get pricing service ( ) { if ( pricing service == null ) { try { class clazz = class . for name ( pricing service ) ; pricing service = ( pricing service ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return pricing service ; }	Retrieve PricingService implementation.
public static instance service get instance service ( ) { if ( instance service == null ) { try { class clazz = class . for name ( instance service ) ; instance service = ( instance service ) clazz . new instance ( ) ; } catch ( class not found exception | instantiation exception | illegal access exception e ) { logger . warn ( str , e . get message ( ) ) ; throw new illegal state exception ( e ) ; } } return instance service ; }	Retrieve InstanceService implementation.
@ override public set < string > get object id ( file uploaded file ) throws harvester exception { set < string > object ids = new hash set < string > ( ) ; try { object ids . add ( create digital object ( uploaded file ) ) ; } catch ( storage exception se ) { throw new harvester exception ( se ) ; } return object ids ; }	Get an individual uploaded file as a digital object.
private string create digital object ( file file ) throws harvester exception , storage exception { string object id ; digital object object ; if ( force update ) { object = storage utils . store file ( get storage ( ) , file , ! force local storage ) ; } else { string oid = storage utils . generate oid ( file ) ; string pid = storage utils . generate pid ( file ) ; object = get storage ( ) . create object ( oid ) ; if ( force local storage ) { try { object . create stored payload ( pid , new file input stream ( file ) ) ; } catch ( file not found exception ex ) { throw new harvester exception ( ex ) ; } } else { object . create linked payload ( pid , file . get absolute path ( ) ) ; } }	Store the provided file in storage.
private void store list ( properties props , map < string , list < string > > details , string field ) { set < string > value set = new linked hash set < string > ( ) ;	Take a list of strings from a Java Map, concatenate the values togetherand store them in a Properties object using the Map's original key.
public list < metadata info > ensure metadata ( final migratory option [ ] options ) throws migratory exception { if ( migratory context . get db support ( ) . table exists ( migratory config . get metadata table name ( ) ) ) { return null ; } if ( migratory config . is read only ( ) ) { throw new migratory exception ( reason . is readonly ) ; }	Make sure that the metadata exists.
private object create dry source detail ( final abstract build < ? , ? > owner , final annotation container container , final string default encoding , final string from string , final string to string ) { long from = long . parse long ( from string ) ; long to = long . parse long ( to string ) ; file annotation from annotation = container . get annotation ( from ) ; if ( from annotation instanceof duplicate code ) { return new source detail ( owner , ( ( duplicate code ) from annotation ) . get link ( to ) , default encoding ) ; } return null ; }	Creates the dry source detail view.
private form validation validate ( final string high threshold , final string normal threshold , final string message ) { try { int high = integer . parse int ( high threshold ) ; int normal = integer . parse int ( normal threshold ) ; if ( is valid ( normal , high ) ) { return form validation . ok ( ) ; } } catch ( number format exception exception ) {	Performs on-the-fly validation on thresholds for high and normal warnings.
static void validate args ( list < object > args , object instance , method m , command cmd ) { if ( ! on classpath ( js 1 1 classname ) ) { return ; } try { object validator = get validator ( ) ; method validate = validator . get class ( ) . get method ( str , list . class , object . class , method . class , command . class ) ; validate . invoke ( validator , args , instance , m , cmd ) ; } catch ( invocation target exception e ) { if ( e . get target exception ( ) instanceof runtime exception ) { throw ( runtime exception ) e . get cause ( ) ; } throw new runtime exception ( e . get cause ( ) ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	Validate that the method parameters if Bean Validation 1.1 is availableon classpath.
static void validate opts ( object instance ) { if ( ! on classpath ( js 1 0 classname ) ) { return ; } try { object validator = get validator ( ) ; method validate = validator . get class ( ) . get method ( str , object . class ) ; validate . invoke ( validator , instance ) ; } catch ( invocation target exception e ) { if ( e . get target exception ( ) instanceof runtime exception ) { throw ( runtime exception ) e . get target exception ( ) ; } throw new runtime exception ( e . get target exception ( ) ) ; } catch ( runtime exception e ) { throw e ; } catch ( throwable e ) { throw new runtime exception ( e ) ; } }	Validate that the options if Bean Validation is available on classpath.
static boolean on classpath ( string class name ) { class loader cl = thread . current thread ( ) . get context class loader ( ) ; try { cl . load class ( class name ) ; } catch ( class not found exception e ) { return bool ; } return bool ; }	Checks to see if JSR303 implementation isavailable on classpath.
public boolean accept ( final uri uri ) { for ( final migration loader loader : loaders ) { if ( loader . accept ( uri ) ) { return bool ; } } return bool ; }	Returns true if this loader accepts the URI.
public string load file ( final uri file uri ) { try { for ( final migration loader loader : loaders ) { if ( loader . accept ( file uri ) ) { return loader . load file ( file uri ) ; } } return null ; } catch ( io ioe ) { throw new migratory exception ( reason . internal , ioe ) ; } }	Load a file from an URI.
public void run ( ) throws runtime exception { if ( terminal args == null ) { terminal args = new string [ num ] ; } p = gn . parse ( terminal args ) ; read commands ( ) ; if ( p . get command ( ) == null || str . equals ( p . get command ( ) ) ) { utils . print available commands help ( commands ) ; return ; } final command cmd = commands . get ( p . get command ( ) ) ; if ( cmd == null ) { throw cli exception . command not found ( p . get command ( ) ) ; } if ( p . help ( ) ) { utils . print command help ( cmd ) ; return ; } try { cmd . execute ( p ) ; } catch ( exception e ) { if ( p . debug ( ) ) { e . print stack trace ( ) ; } if ( e instanceof runtime exception ) { throw ( runtime exception ) e ; } } }	Start evaluating the user input and eventually execute the commandrequested by the user.
private void read commands ( ) { try { final enumeration < url > urls = thread . current thread ( ) . get context class loader ( ) . get resources ( xml commands . filepath ) ; while ( urls . has more elements ( ) ) { url url = urls . next element ( ) ; input stream in = url . open stream ( ) ; for ( command command : xml commands . from xml ( in ) ) { commands . put ( command . get command ( ) , command ) ; } } } catch ( io e ) { throw new runtime exception ( e ) ; } }	Find all commands available on classpath.
protected void post process ( final string target , final request base request , final http servlet request request , final http servlet response response ) throws io , servlet exception {	The purpose of this methods is to allow the Handler to return an HTTP response.
protected map < string , object > pre process ( final string target , final request base request , final http servlet request request , final http servlet response response ) throws io , servlet exception { return collections . empty map ( ) ; }	Validate the request and extract any data from the HTTP request that will be required to process the request asynchronously.If the request is invalid, then handle the request appropriately.*** NOTE: to indicate that this method handled the request, set Request.handled to true: baseRequest.setHandled(true);.
public map < string , list < metadata info > > db migrate ( final migration plan migration plan , final migratory option ... options ) throws migratory exception { init ( ) ; final internal migrator migrator = new internal migrator ( this ) ; return migrator . migrate ( migration plan , options ) ; }	Bring the current database to the requested levels.
public map < string , validation result > db validate ( final collection < string > personalities , final migratory option ... options ) throws migratory exception { init ( ) ; final internal validator validator = new internal validator ( this ) ; return validator . validate ( personalities , options ) ; }	Run validation on the database.
public map < string , list < metadata info > > db history ( final collection < string > personalities , final migratory option ... options ) throws migratory exception { init ( ) ; final internal history internal history = new internal history ( this ) ; return internal history . history ( personalities , options ) ; }	Returns the full history of all applied migrations.
public list < metadata info > db init ( final migratory option ... options ) throws migratory exception { init ( ) ; final internal init internal init = new internal init ( this ) ; return internal init . init ( options ) ; }	Creates and initializes the Migratory metadata table.Returns null if the table already exists, returns a list of migration resultsfor the migrations executed otherwise.
list < sql statement > lines to statements ( list < string > lines ) { final list < sql statement > statements = lists . new array list ( ) ; final string builder statement sql = new string builder ( ) ; int count = num ; string delimiter = default statement delimiter ; for ( final string line : lines ) { if ( string utils . is blank ( line ) ) { continue ; } if ( statement sql . length ( ) > num ) { statement sql . append ( str ) ; } statement sql . append ( line ) ; final string old delimiter = delimiter ; delimiter = change delimiter if necessary ( statement sql . to string ( ) , line , delimiter ) ; if ( ! string utils . equals ( delimiter , old delimiter ) && is delimiter change explicit ( ) ) { statement sql . set length ( num ) ; continue ;	Turns these lines in a series of statements.
@ programmatic public notable link find by notable and calendar name ( final object notable , final string calendar name ) { if ( notable == null ) { return null ; } if ( calendar name == null ) { return null ; } final bookmark bookmark = bookmark service . bookmark for ( notable ) ; if ( bookmark == null ) { return null ; } final string notable str = bookmark . to string ( ) ; return repository service . first match ( new query default < > ( notable link . class , str , str , notable str , str , calendar name ) ) ; }	Each notable can only have one note per calendar, thus this method returns a single object rather than a list.
private string [ ] parse opts ( string [ ] args ) { if ( args == null || args . length == num ) { return new string [ num ] ; } final list < string > remaining args = new array list < string > ( ) ; final list < string > args list = arrays . as list ( args ) ; final list iterator < string > args it = args list . list iterator ( ) ; while ( args it . has next ( ) ) { string word = args it . next ( ) ; if ( word . starts with ( str ) ) {	Parse the options for the command.
public void transmit ( command c , map h , string b ) { server . receive ( c , h , b , this ) ; }	Transmit a message to clients and listeners.
public string get formatted source code ( ) { try { java source source = new java source parser ( ) . parse ( new string reader ( source code ) ) ; html converter = new html ( ) ; string writer writer = new string writer ( ) ; java source conversion options options = java source conversion options . get default ( ) ; options . set show line numbers ( bool ) ; options . set add line anchors ( bool ) ; converter . convert ( source , options , writer ) ; return writer . to string ( ) ; } catch ( illegal configuration exception exception ) { return source code ; } catch ( io exception ) { return source code ; } }	Returns the duplicate source code fragment as formatted HTML string.
public file annotation get link ( final long link hash code ) { for ( file annotation link : links ) { if ( link . get key ( ) == link hash code ) { return link ; } } throw new no such element exception ( str + link hash code ) ; }	Returns the link with the specified hash code.
public void transmit ( command c , map h , string b ) { try { transmitter . transmit ( c , h , b , output ) ; } catch ( exception e ) { receive ( command . error , null , e . get message ( ) ) ; } }	Transmit a message to the server.
public static jaxb get ( final string context path ) { assert . has text ( context path , str ) ; jaxb ctx = jaxb contexts . get ( context path ) ; if ( ctx == null ) { try { ctx = jaxb . new instance ( context path ) ; } catch ( final jaxb e ) { throw new illegal argument exception ( str + context path , e ) ; } jaxb contexts . put ( context path , ctx ) ; logger factory . get logger ( jaxb . class ) . info ( str , context path ) ; } return ctx ; }	If the JAXBContext is not cached, then it will create a new instance and cache it.
private void create box list ( box root , vector < box node > list ) { if ( root . is displayed ( ) ) { if ( ! ( root instanceof viewport ) && root . is visible ( ) ) { box node newnode = new box node ( root , page , zoom ) ; newnode . set order ( order counter ++ ) ; list . add ( newnode ) ; } if ( root instanceof element box ) { element box elem = ( element box ) root ; for ( int i = elem . get start child ( ) ; i < elem . get end child ( ) ; i ++ ) create box list ( elem . get sub box ( i ) , list ) ; } } }	Recursively creates a list of all the visible boxes in a box subtree.
private void compute backgrounds ( box node root , color currentbg ) { color newbg = root . get background color ( ) ; if ( newbg == null ) newbg = currentbg ; root . set efficient background ( newbg ) ; root . set background separated ( ! newbg . equals ( currentbg ) ) ; for ( int i = num ; i < root . get child count ( ) ; i ++ ) compute backgrounds ( ( box node ) root . get child at ( i ) , newbg ) ; }	Computes efficient background color for all the nodes in the tree.
public void set mapping file ( url url , string real file ) { if ( component files == null ) init fast indexes ( str , str , str ) ; file file = new file ( real file ) ; component files . put ( url . get file ( ) , file ) ; }	Set the real file of component url.
public box transform concatenate ( box transform src ) { if ( src . is empty ( ) ) return this ; else if ( this . is empty ( ) ) return src ; else { box transform ret = new box transform ( this ) ; ret . transform = new affine transform ( transform ) ; ret . transform . concatenate ( src . transform ) ; return ret ; } }	Concatenates another transformation to this transformation.
public rectangular transform rect ( rectangular rect ) { if ( transform != null ) { rectangle src = new rectangle ( rect . get x1 ( ) , rect . get y1 ( ) , rect . get width ( ) , rect . get height ( ) ) ; shape dest = transform . create transformed shape ( src ) ; rectangle destr ; if ( dest instanceof rectangle ) destr = ( rectangle ) dest ; else destr = dest . get bounds ( ) ; return new rectangular ( destr ) ; } else return rect ; }	Transforms a rectangle to other rectangle using the given transformation.
private rectangular get minimal visual bounds ( ) { final box box = get box ( ) ; if ( box instanceof text box ) return new z ( box . get absolute bounds ( ) . intersection ( box . get clip block ( ) . get clipped content bounds ( ) ) , zoom ) ; else if ( box != null && box . is replaced ( ) ) return new z ( box . get minimal absolute bounds ( ) . intersection ( box . get clip block ( ) . get clipped content bounds ( ) ) , zoom ) ; else { rectangular ret = null ; for ( int i = num ; i < get child count ( ) ; i ++ ) { box node subnode = ( box node ) get child at ( i ) ; box sub = subnode . get box ( ) ; rectangular sb = subnode . get visual bounds ( ) ; if ( sub . is displayed ( ) && subnode . is visible ( ) && sb . get width ( ) > num && sb . get height ( ) > num ) { if ( ret == null ) ret = new rectangular ( sb ) ; else ret . expand to enclose ( sb ) ; } }	Returns the minimal bounds of the box for enclosing all the contained boxes.
public void recompute visual bounds ( ) { for ( int i = num ; i < get child count ( ) ; i ++ ) ( ( box node ) get child at ( i ) ) . recompute visual bounds ( ) ; visual = compute visual bounds ( ) ; }	Re-computes the visual bounds of the whole subtree.
public void recompute bounds ( ) { bounds = new rectangular ( visual ) ; for ( int i = num ; i < get child count ( ) ; i ++ ) { box node child = ( box node ) get child at ( i ) ; child . recompute bounds ( ) ; expand to enclose ( child ) ; } }	Recomputes the total bounds of the whole subtree.
private rectangular compute content bounds ( ) { box box = get box ( ) ; rectangular ret = null ; if ( box instanceof viewport ) { ret = new z ( ( ( viewport ) box ) . get clipped bounds ( ) , zoom ) ; } else if ( box instanceof element box ) { element box elem = ( element box ) box ;	Computes node the content bounds.
@ override public int get top border ( ) { box box = get box ( ) ; if ( box instanceof element box ) return ( ( element box ) box ) . get border ( ) . top ; else return num ; }	Obtains the top border of the box.
@ override public int get bottom border ( ) { box box = get box ( ) ; if ( box instanceof element box ) return ( ( element box ) box ) . get border ( ) . bottom ; else return num ; }	Obtains the bottom border of the box.
@ override public int get left border ( ) { box box = get box ( ) ; if ( box instanceof element box ) return ( ( element box ) box ) . get border ( ) . left ; else return num ; }	Obtains the left border of the box.
@ override public int get right border ( ) { box box = get box ( ) ; if ( box instanceof element box ) return ( ( element box ) box ) . get border ( ) . right ; else return num ; }	Obtains the right border of the box.
public string get efficient color ( ) { box box = get box ( ) ; do { if ( box instanceof element box ) { string color = ( ( element box ) box ) . get style property value ( str ) ; if ( ! color . equals ( str ) ) return color ; } box = box . get parent ( ) ; } while ( box != null ) ; return str ; }	Get the effective text color.
public boolean visually encloses1 ( box node child node ) { int cx1 = child node . get visual bounds ( ) . get x1 ( ) ; int cy1 = child node . get visual bounds ( ) . get y1 ( ) ; int cx2 = child node . get visual bounds ( ) . get x2 ( ) ; int cy2 = child node . get visual bounds ( ) . get y2 ( ) ; int px1 = get visual bounds ( ) . get x1 ( ) ; int py1 = get visual bounds ( ) . get y1 ( ) ; int px2 = get visual bounds ( ) . get x2 ( ) ; int py2 = get visual bounds ( ) . get y2 ( ) ;	Checks if another node is fully located inside the content bounds of this box.
public void take children ( vector < box node > list ) { for ( iterator < box node > it = list . iterator ( ) ; it . has next ( ) ; ) { box node node = it . next ( ) ; if ( node . nearest parent . equals ( this ) ) { append child ( node ) ; it . remove ( ) ; } }	Goes through the parent's children, takes all the nodes that are inside of this nodeand makes them the children of this node.
protected void process ( string command ) { try { method method = this . get class ( ) . get method ( command ) ; logger . info ( str , command ) ; method . invoke ( this ) ; logger . info ( str , command ) ; } catch ( no such method exception e ) { logger . warn ( str , command ) ; } catch ( exception e ) { logger . warn ( str , command ) ; } }	Process user specified command.
@ bean public data source data source ( ) {	Use this data source to create an embedded database.
@ bean public data source data source plain ( ) { simple driver data source ds = new simple driver data source ( ) ; ds . set driver class ( null ) ; ds . set url ( str ) ; ds . set username ( str ) ; ds . set password ( str ) ; return ds ; }	Use this data source to connect to an existing database.
public void setup ( platform configuration config , environment env ) { this . configuration = preconditions . check not null ( config , str ) ; this . environment = preconditions . check not null ( env , str ) ; }	Called when the configuration and environment come into scope.
public < t > t query ( method map method map , arg map arg map , class < t > response type ) throws open states exception { buffered reader reader = null ; url conn = null ; string char set = str ; try { if ( is caching ( method map , arg map ) ) { file file = get cache file ( method map , arg map ) ; long file length = file . length ( ) ; logger . fine ( str + file length + str + file . get name ( ) ) ; if ( file length == num ) { open states . cache file from api ( method map , arg map , file , response type ) ; } reader = new buffered reader ( new input stream reader ( new file input stream ( file ) , char set ) ) ; } else { conn = open states . get connection from api ( method map , arg map ) ; char set = get charset ( conn ) ;	Handles the actual API calls and caching.This is part of a static class and therefore is not thread-safe.
public void register ( command command ) { preconditions . check argument ( command != null , str + command + str ) ; register ( command . name ( ) , command ) ; }	Registers the specified command instance into the shell.
public void register ( string name , command command ) { preconditions . check argument ( name != null && ! name . is empty ( ) , str + name + str ) ; preconditions . check argument ( command != null , str + command + str ) ; commands . put ( name , command ) ; }	Registers the specified command instance into the shell with the specified name.
public void unregister ( string name ) { preconditions . check argument ( name != null && ! name . is empty ( ) , str + name + str ) ; commands . remove ( name ) ; }	Unregisters the command corresponding to the specified name from the shell.
@ suppress warnings ( str ) public void exec ( string line ) { string [ ] strings = line . split ( str ) ; if ( strings . length == num ) { return ; } string cmd = strings [ num ] ; if ( strings [ num ] == null || strings [ num ] . is empty ( ) ) { return ; } string [ ] args = { } ; if ( strings . length > num ) { args = new string [ strings . length - num ] ; system . arraycopy ( strings , num , args , num , args . length ) ; } command command = commands . get ( cmd ) ; if ( command == null ) {	Executes the specified command line input.
public void start ( ) { repl . set ( bool ) ; string line = null ; while ( repl . get ( ) && ( ( line = console . read line ( ) ) != null ) ) { exec ( line ) ; } }	Runs into the REPL mode.
public committees search by state chamber ( string state , string chamber ) throws open states exception { return api . query ( new method map ( str ) , new arg map ( str , state , str , chamber ) , committees . class ) ; }	Committee SearchThis method allows searching by state and chamber.Committee objects returned by this method do not include the list of members by default.
public committee detail ( string id ) throws open states exception { return api . query ( new method map ( str , id ) , null , committee . class ) ; }	Committee DetailThis method returns the full committee object given a committee id.
private static jmx connect ( string host , string port , string login , string password ) throws io {	Connect to the JMX service.
private static string get property ( properties properties , string key ) {	Get the property.
@ override public object invoke ( object proxy , method method , object [ ] args ) throws throwable { object result ; jmx connector = null ; try {	Invoke the method and return the result.
public districts search by state ( string state ) throws open states exception { return api . query ( new method map ( str , state ) , null , districts . class ) ; }	List districts for state.
public districts search ( string state , string chamber ) throws open states exception { return api . query ( new method map ( str , state , chamber ) , null , districts . class ) ; }	List districts for state and chamber.
public district boundary lookup ( string boundary id ) throws open states exception { return api . query ( new method map ( str , str , boundary id ) , null , district . class ) ; }	Get geographic boundary for a district.
public metadata state ( string state ) throws open states exception { return api . query ( new method map ( str , state ) , null , metadata . class ) ; }	Get detailed metadata for a particular state.
private static < t > t create object ( class < t > interface class ) { service loader < t > loader = service loader . load ( interface class ) ; t object = null ;	Create the MBean object.
public static < t > object name register ( class < t > interface class , object name object name ) throws m {	Register the MBean represented by the interface class.
public static void unregister ( object name object name ) throws m { try {	Unregister the MBean represented by the object name.
protected static void validate m ( class interface class , object name object name , m m bean server connection ) throws m { try {	Validate the MBean represented by the interface class and object name.
@ override public string get ( ) { try ( final timer . context context = timer . time ( ) ) { final string s = random uuid ( ) . to string ( ) ; if ( length == num || count == num ) { return s ; } final string joiner joiner = new string joiner ( str , str , str + s ) ; int stream . range closed ( num , count - num ) . for each ( x -> joiner . add ( s . substring ( x * length , ( x + num ) * length ) ) ) ; return joiner . to string ( ) ; } }	Mint a unique identifier as a UUID.
public void add value ( string value , boolean is default ) { p ( str + ( is default ? str : str ) + str + value + str + m field . get name ( ) ) ; string name = m wrapped parameter . names ( ) [ num ] ; if ( m assigned && ! is multi option ( ) ) { throw new parameter exception ( str + name + str ) ; } validate parameter ( name , value ) ; class < ? > type = m field . get type ( ) ; object converted value = m j commander . convert value ( this , value ) ; boolean is collection = collection . class . is assignable from ( type ) ; try { if ( is collection ) { @ suppress warnings ( str ) collection < object > l = ( collection < object > ) m field . get ( m object ) ; if ( l == null || field is set for the first time ( is default ) ) { l = new collection ( type ) ; m field . set ( m object , l ) ; } if ( converted value instanceof collection ) { l . add all ( ( collection ) converted value ) ; } else {	Add the specified value to the field.
public legislators search by state ( string state ) throws open states exception { return api . query ( new method map ( str ) , new arg map ( str , state ) , legislators . class ) ; }	Get Legislators by State.
public legislators search by state active ( string state , boolean active ) throws open states exception { return api . query ( new method map ( str ) , new arg map ( str , state , str , active . to string ( ) ) , legislators . class ) ; }	Get Legislators by State and Active filters.
public legislators search by state term ( string state , string term ) throws open states exception { return api . query ( new method map ( str ) , new arg map ( str , state , str , term ) , legislators . class ) ; }	Search for Legislators by State and Term.
public legislator detail ( string id ) throws open states exception { return api . query ( new method map ( str , id ) , null , legislator . class ) ; }	This method returns the full detail for a legislator.
public int compare to ( e o ) { if ( o . get class ( ) != get class ( ) ) { throw new class cast exception ( ) ; } return ordinal - typesafe enum . class . cast ( o ) . ordinal ; }	Compares with the specified object by ordinal.
public void set mapped class ( class < t > mapped class ) { if ( this . mapped class == null ) { initialize ( mapped class ) ; } else { if ( ! this . mapped class . equals ( mapped class ) ) { throw new invalid data access api usage exception ( str + mapped class + str + this . mapped class ) ; } } }	Set the class that each row should be mapped to.
@ suppress warnings ( str ) public r proceed ( ) throws throwable { try { return ( r ) method ( ) . invoke ( target , args ) ; } catch ( invocation target exception e ) { throw e . get target exception ( ) ; } }	Proceeds this method invocation.
public long stop ( ) { if ( is running ( ) ) { stop = system . nano time ( ) ; total += stop - start ; running = bool ; } return math . round ( total * get precision ( ) . value ) ; }	Stops to measure.
protected http client build client ( ) { http client builder builder = http client builder . create ( ) . use system properties ( ) . set connection manager ( conn manager ) ; if ( ! is blank ( username ) && ! is blank ( password ) ) { final uri uri = uri . create ( url ) ; final credentials provider creds provider = new basic credentials provider ( ) ; creds provider . set credentials ( new auth scope ( uri . get host ( ) , uri . get port ( ) ) , new username password credentials ( username , password ) ) ; builder = builder . set default credentials provider ( creds provider ) ; } return builder . build ( ) ; }	Setup authentication in httpclient.
private http uri request minter request ( ) { switch ( method . to upper case ( ) ) { case str : return new http get ( url ) ; case str : return new http put ( url ) ; default : return new http post ( url ) ; } }	Instantiate a request object based on the method variable.
protected string response to pid ( final string response text ) throws io { logger . debug ( str , response text ) ; if ( ! is blank ( regex ) ) { return response text . replace first ( regex , str ) ; } else if ( xpath != null ) { try { return xpath ( response text , xpath ) ; } catch ( parser configuration exception | sax | x e ) { throw new io ( e ) ; } } else { return response text ; } }	Remove unwanted text from the minter service response to produce the desired identifier.Override this method for processing more complex than a simple regex replacement.
private static string xpath ( final string xml , final x xpath ) throws parser configuration exception , sax , io , x { final document builder builder = document builder factory . new document builder ( ) ; final document doc = builder . parse ( new byte array input stream ( xml . get bytes ( ) ) ) ; return xpath . evaluate ( doc ) ; }	Extract the desired identifier value from an XML response using XPath.
@ timed @ override public string get ( ) { try { logger . debug ( str ) ; final http response resp = client . execute ( minter request ( ) ) ; return response to pid ( entity utils . to string ( resp . get entity ( ) ) ) ; } catch ( final io ex ) { logger . warn ( str , url , ex . get message ( ) ) ; throw new pid minting exception ( str , ex ) ; } catch ( final exception ex ) { logger . warn ( str , ex . get message ( ) ) ; throw new pid minting exception ( str , ex ) ; } }	Mint a unique identifier using an external HTTP API.
public static < t extends configuration > configuration binder < t > for class ( class < t > klass , binder binder ) { return new configuration binder < > ( klass , binder ) ; }	The starting point for using a ConfigurationBinder.
public void to instance ( config configuration ) { preconditions . check not null ( configuration , str ) ; if ( annotation class == null ) { binder . bind ( config class ) . to instance ( configuration ) ; } else { binder . bind ( config class ) . annotated with ( annotation class ) . to instance ( configuration ) ; } }	This method will bind the class to a particular instance.
public static filter pattern new instance ( enum set < dispatcher type > dispatcher types , boolean match after , iterable < string > patterns ) { return new filter pattern ( dispatcher types , match after , immutable list . copy of ( patterns ) ) ; }	Returns a new instance of FilterPattern, using the passed in arguments.
public t proceed ( ) throws throwable { try { return constructor ( ) . new instance ( args ) ; } catch ( invocation target exception e ) { throw e . get target exception ( ) ; } }	Proceeds this constructor invocation.
